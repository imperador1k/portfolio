"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_ani-cursor_dist_parser_js"],{

/***/ "(pages-dir-browser)/./node_modules/ani-cursor/dist/parser.js":
/*!************************************************!*\
  !*** ./node_modules/ani-cursor/dist/parser.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAni = void 0;\nvar riff_file_1 = __webpack_require__(/*! riff-file */ \"(pages-dir-browser)/./node_modules/riff-file/index.js\");\nvar byte_data_1 = __webpack_require__(/*! byte-data */ \"(pages-dir-browser)/./node_modules/byte-data/index.js\");\nvar DWORD = { bits: 32, be: false, signed: false, fp: false };\nfunction parseAni(arr) {\n    var riff = new riff_file_1.RIFFFile();\n    riff.setSignature(arr);\n    var signature = riff.signature;\n    if (signature.format !== \"ACON\") {\n        throw new Error(\"Expected format. Expected \\\"ACON\\\", got \\\"\" + signature.format + \"\\\"\");\n    }\n    // Helper function to get a chunk by chunkId and transform it if it's non-null.\n    function mapChunk(chunkId, mapper) {\n        var chunk = riff.findChunk(chunkId);\n        return chunk == null ? null : mapper(chunk);\n    }\n    function readImages(chunk, frameCount) {\n        return chunk.subChunks.slice(0, frameCount).map(function (c) {\n            if (c.chunkId !== \"icon\") {\n                throw new Error(\"Unexpected chunk type in fram: \" + c.chunkId);\n            }\n            return arr.slice(c.chunkData.start, c.chunkData.end);\n        });\n    }\n    var metadata = mapChunk(\"anih\", function (c) {\n        var words = byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);\n        return {\n            cbSize: words[0],\n            nFrames: words[1],\n            nSteps: words[2],\n            iWidth: words[3],\n            iHeight: words[4],\n            iBitCount: words[5],\n            nPlanes: words[6],\n            iDispRate: words[7],\n            bfAttributes: words[8],\n        };\n    });\n    if (metadata == null) {\n        throw new Error(\"Did not find anih\");\n    }\n    var rate = mapChunk(\"rate\", function (c) {\n        return byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);\n    });\n    // chunkIds are always four chars, hence the trailing space.\n    var seq = mapChunk(\"seq \", function (c) {\n        return byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);\n    });\n    var lists = riff.findChunk(\"LIST\", true);\n    var imageChunk = lists === null || lists === void 0 ? void 0 : lists.find(function (c) { return c.format === \"fram\"; });\n    if (imageChunk == null) {\n        throw new Error(\"Did not find fram LIST\");\n    }\n    var images = readImages(imageChunk, metadata.nFrames);\n    var title = null;\n    var artist = null;\n    var infoChunk = lists === null || lists === void 0 ? void 0 : lists.find(function (c) { return c.format === \"INFO\"; });\n    if (infoChunk != null) {\n        infoChunk.subChunks.forEach(function (c) {\n            switch (c.chunkId) {\n                case \"INAM\":\n                    title = byte_data_1.unpackString(arr, c.chunkData.start, c.chunkData.end);\n                    break;\n                case \"IART\":\n                    artist = byte_data_1.unpackString(arr, c.chunkData.start, c.chunkData.end);\n                    break;\n                case \"LIST\":\n                    // Some cursors with an artist of \"Created with Take ONE 3.5 (unregisterred version)\" seem to have their frames here for some reason?\n                    if (c.format === \"fram\") {\n                        images = readImages(c, metadata.nFrames);\n                    }\n                    break;\n                default:\n                // Unexpected subchunk\n            }\n        });\n    }\n    return { images: images, rate: rate, seq: seq, metadata: metadata, artist: artist, title: title };\n}\nexports.parseAni = parseAni;\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbmktY3Vyc29yL2Rpc3QvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBVztBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBVztBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RkFBNkYsNkJBQTZCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw2QkFBNkI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcYW5pLWN1cnNvclxcZGlzdFxccGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUFuaSA9IHZvaWQgMDtcbnZhciByaWZmX2ZpbGVfMSA9IHJlcXVpcmUoXCJyaWZmLWZpbGVcIik7XG52YXIgYnl0ZV9kYXRhXzEgPSByZXF1aXJlKFwiYnl0ZS1kYXRhXCIpO1xudmFyIERXT1JEID0geyBiaXRzOiAzMiwgYmU6IGZhbHNlLCBzaWduZWQ6IGZhbHNlLCBmcDogZmFsc2UgfTtcbmZ1bmN0aW9uIHBhcnNlQW5pKGFycikge1xuICAgIHZhciByaWZmID0gbmV3IHJpZmZfZmlsZV8xLlJJRkZGaWxlKCk7XG4gICAgcmlmZi5zZXRTaWduYXR1cmUoYXJyKTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcmlmZi5zaWduYXR1cmU7XG4gICAgaWYgKHNpZ25hdHVyZS5mb3JtYXQgIT09IFwiQUNPTlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGZvcm1hdC4gRXhwZWN0ZWQgXFxcIkFDT05cXFwiLCBnb3QgXFxcIlwiICsgc2lnbmF0dXJlLmZvcm1hdCArIFwiXFxcIlwiKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGNodW5rIGJ5IGNodW5rSWQgYW5kIHRyYW5zZm9ybSBpdCBpZiBpdCdzIG5vbi1udWxsLlxuICAgIGZ1bmN0aW9uIG1hcENodW5rKGNodW5rSWQsIG1hcHBlcikge1xuICAgICAgICB2YXIgY2h1bmsgPSByaWZmLmZpbmRDaHVuayhjaHVua0lkKTtcbiAgICAgICAgcmV0dXJuIGNodW5rID09IG51bGwgPyBudWxsIDogbWFwcGVyKGNodW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEltYWdlcyhjaHVuaywgZnJhbWVDb3VudCkge1xuICAgICAgICByZXR1cm4gY2h1bmsuc3ViQ2h1bmtzLnNsaWNlKDAsIGZyYW1lQ291bnQpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgaWYgKGMuY2h1bmtJZCAhPT0gXCJpY29uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNodW5rIHR5cGUgaW4gZnJhbTogXCIgKyBjLmNodW5rSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZShjLmNodW5rRGF0YS5zdGFydCwgYy5jaHVua0RhdGEuZW5kKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBtZXRhZGF0YSA9IG1hcENodW5rKFwiYW5paFwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgd29yZHMgPSBieXRlX2RhdGFfMS51bnBhY2tBcnJheShhcnIsIERXT1JELCBjLmNodW5rRGF0YS5zdGFydCwgYy5jaHVua0RhdGEuZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNiU2l6ZTogd29yZHNbMF0sXG4gICAgICAgICAgICBuRnJhbWVzOiB3b3Jkc1sxXSxcbiAgICAgICAgICAgIG5TdGVwczogd29yZHNbMl0sXG4gICAgICAgICAgICBpV2lkdGg6IHdvcmRzWzNdLFxuICAgICAgICAgICAgaUhlaWdodDogd29yZHNbNF0sXG4gICAgICAgICAgICBpQml0Q291bnQ6IHdvcmRzWzVdLFxuICAgICAgICAgICAgblBsYW5lczogd29yZHNbNl0sXG4gICAgICAgICAgICBpRGlzcFJhdGU6IHdvcmRzWzddLFxuICAgICAgICAgICAgYmZBdHRyaWJ1dGVzOiB3b3Jkc1s4XSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBpZiAobWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGZpbmQgYW5paFwiKTtcbiAgICB9XG4gICAgdmFyIHJhdGUgPSBtYXBDaHVuayhcInJhdGVcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVfZGF0YV8xLnVucGFja0FycmF5KGFyciwgRFdPUkQsIGMuY2h1bmtEYXRhLnN0YXJ0LCBjLmNodW5rRGF0YS5lbmQpO1xuICAgIH0pO1xuICAgIC8vIGNodW5rSWRzIGFyZSBhbHdheXMgZm91ciBjaGFycywgaGVuY2UgdGhlIHRyYWlsaW5nIHNwYWNlLlxuICAgIHZhciBzZXEgPSBtYXBDaHVuayhcInNlcSBcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVfZGF0YV8xLnVucGFja0FycmF5KGFyciwgRFdPUkQsIGMuY2h1bmtEYXRhLnN0YXJ0LCBjLmNodW5rRGF0YS5lbmQpO1xuICAgIH0pO1xuICAgIHZhciBsaXN0cyA9IHJpZmYuZmluZENodW5rKFwiTElTVFwiLCB0cnVlKTtcbiAgICB2YXIgaW1hZ2VDaHVuayA9IGxpc3RzID09PSBudWxsIHx8IGxpc3RzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0cy5maW5kKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmZvcm1hdCA9PT0gXCJmcmFtXCI7IH0pO1xuICAgIGlmIChpbWFnZUNodW5rID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIGZyYW0gTElTVFwiKTtcbiAgICB9XG4gICAgdmFyIGltYWdlcyA9IHJlYWRJbWFnZXMoaW1hZ2VDaHVuaywgbWV0YWRhdGEubkZyYW1lcyk7XG4gICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICB2YXIgYXJ0aXN0ID0gbnVsbDtcbiAgICB2YXIgaW5mb0NodW5rID0gbGlzdHMgPT09IG51bGwgfHwgbGlzdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RzLmZpbmQoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZm9ybWF0ID09PSBcIklORk9cIjsgfSk7XG4gICAgaWYgKGluZm9DaHVuayAhPSBudWxsKSB7XG4gICAgICAgIGluZm9DaHVuay5zdWJDaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgc3dpdGNoIChjLmNodW5rSWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiSU5BTVwiOlxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGJ5dGVfZGF0YV8xLnVucGFja1N0cmluZyhhcnIsIGMuY2h1bmtEYXRhLnN0YXJ0LCBjLmNodW5rRGF0YS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiSUFSVFwiOlxuICAgICAgICAgICAgICAgICAgICBhcnRpc3QgPSBieXRlX2RhdGFfMS51bnBhY2tTdHJpbmcoYXJyLCBjLmNodW5rRGF0YS5zdGFydCwgYy5jaHVua0RhdGEuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxJU1RcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBjdXJzb3JzIHdpdGggYW4gYXJ0aXN0IG9mIFwiQ3JlYXRlZCB3aXRoIFRha2UgT05FIDMuNSAodW5yZWdpc3RlcnJlZCB2ZXJzaW9uKVwiIHNlZW0gdG8gaGF2ZSB0aGVpciBmcmFtZXMgaGVyZSBmb3Igc29tZSByZWFzb24/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmZvcm1hdCA9PT0gXCJmcmFtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlcyA9IHJlYWRJbWFnZXMoYywgbWV0YWRhdGEubkZyYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHN1YmNodW5rXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBpbWFnZXM6IGltYWdlcywgcmF0ZTogcmF0ZSwgc2VxOiBzZXEsIG1ldGFkYXRhOiBtZXRhZGF0YSwgYXJ0aXN0OiBhcnRpc3QsIHRpdGxlOiB0aXRsZSB9O1xufVxuZXhwb3J0cy5wYXJzZUFuaSA9IHBhcnNlQW5pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ani-cursor/dist/parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/byte-data/index.js":
/*!*****************************************!*\
  !*** ./node_modules/byte-data/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   packArray: () => (/* binding */ packArray),\n/* harmony export */   packArrayTo: () => (/* binding */ packArrayTo),\n/* harmony export */   packString: () => (/* binding */ packString),\n/* harmony export */   packStringTo: () => (/* binding */ packStringTo),\n/* harmony export */   packTo: () => (/* binding */ packTo),\n/* harmony export */   unpack: () => (/* binding */ unpack),\n/* harmony export */   unpackArray: () => (/* binding */ unpackArray),\n/* harmony export */   unpackArrayTo: () => (/* binding */ unpackArrayTo),\n/* harmony export */   unpackString: () => (/* binding */ unpackString)\n/* harmony export */ });\n/* harmony import */ var endianness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! endianness */ \"(pages-dir-browser)/./node_modules/endianness/endianness.js\");\n/* harmony import */ var utf8_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utf8-buffer */ \"(pages-dir-browser)/./node_modules/utf8-buffer/index.js\");\n/* harmony import */ var _lib_int_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/int-parser */ \"(pages-dir-browser)/./node_modules/byte-data/lib/int-parser.js\");\n/* harmony import */ var ieee754_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ieee754-buffer */ \"(pages-dir-browser)/./node_modules/ieee754-buffer/index.js\");\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview JavaScript binary parser for any browser or environment.\r\n * @see https://github.com/rochars/byte-data\r\n */\r\n\r\n/** @module byte-data */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\r\nfunction unpackString(buffer, index=0, end=buffer.length) {\r\n  return (0,utf8_buffer__WEBPACK_IMPORTED_MODULE_1__.unpack)(buffer, index, end);\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\r\nfunction packString(str) {\r\n  /** @type {!Array<number>} */\r\n  let buffer = [];\r\n  (0,utf8_buffer__WEBPACK_IMPORTED_MODULE_1__.pack)(str, buffer, 0);\r\n  return buffer;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nfunction packStringTo(str, buffer, index=0) {\r\n  return (0,utf8_buffer__WEBPACK_IMPORTED_MODULE_1__.pack)(str, buffer, index);\r\n}\r\n\r\n// Numbers\r\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {RangeError} On overflow.\r\n * @throws {TypeError} If input is not valid.\r\n */\r\nfunction packArrayTo(values, theType, buffer, index=0, clamp=false) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let packer = getParser_(theType.bits, theType.fp, theType.signed, clamp);\r\n  /** @type {number} */\r\n  let offset = Math.ceil(theType.bits / 8);\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let start = index;\r\n  try {\r\n    for (let valuesLen = values.length; i < valuesLen; i++) {\r\n      index = packer.pack(buffer, values[i], index);\r\n    }\r\n    if (theType.be) {\r\n      (0,endianness__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(buffer, offset, start, index);\r\n    }\r\n  } catch (e) {\r\n    throwValueError_(e, values[i], i);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @param {boolean} [safe=false] If set to false, extra bytes in the end of\r\n *   the array are ignored and input buffers with insufficient bytes will\r\n *   write nothing to the output array. If safe is set to true the function\r\n *   will throw a 'Bad buffer length' error.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @throws {Error} If the type definition is not valid\r\n * @throws {RangeError} On overflow\r\n */\r\nfunction unpackArrayTo(\r\n    buffer, theType, output, start=0, end=buffer.length,\r\n    safe=false, clamp=false) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let packer = getParser_(theType.bits, theType.fp, theType.signed, clamp);\r\n  /** @type {number} */\r\n  let offset = Math.ceil(theType.bits / 8);\r\n  // getUnpackLen_ will either fix the length of the input buffer\r\n  // according to the byte offset of the type (on unsafe mode) or\r\n  // throw a Error if the input buffer has a bad length (on safe mode)\r\n  end = getUnpackLen_(buffer, start, end, offset, safe);\r\n  /** @type {number} */\r\n  let index = 0;\r\n  let j = start;\r\n  try {\r\n    if (theType.be) {\r\n      (0,endianness__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(buffer, offset, start, end);\r\n    }\r\n    for (; j < end; j += offset, index++) {\r\n      output[index] = packer.unpack(buffer, j);\r\n    }\r\n    if (theType.be) {\r\n      (0,endianness__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(buffer, offset, start, end);\r\n    }\r\n  } catch (e) {\r\n    throwValueError_(e, buffer.slice(j, j + offset), j);\r\n  }\r\n}\r\n\r\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {RangeError} On overflow.\r\n * @throws {TypeError} If input is not valid.\r\n */\r\nfunction packTo(value, theType, buffer, index=0, clamp=false) {\r\n  return packArrayTo([value], theType, buffer, index, clamp);\r\n}\r\n\r\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {RangeError} On overflow.\r\n * @throws {TypeError} If input is not valid.\r\n */\r\nfunction pack(value, theType, clamp=false) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  packTo(value, theType, output, 0, clamp);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Pack a array of numbers as a array of bytes.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {!Array<number>} The packed values.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {RangeError} On overflow.\r\n * @throws {TypeError} If input is not valid.\r\n */\r\nfunction packArray(values, theType, clamp=false) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  packArrayTo(values, theType, output, 0, clamp);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @param {boolean} [safe=false] If set to false, extra bytes in the end of\r\n *   the array are ignored and input buffers with insufficient bytes will\r\n *   output a empty array. If safe is set to true the function\r\n *   will throw a 'Bad buffer length' error.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid\r\n * @throws {RangeError} On overflow\r\n */\r\nfunction unpackArray(\r\n    buffer, theType, start=0, end=buffer.length, safe=false, clamp=false) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  unpackArrayTo(buffer, theType, output, start, end, safe, clamp);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @param {boolean} [clamp=false] True to clamp ints on overflow.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid\r\n * @throws {Error} On bad buffer length.\r\n * @throws {RangeError} On overflow\r\n */\r\nfunction unpack(buffer, theType, index=0, clamp=false) {\r\n  return unpackArray(\r\n    buffer, theType, index, index + Math.ceil(theType.bits / 8),\r\n    true, clamp)[0];\r\n}\r\n\r\n/**\r\n * Throw a error with information about the problem.\r\n * @param {!Object} err The Error object that is being raised.\r\n * @param {*} value The value that caused the error.\r\n * @param {number} index The index of the value that caused the error.\r\n * @throws {RangeError|TypeError|Error} A Error with a message.\r\n * @private\r\n */\r\nfunction throwValueError_(err, value, index) {\r\n  err.message = err.constructor.name +\r\n    ' at index ' + index + ': ' + value;\r\n  throw err;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers to a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @param {boolean} safe True for size-safe buffer reading.\r\n * @throws {Error} On bad buffer length, if safe.\r\n * @private\r\n */\r\nfunction getUnpackLen_(buffer, start, end, offset, safe) {\r\n  /** @type {number} */\r\n  let extra = (end - start) % offset;\r\n  if (safe && (extra || buffer.length < offset)) {\r\n    throw new Error('Bad buffer length');\r\n  }\r\n  return end - extra;\r\n}\r\n\r\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @param {boolean|undefined} clamp True to clamp ints on overflow, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\r\nfunction getParser_(bits, fp, signed, clamp) {\r\n  if (fp) {\r\n    validateFloatType(bits);\r\n  } else {\r\n    validateIntType(bits);\r\n  }\r\n  if (fp && bits === 16) {\r\n    return new ieee754_buffer__WEBPACK_IMPORTED_MODULE_3__.IEEE754Buffer(5, 11);\r\n  } else if (fp && bits == 32) {\r\n    return new ieee754_buffer__WEBPACK_IMPORTED_MODULE_3__.IEEE754Buffer(8, 23);\r\n  } else if(fp && bits == 64) {\r\n    return new ieee754_buffer__WEBPACK_IMPORTED_MODULE_3__.IEEE754Buffer(11, 52);\r\n  }\r\n  return new _lib_int_parser__WEBPACK_IMPORTED_MODULE_2__.IntParser(bits, signed, clamp);\r\n}\r\n\r\n/**\r\n * The type definition error message.\r\n * @type {string}\r\n * @private\r\n */\r\nconst TYPE_ERR = 'Unsupported type';\r\n\r\n/**\r\n * Validate the type definition of floating-point numbers.\r\n * @param {number} bits The number of bits.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateFloatType(bits) {\r\n  if (!bits || bits !== 16 && bits !== 32 && bits !== 64) {\r\n    throw new Error(TYPE_ERR + ': float, bits: ' + bits);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of integers.\r\n * @param {number} bits The number of bits.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateIntType(bits) {\r\n  if (!bits || bits < 1 || bits > 53) {\r\n    throw new Error(TYPE_ERR + ': int, bits: ' + bits);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ieXRlLWRhdGEvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvQztBQUNpQztBQUN4QjtBQUNFO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUCxTQUFTLG1EQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ087QUFDUCxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLEVBQUUsaURBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQLFNBQVMsaURBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksV0FBVztBQUN2QjtBQUNPO0FBQ1A7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQVU7QUFDaEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzREFBVTtBQUNoQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFVO0FBQ2hCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVyxTQUFTO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUCxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVyxTQUFTO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUCxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ087QUFDUDtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBYTtBQUM1QixJQUFJO0FBQ0osZUFBZSx5REFBYTtBQUM1QixJQUFJO0FBQ0osZUFBZSx5REFBYTtBQUM1QjtBQUNBLGFBQWEsc0RBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxieXRlLWRhdGFcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IFJhZmFlbCBkYSBTaWx2YSBSb2NoYS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEphdmFTY3JpcHQgYmluYXJ5IHBhcnNlciBmb3IgYW55IGJyb3dzZXIgb3IgZW52aXJvbm1lbnQuXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JvY2hhcnMvYnl0ZS1kYXRhXHJcbiAqL1xyXG5cclxuLyoqIEBtb2R1bGUgYnl0ZS1kYXRhICovXHJcblxyXG5pbXBvcnQgZW5kaWFubmVzcyBmcm9tICdlbmRpYW5uZXNzJztcclxuaW1wb3J0IHsgcGFjayBhcyBwYWNrVVRGOCwgdW5wYWNrIGFzIHVucGFja1VURjggfSBmcm9tICd1dGY4LWJ1ZmZlcic7XHJcbmltcG9ydCB7IEludFBhcnNlciB9IGZyb20gJy4vbGliL2ludC1wYXJzZXInO1xyXG5pbXBvcnQgeyBJRUVFNzU0QnVmZmVyIH0gZnJvbSAnaWVlZTc1NC1idWZmZXInO1xyXG5cclxuLyoqXHJcbiAqIFJlYWQgYSBzdHJpbmcgb2YgVVRGLTggY2hhcmFjdGVycyBmcm9tIGEgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7IShVaW50OEFycmF5fEFycmF5PG51bWJlcj4pfSBidWZmZXIgQSBieXRlIGJ1ZmZlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSBUaGUgYnVmZmVyIGluZGV4IHRvIHN0YXJ0IHJlYWRpbmcuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWJ1ZmZlci5sZW5ndGhdIFRoZSBpbmRleCB0byBzdG9wIHJlYWRpbmcsIG5vbiBpbmNsdXNpdmUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tTdHJpbmcoYnVmZmVyLCBpbmRleD0wLCBlbmQ9YnVmZmVyLmxlbmd0aCkge1xyXG4gIHJldHVybiB1bnBhY2tVVEY4KGJ1ZmZlciwgaW5kZXgsIGVuZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZSBhIHN0cmluZyBvZiBVVEYtOCBjaGFyYWN0ZXJzIGFzIGEgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBwYWNrLlxyXG4gKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gVGhlIFVURi04IHN0cmluZyBieXRlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYWNrU3RyaW5nKHN0cikge1xyXG4gIC8qKiBAdHlwZSB7IUFycmF5PG51bWJlcj59ICovXHJcbiAgbGV0IGJ1ZmZlciA9IFtdO1xyXG4gIHBhY2tVVEY4KHN0ciwgYnVmZmVyLCAwKTtcclxuICByZXR1cm4gYnVmZmVyO1xyXG59XHJcblxyXG4vKipcclxuICogV3JpdGUgYSBzdHJpbmcgb2YgVVRGLTggY2hhcmFjdGVycyB0byBhIGJ5dGUgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gcGFjay5cclxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBUaGUgb3V0cHV0IGJ1ZmZlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSBUaGUgYnVmZmVyIGluZGV4IHRvIHN0YXJ0IHdyaXRpbmcuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgaW5kZXggdG8gd3JpdGUgaW4gdGhlIGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYWNrU3RyaW5nVG8oc3RyLCBidWZmZXIsIGluZGV4PTApIHtcclxuICByZXR1cm4gcGFja1VURjgoc3RyLCBidWZmZXIsIGluZGV4KTtcclxufVxyXG5cclxuLy8gTnVtYmVyc1xyXG4vKipcclxuICogUGFjayBhIGFycmF5IG9mIG51bWJlcnMgdG8gYSBieXRlIGJ1ZmZlci5cclxuICogQWxsIG90aGVyIHBhY2tpbmcgZnVuY3Rpb25zIGFyZSBpbnRlcmZhY2VzIHRvIHRoaXMgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7IShBcnJheTxudW1iZXI+fFR5cGVkQXJyYXkpfSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBwYWNrLlxyXG4gKiBAcGFyYW0geyF7Yml0czpudW1iZXIsXHJcbiAqICAgZnA6IChib29sZWFufHVuZGVmaW5lZCksXHJcbiAqICAgc2lnbmVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxyXG4gKiAgIGJlOiAoYm9vbGVhbnx1bmRlZmluZWQpfX0gdGhlVHlwZSBUaGUgdHlwZSBkZWZpbml0aW9uLlxyXG4gKiBAcGFyYW0geyEoVWludDhBcnJheXxBcnJheTxudW1iZXI+KX0gYnVmZmVyIFRoZSBidWZmZXIgdG8gd3JpdGUgb24uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gVGhlIGJ1ZmZlciBpbmRleCB0byBzdGFydCB3cml0aW5nLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV0gVHJ1ZSB0byBjbGFtcCBpbnRzIG9uIG92ZXJmbG93LlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IGluZGV4IHRvIHdyaXRlLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHR5cGUgZGVmaW5pdGlvbiBpcyBub3QgdmFsaWQuXHJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IE9uIG92ZXJmbG93LlxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGlucHV0IGlzIG5vdCB2YWxpZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYWNrQXJyYXlUbyh2YWx1ZXMsIHRoZVR5cGUsIGJ1ZmZlciwgaW5kZXg9MCwgY2xhbXA9ZmFsc2UpIHtcclxuICB0aGVUeXBlID0gdGhlVHlwZSB8fCB7fTtcclxuICAvKiogQHR5cGUgeyFPYmplY3R9ICovXHJcbiAgbGV0IHBhY2tlciA9IGdldFBhcnNlcl8odGhlVHlwZS5iaXRzLCB0aGVUeXBlLmZwLCB0aGVUeXBlLnNpZ25lZCwgY2xhbXApO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIGxldCBvZmZzZXQgPSBNYXRoLmNlaWwodGhlVHlwZS5iaXRzIC8gOCk7XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgbGV0IGkgPSAwO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIGxldCBzdGFydCA9IGluZGV4O1xyXG4gIHRyeSB7XHJcbiAgICBmb3IgKGxldCB2YWx1ZXNMZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgdmFsdWVzTGVuOyBpKyspIHtcclxuICAgICAgaW5kZXggPSBwYWNrZXIucGFjayhidWZmZXIsIHZhbHVlc1tpXSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoZVR5cGUuYmUpIHtcclxuICAgICAgZW5kaWFubmVzcyhidWZmZXIsIG9mZnNldCwgc3RhcnQsIGluZGV4KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB0aHJvd1ZhbHVlRXJyb3JfKGUsIHZhbHVlc1tpXSwgaSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVucGFjayBhIGFycmF5IG9mIG51bWJlcnMgZnJvbSBhIGJ5dGUgYnVmZmVyIHRvIGEgYXJyYXkgb3IgYSB0eXBlZCBhcnJheS5cclxuICogQWxsIG90aGVyIHVucGFja2luZyBmdW5jdGlvbnMgYXJlIGludGVyZmFjZXMgdG8gdGhpcyBmdW5jdGlvbi5cclxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBUaGUgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7IXtiaXRzOm51bWJlcixcclxuICogICBmcDogKGJvb2xlYW58dW5kZWZpbmVkKSxcclxuICogICBzaWduZWQ6IChib29sZWFufHVuZGVmaW5lZCksXHJcbiAqICAgYmU6IChib29sZWFufHVuZGVmaW5lZCl9fSB0aGVUeXBlIFRoZSB0eXBlIGRlZmluaXRpb24uXHJcbiAqIEBwYXJhbSB7IShUeXBlZEFycmF5fEFycmF5PG51bWJlcj4pfSBvdXRwdXQgVGhlIG91dHB1dCBhcnJheSBvciB0eXBlZCBhcnJheS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgYnVmZmVyIGluZGV4IHRvIHN0YXJ0IHJlYWRpbmcuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWJ1ZmZlci5sZW5ndGhdIFRoZSBidWZmZXIgaW5kZXggdG8gc3RvcCByZWFkaW5nLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzYWZlPWZhbHNlXSBJZiBzZXQgdG8gZmFsc2UsIGV4dHJhIGJ5dGVzIGluIHRoZSBlbmQgb2ZcclxuICogICB0aGUgYXJyYXkgYXJlIGlnbm9yZWQgYW5kIGlucHV0IGJ1ZmZlcnMgd2l0aCBpbnN1ZmZpY2llbnQgYnl0ZXMgd2lsbFxyXG4gKiAgIHdyaXRlIG5vdGhpbmcgdG8gdGhlIG91dHB1dCBhcnJheS4gSWYgc2FmZSBpcyBzZXQgdG8gdHJ1ZSB0aGUgZnVuY3Rpb25cclxuICogICB3aWxsIHRocm93IGEgJ0JhZCBidWZmZXIgbGVuZ3RoJyBlcnJvci5cclxuICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdIFRydWUgdG8gY2xhbXAgaW50cyBvbiBvdmVyZmxvdy5cclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0eXBlIGRlZmluaXRpb24gaXMgbm90IHZhbGlkXHJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IE9uIG92ZXJmbG93XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrQXJyYXlUbyhcclxuICAgIGJ1ZmZlciwgdGhlVHlwZSwgb3V0cHV0LCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aCxcclxuICAgIHNhZmU9ZmFsc2UsIGNsYW1wPWZhbHNlKSB7XHJcbiAgdGhlVHlwZSA9IHRoZVR5cGUgfHwge307XHJcbiAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xyXG4gIGxldCBwYWNrZXIgPSBnZXRQYXJzZXJfKHRoZVR5cGUuYml0cywgdGhlVHlwZS5mcCwgdGhlVHlwZS5zaWduZWQsIGNsYW1wKTtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICBsZXQgb2Zmc2V0ID0gTWF0aC5jZWlsKHRoZVR5cGUuYml0cyAvIDgpO1xyXG4gIC8vIGdldFVucGFja0xlbl8gd2lsbCBlaXRoZXIgZml4IHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IGJ1ZmZlclxyXG4gIC8vIGFjY29yZGluZyB0byB0aGUgYnl0ZSBvZmZzZXQgb2YgdGhlIHR5cGUgKG9uIHVuc2FmZSBtb2RlKSBvclxyXG4gIC8vIHRocm93IGEgRXJyb3IgaWYgdGhlIGlucHV0IGJ1ZmZlciBoYXMgYSBiYWQgbGVuZ3RoIChvbiBzYWZlIG1vZGUpXHJcbiAgZW5kID0gZ2V0VW5wYWNrTGVuXyhidWZmZXIsIHN0YXJ0LCBlbmQsIG9mZnNldCwgc2FmZSk7XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgbGV0IGluZGV4ID0gMDtcclxuICBsZXQgaiA9IHN0YXJ0O1xyXG4gIHRyeSB7XHJcbiAgICBpZiAodGhlVHlwZS5iZSkge1xyXG4gICAgICBlbmRpYW5uZXNzKGJ1ZmZlciwgb2Zmc2V0LCBzdGFydCwgZW5kKTtcclxuICAgIH1cclxuICAgIGZvciAoOyBqIDwgZW5kOyBqICs9IG9mZnNldCwgaW5kZXgrKykge1xyXG4gICAgICBvdXRwdXRbaW5kZXhdID0gcGFja2VyLnVucGFjayhidWZmZXIsIGopO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoZVR5cGUuYmUpIHtcclxuICAgICAgZW5kaWFubmVzcyhidWZmZXIsIG9mZnNldCwgc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdGhyb3dWYWx1ZUVycm9yXyhlLCBidWZmZXIuc2xpY2UoaiwgaiArIG9mZnNldCksIGopO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhY2sgYSBudW1iZXIgdG8gYSBieXRlIGJ1ZmZlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIHshe2JpdHM6bnVtYmVyLFxyXG4gKiAgIGZwOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxyXG4gKiAgIHNpZ25lZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcclxuICogICBiZTogKGJvb2xlYW58dW5kZWZpbmVkKX19IHRoZVR5cGUgVGhlIHR5cGUgZGVmaW5pdGlvbi5cclxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBUaGUgYnl0ZSBidWZmZXIgdG8gd3JpdGUgb24uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gVGhlIGJ1ZmZlciBpbmRleCB0byB3cml0ZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdIFRydWUgdG8gY2xhbXAgaW50cyBvbiBvdmVyZmxvdy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBpbmRleCB0byB3cml0ZS5cclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0eXBlIGRlZmluaXRpb24gaXMgbm90IHZhbGlkLlxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBPbiBvdmVyZmxvdy5cclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBpbnB1dCBpcyBub3QgdmFsaWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFja1RvKHZhbHVlLCB0aGVUeXBlLCBidWZmZXIsIGluZGV4PTAsIGNsYW1wPWZhbHNlKSB7XHJcbiAgcmV0dXJuIHBhY2tBcnJheVRvKFt2YWx1ZV0sIHRoZVR5cGUsIGJ1ZmZlciwgaW5kZXgsIGNsYW1wKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhY2sgYSBudW1iZXIgYXMgYSBhcnJheSBvZiBieXRlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgdG8gcGFjay5cclxuICogQHBhcmFtIHshe2JpdHM6bnVtYmVyLFxyXG4gKiAgIGZwOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxyXG4gKiAgIHNpZ25lZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcclxuICogICBiZTogKGJvb2xlYW58dW5kZWZpbmVkKX19IHRoZVR5cGUgVGhlIHR5cGUgZGVmaW5pdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdIFRydWUgdG8gY2xhbXAgaW50cyBvbiBvdmVyZmxvdy5cclxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IFRoZSBwYWNrZWQgdmFsdWUuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdHlwZSBkZWZpbml0aW9uIGlzIG5vdCB2YWxpZC5cclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gT24gb3ZlcmZsb3cuXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgaW5wdXQgaXMgbm90IHZhbGlkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhY2sodmFsdWUsIHRoZVR5cGUsIGNsYW1wPWZhbHNlKSB7XHJcbiAgLyoqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn0gKi9cclxuICBsZXQgb3V0cHV0ID0gW107XHJcbiAgcGFja1RvKHZhbHVlLCB0aGVUeXBlLCBvdXRwdXQsIDAsIGNsYW1wKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKipcclxuICogUGFjayBhIGFycmF5IG9mIG51bWJlcnMgYXMgYSBhcnJheSBvZiBieXRlcy5cclxuICogQHBhcmFtIHshKEFycmF5PG51bWJlcj58VHlwZWRBcnJheSl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHBhY2suXHJcbiAqIEBwYXJhbSB7IXtiaXRzOm51bWJlcixcclxuICogICBmcDogKGJvb2xlYW58dW5kZWZpbmVkKSxcclxuICogICBzaWduZWQ6IChib29sZWFufHVuZGVmaW5lZCksXHJcbiAqICAgYmU6IChib29sZWFufHVuZGVmaW5lZCl9fSB0aGVUeXBlIFRoZSB0eXBlIGRlZmluaXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXSBUcnVlIHRvIGNsYW1wIGludHMgb24gb3ZlcmZsb3cuXHJcbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBUaGUgcGFja2VkIHZhbHVlcy5cclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0eXBlIGRlZmluaXRpb24gaXMgbm90IHZhbGlkLlxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBPbiBvdmVyZmxvdy5cclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBpbnB1dCBpcyBub3QgdmFsaWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFja0FycmF5KHZhbHVlcywgdGhlVHlwZSwgY2xhbXA9ZmFsc2UpIHtcclxuICAvKiogQHR5cGUgeyFBcnJheTxudW1iZXI+fSAqL1xyXG4gIGxldCBvdXRwdXQgPSBbXTtcclxuICBwYWNrQXJyYXlUbyh2YWx1ZXMsIHRoZVR5cGUsIG91dHB1dCwgMCwgY2xhbXApO1xyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbnBhY2sgYSBhcnJheSBvZiBudW1iZXJzIGZyb20gYSBieXRlIGJ1ZmZlci5cclxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBUaGUgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7IXtiaXRzOm51bWJlcixcclxuICogICBmcDogKGJvb2xlYW58dW5kZWZpbmVkKSxcclxuICogICBzaWduZWQ6IChib29sZWFufHVuZGVmaW5lZCksXHJcbiAqICAgYmU6IChib29sZWFufHVuZGVmaW5lZCl9fSB0aGVUeXBlIFRoZSB0eXBlIGRlZmluaXRpb24uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIGJ1ZmZlciBpbmRleCB0byBzdGFydCByZWFkaW5nLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1idWZmZXIubGVuZ3RoXSBUaGUgYnVmZmVyIGluZGV4IHRvIHN0b3AgcmVhZGluZy5cclxuICogQHBhcmFtIHtib29sZWFufSBbc2FmZT1mYWxzZV0gSWYgc2V0IHRvIGZhbHNlLCBleHRyYSBieXRlcyBpbiB0aGUgZW5kIG9mXHJcbiAqICAgdGhlIGFycmF5IGFyZSBpZ25vcmVkIGFuZCBpbnB1dCBidWZmZXJzIHdpdGggaW5zdWZmaWNpZW50IGJ5dGVzIHdpbGxcclxuICogICBvdXRwdXQgYSBlbXB0eSBhcnJheS4gSWYgc2FmZSBpcyBzZXQgdG8gdHJ1ZSB0aGUgZnVuY3Rpb25cclxuICogICB3aWxsIHRocm93IGEgJ0JhZCBidWZmZXIgbGVuZ3RoJyBlcnJvci5cclxuICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdIFRydWUgdG8gY2xhbXAgaW50cyBvbiBvdmVyZmxvdy5cclxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdHlwZSBkZWZpbml0aW9uIGlzIG5vdCB2YWxpZFxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBPbiBvdmVyZmxvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVucGFja0FycmF5KFxyXG4gICAgYnVmZmVyLCB0aGVUeXBlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aCwgc2FmZT1mYWxzZSwgY2xhbXA9ZmFsc2UpIHtcclxuICAvKiogQHR5cGUgeyFBcnJheTxudW1iZXI+fSAqL1xyXG4gIGxldCBvdXRwdXQgPSBbXTtcclxuICB1bnBhY2tBcnJheVRvKGJ1ZmZlciwgdGhlVHlwZSwgb3V0cHV0LCBzdGFydCwgZW5kLCBzYWZlLCBjbGFtcCk7XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVucGFjayBhIG51bWJlciBmcm9tIGEgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7IShVaW50OEFycmF5fEFycmF5PG51bWJlcj4pfSBidWZmZXIgVGhlIGJ5dGUgYnVmZmVyLlxyXG4gKiBAcGFyYW0geyF7Yml0czpudW1iZXIsXHJcbiAqICAgZnA6IChib29sZWFufHVuZGVmaW5lZCksXHJcbiAqICAgc2lnbmVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxyXG4gKiAgIGJlOiAoYm9vbGVhbnx1bmRlZmluZWQpfX0gdGhlVHlwZSBUaGUgdHlwZSBkZWZpbml0aW9uLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIFRoZSBidWZmZXIgaW5kZXggdG8gcmVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdIFRydWUgdG8gY2xhbXAgaW50cyBvbiBvdmVyZmxvdy5cclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHR5cGUgZGVmaW5pdGlvbiBpcyBub3QgdmFsaWRcclxuICogQHRocm93cyB7RXJyb3J9IE9uIGJhZCBidWZmZXIgbGVuZ3RoLlxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBPbiBvdmVyZmxvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVucGFjayhidWZmZXIsIHRoZVR5cGUsIGluZGV4PTAsIGNsYW1wPWZhbHNlKSB7XHJcbiAgcmV0dXJuIHVucGFja0FycmF5KFxyXG4gICAgYnVmZmVyLCB0aGVUeXBlLCBpbmRleCwgaW5kZXggKyBNYXRoLmNlaWwodGhlVHlwZS5iaXRzIC8gOCksXHJcbiAgICB0cnVlLCBjbGFtcClbMF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaHJvdyBhIGVycm9yIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb2JsZW0uXHJcbiAqIEBwYXJhbSB7IU9iamVjdH0gZXJyIFRoZSBFcnJvciBvYmplY3QgdGhhdCBpcyBiZWluZyByYWlzZWQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci5cclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfFR5cGVFcnJvcnxFcnJvcn0gQSBFcnJvciB3aXRoIGEgbWVzc2FnZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRocm93VmFsdWVFcnJvcl8oZXJyLCB2YWx1ZSwgaW5kZXgpIHtcclxuICBlcnIubWVzc2FnZSA9IGVyci5jb25zdHJ1Y3Rvci5uYW1lICtcclxuICAgICcgYXQgaW5kZXggJyArIGluZGV4ICsgJzogJyArIHZhbHVlO1xyXG4gIHRocm93IGVycjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVucGFjayBhIGFycmF5IG9mIG51bWJlcnMgdG8gYSB0eXBlZCBhcnJheS5cclxuICogQWxsIG90aGVyIHVucGFja2luZyBmdW5jdGlvbnMgYXJlIGludGVyZmFjZXMgdG8gdGhpcyBmdW5jdGlvbi5cclxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBUaGUgYnl0ZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgYnVmZmVyIGluZGV4IHRvIHN0YXJ0IHJlYWRpbmcuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGJ1ZmZlciBpbmRleCB0byBzdG9wIHJlYWRpbmcuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG51bWJlciBvZiBieXRlcyB1c2VkIGJ5IHRoZSB0eXBlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNhZmUgVHJ1ZSBmb3Igc2l6ZS1zYWZlIGJ1ZmZlciByZWFkaW5nLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gT24gYmFkIGJ1ZmZlciBsZW5ndGgsIGlmIHNhZmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVbnBhY2tMZW5fKGJ1ZmZlciwgc3RhcnQsIGVuZCwgb2Zmc2V0LCBzYWZlKSB7XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgbGV0IGV4dHJhID0gKGVuZCAtIHN0YXJ0KSAlIG9mZnNldDtcclxuICBpZiAoc2FmZSAmJiAoZXh0cmEgfHwgYnVmZmVyLmxlbmd0aCA8IG9mZnNldCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmFkIGJ1ZmZlciBsZW5ndGgnKTtcclxuICB9XHJcbiAgcmV0dXJuIGVuZCAtIGV4dHJhO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgcGFyc2VyIGZvciBpbnQsIHVpbnQgb3IgZnAgbnVtYmVycy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHMgVGhlIG51bWJlciBvZiBiaXRzLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBmcCBUcnVlIGZvciBmcCBudW1iZXJzLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHNpZ25lZCBUcnVlIGZvciBzaWduZWQgaW50cywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBjbGFtcCBUcnVlIHRvIGNsYW1wIGludHMgb24gb3ZlcmZsb3csIGZhbHNlIG90aGVyd2lzZS5cclxuICogQHJldHVybiB7IU9iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFBhcnNlcl8oYml0cywgZnAsIHNpZ25lZCwgY2xhbXApIHtcclxuICBpZiAoZnApIHtcclxuICAgIHZhbGlkYXRlRmxvYXRUeXBlKGJpdHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWxpZGF0ZUludFR5cGUoYml0cyk7XHJcbiAgfVxyXG4gIGlmIChmcCAmJiBiaXRzID09PSAxNikge1xyXG4gICAgcmV0dXJuIG5ldyBJRUVFNzU0QnVmZmVyKDUsIDExKTtcclxuICB9IGVsc2UgaWYgKGZwICYmIGJpdHMgPT0gMzIpIHtcclxuICAgIHJldHVybiBuZXcgSUVFRTc1NEJ1ZmZlcig4LCAyMyk7XHJcbiAgfSBlbHNlIGlmKGZwICYmIGJpdHMgPT0gNjQpIHtcclxuICAgIHJldHVybiBuZXcgSUVFRTc1NEJ1ZmZlcigxMSwgNTIpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEludFBhcnNlcihiaXRzLCBzaWduZWQsIGNsYW1wKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSB0eXBlIGRlZmluaXRpb24gZXJyb3IgbWVzc2FnZS5cclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IFRZUEVfRVJSID0gJ1Vuc3VwcG9ydGVkIHR5cGUnO1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoZSB0eXBlIGRlZmluaXRpb24gb2YgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHMgVGhlIG51bWJlciBvZiBiaXRzLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHR5cGUgZGVmaW5pdGlvbiBpcyBub3QgdmFsaWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUZsb2F0VHlwZShiaXRzKSB7XHJcbiAgaWYgKCFiaXRzIHx8IGJpdHMgIT09IDE2ICYmIGJpdHMgIT09IDMyICYmIGJpdHMgIT09IDY0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoVFlQRV9FUlIgKyAnOiBmbG9hdCwgYml0czogJyArIGJpdHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoZSB0eXBlIGRlZmluaXRpb24gb2YgaW50ZWdlcnMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzIFRoZSBudW1iZXIgb2YgYml0cy5cclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0eXBlIGRlZmluaXRpb24gaXMgbm90IHZhbGlkLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJbnRUeXBlKGJpdHMpIHtcclxuICBpZiAoIWJpdHMgfHwgYml0cyA8IDEgfHwgYml0cyA+IDUzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoVFlQRV9FUlIgKyAnOiBpbnQsIGJpdHM6ICcgKyBiaXRzKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/byte-data/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/byte-data/lib/int-parser.js":
/*!**************************************************!*\
  !*** ./node_modules/byte-data/lib/int-parser.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntParser: () => (/* binding */ IntParser)\n/* harmony export */ });\n/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n */\r\n\r\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\r\nclass IntParser {\r\n  \r\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   * @param {boolean} [clamp=false] True to clamp on overflow.\r\n   */\r\n  constructor(bits, signed=false, clamp=false) {\r\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bytes = bits < 8 ? 1 : Math.ceil(bits / 8);\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.max = Math.pow(2, bits) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.min = 0;\r\n    /** @type {number} */\r\n    let r = 8 - ((((bits - 1) | 7) + 1) - bits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.lastByteMask_ = Math.pow(2, r > 0 ? r : 8) - 1;\r\n    /**\r\n     * @type {Function}\r\n     * @protected\r\n     */\r\n    this.unpack = this.unpackUnsigned_;\r\n    if (signed) {\r\n      this.max = Math.pow(2, bits) / 2 - 1;\r\n      this.min = -this.max - 1;\r\n      this.unpack = this.unpackSigned_;\r\n    }\r\n    if (clamp) {\r\n      this.overflow_ = this.overflowClamp_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  pack(buffer, num, index=0) {\r\n    if (num !== num || num.constructor != Number) {\r\n      throw new TypeError();\r\n    }\r\n    num = this.overflow_(num);\r\n    buffer[index] = (num < 0 ? num + Math.pow(2, this.bits) : num) & 255;\r\n    index++;\r\n    for (let i = 2, len = this.bytes; i < len; i++) {\r\n      buffer[index] = Math.floor(num / Math.pow(2, ((i - 1) * 8))) & 255;\r\n      index++;\r\n    }\r\n    if (this.bits > 8) {\r\n      buffer[index] = Math.floor(\r\n        num / Math.pow(2, ((this.bytes - 1) * 8))) & this.lastByteMask_;\r\n      index++;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   */\r\n  unpack_(buffer, index=0) {\r\n    /** @type {number} */\r\n    let num = 0;\r\n    for(let x = 0; x < this.bytes; x++) {\r\n      num += buffer[index + x] * Math.pow(256, x);\r\n    }\r\n    return num;\r\n  }\r\n\r\n  unpackUnsigned_(buffer, index=0) {\r\n    return this.overflow_(this.unpack_(buffer, index));\r\n  }\r\n\r\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   */\r\n  unpackSigned_(buffer, index=0) {\r\n    return this.overflow_(this.sign_(this.unpack_(buffer, index)));\r\n  }\r\n\r\n  /**\r\n   * Truncate values in case of overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  overflow_(num) {\r\n    if (num > this.max || num < this.min) {\r\n      throw new RangeError();\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Truncate values in case of overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  overflowClamp_(num) {\r\n    if (num > this.max) {\r\n      return this.max;\r\n    } else if (num < this.min) {\r\n      return this.min;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ieXRlLWRhdGEvbGliL2ludC1wYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcYnl0ZS1kYXRhXFxsaWJcXGludC1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggUmFmYWVsIGRhIFNpbHZhIFJvY2hhLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcclxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxyXG4gKiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgRW5jb2RlIGFuZCBkZWNvZGUgaW50IG51bWJlcnMgdG8gYW5kIGZyb20gYnl0ZSBidWZmZXJzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2NoYXJzL2J5dGUtZGF0YVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRvIHdyaXRlIGFuZCByZWFkIGludGVnZXIgbnVtYmVycyB0byBhbmQgZnJvbSBieXRlIGJ1ZmZlcnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW50UGFyc2VyIHtcclxuICBcclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdXNlZCBieSB0aGUgaW50ZWdlci5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWduZWQ9ZmFsc2VdIFRydWUgZm9yIHNpZ25lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXSBUcnVlIHRvIGNsYW1wIG9uIG92ZXJmbG93LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGJpdHMsIHNpZ25lZD1mYWxzZSwgY2xhbXA9ZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBiaXRzIHVzZWQgYnkgb25lIG51bWJlci5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYml0cyA9IGJpdHM7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgdXNlZCBieSBvbmUgbnVtYmVyLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ieXRlcyA9IGJpdHMgPCA4ID8gMSA6IE1hdGguY2VpbChiaXRzIC8gOCk7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4ID0gTWF0aC5wb3coMiwgYml0cykgLSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pbiA9IDA7XHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIGxldCByID0gOCAtICgoKChiaXRzIC0gMSkgfCA3KSArIDEpIC0gYml0cyk7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RCeXRlTWFza18gPSBNYXRoLnBvdygyLCByID4gMCA/IHIgOiA4KSAtIDE7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgdGhpcy51bnBhY2sgPSB0aGlzLnVucGFja1Vuc2lnbmVkXztcclxuICAgIGlmIChzaWduZWQpIHtcclxuICAgICAgdGhpcy5tYXggPSBNYXRoLnBvdygyLCBiaXRzKSAvIDIgLSAxO1xyXG4gICAgICB0aGlzLm1pbiA9IC10aGlzLm1heCAtIDE7XHJcbiAgICAgIHRoaXMudW5wYWNrID0gdGhpcy51bnBhY2tTaWduZWRfO1xyXG4gICAgfVxyXG4gICAgaWYgKGNsYW1wKSB7XHJcbiAgICAgIHRoaXMub3ZlcmZsb3dfID0gdGhpcy5vdmVyZmxvd0NsYW1wXztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIG9uZSB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgYnl0ZSBidWZmZXIuXHJcbiAgICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBBbiBhcnJheSBvZiBieXRlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIuIE92ZXJmbG93cyBhcmUgdHJ1bmNhdGVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gVGhlIGluZGV4IGJlaW5nIHdyaXR0ZW4gaW4gdGhlIGJ5dGUgYnVmZmVyLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgaW5kZXggdG8gd3JpdGUgb24gdGhlIGJ5dGUgYnVmZmVyLlxyXG4gICAqL1xyXG4gIHBhY2soYnVmZmVyLCBudW0sIGluZGV4PTApIHtcclxuICAgIGlmIChudW0gIT09IG51bSB8fCBudW0uY29uc3RydWN0b3IgIT0gTnVtYmVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgIH1cclxuICAgIG51bSA9IHRoaXMub3ZlcmZsb3dfKG51bSk7XHJcbiAgICBidWZmZXJbaW5kZXhdID0gKG51bSA8IDAgPyBudW0gKyBNYXRoLnBvdygyLCB0aGlzLmJpdHMpIDogbnVtKSAmIDI1NTtcclxuICAgIGluZGV4Kys7XHJcbiAgICBmb3IgKGxldCBpID0gMiwgbGVuID0gdGhpcy5ieXRlczsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGJ1ZmZlcltpbmRleF0gPSBNYXRoLmZsb29yKG51bSAvIE1hdGgucG93KDIsICgoaSAtIDEpICogOCkpKSAmIDI1NTtcclxuICAgICAgaW5kZXgrKztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmJpdHMgPiA4KSB7XHJcbiAgICAgIGJ1ZmZlcltpbmRleF0gPSBNYXRoLmZsb29yKFxyXG4gICAgICAgIG51bSAvIE1hdGgucG93KDIsICgodGhpcy5ieXRlcyAtIDEpICogOCkpKSAmIHRoaXMubGFzdEJ5dGVNYXNrXztcclxuICAgICAgaW5kZXgrKztcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgb25lIHVuc2lnbmVkIGludGVnZXIgZnJvbSBhIGJ5dGUgYnVmZmVyLlxyXG4gICAqIERvZXMgbm90IGNoZWNrIGZvciBvdmVyZmxvd3MuXHJcbiAgICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXk8bnVtYmVyPil9IGJ1ZmZlciBBbiBhcnJheSBvZiBieXRlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIFRoZSBpbmRleCB0byByZWFkLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICB1bnBhY2tfKGJ1ZmZlciwgaW5kZXg9MCkge1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBsZXQgbnVtID0gMDtcclxuICAgIGZvcihsZXQgeCA9IDA7IHggPCB0aGlzLmJ5dGVzOyB4KyspIHtcclxuICAgICAgbnVtICs9IGJ1ZmZlcltpbmRleCArIHhdICogTWF0aC5wb3coMjU2LCB4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBudW07XHJcbiAgfVxyXG5cclxuICB1bnBhY2tVbnNpZ25lZF8oYnVmZmVyLCBpbmRleD0wKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vdmVyZmxvd18odGhpcy51bnBhY2tfKGJ1ZmZlciwgaW5kZXgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgb25lIHR3bydzIGNvbXBsZW1lbnQgc2lnbmVkIGludGVnZXIgZnJvbSBhIGJ5dGUgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSB7IShVaW50OEFycmF5fEFycmF5PG51bWJlcj4pfSBidWZmZXIgQW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSBUaGUgaW5kZXggdG8gcmVhZC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgdW5wYWNrU2lnbmVkXyhidWZmZXIsIGluZGV4PTApIHtcclxuICAgIHJldHVybiB0aGlzLm92ZXJmbG93Xyh0aGlzLnNpZ25fKHRoaXMudW5wYWNrXyhidWZmZXIsIGluZGV4KSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJ1bmNhdGUgdmFsdWVzIGluIGNhc2Ugb2Ygb3ZlcmZsb3cuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgb3ZlcmZsb3dfKG51bSkge1xyXG4gICAgaWYgKG51bSA+IHRoaXMubWF4IHx8IG51bSA8IHRoaXMubWluKSB7XHJcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJ1bmNhdGUgdmFsdWVzIGluIGNhc2Ugb2Ygb3ZlcmZsb3cuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgb3ZlcmZsb3dDbGFtcF8obnVtKSB7XHJcbiAgICBpZiAobnVtID4gdGhpcy5tYXgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWF4O1xyXG4gICAgfSBlbHNlIGlmIChudW0gPCB0aGlzLm1pbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5taW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2lnbiBhIG51bWJlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc2lnbl8obnVtKSB7XHJcbiAgICBpZiAobnVtID4gdGhpcy5tYXgpIHtcclxuICAgICAgbnVtIC09ICh0aGlzLm1heCAqIDIpICsgMjtcclxuICAgIH1cclxuICAgIHJldHVybiBudW07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/byte-data/lib/int-parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/endianness/endianness.js":
/*!***********************************************!*\
  !*** ./node_modules/endianness/endianness.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ endianness)\n/* harmony export */ });\n/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A function to swap endianness in byte buffers.\r\n * @see https://github.com/rochars/endianness\r\n */\r\n\r\n/** @module endianness */\r\n\r\n/**\r\n * Swap the byte ordering in a buffer. The buffer is modified in place.\r\n * @param {!Array|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number=} start The start index. Assumes 0.\r\n * @param {number=} end The end index. Assumes the buffer length.\r\n * @throws {Error} If the buffer length is not valid.\r\n */\r\nfunction endianness(bytes, offset, start=0, end=bytes.length) {\r\n  if (end % offset) {\r\n    throw new Error(\"Bad buffer length.\");\r\n  }\r\n  for (let index = start; index < end; index += offset) {\r\n    swap(bytes, offset, index);\r\n  }\r\n}\r\n\r\n/**\r\n * Swap the byte order of a value in a buffer. The buffer is modified in place.\r\n * @param {!Array|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number} index The start index.\r\n * @private\r\n */\r\nfunction swap(bytes, offset, index) {\r\n  offset--;\r\n  for(let x = 0; x < offset; x++) {\r\n    /** @type {*} */\r\n    let theByte = bytes[index + x];\r\n    bytes[index + x] = bytes[index + offset];\r\n    bytes[index + offset] = theByte;\r\n    offset--;\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmRpYW5uZXNzL2VuZGlhbm5lc3MuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxlbmRpYW5uZXNzXFxlbmRpYW5uZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFJhZmFlbCBkYSBTaWx2YSBSb2NoYS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEEgZnVuY3Rpb24gdG8gc3dhcCBlbmRpYW5uZXNzIGluIGJ5dGUgYnVmZmVycy5cclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcm9jaGFycy9lbmRpYW5uZXNzXHJcbiAqL1xyXG5cclxuLyoqIEBtb2R1bGUgZW5kaWFubmVzcyAqL1xyXG5cclxuLyoqXHJcbiAqIFN3YXAgdGhlIGJ5dGUgb3JkZXJpbmcgaW4gYSBidWZmZXIuIFRoZSBidWZmZXIgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXHJcbiAqIEBwYXJhbSB7IUFycmF5fCFVaW50OEFycmF5fSBieXRlcyBUaGUgYnl0ZXMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0IFRoZSBzdGFydCBpbmRleC4gQXNzdW1lcyAwLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IGVuZCBUaGUgZW5kIGluZGV4LiBBc3N1bWVzIHRoZSBidWZmZXIgbGVuZ3RoLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJ1ZmZlciBsZW5ndGggaXMgbm90IHZhbGlkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kaWFubmVzcyhieXRlcywgb2Zmc2V0LCBzdGFydD0wLCBlbmQ9Ynl0ZXMubGVuZ3RoKSB7XHJcbiAgaWYgKGVuZCAlIG9mZnNldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGJ1ZmZlciBsZW5ndGguXCIpO1xyXG4gIH1cclxuICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0OyBpbmRleCA8IGVuZDsgaW5kZXggKz0gb2Zmc2V0KSB7XHJcbiAgICBzd2FwKGJ5dGVzLCBvZmZzZXQsIGluZGV4KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTd2FwIHRoZSBieXRlIG9yZGVyIG9mIGEgdmFsdWUgaW4gYSBidWZmZXIuIFRoZSBidWZmZXIgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXHJcbiAqIEBwYXJhbSB7IUFycmF5fCFVaW50OEFycmF5fSBieXRlcyBUaGUgYnl0ZXMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHN0YXJ0IGluZGV4LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3dhcChieXRlcywgb2Zmc2V0LCBpbmRleCkge1xyXG4gIG9mZnNldC0tO1xyXG4gIGZvcihsZXQgeCA9IDA7IHggPCBvZmZzZXQ7IHgrKykge1xyXG4gICAgLyoqIEB0eXBlIHsqfSAqL1xyXG4gICAgbGV0IHRoZUJ5dGUgPSBieXRlc1tpbmRleCArIHhdO1xyXG4gICAgYnl0ZXNbaW5kZXggKyB4XSA9IGJ5dGVzW2luZGV4ICsgb2Zmc2V0XTtcclxuICAgIGJ5dGVzW2luZGV4ICsgb2Zmc2V0XSA9IHRoZUJ5dGU7XHJcbiAgICBvZmZzZXQtLTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/endianness/endianness.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ieee754-buffer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ieee754-buffer/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IEEE754Buffer: () => (/* binding */ IEEE754Buffer)\n/* harmony export */ });\n/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/ieee754-buffer\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\r\n\r\n/** \r\n * @module ieee754-buffer\r\n */\r\n\r\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\r\nclass IEEE754Buffer {\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\r\n  constructor(ebits, fbits) {\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebits = ebits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbits = fbits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bias = (1 << (ebits - 1)) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.numBytes = Math.ceil((ebits + fbits) / 8);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.biasP2 = Math.pow(2, this.bias + 1);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebitsFbits = (ebits + fbits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbias = Math.pow(2, -(8 * this.numBytes - 1 - ebits));\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   * @throws {TypeError} If input is not a number.\r\n   */\r\n  pack(buffer, num, index) {\r\n    // Only numbers can be packed\r\n    if (typeof num != 'number') {\r\n      throw new TypeError();\r\n    }\r\n    // Round overflows\r\n    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {\r\n      num = num < 0 ? -Infinity : Infinity;\r\n    }\r\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\r\n    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;\r\n    num = Math.abs(num);\r\n    /** @type {number} */\r\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\r\n    /** @type {number} */\r\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\r\n    // NaN\r\n    if (num !== num) {\r\n      fraction = Math.pow(2, this.fbits - 1);\r\n      exp = (1 << this.ebits) - 1;\r\n    // Number\r\n    } else if (num !== 0) {\r\n      if (num >= Math.pow(2, 1 - this.bias)) {\r\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\r\n          exp = exp + 1;\r\n          fraction = 1;\r\n        }\r\n        // Overflow\r\n        if (exp > this.bias) {\r\n          exp = (1 << this.ebits) - 1;\r\n          fraction = 0;\r\n        } else {\r\n          exp = exp + this.bias;\r\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\r\n        }\r\n      } else {\r\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\r\n        exp = 0;\r\n      } \r\n    }\r\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\r\n  }\r\n\r\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\r\n  unpack(buffer, index) {\r\n    /** @type {number} */\r\n    let eMax = (1 << this.ebits) - 1;\r\n    /** @type {number} */\r\n    let significand;\r\n    /** @type {string} */\r\n    let leftBits = \"\";\r\n    for (let i = this.numBytes - 1; i >= 0 ; i--) {\r\n      /** @type {string} */\r\n      let t = buffer[i + index].toString(2);\r\n      leftBits += \"00000000\".substring(t.length) + t;\r\n    }\r\n    /** @type {number} */\r\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\r\n    leftBits = leftBits.substring(1);\r\n    /** @type {number} */\r\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\r\n    leftBits = leftBits.substring(this.ebits);\r\n    if (exponent == eMax) {\r\n      if (parseInt(leftBits, 2) !== 0) {\r\n        return NaN;\r\n      }\r\n      return sign * Infinity;  \r\n    } else if (exponent === 0) {\r\n      exponent += 1;\r\n      significand = parseInt(leftBits, 2);\r\n    } else {\r\n      significand = parseInt(\"1\" + leftBits, 2);\r\n    }\r\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  packFloatBits_(buffer, index, sign, exp, fraction) {\r\n    /** @type {!Array<number>} */\r\n    let bits = [];\r\n    // the sign\r\n    bits.push(sign);\r\n    // the exponent\r\n    for (let i = this.ebits; i > 0; i -= 1) {\r\n      bits[i] = (exp % 2 ? 1 : 0);\r\n      exp = Math.floor(exp / 2);\r\n    }\r\n    // the fraction\r\n    let len = bits.length;\r\n    for (let i = this.fbits; i > 0; i -= 1) {\r\n      bits[len + i] = (fraction % 2 ? 1 : 0);\r\n      fraction = Math.floor(fraction / 2);\r\n    }\r\n    // pack as bytes\r\n    /** @type {string} */\r\n    let str = bits.join('');\r\n    /** @type {number} */\r\n    let numBytes = this.numBytes + index - 1;\r\n    /** @type {number} */\r\n    let k = index;\r\n    while (numBytes >= index) {\r\n      buffer[numBytes] = parseInt(str.substring(0, 8), 2);\r\n      str = str.substring(8);\r\n      numBytes--;\r\n      k++;\r\n    }\r\n    return k;\r\n  }\r\n}\r\n\r\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction roundToEven(n) {\r\n  /** @type {number} */\r\n  let w = Math.floor(n);\r\n  let f = n - w;\r\n  if (f < 0.5) {\r\n    return w;\r\n  }\r\n  if (f > 0.5) {\r\n    return w + 1;\r\n  }\r\n  return w % 2 ? w + 1 : w;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0LWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0MsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcaWVlZTc1NC1idWZmZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDE5IFJhZmFlbCBkYSBTaWx2YSBSb2NoYS5cclxuICogQ29weXJpZ2h0IChjKSAyMDEzIERlTkEgQ28uLCBMdGQuXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCwgTGluZGVuIFJlc2VhcmNoLCBJbmNcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEVuY29kZSBhbmQgZGVjb2RlIElFRUUgNzU0IGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JvY2hhcnMvaWVlZTc1NC1idWZmZXJcclxuICogQHNlZSBodHRwczovL2JpdGJ1Y2tldC5vcmcvbGluZGVubGFiL2xsc2QvcmF3LzdkMjY0NmNkM2Y5YjRjODA2ZTczYWViYzRiMzJiZDgxZTQwNDdmZGMvanMvdHlwZWRhcnJheS5qc1xyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXp1aG8vaWVlZTc1NC5qcy9ibG9iL21hc3Rlci9pZWVlNzU0LmpzXHJcbiAqL1xyXG5cclxuLyoqIFxyXG4gKiBAbW9kdWxlIGllZWU3NTQtYnVmZmVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdG8gZW5jb2RlIGFuZCBkZWNvZGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJRUVFNzU0QnVmZmVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUGFjayBhIElFRUUgNzU0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZWJpdHMgVGhlIGV4cG9uZW50IGJpdHMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZiaXRzIFRoZSBmcmFjdGlvbiBiaXRzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGViaXRzLCBmYml0cykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5lYml0cyA9IGViaXRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5mYml0cyA9IGZiaXRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5iaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubnVtQnl0ZXMgPSBNYXRoLmNlaWwoKGViaXRzICsgZmJpdHMpIC8gOCk7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJpYXNQMiA9IE1hdGgucG93KDIsIHRoaXMuYmlhcyArIDEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5lYml0c0ZiaXRzID0gKGViaXRzICsgZmJpdHMpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5mYmlhcyA9IE1hdGgucG93KDIsIC0oOCAqIHRoaXMubnVtQnl0ZXMgLSAxIC0gZWJpdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhY2sgYSBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXIuXHJcbiAgICogQHBhcmFtIHshVWludDhBcnJheXwhQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFRoZSBidWZmZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gd3JpdGUgb24gdGhlIGJ1ZmZlci5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IGluZGV4IHRvIHdyaXRlIG9uIHRoZSBidWZmZXIuXHJcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBpbnB1dCBpcyBub3QgYSBudW1iZXIuXHJcbiAgICovXHJcbiAgcGFjayhidWZmZXIsIG51bSwgaW5kZXgpIHtcclxuICAgIC8vIE9ubHkgbnVtYmVycyBjYW4gYmUgcGFja2VkXHJcbiAgICBpZiAodHlwZW9mIG51bSAhPSAnbnVtYmVyJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICB9XHJcbiAgICAvLyBSb3VuZCBvdmVyZmxvd3NcclxuICAgIGlmIChNYXRoLmFicyhudW0pID4gdGhpcy5iaWFzUDIgLSAodGhpcy5lYml0c0ZiaXRzICogMikpIHtcclxuICAgICAgbnVtID0gbnVtIDwgMCA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzaWduLCBuZWVkIHRoaXMgdG8gaGFuZGxlIG5lZ2F0aXZlIHplcm9cclxuICAgICAqIEBzZWUgaHR0cDovL2N3ZXN0YmxvZy5jb20vMjAxNC8wMi8yNS9qYXZhc2NyaXB0LXRlc3RpbmctZm9yLW5lZ2F0aXZlLXplcm8vXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBsZXQgc2lnbiA9ICgoKG51bSA9ICtudW0pIHx8IDEgLyBudW0pIDwgMCkgPyAxIDogbnVtIDwgMCA/IDEgOiAwO1xyXG4gICAgbnVtID0gTWF0aC5hYnMobnVtKTtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IGV4cCA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGguTE4yKSwgMTAyMyk7XHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIGxldCBmcmFjdGlvbiA9IHJvdW5kVG9FdmVuKG51bSAvIE1hdGgucG93KDIsIGV4cCkgKiBNYXRoLnBvdygyLCB0aGlzLmZiaXRzKSk7XHJcbiAgICAvLyBOYU5cclxuICAgIGlmIChudW0gIT09IG51bSkge1xyXG4gICAgICBmcmFjdGlvbiA9IE1hdGgucG93KDIsIHRoaXMuZmJpdHMgLSAxKTtcclxuICAgICAgZXhwID0gKDEgPDwgdGhpcy5lYml0cykgLSAxO1xyXG4gICAgLy8gTnVtYmVyXHJcbiAgICB9IGVsc2UgaWYgKG51bSAhPT0gMCkge1xyXG4gICAgICBpZiAobnVtID49IE1hdGgucG93KDIsIDEgLSB0aGlzLmJpYXMpKSB7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uIC8gTWF0aC5wb3coMiwgdGhpcy5mYml0cykgPj0gMikge1xyXG4gICAgICAgICAgZXhwID0gZXhwICsgMTtcclxuICAgICAgICAgIGZyYWN0aW9uID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3ZlcmZsb3dcclxuICAgICAgICBpZiAoZXhwID4gdGhpcy5iaWFzKSB7XHJcbiAgICAgICAgICBleHAgPSAoMSA8PCB0aGlzLmViaXRzKSAtIDE7XHJcbiAgICAgICAgICBmcmFjdGlvbiA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4cCA9IGV4cCArIHRoaXMuYmlhcztcclxuICAgICAgICAgIGZyYWN0aW9uID0gcm91bmRUb0V2ZW4oZnJhY3Rpb24pIC0gTWF0aC5wb3coMiwgdGhpcy5mYml0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZyYWN0aW9uID0gcm91bmRUb0V2ZW4obnVtIC8gTWF0aC5wb3coMiwgMSAtIHRoaXMuYmlhcyAtIHRoaXMuZmJpdHMpKTtcclxuICAgICAgICBleHAgPSAwO1xyXG4gICAgICB9IFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucGFja0Zsb2F0Qml0c18oYnVmZmVyLCBpbmRleCwgc2lnbiwgZXhwLCBmcmFjdGlvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbnBhY2sgYSBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXIuXHJcbiAgICogRGVyaXZlZCBmcm9tIElFRUU3NTQgYnkgRGVOQSBDby4sIEx0ZC4sIE1JVCBMaWNlbnNlLiBcclxuICAgKiBBZGFwdGVkIHRvIGhhbmRsZSBOYU4uIFNob3VsZCBwb3J0IHRoZSBzb2x1dGlvbiB0byB0aGUgb3JpZ2luYWwgcmVwby5cclxuICAgKiBAcGFyYW0geyFVaW50OEFycmF5fCFBcnJheTxudW1iZXI+fSBidWZmZXIgVGhlIGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICAgKi9cclxuICB1bnBhY2soYnVmZmVyLCBpbmRleCkge1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBsZXQgZU1heCA9ICgxIDw8IHRoaXMuZWJpdHMpIC0gMTtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IHNpZ25pZmljYW5kO1xyXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICBsZXQgbGVmdEJpdHMgPSBcIlwiO1xyXG4gICAgZm9yIChsZXQgaSA9IHRoaXMubnVtQnl0ZXMgLSAxOyBpID49IDAgOyBpLS0pIHtcclxuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgIGxldCB0ID0gYnVmZmVyW2kgKyBpbmRleF0udG9TdHJpbmcoMik7XHJcbiAgICAgIGxlZnRCaXRzICs9IFwiMDAwMDAwMDBcIi5zdWJzdHJpbmcodC5sZW5ndGgpICsgdDtcclxuICAgIH1cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IHNpZ24gPSBsZWZ0Qml0cy5jaGFyQXQoMCkgPT0gXCIxXCIgPyAtMSA6IDE7XHJcbiAgICBsZWZ0Qml0cyA9IGxlZnRCaXRzLnN1YnN0cmluZygxKTtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IGV4cG9uZW50ID0gcGFyc2VJbnQobGVmdEJpdHMuc3Vic3RyaW5nKDAsIHRoaXMuZWJpdHMpLCAyKTtcclxuICAgIGxlZnRCaXRzID0gbGVmdEJpdHMuc3Vic3RyaW5nKHRoaXMuZWJpdHMpO1xyXG4gICAgaWYgKGV4cG9uZW50ID09IGVNYXgpIHtcclxuICAgICAgaWYgKHBhcnNlSW50KGxlZnRCaXRzLCAyKSAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpZ24gKiBJbmZpbml0eTsgIFxyXG4gICAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gMCkge1xyXG4gICAgICBleHBvbmVudCArPSAxO1xyXG4gICAgICBzaWduaWZpY2FuZCA9IHBhcnNlSW50KGxlZnRCaXRzLCAyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNpZ25pZmljYW5kID0gcGFyc2VJbnQoXCIxXCIgKyBsZWZ0Qml0cywgMik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2lnbiAqIHNpZ25pZmljYW5kICogdGhpcy5mYmlhcyAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gdGhpcy5iaWFzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhY2sgYSBJRUVFNzU0IGZyb20gaXRzIHNpZ24sIGV4cG9uZW50IGFuZCBmcmFjdGlvbiBiaXRzXHJcbiAgICogYW5kIHBsYWNlIGl0IGluIGEgYnl0ZSBidWZmZXIuXHJcbiAgICogQHBhcmFtIHshVWludDhBcnJheXwhQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFRoZSBieXRlIGJ1ZmZlciB0byB3cml0ZSB0by5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGJ1ZmZlciBpbmRleCB0byB3cml0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2lnbiBUaGUgc2lnbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZXhwIHRoZSBleHBvbmVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJhY3Rpb24gVGhlIGZyYWN0aW9uLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHBhY2tGbG9hdEJpdHNfKGJ1ZmZlciwgaW5kZXgsIHNpZ24sIGV4cCwgZnJhY3Rpb24pIHtcclxuICAgIC8qKiBAdHlwZSB7IUFycmF5PG51bWJlcj59ICovXHJcbiAgICBsZXQgYml0cyA9IFtdO1xyXG4gICAgLy8gdGhlIHNpZ25cclxuICAgIGJpdHMucHVzaChzaWduKTtcclxuICAgIC8vIHRoZSBleHBvbmVudFxyXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZWJpdHM7IGkgPiAwOyBpIC09IDEpIHtcclxuICAgICAgYml0c1tpXSA9IChleHAgJSAyID8gMSA6IDApO1xyXG4gICAgICBleHAgPSBNYXRoLmZsb29yKGV4cCAvIDIpO1xyXG4gICAgfVxyXG4gICAgLy8gdGhlIGZyYWN0aW9uXHJcbiAgICBsZXQgbGVuID0gYml0cy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gdGhpcy5mYml0czsgaSA+IDA7IGkgLT0gMSkge1xyXG4gICAgICBiaXRzW2xlbiArIGldID0gKGZyYWN0aW9uICUgMiA/IDEgOiAwKTtcclxuICAgICAgZnJhY3Rpb24gPSBNYXRoLmZsb29yKGZyYWN0aW9uIC8gMik7XHJcbiAgICB9XHJcbiAgICAvLyBwYWNrIGFzIGJ5dGVzXHJcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgIGxldCBzdHIgPSBiaXRzLmpvaW4oJycpO1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBsZXQgbnVtQnl0ZXMgPSB0aGlzLm51bUJ5dGVzICsgaW5kZXggLSAxO1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBsZXQgayA9IGluZGV4O1xyXG4gICAgd2hpbGUgKG51bUJ5dGVzID49IGluZGV4KSB7XHJcbiAgICAgIGJ1ZmZlcltudW1CeXRlc10gPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDgpLCAyKTtcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZyg4KTtcclxuICAgICAgbnVtQnl0ZXMtLTtcclxuICAgICAgaysrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGs7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUm91bmQgYSBudW1iZXIgdG8gaXRzIG5lYXJlc3QgZXZlbiB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlci5cclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRUb0V2ZW4obikge1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIGxldCB3ID0gTWF0aC5mbG9vcihuKTtcclxuICBsZXQgZiA9IG4gLSB3O1xyXG4gIGlmIChmIDwgMC41KSB7XHJcbiAgICByZXR1cm4gdztcclxuICB9XHJcbiAgaWYgKGYgPiAwLjUpIHtcclxuICAgIHJldHVybiB3ICsgMTtcclxuICB9XHJcbiAgcmV0dXJuIHcgJSAyID8gdyArIDEgOiB3O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ieee754-buffer/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/riff-file/index.js":
/*!*****************************************!*\
  !*** ./node_modules/riff-file/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIFFFile: () => (/* binding */ RIFFFile)\n/* harmony export */ });\n/* harmony import */ var byte_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! byte-data */ \"(pages-dir-browser)/./node_modules/byte-data/index.js\");\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/riff-file\r\n */\r\n\r\n/** @module riff-file */\r\n\r\n\r\n\r\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\r\nclass RIFFFile {\r\n\r\n  constructor() {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * The main chunk size, in bytes.\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format identifier.\r\n     * @type {string}\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * An object representing the signature of all chunks in the file.\r\n     * @type {{\r\n      chunkId: string,\r\n      chunkSize: number,\r\n      format: string,\r\n      chunkData: {start: number, end: number},\r\n      subChunks: Array\r\n      }|null}\r\n     */\r\n    this.signature = null;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.head = 0;\r\n    /**\r\n     * @type {\r\n      {bits: number, be: boolean, signed: boolean, fp: boolean}\r\n     }\r\n     * @protected\r\n     */\r\n    this.uInt32 = { bits: 32, be: false, signed: false, fp: false };\r\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\r\n    this.supported_containers = ['RIFF', 'RIFX'];\r\n  }\r\n\r\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\r\n  setSignature(buffer) {\r\n      this.head = 0;\r\n      this.container = this.readString(buffer, 4);\r\n      if (this.supported_containers.indexOf(this.container) === -1) {\r\n        throw Error('Not a supported format.');\r\n      }\r\n      this.uInt32.be = this.container === 'RIFX';\r\n      this.chunkSize = this.readUInt32(buffer);\r\n      this.format = this.readString(buffer, 4);\r\n      // The RIFF file signature\r\n      this.signature = {\r\n          chunkId: this.container,\r\n          chunkSize: this.chunkSize,\r\n          format: this.format,\r\n          subChunks: this.getSubChunksIndex_(buffer),\r\n          chunkData: {start: 0, end: this.chunkSize}\r\n      };\r\n  }\r\n\r\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} multiple True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\r\n  findChunk(chunkId, multiple=false) {\r\n    /** @type {!Array|null} */\r\n    let chunks = this.signature.subChunks;\r\n    /** @type {!Array<!Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i].chunkId == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\r\n  readString(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    str = (0,byte_data__WEBPACK_IMPORTED_MODULE_0__.unpackString)(bytes, this.head, this.head + maxSize);\r\n    this.head += maxSize;\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\r\n  readUInt32(bytes) {\r\n    /** @type {number} */\r\n    let value = (0,byte_data__WEBPACK_IMPORTED_MODULE_0__.unpack)(bytes, this.uInt32, this.head);\r\n    this.head += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunksIndex_(buffer) {\r\n      /** @type {!Array<!Object>} */\r\n      let chunks = [];\r\n      /** @type {number} */\r\n      let i = this.head;\r\n      while(i <= buffer.length - 8) {\r\n          chunks.push(this.getSubChunkIndex_(buffer, i));\r\n          i += 8 + chunks[chunks.length - 1].chunkSize;\r\n          i = i % 2 ? i + 1 : i;\r\n      }\r\n      return chunks;\r\n  }\r\n\r\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunkIndex_(buffer, index) {\r\n      /** @type {!Object} */\r\n      let chunk = {\r\n          chunkId: this.getChunkId_(buffer, index),\r\n          chunkSize: this.getChunkSize_(buffer, index),\r\n      };\r\n      if (chunk.chunkId == 'LIST') {\r\n          chunk.format = (0,byte_data__WEBPACK_IMPORTED_MODULE_0__.unpackString)(buffer, index + 8, index + 12);\r\n          this.head += 4;\r\n          chunk.subChunks = this.getSubChunksIndex_(buffer);\r\n      } else {\r\n          /** @type {number} */\r\n          let realChunkSize = chunk.chunkSize % 2 ?\r\n              chunk.chunkSize + 1 : chunk.chunkSize;\r\n          this.head = index + 8 + realChunkSize;\r\n          chunk.chunkData = {\r\n              start: index + 8,\r\n              end: this.head\r\n          };\r\n      }\r\n      return chunk;\r\n  }\r\n\r\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\r\n  getChunkId_(buffer, index) {\r\n      this.head += 4;\r\n      return (0,byte_data__WEBPACK_IMPORTED_MODULE_0__.unpackString)(buffer, index, index + 4);\r\n  }\r\n\r\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\r\n  getChunkSize_(buffer, index) {\r\n      this.head += 4;\r\n      return (0,byte_data__WEBPACK_IMPORTED_MODULE_0__.unpack)(buffer, this.uInt32, index + 4);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yaWZmLWZpbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxVQUFVLHVEQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFZO0FBQ3JDO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdURBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQU07QUFDbkI7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHJpZmYtZmlsZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMTkgUmFmYWVsIGRhIFNpbHZhIFJvY2hhLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcclxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxyXG4gKiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgVGhlIFJJRkZGaWxlIGNsYXNzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2NoYXJzL3JpZmYtZmlsZVxyXG4gKi9cclxuXHJcbi8qKiBAbW9kdWxlIHJpZmYtZmlsZSAqL1xyXG5cclxuaW1wb3J0IHt1bnBhY2tTdHJpbmcsIHVucGFja30gZnJvbSAnYnl0ZS1kYXRhJztcclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRvIHBlcmZvcm0gbG93LWxldmVsIHJlYWRpbmcgb2YgUklGRi9SSUZYIGZpbGVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJJRkZGaWxlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb250YWluZXIgaWRlbnRpZmllci5cclxuICAgICAqICdSSUZGJywgJ1JJRlgnIGFuZCAnUkY2NCcgYXJlIHN1cHBvcnRlZC5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFpbmVyID0gJyc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYWluIGNodW5rIHNpemUsIGluIGJ5dGVzLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jaHVua1NpemUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9ybWF0IGlkZW50aWZpZXIuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZvcm1hdCA9ICcnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzaWduYXR1cmUgb2YgYWxsIGNodW5rcyBpbiB0aGUgZmlsZS5cclxuICAgICAqIEB0eXBlIHt7XHJcbiAgICAgIGNodW5rSWQ6IHN0cmluZyxcclxuICAgICAgY2h1bmtTaXplOiBudW1iZXIsXHJcbiAgICAgIGZvcm1hdDogc3RyaW5nLFxyXG4gICAgICBjaHVua0RhdGE6IHtzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn0sXHJcbiAgICAgIHN1YkNodW5rczogQXJyYXlcclxuICAgICAgfXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNpZ25hdHVyZSA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVhZCA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtcclxuICAgICAge2JpdHM6IG51bWJlciwgYmU6IGJvb2xlYW4sIHNpZ25lZDogYm9vbGVhbiwgZnA6IGJvb2xlYW59XHJcbiAgICAgfVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnVJbnQzMiA9IHsgYml0czogMzIsIGJlOiBmYWxzZSwgc2lnbmVkOiBmYWxzZSwgZnA6IGZhbHNlIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjb250YWluZXJzLlxyXG4gICAgICogQW55IGZvcm1hdCBkaWZmZXJlbnQgZnJvbSBSSUZYIHdpbGwgYmUgdHJlYXRlZCBhcyBSSUZGLlxyXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnN1cHBvcnRlZF9jb250YWluZXJzID0gWydSSUZGJywgJ1JJRlgnXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgdGhlIHNpZ25hdHVyZSBvZiB0aGUgY2h1bmtzIGluIGEgUklGRi9SSUZYIGZpbGUuXHJcbiAgICogQHBhcmFtIHshVWludDhBcnJheX0gYnVmZmVyIFRoZSBmaWxlIGJ5dGVzLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBzZXRTaWduYXR1cmUoYnVmZmVyKSB7XHJcbiAgICAgIHRoaXMuaGVhZCA9IDA7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5yZWFkU3RyaW5nKGJ1ZmZlciwgNCk7XHJcbiAgICAgIGlmICh0aGlzLnN1cHBvcnRlZF9jb250YWluZXJzLmluZGV4T2YodGhpcy5jb250YWluZXIpID09PSAtMSkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgYSBzdXBwb3J0ZWQgZm9ybWF0LicpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudUludDMyLmJlID0gdGhpcy5jb250YWluZXIgPT09ICdSSUZYJztcclxuICAgICAgdGhpcy5jaHVua1NpemUgPSB0aGlzLnJlYWRVSW50MzIoYnVmZmVyKTtcclxuICAgICAgdGhpcy5mb3JtYXQgPSB0aGlzLnJlYWRTdHJpbmcoYnVmZmVyLCA0KTtcclxuICAgICAgLy8gVGhlIFJJRkYgZmlsZSBzaWduYXR1cmVcclxuICAgICAgdGhpcy5zaWduYXR1cmUgPSB7XHJcbiAgICAgICAgICBjaHVua0lkOiB0aGlzLmNvbnRhaW5lcixcclxuICAgICAgICAgIGNodW5rU2l6ZTogdGhpcy5jaHVua1NpemUsXHJcbiAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxyXG4gICAgICAgICAgc3ViQ2h1bmtzOiB0aGlzLmdldFN1YkNodW5rc0luZGV4XyhidWZmZXIpLFxyXG4gICAgICAgICAgY2h1bmtEYXRhOiB7c3RhcnQ6IDAsIGVuZDogdGhpcy5jaHVua1NpemV9XHJcbiAgICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICogRmluZCBhIGNodW5rIGJ5IGl0cyBmb3VyQ0NfIGluIGEgYXJyYXkgb2YgUklGRiBjaHVua3MuXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaHVua0lkIFRoZSBjaHVuayBmb3VyQ0NfLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlIFRydWUgaWYgdGhlcmUgbWF5IGJlIG11bHRpcGxlIGNodW5rc1xyXG4gICAgKiAgICB3aXRoIHRoZSBzYW1lIGNodW5rSWQuXHJcbiAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICogQHByb3RlY3RlZFxyXG4gICAgKi9cclxuICBmaW5kQ2h1bmsoY2h1bmtJZCwgbXVsdGlwbGU9ZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7IUFycmF5fG51bGx9ICovXHJcbiAgICBsZXQgY2h1bmtzID0gdGhpcy5zaWduYXR1cmUuc3ViQ2h1bmtzO1xyXG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IU9iamVjdD59ICovXHJcbiAgICBsZXQgY2h1bmsgPSBbXTtcclxuICAgIGZvciAobGV0IGk9MDsgaTxjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNodW5rc1tpXS5jaHVua0lkID09IGNodW5rSWQpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgIGNodW5rLnB1c2goY2h1bmtzW2ldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGNodW5rc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjaHVua0lkID09ICdMSVNUJykge1xyXG4gICAgICByZXR1cm4gY2h1bmsubGVuZ3RoID8gY2h1bmsgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkIGJ5dGVzIGFzIGEgc3RyaW5nIGZyb20gYSBSSUZGIGNodW5rLlxyXG4gICAqIEBwYXJhbSB7IVVpbnQ4QXJyYXl9IGJ5dGVzIFRoZSBieXRlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U2l6ZSB0aGUgbWF4IHNpemUgb2YgdGhlIHN0cmluZy5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcuXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIHJlYWRTdHJpbmcoYnl0ZXMsIG1heFNpemUpIHtcclxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgc3RyID0gdW5wYWNrU3RyaW5nKGJ5dGVzLCB0aGlzLmhlYWQsIHRoaXMuaGVhZCArIG1heFNpemUpO1xyXG4gICAgdGhpcy5oZWFkICs9IG1heFNpemU7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIG51bWJlciBmcm9tIGEgY2h1bmsuXHJcbiAgICogQHBhcmFtIHshVWludDhBcnJheX0gYnl0ZXMgVGhlIGNodW5rIGJ5dGVzLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlci5cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgcmVhZFVJbnQzMihieXRlcykge1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBsZXQgdmFsdWUgPSB1bnBhY2soYnl0ZXMsIHRoaXMudUludDMyLCB0aGlzLmhlYWQpO1xyXG4gICAgdGhpcy5oZWFkICs9IDQ7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHN1YiBjaHVua3Mgb2YgYSBSSUZGIGZpbGUuXHJcbiAgICogQHBhcmFtIHshVWludDhBcnJheX0gYnVmZmVyIHRoZSBSSUZGIGZpbGUgYnl0ZXMuXHJcbiAgICogQHJldHVybiB7IUFycmF5PE9iamVjdD59IFRoZSBzdWJjaHVua3Mgb2YgYSBSSUZGL1JJRlggb3IgTElTVCBjaHVuay5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldFN1YkNodW5rc0luZGV4XyhidWZmZXIpIHtcclxuICAgICAgLyoqIEB0eXBlIHshQXJyYXk8IU9iamVjdD59ICovXHJcbiAgICAgIGxldCBjaHVua3MgPSBbXTtcclxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgIGxldCBpID0gdGhpcy5oZWFkO1xyXG4gICAgICB3aGlsZShpIDw9IGJ1ZmZlci5sZW5ndGggLSA4KSB7XHJcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmdldFN1YkNodW5rSW5kZXhfKGJ1ZmZlciwgaSkpO1xyXG4gICAgICAgICAgaSArPSA4ICsgY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXS5jaHVua1NpemU7XHJcbiAgICAgICAgICBpID0gaSAlIDIgPyBpICsgMSA6IGk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNodW5rcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHN1YiBjaHVuayBmcm9tIGEgUklGRiBmaWxlLlxyXG4gICAqIEBwYXJhbSB7IVVpbnQ4QXJyYXl9IGJ1ZmZlciB0aGUgUklGRiBmaWxlIGJ5dGVzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGNodW5rLlxyXG4gICAqIEByZXR1cm4geyFPYmplY3R9IEEgc3ViY2h1bmsgb2YgYSBSSUZGL1JJRlggb3IgTElTVCBjaHVuay5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldFN1YkNodW5rSW5kZXhfKGJ1ZmZlciwgaW5kZXgpIHtcclxuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xyXG4gICAgICBsZXQgY2h1bmsgPSB7XHJcbiAgICAgICAgICBjaHVua0lkOiB0aGlzLmdldENodW5rSWRfKGJ1ZmZlciwgaW5kZXgpLFxyXG4gICAgICAgICAgY2h1bmtTaXplOiB0aGlzLmdldENodW5rU2l6ZV8oYnVmZmVyLCBpbmRleCksXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjaHVuay5jaHVua0lkID09ICdMSVNUJykge1xyXG4gICAgICAgICAgY2h1bmsuZm9ybWF0ID0gdW5wYWNrU3RyaW5nKGJ1ZmZlciwgaW5kZXggKyA4LCBpbmRleCArIDEyKTtcclxuICAgICAgICAgIHRoaXMuaGVhZCArPSA0O1xyXG4gICAgICAgICAgY2h1bmsuc3ViQ2h1bmtzID0gdGhpcy5nZXRTdWJDaHVua3NJbmRleF8oYnVmZmVyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgICAgbGV0IHJlYWxDaHVua1NpemUgPSBjaHVuay5jaHVua1NpemUgJSAyID9cclxuICAgICAgICAgICAgICBjaHVuay5jaHVua1NpemUgKyAxIDogY2h1bmsuY2h1bmtTaXplO1xyXG4gICAgICAgICAgdGhpcy5oZWFkID0gaW5kZXggKyA4ICsgcmVhbENodW5rU2l6ZTtcclxuICAgICAgICAgIGNodW5rLmNodW5rRGF0YSA9IHtcclxuICAgICAgICAgICAgICBzdGFydDogaW5kZXggKyA4LFxyXG4gICAgICAgICAgICAgIGVuZDogdGhpcy5oZWFkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjaHVuaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgZm91ckNDXyBvZiBhIGNodW5rLlxyXG4gICAqIEBwYXJhbSB7IVVpbnQ4QXJyYXl9IGJ1ZmZlciB0aGUgUklGRiBmaWxlIGJ5dGVzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGNodW5rLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGlkIG9mIHRoZSBjaHVuay5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldENodW5rSWRfKGJ1ZmZlciwgaW5kZXgpIHtcclxuICAgICAgdGhpcy5oZWFkICs9IDQ7XHJcbiAgICAgIHJldHVybiB1bnBhY2tTdHJpbmcoYnVmZmVyLCBpbmRleCwgaW5kZXggKyA0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgc2l6ZSBvZiBhIGNodW5rLlxyXG4gICAqIEBwYXJhbSB7IVVpbnQ4QXJyYXl9IGJ1ZmZlciB0aGUgUklGRiBmaWxlIGJ5dGVzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGNodW5rLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGNodW5rIHdpdGhvdXQgdGhlIGlkIGFuZCBzaXplIGZpZWxkcy5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldENodW5rU2l6ZV8oYnVmZmVyLCBpbmRleCkge1xyXG4gICAgICB0aGlzLmhlYWQgKz0gNDtcclxuICAgICAgcmV0dXJuIHVucGFjayhidWZmZXIsIHRoaXMudUludDMyLCBpbmRleCArIDQpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/riff-file/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/utf8-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/utf8-buffer/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Functions to serialize and deserialize UTF-8 strings.\r\n * @see https://github.com/rochars/utf8-buffer\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\r\n\r\n/** @module utf8-buffer */\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number=} start The buffer index to start reading.\r\n * @param {?number=} end The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\r\nfunction unpack(buffer, start=0, end=buffer.length) {\r\n  /** @type {string} */\r\n  let str = '';\r\n  for(let index = start; index < end;) {\r\n    /** @type {number} */\r\n    let lowerBoundary = 0x80;\r\n    /** @type {number} */\r\n    let upperBoundary = 0xBF;\r\n    /** @type {boolean} */\r\n    let replace = false;\r\n    /** @type {number} */\r\n    let charCode = buffer[index++];\r\n    if (charCode >= 0x00 && charCode <= 0x7F) {\r\n      str += String.fromCharCode(charCode);\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\r\n        count = 1;\r\n      } else if (charCode >= 0xE0 && charCode <= 0xEF ) {\r\n        count = 2;\r\n        if (buffer[index] === 0xE0) {\r\n          lowerBoundary = 0xA0;\r\n        }\r\n        if (buffer[index] === 0xED) {\r\n          upperBoundary = 0x9F;\r\n        }\r\n      } else if (charCode >= 0xF0 && charCode <= 0xF4 ) {\r\n        count = 3;\r\n        if (buffer[index] === 0xF0) {\r\n          lowerBoundary = 0x90;\r\n        }\r\n        if (buffer[index] === 0xF4) {\r\n          upperBoundary = 0x8F;\r\n        }\r\n      } else {\r\n        replace = true;\r\n      }\r\n      charCode = charCode & (1 << (8 - count - 1)) - 1;\r\n      for (let i = 0; i < count; i++) {\r\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\r\n          replace = true;\r\n        }\r\n        charCode = (charCode << 6) | (buffer[index] & 0x3f);\r\n        index++;\r\n      }\r\n      if (replace) {\r\n        str += String.fromCharCode(0xFFFD);\r\n      } \r\n      else if (charCode <= 0xffff) {\r\n        str += String.fromCharCode(charCode);\r\n      } else {\r\n        charCode -= 0x10000;\r\n        str += String.fromCharCode(\r\n          ((charCode >> 10) & 0x3ff) + 0xd800,\r\n          (charCode & 0x3ff) + 0xdc00);\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nfunction pack(str, buffer, index=0) {\r\n  for (let i = 0, len = str.length; i < len; i++) {\r\n    /** @type {number} */\r\n    let codePoint = str.codePointAt(i);\r\n    if (codePoint < 128) {\r\n      buffer[index] = codePoint;\r\n      index++;\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      /** @type {number} */\r\n      let offset = 0;\r\n      if (codePoint <= 0x07FF) {\r\n        count = 1;\r\n        offset = 0xC0;\r\n      } else if(codePoint <= 0xFFFF) {\r\n        count = 2;\r\n        offset = 0xE0;\r\n      } else if(codePoint <= 0x10FFFF) {\r\n        count = 3;\r\n        offset = 0xF0;\r\n        i++;\r\n      }\r\n      buffer[index] = (codePoint >> (6 * count)) + offset;\r\n      index++;\r\n      while (count > 0) {\r\n        buffer[index] = 0x80 | (codePoint >> (6 * (count - 1)) & 0x3F);\r\n        index++;\r\n        count--;\r\n      }\r\n    }\r\n  }\r\n  return index;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dGY4LWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUCxhQUFhLFFBQVE7QUFDckI7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQyxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQLG9DQUFvQyxTQUFTO0FBQzdDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcdXRmOC1idWZmZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxOCBSYWZhZWwgZGEgU2lsdmEgUm9jaGEuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxyXG4gKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXHJcbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGdW5jdGlvbnMgdG8gc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBVVEYtOCBzdHJpbmdzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2NoYXJzL3V0ZjgtYnVmZmVyXHJcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1lbmNvZGluZ1xyXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyN1dGYtOC1lbmNvZGVyXHJcbiAqL1xyXG5cclxuLyoqIEBtb2R1bGUgdXRmOC1idWZmZXIgKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkIGEgc3RyaW5nIG9mIFVURi04IGNoYXJhY3RlcnMgZnJvbSBhIGJ5dGUgYnVmZmVyLlxyXG4gKiBJbnZhbGlkIGNoYXJhY3RlcnMgYXJlIHJlcGxhY2VkIHdpdGggJ1JFUExBQ0VNRU5UIENIQVJBQ1RFUicgKFUrRkZGRCkuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1lbmNvZGluZ1xyXG4gKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDkyNjkxMVxyXG4gKiBAcGFyYW0geyFVaW50OEFycmF5fCFBcnJheTxudW1iZXI+fSBidWZmZXIgQSBieXRlIGJ1ZmZlci5cclxuICogQHBhcmFtIHtudW1iZXI9fSBzdGFydCBUaGUgYnVmZmVyIGluZGV4IHRvIHN0YXJ0IHJlYWRpbmcuXHJcbiAqIEBwYXJhbSB7P251bWJlcj19IGVuZCBUaGUgYnVmZmVyIGluZGV4IHRvIHN0b3AgcmVhZGluZy5cclxuICogICBBc3N1bWVzIHRoZSBidWZmZXIgbGVuZ3RoIGlmIHVuZGVmaW5lZC5cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVucGFjayhidWZmZXIsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKSB7XHJcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgbGV0IHN0ciA9ICcnO1xyXG4gIGZvcihsZXQgaW5kZXggPSBzdGFydDsgaW5kZXggPCBlbmQ7KSB7XHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIGxldCBsb3dlckJvdW5kYXJ5ID0gMHg4MDtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IHVwcGVyQm91bmRhcnkgPSAweEJGO1xyXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgbGV0IHJlcGxhY2UgPSBmYWxzZTtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IGNoYXJDb2RlID0gYnVmZmVyW2luZGV4KytdO1xyXG4gICAgaWYgKGNoYXJDb2RlID49IDB4MDAgJiYgY2hhckNvZGUgPD0gMHg3Rikge1xyXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgaWYgKGNoYXJDb2RlID49IDB4QzIgJiYgY2hhckNvZGUgPD0gMHhERikge1xyXG4gICAgICAgIGNvdW50ID0gMTtcclxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+PSAweEUwICYmIGNoYXJDb2RlIDw9IDB4RUYgKSB7XHJcbiAgICAgICAgY291bnQgPSAyO1xyXG4gICAgICAgIGlmIChidWZmZXJbaW5kZXhdID09PSAweEUwKSB7XHJcbiAgICAgICAgICBsb3dlckJvdW5kYXJ5ID0gMHhBMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlcltpbmRleF0gPT09IDB4RUQpIHtcclxuICAgICAgICAgIHVwcGVyQm91bmRhcnkgPSAweDlGO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+PSAweEYwICYmIGNoYXJDb2RlIDw9IDB4RjQgKSB7XHJcbiAgICAgICAgY291bnQgPSAzO1xyXG4gICAgICAgIGlmIChidWZmZXJbaW5kZXhdID09PSAweEYwKSB7XHJcbiAgICAgICAgICBsb3dlckJvdW5kYXJ5ID0gMHg5MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlcltpbmRleF0gPT09IDB4RjQpIHtcclxuICAgICAgICAgIHVwcGVyQm91bmRhcnkgPSAweDhGO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXBsYWNlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBjaGFyQ29kZSA9IGNoYXJDb2RlICYgKDEgPDwgKDggLSBjb3VudCAtIDEpKSAtIDE7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIGlmIChidWZmZXJbaW5kZXhdIDwgbG93ZXJCb3VuZGFyeSB8fCBidWZmZXJbaW5kZXhdID4gdXBwZXJCb3VuZGFyeSkge1xyXG4gICAgICAgICAgcmVwbGFjZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJDb2RlID0gKGNoYXJDb2RlIDw8IDYpIHwgKGJ1ZmZlcltpbmRleF0gJiAweDNmKTtcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTtcclxuICAgICAgfSBcclxuICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPD0gMHhmZmZmKSB7XHJcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJDb2RlIC09IDB4MTAwMDA7XHJcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgICAoKGNoYXJDb2RlID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCxcclxuICAgICAgICAgIChjaGFyQ29kZSAmIDB4M2ZmKSArIDB4ZGMwMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyaXRlIGEgc3RyaW5nIG9mIFVURi04IGNoYXJhY3RlcnMgdG8gYSBieXRlIGJ1ZmZlci5cclxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZW5jb2RlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gcGFjay5cclxuICogQHBhcmFtIHshVWludDhBcnJheXwhQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gcGFjayB0aGUgc3RyaW5nIHRvLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IGluZGV4IFRoZSBidWZmZXIgaW5kZXggdG8gc3RhcnQgd3JpdGluZy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBpbmRleCB0byB3cml0ZSBpbiB0aGUgYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhY2soc3RyLCBidWZmZXIsIGluZGV4PTApIHtcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIGxldCBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XHJcbiAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7XHJcbiAgICAgIGJ1ZmZlcltpbmRleF0gPSBjb2RlUG9pbnQ7XHJcbiAgICAgIGluZGV4Kys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICBpZiAoY29kZVBvaW50IDw9IDB4MDdGRikge1xyXG4gICAgICAgIGNvdW50ID0gMTtcclxuICAgICAgICBvZmZzZXQgPSAweEMwO1xyXG4gICAgICB9IGVsc2UgaWYoY29kZVBvaW50IDw9IDB4RkZGRikge1xyXG4gICAgICAgIGNvdW50ID0gMjtcclxuICAgICAgICBvZmZzZXQgPSAweEUwO1xyXG4gICAgICB9IGVsc2UgaWYoY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XHJcbiAgICAgICAgY291bnQgPSAzO1xyXG4gICAgICAgIG9mZnNldCA9IDB4RjA7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICAgIGJ1ZmZlcltpbmRleF0gPSAoY29kZVBvaW50ID4+ICg2ICogY291bnQpKSArIG9mZnNldDtcclxuICAgICAgaW5kZXgrKztcclxuICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xyXG4gICAgICAgIGJ1ZmZlcltpbmRleF0gPSAweDgwIHwgKGNvZGVQb2ludCA+PiAoNiAqIChjb3VudCAtIDEpKSAmIDB4M0YpO1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgY291bnQtLTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/utf8-buffer/index.js\n"));

/***/ })

}]);