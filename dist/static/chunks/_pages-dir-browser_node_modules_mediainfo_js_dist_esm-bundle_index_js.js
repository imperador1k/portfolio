"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_mediainfo_js_dist_esm-bundle_index_js"],{

/***/ "(pages-dir-browser)/./node_modules/mediainfo.js/dist/esm-bundle/index.js":
/*!************************************************************!*\
  !*** ./node_modules/mediainfo.js/dist/esm-bundle/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mediaInfoFactory),\n/* harmony export */   isTrackType: () => (/* binding */ isTrackType),\n/* harmony export */   mediaInfoFactory: () => (/* binding */ mediaInfoFactory)\n/* harmony export */ });\nfunction isError(error) {\n  return error !== null && typeof error === 'object' && Object.prototype.hasOwnProperty.call(error, 'message');\n}\nfunction unknownToError(error) {\n  if (isError(error)) {\n    return error;\n  }\n  return new Error(typeof error === 'string' ? error : 'Unknown error');\n}\n\n// DO NOT EDIT! File generated using `generate-types` script.\n\nconst INT_FIELDS = ['Active_Height', 'Active_Width', 'AudioCount', 'Audio_Channels_Total', 'BitDepth_Detected', 'BitDepth', 'BitDepth_Stored', 'Channels', 'Channels_Original', 'Chapters_Pos_Begin', 'Chapters_Pos_End', 'Comic_Position_Total', 'Count', 'DataSize', 'ElementCount', 'EPG_Positions_Begin', 'EPG_Positions_End', 'FirstPacketOrder', 'FooterSize', 'Format_Settings_GMC', 'Format_Settings_RefFrames', 'Format_Settings_SliceCount', 'FrameCount', 'FrameRate_Den', 'FrameRate_Num', 'GeneralCount', 'HeaderSize', 'Height_CleanAperture', 'Height', 'Height_Offset', 'Height_Original', 'ImageCount', 'Lines_MaxCharacterCount', 'Lines_MaxCountPerEvent', 'Matrix_Channels', 'MenuCount', 'OtherCount', 'Part_Position', 'Part_Position_Total', 'Played_Count', 'Reel_Position', 'Reel_Position_Total', 'Resolution', 'Sampled_Height', 'Sampled_Width', 'SamplingCount', 'Season_Position', 'Season_Position_Total', 'Source_FrameCount', 'Source_SamplingCount', 'Source_StreamSize_Encoded', 'Source_StreamSize', 'Status', 'Stored_Height', 'Stored_Width', 'StreamCount', 'StreamKindID', 'StreamKindPos', 'StreamSize_Demuxed', 'StreamSize_Encoded', 'StreamSize', 'TextCount', 'Track_Position', 'Track_Position_Total', 'Video0_Delay', 'VideoCount', 'Width_CleanAperture', 'Width', 'Width_Offset', 'Width_Original'];\nconst FLOAT_FIELDS = ['Active_DisplayAspectRatio', 'BitRate_Encoded', 'BitRate_Maximum', 'BitRate_Minimum', 'BitRate', 'BitRate_Nominal', 'Bits-Pixel_Frame', 'BitsPixel_Frame', 'Compression_Ratio', 'Delay', 'Delay_Original', 'DisplayAspectRatio_CleanAperture', 'DisplayAspectRatio', 'DisplayAspectRatio_Original', 'Duration_End_Command', 'Duration_End', 'Duration_FirstFrame', 'Duration_LastFrame', 'Duration', 'Duration_Start2End', 'Duration_Start_Command', 'Duration_Start', 'Events_MinDuration', 'FrameRate_Maximum', 'FrameRate_Minimum', 'FrameRate', 'FrameRate_Nominal', 'FrameRate_Original_Den', 'FrameRate_Original', 'FrameRate_Original_Num', 'FrameRate_Real', 'Interleave_Duration', 'Interleave_Preload', 'Interleave_VideoFrames', 'OverallBitRate_Maximum', 'OverallBitRate_Minimum', 'OverallBitRate', 'OverallBitRate_Nominal', 'PixelAspectRatio_CleanAperture', 'PixelAspectRatio', 'PixelAspectRatio_Original', 'SamplesPerFrame', 'SamplingRate', 'Source_Duration_FirstFrame', 'Source_Duration_LastFrame', 'Source_Duration', 'TimeStamp_FirstFrame', 'Video_Delay'];\n\nconst MAX_UINT32_PLUS_ONE = 2 ** 32;\nconst DEFAULT_OPTIONS = {\n  coverData: false,\n  chunkSize: 256 * 1024,\n  format: 'object',\n  full: false\n};\n/**\n * Wrapper for the MediaInfoLib WASM module.\n *\n * This class should not be instantiated directly. Use the {@link mediaInfoFactory} function\n * to create instances of `MediaInfo`.\n *\n * @typeParam TFormat - The format type, defaults to `object`.\n */\nclass MediaInfo {\n  isAnalyzing = false;\n\n  /** @group General Use */\n\n  /**\n   * The constructor should not be called directly, instead use {@link mediaInfoFactory}.\n   *\n   * @hidden\n   * @param mediainfoModule WASM module\n   * @param options User options\n   */\n  constructor(mediainfoModule, options) {\n    this.mediainfoModule = mediainfoModule;\n    this.options = options;\n    this.mediainfoModuleInstance = this.instantiateModuleInstance();\n  }\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param size Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   * @group General Use\n   */\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param size Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   * @param callback Function that is called once the processing is done\n   * @group General Use\n   */\n\n  analyzeData(size, readChunk, callback) {\n    // Support promise signature\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        const resultCb = (result, error) => {\n          this.isAnalyzing = false;\n          if (error || !result) {\n            reject(unknownToError(error));\n          } else {\n            resolve(result);\n          }\n        };\n        this.analyzeData(size, readChunk, resultCb);\n      });\n    }\n    if (this.isAnalyzing) {\n      callback('', new Error('cannot start a new analysis while another is in progress'));\n      return;\n    }\n    this.reset();\n    this.isAnalyzing = true;\n    const finalize = () => {\n      try {\n        this.openBufferFinalize();\n        const result = this.inform();\n        if (this.options.format === 'object') {\n          callback(this.parseResultJson(result));\n        } else {\n          callback(result);\n        }\n      } finally {\n        this.isAnalyzing = false;\n      }\n    };\n    let offset = 0;\n    const runReadDataLoop = fileSize => {\n      const readNextChunk = data => {\n        if (continueBuffer(data)) {\n          getChunk();\n        } else {\n          finalize();\n        }\n      };\n      const getChunk = () => {\n        let dataValue;\n        try {\n          const safeSize = Math.min(this.options.chunkSize, fileSize - offset);\n          dataValue = readChunk(safeSize, offset);\n        } catch (error) {\n          this.isAnalyzing = false;\n          callback('', unknownToError(error));\n          return;\n        }\n        if (dataValue instanceof Promise) {\n          dataValue.then(readNextChunk).catch(error => {\n            this.isAnalyzing = false;\n            callback('', unknownToError(error));\n          });\n        } else {\n          readNextChunk(dataValue);\n        }\n      };\n      const continueBuffer = data => {\n        if (data.length === 0 || this.openBufferContinue(data, data.length)) {\n          return false;\n        }\n        const seekTo = this.openBufferContinueGotoGet();\n        if (seekTo === -1) {\n          offset += data.length;\n        } else {\n          offset = seekTo;\n          this.openBufferInit(fileSize, seekTo);\n        }\n        return true;\n      };\n      this.openBufferInit(fileSize, offset);\n      getChunk();\n    };\n    const fileSizeValue = typeof size === 'function' ? size() : size;\n    if (fileSizeValue instanceof Promise) {\n      fileSizeValue.then(runReadDataLoop).catch(error => {\n        callback(null, unknownToError(error));\n      });\n    } else {\n      runReadDataLoop(fileSizeValue);\n    }\n  }\n\n  /**\n   * Close the MediaInfoLib WASM instance.\n   *\n   * @group General Use\n   */\n  close() {\n    if (typeof this.mediainfoModuleInstance.close === 'function') {\n      this.mediainfoModuleInstance.close();\n    }\n  }\n\n  /**\n   * Reset the MediaInfoLib WASM instance to its initial state.\n   *\n   * This method ensures that the instance is ready for a new parse.\n   * @group General Use\n   */\n  reset() {\n    this.mediainfoModuleInstance.delete();\n    this.mediainfoModuleInstance = this.instantiateModuleInstance();\n  }\n\n  /**\n   * Receive result data from the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Result data (format can be configured in options)\n   * @group Low-level\n   */\n  inform() {\n    return this.mediainfoModuleInstance.inform();\n  }\n\n  /**\n   * Send more data to the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @param data Data buffer\n   * @param size Buffer size\n   * @returns Processing state: `0` (no bits set) = not finished, Bit `0` set = enough data read for providing information\n   * @group Low-level\n   */\n  openBufferContinue(data, size) {\n    // bit 3 set -> done\n    return !!(this.mediainfoModuleInstance.open_buffer_continue(data, size) & 0x08);\n  }\n\n  /**\n   * Retrieve seek position from WASM instance.\n   * The MediaInfoLib function `Open_Buffer_GoTo` returns an integer with 64 bit precision.\n   * It would be cut at 32 bit due to the JavaScript bindings. Here we transport the low and high\n   * parts separately and put them together.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Seek position (where MediaInfoLib wants go in the data buffer)\n   * @group Low-level\n   */\n  openBufferContinueGotoGet() {\n    // JS bindings don't support 64 bit int\n    // https://github.com/buzz/mediainfo.js/issues/11\n    let seekTo = -1;\n    const seekToLow = this.mediainfoModuleInstance.open_buffer_continue_goto_get_lower();\n    const seekToHigh = this.mediainfoModuleInstance.open_buffer_continue_goto_get_upper();\n    if (seekToLow == -1 && seekToHigh == -1) {\n      seekTo = -1;\n    } else if (seekToLow < 0) {\n      seekTo = seekToLow + MAX_UINT32_PLUS_ONE + seekToHigh * MAX_UINT32_PLUS_ONE;\n    } else {\n      seekTo = seekToLow + seekToHigh * MAX_UINT32_PLUS_ONE;\n    }\n    return seekTo;\n  }\n\n  /**\n   * Inform MediaInfoLib that no more data is being read.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @group Low-level\n   */\n  openBufferFinalize() {\n    this.mediainfoModuleInstance.open_buffer_finalize();\n  }\n\n  /**\n   * Prepare MediaInfoLib to process a data buffer.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @param size Expected buffer size\n   * @param offset Buffer offset\n   * @group Low-level\n   */\n  openBufferInit(size, offset) {\n    this.mediainfoModuleInstance.open_buffer_init(size, offset);\n  }\n\n  /**\n   * Parse result JSON. Convert integer/float fields.\n   *\n   * @param result Serialized JSON from MediaInfo\n   * @returns Parsed JSON object\n   */\n  parseResultJson(resultString) {\n    const intFields = INT_FIELDS;\n    const floatFields = FLOAT_FIELDS;\n\n    // Parse JSON\n    const result = JSON.parse(resultString);\n    if (result.media) {\n      const newMedia = {\n        ...result.media,\n        track: []\n      };\n      if (Array.isArray(result.media.track)) {\n        for (const track of result.media.track) {\n          let newTrack = {\n            '@type': track['@type']\n          };\n          for (const [key, val] of Object.entries(track)) {\n            if (key === '@type') {\n              continue;\n            }\n            if (typeof val === 'string' && intFields.includes(key)) {\n              newTrack = {\n                ...newTrack,\n                [key]: Number.parseInt(val, 10)\n              };\n            } else if (typeof val === 'string' && floatFields.includes(key)) {\n              newTrack = {\n                ...newTrack,\n                [key]: Number.parseFloat(val)\n              };\n            } else {\n              newTrack = {\n                ...newTrack,\n                [key]: val\n              };\n            }\n          }\n          newMedia.track.push(newTrack);\n        }\n      }\n      return {\n        ...result,\n        media: newMedia\n      };\n    }\n    return result;\n  }\n\n  /**\n   * Instantiate a new WASM module instance.\n   *\n   * @returns MediaInfo module instance\n   */\n  instantiateModuleInstance() {\n    return new this.mediainfoModule.MediaInfo(this.options.format === 'object' ? 'JSON' : this.options.format, this.options.coverData, this.options.full);\n  }\n}\n\n// This code implements the `-sMODULARIZE` settings by taking the generated\n// JS program code (INNER_JS_CODE) and wrapping it in a factory function.\n\n// When targetting node and ES6 we use `await import ..` in the generated code\n// so the outer function needs to be marked as async.\nasync function Module(moduleArg = {}) {\n  var moduleRtn;\n\n  // include: shell.js\n  // The Module object: Our interface to the outside world. We import\n  // and export values on it. There are various ways Module can be used:\n  // 1. Not defined. We create it here\n  // 2. A function parameter, function(moduleArg) => Promise<Module>\n  // 3. pre-run appended it, var Module = {}; ..generated code..\n  // 4. External script tag defines var Module.\n  // We need to check if Module already exists (e.g. case 3 above).\n  // Substitution will be replaced with actual code on later stage of the build,\n  // this way Closure Compiler will not mangle it (e.g. case 4. above).\n  // Note that if you want to run closure, and also to use Module\n  // after the generated code, you will need to define   var Module = {};\n  // before the code. Then that object will be used in the code, and you\n  // can continue to use Module afterwards as well.\n  var Module = moduleArg;\n  var thisProgram = './this.program';\n\n  var _scriptName = \"file:///C:/Users/User/Documents/Sites/Sites/em%20desenvolvimento/Portfolio2/node_modules/mediainfo.js/dist/esm-bundle/index.js\";\n\n  // `/` should be present at the end if `scriptDirectory` is not empty\n  var scriptDirectory = '';\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory)\n    }\n    return scriptDirectory + path\n  }\n\n  // Hooks that are implemented differently in different runtime environments.\n  var readAsync;\n\n  // Note that this includes Node.js workers when relevant (pthreads is enabled).\n  // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n  // ENVIRONMENT_IS_NODE.\n  {\n    try {\n      scriptDirectory = new URL('.', _scriptName).href; // includes trailing slash\n    } catch {\n      // Must be a `blob:` or `data:` URL (e.g. `blob:http://site.com/etc/etc`), we cannot\n      // infer anything from them.\n    }\n\n    {\n      // include: web_or_worker_shell_read.js\n      readAsync = async (url) => {\n        var response = await fetch(url, { credentials: 'same-origin' });\n        if (response.ok) {\n          return response.arrayBuffer()\n        }\n        throw new Error(response.status + ' : ' + response.url)\n      };\n      // end include: web_or_worker_shell_read.js\n    }\n  }\n\n  var out = console.log.bind(console);\n  var err = console.error.bind(console);\n\n  // end include: shell.js\n\n  // include: preamble.js\n  // === Preamble library stuff ===\n\n  // Documentation for the public APIs defined in this file must be updated in:\n  //    site/source/docs/api_reference/preamble.js.rst\n  // A prebuilt local version of the documentation is available at:\n  //    site/build/text/docs/api_reference/preamble.js.txt\n  // You can also build docs locally as HTML or other formats in site/\n  // An online HTML version (which may be of a different version of Emscripten)\n  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n  var wasmBinary;\n\n  // Wasm globals\n\n  //========================================\n  // Runtime essentials\n  //========================================\n\n  // whether we are quitting the application. no code should run after this.\n  // set in exit() and abort()\n  var ABORT = false;\n\n  // include: runtime_common.js\n  // include: runtime_stack_check.js\n  // end include: runtime_stack_check.js\n  // include: runtime_exceptions.js\n  // end include: runtime_exceptions.js\n  // include: runtime_debug.js\n  // end include: runtime_debug.js\n  var readyPromiseResolve, readyPromiseReject;\n\n  // Memory management\n\n  var wasmMemory;\n\n  var /** @type {!Int8Array} */\n    HEAP8,\n    /** @type {!Uint8Array} */\n    HEAPU8,\n    /** @type {!Int16Array} */\n    HEAP16,\n    /** @type {!Uint16Array} */\n    HEAPU16,\n    /** @type {!Int32Array} */\n    HEAP32,\n    /** @type {!Uint32Array} */\n    HEAPU32,\n    /** @type {!Float32Array} */\n    HEAPF32,\n    /** @type {!Float64Array} */\n    HEAPF64;\n\n  // BigInt64Array type is not correctly defined in closure\n  var /** not-@type {!BigInt64Array} */\n    HEAP64,\n    /* BigUint64Array type is not correctly defined in closure\n/** not-@type {!BigUint64Array} */\n    HEAPU64;\n\n  var runtimeInitialized = false;\n\n  function updateMemoryViews() {\n    var b = wasmMemory.buffer;\n    HEAP8 = new Int8Array(b);\n    HEAP16 = new Int16Array(b);\n    HEAPU8 = new Uint8Array(b);\n    HEAPU16 = new Uint16Array(b);\n    HEAP32 = new Int32Array(b);\n    HEAPU32 = new Uint32Array(b);\n    HEAPF32 = new Float32Array(b);\n    HEAPF64 = new Float64Array(b);\n    HEAP64 = new BigInt64Array(b);\n    HEAPU64 = new BigUint64Array(b);\n  }\n\n  function initRuntime() {\n    runtimeInitialized = true;\n\n    // No ATINITS hooks\n\n    wasmExports['__wasm_call_ctors']();\n\n    // No ATPOSTCTORS hooks\n  }\n\n  // A counter of dependencies for calling run(). If we need to\n  // do asynchronous work before running, increment this and\n  // decrement it. Incrementing must happen in a place like\n  // Module.preRun (used by emcc to add file preloading).\n  // Note that you can add dependencies in preRun, even though\n  // it happens right before run - run will be postponed until\n  // the dependencies are met.\n  var runDependencies = 0;\n  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n  function addRunDependency(id) {\n    runDependencies++;\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n\n    if (runDependencies == 0) {\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback(); // can add another dependenciesFulfilled\n      }\n    }\n  }\n\n  /** @param {string|number=} what */\n  function abort(what) {\n    what = 'Aborted(' + what + ')';\n    // TODO(sbc): Should we remove printing and leave it up to whoever\n    // catches the exception?\n    err(what);\n\n    ABORT = true;\n\n    what += '. Build with -sASSERTIONS for more info.';\n\n    // Use a wasm runtime error, because a JS error might be seen as a foreign\n    // exception, which means we'd run destructors on it. We need the error to\n    // simply make the program stop.\n    // FIXME This approach does not work in Wasm EH because it currently does not assume\n    // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n    // a trap or not based on a hidden field within the object. So at the moment\n    // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n    // allows this in the wasm spec.\n\n    // Suppress closure compiler warning here. Closure compiler's builtin extern\n    // definition for WebAssembly.RuntimeError claims it takes no arguments even\n    // though it can.\n    // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n    /** @suppress {checkTypes} */\n    var e = new WebAssembly.RuntimeError(what);\n\n    readyPromiseReject?.(e);\n    // Throw the error whether or not MODULARIZE is set because abort is used\n    // in code paths apart from instantiation where an exception is expected\n    // to be thrown when abort is called.\n    throw e\n  }\n\n  var wasmBinaryFile;\n\n  function findWasmBinary() {\n    if (Module['locateFile']) {\n      return locateFile('MediaInfoModule.wasm')\n    }\n    // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n    return /* asset import */ new __webpack_require__.U(__webpack_require__(/*! MediaInfoModule.wasm */ \"(pages-dir-browser)/./public/System/mediainfo.js/MediaInfoModule.wasm\")).href\n  }\n\n  function getBinarySync(file) {\n    throw 'both async and sync fetching of the wasm failed'\n  }\n\n  async function getWasmBinary(binaryFile) {\n    // If we don't have the binary yet, load it asynchronously using readAsync.\n    {\n      // Fetch the binary using readAsync\n      try {\n        var response = await readAsync(binaryFile);\n        return new Uint8Array(response)\n      } catch {\n        // Fall back to getBinarySync below;\n      }\n    }\n\n    // Otherwise, getBinarySync should be able to get it synchronously\n    return getBinarySync()\n  }\n\n  async function instantiateArrayBuffer(binaryFile, imports) {\n    try {\n      var binary = await getWasmBinary(binaryFile);\n      var instance = await WebAssembly.instantiate(binary, imports);\n      return instance\n    } catch (reason) {\n      err(`failed to asynchronously prepare wasm: ${reason}`);\n\n      abort(reason);\n    }\n  }\n\n  async function instantiateAsync(binary, binaryFile, imports) {\n    {\n      try {\n        var response = fetch(binaryFile, { credentials: 'same-origin' });\n        var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n        return instantiationResult\n      } catch (reason) {\n        // We expect the most common failure cause to be a bad MIME type for the binary,\n        // in which case falling back to ArrayBuffer instantiation should work.\n        err(`wasm streaming compile failed: ${reason}`);\n        err('falling back to ArrayBuffer instantiation');\n        // fall back of instantiateArrayBuffer below\n      }\n    }\n    return instantiateArrayBuffer(binaryFile, imports)\n  }\n\n  function getWasmImports() {\n    // prepare imports\n    return {\n      env: wasmImports,\n      wasi_snapshot_preview1: wasmImports,\n    }\n  }\n\n  // Create the wasm instance.\n  // Receives the wasm imports, returns the exports.\n  async function createWasm() {\n    // Load the wasm module and create an instance of using native support in the JS engine.\n    // handle a generated wasm instance, receiving its exports and\n    // performing other necessary setup\n    /** @param {WebAssembly.Module=} module*/\n    function receiveInstance(instance, module) {\n      wasmExports = instance.exports;\n\n      wasmMemory = wasmExports['memory'];\n\n      updateMemoryViews();\n\n      wasmTable = wasmExports['__indirect_function_table'];\n\n      assignWasmExports(wasmExports);\n      removeRunDependency();\n      return wasmExports\n    }\n    // wait for the pthread pool (if any)\n    addRunDependency();\n\n    // Prefer streaming instantiation if available.\n    function receiveInstantiationResult(result) {\n      // 'result' is a ResultObject object which has both the module and instance.\n      // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n      // When the regression is fixed, can restore the above PTHREADS-enabled path.\n      return receiveInstance(result['instance'])\n    }\n\n    var info = getWasmImports();\n\n    wasmBinaryFile ??= findWasmBinary();\n    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n    var exports = receiveInstantiationResult(result);\n    return exports\n  }\n\n  var __abort_js = () => abort('');\n\n  var AsciiToString = (ptr) => {\n    var str = '';\n    while (1) {\n      var ch = HEAPU8[ptr++];\n      if (!ch) return str\n      str += String.fromCharCode(ch);\n    }\n  };\n\n  var awaitingDependencies = {};\n\n  var registeredTypes = {};\n\n  var typeDependencies = {};\n\n  var BindingError = class BindingError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = 'BindingError';\n    }\n  };\n  var throwBindingError = (message) => {\n    throw new BindingError(message)\n  };\n  /** @param {Object=} options */\n  function sharedRegisterType(rawType, registeredInstance, options = {}) {\n    var name = registeredInstance.name;\n    if (!rawType) {\n      throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n    }\n    if (registeredTypes.hasOwnProperty(rawType)) {\n      if (options.ignoreDuplicateRegistrations) {\n        return\n      } else {\n        throwBindingError(`Cannot register type '${name}' twice`);\n      }\n    }\n\n    registeredTypes[rawType] = registeredInstance;\n    delete typeDependencies[rawType];\n\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\n      var callbacks = awaitingDependencies[rawType];\n      delete awaitingDependencies[rawType];\n      callbacks.forEach((cb) => cb());\n    }\n  }\n  /** @param {Object=} options */\n  function registerType(rawType, registeredInstance, options = {}) {\n    return sharedRegisterType(rawType, registeredInstance, options)\n  }\n\n  var integerReadValueFromPointer = (name, width, signed) => {\n    // integers are quite common, so generate very specialized functions\n    switch (width) {\n      case 1:\n        return signed ? (pointer) => HEAP8[pointer] : (pointer) => HEAPU8[pointer]\n      case 2:\n        return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1]\n      case 4:\n        return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2]\n      case 8:\n        return signed ? (pointer) => HEAP64[pointer >> 3] : (pointer) => HEAPU64[pointer >> 3]\n      default:\n        throw new TypeError(`invalid integer width (${width}): ${name}`)\n    }\n  };\n  /** @suppress {globalThis} */\n  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {\n    name = AsciiToString(name);\n\n    const isUnsignedType = minRange === 0n;\n\n    let fromWireType = (value) => value;\n    if (isUnsignedType) {\n      // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.\n      const bitSize = size * 8;\n      fromWireType = (value) => {\n        return BigInt.asUintN(bitSize, value)\n      };\n      maxRange = fromWireType(maxRange);\n    }\n\n    registerType(primitiveType, {\n      name,\n      fromWireType: fromWireType,\n      toWireType: (destructors, value) => {\n        if (typeof value == 'number') {\n          value = BigInt(value);\n        }\n        return value\n      },\n      readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType),\n      destructorFunction: null, // This type does not need a destructor\n    });\n  };\n\n  /** @suppress {globalThis} */\n  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\n    name = AsciiToString(name);\n    registerType(rawType, {\n      name,\n      fromWireType: function (wt) {\n        // ambiguous emscripten ABI: sometimes return values are\n        // true or false, and sometimes integers (0 or 1)\n        return !!wt\n      },\n      toWireType: function (destructors, o) {\n        return o ? trueValue : falseValue\n      },\n      readValueFromPointer: function (pointer) {\n        return this.fromWireType(HEAPU8[pointer])\n      },\n      destructorFunction: null, // This type does not need a destructor\n    });\n  };\n\n  var shallowCopyInternalPointer = (o) => {\n    return {\n      count: o.count,\n      deleteScheduled: o.deleteScheduled,\n      preservePointerOnDelete: o.preservePointerOnDelete,\n      ptr: o.ptr,\n      ptrType: o.ptrType,\n      smartPtr: o.smartPtr,\n      smartPtrType: o.smartPtrType,\n    }\n  };\n\n  var throwInstanceAlreadyDeleted = (obj) => {\n    function getInstanceTypeName(handle) {\n      return handle.$$.ptrType.registeredClass.name\n    }\n    throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n  };\n\n  var finalizationRegistry = false;\n\n  var detachFinalizer = (handle) => {};\n\n  var runDestructor = ($$) => {\n    if ($$.smartPtr) {\n      $$.smartPtrType.rawDestructor($$.smartPtr);\n    } else {\n      $$.ptrType.registeredClass.rawDestructor($$.ptr);\n    }\n  };\n  var releaseClassHandle = ($$) => {\n    $$.count.value -= 1;\n    var toDelete = 0 === $$.count.value;\n    if (toDelete) {\n      runDestructor($$);\n    }\n  };\n  var attachFinalizer = (handle) => {\n    if ('undefined' === typeof FinalizationRegistry) {\n      attachFinalizer = (handle) => handle;\n      return handle\n    }\n    // If the running environment has a FinalizationRegistry (see\n    // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n    // for class handles.  We check for the presence of FinalizationRegistry\n    // at run-time, not build-time.\n    finalizationRegistry = new FinalizationRegistry((info) => {\n      releaseClassHandle(info.$$);\n    });\n    attachFinalizer = (handle) => {\n      var $$ = handle.$$;\n      var hasSmartPtr = !!$$.smartPtr;\n      if (hasSmartPtr) {\n        // We should not call the destructor on raw pointers in case other code expects the pointee to live\n        var info = { $$: $$ };\n        finalizationRegistry.register(handle, info, handle);\n      }\n      return handle\n    };\n    detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\n    return attachFinalizer(handle)\n  };\n  var init_ClassHandle = () => {\n    let proto = ClassHandle.prototype;\n\n    Object.assign(proto, {\n      isAliasOf(other) {\n        if (!(this instanceof ClassHandle)) {\n          return false\n        }\n        if (!(other instanceof ClassHandle)) {\n          return false\n        }\n\n        var leftClass = this.$$.ptrType.registeredClass;\n        var left = this.$$.ptr;\n        other.$$ = /** @type {Object} */ (other.$$);\n        var rightClass = other.$$.ptrType.registeredClass;\n        var right = other.$$.ptr;\n\n        while (leftClass.baseClass) {\n          left = leftClass.upcast(left);\n          leftClass = leftClass.baseClass;\n        }\n\n        while (rightClass.baseClass) {\n          right = rightClass.upcast(right);\n          rightClass = rightClass.baseClass;\n        }\n\n        return leftClass === rightClass && left === right\n      },\n\n      clone() {\n        if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n        }\n\n        if (this.$$.preservePointerOnDelete) {\n          this.$$.count.value += 1;\n          return this\n        } else {\n          var clone = attachFinalizer(\n            Object.create(Object.getPrototypeOf(this), {\n              $$: {\n                value: shallowCopyInternalPointer(this.$$),\n              },\n            })\n          );\n\n          clone.$$.count.value += 1;\n          clone.$$.deleteScheduled = false;\n          return clone\n        }\n      },\n\n      delete() {\n        if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n        }\n\n        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n          throwBindingError('Object already scheduled for deletion');\n        }\n\n        detachFinalizer(this);\n        releaseClassHandle(this.$$);\n\n        if (!this.$$.preservePointerOnDelete) {\n          this.$$.smartPtr = undefined;\n          this.$$.ptr = undefined;\n        }\n      },\n\n      isDeleted() {\n        return !this.$$.ptr\n      },\n\n      deleteLater() {\n        if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n        }\n        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n          throwBindingError('Object already scheduled for deletion');\n        }\n        this.$$.deleteScheduled = true;\n        return this\n      },\n    });\n\n    // Support `using ...` from https://github.com/tc39/proposal-explicit-resource-management.\n    const symbolDispose = Symbol.dispose;\n    if (symbolDispose) {\n      proto[symbolDispose] = proto['delete'];\n    }\n  };\n  /** @constructor */\n  function ClassHandle() {}\n\n  var createNamedFunction = (name, func) => Object.defineProperty(func, 'name', { value: name });\n\n  var registeredPointers = {};\n\n  var ensureOverloadTable = (proto, methodName, humanName) => {\n    if (undefined === proto[methodName].overloadTable) {\n      var prevFunc = proto[methodName];\n      // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n      proto[methodName] = function (...args) {\n        // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n        if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {\n          throwBindingError(\n            `Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`\n          );\n        }\n        return proto[methodName].overloadTable[args.length].apply(this, args)\n      };\n      // Move the previous function into the overload table.\n      proto[methodName].overloadTable = [];\n      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n    }\n  };\n\n  /** @param {number=} numArguments */\n  var exposePublicSymbol = (name, value, numArguments) => {\n    if (Module.hasOwnProperty(name)) {\n      {\n        throwBindingError(`Cannot register public name '${name}' twice`);\n      }\n\n      // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n      // that routes between the two.\n      ensureOverloadTable(Module, name, name);\n      if (Module[name].overloadTable.hasOwnProperty(numArguments)) {\n        throwBindingError(\n          `Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`\n        );\n      }\n      // Add the new function into the overload table.\n      Module[name].overloadTable[numArguments] = value;\n    } else {\n      Module[name] = value;\n      Module[name].argCount = numArguments;\n    }\n  };\n\n  var char_0 = 48;\n\n  var char_9 = 57;\n  var makeLegalFunctionName = (name) => {\n    name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n    var f = name.charCodeAt(0);\n    if (f >= char_0 && f <= char_9) {\n      return `_${name}`\n    }\n    return name\n  };\n\n  /** @constructor */\n  function RegisteredClass(\n    name,\n    constructor,\n    instancePrototype,\n    rawDestructor,\n    baseClass,\n    getActualType,\n    upcast,\n    downcast\n  ) {\n    this.name = name;\n    this.constructor = constructor;\n    this.instancePrototype = instancePrototype;\n    this.rawDestructor = rawDestructor;\n    this.baseClass = baseClass;\n    this.getActualType = getActualType;\n    this.upcast = upcast;\n    this.downcast = downcast;\n    this.pureVirtualFunctions = [];\n  }\n\n  var upcastPointer = (ptr, ptrClass, desiredClass) => {\n    while (ptrClass !== desiredClass) {\n      if (!ptrClass.upcast) {\n        throwBindingError(\n          `Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`\n        );\n      }\n      ptr = ptrClass.upcast(ptr);\n      ptrClass = ptrClass.baseClass;\n    }\n    return ptr\n  };\n\n  var embindRepr = (v) => {\n    if (v === null) {\n      return 'null'\n    }\n    var t = typeof v;\n    if (t === 'object' || t === 'array' || t === 'function') {\n      return v.toString()\n    } else {\n      return '' + v\n    }\n  };\n  /** @suppress {globalThis} */\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError(`null is not a valid ${this.name}`);\n      }\n      return 0\n    }\n\n    if (!handle.$$) {\n      throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n    return ptr\n  }\n\n  /** @suppress {globalThis} */\n  function genericPointerToWireType(destructors, handle) {\n    var ptr;\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError(`null is not a valid ${this.name}`);\n      }\n\n      if (this.isSmartPointer) {\n        ptr = this.rawConstructor();\n        if (destructors !== null) {\n          destructors.push(this.rawDestructor, ptr);\n        }\n        return ptr\n      } else {\n        return 0\n      }\n    }\n\n    if (!handle || !handle.$$) {\n      throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    }\n    if (!this.isConst && handle.$$.ptrType.isConst) {\n      throwBindingError(\n        `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`\n      );\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\n    if (this.isSmartPointer) {\n      // TODO: this is not strictly true\n      // We could support BY_EMVAL conversions from raw pointers to smart pointers\n      // because the smart pointer can hold a reference to the handle\n      if (undefined === handle.$$.smartPtr) {\n        throwBindingError('Passing raw pointer to smart pointer is illegal');\n      }\n\n      switch (this.sharingPolicy) {\n        case 0: // NONE\n          // no upcasting\n          if (handle.$$.smartPtrType === this) {\n            ptr = handle.$$.smartPtr;\n          } else {\n            throwBindingError(\n              `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`\n            );\n          }\n          break\n\n        case 1: // INTRUSIVE\n          ptr = handle.$$.smartPtr;\n          break\n\n        case 2: // BY_EMVAL\n          if (handle.$$.smartPtrType === this) {\n            ptr = handle.$$.smartPtr;\n          } else {\n            var clonedHandle = handle['clone']();\n            ptr = this.rawShare(\n              ptr,\n              Emval.toHandle(() => clonedHandle['delete']())\n            );\n            if (destructors !== null) {\n              destructors.push(this.rawDestructor, ptr);\n            }\n          }\n          break\n\n        default:\n          throwBindingError('Unsupporting sharing policy');\n      }\n    }\n    return ptr\n  }\n\n  /** @suppress {globalThis} */\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError(`null is not a valid ${this.name}`);\n      }\n      return 0\n    }\n\n    if (!handle.$$) {\n      throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    }\n    if (handle.$$.ptrType.isConst) {\n      throwBindingError(\n        `Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`\n      );\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n    return ptr\n  }\n\n  /** @suppress {globalThis} */\n  function readPointer(pointer) {\n    return this.fromWireType(HEAPU32[pointer >> 2])\n  }\n\n  var downcastPointer = (ptr, ptrClass, desiredClass) => {\n    if (ptrClass === desiredClass) {\n      return ptr\n    }\n    if (undefined === desiredClass.baseClass) {\n      return null // no conversion\n    }\n\n    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n    if (rv === null) {\n      return null\n    }\n    return desiredClass.downcast(rv)\n  };\n\n  var registeredInstances = {};\n\n  var getBasestPointer = (class_, ptr) => {\n    if (ptr === undefined) {\n      throwBindingError('ptr should not be undefined');\n    }\n    while (class_.baseClass) {\n      ptr = class_.upcast(ptr);\n      class_ = class_.baseClass;\n    }\n    return ptr\n  };\n  var getInheritedInstance = (class_, ptr) => {\n    ptr = getBasestPointer(class_, ptr);\n    return registeredInstances[ptr]\n  };\n\n  var InternalError = class InternalError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = 'InternalError';\n    }\n  };\n  var throwInternalError = (message) => {\n    throw new InternalError(message)\n  };\n\n  var makeClassHandle = (prototype, record) => {\n    if (!record.ptrType || !record.ptr) {\n      throwInternalError('makeClassHandle requires ptr and ptrType');\n    }\n    var hasSmartPtrType = !!record.smartPtrType;\n    var hasSmartPtr = !!record.smartPtr;\n    if (hasSmartPtrType !== hasSmartPtr) {\n      throwInternalError('Both smartPtrType and smartPtr must be specified');\n    }\n    record.count = { value: 1 };\n    return attachFinalizer(\n      Object.create(prototype, {\n        $$: {\n          value: record,\n          writable: true,\n        },\n      })\n    )\n  };\n  /** @suppress {globalThis} */\n  function RegisteredPointer_fromWireType(ptr) {\n    // ptr is a raw pointer (or a raw smartpointer)\n\n    // rawPointer is a maybe-null raw pointer\n    var rawPointer = this.getPointee(ptr);\n    if (!rawPointer) {\n      this.destructor(ptr);\n      return null\n    }\n\n    var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n    if (undefined !== registeredInstance) {\n      // JS object has been neutered, time to repopulate it\n      if (0 === registeredInstance.$$.count.value) {\n        registeredInstance.$$.ptr = rawPointer;\n        registeredInstance.$$.smartPtr = ptr;\n        return registeredInstance['clone']()\n      } else {\n        // else, just increment reference count on existing object\n        // it already has a reference to the smart pointer\n        var rv = registeredInstance['clone']();\n        this.destructor(ptr);\n        return rv\n      }\n    }\n\n    function makeDefaultHandle() {\n      if (this.isSmartPointer) {\n        return makeClassHandle(this.registeredClass.instancePrototype, {\n          ptrType: this.pointeeType,\n          ptr: rawPointer,\n          smartPtrType: this,\n          smartPtr: ptr,\n        })\n      } else {\n        return makeClassHandle(this.registeredClass.instancePrototype, {\n          ptrType: this,\n          ptr,\n        })\n      }\n    }\n\n    var actualType = this.registeredClass.getActualType(rawPointer);\n    var registeredPointerRecord = registeredPointers[actualType];\n    if (!registeredPointerRecord) {\n      return makeDefaultHandle.call(this)\n    }\n\n    var toType;\n    if (this.isConst) {\n      toType = registeredPointerRecord.constPointerType;\n    } else {\n      toType = registeredPointerRecord.pointerType;\n    }\n    var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n    if (dp === null) {\n      return makeDefaultHandle.call(this)\n    }\n    if (this.isSmartPointer) {\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\n        ptrType: toType,\n        ptr: dp,\n        smartPtrType: this,\n        smartPtr: ptr,\n      })\n    } else {\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\n        ptrType: toType,\n        ptr: dp,\n      })\n    }\n  }\n  var init_RegisteredPointer = () => {\n    Object.assign(RegisteredPointer.prototype, {\n      getPointee(ptr) {\n        if (this.rawGetPointee) {\n          ptr = this.rawGetPointee(ptr);\n        }\n        return ptr\n      },\n      destructor(ptr) {\n        this.rawDestructor?.(ptr);\n      },\n      readValueFromPointer: readPointer,\n      fromWireType: RegisteredPointer_fromWireType,\n    });\n  };\n  /** @constructor\n      @param {*=} pointeeType,\n      @param {*=} sharingPolicy,\n      @param {*=} rawGetPointee,\n      @param {*=} rawConstructor,\n      @param {*=} rawShare,\n      @param {*=} rawDestructor,\n       */\n  function RegisteredPointer(\n    name,\n    registeredClass,\n    isReference,\n    isConst,\n\n    // smart pointer properties\n    isSmartPointer,\n    pointeeType,\n    sharingPolicy,\n    rawGetPointee,\n    rawConstructor,\n    rawShare,\n    rawDestructor\n  ) {\n    this.name = name;\n    this.registeredClass = registeredClass;\n    this.isReference = isReference;\n    this.isConst = isConst;\n\n    // smart pointer properties\n    this.isSmartPointer = isSmartPointer;\n    this.pointeeType = pointeeType;\n    this.sharingPolicy = sharingPolicy;\n    this.rawGetPointee = rawGetPointee;\n    this.rawConstructor = rawConstructor;\n    this.rawShare = rawShare;\n    this.rawDestructor = rawDestructor;\n\n    if (!isSmartPointer && registeredClass.baseClass === undefined) {\n      if (isConst) {\n        this.toWireType = constNoSmartPtrRawPointerToWireType;\n        this.destructorFunction = null;\n      } else {\n        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;\n        this.destructorFunction = null;\n      }\n    } else {\n      this.toWireType = genericPointerToWireType;\n      // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\n      // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\n      // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\n      //       craftInvokerFunction altogether.\n    }\n  }\n\n  /** @param {number=} numArguments */\n  var replacePublicSymbol = (name, value, numArguments) => {\n    if (!Module.hasOwnProperty(name)) {\n      throwInternalError('Replacing nonexistent public symbol');\n    }\n    // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n    if (undefined !== Module[name].overloadTable && undefined !== numArguments) ; else {\n      Module[name] = value;\n      Module[name].argCount = numArguments;\n    }\n  };\n\n  var wasmTableMirror = [];\n\n  /** @type {WebAssembly.Table} */\n  var wasmTable;\n  var getWasmTableEntry = (funcPtr) => {\n    var func = wasmTableMirror[funcPtr];\n    if (!func) {\n      /** @suppress {checkTypes} */\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n    }\n    return func\n  };\n  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {\n    signature = AsciiToString(signature);\n\n    function makeDynCaller() {\n      var rtn = getWasmTableEntry(rawFunction);\n      return rtn\n    }\n\n    var fp = makeDynCaller();\n    if (typeof fp != 'function') {\n      throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n    }\n    return fp\n  };\n\n  class UnboundTypeError extends Error {}\n\n  var getTypeName = (type) => {\n    var ptr = ___getTypeName(type);\n    var rv = AsciiToString(ptr);\n    _free(ptr);\n    return rv\n  };\n  var throwUnboundTypeError = (message, types) => {\n    var unboundTypes = [];\n    var seen = {};\n    function visit(type) {\n      if (seen[type]) {\n        return\n      }\n      if (registeredTypes[type]) {\n        return\n      }\n      if (typeDependencies[type]) {\n        typeDependencies[type].forEach(visit);\n        return\n      }\n      unboundTypes.push(type);\n      seen[type] = true;\n    }\n    types.forEach(visit);\n\n    throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']))\n  };\n\n  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n    myTypes.forEach((type) => (typeDependencies[type] = dependentTypes));\n\n    function onComplete(typeConverters) {\n      var myTypeConverters = getTypeConverters(typeConverters);\n      if (myTypeConverters.length !== myTypes.length) {\n        throwInternalError('Mismatched type converter count');\n      }\n      for (var i = 0; i < myTypes.length; ++i) {\n        registerType(myTypes[i], myTypeConverters[i]);\n      }\n    }\n\n    var typeConverters = new Array(dependentTypes.length);\n    var unregisteredTypes = [];\n    var registered = 0;\n    dependentTypes.forEach((dt, i) => {\n      if (registeredTypes.hasOwnProperty(dt)) {\n        typeConverters[i] = registeredTypes[dt];\n      } else {\n        unregisteredTypes.push(dt);\n        if (!awaitingDependencies.hasOwnProperty(dt)) {\n          awaitingDependencies[dt] = [];\n        }\n        awaitingDependencies[dt].push(() => {\n          typeConverters[i] = registeredTypes[dt];\n          ++registered;\n          if (registered === unregisteredTypes.length) {\n            onComplete(typeConverters);\n          }\n        });\n      }\n    });\n    if (0 === unregisteredTypes.length) {\n      onComplete(typeConverters);\n    }\n  };\n  var __embind_register_class = (\n    rawType,\n    rawPointerType,\n    rawConstPointerType,\n    baseClassRawType,\n    getActualTypeSignature,\n    getActualType,\n    upcastSignature,\n    upcast,\n    downcastSignature,\n    downcast,\n    name,\n    destructorSignature,\n    rawDestructor\n  ) => {\n    name = AsciiToString(name);\n    getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n    upcast &&= embind__requireFunction(upcastSignature, upcast);\n    downcast &&= embind__requireFunction(downcastSignature, downcast);\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n    var legalFunctionName = makeLegalFunctionName(name);\n\n    exposePublicSymbol(legalFunctionName, function () {\n      // this code cannot run if baseClassRawType is zero\n      throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\n    });\n\n    whenDependentTypesAreResolved(\n      [rawType, rawPointerType, rawConstPointerType],\n      baseClassRawType ? [baseClassRawType] : [],\n      (base) => {\n        base = base[0];\n\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n\n        var constructor = createNamedFunction(name, function (...args) {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(`Use 'new' to construct ${name}`)\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(`${name} has no accessible constructor`)\n          }\n          var body = registeredClass.constructor_body[args.length];\n          if (undefined === body) {\n            throw new BindingError(\n              `Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`\n            )\n          }\n          return body.apply(this, args)\n        });\n\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: { value: constructor },\n        });\n\n        constructor.prototype = instancePrototype;\n\n        var registeredClass = new RegisteredClass(\n          name,\n          constructor,\n          instancePrototype,\n          rawDestructor,\n          baseClass,\n          getActualType,\n          upcast,\n          downcast\n        );\n\n        if (registeredClass.baseClass) {\n          // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.\n          registeredClass.baseClass.__derivedClasses ??= [];\n\n          registeredClass.baseClass.__derivedClasses.push(registeredClass);\n        }\n\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n\n        var pointerConverter = new RegisteredPointer(\n          name + '*',\n          registeredClass,\n          false,\n          false,\n          false\n        );\n\n        var constPointerConverter = new RegisteredPointer(\n          name + ' const*',\n          registeredClass,\n          false,\n          true,\n          false\n        );\n\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter,\n        };\n\n        replacePublicSymbol(legalFunctionName, constructor);\n\n        return [referenceConverter, pointerConverter, constPointerConverter]\n      }\n    );\n  };\n\n  var heap32VectorToArray = (count, firstElement) => {\n    var array = [];\n    for (var i = 0; i < count; i++) {\n      // TODO(https://github.com/emscripten-core/emscripten/issues/17310):\n      // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\n      array.push(HEAPU32[(firstElement + i * 4) >> 2]);\n    }\n    return array\n  };\n\n  var runDestructors = (destructors) => {\n    while (destructors.length) {\n      var ptr = destructors.pop();\n      var del = destructors.pop();\n      del(ptr);\n    }\n  };\n\n  function usesDestructorStack(argTypes) {\n    // Skip return value at index 0 - it's not deleted here.\n    for (var i = 1; i < argTypes.length; ++i) {\n      // The type does not define a destructor function - must use dynamic stack\n      if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n        return true\n      }\n    }\n    return false\n  }\n\n  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\n    var needsDestructorStack = usesDestructorStack(argTypes);\n    var argCount = argTypes.length - 2;\n    var argsList = [];\n    var argsListWired = ['fn'];\n    if (isClassMethodFunc) {\n      argsListWired.push('thisWired');\n    }\n    for (var i = 0; i < argCount; ++i) {\n      argsList.push(`arg${i}`);\n      argsListWired.push(`arg${i}Wired`);\n    }\n    argsList = argsList.join(',');\n    argsListWired = argsListWired.join(',');\n\n    var invokerFnBody = `return function (${argsList}) {\\n`;\n\n    if (needsDestructorStack) {\n      invokerFnBody += 'var destructors = [];\\n';\n    }\n\n    var dtorStack = needsDestructorStack ? 'destructors' : 'null';\n    var args1 = [\n      'humanName',\n      'throwBindingError',\n      'invoker',\n      'fn',\n      'runDestructors',\n      'fromRetWire',\n      'toClassParamWire',\n    ];\n\n    if (isClassMethodFunc) {\n      invokerFnBody += `var thisWired = toClassParamWire(${dtorStack}, this);\\n`;\n    }\n\n    for (var i = 0; i < argCount; ++i) {\n      var argName = `toArg${i}Wire`;\n      invokerFnBody += `var arg${i}Wired = ${argName}(${dtorStack}, arg${i});\\n`;\n      args1.push(argName);\n    }\n\n    invokerFnBody += (returns || isAsync ? 'var rv = ' : '') + `invoker(${argsListWired});\\n`;\n\n    if (needsDestructorStack) {\n      invokerFnBody += 'runDestructors(destructors);\\n';\n    } else {\n      for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n        // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n        var paramName = i === 1 ? 'thisWired' : 'arg' + (i - 2) + 'Wired';\n        if (argTypes[i].destructorFunction !== null) {\n          invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\n          args1.push(`${paramName}_dtor`);\n        }\n      }\n    }\n\n    if (returns) {\n      invokerFnBody += 'var ret = fromRetWire(rv);\\n' + 'return ret;\\n';\n    }\n\n    invokerFnBody += '}\\n';\n\n    return new Function(args1, invokerFnBody)\n  }\n  function craftInvokerFunction(\n    humanName,\n    argTypes,\n    classType,\n    cppInvokerFunc,\n    cppTargetFunc,\n    /** boolean= */ isAsync\n  ) {\n    // humanName: a human-readable string name for the function to be generated.\n    // argTypes: An array that contains the embind type objects for all types in the function signature.\n    //    argTypes[0] is the type object for the function return value.\n    //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n    //    argTypes[2...] are the actual function parameters.\n    // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n    // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n    // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n    // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\n    var argCount = argTypes.length;\n\n    if (argCount < 2) {\n      throwBindingError(\n        \"argTypes array size mismatch! Must at least get return value and 'this' types!\"\n      );\n    }\n\n    var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n\n    // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n    // TODO: This omits argument count check - enable only at -O3 or similar.\n    //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n    //       return FUNCTION_TABLE[fn];\n    //    }\n\n    // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n    // TODO: Remove this completely once all function invokers are being dynamically generated.\n    var needsDestructorStack = usesDestructorStack(argTypes);\n\n    var returns = !argTypes[0].isVoid;\n    // Builld the arguments that will be passed into the closure around the invoker\n    // function.\n    var retType = argTypes[0];\n    var instType = argTypes[1];\n    var closureArgs = [\n      humanName,\n      throwBindingError,\n      cppInvokerFunc,\n      cppTargetFunc,\n      runDestructors,\n      retType.fromWireType.bind(retType),\n      instType?.toWireType.bind(instType),\n    ];\n    for (var i = 2; i < argCount; ++i) {\n      var argType = argTypes[i];\n      closureArgs.push(argType.toWireType.bind(argType));\n    }\n    if (!needsDestructorStack) {\n      // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n      for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n        if (argTypes[i].destructorFunction !== null) {\n          closureArgs.push(argTypes[i].destructorFunction);\n        }\n      }\n    }\n\n    let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\n    var invokerFn = invokerFactory(...closureArgs);\n    return createNamedFunction(humanName, invokerFn)\n  }\n  var __embind_register_class_constructor = (\n    rawClassType,\n    argCount,\n    rawArgTypesAddr,\n    invokerSignature,\n    invoker,\n    rawConstructor\n  ) => {\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n    invoker = embind__requireFunction(invokerSignature, invoker);\n\n    whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n      classType = classType[0];\n      var humanName = `constructor ${classType.name}`;\n\n      if (undefined === classType.registeredClass.constructor_body) {\n        classType.registeredClass.constructor_body = [];\n      }\n      if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n        throw new BindingError(\n          `Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`\n        )\n      }\n      classType.registeredClass.constructor_body[argCount - 1] = () => {\n        throwUnboundTypeError(\n          `Cannot construct ${classType.name} due to unbound types`,\n          rawArgTypes\n        );\n      };\n\n      whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n        // Insert empty slot for context type (argTypes[1]).\n        argTypes.splice(1, 0, null);\n        classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(\n          humanName,\n          argTypes,\n          null,\n          invoker,\n          rawConstructor\n        );\n        return []\n      });\n      return []\n    });\n  };\n\n  var getFunctionName = (signature) => {\n    signature = signature.trim();\n    const argsIndex = signature.indexOf('(');\n    if (argsIndex === -1) return signature\n    return signature.slice(0, argsIndex)\n  };\n  var __embind_register_class_function = (\n    rawClassType,\n    methodName,\n    argCount,\n    rawArgTypesAddr, // [ReturnType, ThisType, Args...]\n    invokerSignature,\n    rawInvoker,\n    context,\n    isPureVirtual,\n    isAsync,\n    isNonnullReturn\n  ) => {\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n    methodName = AsciiToString(methodName);\n    methodName = getFunctionName(methodName);\n    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);\n\n    whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n      classType = classType[0];\n      var humanName = `${classType.name}.${methodName}`;\n\n      if (methodName.startsWith('@@')) {\n        methodName = Symbol[methodName.substring(2)];\n      }\n\n      if (isPureVirtual) {\n        classType.registeredClass.pureVirtualFunctions.push(methodName);\n      }\n\n      function unboundTypesHandler() {\n        throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n      }\n\n      var proto = classType.registeredClass.instancePrototype;\n      var method = proto[methodName];\n      if (\n        undefined === method ||\n        (undefined === method.overloadTable &&\n          method.className !== classType.name &&\n          method.argCount === argCount - 2)\n      ) {\n        // This is the first overload to be registered, OR we are replacing a\n        // function in the base class with a function in the derived class.\n        unboundTypesHandler.argCount = argCount - 2;\n        unboundTypesHandler.className = classType.name;\n        proto[methodName] = unboundTypesHandler;\n      } else {\n        // There was an existing function with the same name registered. Set up\n        // a function overload routing table.\n        ensureOverloadTable(proto, methodName, humanName);\n        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n      }\n\n      whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n        var memberFunction = craftInvokerFunction(\n          humanName,\n          argTypes,\n          classType,\n          rawInvoker,\n          context,\n          isAsync\n        );\n\n        // Replace the initial unbound-handler-stub function with the\n        // appropriate member function, now that all types are resolved. If\n        // multiple overloads are registered for this function, the function\n        // goes into an overload table.\n        if (undefined === proto[methodName].overloadTable) {\n          // Set argCount in case an overload is registered later\n          memberFunction.argCount = argCount - 2;\n          proto[methodName] = memberFunction;\n        } else {\n          proto[methodName].overloadTable[argCount - 2] = memberFunction;\n        }\n\n        return []\n      });\n      return []\n    });\n  };\n\n  var emval_freelist = [];\n\n  var emval_handles = [0, 1, , 1, null, 1, true, 1, false, 1];\n  var __emval_decref = (handle) => {\n    if (handle > 9 && 0 === --emval_handles[handle + 1]) {\n      emval_handles[handle] = undefined;\n      emval_freelist.push(handle);\n    }\n  };\n\n  var Emval = {\n    toValue: (handle) => {\n      if (!handle) {\n        throwBindingError(`Cannot use deleted val. handle = ${handle}`);\n      }\n      return emval_handles[handle]\n    },\n    toHandle: (value) => {\n      switch (value) {\n        case undefined:\n          return 2\n        case null:\n          return 4\n        case true:\n          return 6\n        case false:\n          return 8\n        default: {\n          const handle = emval_freelist.pop() || emval_handles.length;\n          emval_handles[handle] = value;\n          emval_handles[handle + 1] = 1;\n          return handle\n        }\n      }\n    },\n  };\n\n  var EmValType = {\n    name: 'emscripten::val',\n    fromWireType: (handle) => {\n      var rv = Emval.toValue(handle);\n      __emval_decref(handle);\n      return rv\n    },\n    toWireType: (destructors, value) => Emval.toHandle(value),\n    readValueFromPointer: readPointer,\n    destructorFunction: null, // This type does not need a destructor\n\n    // TODO: do we need a deleteObject here?  write a test where\n    // emval is passed into JS via an interface\n  };\n  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);\n\n  var floatReadValueFromPointer = (name, width) => {\n    switch (width) {\n      case 4:\n        return function (pointer) {\n          return this.fromWireType(HEAPF32[pointer >> 2])\n        }\n      case 8:\n        return function (pointer) {\n          return this.fromWireType(HEAPF64[pointer >> 3])\n        }\n      default:\n        throw new TypeError(`invalid float width (${width}): ${name}`)\n    }\n  };\n\n  var __embind_register_float = (rawType, name, size) => {\n    name = AsciiToString(name);\n    registerType(rawType, {\n      name,\n      fromWireType: (value) => value,\n      toWireType: (destructors, value) => {\n        // The VM will perform JS to Wasm value conversion, according to the spec:\n        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n        return value\n      },\n      readValueFromPointer: floatReadValueFromPointer(name, size),\n      destructorFunction: null, // This type does not need a destructor\n    });\n  };\n\n  /** @suppress {globalThis} */\n  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\n    name = AsciiToString(name);\n\n    const isUnsignedType = minRange === 0;\n\n    let fromWireType = (value) => value;\n    if (isUnsignedType) {\n      var bitshift = 32 - 8 * size;\n      fromWireType = (value) => (value << bitshift) >>> bitshift;\n      maxRange = fromWireType(maxRange);\n    }\n\n    registerType(primitiveType, {\n      name,\n      fromWireType: fromWireType,\n      toWireType: (destructors, value) => {\n        // The VM will perform JS to Wasm value conversion, according to the spec:\n        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n        return value\n      },\n      readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),\n      destructorFunction: null, // This type does not need a destructor\n    });\n  };\n\n  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\n    var typeMapping = [\n      Int8Array,\n      Uint8Array,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      BigInt64Array,\n      BigUint64Array,\n    ];\n\n    var TA = typeMapping[dataTypeIndex];\n\n    function decodeMemoryView(handle) {\n      var size = HEAPU32[handle >> 2];\n      var data = HEAPU32[(handle + 4) >> 2];\n      return new TA(HEAP8.buffer, data, size)\n    }\n\n    name = AsciiToString(name);\n    registerType(\n      rawType,\n      {\n        name,\n        fromWireType: decodeMemoryView,\n        readValueFromPointer: decodeMemoryView,\n      },\n      {\n        ignoreDuplicateRegistrations: true,\n      }\n    );\n  };\n\n  var __embind_register_smart_ptr = (\n    rawType,\n    rawPointeeType,\n    name,\n    sharingPolicy,\n    getPointeeSignature,\n    rawGetPointee,\n    constructorSignature,\n    rawConstructor,\n    shareSignature,\n    rawShare,\n    destructorSignature,\n    rawDestructor\n  ) => {\n    name = AsciiToString(name);\n    rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\n    rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);\n    rawShare = embind__requireFunction(shareSignature, rawShare);\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n\n    whenDependentTypesAreResolved([rawType], [rawPointeeType], (pointeeType) => {\n      pointeeType = pointeeType[0];\n\n      var registeredPointer = new RegisteredPointer(\n        name,\n        pointeeType.registeredClass,\n        false,\n        false,\n        // smart pointer properties\n        true,\n        pointeeType,\n        sharingPolicy,\n        rawGetPointee,\n        rawConstructor,\n        rawShare,\n        rawDestructor\n      );\n      return [registeredPointer]\n    });\n  };\n\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n    // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n    // undefined and false each don't write out any bytes.\n    if (!(maxBytesToWrite > 0)) return 0\n\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n    for (var i = 0; i < str.length; ++i) {\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n      // and https://www.ietf.org/rfc/rfc2279.txt\n      // and https://tools.ietf.org/html/rfc3629\n      var u = str.codePointAt(i);\n      if (u <= 0x7f) {\n        if (outIdx >= endIdx) break\n        heap[outIdx++] = u;\n      } else if (u <= 0x7ff) {\n        if (outIdx + 1 >= endIdx) break\n        heap[outIdx++] = 0xc0 | (u >> 6);\n        heap[outIdx++] = 0x80 | (u & 63);\n      } else if (u <= 0xffff) {\n        if (outIdx + 2 >= endIdx) break\n        heap[outIdx++] = 0xe0 | (u >> 12);\n        heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n        heap[outIdx++] = 0x80 | (u & 63);\n      } else {\n        if (outIdx + 3 >= endIdx) break\n        heap[outIdx++] = 0xf0 | (u >> 18);\n        heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n        heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n        heap[outIdx++] = 0x80 | (u & 63);\n        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n        // We need to manually skip over the second code unit for correct iteration.\n        i++;\n      }\n    }\n    // Null-terminate the pointer to the buffer.\n    heap[outIdx] = 0;\n    return outIdx - startIdx\n  };\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\n  };\n\n  var lengthBytesUTF8 = (str) => {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n      // unit, not a Unicode code point of the character! So decode\n      // UTF16->UTF32->UTF8.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var c = str.charCodeAt(i); // possibly a lead surrogate\n      if (c <= 0x7f) {\n        len++;\n      } else if (c <= 0x7ff) {\n        len += 2;\n      } else if (c >= 0xd800 && c <= 0xdfff) {\n        len += 4;\n        ++i;\n      } else {\n        len += 3;\n      }\n    }\n    return len\n  };\n\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {\n    var maxIdx = idx + maxBytesToRead;\n    if (ignoreNul) return maxIdx\n    // TextDecoder needs to know the byte length in advance, it doesn't stop on\n    // null terminator by itself.\n    // As a tiny code save trick, compare idx against maxIdx using a negation,\n    // so that maxBytesToRead=undefined/NaN means Infinity.\n    while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;\n    return idx\n  };\n\n  /**\n   * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n   * array that contains uint8 values, returns a copy of that string as a\n   * Javascript String object.\n   * heapOrArray is either a regular array, or a JavaScript typed array view.\n   * @param {number=} idx\n   * @param {number=} maxBytesToRead\n   * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n   * @return {string}\n   */\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {\n    var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);\n\n    // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))\n    }\n    var str = '';\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = heapOrArray[idx++];\n      if (!(u0 & 0x80)) {\n        str += String.fromCharCode(u0);\n        continue\n      }\n      var u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 0xe0) == 0xc0) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\n        continue\n      }\n      var u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 0xf0) == 0xe0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));\n      }\n    }\n    return str\n  };\n\n  /**\n   * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n   * emscripten HEAP, returns a copy of that string as a Javascript String object.\n   *\n   * @param {number} ptr\n   * @param {number=} maxBytesToRead - An optional length that specifies the\n   *   maximum number of bytes to read. You can omit this parameter to scan the\n   *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n   *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n   *   string will cut short at that byte index.\n   * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n   * @return {string}\n   */\n  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : ''\n  };\n  var __embind_register_std_string = (rawType, name) => {\n    name = AsciiToString(name);\n\n    registerType(rawType, {\n      name,\n      // For some method names we use string keys here since they are part of\n      // the public/external API and/or used by the runtime-generated code.\n      fromWireType(value) {\n        var length = HEAPU32[value >> 2];\n        var payload = value + 4;\n\n        var str;\n        {\n          str = UTF8ToString(payload, length, true);\n        }\n\n        _free(value);\n\n        return str\n      },\n      toWireType(destructors, value) {\n        if (value instanceof ArrayBuffer) {\n          value = new Uint8Array(value);\n        }\n\n        var length;\n        var valueIsOfTypeString = typeof value == 'string';\n\n        // We accept `string` or array views with single byte elements\n        if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {\n          throwBindingError('Cannot pass non-string to std::string');\n        }\n        if (valueIsOfTypeString) {\n          length = lengthBytesUTF8(value);\n        } else {\n          length = value.length;\n        }\n\n        // assumes POINTER_SIZE alignment\n        var base = _malloc(4 + length + 1);\n        var ptr = base + 4;\n        HEAPU32[base >> 2] = length;\n        if (valueIsOfTypeString) {\n          {\n            stringToUTF8(value, ptr, length + 1);\n          }\n        } else {\n          HEAPU8.set(value, ptr);\n        }\n\n        if (destructors !== null) {\n          destructors.push(_free, base);\n        }\n        return base\n      },\n      readValueFromPointer: readPointer,\n      destructorFunction(ptr) {\n        _free(ptr);\n      },\n    });\n  };\n\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n  var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {\n    var idx = ptr >> 1;\n    var endIdx = findStringEnd(HEAPU16, idx, maxBytesToRead / 2, ignoreNul);\n\n    // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n    if (endIdx - idx > 16 && UTF16Decoder) return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx))\n\n    // Fallback: decode without UTF16Decoder\n    var str = '';\n\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n    // for-loop's condition will always evaluate to true. The loop is then\n    // terminated on the first null char.\n    for (var i = idx; i < endIdx; ++i) {\n      var codeUnit = HEAPU16[i];\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can\n      // pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n\n    return str\n  };\n\n  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n    // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n    maxBytesToWrite ??= 0x7fffffff;\n    if (maxBytesToWrite < 2) return 0\n    maxBytesToWrite -= 2; // Null terminator.\n    var startPtr = outPtr;\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n      HEAP16[outPtr >> 1] = codeUnit;\n      outPtr += 2;\n    }\n    // Null-terminate the pointer to the HEAP.\n    HEAP16[outPtr >> 1] = 0;\n    return outPtr - startPtr\n  };\n\n  var lengthBytesUTF16 = (str) => str.length * 2;\n\n  var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {\n    var str = '';\n    var startIdx = ptr >> 2;\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n    // will always evaluate to true. This saves on code size.\n    for (var i = 0; !(i >= maxBytesToRead / 4); i++) {\n      var utf32 = HEAPU32[startIdx + i];\n      if (!utf32 && !ignoreNul) break\n      str += String.fromCodePoint(utf32);\n    }\n    return str\n  };\n\n  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n    // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n    maxBytesToWrite ??= 0x7fffffff;\n    if (maxBytesToWrite < 4) return 0\n    var startPtr = outPtr;\n    var endPtr = startPtr + maxBytesToWrite - 4;\n    for (var i = 0; i < str.length; ++i) {\n      var codePoint = str.codePointAt(i);\n      // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n      // We need to manually skip over the second code unit for correct iteration.\n      if (codePoint > 0xffff) {\n        i++;\n      }\n      HEAP32[outPtr >> 2] = codePoint;\n      outPtr += 4;\n      if (outPtr + 4 > endPtr) break\n    }\n    // Null-terminate the pointer to the HEAP.\n    HEAP32[outPtr >> 2] = 0;\n    return outPtr - startPtr\n  };\n\n  var lengthBytesUTF32 = (str) => {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n      var codePoint = str.codePointAt(i);\n      // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n      // We need to manually skip over the second code unit for correct iteration.\n      if (codePoint > 0xffff) {\n        i++;\n      }\n      len += 4;\n    }\n\n    return len\n  };\n  var __embind_register_std_wstring = (rawType, charSize, name) => {\n    name = AsciiToString(name);\n    var decodeString, encodeString, lengthBytesUTF;\n    if (charSize === 2) {\n      decodeString = UTF16ToString;\n      encodeString = stringToUTF16;\n      lengthBytesUTF = lengthBytesUTF16;\n    } else {\n      decodeString = UTF32ToString;\n      encodeString = stringToUTF32;\n      lengthBytesUTF = lengthBytesUTF32;\n    }\n    registerType(rawType, {\n      name,\n      fromWireType: (value) => {\n        // Code mostly taken from _embind_register_std_string fromWireType\n        var length = HEAPU32[value >> 2];\n        var str = decodeString(value + 4, length * charSize, true);\n\n        _free(value);\n\n        return str\n      },\n      toWireType: (destructors, value) => {\n        if (!(typeof value == 'string')) {\n          throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n        }\n\n        // assumes POINTER_SIZE alignment\n        var length = lengthBytesUTF(value);\n        var ptr = _malloc(4 + length + charSize);\n        HEAPU32[ptr >> 2] = length / charSize;\n\n        encodeString(value, ptr + 4, length + charSize);\n\n        if (destructors !== null) {\n          destructors.push(_free, ptr);\n        }\n        return ptr\n      },\n      readValueFromPointer: readPointer,\n      destructorFunction(ptr) {\n        _free(ptr);\n      },\n    });\n  };\n\n  var __embind_register_void = (rawType, name) => {\n    name = AsciiToString(name);\n    registerType(rawType, {\n      isVoid: true, // void return values can be optimized out sometimes\n      name,\n      fromWireType: () => undefined,\n      // TODO: assert if anything else is given?\n      toWireType: (destructors, o) => undefined,\n    });\n  };\n\n  var emval_methodCallers = [];\n  var emval_addMethodCaller = (caller) => {\n    var id = emval_methodCallers.length;\n    emval_methodCallers.push(caller);\n    return id\n  };\n\n  var requireRegisteredType = (rawType, humanName) => {\n    var impl = registeredTypes[rawType];\n    if (undefined === impl) {\n      throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\n    }\n    return impl\n  };\n  var emval_lookupTypes = (argCount, argTypes) => {\n    var a = new Array(argCount);\n    for (var i = 0; i < argCount; ++i) {\n      a[i] = requireRegisteredType(HEAPU32[(argTypes + i * 4) >> 2], `parameter ${i}`);\n    }\n    return a\n  };\n\n  var emval_returnValue = (toReturnWire, destructorsRef, handle) => {\n    var destructors = [];\n    var result = toReturnWire(destructors, handle);\n    if (destructors.length) {\n      // void, primitives and any other types w/o destructors don't need to allocate a handle\n      HEAPU32[destructorsRef >> 2] = Emval.toHandle(destructors);\n    }\n    return result\n  };\n\n  var emval_symbols = {};\n\n  var getStringOrSymbol = (address) => {\n    var symbol = emval_symbols[address];\n    if (symbol === undefined) {\n      return AsciiToString(address)\n    }\n    return symbol\n  };\n  var __emval_create_invoker = (argCount, argTypesPtr, kind) => {\n    var GenericWireTypeSize = 8;\n\n    var [retType, ...argTypes] = emval_lookupTypes(argCount, argTypesPtr);\n    var toReturnWire = retType.toWireType.bind(retType);\n    var argFromPtr = argTypes.map((type) => type.readValueFromPointer.bind(type));\n    argCount--; // remove the extracted return type\n\n    var captures = { toValue: Emval.toValue };\n    var args = argFromPtr.map((argFromPtr, i) => {\n      var captureName = `argFromPtr${i}`;\n      captures[captureName] = argFromPtr;\n      return `${captureName}(args${i ? '+' + i * GenericWireTypeSize : ''})`\n    });\n    var functionBody;\n    switch (kind) {\n      case 0:\n        functionBody = 'toValue(handle)';\n        break\n      case 2:\n        functionBody = 'new (toValue(handle))';\n        break\n      case 3:\n        functionBody = '';\n        break\n      case 1:\n        captures['getStringOrSymbol'] = getStringOrSymbol;\n        functionBody = 'toValue(handle)[getStringOrSymbol(methodName)]';\n        break\n    }\n    functionBody += `(${args})`;\n    if (!retType.isVoid) {\n      captures['toReturnWire'] = toReturnWire;\n      captures['emval_returnValue'] = emval_returnValue;\n      functionBody = `return emval_returnValue(toReturnWire, destructorsRef, ${functionBody})`;\n    }\n    functionBody = `return function (handle, methodName, destructorsRef, args) {\n  ${functionBody}\n  }`;\n\n    var invokerFunction = new Function(Object.keys(captures), functionBody)(\n      ...Object.values(captures)\n    );\n    var functionName = `methodCaller<(${argTypes.map((t) => t.name)}) => ${retType.name}>`;\n    return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction))\n  };\n\n  var __emval_incref = (handle) => {\n    if (handle > 9) {\n      emval_handles[handle + 1] += 1;\n    }\n  };\n\n  var __emval_invoke = (caller, handle, methodName, destructorsRef, args) => {\n    return emval_methodCallers[caller](handle, methodName, destructorsRef, args)\n  };\n\n  var __emval_run_destructors = (handle) => {\n    var destructors = Emval.toValue(handle);\n    runDestructors(destructors);\n    __emval_decref(handle);\n  };\n\n  var INT53_MAX = 9007199254740992;\n\n  var INT53_MIN = -9007199254740992;\n  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX ? NaN : Number(num));\n  function __gmtime_js(time, tmPtr) {\n    time = bigintToI53Checked(time);\n\n    var date = new Date(time * 1000);\n    HEAP32[tmPtr >> 2] = date.getUTCSeconds();\n    HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();\n    HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();\n    HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();\n    HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();\n    HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;\n    HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();\n    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\n    var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;\n    HEAP32[(tmPtr + 28) >> 2] = yday;\n  }\n\n  var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n    // TODO: Use (malleable) environment variables instead of system settings.\n    var currentYear = new Date().getFullYear();\n    var winter = new Date(currentYear, 0, 1);\n    var summer = new Date(currentYear, 6, 1);\n    var winterOffset = winter.getTimezoneOffset();\n    var summerOffset = summer.getTimezoneOffset();\n\n    // Local standard timezone offset. Local standard time is not adjusted for\n    // daylight savings.  This code uses the fact that getTimezoneOffset returns\n    // a greater value during Standard Time versus Daylight Saving Time (DST).\n    // Thus it determines the expected output during Standard Time, and it\n    // compares whether the output of the given date the same (Standard) or less\n    // (DST).\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n\n    // timezone is specified as seconds west of UTC (\"The external variable\n    // `timezone` shall be set to the difference, in seconds, between\n    // Coordinated Universal Time (UTC) and local standard time.\"), the same\n    // as returned by stdTimezoneOffset.\n    // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n\n    var extractZone = (timezoneOffset) => {\n      // Why inverse sign?\n      // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n      var sign = timezoneOffset >= 0 ? '-' : '+';\n\n      var absOffset = Math.abs(timezoneOffset);\n      var hours = String(Math.floor(absOffset / 60)).padStart(2, '0');\n      var minutes = String(absOffset % 60).padStart(2, '0');\n\n      return `UTC${sign}${hours}${minutes}`\n    };\n\n    var winterName = extractZone(winterOffset);\n    var summerName = extractZone(summerOffset);\n    if (summerOffset < winterOffset) {\n      // Northern hemisphere\n      stringToUTF8(winterName, std_name, 17);\n      stringToUTF8(summerName, dst_name, 17);\n    } else {\n      stringToUTF8(winterName, dst_name, 17);\n      stringToUTF8(summerName, std_name, 17);\n    }\n  };\n\n  var _emscripten_date_now = () => Date.now();\n\n  var getHeapMax = () =>\n    // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n    // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n    // for any code that deals with heap sizes, which would require special\n    // casing all heap size related code to treat 0 specially.\n    2147483648;\n\n  var alignMemory = (size, alignment) => {\n    return Math.ceil(size / alignment) * alignment\n  };\n\n  var growMemory = (size) => {\n    var oldHeapSize = wasmMemory.buffer.byteLength;\n    var pages = ((size - oldHeapSize + 65535) / 65536) | 0;\n    try {\n      // round size grow request up to wasm page size (fixed 64KB per spec)\n      wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\n      updateMemoryViews();\n      return 1 /*success*/\n    } catch (e) {}\n    // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n    // anyhow)\n  };\n  var _emscripten_resize_heap = (requestedSize) => {\n    var oldSize = HEAPU8.length;\n    // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n    requestedSize >>>= 0;\n    // With multithreaded builds, races can happen (another thread might increase the size\n    // in between), so return a failure, and let the caller retry.\n\n    // Memory resize rules:\n    // 1.  Always increase heap size to at least the requested size, rounded up\n    //     to next page multiple.\n    // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n    //     geometrically: increase the heap size according to\n    //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n    //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n    // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n    //     linearly: increase the heap size by at least\n    //     MEMORY_GROWTH_LINEAR_STEP bytes.\n    // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n    //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n    // 4.  If we were unable to allocate as much memory, it may be due to\n    //     over-eager decision to excessively reserve due to (3) above.\n    //     Hence if an allocation fails, cut down on the amount of excess\n    //     growth, in an attempt to succeed to perform a smaller allocation.\n\n    // A limit is set for how much we can grow. We should not exceed that\n    // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n    var maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize) {\n      return false\n    }\n\n    // Loop through potential heap size increases. If we attempt a too eager\n    // reservation that fails, cut down on the attempted size and reserve a\n    // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n      // but limit overreserving (default to capping at +96MB overgrowth at most)\n      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n\n      var newSize = Math.min(\n        maxHeapSize,\n        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)\n      );\n\n      var replacement = growMemory(newSize);\n      if (replacement) {\n        return true\n      }\n    }\n    return false\n  };\n\n  var ENV = {};\n\n  var getExecutableName = () => thisProgram;\n  var getEnvStrings = () => {\n    if (!getEnvStrings.strings) {\n      // Default values.\n      // Browser language detection #8751\n      var lang =\n        ((typeof navigator == 'object' && navigator.language) || 'C').replace('-', '_') + '.UTF-8';\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName(),\n      };\n      // Apply the user-provided values, if any.\n      for (var x in ENV) {\n        // x is a key in ENV; if ENV[x] is undefined, that means it was\n        // explicitly set to be so. We allow user code to do that to\n        // force variables with default values to remain unset.\n        if (ENV[x] === undefined) delete env[x];\n        else env[x] = ENV[x];\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(`${x}=${env[x]}`);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings\n  };\n\n  var _environ_get = (__environ, environ_buf) => {\n    var bufSize = 0;\n    var envp = 0;\n    for (var string of getEnvStrings()) {\n      var ptr = environ_buf + bufSize;\n      HEAPU32[(__environ + envp) >> 2] = ptr;\n      bufSize += stringToUTF8(string, ptr, Infinity) + 1;\n      envp += 4;\n    }\n    return 0\n  };\n\n  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n    var strings = getEnvStrings();\n    HEAPU32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    for (var string of strings) {\n      bufSize += lengthBytesUTF8(string) + 1;\n    }\n    HEAPU32[penviron_buf_size >> 2] = bufSize;\n    return 0\n  };\n\n  var _fd_close = (fd) => {\n    return 52\n  };\n\n  function _fd_seek(fd, offset, whence, newOffset) {\n\n    return 70\n  }\n\n  var printCharBuffers = [null, [], []];\n\n  var printChar = (stream, curr) => {\n    var buffer = printCharBuffers[stream];\n    if (curr === 0 || curr === 10) {\n(stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n      buffer.length = 0;\n    } else {\n      buffer.push(curr);\n    }\n  };\n  var _fd_write = (fd, iov, iovcnt, pnum) => {\n    // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n    var num = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[(iov + 4) >> 2];\n      iov += 8;\n      for (var j = 0; j < len; j++) {\n        printChar(fd, HEAPU8[ptr + j]);\n      }\n      num += len;\n    }\n    HEAPU32[pnum >> 2] = num;\n    return 0\n  };\n  init_ClassHandle();\n  init_RegisteredPointer();\n\n  // Begin runtime exports\n  // End runtime exports\n  // Begin JS library exports\n  // End JS library exports\n\n  // end include: postlibrary.js\n\n  // Imports from the Wasm binary.\n  var ___getTypeName,\n    _malloc,\n    _free;\n\n  function assignWasmExports(wasmExports) {\n    ___getTypeName = wasmExports['__getTypeName'];\n    _malloc = wasmExports['malloc'];\n    _free = wasmExports['free'];\n    wasmExports['_emscripten_stack_restore'];\n    wasmExports['_emscripten_stack_alloc'];\n    wasmExports['emscripten_stack_get_current'];\n  }\n  var wasmImports = {\n    /** @export */\n    _abort_js: __abort_js,\n    /** @export */\n    _embind_register_bigint: __embind_register_bigint,\n    /** @export */\n    _embind_register_bool: __embind_register_bool,\n    /** @export */\n    _embind_register_class: __embind_register_class,\n    /** @export */\n    _embind_register_class_constructor: __embind_register_class_constructor,\n    /** @export */\n    _embind_register_class_function: __embind_register_class_function,\n    /** @export */\n    _embind_register_emval: __embind_register_emval,\n    /** @export */\n    _embind_register_float: __embind_register_float,\n    /** @export */\n    _embind_register_integer: __embind_register_integer,\n    /** @export */\n    _embind_register_memory_view: __embind_register_memory_view,\n    /** @export */\n    _embind_register_smart_ptr: __embind_register_smart_ptr,\n    /** @export */\n    _embind_register_std_string: __embind_register_std_string,\n    /** @export */\n    _embind_register_std_wstring: __embind_register_std_wstring,\n    /** @export */\n    _embind_register_void: __embind_register_void,\n    /** @export */\n    _emval_create_invoker: __emval_create_invoker,\n    /** @export */\n    _emval_decref: __emval_decref,\n    /** @export */\n    _emval_incref: __emval_incref,\n    /** @export */\n    _emval_invoke: __emval_invoke,\n    /** @export */\n    _emval_run_destructors: __emval_run_destructors,\n    /** @export */\n    _gmtime_js: __gmtime_js,\n    /** @export */\n    _tzset_js: __tzset_js,\n    /** @export */\n    emscripten_date_now: _emscripten_date_now,\n    /** @export */\n    emscripten_resize_heap: _emscripten_resize_heap,\n    /** @export */\n    environ_get: _environ_get,\n    /** @export */\n    environ_sizes_get: _environ_sizes_get,\n    /** @export */\n    fd_close: _fd_close,\n    /** @export */\n    fd_seek: _fd_seek,\n    /** @export */\n    fd_write: _fd_write,\n  };\n  var wasmExports = await createWasm();\n\n  // include: postamble.js\n  // === Auto-generated postamble setup entry stuff ===\n\n  function run() {\n    if (runDependencies > 0) {\n      dependenciesFulfilled = run;\n      return\n    }\n\n    // a preRun added a dependency, run will be called later\n    if (runDependencies > 0) {\n      dependenciesFulfilled = run;\n      return\n    }\n\n    function doRun() {\n      // run may have just been called through dependencies being fulfilled just in this very frame,\n      // or while the async setStatus time below was happening\n      Module['calledRun'] = true;\n\n      if (ABORT) return\n\n      initRuntime();\n\n      readyPromiseResolve?.(Module);\n    }\n\n    {\n      doRun();\n    }\n  }\n  run();\n\n  // end include: postamble.js\n\n  // include: postamble_modularize.js\n  // In MODULARIZE mode we wrap the generated code in a factory function\n  // and return either the Module itself, or a promise of the module.\n  //\n  // We assign to the `moduleRtn` global here and configure closure to see\n  // this as and extern so it won't get minified.\n\n  if (runtimeInitialized) {\n    moduleRtn = Module;\n  } else {\n    // Set up the promise that indicates the Module is initialized\n    moduleRtn = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n  }\n\n  // end include: postamble_modularize.js\n\n  return moduleRtn\n}\n\nconst noopPrint = () => {\n  // No-op\n};\nfunction defaultLocateFile(path, prefix) {\n  try {\n    const url = new URL(prefix);\n    if (url.pathname === '/') {\n      return `${prefix}mediainfo.js/dist/${path}`;\n    }\n  } catch {\n    // empty\n  }\n  return `${prefix}../${path}`;\n}\n\n// TODO pass through more emscripten module options?\n\n/**\n * Creates a {@link MediaInfo} instance with the specified options.\n *\n * @typeParam TFormat - The format type, defaults to `object`.\n * @param options - Configuration options for creating the {@link MediaInfo} instance.\n * @returns A promise that resolves to a {@link MediaInfo} instance when no callback is provided.\n */\n\n/**\n * Creates a {@link MediaInfo} instance with the specified options and executes the callback.\n *\n * @typeParam TFormat - The format type, defaults to `object`.\n * @param options - Configuration options for creating the {@link MediaInfo} instance.\n * @param callback - Function to call with the {@link MediaInfo} instance.\n * @param errCallback - Optional function to call on error.\n */\n\nfunction mediaInfoFactory() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 ? arguments[1] : undefined;\n  let errCallback = arguments.length > 2 ? arguments[2] : undefined;\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      mediaInfoFactory(options, resolve, reject);\n    });\n  }\n  const {\n    locateFile,\n    ...mergedOptions\n  } = {\n    ...DEFAULT_OPTIONS,\n    ...options,\n    format: options.format ?? DEFAULT_OPTIONS.format\n  };\n  const mediaInfoModuleFactoryOpts = {\n    // Silence all print in module\n    print: noopPrint,\n    printErr: noopPrint,\n    locateFile: locateFile ?? defaultLocateFile,\n    onAbort: err => {\n      if (errCallback) {\n        errCallback(err);\n      }\n    }\n  };\n\n  // Fetch and load WASM module\n  Module(mediaInfoModuleFactoryOpts).then(wasmModule => {\n    callback(new MediaInfo(wasmModule, mergedOptions));\n  }).catch(error => {\n    if (errCallback) {\n      errCallback(error);\n    }\n  });\n}\n\n/**\n * Checks if a given object is of a specified track type.\n *\n * @template T - The type of track to check for.\n * @param thing - The object to check.\n * @param type - The track type to check against.\n * @returns A boolean indicating whether the object is of the specified track type.\n */\nfunction isTrackType(thing, type) {\n  return thing !== null && typeof thing === 'object' && thing['@type'] === type;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYWluZm8uanMvZGlzdC9lc20tYnVuZGxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdCQUF3QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpRUFBaUUsdUJBQXVCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFF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QUM3RSwwQ0FBMEMsaUJBQWlCO0FBQzNEOztBQUVBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0UsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNFO0FBQ3RFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcbWVkaWFpbmZvLmpzXFxkaXN0XFxlc20tYnVuZGxlXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnJvciwgJ21lc3NhZ2UnKTtcbn1cbmZ1bmN0aW9uIHVua25vd25Ub0Vycm9yKGVycm9yKSB7XG4gIGlmIChpc0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6ICdVbmtub3duIGVycm9yJyk7XG59XG5cbi8vIERPIE5PVCBFRElUISBGaWxlIGdlbmVyYXRlZCB1c2luZyBgZ2VuZXJhdGUtdHlwZXNgIHNjcmlwdC5cblxuY29uc3QgSU5UX0ZJRUxEUyA9IFsnQWN0aXZlX0hlaWdodCcsICdBY3RpdmVfV2lkdGgnLCAnQXVkaW9Db3VudCcsICdBdWRpb19DaGFubmVsc19Ub3RhbCcsICdCaXREZXB0aF9EZXRlY3RlZCcsICdCaXREZXB0aCcsICdCaXREZXB0aF9TdG9yZWQnLCAnQ2hhbm5lbHMnLCAnQ2hhbm5lbHNfT3JpZ2luYWwnLCAnQ2hhcHRlcnNfUG9zX0JlZ2luJywgJ0NoYXB0ZXJzX1Bvc19FbmQnLCAnQ29taWNfUG9zaXRpb25fVG90YWwnLCAnQ291bnQnLCAnRGF0YVNpemUnLCAnRWxlbWVudENvdW50JywgJ0VQR19Qb3NpdGlvbnNfQmVnaW4nLCAnRVBHX1Bvc2l0aW9uc19FbmQnLCAnRmlyc3RQYWNrZXRPcmRlcicsICdGb290ZXJTaXplJywgJ0Zvcm1hdF9TZXR0aW5nc19HTUMnLCAnRm9ybWF0X1NldHRpbmdzX1JlZkZyYW1lcycsICdGb3JtYXRfU2V0dGluZ3NfU2xpY2VDb3VudCcsICdGcmFtZUNvdW50JywgJ0ZyYW1lUmF0ZV9EZW4nLCAnRnJhbWVSYXRlX051bScsICdHZW5lcmFsQ291bnQnLCAnSGVhZGVyU2l6ZScsICdIZWlnaHRfQ2xlYW5BcGVydHVyZScsICdIZWlnaHQnLCAnSGVpZ2h0X09mZnNldCcsICdIZWlnaHRfT3JpZ2luYWwnLCAnSW1hZ2VDb3VudCcsICdMaW5lc19NYXhDaGFyYWN0ZXJDb3VudCcsICdMaW5lc19NYXhDb3VudFBlckV2ZW50JywgJ01hdHJpeF9DaGFubmVscycsICdNZW51Q291bnQnLCAnT3RoZXJDb3VudCcsICdQYXJ0X1Bvc2l0aW9uJywgJ1BhcnRfUG9zaXRpb25fVG90YWwnLCAnUGxheWVkX0NvdW50JywgJ1JlZWxfUG9zaXRpb24nLCAnUmVlbF9Qb3NpdGlvbl9Ub3RhbCcsICdSZXNvbHV0aW9uJywgJ1NhbXBsZWRfSGVpZ2h0JywgJ1NhbXBsZWRfV2lkdGgnLCAnU2FtcGxpbmdDb3VudCcsICdTZWFzb25fUG9zaXRpb24nLCAnU2Vhc29uX1Bvc2l0aW9uX1RvdGFsJywgJ1NvdXJjZV9GcmFtZUNvdW50JywgJ1NvdXJjZV9TYW1wbGluZ0NvdW50JywgJ1NvdXJjZV9TdHJlYW1TaXplX0VuY29kZWQnLCAnU291cmNlX1N0cmVhbVNpemUnLCAnU3RhdHVzJywgJ1N0b3JlZF9IZWlnaHQnLCAnU3RvcmVkX1dpZHRoJywgJ1N0cmVhbUNvdW50JywgJ1N0cmVhbUtpbmRJRCcsICdTdHJlYW1LaW5kUG9zJywgJ1N0cmVhbVNpemVfRGVtdXhlZCcsICdTdHJlYW1TaXplX0VuY29kZWQnLCAnU3RyZWFtU2l6ZScsICdUZXh0Q291bnQnLCAnVHJhY2tfUG9zaXRpb24nLCAnVHJhY2tfUG9zaXRpb25fVG90YWwnLCAnVmlkZW8wX0RlbGF5JywgJ1ZpZGVvQ291bnQnLCAnV2lkdGhfQ2xlYW5BcGVydHVyZScsICdXaWR0aCcsICdXaWR0aF9PZmZzZXQnLCAnV2lkdGhfT3JpZ2luYWwnXTtcbmNvbnN0IEZMT0FUX0ZJRUxEUyA9IFsnQWN0aXZlX0Rpc3BsYXlBc3BlY3RSYXRpbycsICdCaXRSYXRlX0VuY29kZWQnLCAnQml0UmF0ZV9NYXhpbXVtJywgJ0JpdFJhdGVfTWluaW11bScsICdCaXRSYXRlJywgJ0JpdFJhdGVfTm9taW5hbCcsICdCaXRzLVBpeGVsX0ZyYW1lJywgJ0JpdHNQaXhlbF9GcmFtZScsICdDb21wcmVzc2lvbl9SYXRpbycsICdEZWxheScsICdEZWxheV9PcmlnaW5hbCcsICdEaXNwbGF5QXNwZWN0UmF0aW9fQ2xlYW5BcGVydHVyZScsICdEaXNwbGF5QXNwZWN0UmF0aW8nLCAnRGlzcGxheUFzcGVjdFJhdGlvX09yaWdpbmFsJywgJ0R1cmF0aW9uX0VuZF9Db21tYW5kJywgJ0R1cmF0aW9uX0VuZCcsICdEdXJhdGlvbl9GaXJzdEZyYW1lJywgJ0R1cmF0aW9uX0xhc3RGcmFtZScsICdEdXJhdGlvbicsICdEdXJhdGlvbl9TdGFydDJFbmQnLCAnRHVyYXRpb25fU3RhcnRfQ29tbWFuZCcsICdEdXJhdGlvbl9TdGFydCcsICdFdmVudHNfTWluRHVyYXRpb24nLCAnRnJhbWVSYXRlX01heGltdW0nLCAnRnJhbWVSYXRlX01pbmltdW0nLCAnRnJhbWVSYXRlJywgJ0ZyYW1lUmF0ZV9Ob21pbmFsJywgJ0ZyYW1lUmF0ZV9PcmlnaW5hbF9EZW4nLCAnRnJhbWVSYXRlX09yaWdpbmFsJywgJ0ZyYW1lUmF0ZV9PcmlnaW5hbF9OdW0nLCAnRnJhbWVSYXRlX1JlYWwnLCAnSW50ZXJsZWF2ZV9EdXJhdGlvbicsICdJbnRlcmxlYXZlX1ByZWxvYWQnLCAnSW50ZXJsZWF2ZV9WaWRlb0ZyYW1lcycsICdPdmVyYWxsQml0UmF0ZV9NYXhpbXVtJywgJ092ZXJhbGxCaXRSYXRlX01pbmltdW0nLCAnT3ZlcmFsbEJpdFJhdGUnLCAnT3ZlcmFsbEJpdFJhdGVfTm9taW5hbCcsICdQaXhlbEFzcGVjdFJhdGlvX0NsZWFuQXBlcnR1cmUnLCAnUGl4ZWxBc3BlY3RSYXRpbycsICdQaXhlbEFzcGVjdFJhdGlvX09yaWdpbmFsJywgJ1NhbXBsZXNQZXJGcmFtZScsICdTYW1wbGluZ1JhdGUnLCAnU291cmNlX0R1cmF0aW9uX0ZpcnN0RnJhbWUnLCAnU291cmNlX0R1cmF0aW9uX0xhc3RGcmFtZScsICdTb3VyY2VfRHVyYXRpb24nLCAnVGltZVN0YW1wX0ZpcnN0RnJhbWUnLCAnVmlkZW9fRGVsYXknXTtcblxuY29uc3QgTUFYX1VJTlQzMl9QTFVTX09ORSA9IDIgKiogMzI7XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGNvdmVyRGF0YTogZmFsc2UsXG4gIGNodW5rU2l6ZTogMjU2ICogMTAyNCxcbiAgZm9ybWF0OiAnb2JqZWN0JyxcbiAgZnVsbDogZmFsc2Vcbn07XG4vKipcbiAqIFdyYXBwZXIgZm9yIHRoZSBNZWRpYUluZm9MaWIgV0FTTSBtb2R1bGUuXG4gKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gVXNlIHRoZSB7QGxpbmsgbWVkaWFJbmZvRmFjdG9yeX0gZnVuY3Rpb25cbiAqIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYE1lZGlhSW5mb2AuXG4gKlxuICogQHR5cGVQYXJhbSBURm9ybWF0IC0gVGhlIGZvcm1hdCB0eXBlLCBkZWZhdWx0cyB0byBgb2JqZWN0YC5cbiAqL1xuY2xhc3MgTWVkaWFJbmZvIHtcbiAgaXNBbmFseXppbmcgPSBmYWxzZTtcblxuICAvKiogQGdyb3VwIEdlbmVyYWwgVXNlICovXG5cbiAgLyoqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgaW5zdGVhZCB1c2Uge0BsaW5rIG1lZGlhSW5mb0ZhY3Rvcnl9LlxuICAgKlxuICAgKiBAaGlkZGVuXG4gICAqIEBwYXJhbSBtZWRpYWluZm9Nb2R1bGUgV0FTTSBtb2R1bGVcbiAgICogQHBhcmFtIG9wdGlvbnMgVXNlciBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYWluZm9Nb2R1bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1lZGlhaW5mb01vZHVsZSA9IG1lZGlhaW5mb01vZHVsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubWVkaWFpbmZvTW9kdWxlSW5zdGFuY2UgPSB0aGlzLmluc3RhbnRpYXRlTW9kdWxlSW5zdGFuY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGFuYWx5emluZyBhIGJ1ZmZlciBjaHVuayBieSBjaHVuay5cbiAgICpcbiAgICogQHBhcmFtIHNpemUgUmV0dXJuIHRvdGFsIGJ1ZmZlciBzaXplIGluIGJ5dGVzLlxuICAgKiBAcGFyYW0gcmVhZENodW5rIFJlYWQgY2h1bmsgb2YgZGF0YSBhbmQgcmV0dXJuIGFuIHtAbGluayBVaW50OEFycmF5fS5cbiAgICogQGdyb3VwIEdlbmVyYWwgVXNlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGFuYWx5emluZyBhIGJ1ZmZlciBjaHVuayBieSBjaHVuay5cbiAgICpcbiAgICogQHBhcmFtIHNpemUgUmV0dXJuIHRvdGFsIGJ1ZmZlciBzaXplIGluIGJ5dGVzLlxuICAgKiBAcGFyYW0gcmVhZENodW5rIFJlYWQgY2h1bmsgb2YgZGF0YSBhbmQgcmV0dXJuIGFuIHtAbGluayBVaW50OEFycmF5fS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgdGhlIHByb2Nlc3NpbmcgaXMgZG9uZVxuICAgKiBAZ3JvdXAgR2VuZXJhbCBVc2VcbiAgICovXG5cbiAgYW5hbHl6ZURhdGEoc2l6ZSwgcmVhZENodW5rLCBjYWxsYmFjaykge1xuICAgIC8vIFN1cHBvcnQgcHJvbWlzZSBzaWduYXR1cmVcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0Q2IgPSAocmVzdWx0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMuaXNBbmFseXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZXJyb3IgfHwgIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVqZWN0KHVua25vd25Ub0Vycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYW5hbHl6ZURhdGEoc2l6ZSwgcmVhZENodW5rLCByZXN1bHRDYik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBbmFseXppbmcpIHtcbiAgICAgIGNhbGxiYWNrKCcnLCBuZXcgRXJyb3IoJ2Nhbm5vdCBzdGFydCBhIG5ldyBhbmFseXNpcyB3aGlsZSBhbm90aGVyIGlzIGluIHByb2dyZXNzJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5pc0FuYWx5emluZyA9IHRydWU7XG4gICAgY29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wZW5CdWZmZXJGaW5hbGl6ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmluZm9ybSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjYWxsYmFjayh0aGlzLnBhcnNlUmVzdWx0SnNvbihyZXN1bHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzQW5hbHl6aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBydW5SZWFkRGF0YUxvb3AgPSBmaWxlU2l6ZSA9PiB7XG4gICAgICBjb25zdCByZWFkTmV4dENodW5rID0gZGF0YSA9PiB7XG4gICAgICAgIGlmIChjb250aW51ZUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgIGdldENodW5rKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENodW5rID0gKCkgPT4ge1xuICAgICAgICBsZXQgZGF0YVZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNhZmVTaXplID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICAgIGRhdGFWYWx1ZSA9IHJlYWRDaHVuayhzYWZlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmlzQW5hbHl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soJycsIHVua25vd25Ub0Vycm9yKGVycm9yKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgZGF0YVZhbHVlLnRoZW4ocmVhZE5leHRDaHVuaykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0FuYWx5emluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2FsbGJhY2soJycsIHVua25vd25Ub0Vycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZE5leHRDaHVuayhkYXRhVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGludWVCdWZmZXIgPSBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwIHx8IHRoaXMub3BlbkJ1ZmZlckNvbnRpbnVlKGRhdGEsIGRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVrVG8gPSB0aGlzLm9wZW5CdWZmZXJDb250aW51ZUdvdG9HZXQoKTtcbiAgICAgICAgaWYgKHNlZWtUbyA9PT0gLTEpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc2Vla1RvO1xuICAgICAgICAgIHRoaXMub3BlbkJ1ZmZlckluaXQoZmlsZVNpemUsIHNlZWtUbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdGhpcy5vcGVuQnVmZmVySW5pdChmaWxlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIGdldENodW5rKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxlU2l6ZVZhbHVlID0gdHlwZW9mIHNpemUgPT09ICdmdW5jdGlvbicgPyBzaXplKCkgOiBzaXplO1xuICAgIGlmIChmaWxlU2l6ZVZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgZmlsZVNpemVWYWx1ZS50aGVuKHJ1blJlYWREYXRhTG9vcCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB1bmtub3duVG9FcnJvcihlcnJvcikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1blJlYWREYXRhTG9vcChmaWxlU2l6ZVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIE1lZGlhSW5mb0xpYiBXQVNNIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZ3JvdXAgR2VuZXJhbCBVc2VcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tZWRpYWluZm9Nb2R1bGVJbnN0YW5jZS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5tZWRpYWluZm9Nb2R1bGVJbnN0YW5jZS5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgTWVkaWFJbmZvTGliIFdBU00gaW5zdGFuY2UgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgaW5zdGFuY2UgaXMgcmVhZHkgZm9yIGEgbmV3IHBhcnNlLlxuICAgKiBAZ3JvdXAgR2VuZXJhbCBVc2VcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMubWVkaWFpbmZvTW9kdWxlSW5zdGFuY2UuZGVsZXRlKCk7XG4gICAgdGhpcy5tZWRpYWluZm9Nb2R1bGVJbnN0YW5jZSA9IHRoaXMuaW5zdGFudGlhdGVNb2R1bGVJbnN0YW5jZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgcmVzdWx0IGRhdGEgZnJvbSB0aGUgV0FTTSBpbnN0YW5jZS5cbiAgICpcbiAgICogKFRoaXMgaXMgYSBsb3ctbGV2ZWwgTWVkaWFJbmZvTGliIGZ1bmN0aW9uLilcbiAgICpcbiAgICogQHJldHVybnMgUmVzdWx0IGRhdGEgKGZvcm1hdCBjYW4gYmUgY29uZmlndXJlZCBpbiBvcHRpb25zKVxuICAgKiBAZ3JvdXAgTG93LWxldmVsXG4gICAqL1xuICBpbmZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWFpbmZvTW9kdWxlSW5zdGFuY2UuaW5mb3JtKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBtb3JlIGRhdGEgdG8gdGhlIFdBU00gaW5zdGFuY2UuXG4gICAqXG4gICAqIChUaGlzIGlzIGEgbG93LWxldmVsIE1lZGlhSW5mb0xpYiBmdW5jdGlvbi4pXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgYnVmZmVyXG4gICAqIEBwYXJhbSBzaXplIEJ1ZmZlciBzaXplXG4gICAqIEByZXR1cm5zIFByb2Nlc3Npbmcgc3RhdGU6IGAwYCAobm8gYml0cyBzZXQpID0gbm90IGZpbmlzaGVkLCBCaXQgYDBgIHNldCA9IGVub3VnaCBkYXRhIHJlYWQgZm9yIHByb3ZpZGluZyBpbmZvcm1hdGlvblxuICAgKiBAZ3JvdXAgTG93LWxldmVsXG4gICAqL1xuICBvcGVuQnVmZmVyQ29udGludWUoZGF0YSwgc2l6ZSkge1xuICAgIC8vIGJpdCAzIHNldCAtPiBkb25lXG4gICAgcmV0dXJuICEhKHRoaXMubWVkaWFpbmZvTW9kdWxlSW5zdGFuY2Uub3Blbl9idWZmZXJfY29udGludWUoZGF0YSwgc2l6ZSkgJiAweDA4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBzZWVrIHBvc2l0aW9uIGZyb20gV0FTTSBpbnN0YW5jZS5cbiAgICogVGhlIE1lZGlhSW5mb0xpYiBmdW5jdGlvbiBgT3Blbl9CdWZmZXJfR29Ub2AgcmV0dXJucyBhbiBpbnRlZ2VyIHdpdGggNjQgYml0IHByZWNpc2lvbi5cbiAgICogSXQgd291bGQgYmUgY3V0IGF0IDMyIGJpdCBkdWUgdG8gdGhlIEphdmFTY3JpcHQgYmluZGluZ3MuIEhlcmUgd2UgdHJhbnNwb3J0IHRoZSBsb3cgYW5kIGhpZ2hcbiAgICogcGFydHMgc2VwYXJhdGVseSBhbmQgcHV0IHRoZW0gdG9nZXRoZXIuXG4gICAqXG4gICAqIChUaGlzIGlzIGEgbG93LWxldmVsIE1lZGlhSW5mb0xpYiBmdW5jdGlvbi4pXG4gICAqXG4gICAqIEByZXR1cm5zIFNlZWsgcG9zaXRpb24gKHdoZXJlIE1lZGlhSW5mb0xpYiB3YW50cyBnbyBpbiB0aGUgZGF0YSBidWZmZXIpXG4gICAqIEBncm91cCBMb3ctbGV2ZWxcbiAgICovXG4gIG9wZW5CdWZmZXJDb250aW51ZUdvdG9HZXQoKSB7XG4gICAgLy8gSlMgYmluZGluZ3MgZG9uJ3Qgc3VwcG9ydCA2NCBiaXQgaW50XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J1enovbWVkaWFpbmZvLmpzL2lzc3Vlcy8xMVxuICAgIGxldCBzZWVrVG8gPSAtMTtcbiAgICBjb25zdCBzZWVrVG9Mb3cgPSB0aGlzLm1lZGlhaW5mb01vZHVsZUluc3RhbmNlLm9wZW5fYnVmZmVyX2NvbnRpbnVlX2dvdG9fZ2V0X2xvd2VyKCk7XG4gICAgY29uc3Qgc2Vla1RvSGlnaCA9IHRoaXMubWVkaWFpbmZvTW9kdWxlSW5zdGFuY2Uub3Blbl9idWZmZXJfY29udGludWVfZ290b19nZXRfdXBwZXIoKTtcbiAgICBpZiAoc2Vla1RvTG93ID09IC0xICYmIHNlZWtUb0hpZ2ggPT0gLTEpIHtcbiAgICAgIHNlZWtUbyA9IC0xO1xuICAgIH0gZWxzZSBpZiAoc2Vla1RvTG93IDwgMCkge1xuICAgICAgc2Vla1RvID0gc2Vla1RvTG93ICsgTUFYX1VJTlQzMl9QTFVTX09ORSArIHNlZWtUb0hpZ2ggKiBNQVhfVUlOVDMyX1BMVVNfT05FO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVrVG8gPSBzZWVrVG9Mb3cgKyBzZWVrVG9IaWdoICogTUFYX1VJTlQzMl9QTFVTX09ORTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZWtUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZvcm0gTWVkaWFJbmZvTGliIHRoYXQgbm8gbW9yZSBkYXRhIGlzIGJlaW5nIHJlYWQuXG4gICAqXG4gICAqIChUaGlzIGlzIGEgbG93LWxldmVsIE1lZGlhSW5mb0xpYiBmdW5jdGlvbi4pXG4gICAqXG4gICAqIEBncm91cCBMb3ctbGV2ZWxcbiAgICovXG4gIG9wZW5CdWZmZXJGaW5hbGl6ZSgpIHtcbiAgICB0aGlzLm1lZGlhaW5mb01vZHVsZUluc3RhbmNlLm9wZW5fYnVmZmVyX2ZpbmFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBNZWRpYUluZm9MaWIgdG8gcHJvY2VzcyBhIGRhdGEgYnVmZmVyLlxuICAgKlxuICAgKiAoVGhpcyBpcyBhIGxvdy1sZXZlbCBNZWRpYUluZm9MaWIgZnVuY3Rpb24uKVxuICAgKlxuICAgKiBAcGFyYW0gc2l6ZSBFeHBlY3RlZCBidWZmZXIgc2l6ZVxuICAgKiBAcGFyYW0gb2Zmc2V0IEJ1ZmZlciBvZmZzZXRcbiAgICogQGdyb3VwIExvdy1sZXZlbFxuICAgKi9cbiAgb3BlbkJ1ZmZlckluaXQoc2l6ZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5tZWRpYWluZm9Nb2R1bGVJbnN0YW5jZS5vcGVuX2J1ZmZlcl9pbml0KHNpemUsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgcmVzdWx0IEpTT04uIENvbnZlcnQgaW50ZWdlci9mbG9hdCBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHQgU2VyaWFsaXplZCBKU09OIGZyb20gTWVkaWFJbmZvXG4gICAqIEByZXR1cm5zIFBhcnNlZCBKU09OIG9iamVjdFxuICAgKi9cbiAgcGFyc2VSZXN1bHRKc29uKHJlc3VsdFN0cmluZykge1xuICAgIGNvbnN0IGludEZpZWxkcyA9IElOVF9GSUVMRFM7XG4gICAgY29uc3QgZmxvYXRGaWVsZHMgPSBGTE9BVF9GSUVMRFM7XG5cbiAgICAvLyBQYXJzZSBKU09OXG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHRTdHJpbmcpO1xuICAgIGlmIChyZXN1bHQubWVkaWEpIHtcbiAgICAgIGNvbnN0IG5ld01lZGlhID0ge1xuICAgICAgICAuLi5yZXN1bHQubWVkaWEsXG4gICAgICAgIHRyYWNrOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdC5tZWRpYS50cmFjaykpIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiByZXN1bHQubWVkaWEudHJhY2spIHtcbiAgICAgICAgICBsZXQgbmV3VHJhY2sgPSB7XG4gICAgICAgICAgICAnQHR5cGUnOiB0cmFja1snQHR5cGUnXVxuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHRyYWNrKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ0B0eXBlJykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBpbnRGaWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICBuZXdUcmFjayA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdUcmFjayxcbiAgICAgICAgICAgICAgICBba2V5XTogTnVtYmVyLnBhcnNlSW50KHZhbCwgMTApXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGZsb2F0RmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgbmV3VHJhY2sgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV3VHJhY2ssXG4gICAgICAgICAgICAgICAgW2tleV06IE51bWJlci5wYXJzZUZsb2F0KHZhbClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1RyYWNrID0ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1RyYWNrLFxuICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3TWVkaWEudHJhY2sucHVzaChuZXdUcmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgbWVkaWE6IG5ld01lZGlhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGEgbmV3IFdBU00gbW9kdWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyBNZWRpYUluZm8gbW9kdWxlIGluc3RhbmNlXG4gICAqL1xuICBpbnN0YW50aWF0ZU1vZHVsZUluc3RhbmNlKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5tZWRpYWluZm9Nb2R1bGUuTWVkaWFJbmZvKHRoaXMub3B0aW9ucy5mb3JtYXQgPT09ICdvYmplY3QnID8gJ0pTT04nIDogdGhpcy5vcHRpb25zLmZvcm1hdCwgdGhpcy5vcHRpb25zLmNvdmVyRGF0YSwgdGhpcy5vcHRpb25zLmZ1bGwpO1xuICB9XG59XG5cbi8vIFRoaXMgY29kZSBpbXBsZW1lbnRzIHRoZSBgLXNNT0RVTEFSSVpFYCBzZXR0aW5ncyBieSB0YWtpbmcgdGhlIGdlbmVyYXRlZFxuLy8gSlMgcHJvZ3JhbSBjb2RlIChJTk5FUl9KU19DT0RFKSBhbmQgd3JhcHBpbmcgaXQgaW4gYSBmYWN0b3J5IGZ1bmN0aW9uLlxuXG4vLyBXaGVuIHRhcmdldHRpbmcgbm9kZSBhbmQgRVM2IHdlIHVzZSBgYXdhaXQgaW1wb3J0IC4uYCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGVcbi8vIHNvIHRoZSBvdXRlciBmdW5jdGlvbiBuZWVkcyB0byBiZSBtYXJrZWQgYXMgYXN5bmMuXG5hc3luYyBmdW5jdGlvbiBNb2R1bGUobW9kdWxlQXJnID0ge30pIHtcbiAgdmFyIG1vZHVsZVJ0bjtcblxuICAvLyBpbmNsdWRlOiBzaGVsbC5qc1xuICAvLyBUaGUgTW9kdWxlIG9iamVjdDogT3VyIGludGVyZmFjZSB0byB0aGUgb3V0c2lkZSB3b3JsZC4gV2UgaW1wb3J0XG4gIC8vIGFuZCBleHBvcnQgdmFsdWVzIG9uIGl0LiBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIE1vZHVsZSBjYW4gYmUgdXNlZDpcbiAgLy8gMS4gTm90IGRlZmluZWQuIFdlIGNyZWF0ZSBpdCBoZXJlXG4gIC8vIDIuIEEgZnVuY3Rpb24gcGFyYW1ldGVyLCBmdW5jdGlvbihtb2R1bGVBcmcpID0+IFByb21pc2U8TW9kdWxlPlxuICAvLyAzLiBwcmUtcnVuIGFwcGVuZGVkIGl0LCB2YXIgTW9kdWxlID0ge307IC4uZ2VuZXJhdGVkIGNvZGUuLlxuICAvLyA0LiBFeHRlcm5hbCBzY3JpcHQgdGFnIGRlZmluZXMgdmFyIE1vZHVsZS5cbiAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBNb2R1bGUgYWxyZWFkeSBleGlzdHMgKGUuZy4gY2FzZSAzIGFib3ZlKS5cbiAgLy8gU3Vic3RpdHV0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgY29kZSBvbiBsYXRlciBzdGFnZSBvZiB0aGUgYnVpbGQsXG4gIC8vIHRoaXMgd2F5IENsb3N1cmUgQ29tcGlsZXIgd2lsbCBub3QgbWFuZ2xlIGl0IChlLmcuIGNhc2UgNC4gYWJvdmUpLlxuICAvLyBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8gcnVuIGNsb3N1cmUsIGFuZCBhbHNvIHRvIHVzZSBNb2R1bGVcbiAgLy8gYWZ0ZXIgdGhlIGdlbmVyYXRlZCBjb2RlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZSAgIHZhciBNb2R1bGUgPSB7fTtcbiAgLy8gYmVmb3JlIHRoZSBjb2RlLiBUaGVuIHRoYXQgb2JqZWN0IHdpbGwgYmUgdXNlZCBpbiB0aGUgY29kZSwgYW5kIHlvdVxuICAvLyBjYW4gY29udGludWUgdG8gdXNlIE1vZHVsZSBhZnRlcndhcmRzIGFzIHdlbGwuXG4gIHZhciBNb2R1bGUgPSBtb2R1bGVBcmc7XG4gIHZhciB0aGlzUHJvZ3JhbSA9ICcuL3RoaXMucHJvZ3JhbSc7XG5cbiAgdmFyIF9zY3JpcHROYW1lID0gaW1wb3J0Lm1ldGEudXJsO1xuXG4gIC8vIGAvYCBzaG91bGQgYmUgcHJlc2VudCBhdCB0aGUgZW5kIGlmIGBzY3JpcHREaXJlY3RvcnlgIGlzIG5vdCBlbXB0eVxuICB2YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gIGZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICAgIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgICAgcmV0dXJuIE1vZHVsZVsnbG9jYXRlRmlsZSddKHBhdGgsIHNjcmlwdERpcmVjdG9yeSlcbiAgICB9XG4gICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGhcbiAgfVxuXG4gIC8vIEhvb2tzIHRoYXQgYXJlIGltcGxlbWVudGVkIGRpZmZlcmVudGx5IGluIGRpZmZlcmVudCBydW50aW1lIGVudmlyb25tZW50cy5cbiAgdmFyIHJlYWRBc3luYztcblxuICAvLyBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyBOb2RlLmpzIHdvcmtlcnMgd2hlbiByZWxldmFudCAocHRocmVhZHMgaXMgZW5hYmxlZCkuXG4gIC8vIE5vZGUuanMgd29ya2VycyBhcmUgZGV0ZWN0ZWQgYXMgYSBjb21iaW5hdGlvbiBvZiBFTlZJUk9OTUVOVF9JU19XT1JLRVIgYW5kXG4gIC8vIEVOVklST05NRU5UX0lTX05PREUuXG4gIHtcbiAgICB0cnkge1xuICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gbmV3IFVSTCgnLicsIF9zY3JpcHROYW1lKS5ocmVmOyAvLyBpbmNsdWRlcyB0cmFpbGluZyBzbGFzaFxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gTXVzdCBiZSBhIGBibG9iOmAgb3IgYGRhdGE6YCBVUkwgKGUuZy4gYGJsb2I6aHR0cDovL3NpdGUuY29tL2V0Yy9ldGNgKSwgd2UgY2Fubm90XG4gICAgICAvLyBpbmZlciBhbnl0aGluZyBmcm9tIHRoZW0uXG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gaW5jbHVkZTogd2ViX29yX3dvcmtlcl9zaGVsbF9yZWFkLmpzXG4gICAgICByZWFkQXN5bmMgPSBhc3luYyAodXJsKSA9PiB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgJyA6ICcgKyByZXNwb25zZS51cmwpXG4gICAgICB9O1xuICAgICAgLy8gZW5kIGluY2x1ZGU6IHdlYl9vcl93b3JrZXJfc2hlbGxfcmVhZC5qc1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXQgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICB2YXIgZXJyID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuXG4gIC8vIGVuZCBpbmNsdWRlOiBzaGVsbC5qc1xuXG4gIC8vIGluY2x1ZGU6IHByZWFtYmxlLmpzXG4gIC8vID09PSBQcmVhbWJsZSBsaWJyYXJ5IHN0dWZmID09PVxuXG4gIC8vIERvY3VtZW50YXRpb24gZm9yIHRoZSBwdWJsaWMgQVBJcyBkZWZpbmVkIGluIHRoaXMgZmlsZSBtdXN0IGJlIHVwZGF0ZWQgaW46XG4gIC8vICAgIHNpdGUvc291cmNlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5yc3RcbiAgLy8gQSBwcmVidWlsdCBsb2NhbCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudGF0aW9uIGlzIGF2YWlsYWJsZSBhdDpcbiAgLy8gICAgc2l0ZS9idWlsZC90ZXh0L2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy50eHRcbiAgLy8gWW91IGNhbiBhbHNvIGJ1aWxkIGRvY3MgbG9jYWxseSBhcyBIVE1MIG9yIG90aGVyIGZvcm1hdHMgaW4gc2l0ZS9cbiAgLy8gQW4gb25saW5lIEhUTUwgdmVyc2lvbiAod2hpY2ggbWF5IGJlIG9mIGEgZGlmZmVyZW50IHZlcnNpb24gb2YgRW1zY3JpcHRlbilcbiAgLy8gICAgaXMgdXAgYXQgaHR0cDovL2tyaXBrZW4uZ2l0aHViLmlvL2Vtc2NyaXB0ZW4tc2l0ZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMuaHRtbFxuXG4gIHZhciB3YXNtQmluYXJ5O1xuXG4gIC8vIFdhc20gZ2xvYmFsc1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBSdW50aW1lIGVzc2VudGlhbHNcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gd2hldGhlciB3ZSBhcmUgcXVpdHRpbmcgdGhlIGFwcGxpY2F0aW9uLiBubyBjb2RlIHNob3VsZCBydW4gYWZ0ZXIgdGhpcy5cbiAgLy8gc2V0IGluIGV4aXQoKSBhbmQgYWJvcnQoKVxuICB2YXIgQUJPUlQgPSBmYWxzZTtcblxuICAvLyBpbmNsdWRlOiBydW50aW1lX2NvbW1vbi5qc1xuICAvLyBpbmNsdWRlOiBydW50aW1lX3N0YWNrX2NoZWNrLmpzXG4gIC8vIGVuZCBpbmNsdWRlOiBydW50aW1lX3N0YWNrX2NoZWNrLmpzXG4gIC8vIGluY2x1ZGU6IHJ1bnRpbWVfZXhjZXB0aW9ucy5qc1xuICAvLyBlbmQgaW5jbHVkZTogcnVudGltZV9leGNlcHRpb25zLmpzXG4gIC8vIGluY2x1ZGU6IHJ1bnRpbWVfZGVidWcuanNcbiAgLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZGVidWcuanNcbiAgdmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcblxuICAvLyBNZW1vcnkgbWFuYWdlbWVudFxuXG4gIHZhciB3YXNtTWVtb3J5O1xuXG4gIHZhciAvKiogQHR5cGUgeyFJbnQ4QXJyYXl9ICovXG4gICAgSEVBUDgsXG4gICAgLyoqIEB0eXBlIHshVWludDhBcnJheX0gKi9cbiAgICBIRUFQVTgsXG4gICAgLyoqIEB0eXBlIHshSW50MTZBcnJheX0gKi9cbiAgICBIRUFQMTYsXG4gICAgLyoqIEB0eXBlIHshVWludDE2QXJyYXl9ICovXG4gICAgSEVBUFUxNixcbiAgICAvKiogQHR5cGUgeyFJbnQzMkFycmF5fSAqL1xuICAgIEhFQVAzMixcbiAgICAvKiogQHR5cGUgeyFVaW50MzJBcnJheX0gKi9cbiAgICBIRUFQVTMyLFxuICAgIC8qKiBAdHlwZSB7IUZsb2F0MzJBcnJheX0gKi9cbiAgICBIRUFQRjMyLFxuICAgIC8qKiBAdHlwZSB7IUZsb2F0NjRBcnJheX0gKi9cbiAgICBIRUFQRjY0O1xuXG4gIC8vIEJpZ0ludDY0QXJyYXkgdHlwZSBpcyBub3QgY29ycmVjdGx5IGRlZmluZWQgaW4gY2xvc3VyZVxuICB2YXIgLyoqIG5vdC1AdHlwZSB7IUJpZ0ludDY0QXJyYXl9ICovXG4gICAgSEVBUDY0LFxuICAgIC8qIEJpZ1VpbnQ2NEFycmF5IHR5cGUgaXMgbm90IGNvcnJlY3RseSBkZWZpbmVkIGluIGNsb3N1cmVcbi8qKiBub3QtQHR5cGUgeyFCaWdVaW50NjRBcnJheX0gKi9cbiAgICBIRUFQVTY0O1xuXG4gIHZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpIHtcbiAgICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuICAgIEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiAgICBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiAgICBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICAgIEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpO1xuICAgIEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgSEVBUDY0ID0gbmV3IEJpZ0ludDY0QXJyYXkoYik7XG4gICAgSEVBUFU2NCA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuICAgIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAvLyBObyBBVElOSVRTIGhvb2tzXG5cbiAgICB3YXNtRXhwb3J0c1snX193YXNtX2NhbGxfY3RvcnMnXSgpO1xuXG4gICAgLy8gTm8gQVRQT1NUQ1RPUlMgaG9va3NcbiAgfVxuXG4gIC8vIEEgY291bnRlciBvZiBkZXBlbmRlbmNpZXMgZm9yIGNhbGxpbmcgcnVuKCkuIElmIHdlIG5lZWQgdG9cbiAgLy8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYmVmb3JlIHJ1bm5pbmcsIGluY3JlbWVudCB0aGlzIGFuZFxuICAvLyBkZWNyZW1lbnQgaXQuIEluY3JlbWVudGluZyBtdXN0IGhhcHBlbiBpbiBhIHBsYWNlIGxpa2VcbiAgLy8gTW9kdWxlLnByZVJ1biAodXNlZCBieSBlbWNjIHRvIGFkZCBmaWxlIHByZWxvYWRpbmcpLlxuICAvLyBOb3RlIHRoYXQgeW91IGNhbiBhZGQgZGVwZW5kZW5jaWVzIGluIHByZVJ1biwgZXZlbiB0aG91Z2hcbiAgLy8gaXQgaGFwcGVucyByaWdodCBiZWZvcmUgcnVuIC0gcnVuIHdpbGwgYmUgcG9zdHBvbmVkIHVudGlsXG4gIC8vIHRoZSBkZXBlbmRlbmNpZXMgYXJlIG1ldC5cbiAgdmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG4gIHZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsOyAvLyBvdmVycmlkZGVuIHRvIHRha2UgZGlmZmVyZW50IGFjdGlvbnMgd2hlbiBhbGwgcnVuIGRlcGVuZGVuY2llcyBhcmUgZnVsZmlsbGVkXG5cbiAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICAgIHJ1bkRlcGVuZGVuY2llcysrO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcbiAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSB3aGF0ICovXG4gIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgICB3aGF0ID0gJ0Fib3J0ZWQoJyArIHdoYXQgKyAnKSc7XG4gICAgLy8gVE9ETyhzYmMpOiBTaG91bGQgd2UgcmVtb3ZlIHByaW50aW5nIGFuZCBsZWF2ZSBpdCB1cCB0byB3aG9ldmVyXG4gICAgLy8gY2F0Y2hlcyB0aGUgZXhjZXB0aW9uP1xuICAgIGVycih3aGF0KTtcblxuICAgIEFCT1JUID0gdHJ1ZTtcblxuICAgIHdoYXQgKz0gJy4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4nO1xuXG4gICAgLy8gVXNlIGEgd2FzbSBydW50aW1lIGVycm9yLCBiZWNhdXNlIGEgSlMgZXJyb3IgbWlnaHQgYmUgc2VlbiBhcyBhIGZvcmVpZ25cbiAgICAvLyBleGNlcHRpb24sIHdoaWNoIG1lYW5zIHdlJ2QgcnVuIGRlc3RydWN0b3JzIG9uIGl0LiBXZSBuZWVkIHRoZSBlcnJvciB0b1xuICAgIC8vIHNpbXBseSBtYWtlIHRoZSBwcm9ncmFtIHN0b3AuXG4gICAgLy8gRklYTUUgVGhpcyBhcHByb2FjaCBkb2VzIG5vdCB3b3JrIGluIFdhc20gRUggYmVjYXVzZSBpdCBjdXJyZW50bHkgZG9lcyBub3QgYXNzdW1lXG4gICAgLy8gYWxsIFJ1bnRpbWVFcnJvcnMgYXJlIGZyb20gdHJhcHM7IGl0IGRlY2lkZXMgd2hldGhlciBhIFJ1bnRpbWVFcnJvciBpcyBmcm9tXG4gICAgLy8gYSB0cmFwIG9yIG5vdCBiYXNlZCBvbiBhIGhpZGRlbiBmaWVsZCB3aXRoaW4gdGhlIG9iamVjdC4gU28gYXQgdGhlIG1vbWVudFxuICAgIC8vIHdlIGRvbid0IGhhdmUgYSB3YXkgb2YgdGhyb3dpbmcgYSB3YXNtIHRyYXAgZnJvbSBKUy4gVE9ETyBNYWtlIGEgSlMgQVBJIHRoYXRcbiAgICAvLyBhbGxvd3MgdGhpcyBpbiB0aGUgd2FzbSBzcGVjLlxuXG4gICAgLy8gU3VwcHJlc3MgY2xvc3VyZSBjb21waWxlciB3YXJuaW5nIGhlcmUuIENsb3N1cmUgY29tcGlsZXIncyBidWlsdGluIGV4dGVyblxuICAgIC8vIGRlZmluaXRpb24gZm9yIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvciBjbGFpbXMgaXQgdGFrZXMgbm8gYXJndW1lbnRzIGV2ZW5cbiAgICAvLyB0aG91Z2ggaXQgY2FuLlxuICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL3B1bGwvMzkxMyk6IFJlbW92ZSBpZi93aGVuIHVwc3RyZWFtIGNsb3N1cmUgZ2V0cyBmaXhlZC5cbiAgICAvKiogQHN1cHByZXNzIHtjaGVja1R5cGVzfSAqL1xuICAgIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtcblxuICAgIHJlYWR5UHJvbWlzZVJlamVjdD8uKGUpO1xuICAgIC8vIFRocm93IHRoZSBlcnJvciB3aGV0aGVyIG9yIG5vdCBNT0RVTEFSSVpFIGlzIHNldCBiZWNhdXNlIGFib3J0IGlzIHVzZWRcbiAgICAvLyBpbiBjb2RlIHBhdGhzIGFwYXJ0IGZyb20gaW5zdGFudGlhdGlvbiB3aGVyZSBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWRcbiAgICAvLyB0byBiZSB0aHJvd24gd2hlbiBhYm9ydCBpcyBjYWxsZWQuXG4gICAgdGhyb3cgZVxuICB9XG5cbiAgdmFyIHdhc21CaW5hcnlGaWxlO1xuXG4gIGZ1bmN0aW9uIGZpbmRXYXNtQmluYXJ5KCkge1xuICAgIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgICAgcmV0dXJuIGxvY2F0ZUZpbGUoJ01lZGlhSW5mb01vZHVsZS53YXNtJylcbiAgICB9XG4gICAgLy8gVXNlIGJ1bmRsZXItZnJpZW5kbHkgYG5ldyBVUkwoLi4uLCBpbXBvcnQubWV0YS51cmwpYCBwYXR0ZXJuOyB3b3JrcyBpbiBicm93c2VycyB0b28uXG4gICAgcmV0dXJuIG5ldyBVUkwoJ01lZGlhSW5mb01vZHVsZS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpIHtcbiAgICB0aHJvdyAnYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQnXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBnZXRXYXNtQmluYXJ5KGJpbmFyeUZpbGUpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHRoZSBiaW5hcnkgeWV0LCBsb2FkIGl0IGFzeW5jaHJvbm91c2x5IHVzaW5nIHJlYWRBc3luYy5cbiAgICB7XG4gICAgICAvLyBGZXRjaCB0aGUgYmluYXJ5IHVzaW5nIHJlYWRBc3luY1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgcmVhZEFzeW5jKGJpbmFyeUZpbGUpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGdldEJpbmFyeVN5bmMgYmVsb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBnZXRCaW5hcnlTeW5jIHNob3VsZCBiZSBhYmxlIHRvIGdldCBpdCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGdldEJpbmFyeVN5bmMoKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBiaW5hcnkgPSBhd2FpdCBnZXRXYXNtQmluYXJ5KGJpbmFyeUZpbGUpO1xuICAgICAgdmFyIGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbXBvcnRzKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTtcblxuICAgICAgYWJvcnQocmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cykge1xuICAgIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZldGNoKGJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSk7XG4gICAgICAgIHZhciBpbnN0YW50aWF0aW9uUmVzdWx0ID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGltcG9ydHMpO1xuICAgICAgICByZXR1cm4gaW5zdGFudGlhdGlvblJlc3VsdFxuICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgbW9zdCBjb21tb24gZmFpbHVyZSBjYXVzZSB0byBiZSBhIGJhZCBNSU1FIHR5cGUgZm9yIHRoZSBiaW5hcnksXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24gc2hvdWxkIHdvcmsuXG4gICAgICAgIGVycihgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7cmVhc29ufWApO1xuICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgIC8vIGZhbGwgYmFjayBvZiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyIGJlbG93XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRXYXNtSW1wb3J0cygpIHtcbiAgICAvLyBwcmVwYXJlIGltcG9ydHNcbiAgICByZXR1cm4ge1xuICAgICAgZW52OiB3YXNtSW1wb3J0cyxcbiAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IHdhc21JbXBvcnRzLFxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgd2FzbSBpbnN0YW5jZS5cbiAgLy8gUmVjZWl2ZXMgdGhlIHdhc20gaW1wb3J0cywgcmV0dXJucyB0aGUgZXhwb3J0cy5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICAvLyBMb2FkIHRoZSB3YXNtIG1vZHVsZSBhbmQgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHVzaW5nIG5hdGl2ZSBzdXBwb3J0IGluIHRoZSBKUyBlbmdpbmUuXG4gICAgLy8gaGFuZGxlIGEgZ2VuZXJhdGVkIHdhc20gaW5zdGFuY2UsIHJlY2VpdmluZyBpdHMgZXhwb3J0cyBhbmRcbiAgICAvLyBwZXJmb3JtaW5nIG90aGVyIG5lY2Vzc2FyeSBzZXR1cFxuICAgIC8qKiBAcGFyYW0ge1dlYkFzc2VtYmx5Lk1vZHVsZT19IG1vZHVsZSovXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICAgIHdhc21FeHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcblxuICAgICAgd2FzbU1lbW9yeSA9IHdhc21FeHBvcnRzWydtZW1vcnknXTtcblxuICAgICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcblxuICAgICAgd2FzbVRhYmxlID0gd2FzbUV4cG9ydHNbJ19faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUnXTtcblxuICAgICAgYXNzaWduV2FzbUV4cG9ydHMod2FzbUV4cG9ydHMpO1xuICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgpO1xuICAgICAgcmV0dXJuIHdhc21FeHBvcnRzXG4gICAgfVxuICAgIC8vIHdhaXQgZm9yIHRoZSBwdGhyZWFkIHBvb2wgKGlmIGFueSlcbiAgICBhZGRSdW5EZXBlbmRlbmN5KCk7XG5cbiAgICAvLyBQcmVmZXIgc3RyZWFtaW5nIGluc3RhbnRpYXRpb24gaWYgYXZhaWxhYmxlLlxuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCkge1xuICAgICAgLy8gJ3Jlc3VsdCcgaXMgYSBSZXN1bHRPYmplY3Qgb2JqZWN0IHdoaWNoIGhhcyBib3RoIHRoZSBtb2R1bGUgYW5kIGluc3RhbmNlLlxuICAgICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcbiAgICAgIC8vIFRPRE86IER1ZSB0byBDbG9zdXJlIHJlZ3Jlc3Npb24gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMTkzLCB0aGUgYWJvdmUgbGluZSBubyBsb25nZXIgb3B0aW1pemVzIG91dCBkb3duIHRvIHRoZSBmb2xsb3dpbmcgbGluZS5cbiAgICAgIC8vIFdoZW4gdGhlIHJlZ3Jlc3Npb24gaXMgZml4ZWQsIGNhbiByZXN0b3JlIHRoZSBhYm92ZSBQVEhSRUFEUy1lbmFibGVkIHBhdGguXG4gICAgICByZXR1cm4gcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsnaW5zdGFuY2UnXSlcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IGdldFdhc21JbXBvcnRzKCk7XG5cbiAgICB3YXNtQmluYXJ5RmlsZSA/Pz0gZmluZFdhc21CaW5hcnkoKTtcbiAgICB2YXIgcmVzdWx0ID0gYXdhaXQgaW5zdGFudGlhdGVBc3luYyh3YXNtQmluYXJ5LCB3YXNtQmluYXJ5RmlsZSwgaW5mbyk7XG4gICAgdmFyIGV4cG9ydHMgPSByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpO1xuICAgIHJldHVybiBleHBvcnRzXG4gIH1cblxuICB2YXIgX19hYm9ydF9qcyA9ICgpID0+IGFib3J0KCcnKTtcblxuICB2YXIgQXNjaWlUb1N0cmluZyA9IChwdHIpID0+IHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHZhciBjaCA9IEhFQVBVOFtwdHIrK107XG4gICAgICBpZiAoIWNoKSByZXR1cm4gc3RyXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhd2FpdGluZ0RlcGVuZGVuY2llcyA9IHt9O1xuXG4gIHZhciByZWdpc3RlcmVkVHlwZXMgPSB7fTtcblxuICB2YXIgdHlwZURlcGVuZGVuY2llcyA9IHt9O1xuXG4gIHZhciBCaW5kaW5nRXJyb3IgPSBjbGFzcyBCaW5kaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB0aGlzLm5hbWUgPSAnQmluZGluZ0Vycm9yJztcbiAgICB9XG4gIH07XG4gIHZhciB0aHJvd0JpbmRpbmdFcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcihtZXNzYWdlKVxuICB9O1xuICAvKiogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICovXG4gIGZ1bmN0aW9uIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLCByZWdpc3RlcmVkSW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBuYW1lID0gcmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7XG4gICAgaWYgKCFyYXdUeXBlKSB7XG4gICAgICB0aHJvd0JpbmRpbmdFcnJvcihgdHlwZSBcIiR7bmFtZX1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7XG4gICAgfVxuICAgIGlmIChyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHtcbiAgICAgIGlmIChvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7bmFtZX0nIHR3aWNlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdID0gcmVnaXN0ZXJlZEluc3RhbmNlO1xuICAgIGRlbGV0ZSB0eXBlRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO1xuXG4gICAgaWYgKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07XG4gICAgICBkZWxldGUgYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIH1cbiAgfVxuICAvKiogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCByZWdpc3RlcmVkSW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBzaGFyZWRSZWdpc3RlclR5cGUocmF3VHlwZSwgcmVnaXN0ZXJlZEluc3RhbmNlLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlciA9IChuYW1lLCB3aWR0aCwgc2lnbmVkKSA9PiB7XG4gICAgLy8gaW50ZWdlcnMgYXJlIHF1aXRlIGNvbW1vbiwgc28gZ2VuZXJhdGUgdmVyeSBzcGVjaWFsaXplZCBmdW5jdGlvbnNcbiAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBzaWduZWQgPyAocG9pbnRlcikgPT4gSEVBUDhbcG9pbnRlcl0gOiAocG9pbnRlcikgPT4gSEVBUFU4W3BvaW50ZXJdXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBzaWduZWQgPyAocG9pbnRlcikgPT4gSEVBUDE2W3BvaW50ZXIgPj4gMV0gOiAocG9pbnRlcikgPT4gSEVBUFUxNltwb2ludGVyID4+IDFdXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBzaWduZWQgPyAocG9pbnRlcikgPT4gSEVBUDMyW3BvaW50ZXIgPj4gMl0gOiAocG9pbnRlcikgPT4gSEVBUFUzMltwb2ludGVyID4+IDJdXG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiBzaWduZWQgPyAocG9pbnRlcikgPT4gSEVBUDY0W3BvaW50ZXIgPj4gM10gOiAocG9pbnRlcikgPT4gSEVBUFU2NFtwb2ludGVyID4+IDNdXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApXG4gICAgfVxuICB9O1xuICAvKiogQHN1cHByZXNzIHtnbG9iYWxUaGlzfSAqL1xuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50ID0gKHByaW1pdGl2ZVR5cGUsIG5hbWUsIHNpemUsIG1pblJhbmdlLCBtYXhSYW5nZSkgPT4ge1xuICAgIG5hbWUgPSBBc2NpaVRvU3RyaW5nKG5hbWUpO1xuXG4gICAgY29uc3QgaXNVbnNpZ25lZFR5cGUgPSBtaW5SYW5nZSA9PT0gMG47XG5cbiAgICBsZXQgZnJvbVdpcmVUeXBlID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgICBpZiAoaXNVbnNpZ25lZFR5cGUpIHtcbiAgICAgIC8vIHVpbnQ2NCBnZXQgY29udmVydGVkIHRvIGludDY0IGluIEFCSSwgZml4IHRoZW0gdXAgbGlrZSB3ZSBkbyBmb3IgMzItYml0IGludGVnZXJzLlxuICAgICAgY29uc3QgYml0U2l6ZSA9IHNpemUgKiA4O1xuICAgICAgZnJvbVdpcmVUeXBlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50TihiaXRTaXplLCB2YWx1ZSlcbiAgICAgIH07XG4gICAgICBtYXhSYW5nZSA9IGZyb21XaXJlVHlwZShtYXhSYW5nZSk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUsIHtcbiAgICAgIG5hbWUsXG4gICAgICBmcm9tV2lyZVR5cGU6IGZyb21XaXJlVHlwZSxcbiAgICAgIHRvV2lyZVR5cGU6IChkZXN0cnVjdG9ycywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH0sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNpemUsICFpc1Vuc2lnbmVkVHlwZSksXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsIC8vIFRoaXMgdHlwZSBkb2VzIG5vdCBuZWVkIGEgZGVzdHJ1Y3RvclxuICAgIH0pO1xuICB9O1xuXG4gIC8qKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9ICovXG4gIHZhciBfX2VtYmluZF9yZWdpc3Rlcl9ib29sID0gKHJhd1R5cGUsIG5hbWUsIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSkgPT4ge1xuICAgIG5hbWUgPSBBc2NpaVRvU3RyaW5nKG5hbWUpO1xuICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7XG4gICAgICBuYW1lLFxuICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAod3QpIHtcbiAgICAgICAgLy8gYW1iaWd1b3VzIGVtc2NyaXB0ZW4gQUJJOiBzb21ldGltZXMgcmV0dXJuIHZhbHVlcyBhcmVcbiAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZSwgYW5kIHNvbWV0aW1lcyBpbnRlZ2VycyAoMCBvciAxKVxuICAgICAgICByZXR1cm4gISF3dFxuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgbykge1xuICAgICAgICByZXR1cm4gbyA/IHRydWVWYWx1ZSA6IGZhbHNlVmFsdWVcbiAgICAgIH0sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKEhFQVBVOFtwb2ludGVyXSlcbiAgICAgIH0sXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsIC8vIFRoaXMgdHlwZSBkb2VzIG5vdCBuZWVkIGEgZGVzdHJ1Y3RvclxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzaGFsbG93Q29weUludGVybmFsUG9pbnRlciA9IChvKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBvLmNvdW50LFxuICAgICAgZGVsZXRlU2NoZWR1bGVkOiBvLmRlbGV0ZVNjaGVkdWxlZCxcbiAgICAgIHByZXNlcnZlUG9pbnRlck9uRGVsZXRlOiBvLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlLFxuICAgICAgcHRyOiBvLnB0cixcbiAgICAgIHB0clR5cGU6IG8ucHRyVHlwZSxcbiAgICAgIHNtYXJ0UHRyOiBvLnNtYXJ0UHRyLFxuICAgICAgc21hcnRQdHJUeXBlOiBvLnNtYXJ0UHRyVHlwZSxcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCA9IChvYmopID0+IHtcbiAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZVR5cGVOYW1lKGhhbmRsZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5uYW1lXG4gICAgfVxuICAgIHRocm93QmluZGluZ0Vycm9yKGdldEluc3RhbmNlVHlwZU5hbWUob2JqKSArICcgaW5zdGFuY2UgYWxyZWFkeSBkZWxldGVkJyk7XG4gIH07XG5cbiAgdmFyIGZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZmFsc2U7XG5cbiAgdmFyIGRldGFjaEZpbmFsaXplciA9IChoYW5kbGUpID0+IHt9O1xuXG4gIHZhciBydW5EZXN0cnVjdG9yID0gKCQkKSA9PiB7XG4gICAgaWYgKCQkLnNtYXJ0UHRyKSB7XG4gICAgICAkJC5zbWFydFB0clR5cGUucmF3RGVzdHJ1Y3RvcigkJC5zbWFydFB0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoJCQucHRyKTtcbiAgICB9XG4gIH07XG4gIHZhciByZWxlYXNlQ2xhc3NIYW5kbGUgPSAoJCQpID0+IHtcbiAgICAkJC5jb3VudC52YWx1ZSAtPSAxO1xuICAgIHZhciB0b0RlbGV0ZSA9IDAgPT09ICQkLmNvdW50LnZhbHVlO1xuICAgIGlmICh0b0RlbGV0ZSkge1xuICAgICAgcnVuRGVzdHJ1Y3RvcigkJCk7XG4gICAgfVxuICB9O1xuICB2YXIgYXR0YWNoRmluYWxpemVyID0gKGhhbmRsZSkgPT4ge1xuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gICAgICBhdHRhY2hGaW5hbGl6ZXIgPSAoaGFuZGxlKSA9PiBoYW5kbGU7XG4gICAgICByZXR1cm4gaGFuZGxlXG4gICAgfVxuICAgIC8vIElmIHRoZSBydW5uaW5nIGVudmlyb25tZW50IGhhcyBhIEZpbmFsaXphdGlvblJlZ2lzdHJ5IChzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC13ZWFrcmVmcyksIHRoZW4gYXR0YWNoIGZpbmFsaXplcnNcbiAgICAvLyBmb3IgY2xhc3MgaGFuZGxlcy4gIFdlIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAvLyBhdCBydW4tdGltZSwgbm90IGJ1aWxkLXRpbWUuXG4gICAgZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGluZm8pID0+IHtcbiAgICAgIHJlbGVhc2VDbGFzc0hhbmRsZShpbmZvLiQkKTtcbiAgICB9KTtcbiAgICBhdHRhY2hGaW5hbGl6ZXIgPSAoaGFuZGxlKSA9PiB7XG4gICAgICB2YXIgJCQgPSBoYW5kbGUuJCQ7XG4gICAgICB2YXIgaGFzU21hcnRQdHIgPSAhISQkLnNtYXJ0UHRyO1xuICAgICAgaWYgKGhhc1NtYXJ0UHRyKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgY2FsbCB0aGUgZGVzdHJ1Y3RvciBvbiByYXcgcG9pbnRlcnMgaW4gY2FzZSBvdGhlciBjb2RlIGV4cGVjdHMgdGhlIHBvaW50ZWUgdG8gbGl2ZVxuICAgICAgICB2YXIgaW5mbyA9IHsgJCQ6ICQkIH07XG4gICAgICAgIGZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKGhhbmRsZSwgaW5mbywgaGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVcbiAgICB9O1xuICAgIGRldGFjaEZpbmFsaXplciA9IChoYW5kbGUpID0+IGZpbmFsaXphdGlvblJlZ2lzdHJ5LnVucmVnaXN0ZXIoaGFuZGxlKTtcbiAgICByZXR1cm4gYXR0YWNoRmluYWxpemVyKGhhbmRsZSlcbiAgfTtcbiAgdmFyIGluaXRfQ2xhc3NIYW5kbGUgPSAoKSA9PiB7XG4gICAgbGV0IHByb3RvID0gQ2xhc3NIYW5kbGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmFzc2lnbihwcm90bywge1xuICAgICAgaXNBbGlhc09mKG90aGVyKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzc0hhbmRsZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRDbGFzcyA9IHRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy4kJC5wdHI7XG4gICAgICAgIG90aGVyLiQkID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvdGhlci4kJCk7XG4gICAgICAgIHZhciByaWdodENsYXNzID0gb3RoZXIuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7XG4gICAgICAgIHZhciByaWdodCA9IG90aGVyLiQkLnB0cjtcblxuICAgICAgICB3aGlsZSAobGVmdENsYXNzLmJhc2VDbGFzcykge1xuICAgICAgICAgIGxlZnQgPSBsZWZ0Q2xhc3MudXBjYXN0KGxlZnQpO1xuICAgICAgICAgIGxlZnRDbGFzcyA9IGxlZnRDbGFzcy5iYXNlQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmlnaHRDbGFzcy5iYXNlQ2xhc3MpIHtcbiAgICAgICAgICByaWdodCA9IHJpZ2h0Q2xhc3MudXBjYXN0KHJpZ2h0KTtcbiAgICAgICAgICByaWdodENsYXNzID0gcmlnaHRDbGFzcy5iYXNlQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVmdENsYXNzID09PSByaWdodENsYXNzICYmIGxlZnQgPT09IHJpZ2h0XG4gICAgICB9LFxuXG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiQkLnB0cikge1xuICAgICAgICAgIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKSB7XG4gICAgICAgICAgdGhpcy4kJC5jb3VudC52YWx1ZSArPSAxO1xuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb25lID0gYXR0YWNoRmluYWxpemVyKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHtcbiAgICAgICAgICAgICAgJCQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIodGhpcy4kJCksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjbG9uZS4kJC5jb3VudC52YWx1ZSArPSAxO1xuICAgICAgICAgIGNsb25lLiQkLmRlbGV0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBjbG9uZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkZWxldGUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kJC5wdHIpIHtcbiAgICAgICAgICB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHtcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoRmluYWxpemVyKHRoaXMpO1xuICAgICAgICByZWxlYXNlQ2xhc3NIYW5kbGUodGhpcy4kJCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKSB7XG4gICAgICAgICAgdGhpcy4kJC5zbWFydFB0ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLiQkLnB0ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaXNEZWxldGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuJCQucHRyXG4gICAgICB9LFxuXG4gICAgICBkZWxldGVMYXRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiQkLnB0cikge1xuICAgICAgICAgIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHtcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTdXBwb3J0IGB1c2luZyAuLi5gIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXhwbGljaXQtcmVzb3VyY2UtbWFuYWdlbWVudC5cbiAgICBjb25zdCBzeW1ib2xEaXNwb3NlID0gU3ltYm9sLmRpc3Bvc2U7XG4gICAgaWYgKHN5bWJvbERpc3Bvc2UpIHtcbiAgICAgIHByb3RvW3N5bWJvbERpc3Bvc2VdID0gcHJvdG9bJ2RlbGV0ZSddO1xuICAgIH1cbiAgfTtcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiBDbGFzc0hhbmRsZSgpIHt9XG5cbiAgdmFyIGNyZWF0ZU5hbWVkRnVuY3Rpb24gPSAobmFtZSwgZnVuYykgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmMsICduYW1lJywgeyB2YWx1ZTogbmFtZSB9KTtcblxuICB2YXIgcmVnaXN0ZXJlZFBvaW50ZXJzID0ge307XG5cbiAgdmFyIGVuc3VyZU92ZXJsb2FkVGFibGUgPSAocHJvdG8sIG1ldGhvZE5hbWUsIGh1bWFuTmFtZSkgPT4ge1xuICAgIGlmICh1bmRlZmluZWQgPT09IHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpIHtcbiAgICAgIHZhciBwcmV2RnVuYyA9IHByb3RvW21ldGhvZE5hbWVdO1xuICAgICAgLy8gSW5qZWN0IGFuIG92ZXJsb2FkIHJlc29sdmVyIGZ1bmN0aW9uIHRoYXQgcm91dGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvdmVybG9hZCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAgICAgIHByb3RvW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVE9ETyBUaGlzIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIC1PMyBsZXZlbCBcInVuc2FmZVwiIG9wdGltaXphdGlvbnMuXG4gICAgICAgIGlmICghcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZS5oYXNPd25Qcm9wZXJ0eShhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihcbiAgICAgICAgICAgIGBGdW5jdGlvbiAnJHtodW1hbk5hbWV9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7YXJncy5sZW5ndGh9KSAtIGV4cGVjdHMgb25lIG9mICgke3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGV9KSFgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmdzLmxlbmd0aF0uYXBwbHkodGhpcywgYXJncylcbiAgICAgIH07XG4gICAgICAvLyBNb3ZlIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBpbnRvIHRoZSBvdmVybG9hZCB0YWJsZS5cbiAgICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUgPSBbXTtcbiAgICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbcHJldkZ1bmMuYXJnQ291bnRdID0gcHJldkZ1bmM7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBAcGFyYW0ge251bWJlcj19IG51bUFyZ3VtZW50cyAqL1xuICB2YXIgZXhwb3NlUHVibGljU3ltYm9sID0gKG5hbWUsIHZhbHVlLCBudW1Bcmd1bWVudHMpID0+IHtcbiAgICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyR7bmFtZX0nIHR3aWNlYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFyZSBleHBvc2luZyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhbiBleGlzdGluZyBmdW5jdGlvbi4gQ3JlYXRlIGFuIG92ZXJsb2FkIHRhYmxlIGFuZCBhIGZ1bmN0aW9uIHNlbGVjdG9yXG4gICAgICAvLyB0aGF0IHJvdXRlcyBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICBlbnN1cmVPdmVybG9hZFRhYmxlKE1vZHVsZSwgbmFtZSwgbmFtZSk7XG4gICAgICBpZiAoTW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGUuaGFzT3duUHJvcGVydHkobnVtQXJndW1lbnRzKSkge1xuICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJHtudW1Bcmd1bWVudHN9KSFgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIG5ldyBmdW5jdGlvbiBpbnRvIHRoZSBvdmVybG9hZCB0YWJsZS5cbiAgICAgIE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgTW9kdWxlW25hbWVdID0gdmFsdWU7XG4gICAgICBNb2R1bGVbbmFtZV0uYXJnQ291bnQgPSBudW1Bcmd1bWVudHM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGFyXzAgPSA0ODtcblxuICB2YXIgY2hhcl85ID0gNTc7XG4gIHZhciBtYWtlTGVnYWxGdW5jdGlvbk5hbWUgPSAobmFtZSkgPT4ge1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05X10vZywgJyQnKTtcbiAgICB2YXIgZiA9IG5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoZiA+PSBjaGFyXzAgJiYgZiA8PSBjaGFyXzkpIHtcbiAgICAgIHJldHVybiBgXyR7bmFtZX1gXG4gICAgfVxuICAgIHJldHVybiBuYW1lXG4gIH07XG5cbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiBSZWdpc3RlcmVkQ2xhc3MoXG4gICAgbmFtZSxcbiAgICBjb25zdHJ1Y3RvcixcbiAgICBpbnN0YW5jZVByb3RvdHlwZSxcbiAgICByYXdEZXN0cnVjdG9yLFxuICAgIGJhc2VDbGFzcyxcbiAgICBnZXRBY3R1YWxUeXBlLFxuICAgIHVwY2FzdCxcbiAgICBkb3duY2FzdFxuICApIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICB0aGlzLmluc3RhbmNlUHJvdG90eXBlID0gaW5zdGFuY2VQcm90b3R5cGU7XG4gICAgdGhpcy5yYXdEZXN0cnVjdG9yID0gcmF3RGVzdHJ1Y3RvcjtcbiAgICB0aGlzLmJhc2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICB0aGlzLmdldEFjdHVhbFR5cGUgPSBnZXRBY3R1YWxUeXBlO1xuICAgIHRoaXMudXBjYXN0ID0gdXBjYXN0O1xuICAgIHRoaXMuZG93bmNhc3QgPSBkb3duY2FzdDtcbiAgICB0aGlzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zID0gW107XG4gIH1cblxuICB2YXIgdXBjYXN0UG9pbnRlciA9IChwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MpID0+IHtcbiAgICB3aGlsZSAocHRyQ2xhc3MgIT09IGRlc2lyZWRDbGFzcykge1xuICAgICAgaWYgKCFwdHJDbGFzcy51cGNhc3QpIHtcbiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgJHtkZXNpcmVkQ2xhc3MubmFtZX0sIGdvdCBhbiBpbnN0YW5jZSBvZiAke3B0ckNsYXNzLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHRyID0gcHRyQ2xhc3MudXBjYXN0KHB0cik7XG4gICAgICBwdHJDbGFzcyA9IHB0ckNsYXNzLmJhc2VDbGFzcztcbiAgICB9XG4gICAgcmV0dXJuIHB0clxuICB9O1xuXG4gIHZhciBlbWJpbmRSZXByID0gKHYpID0+IHtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJ1xuICAgIH1cbiAgICB2YXIgdCA9IHR5cGVvZiB2O1xuICAgIGlmICh0ID09PSAnb2JqZWN0JyB8fCB0ID09PSAnYXJyYXknIHx8IHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnICsgdlxuICAgIH1cbiAgfTtcbiAgLyoqIEBzdXBwcmVzcyB7Z2xvYmFsVGhpc30gKi9cbiAgZnVuY3Rpb24gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsIGhhbmRsZSkge1xuICAgIGlmIChoYW5kbGUgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7XG4gICAgICAgIHRocm93QmluZGluZ0Vycm9yKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZS4kJCkge1xuICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIFwiJHtlbWJpbmRSZXByKGhhbmRsZSl9XCIgYXMgYSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKCFoYW5kbGUuJCQucHRyKSB7XG4gICAgICB0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgfVxuICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO1xuICAgIHJldHVybiBwdHJcbiAgfVxuXG4gIC8qKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9ICovXG4gIGZ1bmN0aW9uIGdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7XG4gICAgdmFyIHB0cjtcbiAgICBpZiAoaGFuZGxlID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5pc1JlZmVyZW5jZSkge1xuICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHtcbiAgICAgICAgcHRyID0gdGhpcy5yYXdDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHtcbiAgICAgICAgICBkZXN0cnVjdG9ycy5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvciwgcHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHRyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFuZGxlIHx8ICFoYW5kbGUuJCQpIHtcbiAgICAgIHRocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBcIiR7ZW1iaW5kUmVwcihoYW5kbGUpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlLiQkLnB0cikge1xuICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNDb25zdCAmJiBoYW5kbGUuJCQucHRyVHlwZS5pc0NvbnN0KSB7XG4gICAgICB0aHJvd0JpbmRpbmdFcnJvcihcbiAgICAgICAgYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO1xuICAgIHB0ciA9IHVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0ciwgaGFuZGxlQ2xhc3MsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTtcblxuICAgIGlmICh0aGlzLmlzU21hcnRQb2ludGVyKSB7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdCBzdHJpY3RseSB0cnVlXG4gICAgICAvLyBXZSBjb3VsZCBzdXBwb3J0IEJZX0VNVkFMIGNvbnZlcnNpb25zIGZyb20gcmF3IHBvaW50ZXJzIHRvIHNtYXJ0IHBvaW50ZXJzXG4gICAgICAvLyBiZWNhdXNlIHRoZSBzbWFydCBwb2ludGVyIGNhbiBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBoYW5kbGVcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IGhhbmRsZS4kJC5zbWFydFB0cikge1xuICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignUGFzc2luZyByYXcgcG9pbnRlciB0byBzbWFydCBwb2ludGVyIGlzIGlsbGVnYWwnKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLnNoYXJpbmdQb2xpY3kpIHtcbiAgICAgICAgY2FzZSAwOiAvLyBOT05FXG4gICAgICAgICAgLy8gbm8gdXBjYXN0aW5nXG4gICAgICAgICAgaWYgKGhhbmRsZS4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHB0ciA9IGhhbmRsZS4kJC5zbWFydFB0cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoXG4gICAgICAgICAgICAgIGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7aGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA/IGhhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZSA6IGhhbmRsZS4kJC5wdHJUeXBlLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAxOiAvLyBJTlRSVVNJVkVcbiAgICAgICAgICBwdHIgPSBoYW5kbGUuJCQuc21hcnRQdHI7XG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIDI6IC8vIEJZX0VNVkFMXG4gICAgICAgICAgaWYgKGhhbmRsZS4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHB0ciA9IGhhbmRsZS4kJC5zbWFydFB0cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNsb25lZEhhbmRsZSA9IGhhbmRsZVsnY2xvbmUnXSgpO1xuICAgICAgICAgICAgcHRyID0gdGhpcy5yYXdTaGFyZShcbiAgICAgICAgICAgICAgcHRyLFxuICAgICAgICAgICAgICBFbXZhbC50b0hhbmRsZSgoKSA9PiBjbG9uZWRIYW5kbGVbJ2RlbGV0ZSddKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCBwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ1Vuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHRyXG4gIH1cblxuICAvKiogQHN1cHByZXNzIHtnbG9iYWxUaGlzfSAqL1xuICBmdW5jdGlvbiBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7XG4gICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UpIHtcbiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoYG51bGwgaXMgbm90IGEgdmFsaWQgJHt0aGlzLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGlmICghaGFuZGxlLiQkKSB7XG4gICAgICB0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3MgXCIke2VtYmluZFJlcHIoaGFuZGxlKX1cIiBhcyBhICR7dGhpcy5uYW1lfWApO1xuICAgIH1cbiAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHtcbiAgICAgIHRocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3QpIHtcbiAgICAgIHRocm93QmluZGluZ0Vycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke2hhbmRsZS4kJC5wdHJUeXBlLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO1xuICAgIHJldHVybiBwdHJcbiAgfVxuXG4gIC8qKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9ICovXG4gIGZ1bmN0aW9uIHJlYWRQb2ludGVyKHBvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoSEVBUFUzMltwb2ludGVyID4+IDJdKVxuICB9XG5cbiAgdmFyIGRvd25jYXN0UG9pbnRlciA9IChwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MpID0+IHtcbiAgICBpZiAocHRyQ2xhc3MgPT09IGRlc2lyZWRDbGFzcykge1xuICAgICAgcmV0dXJuIHB0clxuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBkZXNpcmVkQ2xhc3MuYmFzZUNsYXNzKSB7XG4gICAgICByZXR1cm4gbnVsbCAvLyBubyBjb252ZXJzaW9uXG4gICAgfVxuXG4gICAgdmFyIHJ2ID0gZG93bmNhc3RQb2ludGVyKHB0ciwgcHRyQ2xhc3MsIGRlc2lyZWRDbGFzcy5iYXNlQ2xhc3MpO1xuICAgIGlmIChydiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRDbGFzcy5kb3duY2FzdChydilcbiAgfTtcblxuICB2YXIgcmVnaXN0ZXJlZEluc3RhbmNlcyA9IHt9O1xuXG4gIHZhciBnZXRCYXNlc3RQb2ludGVyID0gKGNsYXNzXywgcHRyKSA9PiB7XG4gICAgaWYgKHB0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvd0JpbmRpbmdFcnJvcigncHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHdoaWxlIChjbGFzc18uYmFzZUNsYXNzKSB7XG4gICAgICBwdHIgPSBjbGFzc18udXBjYXN0KHB0cik7XG4gICAgICBjbGFzc18gPSBjbGFzc18uYmFzZUNsYXNzO1xuICAgIH1cbiAgICByZXR1cm4gcHRyXG4gIH07XG4gIHZhciBnZXRJbmhlcml0ZWRJbnN0YW5jZSA9IChjbGFzc18sIHB0cikgPT4ge1xuICAgIHB0ciA9IGdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLCBwdHIpO1xuICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFuY2VzW3B0cl1cbiAgfTtcblxuICB2YXIgSW50ZXJuYWxFcnJvciA9IGNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB0aGlzLm5hbWUgPSAnSW50ZXJuYWxFcnJvcic7XG4gICAgfVxuICB9O1xuICB2YXIgdGhyb3dJbnRlcm5hbEVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihtZXNzYWdlKVxuICB9O1xuXG4gIHZhciBtYWtlQ2xhc3NIYW5kbGUgPSAocHJvdG90eXBlLCByZWNvcmQpID0+IHtcbiAgICBpZiAoIXJlY29yZC5wdHJUeXBlIHx8ICFyZWNvcmQucHRyKSB7XG4gICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ21ha2VDbGFzc0hhbmRsZSByZXF1aXJlcyBwdHIgYW5kIHB0clR5cGUnKTtcbiAgICB9XG4gICAgdmFyIGhhc1NtYXJ0UHRyVHlwZSA9ICEhcmVjb3JkLnNtYXJ0UHRyVHlwZTtcbiAgICB2YXIgaGFzU21hcnRQdHIgPSAhIXJlY29yZC5zbWFydFB0cjtcbiAgICBpZiAoaGFzU21hcnRQdHJUeXBlICE9PSBoYXNTbWFydFB0cikge1xuICAgICAgdGhyb3dJbnRlcm5hbEVycm9yKCdCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgcmVjb3JkLmNvdW50ID0geyB2YWx1ZTogMSB9O1xuICAgIHJldHVybiBhdHRhY2hGaW5hbGl6ZXIoXG4gICAgICBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSwge1xuICAgICAgICAkJDoge1xuICAgICAgICAgIHZhbHVlOiByZWNvcmQsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIClcbiAgfTtcbiAgLyoqIEBzdXBwcmVzcyB7Z2xvYmFsVGhpc30gKi9cbiAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlKHB0cikge1xuICAgIC8vIHB0ciBpcyBhIHJhdyBwb2ludGVyIChvciBhIHJhdyBzbWFydHBvaW50ZXIpXG5cbiAgICAvLyByYXdQb2ludGVyIGlzIGEgbWF5YmUtbnVsbCByYXcgcG9pbnRlclxuICAgIHZhciByYXdQb2ludGVyID0gdGhpcy5nZXRQb2ludGVlKHB0cik7XG4gICAgaWYgKCFyYXdQb2ludGVyKSB7XG4gICAgICB0aGlzLmRlc3RydWN0b3IocHRyKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdGVyZWRJbnN0YW5jZSA9IGdldEluaGVyaXRlZEluc3RhbmNlKHRoaXMucmVnaXN0ZXJlZENsYXNzLCByYXdQb2ludGVyKTtcbiAgICBpZiAodW5kZWZpbmVkICE9PSByZWdpc3RlcmVkSW5zdGFuY2UpIHtcbiAgICAgIC8vIEpTIG9iamVjdCBoYXMgYmVlbiBuZXV0ZXJlZCwgdGltZSB0byByZXBvcHVsYXRlIGl0XG4gICAgICBpZiAoMCA9PT0gcmVnaXN0ZXJlZEluc3RhbmNlLiQkLmNvdW50LnZhbHVlKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRJbnN0YW5jZS4kJC5wdHIgPSByYXdQb2ludGVyO1xuICAgICAgICByZWdpc3RlcmVkSW5zdGFuY2UuJCQuc21hcnRQdHIgPSBwdHI7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFuY2VbJ2Nsb25lJ10oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWxzZSwganVzdCBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50IG9uIGV4aXN0aW5nIG9iamVjdFxuICAgICAgICAvLyBpdCBhbHJlYWR5IGhhcyBhIHJlZmVyZW5jZSB0byB0aGUgc21hcnQgcG9pbnRlclxuICAgICAgICB2YXIgcnYgPSByZWdpc3RlcmVkSW5zdGFuY2VbJ2Nsb25lJ10oKTtcbiAgICAgICAgdGhpcy5kZXN0cnVjdG9yKHB0cik7XG4gICAgICAgIHJldHVybiBydlxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEZWZhdWx0SGFuZGxlKCkge1xuICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgICAgIHB0clR5cGU6IHRoaXMucG9pbnRlZVR5cGUsXG4gICAgICAgICAgcHRyOiByYXdQb2ludGVyLFxuICAgICAgICAgIHNtYXJ0UHRyVHlwZTogdGhpcyxcbiAgICAgICAgICBzbWFydFB0cjogcHRyLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgICAgIHB0clR5cGU6IHRoaXMsXG4gICAgICAgICAgcHRyLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxUeXBlID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShyYXdQb2ludGVyKTtcbiAgICB2YXIgcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQgPSByZWdpc3RlcmVkUG9pbnRlcnNbYWN0dWFsVHlwZV07XG4gICAgaWYgKCFyZWdpc3RlcmVkUG9pbnRlclJlY29yZCkge1xuICAgICAgcmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcylcbiAgICB9XG5cbiAgICB2YXIgdG9UeXBlO1xuICAgIGlmICh0aGlzLmlzQ29uc3QpIHtcbiAgICAgIHRvVHlwZSA9IHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkLmNvbnN0UG9pbnRlclR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVHlwZSA9IHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkLnBvaW50ZXJUeXBlO1xuICAgIH1cbiAgICB2YXIgZHAgPSBkb3duY2FzdFBvaW50ZXIocmF3UG9pbnRlciwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MsIHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MpO1xuICAgIGlmIChkcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcylcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHtcbiAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgICBwdHJUeXBlOiB0b1R5cGUsXG4gICAgICAgIHB0cjogZHAsXG4gICAgICAgIHNtYXJ0UHRyVHlwZTogdGhpcyxcbiAgICAgICAgc21hcnRQdHI6IHB0cixcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgICBwdHJUeXBlOiB0b1R5cGUsXG4gICAgICAgIHB0cjogZHAsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICB2YXIgaW5pdF9SZWdpc3RlcmVkUG9pbnRlciA9ICgpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZSwge1xuICAgICAgZ2V0UG9pbnRlZShwdHIpIHtcbiAgICAgICAgaWYgKHRoaXMucmF3R2V0UG9pbnRlZSkge1xuICAgICAgICAgIHB0ciA9IHRoaXMucmF3R2V0UG9pbnRlZShwdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdHJcbiAgICAgIH0sXG4gICAgICBkZXN0cnVjdG9yKHB0cikge1xuICAgICAgICB0aGlzLnJhd0Rlc3RydWN0b3I/LihwdHIpO1xuICAgICAgfSxcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiByZWFkUG9pbnRlcixcbiAgICAgIGZyb21XaXJlVHlwZTogUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlLFxuICAgIH0pO1xuICB9O1xuICAvKiogQGNvbnN0cnVjdG9yXG4gICAgICBAcGFyYW0geyo9fSBwb2ludGVlVHlwZSxcbiAgICAgIEBwYXJhbSB7Kj19IHNoYXJpbmdQb2xpY3ksXG4gICAgICBAcGFyYW0geyo9fSByYXdHZXRQb2ludGVlLFxuICAgICAgQHBhcmFtIHsqPX0gcmF3Q29uc3RydWN0b3IsXG4gICAgICBAcGFyYW0geyo9fSByYXdTaGFyZSxcbiAgICAgIEBwYXJhbSB7Kj19IHJhd0Rlc3RydWN0b3IsXG4gICAgICAgKi9cbiAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXIoXG4gICAgbmFtZSxcbiAgICByZWdpc3RlcmVkQ2xhc3MsXG4gICAgaXNSZWZlcmVuY2UsXG4gICAgaXNDb25zdCxcblxuICAgIC8vIHNtYXJ0IHBvaW50ZXIgcHJvcGVydGllc1xuICAgIGlzU21hcnRQb2ludGVyLFxuICAgIHBvaW50ZWVUeXBlLFxuICAgIHNoYXJpbmdQb2xpY3ksXG4gICAgcmF3R2V0UG9pbnRlZSxcbiAgICByYXdDb25zdHJ1Y3RvcixcbiAgICByYXdTaGFyZSxcbiAgICByYXdEZXN0cnVjdG9yXG4gICkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yZWdpc3RlcmVkQ2xhc3MgPSByZWdpc3RlcmVkQ2xhc3M7XG4gICAgdGhpcy5pc1JlZmVyZW5jZSA9IGlzUmVmZXJlbmNlO1xuICAgIHRoaXMuaXNDb25zdCA9IGlzQ29uc3Q7XG5cbiAgICAvLyBzbWFydCBwb2ludGVyIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzU21hcnRQb2ludGVyID0gaXNTbWFydFBvaW50ZXI7XG4gICAgdGhpcy5wb2ludGVlVHlwZSA9IHBvaW50ZWVUeXBlO1xuICAgIHRoaXMuc2hhcmluZ1BvbGljeSA9IHNoYXJpbmdQb2xpY3k7XG4gICAgdGhpcy5yYXdHZXRQb2ludGVlID0gcmF3R2V0UG9pbnRlZTtcbiAgICB0aGlzLnJhd0NvbnN0cnVjdG9yID0gcmF3Q29uc3RydWN0b3I7XG4gICAgdGhpcy5yYXdTaGFyZSA9IHJhd1NoYXJlO1xuICAgIHRoaXMucmF3RGVzdHJ1Y3RvciA9IHJhd0Rlc3RydWN0b3I7XG5cbiAgICBpZiAoIWlzU21hcnRQb2ludGVyICYmIHJlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGlzQ29uc3QpIHtcbiAgICAgICAgdGhpcy50b1dpcmVUeXBlID0gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGU7XG4gICAgICAgIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9XaXJlVHlwZSA9IG5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlO1xuICAgICAgICB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9XaXJlVHlwZSA9IGdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZTtcbiAgICAgIC8vIEhlcmUgd2UgbXVzdCBsZWF2ZSB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiB1bmRlZmluZWQsIHNpbmNlIHdoZXRoZXIgZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlIHJldHVybnNcbiAgICAgIC8vIGEgcG9pbnRlciB0aGF0IG5lZWRzIHRvIGJlIGZyZWVkIHVwIGlzIHJ1bnRpbWUtZGVwZW5kZW50LCBhbmQgY2Fubm90IGJlIGV2YWx1YXRlZCBhdCByZWdpc3RyYXRpb24gdGltZS5cbiAgICAgIC8vIFRPRE86IENyZWF0ZSBhbiBhbHRlcm5hdGl2ZSBtZWNoYW5pc20gdGhhdCBhbGxvd3MgcmVtb3ZpbmcgdGhlIHVzZSBvZiB2YXIgZGVzdHJ1Y3RvcnMgPSBbXTsgYXJyYXkgaW5cbiAgICAgIC8vICAgICAgIGNyYWZ0SW52b2tlckZ1bmN0aW9uIGFsdG9nZXRoZXIuXG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyPX0gbnVtQXJndW1lbnRzICovXG4gIHZhciByZXBsYWNlUHVibGljU3ltYm9sID0gKG5hbWUsIHZhbHVlLCBudW1Bcmd1bWVudHMpID0+IHtcbiAgICBpZiAoIU1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhyb3dJbnRlcm5hbEVycm9yKCdSZXBsYWNpbmcgbm9uZXhpc3RlbnQgcHVibGljIHN5bWJvbCcpO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIGFuIG92ZXJsb2FkIHRhYmxlIGZvciB0aGlzIHN5bWJvbCwgcmVwbGFjZSB0aGUgc3ltYm9sIGluIHRoZSBvdmVybG9hZCB0YWJsZSBpbnN0ZWFkLlxuICAgIGlmICh1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlICYmIHVuZGVmaW5lZCAhPT0gbnVtQXJndW1lbnRzKSA7IGVsc2Uge1xuICAgICAgTW9kdWxlW25hbWVdID0gdmFsdWU7XG4gICAgICBNb2R1bGVbbmFtZV0uYXJnQ291bnQgPSBudW1Bcmd1bWVudHM7XG4gICAgfVxuICB9O1xuXG4gIHZhciB3YXNtVGFibGVNaXJyb3IgPSBbXTtcblxuICAvKiogQHR5cGUge1dlYkFzc2VtYmx5LlRhYmxlfSAqL1xuICB2YXIgd2FzbVRhYmxlO1xuICB2YXIgZ2V0V2FzbVRhYmxlRW50cnkgPSAoZnVuY1B0cikgPT4ge1xuICAgIHZhciBmdW5jID0gd2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgICAgIHdhc21UYWJsZU1pcnJvcltmdW5jUHRyXSA9IGZ1bmMgPSB3YXNtVGFibGUuZ2V0KGZ1bmNQdHIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY1xuICB9O1xuICB2YXIgZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24gPSAoc2lnbmF0dXJlLCByYXdGdW5jdGlvbiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgc2lnbmF0dXJlID0gQXNjaWlUb1N0cmluZyhzaWduYXR1cmUpO1xuXG4gICAgZnVuY3Rpb24gbWFrZUR5bkNhbGxlcigpIHtcbiAgICAgIHZhciBydG4gPSBnZXRXYXNtVGFibGVFbnRyeShyYXdGdW5jdGlvbik7XG4gICAgICByZXR1cm4gcnRuXG4gICAgfVxuXG4gICAgdmFyIGZwID0gbWFrZUR5bkNhbGxlcigpO1xuICAgIGlmICh0eXBlb2YgZnAgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoYHVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAke3NpZ25hdHVyZX06ICR7cmF3RnVuY3Rpb259YCk7XG4gICAgfVxuICAgIHJldHVybiBmcFxuICB9O1xuXG4gIGNsYXNzIFVuYm91bmRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4gIHZhciBnZXRUeXBlTmFtZSA9ICh0eXBlKSA9PiB7XG4gICAgdmFyIHB0ciA9IF9fX2dldFR5cGVOYW1lKHR5cGUpO1xuICAgIHZhciBydiA9IEFzY2lpVG9TdHJpbmcocHRyKTtcbiAgICBfZnJlZShwdHIpO1xuICAgIHJldHVybiBydlxuICB9O1xuICB2YXIgdGhyb3dVbmJvdW5kVHlwZUVycm9yID0gKG1lc3NhZ2UsIHR5cGVzKSA9PiB7XG4gICAgdmFyIHVuYm91bmRUeXBlcyA9IFtdO1xuICAgIHZhciBzZWVuID0ge307XG4gICAgZnVuY3Rpb24gdmlzaXQodHlwZSkge1xuICAgICAgaWYgKHNlZW5bdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0ZXJlZFR5cGVzW3R5cGVdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0pIHtcbiAgICAgICAgdHlwZURlcGVuZGVuY2llc1t0eXBlXS5mb3JFYWNoKHZpc2l0KTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1bmJvdW5kVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgIHNlZW5bdHlwZV0gPSB0cnVlO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKHZpc2l0KTtcblxuICAgIHRocm93IG5ldyBVbmJvdW5kVHlwZUVycm9yKGAke21lc3NhZ2V9OiBgICsgdW5ib3VuZFR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbihbJywgJ10pKVxuICB9O1xuXG4gIHZhciB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZCA9IChteVR5cGVzLCBkZXBlbmRlbnRUeXBlcywgZ2V0VHlwZUNvbnZlcnRlcnMpID0+IHtcbiAgICBteVR5cGVzLmZvckVhY2goKHR5cGUpID0+ICh0eXBlRGVwZW5kZW5jaWVzW3R5cGVdID0gZGVwZW5kZW50VHlwZXMpKTtcblxuICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpIHtcbiAgICAgIHZhciBteVR5cGVDb252ZXJ0ZXJzID0gZ2V0VHlwZUNvbnZlcnRlcnModHlwZUNvbnZlcnRlcnMpO1xuICAgICAgaWYgKG15VHlwZUNvbnZlcnRlcnMubGVuZ3RoICE9PSBteVR5cGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ01pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnQnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXlUeXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICByZWdpc3RlclR5cGUobXlUeXBlc1tpXSwgbXlUeXBlQ29udmVydGVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHR5cGVDb252ZXJ0ZXJzID0gbmV3IEFycmF5KGRlcGVuZGVudFR5cGVzLmxlbmd0aCk7XG4gICAgdmFyIHVucmVnaXN0ZXJlZFR5cGVzID0gW107XG4gICAgdmFyIHJlZ2lzdGVyZWQgPSAwO1xuICAgIGRlcGVuZGVudFR5cGVzLmZvckVhY2goKGR0LCBpKSA9PiB7XG4gICAgICBpZiAocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KGR0KSkge1xuICAgICAgICB0eXBlQ29udmVydGVyc1tpXSA9IHJlZ2lzdGVyZWRUeXBlc1tkdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnJlZ2lzdGVyZWRUeXBlcy5wdXNoKGR0KTtcbiAgICAgICAgaWYgKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHtcbiAgICAgICAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgdHlwZUNvbnZlcnRlcnNbaV0gPSByZWdpc3RlcmVkVHlwZXNbZHRdO1xuICAgICAgICAgICsrcmVnaXN0ZXJlZDtcbiAgICAgICAgICBpZiAocmVnaXN0ZXJlZCA9PT0gdW5yZWdpc3RlcmVkVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgwID09PSB1bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpIHtcbiAgICAgIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpO1xuICAgIH1cbiAgfTtcbiAgdmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzID0gKFxuICAgIHJhd1R5cGUsXG4gICAgcmF3UG9pbnRlclR5cGUsXG4gICAgcmF3Q29uc3RQb2ludGVyVHlwZSxcbiAgICBiYXNlQ2xhc3NSYXdUeXBlLFxuICAgIGdldEFjdHVhbFR5cGVTaWduYXR1cmUsXG4gICAgZ2V0QWN0dWFsVHlwZSxcbiAgICB1cGNhc3RTaWduYXR1cmUsXG4gICAgdXBjYXN0LFxuICAgIGRvd25jYXN0U2lnbmF0dXJlLFxuICAgIGRvd25jYXN0LFxuICAgIG5hbWUsXG4gICAgZGVzdHJ1Y3RvclNpZ25hdHVyZSxcbiAgICByYXdEZXN0cnVjdG9yXG4gICkgPT4ge1xuICAgIG5hbWUgPSBBc2NpaVRvU3RyaW5nKG5hbWUpO1xuICAgIGdldEFjdHVhbFR5cGUgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXRBY3R1YWxUeXBlU2lnbmF0dXJlLCBnZXRBY3R1YWxUeXBlKTtcbiAgICB1cGNhc3QgJiY9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHVwY2FzdFNpZ25hdHVyZSwgdXBjYXN0KTtcbiAgICBkb3duY2FzdCAmJj0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZG93bmNhc3RTaWduYXR1cmUsIGRvd25jYXN0KTtcbiAgICByYXdEZXN0cnVjdG9yID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSwgcmF3RGVzdHJ1Y3Rvcik7XG4gICAgdmFyIGxlZ2FsRnVuY3Rpb25OYW1lID0gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO1xuXG4gICAgZXhwb3NlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzIGNvZGUgY2Fubm90IHJ1biBpZiBiYXNlQ2xhc3NSYXdUeXBlIGlzIHplcm9cbiAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGNvbnN0cnVjdCAke25hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgW2Jhc2VDbGFzc1Jhd1R5cGVdKTtcbiAgICB9KTtcblxuICAgIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFxuICAgICAgW3Jhd1R5cGUsIHJhd1BvaW50ZXJUeXBlLCByYXdDb25zdFBvaW50ZXJUeXBlXSxcbiAgICAgIGJhc2VDbGFzc1Jhd1R5cGUgPyBbYmFzZUNsYXNzUmF3VHlwZV0gOiBbXSxcbiAgICAgIChiYXNlKSA9PiB7XG4gICAgICAgIGJhc2UgPSBiYXNlWzBdO1xuXG4gICAgICAgIHZhciBiYXNlQ2xhc3M7XG4gICAgICAgIHZhciBiYXNlUHJvdG90eXBlO1xuICAgICAgICBpZiAoYmFzZUNsYXNzUmF3VHlwZSkge1xuICAgICAgICAgIGJhc2VDbGFzcyA9IGJhc2UucmVnaXN0ZXJlZENsYXNzO1xuICAgICAgICAgIGJhc2VQcm90b3R5cGUgPSBiYXNlQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVByb3RvdHlwZSA9IENsYXNzSGFuZGxlLnByb3RvdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24obmFtZSwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBpbnN0YW5jZVByb3RvdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcihgVXNlICduZXcnIHRvIGNvbnN0cnVjdCAke25hbWV9YClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoYCR7bmFtZX0gaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3JgKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYm9keSA9IHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ3MubGVuZ3RoXTtcbiAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBib2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKFxuICAgICAgICAgICAgICBgVHJpZWQgdG8gaW52b2tlIGN0b3Igb2YgJHtuYW1lfSB3aXRoIGludmFsaWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCR7YXJncy5sZW5ndGh9KSAtIGV4cGVjdGVkICgke09iamVjdC5rZXlzKHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KS50b1N0cmluZygpfSkgcGFyYW1ldGVycyBpbnN0ZWFkIWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGluc3RhbmNlUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IGNvbnN0cnVjdG9yIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGluc3RhbmNlUHJvdG90eXBlO1xuXG4gICAgICAgIHZhciByZWdpc3RlcmVkQ2xhc3MgPSBuZXcgUmVnaXN0ZXJlZENsYXNzKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29uc3RydWN0b3IsXG4gICAgICAgICAgaW5zdGFuY2VQcm90b3R5cGUsXG4gICAgICAgICAgcmF3RGVzdHJ1Y3RvcixcbiAgICAgICAgICBiYXNlQ2xhc3MsXG4gICAgICAgICAgZ2V0QWN0dWFsVHlwZSxcbiAgICAgICAgICB1cGNhc3QsXG4gICAgICAgICAgZG93bmNhc3RcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAocmVnaXN0ZXJlZENsYXNzLmJhc2VDbGFzcykge1xuICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgY2xhc3MgaGllcmFyY2h5LiBVc2VkIHRvIGFsbG93IHN1Yi1jbGFzc2VzIHRvIGluaGVyaXQgY2xhc3MgZnVuY3Rpb25zLlxuICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3MuX19kZXJpdmVkQ2xhc3NlcyA/Pz0gW107XG5cbiAgICAgICAgICByZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzLl9fZGVyaXZlZENsYXNzZXMucHVzaChyZWdpc3RlcmVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZmVyZW5jZUNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLCByZWdpc3RlcmVkQ2xhc3MsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIHBvaW50ZXJDb252ZXJ0ZXIgPSBuZXcgUmVnaXN0ZXJlZFBvaW50ZXIoXG4gICAgICAgICAgbmFtZSArICcqJyxcbiAgICAgICAgICByZWdpc3RlcmVkQ2xhc3MsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgY29uc3RQb2ludGVyQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKFxuICAgICAgICAgIG5hbWUgKyAnIGNvbnN0KicsXG4gICAgICAgICAgcmVnaXN0ZXJlZENsYXNzLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICByZWdpc3RlcmVkUG9pbnRlcnNbcmF3VHlwZV0gPSB7XG4gICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJDb252ZXJ0ZXIsXG4gICAgICAgICAgY29uc3RQb2ludGVyVHlwZTogY29uc3RQb2ludGVyQ29udmVydGVyLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcGxhY2VQdWJsaWNTeW1ib2wobGVnYWxGdW5jdGlvbk5hbWUsIGNvbnN0cnVjdG9yKTtcblxuICAgICAgICByZXR1cm4gW3JlZmVyZW5jZUNvbnZlcnRlciwgcG9pbnRlckNvbnZlcnRlciwgY29uc3RQb2ludGVyQ29udmVydGVyXVxuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhlYXAzMlZlY3RvclRvQXJyYXkgPSAoY291bnQsIGZpcnN0RWxlbWVudCkgPT4ge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vaXNzdWVzLzE3MzEwKTpcbiAgICAgIC8vIEZpbmQgYSB3YXkgdG8gaG9pc3QgdGhlIGA+PiAyYCBvciBgPj4gM2Agb3V0IG9mIHRoaXMgbG9vcC5cbiAgICAgIGFycmF5LnB1c2goSEVBUFUzMlsoZmlyc3RFbGVtZW50ICsgaSAqIDQpID4+IDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5XG4gIH07XG5cbiAgdmFyIHJ1bkRlc3RydWN0b3JzID0gKGRlc3RydWN0b3JzKSA9PiB7XG4gICAgd2hpbGUgKGRlc3RydWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIHB0ciA9IGRlc3RydWN0b3JzLnBvcCgpO1xuICAgICAgdmFyIGRlbCA9IGRlc3RydWN0b3JzLnBvcCgpO1xuICAgICAgZGVsKHB0cik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHVzZXNEZXN0cnVjdG9yU3RhY2soYXJnVHlwZXMpIHtcbiAgICAvLyBTa2lwIHJldHVybiB2YWx1ZSBhdCBpbmRleCAwIC0gaXQncyBub3QgZGVsZXRlZCBoZXJlLlxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIFRoZSB0eXBlIGRvZXMgbm90IGRlZmluZSBhIGRlc3RydWN0b3IgZnVuY3Rpb24gLSBtdXN0IHVzZSBkeW5hbWljIHN0YWNrXG4gICAgICBpZiAoYXJnVHlwZXNbaV0gIT09IG51bGwgJiYgYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVKc0ludm9rZXIoYXJnVHlwZXMsIGlzQ2xhc3NNZXRob2RGdW5jLCByZXR1cm5zLCBpc0FzeW5jKSB7XG4gICAgdmFyIG5lZWRzRGVzdHJ1Y3RvclN0YWNrID0gdXNlc0Rlc3RydWN0b3JTdGFjayhhcmdUeXBlcyk7XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJnVHlwZXMubGVuZ3RoIC0gMjtcbiAgICB2YXIgYXJnc0xpc3QgPSBbXTtcbiAgICB2YXIgYXJnc0xpc3RXaXJlZCA9IFsnZm4nXTtcbiAgICBpZiAoaXNDbGFzc01ldGhvZEZ1bmMpIHtcbiAgICAgIGFyZ3NMaXN0V2lyZWQucHVzaCgndGhpc1dpcmVkJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7ICsraSkge1xuICAgICAgYXJnc0xpc3QucHVzaChgYXJnJHtpfWApO1xuICAgICAgYXJnc0xpc3RXaXJlZC5wdXNoKGBhcmcke2l9V2lyZWRgKTtcbiAgICB9XG4gICAgYXJnc0xpc3QgPSBhcmdzTGlzdC5qb2luKCcsJyk7XG4gICAgYXJnc0xpc3RXaXJlZCA9IGFyZ3NMaXN0V2lyZWQuam9pbignLCcpO1xuXG4gICAgdmFyIGludm9rZXJGbkJvZHkgPSBgcmV0dXJuIGZ1bmN0aW9uICgke2FyZ3NMaXN0fSkge1xcbmA7XG5cbiAgICBpZiAobmVlZHNEZXN0cnVjdG9yU3RhY2spIHtcbiAgICAgIGludm9rZXJGbkJvZHkgKz0gJ3ZhciBkZXN0cnVjdG9ycyA9IFtdO1xcbic7XG4gICAgfVxuXG4gICAgdmFyIGR0b3JTdGFjayA9IG5lZWRzRGVzdHJ1Y3RvclN0YWNrID8gJ2Rlc3RydWN0b3JzJyA6ICdudWxsJztcbiAgICB2YXIgYXJnczEgPSBbXG4gICAgICAnaHVtYW5OYW1lJyxcbiAgICAgICd0aHJvd0JpbmRpbmdFcnJvcicsXG4gICAgICAnaW52b2tlcicsXG4gICAgICAnZm4nLFxuICAgICAgJ3J1bkRlc3RydWN0b3JzJyxcbiAgICAgICdmcm9tUmV0V2lyZScsXG4gICAgICAndG9DbGFzc1BhcmFtV2lyZScsXG4gICAgXTtcblxuICAgIGlmIChpc0NsYXNzTWV0aG9kRnVuYykge1xuICAgICAgaW52b2tlckZuQm9keSArPSBgdmFyIHRoaXNXaXJlZCA9IHRvQ2xhc3NQYXJhbVdpcmUoJHtkdG9yU3RhY2t9LCB0aGlzKTtcXG5gO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7ICsraSkge1xuICAgICAgdmFyIGFyZ05hbWUgPSBgdG9Bcmcke2l9V2lyZWA7XG4gICAgICBpbnZva2VyRm5Cb2R5ICs9IGB2YXIgYXJnJHtpfVdpcmVkID0gJHthcmdOYW1lfSgke2R0b3JTdGFja30sIGFyZyR7aX0pO1xcbmA7XG4gICAgICBhcmdzMS5wdXNoKGFyZ05hbWUpO1xuICAgIH1cblxuICAgIGludm9rZXJGbkJvZHkgKz0gKHJldHVybnMgfHwgaXNBc3luYyA/ICd2YXIgcnYgPSAnIDogJycpICsgYGludm9rZXIoJHthcmdzTGlzdFdpcmVkfSk7XFxuYDtcblxuICAgIGlmIChuZWVkc0Rlc3RydWN0b3JTdGFjaykge1xuICAgICAgaW52b2tlckZuQm9keSArPSAncnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSBpc0NsYXNzTWV0aG9kRnVuYyA/IDEgOiAyOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gU2tpcCByZXR1cm4gdmFsdWUgYXQgaW5kZXggMCAtIGl0J3Mgbm90IGRlbGV0ZWQgaGVyZS4gQWxzbyBza2lwIGNsYXNzIHR5cGUgaWYgbm90IGEgbWV0aG9kLlxuICAgICAgICB2YXIgcGFyYW1OYW1lID0gaSA9PT0gMSA/ICd0aGlzV2lyZWQnIDogJ2FyZycgKyAoaSAtIDIpICsgJ1dpcmVkJztcbiAgICAgICAgaWYgKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGludm9rZXJGbkJvZHkgKz0gYCR7cGFyYW1OYW1lfV9kdG9yKCR7cGFyYW1OYW1lfSk7XFxuYDtcbiAgICAgICAgICBhcmdzMS5wdXNoKGAke3BhcmFtTmFtZX1fZHRvcmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldHVybnMpIHtcbiAgICAgIGludm9rZXJGbkJvZHkgKz0gJ3ZhciByZXQgPSBmcm9tUmV0V2lyZShydik7XFxuJyArICdyZXR1cm4gcmV0O1xcbic7XG4gICAgfVxuXG4gICAgaW52b2tlckZuQm9keSArPSAnfVxcbic7XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGFyZ3MxLCBpbnZva2VyRm5Cb2R5KVxuICB9XG4gIGZ1bmN0aW9uIGNyYWZ0SW52b2tlckZ1bmN0aW9uKFxuICAgIGh1bWFuTmFtZSxcbiAgICBhcmdUeXBlcyxcbiAgICBjbGFzc1R5cGUsXG4gICAgY3BwSW52b2tlckZ1bmMsXG4gICAgY3BwVGFyZ2V0RnVuYyxcbiAgICAvKiogYm9vbGVhbj0gKi8gaXNBc3luY1xuICApIHtcbiAgICAvLyBodW1hbk5hbWU6IGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG5hbWUgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBnZW5lcmF0ZWQuXG4gICAgLy8gYXJnVHlwZXM6IEFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGVtYmluZCB0eXBlIG9iamVjdHMgZm9yIGFsbCB0eXBlcyBpbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlLlxuICAgIC8vICAgIGFyZ1R5cGVzWzBdIGlzIHRoZSB0eXBlIG9iamVjdCBmb3IgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZS5cbiAgICAvLyAgICBhcmdUeXBlc1sxXSBpcyB0aGUgdHlwZSBvYmplY3QgZm9yIGZ1bmN0aW9uIHRoaXMgb2JqZWN0L2NsYXNzIHR5cGUsIG9yIG51bGwgaWYgbm90IGNyYWZ0aW5nIGFuIGludm9rZXIgZm9yIGEgY2xhc3MgbWV0aG9kLlxuICAgIC8vICAgIGFyZ1R5cGVzWzIuLi5dIGFyZSB0aGUgYWN0dWFsIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXG4gICAgLy8gY2xhc3NUeXBlOiBUaGUgZW1iaW5kIHR5cGUgb2JqZWN0IGZvciB0aGUgY2xhc3MgdG8gYmUgYm91bmQsIG9yIG51bGwgaWYgdGhpcyBpcyBub3QgYSBtZXRob2Qgb2YgYSBjbGFzcy5cbiAgICAvLyBjcHBJbnZva2VyRnVuYzogSlMgRnVuY3Rpb24gb2JqZWN0IHRvIHRoZSBDKystc2lkZSBmdW5jdGlvbiB0aGF0IGludGVyb3BzIGludG8gQysrIGNvZGUuXG4gICAgLy8gY3BwVGFyZ2V0RnVuYzogRnVuY3Rpb24gcG9pbnRlciAoYW4gaW50ZWdlciB0byBGVU5DVElPTl9UQUJMRSkgdG8gdGhlIHRhcmdldCBDKysgZnVuY3Rpb24gdGhlIGNwcEludm9rZXJGdW5jIHdpbGwgZW5kIHVwIGNhbGxpbmcuXG4gICAgLy8gaXNBc3luYzogT3B0aW9uYWwuIElmIHRydWUsIHJldHVybnMgYW4gYXN5bmMgZnVuY3Rpb24uIEFzeW5jIGJpbmRpbmdzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIEpTUEkuXG4gICAgdmFyIGFyZ0NvdW50ID0gYXJnVHlwZXMubGVuZ3RoO1xuXG4gICAgaWYgKGFyZ0NvdW50IDwgMikge1xuICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoXG4gICAgICAgIFwiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGlzQ2xhc3NNZXRob2RGdW5jID0gYXJnVHlwZXNbMV0gIT09IG51bGwgJiYgY2xhc3NUeXBlICE9PSBudWxsO1xuXG4gICAgLy8gRnJlZSBmdW5jdGlvbnMgd2l0aCBzaWduYXR1cmUgXCJ2b2lkIGZ1bmN0aW9uKClcIiBkbyBub3QgbmVlZCBhbiBpbnZva2VyIHRoYXQgbWFyc2hhbGxzIGJldHdlZW4gd2lyZSB0eXBlcy5cbiAgICAvLyBUT0RPOiBUaGlzIG9taXRzIGFyZ3VtZW50IGNvdW50IGNoZWNrIC0gZW5hYmxlIG9ubHkgYXQgLU8zIG9yIHNpbWlsYXIuXG4gICAgLy8gICAgaWYgKEVOQUJMRV9VTlNBRkVfT1BUUyAmJiBhcmdDb3VudCA9PSAyICYmIGFyZ1R5cGVzWzBdLm5hbWUgPT0gXCJ2b2lkXCIgJiYgIWlzQ2xhc3NNZXRob2RGdW5jKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIEZVTkNUSU9OX1RBQkxFW2ZuXTtcbiAgICAvLyAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byB1c2UgYSBkeW5hbWljIHN0YWNrIHRvIHN0b3JlIHRoZSBkZXN0cnVjdG9ycyBmb3IgdGhlIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY29tcGxldGVseSBvbmNlIGFsbCBmdW5jdGlvbiBpbnZva2VycyBhcmUgYmVpbmcgZHluYW1pY2FsbHkgZ2VuZXJhdGVkLlxuICAgIHZhciBuZWVkc0Rlc3RydWN0b3JTdGFjayA9IHVzZXNEZXN0cnVjdG9yU3RhY2soYXJnVHlwZXMpO1xuXG4gICAgdmFyIHJldHVybnMgPSAhYXJnVHlwZXNbMF0uaXNWb2lkO1xuICAgIC8vIEJ1aWxsZCB0aGUgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byB0aGUgY2xvc3VyZSBhcm91bmQgdGhlIGludm9rZXJcbiAgICAvLyBmdW5jdGlvbi5cbiAgICB2YXIgcmV0VHlwZSA9IGFyZ1R5cGVzWzBdO1xuICAgIHZhciBpbnN0VHlwZSA9IGFyZ1R5cGVzWzFdO1xuICAgIHZhciBjbG9zdXJlQXJncyA9IFtcbiAgICAgIGh1bWFuTmFtZSxcbiAgICAgIHRocm93QmluZGluZ0Vycm9yLFxuICAgICAgY3BwSW52b2tlckZ1bmMsXG4gICAgICBjcHBUYXJnZXRGdW5jLFxuICAgICAgcnVuRGVzdHJ1Y3RvcnMsXG4gICAgICByZXRUeXBlLmZyb21XaXJlVHlwZS5iaW5kKHJldFR5cGUpLFxuICAgICAgaW5zdFR5cGU/LnRvV2lyZVR5cGUuYmluZChpbnN0VHlwZSksXG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ0NvdW50OyArK2kpIHtcbiAgICAgIHZhciBhcmdUeXBlID0gYXJnVHlwZXNbaV07XG4gICAgICBjbG9zdXJlQXJncy5wdXNoKGFyZ1R5cGUudG9XaXJlVHlwZS5iaW5kKGFyZ1R5cGUpKTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc0Rlc3RydWN0b3JTdGFjaykge1xuICAgICAgLy8gU2tpcCByZXR1cm4gdmFsdWUgYXQgaW5kZXggMCAtIGl0J3Mgbm90IGRlbGV0ZWQgaGVyZS4gQWxzbyBza2lwIGNsYXNzIHR5cGUgaWYgbm90IGEgbWV0aG9kLlxuICAgICAgZm9yICh2YXIgaSA9IGlzQ2xhc3NNZXRob2RGdW5jID8gMSA6IDI7IGkgPCBhcmdUeXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xvc3VyZUFyZ3MucHVzaChhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGludm9rZXJGYWN0b3J5ID0gY3JlYXRlSnNJbnZva2VyKGFyZ1R5cGVzLCBpc0NsYXNzTWV0aG9kRnVuYywgcmV0dXJucywgaXNBc3luYyk7XG4gICAgdmFyIGludm9rZXJGbiA9IGludm9rZXJGYWN0b3J5KC4uLmNsb3N1cmVBcmdzKTtcbiAgICByZXR1cm4gY3JlYXRlTmFtZWRGdW5jdGlvbihodW1hbk5hbWUsIGludm9rZXJGbilcbiAgfVxuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IgPSAoXG4gICAgcmF3Q2xhc3NUeXBlLFxuICAgIGFyZ0NvdW50LFxuICAgIHJhd0FyZ1R5cGVzQWRkcixcbiAgICBpbnZva2VyU2lnbmF0dXJlLFxuICAgIGludm9rZXIsXG4gICAgcmF3Q29uc3RydWN0b3JcbiAgKSA9PiB7XG4gICAgdmFyIHJhd0FyZ1R5cGVzID0gaGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyKTtcbiAgICBpbnZva2VyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSwgaW52b2tlcik7XG5cbiAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgW3Jhd0NsYXNzVHlwZV0sIChjbGFzc1R5cGUpID0+IHtcbiAgICAgIGNsYXNzVHlwZSA9IGNsYXNzVHlwZVswXTtcbiAgICAgIHZhciBodW1hbk5hbWUgPSBgY29uc3RydWN0b3IgJHtjbGFzc1R5cGUubmFtZX1gO1xuXG4gICAgICBpZiAodW5kZWZpbmVkID09PSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpIHtcbiAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5ID0gW107XG4gICAgICB9XG4gICAgICBpZiAodW5kZWZpbmVkICE9PSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQgLSAxXSkge1xuICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKFxuICAgICAgICAgIGBDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke2FyZ0NvdW50IC0gMX0pIGZvciBjbGFzcyAnJHtjbGFzc1R5cGUubmFtZX0nISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudCAtIDFdID0gKCkgPT4ge1xuICAgICAgICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBjb25zdHJ1Y3QgJHtjbGFzc1R5cGUubmFtZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLFxuICAgICAgICAgIHJhd0FyZ1R5cGVzXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIChhcmdUeXBlcykgPT4ge1xuICAgICAgICAvLyBJbnNlcnQgZW1wdHkgc2xvdCBmb3IgY29udGV4dCB0eXBlIChhcmdUeXBlc1sxXSkuXG4gICAgICAgIGFyZ1R5cGVzLnNwbGljZSgxLCAwLCBudWxsKTtcbiAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50IC0gMV0gPSBjcmFmdEludm9rZXJGdW5jdGlvbihcbiAgICAgICAgICBodW1hbk5hbWUsXG4gICAgICAgICAgYXJnVHlwZXMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBpbnZva2VyLFxuICAgICAgICAgIHJhd0NvbnN0cnVjdG9yXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW11cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ2V0RnVuY3Rpb25OYW1lID0gKHNpZ25hdHVyZSkgPT4ge1xuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50cmltKCk7XG4gICAgY29uc3QgYXJnc0luZGV4ID0gc2lnbmF0dXJlLmluZGV4T2YoJygnKTtcbiAgICBpZiAoYXJnc0luZGV4ID09PSAtMSkgcmV0dXJuIHNpZ25hdHVyZVxuICAgIHJldHVybiBzaWduYXR1cmUuc2xpY2UoMCwgYXJnc0luZGV4KVxuICB9O1xuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24gPSAoXG4gICAgcmF3Q2xhc3NUeXBlLFxuICAgIG1ldGhvZE5hbWUsXG4gICAgYXJnQ291bnQsXG4gICAgcmF3QXJnVHlwZXNBZGRyLCAvLyBbUmV0dXJuVHlwZSwgVGhpc1R5cGUsIEFyZ3MuLi5dXG4gICAgaW52b2tlclNpZ25hdHVyZSxcbiAgICByYXdJbnZva2VyLFxuICAgIGNvbnRleHQsXG4gICAgaXNQdXJlVmlydHVhbCxcbiAgICBpc0FzeW5jLFxuICAgIGlzTm9ubnVsbFJldHVyblxuICApID0+IHtcbiAgICB2YXIgcmF3QXJnVHlwZXMgPSBoZWFwMzJWZWN0b3JUb0FycmF5KGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIpO1xuICAgIG1ldGhvZE5hbWUgPSBBc2NpaVRvU3RyaW5nKG1ldGhvZE5hbWUpO1xuICAgIG1ldGhvZE5hbWUgPSBnZXRGdW5jdGlvbk5hbWUobWV0aG9kTmFtZSk7XG4gICAgcmF3SW52b2tlciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGludm9rZXJTaWduYXR1cmUsIHJhd0ludm9rZXIsIGlzQXN5bmMpO1xuXG4gICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFtyYXdDbGFzc1R5cGVdLCAoY2xhc3NUeXBlKSA9PiB7XG4gICAgICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07XG4gICAgICB2YXIgaHVtYW5OYW1lID0gYCR7Y2xhc3NUeXBlLm5hbWV9LiR7bWV0aG9kTmFtZX1gO1xuXG4gICAgICBpZiAobWV0aG9kTmFtZS5zdGFydHNXaXRoKCdAQCcpKSB7XG4gICAgICAgIG1ldGhvZE5hbWUgPSBTeW1ib2xbbWV0aG9kTmFtZS5zdWJzdHJpbmcoMildO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQdXJlVmlydHVhbCkge1xuICAgICAgICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVuYm91bmRUeXBlc0hhbmRsZXIoKSB7XG4gICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGNhbGwgJHtodW1hbk5hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgcmF3QXJnVHlwZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdG8gPSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlO1xuICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB1bmRlZmluZWQgPT09IG1ldGhvZCB8fFxuICAgICAgICAodW5kZWZpbmVkID09PSBtZXRob2Qub3ZlcmxvYWRUYWJsZSAmJlxuICAgICAgICAgIG1ldGhvZC5jbGFzc05hbWUgIT09IGNsYXNzVHlwZS5uYW1lICYmXG4gICAgICAgICAgbWV0aG9kLmFyZ0NvdW50ID09PSBhcmdDb3VudCAtIDIpXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgb3ZlcmxvYWQgdG8gYmUgcmVnaXN0ZXJlZCwgT1Igd2UgYXJlIHJlcGxhY2luZyBhXG4gICAgICAgIC8vIGZ1bmN0aW9uIGluIHRoZSBiYXNlIGNsYXNzIHdpdGggYSBmdW5jdGlvbiBpbiB0aGUgZGVyaXZlZCBjbGFzcy5cbiAgICAgICAgdW5ib3VuZFR5cGVzSGFuZGxlci5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMjtcbiAgICAgICAgdW5ib3VuZFR5cGVzSGFuZGxlci5jbGFzc05hbWUgPSBjbGFzc1R5cGUubmFtZTtcbiAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGV4aXN0aW5nIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSByZWdpc3RlcmVkLiBTZXQgdXBcbiAgICAgICAgLy8gYSBmdW5jdGlvbiBvdmVybG9hZCByb3V0aW5nIHRhYmxlLlxuICAgICAgICBlbnN1cmVPdmVybG9hZFRhYmxlKHByb3RvLCBtZXRob2ROYW1lLCBodW1hbk5hbWUpO1xuICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50IC0gMl0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIChhcmdUeXBlcykgPT4ge1xuICAgICAgICB2YXIgbWVtYmVyRnVuY3Rpb24gPSBjcmFmdEludm9rZXJGdW5jdGlvbihcbiAgICAgICAgICBodW1hbk5hbWUsXG4gICAgICAgICAgYXJnVHlwZXMsXG4gICAgICAgICAgY2xhc3NUeXBlLFxuICAgICAgICAgIHJhd0ludm9rZXIsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBpc0FzeW5jXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgaW5pdGlhbCB1bmJvdW5kLWhhbmRsZXItc3R1YiBmdW5jdGlvbiB3aXRoIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBtZW1iZXIgZnVuY3Rpb24sIG5vdyB0aGF0IGFsbCB0eXBlcyBhcmUgcmVzb2x2ZWQuIElmXG4gICAgICAgIC8vIG11bHRpcGxlIG92ZXJsb2FkcyBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGdvZXMgaW50byBhbiBvdmVybG9hZCB0YWJsZS5cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSkge1xuICAgICAgICAgIC8vIFNldCBhcmdDb3VudCBpbiBjYXNlIGFuIG92ZXJsb2FkIGlzIHJlZ2lzdGVyZWQgbGF0ZXJcbiAgICAgICAgICBtZW1iZXJGdW5jdGlvbi5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMjtcbiAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IG1lbWJlckZ1bmN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQgLSAyXSA9IG1lbWJlckZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbXVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBlbXZhbF9mcmVlbGlzdCA9IFtdO1xuXG4gIHZhciBlbXZhbF9oYW5kbGVzID0gWzAsIDEsICwgMSwgbnVsbCwgMSwgdHJ1ZSwgMSwgZmFsc2UsIDFdO1xuICB2YXIgX19lbXZhbF9kZWNyZWYgPSAoaGFuZGxlKSA9PiB7XG4gICAgaWYgKGhhbmRsZSA+IDkgJiYgMCA9PT0gLS1lbXZhbF9oYW5kbGVzW2hhbmRsZSArIDFdKSB7XG4gICAgICBlbXZhbF9oYW5kbGVzW2hhbmRsZV0gPSB1bmRlZmluZWQ7XG4gICAgICBlbXZhbF9mcmVlbGlzdC5wdXNoKGhhbmRsZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBFbXZhbCA9IHtcbiAgICB0b1ZhbHVlOiAoaGFuZGxlKSA9PiB7XG4gICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gJHtoYW5kbGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW12YWxfaGFuZGxlc1toYW5kbGVdXG4gICAgfSxcbiAgICB0b0hhbmRsZTogKHZhbHVlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHJldHVybiAyXG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICByZXR1cm4gNFxuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgcmV0dXJuIDZcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICByZXR1cm4gOFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlID0gZW12YWxfZnJlZWxpc3QucG9wKCkgfHwgZW12YWxfaGFuZGxlcy5sZW5ndGg7XG4gICAgICAgICAgZW12YWxfaGFuZGxlc1toYW5kbGVdID0gdmFsdWU7XG4gICAgICAgICAgZW12YWxfaGFuZGxlc1toYW5kbGUgKyAxXSA9IDE7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICB2YXIgRW1WYWxUeXBlID0ge1xuICAgIG5hbWU6ICdlbXNjcmlwdGVuOjp2YWwnLFxuICAgIGZyb21XaXJlVHlwZTogKGhhbmRsZSkgPT4ge1xuICAgICAgdmFyIHJ2ID0gRW12YWwudG9WYWx1ZShoYW5kbGUpO1xuICAgICAgX19lbXZhbF9kZWNyZWYoaGFuZGxlKTtcbiAgICAgIHJldHVybiBydlxuICAgIH0sXG4gICAgdG9XaXJlVHlwZTogKGRlc3RydWN0b3JzLCB2YWx1ZSkgPT4gRW12YWwudG9IYW5kbGUodmFsdWUpLFxuICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiByZWFkUG9pbnRlcixcbiAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsIC8vIFRoaXMgdHlwZSBkb2VzIG5vdCBuZWVkIGEgZGVzdHJ1Y3RvclxuXG4gICAgLy8gVE9ETzogZG8gd2UgbmVlZCBhIGRlbGV0ZU9iamVjdCBoZXJlPyAgd3JpdGUgYSB0ZXN0IHdoZXJlXG4gICAgLy8gZW12YWwgaXMgcGFzc2VkIGludG8gSlMgdmlhIGFuIGludGVyZmFjZVxuICB9O1xuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwgPSAocmF3VHlwZSkgPT4gcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIEVtVmFsVHlwZSk7XG5cbiAgdmFyIGZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIgPSAobmFtZSwgd2lkdGgpID0+IHtcbiAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShIRUFQRjMyW3BvaW50ZXIgPj4gMl0pXG4gICAgICAgIH1cbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKEhFQVBGNjRbcG9pbnRlciA+PiAzXSlcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YClcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0ID0gKHJhd1R5cGUsIG5hbWUsIHNpemUpID0+IHtcbiAgICBuYW1lID0gQXNjaWlUb1N0cmluZyhuYW1lKTtcbiAgICByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICAgICAgbmFtZSxcbiAgICAgIGZyb21XaXJlVHlwZTogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgIHRvV2lyZVR5cGU6IChkZXN0cnVjdG9ycywgdmFsdWUpID0+IHtcbiAgICAgICAgLy8gVGhlIFZNIHdpbGwgcGVyZm9ybSBKUyB0byBXYXNtIHZhbHVlIGNvbnZlcnNpb24sIGFjY29yZGluZyB0byB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhc20tanMtYXBpLTEvI3Rvd2ViYXNzZW1ibHl2YWx1ZVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH0sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaXplKSxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbCwgLy8gVGhpcyB0eXBlIGRvZXMgbm90IG5lZWQgYSBkZXN0cnVjdG9yXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqIEBzdXBwcmVzcyB7Z2xvYmFsVGhpc30gKi9cbiAgdmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIgPSAocHJpbWl0aXZlVHlwZSwgbmFtZSwgc2l6ZSwgbWluUmFuZ2UsIG1heFJhbmdlKSA9PiB7XG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG5cbiAgICBjb25zdCBpc1Vuc2lnbmVkVHlwZSA9IG1pblJhbmdlID09PSAwO1xuXG4gICAgbGV0IGZyb21XaXJlVHlwZSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG4gICAgaWYgKGlzVW5zaWduZWRUeXBlKSB7XG4gICAgICB2YXIgYml0c2hpZnQgPSAzMiAtIDggKiBzaXplO1xuICAgICAgZnJvbVdpcmVUeXBlID0gKHZhbHVlKSA9PiAodmFsdWUgPDwgYml0c2hpZnQpID4+PiBiaXRzaGlmdDtcbiAgICAgIG1heFJhbmdlID0gZnJvbVdpcmVUeXBlKG1heFJhbmdlKTtcbiAgICB9XG5cbiAgICByZWdpc3RlclR5cGUocHJpbWl0aXZlVHlwZSwge1xuICAgICAgbmFtZSxcbiAgICAgIGZyb21XaXJlVHlwZTogZnJvbVdpcmVUeXBlLFxuICAgICAgdG9XaXJlVHlwZTogKGRlc3RydWN0b3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBUaGUgVk0gd2lsbCBwZXJmb3JtIEpTIHRvIFdhc20gdmFsdWUgY29udmVyc2lvbiwgYWNjb3JkaW5nIHRvIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FzbS1qcy1hcGktMS8jdG93ZWJhc3NlbWJseXZhbHVlXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBpbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSwgc2l6ZSwgbWluUmFuZ2UgIT09IDApLFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsLCAvLyBUaGlzIHR5cGUgZG9lcyBub3QgbmVlZCBhIGRlc3RydWN0b3JcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcgPSAocmF3VHlwZSwgZGF0YVR5cGVJbmRleCwgbmFtZSkgPT4ge1xuICAgIHZhciB0eXBlTWFwcGluZyA9IFtcbiAgICAgIEludDhBcnJheSxcbiAgICAgIFVpbnQ4QXJyYXksXG4gICAgICBJbnQxNkFycmF5LFxuICAgICAgVWludDE2QXJyYXksXG4gICAgICBJbnQzMkFycmF5LFxuICAgICAgVWludDMyQXJyYXksXG4gICAgICBGbG9hdDMyQXJyYXksXG4gICAgICBGbG9hdDY0QXJyYXksXG4gICAgICBCaWdJbnQ2NEFycmF5LFxuICAgICAgQmlnVWludDY0QXJyYXksXG4gICAgXTtcblxuICAgIHZhciBUQSA9IHR5cGVNYXBwaW5nW2RhdGFUeXBlSW5kZXhdO1xuXG4gICAgZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpIHtcbiAgICAgIHZhciBzaXplID0gSEVBUFUzMltoYW5kbGUgPj4gMl07XG4gICAgICB2YXIgZGF0YSA9IEhFQVBVMzJbKGhhbmRsZSArIDQpID4+IDJdO1xuICAgICAgcmV0dXJuIG5ldyBUQShIRUFQOC5idWZmZXIsIGRhdGEsIHNpemUpXG4gICAgfVxuXG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG4gICAgcmVnaXN0ZXJUeXBlKFxuICAgICAgcmF3VHlwZSxcbiAgICAgIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZnJvbVdpcmVUeXBlOiBkZWNvZGVNZW1vcnlWaWV3LFxuICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZGVjb2RlTWVtb3J5VmlldyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6IHRydWUsXG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc21hcnRfcHRyID0gKFxuICAgIHJhd1R5cGUsXG4gICAgcmF3UG9pbnRlZVR5cGUsXG4gICAgbmFtZSxcbiAgICBzaGFyaW5nUG9saWN5LFxuICAgIGdldFBvaW50ZWVTaWduYXR1cmUsXG4gICAgcmF3R2V0UG9pbnRlZSxcbiAgICBjb25zdHJ1Y3RvclNpZ25hdHVyZSxcbiAgICByYXdDb25zdHJ1Y3RvcixcbiAgICBzaGFyZVNpZ25hdHVyZSxcbiAgICByYXdTaGFyZSxcbiAgICBkZXN0cnVjdG9yU2lnbmF0dXJlLFxuICAgIHJhd0Rlc3RydWN0b3JcbiAgKSA9PiB7XG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG4gICAgcmF3R2V0UG9pbnRlZSA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGdldFBvaW50ZWVTaWduYXR1cmUsIHJhd0dldFBvaW50ZWUpO1xuICAgIHJhd0NvbnN0cnVjdG9yID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oY29uc3RydWN0b3JTaWduYXR1cmUsIHJhd0NvbnN0cnVjdG9yKTtcbiAgICByYXdTaGFyZSA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNoYXJlU2lnbmF0dXJlLCByYXdTaGFyZSk7XG4gICAgcmF3RGVzdHJ1Y3RvciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3IpO1xuXG4gICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW3Jhd1R5cGVdLCBbcmF3UG9pbnRlZVR5cGVdLCAocG9pbnRlZVR5cGUpID0+IHtcbiAgICAgIHBvaW50ZWVUeXBlID0gcG9pbnRlZVR5cGVbMF07XG5cbiAgICAgIHZhciByZWdpc3RlcmVkUG9pbnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcG9pbnRlZVR5cGUucmVnaXN0ZXJlZENsYXNzLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8vIHNtYXJ0IHBvaW50ZXIgcHJvcGVydGllc1xuICAgICAgICB0cnVlLFxuICAgICAgICBwb2ludGVlVHlwZSxcbiAgICAgICAgc2hhcmluZ1BvbGljeSxcbiAgICAgICAgcmF3R2V0UG9pbnRlZSxcbiAgICAgICAgcmF3Q29uc3RydWN0b3IsXG4gICAgICAgIHJhd1NoYXJlLFxuICAgICAgICByYXdEZXN0cnVjdG9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtyZWdpc3RlcmVkUG9pbnRlcl1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc3RyaW5nVG9VVEY4QXJyYXkgPSAoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkgPT4ge1xuICAgIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsXG4gICAgLy8gdW5kZWZpbmVkIGFuZCBmYWxzZSBlYWNoIGRvbid0IHdyaXRlIG91dCBhbnkgYnl0ZXMuXG4gICAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIHJldHVybiAwXG5cbiAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gICAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7IC8vIC0xIGZvciBzdHJpbmcgbnVsbCB0ZXJtaW5hdG9yLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgIC8vIGFuZCBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjI3OS50eHRcbiAgICAgIC8vIGFuZCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVxuICAgICAgdmFyIHUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBpZiAodSA8PSAweDdmKSB7XG4gICAgICAgIGlmIChvdXRJZHggPj0gZW5kSWR4KSBicmVha1xuICAgICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgICB9IGVsc2UgaWYgKHUgPD0gMHg3ZmYpIHtcbiAgICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVha1xuICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4YzAgfCAodSA+PiA2KTtcbiAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICB9IGVsc2UgaWYgKHUgPD0gMHhmZmZmKSB7XG4gICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWtcbiAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweGUwIHwgKHUgPj4gMTIpO1xuICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVha1xuICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ZjAgfCAodSA+PiAxOCk7XG4gICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIC8vIEdvdGNoYTogaWYgY29kZVBvaW50IGlzIG92ZXIgMHhGRkZGLCBpdCBpcyByZXByZXNlbnRlZCBhcyBhIHN1cnJvZ2F0ZSBwYWlyIGluIFVURi0xNi5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBtYW51YWxseSBza2lwIG92ZXIgdGhlIHNlY29uZCBjb2RlIHVuaXQgZm9yIGNvcnJlY3QgaXRlcmF0aW9uLlxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBidWZmZXIuXG4gICAgaGVhcFtvdXRJZHhdID0gMDtcbiAgICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHhcbiAgfTtcbiAgdmFyIHN0cmluZ1RvVVRGOCA9IChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUFU4LCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSlcbiAgfTtcblxuICB2YXIgbGVuZ3RoQnl0ZXNVVEY4ID0gKHN0cikgPT4ge1xuICAgIHZhciBsZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlXG4gICAgICAvLyB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgU28gZGVjb2RlXG4gICAgICAvLyBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgICAgaWYgKGMgPD0gMHg3Zikge1xuICAgICAgICBsZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoYyA8PSAweDdmZikge1xuICAgICAgICBsZW4gKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRmZmYpIHtcbiAgICAgICAgbGVuICs9IDQ7XG4gICAgICAgICsraTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiArPSAzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuXG4gIH07XG5cbiAgdmFyIFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGZpbmRTdHJpbmdFbmQgPSAoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQsIGlnbm9yZU51bCkgPT4ge1xuICAgIHZhciBtYXhJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiAgICBpZiAoaWdub3JlTnVsKSByZXR1cm4gbWF4SWR4XG4gICAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uXG4gICAgLy8gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi5cbiAgICAvLyBBcyBhIHRpbnkgY29kZSBzYXZlIHRyaWNrLCBjb21wYXJlIGlkeCBhZ2FpbnN0IG1heElkeCB1c2luZyBhIG5lZ2F0aW9uLFxuICAgIC8vIHNvIHRoYXQgbWF4Qnl0ZXNUb1JlYWQ9dW5kZWZpbmVkL05hTiBtZWFucyBJbmZpbml0eS5cbiAgICB3aGlsZSAoaGVhcE9yQXJyYXlbaWR4XSAmJiAhKGlkeCA+PSBtYXhJZHgpKSArK2lkeDtcbiAgICByZXR1cm4gaWR4XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgcG9pbnRlciAnaWR4JyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBnaXZlblxuICAgKiBhcnJheSB0aGF0IGNvbnRhaW5zIHVpbnQ4IHZhbHVlcywgcmV0dXJucyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYVxuICAgKiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4gICAqIGhlYXBPckFycmF5IGlzIGVpdGhlciBhIHJlZ3VsYXIgYXJyYXksIG9yIGEgSmF2YVNjcmlwdCB0eXBlZCBhcnJheSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcj19IGlkeFxuICAgKiBAcGFyYW0ge251bWJlcj19IG1heEJ5dGVzVG9SZWFkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZU51bCAtIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIG5vdCBzdG9wIG9uIGEgTlVMIGNoYXJhY3Rlci5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdmFyIFVURjhBcnJheVRvU3RyaW5nID0gKGhlYXBPckFycmF5LCBpZHggPSAwLCBtYXhCeXRlc1RvUmVhZCwgaWdub3JlTnVsKSA9PiB7XG4gICAgdmFyIGVuZFB0ciA9IGZpbmRTdHJpbmdFbmQoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQsIGlnbm9yZU51bCk7XG5cbiAgICAvLyBXaGVuIHVzaW5nIGNvbmRpdGlvbmFsIFRleHREZWNvZGVyLCBza2lwIGl0IGZvciBzaG9ydCBzdHJpbmdzIGFzIHRoZSBvdmVyaGVhZCBvZiB0aGUgbmF0aXZlIGNhbGwgaXMgbm90IHdvcnRoIGl0LlxuICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKVxuICAgIH1cbiAgICB2YXIgc3RyID0gJyc7XG4gICAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xuICAgICAgLy8gRm9yIFVURjggYnl0ZSBzdHJ1Y3R1cmUsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgIC8vIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dFxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMHg4MCkpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhlMCkgPT0gMHhjMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhmMCkgPT0gMHhlMCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1MCA9ICgodTAgJiA3KSA8PCAxOCkgfCAodTEgPDwgMTIpIHwgKHUyIDw8IDYpIHwgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUwIDwgMHgxMDAwMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2ggPSB1MCAtIDB4MTAwMDA7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCB8IChjaCA+PiAxMCksIDB4ZGMwMCB8IChjaCAmIDB4M2ZmKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlXG4gICAqIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJucyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBtYXhCeXRlc1RvUmVhZCAtIEFuIG9wdGlvbmFsIGxlbmd0aCB0aGF0IHNwZWNpZmllcyB0aGVcbiAgICogICBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWFkLiBZb3UgY2FuIG9taXQgdGhpcyBwYXJhbWV0ZXIgdG8gc2NhbiB0aGVcbiAgICogICBzdHJpbmcgdW50aWwgdGhlIGZpcnN0IDAgYnl0ZS4gSWYgbWF4Qnl0ZXNUb1JlYWQgaXMgcGFzc2VkLCBhbmQgdGhlIHN0cmluZ1xuICAgKiAgIGF0IFtwdHIsIHB0cittYXhCeXRlc1RvUmVhZHJbIGNvbnRhaW5zIGEgbnVsbCBieXRlIGluIHRoZSBtaWRkbGUsIHRoZW4gdGhlXG4gICAqICAgc3RyaW5nIHdpbGwgY3V0IHNob3J0IGF0IHRoYXQgYnl0ZSBpbmRleC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlTnVsIC0gSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgbm90IHN0b3Agb24gYSBOVUwgY2hhcmFjdGVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB2YXIgVVRGOFRvU3RyaW5nID0gKHB0ciwgbWF4Qnl0ZXNUb1JlYWQsIGlnbm9yZU51bCkgPT4ge1xuICAgIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0ciwgbWF4Qnl0ZXNUb1JlYWQsIGlnbm9yZU51bCkgOiAnJ1xuICB9O1xuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyA9IChyYXdUeXBlLCBuYW1lKSA9PiB7XG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG5cbiAgICByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICAgICAgbmFtZSxcbiAgICAgIC8vIEZvciBzb21lIG1ldGhvZCBuYW1lcyB3ZSB1c2Ugc3RyaW5nIGtleXMgaGVyZSBzaW5jZSB0aGV5IGFyZSBwYXJ0IG9mXG4gICAgICAvLyB0aGUgcHVibGljL2V4dGVybmFsIEFQSSBhbmQvb3IgdXNlZCBieSB0aGUgcnVudGltZS1nZW5lcmF0ZWQgY29kZS5cbiAgICAgIGZyb21XaXJlVHlwZSh2YWx1ZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gSEVBUFUzMlt2YWx1ZSA+PiAyXTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB2YWx1ZSArIDQ7XG5cbiAgICAgICAgdmFyIHN0cjtcbiAgICAgICAge1xuICAgICAgICAgIHN0ciA9IFVURjhUb1N0cmluZyhwYXlsb2FkLCBsZW5ndGgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2ZyZWUodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlKGRlc3RydWN0b3JzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHVlSXNPZlR5cGVTdHJpbmcgPSB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgLy8gV2UgYWNjZXB0IGBzdHJpbmdgIG9yIGFycmF5IHZpZXdzIHdpdGggc2luZ2xlIGJ5dGUgZWxlbWVudHNcbiAgICAgICAgaWYgKCEodmFsdWVJc09mVHlwZVN0cmluZyB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSAmJiB2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCA9PSAxKSkpIHtcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZUlzT2ZUeXBlU3RyaW5nKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoQnl0ZXNVVEY4KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3N1bWVzIFBPSU5URVJfU0laRSBhbGlnbm1lbnRcbiAgICAgICAgdmFyIGJhc2UgPSBfbWFsbG9jKDQgKyBsZW5ndGggKyAxKTtcbiAgICAgICAgdmFyIHB0ciA9IGJhc2UgKyA0O1xuICAgICAgICBIRUFQVTMyW2Jhc2UgPj4gMl0gPSBsZW5ndGg7XG4gICAgICAgIGlmICh2YWx1ZUlzT2ZUeXBlU3RyaW5nKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RyaW5nVG9VVEY4KHZhbHVlLCBwdHIsIGxlbmd0aCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBIRUFQVTguc2V0KHZhbHVlLCBwdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7XG4gICAgICAgICAgZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSwgYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VcbiAgICAgIH0sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogcmVhZFBvaW50ZXIsXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb24ocHRyKSB7XG4gICAgICAgIF9mcmVlKHB0cik7XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBVVEYxNkRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNmxlJykgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIFVURjE2VG9TdHJpbmcgPSAocHRyLCBtYXhCeXRlc1RvUmVhZCwgaWdub3JlTnVsKSA9PiB7XG4gICAgdmFyIGlkeCA9IHB0ciA+PiAxO1xuICAgIHZhciBlbmRJZHggPSBmaW5kU3RyaW5nRW5kKEhFQVBVMTYsIGlkeCwgbWF4Qnl0ZXNUb1JlYWQgLyAyLCBpZ25vcmVOdWwpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBjb25kaXRpb25hbCBUZXh0RGVjb2Rlciwgc2tpcCBpdCBmb3Igc2hvcnQgc3RyaW5ncyBhcyB0aGUgb3ZlcmhlYWQgb2YgdGhlIG5hdGl2ZSBjYWxsIGlzIG5vdCB3b3J0aCBpdC5cbiAgICBpZiAoZW5kSWR4IC0gaWR4ID4gMTYgJiYgVVRGMTZEZWNvZGVyKSByZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTE2LnN1YmFycmF5KGlkeCwgZW5kSWR4KSlcblxuICAgIC8vIEZhbGxiYWNrOiBkZWNvZGUgd2l0aG91dCBVVEYxNkRlY29kZXJcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAvLyBJZiBtYXhCeXRlc1RvUmVhZCBpcyBub3QgcGFzc2VkIGV4cGxpY2l0bHksIGl0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhlXG4gICAgLy8gZm9yLWxvb3AncyBjb25kaXRpb24gd2lsbCBhbHdheXMgZXZhbHVhdGUgdG8gdHJ1ZS4gVGhlIGxvb3AgaXMgdGhlblxuICAgIC8vIHRlcm1pbmF0ZWQgb24gdGhlIGZpcnN0IG51bGwgY2hhci5cbiAgICBmb3IgKHZhciBpID0gaWR4OyBpIDwgZW5kSWR4OyArK2kpIHtcbiAgICAgIHZhciBjb2RlVW5pdCA9IEhFQVBVMTZbaV07XG4gICAgICAvLyBmcm9tQ2hhckNvZGUgY29uc3RydWN0cyBhIGNoYXJhY3RlciBmcm9tIGEgVVRGLTE2IGNvZGUgdW5pdCwgc28gd2UgY2FuXG4gICAgICAvLyBwYXNzIHRoZSBVVEYxNiBzdHJpbmcgcmlnaHQgdGhyb3VnaC5cbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH07XG5cbiAgdmFyIHN0cmluZ1RvVVRGMTYgPSAoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgPT4ge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiBtYXggYnl0ZXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIHVuc2FmZSB1bmJvdW5kZWQgd3JpdGUgaXMgYWxsb3dlZC5cbiAgICBtYXhCeXRlc1RvV3JpdGUgPz89IDB4N2ZmZmZmZmY7XG4gICAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDIpIHJldHVybiAwXG4gICAgbWF4Qnl0ZXNUb1dyaXRlIC09IDI7IC8vIE51bGwgdGVybWluYXRvci5cbiAgICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XG4gICAgdmFyIG51bUNoYXJzVG9Xcml0ZSA9IG1heEJ5dGVzVG9Xcml0ZSA8IHN0ci5sZW5ndGggKiAyID8gbWF4Qnl0ZXNUb1dyaXRlIC8gMiA6IHN0ci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFyc1RvV3JpdGU7ICsraSkge1xuICAgICAgLy8gY2hhckNvZGVBdCByZXR1cm5zIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBzbyBpdCBjYW4gYmUgZGlyZWN0bHkgd3JpdHRlbiB0byB0aGUgSEVBUC5cbiAgICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgICBIRUFQMTZbb3V0UHRyID4+IDFdID0gY29kZVVuaXQ7XG4gICAgICBvdXRQdHIgKz0gMjtcbiAgICB9XG4gICAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gICAgSEVBUDE2W291dFB0ciA+PiAxXSA9IDA7XG4gICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyXG4gIH07XG5cbiAgdmFyIGxlbmd0aEJ5dGVzVVRGMTYgPSAoc3RyKSA9PiBzdHIubGVuZ3RoICogMjtcblxuICB2YXIgVVRGMzJUb1N0cmluZyA9IChwdHIsIG1heEJ5dGVzVG9SZWFkLCBpZ25vcmVOdWwpID0+IHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIHN0YXJ0SWR4ID0gcHRyID4+IDI7XG4gICAgLy8gSWYgbWF4Qnl0ZXNUb1JlYWQgaXMgbm90IHBhc3NlZCBleHBsaWNpdGx5LCBpdCB3aWxsIGJlIHVuZGVmaW5lZCwgYW5kIHRoaXNcbiAgICAvLyB3aWxsIGFsd2F5cyBldmFsdWF0ZSB0byB0cnVlLiBUaGlzIHNhdmVzIG9uIGNvZGUgc2l6ZS5cbiAgICBmb3IgKHZhciBpID0gMDsgIShpID49IG1heEJ5dGVzVG9SZWFkIC8gNCk7IGkrKykge1xuICAgICAgdmFyIHV0ZjMyID0gSEVBUFUzMltzdGFydElkeCArIGldO1xuICAgICAgaWYgKCF1dGYzMiAmJiAhaWdub3JlTnVsKSBicmVha1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHV0ZjMyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIHZhciBzdHJpbmdUb1VURjMyID0gKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpID0+IHtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXG4gICAgbWF4Qnl0ZXNUb1dyaXRlID8/PSAweDdmZmZmZmZmO1xuICAgIGlmIChtYXhCeXRlc1RvV3JpdGUgPCA0KSByZXR1cm4gMFxuICAgIHZhciBzdGFydFB0ciA9IG91dFB0cjtcbiAgICB2YXIgZW5kUHRyID0gc3RhcnRQdHIgKyBtYXhCeXRlc1RvV3JpdGUgLSA0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgLy8gR290Y2hhOiBpZiBjb2RlUG9pbnQgaXMgb3ZlciAweEZGRkYsIGl0IGlzIHJlcHJlc2VudGVkIGFzIGEgc3Vycm9nYXRlIHBhaXIgaW4gVVRGLTE2LlxuICAgICAgLy8gV2UgbmVlZCB0byBtYW51YWxseSBza2lwIG92ZXIgdGhlIHNlY29uZCBjb2RlIHVuaXQgZm9yIGNvcnJlY3QgaXRlcmF0aW9uLlxuICAgICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZikge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBIRUFQMzJbb3V0UHRyID4+IDJdID0gY29kZVBvaW50O1xuICAgICAgb3V0UHRyICs9IDQ7XG4gICAgICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWtcbiAgICB9XG4gICAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gICAgSEVBUDMyW291dFB0ciA+PiAyXSA9IDA7XG4gICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyXG4gIH07XG5cbiAgdmFyIGxlbmd0aEJ5dGVzVVRGMzIgPSAoc3RyKSA9PiB7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAvLyBHb3RjaGE6IGlmIGNvZGVQb2ludCBpcyBvdmVyIDB4RkZGRiwgaXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBzdXJyb2dhdGUgcGFpciBpbiBVVEYtMTYuXG4gICAgICAvLyBXZSBuZWVkIHRvIG1hbnVhbGx5IHNraXAgb3ZlciB0aGUgc2Vjb25kIGNvZGUgdW5pdCBmb3IgY29ycmVjdCBpdGVyYXRpb24uXG4gICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGxlbiArPSA0O1xuICAgIH1cblxuICAgIHJldHVybiBsZW5cbiAgfTtcbiAgdmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nID0gKHJhd1R5cGUsIGNoYXJTaXplLCBuYW1lKSA9PiB7XG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIGRlY29kZVN0cmluZywgZW5jb2RlU3RyaW5nLCBsZW5ndGhCeXRlc1VURjtcbiAgICBpZiAoY2hhclNpemUgPT09IDIpIHtcbiAgICAgIGRlY29kZVN0cmluZyA9IFVURjE2VG9TdHJpbmc7XG4gICAgICBlbmNvZGVTdHJpbmcgPSBzdHJpbmdUb1VURjE2O1xuICAgICAgbGVuZ3RoQnl0ZXNVVEYgPSBsZW5ndGhCeXRlc1VURjE2O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNvZGVTdHJpbmcgPSBVVEYzMlRvU3RyaW5nO1xuICAgICAgZW5jb2RlU3RyaW5nID0gc3RyaW5nVG9VVEYzMjtcbiAgICAgIGxlbmd0aEJ5dGVzVVRGID0gbGVuZ3RoQnl0ZXNVVEYzMjtcbiAgICB9XG4gICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHtcbiAgICAgIG5hbWUsXG4gICAgICBmcm9tV2lyZVR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBDb2RlIG1vc3RseSB0YWtlbiBmcm9tIF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyBmcm9tV2lyZVR5cGVcbiAgICAgICAgdmFyIGxlbmd0aCA9IEhFQVBVMzJbdmFsdWUgPj4gMl07XG4gICAgICAgIHZhciBzdHIgPSBkZWNvZGVTdHJpbmcodmFsdWUgKyA0LCBsZW5ndGggKiBjaGFyU2l6ZSwgdHJ1ZSk7XG5cbiAgICAgICAgX2ZyZWUodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlOiAoZGVzdHJ1Y3RvcnMsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtuYW1lfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1lcyBQT0lOVEVSX1NJWkUgYWxpZ25tZW50XG4gICAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhCeXRlc1VURih2YWx1ZSk7XG4gICAgICAgIHZhciBwdHIgPSBfbWFsbG9jKDQgKyBsZW5ndGggKyBjaGFyU2l6ZSk7XG4gICAgICAgIEhFQVBVMzJbcHRyID4+IDJdID0gbGVuZ3RoIC8gY2hhclNpemU7XG5cbiAgICAgICAgZW5jb2RlU3RyaW5nKHZhbHVlLCBwdHIgKyA0LCBsZW5ndGggKyBjaGFyU2l6ZSk7XG5cbiAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7XG4gICAgICAgICAgZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSwgcHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHRyXG4gICAgICB9LFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHJlYWRQb2ludGVyLFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cikge1xuICAgICAgICBfZnJlZShwdHIpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZCA9IChyYXdUeXBlLCBuYW1lKSA9PiB7XG4gICAgbmFtZSA9IEFzY2lpVG9TdHJpbmcobmFtZSk7XG4gICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHtcbiAgICAgIGlzVm9pZDogdHJ1ZSwgLy8gdm9pZCByZXR1cm4gdmFsdWVzIGNhbiBiZSBvcHRpbWl6ZWQgb3V0IHNvbWV0aW1lc1xuICAgICAgbmFtZSxcbiAgICAgIGZyb21XaXJlVHlwZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgLy8gVE9ETzogYXNzZXJ0IGlmIGFueXRoaW5nIGVsc2UgaXMgZ2l2ZW4/XG4gICAgICB0b1dpcmVUeXBlOiAoZGVzdHJ1Y3RvcnMsIG8pID0+IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZW12YWxfbWV0aG9kQ2FsbGVycyA9IFtdO1xuICB2YXIgZW12YWxfYWRkTWV0aG9kQ2FsbGVyID0gKGNhbGxlcikgPT4ge1xuICAgIHZhciBpZCA9IGVtdmFsX21ldGhvZENhbGxlcnMubGVuZ3RoO1xuICAgIGVtdmFsX21ldGhvZENhbGxlcnMucHVzaChjYWxsZXIpO1xuICAgIHJldHVybiBpZFxuICB9O1xuXG4gIHZhciByZXF1aXJlUmVnaXN0ZXJlZFR5cGUgPSAocmF3VHlwZSwgaHVtYW5OYW1lKSA9PiB7XG4gICAgdmFyIGltcGwgPSByZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV07XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gaW1wbCkge1xuICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoYCR7aHVtYW5OYW1lfSBoYXMgdW5rbm93biB0eXBlICR7Z2V0VHlwZU5hbWUocmF3VHlwZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsXG4gIH07XG4gIHZhciBlbXZhbF9sb29rdXBUeXBlcyA9IChhcmdDb3VudCwgYXJnVHlwZXMpID0+IHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShhcmdDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudDsgKytpKSB7XG4gICAgICBhW2ldID0gcmVxdWlyZVJlZ2lzdGVyZWRUeXBlKEhFQVBVMzJbKGFyZ1R5cGVzICsgaSAqIDQpID4+IDJdLCBgcGFyYW1ldGVyICR7aX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFcbiAgfTtcblxuICB2YXIgZW12YWxfcmV0dXJuVmFsdWUgPSAodG9SZXR1cm5XaXJlLCBkZXN0cnVjdG9yc1JlZiwgaGFuZGxlKSA9PiB7XG4gICAgdmFyIGRlc3RydWN0b3JzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IHRvUmV0dXJuV2lyZShkZXN0cnVjdG9ycywgaGFuZGxlKTtcbiAgICBpZiAoZGVzdHJ1Y3RvcnMubGVuZ3RoKSB7XG4gICAgICAvLyB2b2lkLCBwcmltaXRpdmVzIGFuZCBhbnkgb3RoZXIgdHlwZXMgdy9vIGRlc3RydWN0b3JzIGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYSBoYW5kbGVcbiAgICAgIEhFQVBVMzJbZGVzdHJ1Y3RvcnNSZWYgPj4gMl0gPSBFbXZhbC50b0hhbmRsZShkZXN0cnVjdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICB2YXIgZW12YWxfc3ltYm9scyA9IHt9O1xuXG4gIHZhciBnZXRTdHJpbmdPclN5bWJvbCA9IChhZGRyZXNzKSA9PiB7XG4gICAgdmFyIHN5bWJvbCA9IGVtdmFsX3N5bWJvbHNbYWRkcmVzc107XG4gICAgaWYgKHN5bWJvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQXNjaWlUb1N0cmluZyhhZGRyZXNzKVxuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sXG4gIH07XG4gIHZhciBfX2VtdmFsX2NyZWF0ZV9pbnZva2VyID0gKGFyZ0NvdW50LCBhcmdUeXBlc1B0ciwga2luZCkgPT4ge1xuICAgIHZhciBHZW5lcmljV2lyZVR5cGVTaXplID0gODtcblxuICAgIHZhciBbcmV0VHlwZSwgLi4uYXJnVHlwZXNdID0gZW12YWxfbG9va3VwVHlwZXMoYXJnQ291bnQsIGFyZ1R5cGVzUHRyKTtcbiAgICB2YXIgdG9SZXR1cm5XaXJlID0gcmV0VHlwZS50b1dpcmVUeXBlLmJpbmQocmV0VHlwZSk7XG4gICAgdmFyIGFyZ0Zyb21QdHIgPSBhcmdUeXBlcy5tYXAoKHR5cGUpID0+IHR5cGUucmVhZFZhbHVlRnJvbVBvaW50ZXIuYmluZCh0eXBlKSk7XG4gICAgYXJnQ291bnQtLTsgLy8gcmVtb3ZlIHRoZSBleHRyYWN0ZWQgcmV0dXJuIHR5cGVcblxuICAgIHZhciBjYXB0dXJlcyA9IHsgdG9WYWx1ZTogRW12YWwudG9WYWx1ZSB9O1xuICAgIHZhciBhcmdzID0gYXJnRnJvbVB0ci5tYXAoKGFyZ0Zyb21QdHIsIGkpID0+IHtcbiAgICAgIHZhciBjYXB0dXJlTmFtZSA9IGBhcmdGcm9tUHRyJHtpfWA7XG4gICAgICBjYXB0dXJlc1tjYXB0dXJlTmFtZV0gPSBhcmdGcm9tUHRyO1xuICAgICAgcmV0dXJuIGAke2NhcHR1cmVOYW1lfShhcmdzJHtpID8gJysnICsgaSAqIEdlbmVyaWNXaXJlVHlwZVNpemUgOiAnJ30pYFxuICAgIH0pO1xuICAgIHZhciBmdW5jdGlvbkJvZHk7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZ1bmN0aW9uQm9keSA9ICd0b1ZhbHVlKGhhbmRsZSknO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBmdW5jdGlvbkJvZHkgPSAnbmV3ICh0b1ZhbHVlKGhhbmRsZSkpJztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZnVuY3Rpb25Cb2R5ID0gJyc7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNhcHR1cmVzWydnZXRTdHJpbmdPclN5bWJvbCddID0gZ2V0U3RyaW5nT3JTeW1ib2w7XG4gICAgICAgIGZ1bmN0aW9uQm9keSA9ICd0b1ZhbHVlKGhhbmRsZSlbZ2V0U3RyaW5nT3JTeW1ib2wobWV0aG9kTmFtZSldJztcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgZnVuY3Rpb25Cb2R5ICs9IGAoJHthcmdzfSlgO1xuICAgIGlmICghcmV0VHlwZS5pc1ZvaWQpIHtcbiAgICAgIGNhcHR1cmVzWyd0b1JldHVybldpcmUnXSA9IHRvUmV0dXJuV2lyZTtcbiAgICAgIGNhcHR1cmVzWydlbXZhbF9yZXR1cm5WYWx1ZSddID0gZW12YWxfcmV0dXJuVmFsdWU7XG4gICAgICBmdW5jdGlvbkJvZHkgPSBgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHRvUmV0dXJuV2lyZSwgZGVzdHJ1Y3RvcnNSZWYsICR7ZnVuY3Rpb25Cb2R5fSlgO1xuICAgIH1cbiAgICBmdW5jdGlvbkJvZHkgPSBgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGUsIG1ldGhvZE5hbWUsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG4gICR7ZnVuY3Rpb25Cb2R5fVxuICB9YDtcblxuICAgIHZhciBpbnZva2VyRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oT2JqZWN0LmtleXMoY2FwdHVyZXMpLCBmdW5jdGlvbkJvZHkpKFxuICAgICAgLi4uT2JqZWN0LnZhbHVlcyhjYXB0dXJlcylcbiAgICApO1xuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBgbWV0aG9kQ2FsbGVyPCgke2FyZ1R5cGVzLm1hcCgodCkgPT4gdC5uYW1lKX0pID0+ICR7cmV0VHlwZS5uYW1lfT5gO1xuICAgIHJldHVybiBlbXZhbF9hZGRNZXRob2RDYWxsZXIoY3JlYXRlTmFtZWRGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGludm9rZXJGdW5jdGlvbikpXG4gIH07XG5cbiAgdmFyIF9fZW12YWxfaW5jcmVmID0gKGhhbmRsZSkgPT4ge1xuICAgIGlmIChoYW5kbGUgPiA5KSB7XG4gICAgICBlbXZhbF9oYW5kbGVzW2hhbmRsZSArIDFdICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfX2VtdmFsX2ludm9rZSA9IChjYWxsZXIsIGhhbmRsZSwgbWV0aG9kTmFtZSwgZGVzdHJ1Y3RvcnNSZWYsIGFyZ3MpID0+IHtcbiAgICByZXR1cm4gZW12YWxfbWV0aG9kQ2FsbGVyc1tjYWxsZXJdKGhhbmRsZSwgbWV0aG9kTmFtZSwgZGVzdHJ1Y3RvcnNSZWYsIGFyZ3MpXG4gIH07XG5cbiAgdmFyIF9fZW12YWxfcnVuX2Rlc3RydWN0b3JzID0gKGhhbmRsZSkgPT4ge1xuICAgIHZhciBkZXN0cnVjdG9ycyA9IEVtdmFsLnRvVmFsdWUoaGFuZGxlKTtcbiAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4gICAgX19lbXZhbF9kZWNyZWYoaGFuZGxlKTtcbiAgfTtcblxuICB2YXIgSU5UNTNfTUFYID0gOTAwNzE5OTI1NDc0MDk5MjtcblxuICB2YXIgSU5UNTNfTUlOID0gLTkwMDcxOTkyNTQ3NDA5OTI7XG4gIHZhciBiaWdpbnRUb0k1M0NoZWNrZWQgPSAobnVtKSA9PiAobnVtIDwgSU5UNTNfTUlOIHx8IG51bSA+IElOVDUzX01BWCA/IE5hTiA6IE51bWJlcihudW0pKTtcbiAgZnVuY3Rpb24gX19nbXRpbWVfanModGltZSwgdG1QdHIpIHtcbiAgICB0aW1lID0gYmlnaW50VG9JNTNDaGVja2VkKHRpbWUpO1xuXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gICAgSEVBUDMyW3RtUHRyID4+IDJdID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgSEVBUDMyWyh0bVB0ciArIDQpID4+IDJdID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIEhFQVAzMlsodG1QdHIgKyAxMikgPj4gMl0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICBIRUFQMzJbKHRtUHRyICsgMTYpID4+IDJdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgIEhFQVAzMlsodG1QdHIgKyAyMCkgPj4gMl0gPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwO1xuICAgIEhFQVAzMlsodG1QdHIgKyAyNCkgPj4gMl0gPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBzdGFydCA9IERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSwgMCwgMCwgMCwgMCk7XG4gICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSB8IDA7XG4gICAgSEVBUDMyWyh0bVB0ciArIDI4KSA+PiAyXSA9IHlkYXk7XG4gIH1cblxuICB2YXIgX190enNldF9qcyA9ICh0aW1lem9uZSwgZGF5bGlnaHQsIHN0ZF9uYW1lLCBkc3RfbmFtZSkgPT4ge1xuICAgIC8vIFRPRE86IFVzZSAobWFsbGVhYmxlKSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW5zdGVhZCBvZiBzeXN0ZW0gc2V0dGluZ3MuXG4gICAgdmFyIGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgdmFyIHN1bW1lciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCA2LCAxKTtcbiAgICB2YXIgd2ludGVyT2Zmc2V0ID0gd2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgLy8gTG9jYWwgc3RhbmRhcmQgdGltZXpvbmUgb2Zmc2V0LiBMb2NhbCBzdGFuZGFyZCB0aW1lIGlzIG5vdCBhZGp1c3RlZCBmb3JcbiAgICAvLyBkYXlsaWdodCBzYXZpbmdzLiAgVGhpcyBjb2RlIHVzZXMgdGhlIGZhY3QgdGhhdCBnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zXG4gICAgLy8gYSBncmVhdGVyIHZhbHVlIGR1cmluZyBTdGFuZGFyZCBUaW1lIHZlcnN1cyBEYXlsaWdodCBTYXZpbmcgVGltZSAoRFNUKS5cbiAgICAvLyBUaHVzIGl0IGRldGVybWluZXMgdGhlIGV4cGVjdGVkIG91dHB1dCBkdXJpbmcgU3RhbmRhcmQgVGltZSwgYW5kIGl0XG4gICAgLy8gY29tcGFyZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBkYXRlIHRoZSBzYW1lIChTdGFuZGFyZCkgb3IgbGVzc1xuICAgIC8vIChEU1QpLlxuICAgIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcblxuICAgIC8vIHRpbWV6b25lIGlzIHNwZWNpZmllZCBhcyBzZWNvbmRzIHdlc3Qgb2YgVVRDIChcIlRoZSBleHRlcm5hbCB2YXJpYWJsZVxuICAgIC8vIGB0aW1lem9uZWAgc2hhbGwgYmUgc2V0IHRvIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBiZXR3ZWVuXG4gICAgLy8gQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUgKFVUQykgYW5kIGxvY2FsIHN0YW5kYXJkIHRpbWUuXCIpLCB0aGUgc2FtZVxuICAgIC8vIGFzIHJldHVybmVkIGJ5IHN0ZFRpbWV6b25lT2Zmc2V0LlxuICAgIC8vIFNlZSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDA5Njk1Mzk5L2Z1bmN0aW9ucy90enNldC5odG1sXG4gICAgSEVBUFUzMlt0aW1lem9uZSA+PiAyXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG5cbiAgICBIRUFQMzJbZGF5bGlnaHQgPj4gMl0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG5cbiAgICB2YXIgZXh0cmFjdFpvbmUgPSAodGltZXpvbmVPZmZzZXQpID0+IHtcbiAgICAgIC8vIFdoeSBpbnZlcnNlIHNpZ24/XG4gICAgICAvLyBSZWFkIGhlcmUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRUaW1lem9uZU9mZnNldFxuICAgICAgdmFyIHNpZ24gPSB0aW1lem9uZU9mZnNldCA+PSAwID8gJy0nIDogJysnO1xuXG4gICAgICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnModGltZXpvbmVPZmZzZXQpO1xuICAgICAgdmFyIGhvdXJzID0gU3RyaW5nKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgdmFyIG1pbnV0ZXMgPSBTdHJpbmcoYWJzT2Zmc2V0ICUgNjApLnBhZFN0YXJ0KDIsICcwJyk7XG5cbiAgICAgIHJldHVybiBgVVRDJHtzaWdufSR7aG91cnN9JHttaW51dGVzfWBcbiAgICB9O1xuXG4gICAgdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXJPZmZzZXQpO1xuICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyT2Zmc2V0KTtcbiAgICBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gICAgICAvLyBOb3J0aGVybiBoZW1pc3BoZXJlXG4gICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgc3RkX25hbWUsIDE3KTtcbiAgICAgIHN0cmluZ1RvVVRGOChzdW1tZXJOYW1lLCBkc3RfbmFtZSwgMTcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgZHN0X25hbWUsIDE3KTtcbiAgICAgIHN0cmluZ1RvVVRGOChzdW1tZXJOYW1lLCBzdGRfbmFtZSwgMTcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX2Vtc2NyaXB0ZW5fZGF0ZV9ub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xuXG4gIHZhciBnZXRIZWFwTWF4ID0gKCkgPT5cbiAgICAvLyBTdGF5IG9uZSBXYXNtIHBhZ2Ugc2hvcnQgb2YgNEdCOiB3aGlsZSBlLmcuIENocm9tZSBpcyBhYmxlIHRvIGFsbG9jYXRlXG4gICAgLy8gZnVsbCA0R0IgV2FzbSBtZW1vcmllcywgdGhlIHNpemUgd2lsbCB3cmFwIGJhY2sgdG8gMCBieXRlcyBpbiBXYXNtIHNpZGVcbiAgICAvLyBmb3IgYW55IGNvZGUgdGhhdCBkZWFscyB3aXRoIGhlYXAgc2l6ZXMsIHdoaWNoIHdvdWxkIHJlcXVpcmUgc3BlY2lhbFxuICAgIC8vIGNhc2luZyBhbGwgaGVhcCBzaXplIHJlbGF0ZWQgY29kZSB0byB0cmVhdCAwIHNwZWNpYWxseS5cbiAgICAyMTQ3NDgzNjQ4O1xuXG4gIHZhciBhbGlnbk1lbW9yeSA9IChzaXplLCBhbGlnbm1lbnQpID0+IHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50XG4gIH07XG5cbiAgdmFyIGdyb3dNZW1vcnkgPSAoc2l6ZSkgPT4ge1xuICAgIHZhciBvbGRIZWFwU2l6ZSA9IHdhc21NZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgdmFyIHBhZ2VzID0gKChzaXplIC0gb2xkSGVhcFNpemUgKyA2NTUzNSkgLyA2NTUzNikgfCAwO1xuICAgIHRyeSB7XG4gICAgICAvLyByb3VuZCBzaXplIGdyb3cgcmVxdWVzdCB1cCB0byB3YXNtIHBhZ2Ugc2l6ZSAoZml4ZWQgNjRLQiBwZXIgc3BlYylcbiAgICAgIHdhc21NZW1vcnkuZ3JvdyhwYWdlcyk7IC8vIC5ncm93KCkgdGFrZXMgYSBkZWx0YSBjb21wYXJlZCB0byB0aGUgcHJldmlvdXMgc2l6ZVxuICAgICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcbiAgICAgIHJldHVybiAxIC8qc3VjY2VzcyovXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICAvLyBpbXBsaWNpdCAwIHJldHVybiB0byBzYXZlIGNvZGUgc2l6ZSAoY2FsbGVyIHdpbGwgY2FzdCBcInVuZGVmaW5lZFwiIGludG8gMFxuICAgIC8vIGFueWhvdylcbiAgfTtcbiAgdmFyIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwID0gKHJlcXVlc3RlZFNpemUpID0+IHtcbiAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gICAgLy8gV2l0aCBDQU5fQUREUkVTU18yR0Igb3IgTUVNT1JZNjQsIHBvaW50ZXJzIGFyZSBhbHJlYWR5IHVuc2lnbmVkLlxuICAgIHJlcXVlc3RlZFNpemUgPj4+PSAwO1xuICAgIC8vIFdpdGggbXVsdGl0aHJlYWRlZCBidWlsZHMsIHJhY2VzIGNhbiBoYXBwZW4gKGFub3RoZXIgdGhyZWFkIG1pZ2h0IGluY3JlYXNlIHRoZSBzaXplXG4gICAgLy8gaW4gYmV0d2VlbiksIHNvIHJldHVybiBhIGZhaWx1cmUsIGFuZCBsZXQgdGhlIGNhbGxlciByZXRyeS5cblxuICAgIC8vIE1lbW9yeSByZXNpemUgcnVsZXM6XG4gICAgLy8gMS4gIEFsd2F5cyBpbmNyZWFzZSBoZWFwIHNpemUgdG8gYXQgbGVhc3QgdGhlIHJlcXVlc3RlZCBzaXplLCByb3VuZGVkIHVwXG4gICAgLy8gICAgIHRvIG5leHQgcGFnZSBtdWx0aXBsZS5cbiAgICAvLyAyYS4gSWYgTUVNT1JZX0dST1dUSF9MSU5FQVJfU1RFUCA9PSAtMSwgZXhjZXNzaXZlbHkgcmVzaXplIHRoZSBoZWFwXG4gICAgLy8gICAgIGdlb21ldHJpY2FsbHk6IGluY3JlYXNlIHRoZSBoZWFwIHNpemUgYWNjb3JkaW5nIHRvXG4gICAgLy8gICAgIE1FTU9SWV9HUk9XVEhfR0VPTUVUUklDX1NURVAgZmFjdG9yIChkZWZhdWx0ICsyMCUpLCBBdCBtb3N0XG4gICAgLy8gICAgIG92ZXJyZXNlcnZlIGJ5IE1FTU9SWV9HUk9XVEhfR0VPTUVUUklDX0NBUCBieXRlcyAoZGVmYXVsdCA5Nk1CKS5cbiAgICAvLyAyYi4gSWYgTUVNT1JZX0dST1dUSF9MSU5FQVJfU1RFUCAhPSAtMSwgZXhjZXNzaXZlbHkgcmVzaXplIHRoZSBoZWFwXG4gICAgLy8gICAgIGxpbmVhcmx5OiBpbmNyZWFzZSB0aGUgaGVhcCBzaXplIGJ5IGF0IGxlYXN0XG4gICAgLy8gICAgIE1FTU9SWV9HUk9XVEhfTElORUFSX1NURVAgYnl0ZXMuXG4gICAgLy8gMy4gIE1heCBzaXplIGZvciB0aGUgaGVhcCBpcyBjYXBwZWQgYXQgMjA0OE1CLVdBU01fUEFHRV9TSVpFLCBvciBieVxuICAgIC8vICAgICBNQVhJTVVNX01FTU9SWSwgb3IgYnkgQVNBTiBsaW1pdCwgZGVwZW5kaW5nIG9uIHdoaWNoIGlzIHNtYWxsZXN0XG4gICAgLy8gNC4gIElmIHdlIHdlcmUgdW5hYmxlIHRvIGFsbG9jYXRlIGFzIG11Y2ggbWVtb3J5LCBpdCBtYXkgYmUgZHVlIHRvXG4gICAgLy8gICAgIG92ZXItZWFnZXIgZGVjaXNpb24gdG8gZXhjZXNzaXZlbHkgcmVzZXJ2ZSBkdWUgdG8gKDMpIGFib3ZlLlxuICAgIC8vICAgICBIZW5jZSBpZiBhbiBhbGxvY2F0aW9uIGZhaWxzLCBjdXQgZG93biBvbiB0aGUgYW1vdW50IG9mIGV4Y2Vzc1xuICAgIC8vICAgICBncm93dGgsIGluIGFuIGF0dGVtcHQgdG8gc3VjY2VlZCB0byBwZXJmb3JtIGEgc21hbGxlciBhbGxvY2F0aW9uLlxuXG4gICAgLy8gQSBsaW1pdCBpcyBzZXQgZm9yIGhvdyBtdWNoIHdlIGNhbiBncm93LiBXZSBzaG91bGQgbm90IGV4Y2VlZCB0aGF0XG4gICAgLy8gKHRoZSB3YXNtIGJpbmFyeSBzcGVjaWZpZXMgaXQsIHNvIGlmIHdlIHRyaWVkLCB3ZSdkIGZhaWwgYW55aG93KS5cbiAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHBvdGVudGlhbCBoZWFwIHNpemUgaW5jcmVhc2VzLiBJZiB3ZSBhdHRlbXB0IGEgdG9vIGVhZ2VyXG4gICAgLy8gcmVzZXJ2YXRpb24gdGhhdCBmYWlscywgY3V0IGRvd24gb24gdGhlIGF0dGVtcHRlZCBzaXplIGFuZCByZXNlcnZlIGFcbiAgICAvLyBzbWFsbGVyIGJ1bXAgaW5zdGVhZC4gKG1heCAzIHRpbWVzLCBjaG9zZW4gc29tZXdoYXQgYXJiaXRyYXJpbHkpXG4gICAgZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTsgLy8gZW5zdXJlIGdlb21ldHJpYyBncm93dGhcbiAgICAgIC8vIGJ1dCBsaW1pdCBvdmVycmVzZXJ2aW5nIChkZWZhdWx0IHRvIGNhcHBpbmcgYXQgKzk2TUIgb3Zlcmdyb3d0aCBhdCBtb3N0KVxuICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSwgcmVxdWVzdGVkU2l6ZSArIDEwMDY2MzI5Nik7XG5cbiAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4oXG4gICAgICAgIG1heEhlYXBTaXplLFxuICAgICAgICBhbGlnbk1lbW9yeShNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KVxuICAgICAgKTtcblxuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZ3Jvd01lbW9yeShuZXdTaXplKTtcbiAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICB2YXIgRU5WID0ge307XG5cbiAgdmFyIGdldEV4ZWN1dGFibGVOYW1lID0gKCkgPT4gdGhpc1Byb2dyYW07XG4gIHZhciBnZXRFbnZTdHJpbmdzID0gKCkgPT4ge1xuICAgIGlmICghZ2V0RW52U3RyaW5ncy5zdHJpbmdzKSB7XG4gICAgICAvLyBEZWZhdWx0IHZhbHVlcy5cbiAgICAgIC8vIEJyb3dzZXIgbGFuZ3VhZ2UgZGV0ZWN0aW9uICM4NzUxXG4gICAgICB2YXIgbGFuZyA9XG4gICAgICAgICgodHlwZW9mIG5hdmlnYXRvciA9PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8ICdDJykucmVwbGFjZSgnLScsICdfJykgKyAnLlVURi04JztcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIFVTRVI6ICd3ZWJfdXNlcicsXG4gICAgICAgIExPR05BTUU6ICd3ZWJfdXNlcicsXG4gICAgICAgIFBBVEg6ICcvJyxcbiAgICAgICAgUFdEOiAnLycsXG4gICAgICAgIEhPTUU6ICcvaG9tZS93ZWJfdXNlcicsXG4gICAgICAgIExBTkc6IGxhbmcsXG4gICAgICAgIF86IGdldEV4ZWN1dGFibGVOYW1lKCksXG4gICAgICB9O1xuICAgICAgLy8gQXBwbHkgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWVzLCBpZiBhbnkuXG4gICAgICBmb3IgKHZhciB4IGluIEVOVikge1xuICAgICAgICAvLyB4IGlzIGEga2V5IGluIEVOVjsgaWYgRU5WW3hdIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyBpdCB3YXNcbiAgICAgICAgLy8gZXhwbGljaXRseSBzZXQgdG8gYmUgc28uIFdlIGFsbG93IHVzZXIgY29kZSB0byBkbyB0aGF0IHRvXG4gICAgICAgIC8vIGZvcmNlIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHQgdmFsdWVzIHRvIHJlbWFpbiB1bnNldC5cbiAgICAgICAgaWYgKEVOVlt4XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgZW52W3hdO1xuICAgICAgICBlbHNlIGVudlt4XSA9IEVOVlt4XTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICBmb3IgKHZhciB4IGluIGVudikge1xuICAgICAgICBzdHJpbmdzLnB1c2goYCR7eH09JHtlbnZbeF19YCk7XG4gICAgICB9XG4gICAgICBnZXRFbnZTdHJpbmdzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzXG4gIH07XG5cbiAgdmFyIF9lbnZpcm9uX2dldCA9IChfX2Vudmlyb24sIGVudmlyb25fYnVmKSA9PiB7XG4gICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgIHZhciBlbnZwID0gMDtcbiAgICBmb3IgKHZhciBzdHJpbmcgb2YgZ2V0RW52U3RyaW5ncygpKSB7XG4gICAgICB2YXIgcHRyID0gZW52aXJvbl9idWYgKyBidWZTaXplO1xuICAgICAgSEVBUFUzMlsoX19lbnZpcm9uICsgZW52cCkgPj4gMl0gPSBwdHI7XG4gICAgICBidWZTaXplICs9IHN0cmluZ1RvVVRGOChzdHJpbmcsIHB0ciwgSW5maW5pdHkpICsgMTtcbiAgICAgIGVudnAgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfTtcblxuICB2YXIgX2Vudmlyb25fc2l6ZXNfZ2V0ID0gKHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkgPT4ge1xuICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgIEhFQVBVMzJbcGVudmlyb25fY291bnQgPj4gMl0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgc3RyaW5nIG9mIHN0cmluZ3MpIHtcbiAgICAgIGJ1ZlNpemUgKz0gbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZykgKyAxO1xuICAgIH1cbiAgICBIRUFQVTMyW3BlbnZpcm9uX2J1Zl9zaXplID4+IDJdID0gYnVmU2l6ZTtcbiAgICByZXR1cm4gMFxuICB9O1xuXG4gIHZhciBfZmRfY2xvc2UgPSAoZmQpID0+IHtcbiAgICByZXR1cm4gNTJcbiAgfTtcblxuICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0LCB3aGVuY2UsIG5ld09mZnNldCkge1xuXG4gICAgcmV0dXJuIDcwXG4gIH1cblxuICB2YXIgcHJpbnRDaGFyQnVmZmVycyA9IFtudWxsLCBbXSwgW11dO1xuXG4gIHZhciBwcmludENoYXIgPSAoc3RyZWFtLCBjdXJyKSA9PiB7XG4gICAgdmFyIGJ1ZmZlciA9IHByaW50Q2hhckJ1ZmZlcnNbc3RyZWFtXTtcbiAgICBpZiAoY3VyciA9PT0gMCB8fCBjdXJyID09PSAxMCkge1xuKHN0cmVhbSA9PT0gMSA/IG91dCA6IGVycikoVVRGOEFycmF5VG9TdHJpbmcoYnVmZmVyKSk7XG4gICAgICBidWZmZXIubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLnB1c2goY3Vycik7XG4gICAgfVxuICB9O1xuICB2YXIgX2ZkX3dyaXRlID0gKGZkLCBpb3YsIGlvdmNudCwgcG51bSkgPT4ge1xuICAgIC8vIGhhY2sgdG8gc3VwcG9ydCBwcmludGYgaW4gU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNPTBcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4gMl07XG4gICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICBpb3YgKz0gODtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcHJpbnRDaGFyKGZkLCBIRUFQVThbcHRyICsgal0pO1xuICAgICAgfVxuICAgICAgbnVtICs9IGxlbjtcbiAgICB9XG4gICAgSEVBUFUzMltwbnVtID4+IDJdID0gbnVtO1xuICAgIHJldHVybiAwXG4gIH07XG4gIGluaXRfQ2xhc3NIYW5kbGUoKTtcbiAgaW5pdF9SZWdpc3RlcmVkUG9pbnRlcigpO1xuXG4gIC8vIEJlZ2luIHJ1bnRpbWUgZXhwb3J0c1xuICAvLyBFbmQgcnVudGltZSBleHBvcnRzXG4gIC8vIEJlZ2luIEpTIGxpYnJhcnkgZXhwb3J0c1xuICAvLyBFbmQgSlMgbGlicmFyeSBleHBvcnRzXG5cbiAgLy8gZW5kIGluY2x1ZGU6IHBvc3RsaWJyYXJ5LmpzXG5cbiAgLy8gSW1wb3J0cyBmcm9tIHRoZSBXYXNtIGJpbmFyeS5cbiAgdmFyIF9fX2dldFR5cGVOYW1lLFxuICAgIF9tYWxsb2MsXG4gICAgX2ZyZWU7XG5cbiAgZnVuY3Rpb24gYXNzaWduV2FzbUV4cG9ydHMod2FzbUV4cG9ydHMpIHtcbiAgICBfX19nZXRUeXBlTmFtZSA9IHdhc21FeHBvcnRzWydfX2dldFR5cGVOYW1lJ107XG4gICAgX21hbGxvYyA9IHdhc21FeHBvcnRzWydtYWxsb2MnXTtcbiAgICBfZnJlZSA9IHdhc21FeHBvcnRzWydmcmVlJ107XG4gICAgd2FzbUV4cG9ydHNbJ19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUnXTtcbiAgICB3YXNtRXhwb3J0c1snX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MnXTtcbiAgICB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCddO1xuICB9XG4gIHZhciB3YXNtSW1wb3J0cyA9IHtcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9hYm9ydF9qczogX19hYm9ydF9qcyxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9lbWJpbmRfcmVnaXN0ZXJfYmlnaW50OiBfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW1iaW5kX3JlZ2lzdGVyX2Jvb2w6IF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzcyxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3I6IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbjogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24sXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsOiBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQ6IF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0LFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyOiBfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldzogX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW1iaW5kX3JlZ2lzdGVyX3NtYXJ0X3B0cjogX19lbWJpbmRfcmVnaXN0ZXJfc21hcnRfcHRyLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nOiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZzogX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ6IF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW12YWxfY3JlYXRlX2ludm9rZXI6IF9fZW12YWxfY3JlYXRlX2ludm9rZXIsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW12YWxfZGVjcmVmOiBfX2VtdmFsX2RlY3JlZixcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9lbXZhbF9pbmNyZWY6IF9fZW12YWxfaW5jcmVmLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX2VtdmFsX2ludm9rZTogX19lbXZhbF9pbnZva2UsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBfZW12YWxfcnVuX2Rlc3RydWN0b3JzOiBfX2VtdmFsX3J1bl9kZXN0cnVjdG9ycyxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIF9nbXRpbWVfanM6IF9fZ210aW1lX2pzLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgX3R6c2V0X2pzOiBfX3R6c2V0X2pzLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIGVudmlyb25fZ2V0OiBfZW52aXJvbl9nZXQsXG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBlbnZpcm9uX3NpemVzX2dldDogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIGZkX3NlZWs6IF9mZF9zZWVrLFxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgZmRfd3JpdGU6IF9mZF93cml0ZSxcbiAgfTtcbiAgdmFyIHdhc21FeHBvcnRzID0gYXdhaXQgY3JlYXRlV2FzbSgpO1xuXG4gIC8vIGluY2x1ZGU6IHBvc3RhbWJsZS5qc1xuICAvLyA9PT0gQXV0by1nZW5lcmF0ZWQgcG9zdGFtYmxlIHNldHVwIGVudHJ5IHN0dWZmID09PVxuXG4gIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYSBwcmVSdW4gYWRkZWQgYSBkZXBlbmRlbmN5LCBydW4gd2lsbCBiZSBjYWxsZWQgbGF0ZXJcbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgICAvLyBydW4gbWF5IGhhdmUganVzdCBiZWVuIGNhbGxlZCB0aHJvdWdoIGRlcGVuZGVuY2llcyBiZWluZyBmdWxmaWxsZWQganVzdCBpbiB0aGlzIHZlcnkgZnJhbWUsXG4gICAgICAvLyBvciB3aGlsZSB0aGUgYXN5bmMgc2V0U3RhdHVzIHRpbWUgYmVsb3cgd2FzIGhhcHBlbmluZ1xuICAgICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICAgIGlmIChBQk9SVCkgcmV0dXJuXG5cbiAgICAgIGluaXRSdW50aW1lKCk7XG5cbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmU/LihNb2R1bGUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGRvUnVuKCk7XG4gICAgfVxuICB9XG4gIHJ1bigpO1xuXG4gIC8vIGVuZCBpbmNsdWRlOiBwb3N0YW1ibGUuanNcblxuICAvLyBpbmNsdWRlOiBwb3N0YW1ibGVfbW9kdWxhcml6ZS5qc1xuICAvLyBJbiBNT0RVTEFSSVpFIG1vZGUgd2Ugd3JhcCB0aGUgZ2VuZXJhdGVkIGNvZGUgaW4gYSBmYWN0b3J5IGZ1bmN0aW9uXG4gIC8vIGFuZCByZXR1cm4gZWl0aGVyIHRoZSBNb2R1bGUgaXRzZWxmLCBvciBhIHByb21pc2Ugb2YgdGhlIG1vZHVsZS5cbiAgLy9cbiAgLy8gV2UgYXNzaWduIHRvIHRoZSBgbW9kdWxlUnRuYCBnbG9iYWwgaGVyZSBhbmQgY29uZmlndXJlIGNsb3N1cmUgdG8gc2VlXG4gIC8vIHRoaXMgYXMgYW5kIGV4dGVybiBzbyBpdCB3b24ndCBnZXQgbWluaWZpZWQuXG5cbiAgaWYgKHJ1bnRpbWVJbml0aWFsaXplZCkge1xuICAgIG1vZHVsZVJ0biA9IE1vZHVsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTZXQgdXAgdGhlIHByb21pc2UgdGhhdCBpbmRpY2F0ZXMgdGhlIE1vZHVsZSBpcyBpbml0aWFsaXplZFxuICAgIG1vZHVsZVJ0biA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZW5kIGluY2x1ZGU6IHBvc3RhbWJsZV9tb2R1bGFyaXplLmpzXG5cbiAgcmV0dXJuIG1vZHVsZVJ0blxufVxuXG5jb25zdCBub29wUHJpbnQgPSAoKSA9PiB7XG4gIC8vIE5vLW9wXG59O1xuZnVuY3Rpb24gZGVmYXVsdExvY2F0ZUZpbGUocGF0aCwgcHJlZml4KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwcmVmaXgpO1xuICAgIGlmICh1cmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH1tZWRpYWluZm8uanMvZGlzdC8ke3BhdGh9YDtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGVtcHR5XG4gIH1cbiAgcmV0dXJuIGAke3ByZWZpeH0uLi8ke3BhdGh9YDtcbn1cblxuLy8gVE9ETyBwYXNzIHRocm91Z2ggbW9yZSBlbXNjcmlwdGVuIG1vZHVsZSBvcHRpb25zP1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTWVkaWFJbmZvfSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGb3JtYXQgLSBUaGUgZm9ybWF0IHR5cGUsIGRlZmF1bHRzIHRvIGBvYmplY3RgLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSB7QGxpbmsgTWVkaWFJbmZvfSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEge0BsaW5rIE1lZGlhSW5mb30gaW5zdGFuY2Ugd2hlbiBubyBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTWVkaWFJbmZvfSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBhbmQgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEB0eXBlUGFyYW0gVEZvcm1hdCAtIFRoZSBmb3JtYXQgdHlwZSwgZGVmYXVsdHMgdG8gYG9iamVjdGAuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHtAbGluayBNZWRpYUluZm99IGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSB7QGxpbmsgTWVkaWFJbmZvfSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlcnJDYWxsYmFjayAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGNhbGwgb24gZXJyb3IuXG4gKi9cblxuZnVuY3Rpb24gbWVkaWFJbmZvRmFjdG9yeSgpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGVyckNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG1lZGlhSW5mb0ZhY3Rvcnkob3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9jYXRlRmlsZSxcbiAgICAuLi5tZXJnZWRPcHRpb25zXG4gIH0gPSB7XG4gICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdCA/PyBERUZBVUxUX09QVElPTlMuZm9ybWF0XG4gIH07XG4gIGNvbnN0IG1lZGlhSW5mb01vZHVsZUZhY3RvcnlPcHRzID0ge1xuICAgIC8vIFNpbGVuY2UgYWxsIHByaW50IGluIG1vZHVsZVxuICAgIHByaW50OiBub29wUHJpbnQsXG4gICAgcHJpbnRFcnI6IG5vb3BQcmludCxcbiAgICBsb2NhdGVGaWxlOiBsb2NhdGVGaWxlID8/IGRlZmF1bHRMb2NhdGVGaWxlLFxuICAgIG9uQWJvcnQ6IGVyciA9PiB7XG4gICAgICBpZiAoZXJyQ2FsbGJhY2spIHtcbiAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRmV0Y2ggYW5kIGxvYWQgV0FTTSBtb2R1bGVcbiAgTW9kdWxlKG1lZGlhSW5mb01vZHVsZUZhY3RvcnlPcHRzKS50aGVuKHdhc21Nb2R1bGUgPT4ge1xuICAgIGNhbGxiYWNrKG5ldyBNZWRpYUluZm8od2FzbU1vZHVsZSwgbWVyZ2VkT3B0aW9ucykpO1xuICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgaWYgKGVyckNhbGxiYWNrKSB7XG4gICAgICBlcnJDYWxsYmFjayhlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBvYmplY3QgaXMgb2YgYSBzcGVjaWZpZWQgdHJhY2sgdHlwZS5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRyYWNrIHRvIGNoZWNrIGZvci5cbiAqIEBwYXJhbSB0aGluZyAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0cmFjayB0eXBlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBvYmplY3QgaXMgb2YgdGhlIHNwZWNpZmllZCB0cmFjayB0eXBlLlxuICovXG5mdW5jdGlvbiBpc1RyYWNrVHlwZSh0aGluZywgdHlwZSkge1xuICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JyAmJiB0aGluZ1snQHR5cGUnXSA9PT0gdHlwZTtcbn1cblxuZXhwb3J0IHsgbWVkaWFJbmZvRmFjdG9yeSBhcyBkZWZhdWx0LCBpc1RyYWNrVHlwZSwgbWVkaWFJbmZvRmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/mediainfo.js/dist/esm-bundle/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./public/System/mediainfo.js/MediaInfoModule.wasm":
/*!*********************************************************!*\
  !*** ./public/System/mediainfo.js/MediaInfoModule.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/MediaInfoModule.1f684634.wasm";

/***/ })

}]);