/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_prettier_plugin-xml_src_plugin_js"],{

/***/ "(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/embed.js":
/*!********************************************************!*\
  !*** ./node_modules/@prettier/plugin-xml/src/embed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var prettier_doc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier/doc */ \"(pages-dir-browser)/./node_modules/prettier/doc.mjs\");\n\n\nconst {\n  dedentToRoot,\n  group,\n  hardline,\n  indent,\n  join,\n  line,\n  literalline,\n  softline\n} = prettier_doc__WEBPACK_IMPORTED_MODULE_0__.builders;\n\n// Get the start and end element tags from the current node on the tree\nfunction getElementTags(path, opts, print) {\n  const node = path.getValue();\n  const { OPEN, Name, attribute, START_CLOSE, SLASH_OPEN, END_NAME, END } =\n    node;\n\n  const parts = [OPEN, Name];\n\n  if (attribute.length > 0) {\n    parts.push(indent([line, join(line, path.map(print, \"attribute\"))]));\n  }\n\n  if (!opts.bracketSameLine) {\n    parts.push(softline);\n  }\n\n  return {\n    openTag: group([...parts, START_CLOSE]),\n    closeTag: group([SLASH_OPEN, END_NAME, END])\n  };\n}\n\n// Returns the value of the type tag if there is one, otherwise returns null.\nfunction getTagType(attributes) {\n  for (const attribute of attributes) {\n    if (attribute.Name === \"type\") {\n      const value = attribute.STRING;\n\n      if (value.startsWith('\"text/') && value.endsWith('\"')) {\n        return value.slice(6, -1);\n      }\n    }\n  }\n\n  return null;\n}\n\n// Get the name of the parser that is represented by the given element node,\n// return null if a matching parser cannot be found\nfunction getParser(node, opts) {\n  const { Name, attribute } = node;\n  let parser = Name.toLowerCase();\n\n  // We don't want to deal with some weird recursive parser situation, so we\n  // need to explicitly call out the XML parser here and just return null\n  if (parser === \"xml\") {\n    return null;\n  }\n\n  // If this is a style tag or a script tag with a text/xxx type then we will\n  // use xxx as the name of the parser\n  if ((parser === \"style\" || parser === \"script\") && attribute.length > 0) {\n    parser = getTagType(attribute);\n  }\n\n  // If the name of the parser is \"javascript\", then we're going to switch over\n  // to the babel parser.\n  if (parser === \"javascript\") {\n    parser = \"babel\";\n  }\n\n  // If there is a plugin that has a parser that matches the name of this\n  // element, then we're going to assume that's correct for embedding and go\n  // ahead and switch to that parser\n  if (\n    opts.plugins.some(\n      (plugin) =>\n        typeof plugin !== \"string\" &&\n        plugin.parsers &&\n        Object.prototype.hasOwnProperty.call(plugin.parsers, parser)\n    )\n  ) {\n    return parser;\n  }\n\n  return null;\n}\n\n// Get the source string that will be passed into the embedded parser from the\n// content of the inside of the element node\nfunction getSource(content) {\n  return content.chardata\n    .map((node) => {\n      const { SEA_WS, TEXT } = node;\n      const image = SEA_WS || TEXT;\n\n      return {\n        offset: node.location.startOffset,\n        printed: image\n      };\n    })\n    .sort(({ offset }) => offset)\n    .map(({ printed }) => printed)\n    .join(\"\");\n}\n\nfunction embed(path, opts) {\n  const node = path.getValue();\n\n  // If the node isn't an element node, then skip\n  if (node.name !== \"element\") {\n    return;\n  }\n\n  // If the name of the node does not correspond to the name of a parser that\n  // prettier knows about, then skip\n  const parser = getParser(node, opts);\n  if (!parser) {\n    return;\n  }\n\n  // If the node is self-closing, then skip\n  if (!node.content) {\n    return;\n  }\n\n  // If the node does not actually contain content, or it contains any content\n  // that is not just plain text, then skip.\n  const content = node.content;\n  if (\n    content.chardata.length === 0 ||\n    content.CData.length > 0 ||\n    content.Comment.length > 0 ||\n    content.element.length > 0 ||\n    content.PROCESSING_INSTRUCTION.length > 0 ||\n    content.reference.length > 0\n  ) {\n    return;\n  }\n\n  return async function (textToDoc, print) {\n    // Get the open and close tags of this element, then return the properly\n    // formatted content enclosed within them\n    const { openTag, closeTag } = getElementTags(path, opts, print);\n    const docNode = await textToDoc(getSource(content), { parser });\n\n    return group([\n      openTag,\n      literalline,\n      dedentToRoot(prettier_doc__WEBPACK_IMPORTED_MODULE_0__.utils.replaceEndOfLine(docNode)),\n      hardline,\n      closeTag\n    ]);\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (embed);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcHJldHRpZXIvcGx1Z2luLXhtbC9zcmMvZW1iZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxrREFBWTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBZ0U7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLFFBQVE7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEMsMERBQTBELFFBQVE7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBwcmV0dGllclxccGx1Z2luLXhtbFxcc3JjXFxlbWJlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBkb2MgZnJvbSBcInByZXR0aWVyL2RvY1wiO1xuXG5jb25zdCB7XG4gIGRlZGVudFRvUm9vdCxcbiAgZ3JvdXAsXG4gIGhhcmRsaW5lLFxuICBpbmRlbnQsXG4gIGpvaW4sXG4gIGxpbmUsXG4gIGxpdGVyYWxsaW5lLFxuICBzb2Z0bGluZVxufSA9IGRvYy5idWlsZGVycztcblxuLy8gR2V0IHRoZSBzdGFydCBhbmQgZW5kIGVsZW1lbnQgdGFncyBmcm9tIHRoZSBjdXJyZW50IG5vZGUgb24gdGhlIHRyZWVcbmZ1bmN0aW9uIGdldEVsZW1lbnRUYWdzKHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gIGNvbnN0IHsgT1BFTiwgTmFtZSwgYXR0cmlidXRlLCBTVEFSVF9DTE9TRSwgU0xBU0hfT1BFTiwgRU5EX05BTUUsIEVORCB9ID1cbiAgICBub2RlO1xuXG4gIGNvbnN0IHBhcnRzID0gW09QRU4sIE5hbWVdO1xuXG4gIGlmIChhdHRyaWJ1dGUubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzLnB1c2goaW5kZW50KFtsaW5lLCBqb2luKGxpbmUsIHBhdGgubWFwKHByaW50LCBcImF0dHJpYnV0ZVwiKSldKSk7XG4gIH1cblxuICBpZiAoIW9wdHMuYnJhY2tldFNhbWVMaW5lKSB7XG4gICAgcGFydHMucHVzaChzb2Z0bGluZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wZW5UYWc6IGdyb3VwKFsuLi5wYXJ0cywgU1RBUlRfQ0xPU0VdKSxcbiAgICBjbG9zZVRhZzogZ3JvdXAoW1NMQVNIX09QRU4sIEVORF9OQU1FLCBFTkRdKVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdHlwZSB0YWcgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuZnVuY3Rpb24gZ2V0VGFnVHlwZShhdHRyaWJ1dGVzKSB7XG4gIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlLk5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZS5TVFJJTkc7XG5cbiAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcInRleHQvJykgJiYgdmFsdWUuZW5kc1dpdGgoJ1wiJykpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDYsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gR2V0IHRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gZWxlbWVudCBub2RlLFxuLy8gcmV0dXJuIG51bGwgaWYgYSBtYXRjaGluZyBwYXJzZXIgY2Fubm90IGJlIGZvdW5kXG5mdW5jdGlvbiBnZXRQYXJzZXIobm9kZSwgb3B0cykge1xuICBjb25zdCB7IE5hbWUsIGF0dHJpYnV0ZSB9ID0gbm9kZTtcbiAgbGV0IHBhcnNlciA9IE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIGRlYWwgd2l0aCBzb21lIHdlaXJkIHJlY3Vyc2l2ZSBwYXJzZXIgc2l0dWF0aW9uLCBzbyB3ZVxuICAvLyBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBvdXQgdGhlIFhNTCBwYXJzZXIgaGVyZSBhbmQganVzdCByZXR1cm4gbnVsbFxuICBpZiAocGFyc2VyID09PSBcInhtbFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGlzIGlzIGEgc3R5bGUgdGFnIG9yIGEgc2NyaXB0IHRhZyB3aXRoIGEgdGV4dC94eHggdHlwZSB0aGVuIHdlIHdpbGxcbiAgLy8gdXNlIHh4eCBhcyB0aGUgbmFtZSBvZiB0aGUgcGFyc2VyXG4gIGlmICgocGFyc2VyID09PSBcInN0eWxlXCIgfHwgcGFyc2VyID09PSBcInNjcmlwdFwiKSAmJiBhdHRyaWJ1dGUubGVuZ3RoID4gMCkge1xuICAgIHBhcnNlciA9IGdldFRhZ1R5cGUoYXR0cmlidXRlKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgaXMgXCJqYXZhc2NyaXB0XCIsIHRoZW4gd2UncmUgZ29pbmcgdG8gc3dpdGNoIG92ZXJcbiAgLy8gdG8gdGhlIGJhYmVsIHBhcnNlci5cbiAgaWYgKHBhcnNlciA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICBwYXJzZXIgPSBcImJhYmVsXCI7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhIHBsdWdpbiB0aGF0IGhhcyBhIHBhcnNlciB0aGF0IG1hdGNoZXMgdGhlIG5hbWUgb2YgdGhpc1xuICAvLyBlbGVtZW50LCB0aGVuIHdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0J3MgY29ycmVjdCBmb3IgZW1iZWRkaW5nIGFuZCBnb1xuICAvLyBhaGVhZCBhbmQgc3dpdGNoIHRvIHRoYXQgcGFyc2VyXG4gIGlmIChcbiAgICBvcHRzLnBsdWdpbnMuc29tZShcbiAgICAgIChwbHVnaW4pID0+XG4gICAgICAgIHR5cGVvZiBwbHVnaW4gIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgcGx1Z2luLnBhcnNlcnMgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbi5wYXJzZXJzLCBwYXJzZXIpXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEdldCB0aGUgc291cmNlIHN0cmluZyB0aGF0IHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIGVtYmVkZGVkIHBhcnNlciBmcm9tIHRoZVxuLy8gY29udGVudCBvZiB0aGUgaW5zaWRlIG9mIHRoZSBlbGVtZW50IG5vZGVcbmZ1bmN0aW9uIGdldFNvdXJjZShjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50LmNoYXJkYXRhXG4gICAgLm1hcCgobm9kZSkgPT4ge1xuICAgICAgY29uc3QgeyBTRUFfV1MsIFRFWFQgfSA9IG5vZGU7XG4gICAgICBjb25zdCBpbWFnZSA9IFNFQV9XUyB8fCBURVhUO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IG5vZGUubG9jYXRpb24uc3RhcnRPZmZzZXQsXG4gICAgICAgIHByaW50ZWQ6IGltYWdlXG4gICAgICB9O1xuICAgIH0pXG4gICAgLnNvcnQoKHsgb2Zmc2V0IH0pID0+IG9mZnNldClcbiAgICAubWFwKCh7IHByaW50ZWQgfSkgPT4gcHJpbnRlZClcbiAgICAuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gZW1iZWQocGF0aCwgb3B0cykge1xuICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gIC8vIElmIHRoZSBub2RlIGlzbid0IGFuIGVsZW1lbnQgbm9kZSwgdGhlbiBza2lwXG4gIGlmIChub2RlLm5hbWUgIT09IFwiZWxlbWVudFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5hbWUgb2YgdGhlIG5vZGUgZG9lcyBub3QgY29ycmVzcG9uZCB0byB0aGUgbmFtZSBvZiBhIHBhcnNlciB0aGF0XG4gIC8vIHByZXR0aWVyIGtub3dzIGFib3V0LCB0aGVuIHNraXBcbiAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VyKG5vZGUsIG9wdHMpO1xuICBpZiAoIXBhcnNlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGlzIHNlbGYtY2xvc2luZywgdGhlbiBza2lwXG4gIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgZG9lcyBub3QgYWN0dWFsbHkgY29udGFpbiBjb250ZW50LCBvciBpdCBjb250YWlucyBhbnkgY29udGVudFxuICAvLyB0aGF0IGlzIG5vdCBqdXN0IHBsYWluIHRleHQsIHRoZW4gc2tpcC5cbiAgY29uc3QgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgaWYgKFxuICAgIGNvbnRlbnQuY2hhcmRhdGEubGVuZ3RoID09PSAwIHx8XG4gICAgY29udGVudC5DRGF0YS5sZW5ndGggPiAwIHx8XG4gICAgY29udGVudC5Db21tZW50Lmxlbmd0aCA+IDAgfHxcbiAgICBjb250ZW50LmVsZW1lbnQubGVuZ3RoID4gMCB8fFxuICAgIGNvbnRlbnQuUFJPQ0VTU0lOR19JTlNUUlVDVElPTi5sZW5ndGggPiAwIHx8XG4gICAgY29udGVudC5yZWZlcmVuY2UubGVuZ3RoID4gMFxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKHRleHRUb0RvYywgcHJpbnQpIHtcbiAgICAvLyBHZXQgdGhlIG9wZW4gYW5kIGNsb3NlIHRhZ3Mgb2YgdGhpcyBlbGVtZW50LCB0aGVuIHJldHVybiB0aGUgcHJvcGVybHlcbiAgICAvLyBmb3JtYXR0ZWQgY29udGVudCBlbmNsb3NlZCB3aXRoaW4gdGhlbVxuICAgIGNvbnN0IHsgb3BlblRhZywgY2xvc2VUYWcgfSA9IGdldEVsZW1lbnRUYWdzKHBhdGgsIG9wdHMsIHByaW50KTtcbiAgICBjb25zdCBkb2NOb2RlID0gYXdhaXQgdGV4dFRvRG9jKGdldFNvdXJjZShjb250ZW50KSwgeyBwYXJzZXIgfSk7XG5cbiAgICByZXR1cm4gZ3JvdXAoW1xuICAgICAgb3BlblRhZyxcbiAgICAgIGxpdGVyYWxsaW5lLFxuICAgICAgZGVkZW50VG9Sb290KGRvYy51dGlscy5yZXBsYWNlRW5kT2ZMaW5lKGRvY05vZGUpKSxcbiAgICAgIGhhcmRsaW5lLFxuICAgICAgY2xvc2VUYWdcbiAgICBdKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZW1iZWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/embed.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/languages.js":
/*!************************************************************!*\
  !*** ./node_modules/@prettier/plugin-xml/src/languages.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n  {\n    name: \"Ant Build System\",\n    tmScope: \"text.xml.ant\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"application/xml\",\n    filenames: [\"ant.xml\", \"build.xml\"],\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 15,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"COLLADA\",\n    extensions: [\".dae\"],\n    tmScope: \"text.xml\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 49,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"Eagle\",\n    extensions: [\".sch\", \".brd\"],\n    tmScope: \"text.xml\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 97,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"Genshi\",\n    extensions: [\".kid\"],\n    tmScope: \"text.xml.genshi\",\n    aliases: [\"xml+genshi\", \"xml+kid\"],\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 126,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"JetBrains MPS\",\n    extensions: [\".mps\", \".mpl\", \".msd\"],\n    tmScope: \"none\",\n    aliases: [\"mps\"],\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 465165328,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"LabVIEW\",\n    extensions: [\".lvproj\", \".lvclass\", \".lvlib\"],\n    tmScope: \"text.xml\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 194,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"Maven POM\",\n    tmScope: \"text.xml.pom\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    group: \"XML\",\n    filenames: [\"pom.xml\"],\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 226,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"SVG\",\n    extensions: [\".svg\"],\n    tmScope: \"text.xml.svg\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 337,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"Web Ontology Language\",\n    extensions: [\".owl\"],\n    tmScope: \"text.xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 394,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"XML\",\n    extensions: [\n      \".adml\",\n      \".admx\",\n      \".ant\",\n      \".axaml\",\n      \".axml\",\n      \".builds\",\n      \".ccproj\",\n      \".ccxml\",\n      \".clixml\",\n      \".cproject\",\n      \".cscfg\",\n      \".csdef\",\n      \".csl\",\n      \".csproj\",\n      \".ct\",\n      \".depproj\",\n      \".dita\",\n      \".ditamap\",\n      \".ditaval\",\n      \".dll.config\",\n      \".dotsettings\",\n      \".filters\",\n      \".fsproj\",\n      \".fxml\",\n      \".glade\",\n      \".gml\",\n      \".gmx\",\n      \".gpx\",\n      \".grxml\",\n      \".gst\",\n      \".hzp\",\n      \".iml\",\n      \".inx\",\n      \".ivy\",\n      \".jelly\",\n      \".jsproj\",\n      \".kml\",\n      \".launch\",\n      \".mdpolicy\",\n      \".mjml\",\n      \".mm\",\n      \".mod\",\n      \".mojo\",\n      \".mxml\",\n      \".natvis\",\n      \".ncl\",\n      \".ndproj\",\n      \".nproj\",\n      \".nuspec\",\n      \".odd\",\n      \".osm\",\n      \".pkgproj\",\n      \".pluginspec\",\n      \".proj\",\n      \".props\",\n      \".ps1xml\",\n      \".psc1\",\n      \".pt\",\n      \".qhelp\",\n      \".rdf\",\n      \".res\",\n      \".resx\",\n      \".rs\",\n      \".rss\",\n      \".runsettings\",\n      \".sch\",\n      \".scxml\",\n      \".sfproj\",\n      \".shproj\",\n      \".slnx\",\n      \".srdf\",\n      \".storyboard\",\n      \".sublime-snippet\",\n      \".sw\",\n      \".targets\",\n      \".tml\",\n      \".typ\",\n      \".ui\",\n      \".urdf\",\n      \".ux\",\n      \".vbproj\",\n      \".vcxproj\",\n      \".vsixmanifest\",\n      \".vssettings\",\n      \".vstemplate\",\n      \".vxml\",\n      \".wixproj\",\n      \".workflow\",\n      \".wsdl\",\n      \".wsf\",\n      \".wxi\",\n      \".wxl\",\n      \".wxs\",\n      \".x3d\",\n      \".xacro\",\n      \".xaml\",\n      \".xib\",\n      \".xlf\",\n      \".xliff\",\n      \".xmi\",\n      \".xml\",\n      \".xml.dist\",\n      \".xmp\",\n      \".xproj\",\n      \".xsd\",\n      \".xspec\",\n      \".xul\",\n      \".zcml\"\n    ],\n    tmScope: \"text.xml\",\n    aliases: [\"rss\", \"xsd\", \"wsdl\"],\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    filenames: [\n      \".classpath\",\n      \".cproject\",\n      \".project\",\n      \"App.config\",\n      \"NuGet.config\",\n      \"Settings.StyleCop\",\n      \"Web.Debug.config\",\n      \"Web.Release.config\",\n      \"Web.config\",\n      \"packages.config\"\n    ],\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 399,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"XML Property List\",\n    extensions: [\n      \".plist\",\n      \".stTheme\",\n      \".tmCommand\",\n      \".tmLanguage\",\n      \".tmPreferences\",\n      \".tmSnippet\",\n      \".tmTheme\"\n    ],\n    tmScope: \"text.xml.plist\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    group: \"XML\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 75622871,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"XPages\",\n    extensions: [\".xsp-config\", \".xsp.metadata\"],\n    tmScope: \"text.xml\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 400,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"XProc\",\n    extensions: [\".xpl\", \".xproc\"],\n    tmScope: \"text.xml\",\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 401,\n    vscodeLanguageIds: [\"xml\"]\n  },\n  {\n    name: \"XSLT\",\n    extensions: [\".xslt\", \".xsl\"],\n    tmScope: \"text.xml.xsl\",\n    aliases: [\"xsl\"],\n    codemirrorMode: \"xml\",\n    codemirrorMimeType: \"text/xml\",\n    since: \"0.1.0\",\n    parsers: [\"xml\"],\n    linguistLanguageId: 404,\n    vscodeLanguageIds: [\"xml\"]\n  }\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcHJldHRpZXIvcGx1Z2luLXhtbC9zcmMvbGFuZ3VhZ2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBwcmV0dGllclxccGx1Z2luLXhtbFxcc3JjXFxsYW5ndWFnZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgW1xuICB7XG4gICAgbmFtZTogXCJBbnQgQnVpbGQgU3lzdGVtXCIsXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbC5hbnRcIixcbiAgICBjb2RlbWlycm9yTW9kZTogXCJ4bWxcIixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgZmlsZW5hbWVzOiBbXCJhbnQueG1sXCIsIFwiYnVpbGQueG1sXCJdLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogMTUsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDT0xMQURBXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLmRhZVwiXSxcbiAgICB0bVNjb3BlOiBcInRleHQueG1sXCIsXG4gICAgY29kZW1pcnJvck1vZGU6IFwieG1sXCIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBcInRleHQveG1sXCIsXG4gICAgc2luY2U6IFwiMC4xLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ4bWxcIl0sXG4gICAgbGluZ3Vpc3RMYW5ndWFnZUlkOiA0OSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wieG1sXCJdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkVhZ2xlXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnNjaFwiLCBcIi5icmRcIl0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbFwiLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBcInhtbFwiLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogXCJ0ZXh0L3htbFwiLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogOTcsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJHZW5zaGlcIixcbiAgICBleHRlbnNpb25zOiBbXCIua2lkXCJdLFxuICAgIHRtU2NvcGU6IFwidGV4dC54bWwuZ2Vuc2hpXCIsXG4gICAgYWxpYXNlczogW1wieG1sK2dlbnNoaVwiLCBcInhtbCtraWRcIl0sXG4gICAgY29kZW1pcnJvck1vZGU6IFwieG1sXCIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBcInRleHQveG1sXCIsXG4gICAgc2luY2U6IFwiMC4xLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ4bWxcIl0sXG4gICAgbGluZ3Vpc3RMYW5ndWFnZUlkOiAxMjYsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJKZXRCcmFpbnMgTVBTXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLm1wc1wiLCBcIi5tcGxcIiwgXCIubXNkXCJdLFxuICAgIHRtU2NvcGU6IFwibm9uZVwiLFxuICAgIGFsaWFzZXM6IFtcIm1wc1wiXSxcbiAgICBjb2RlbWlycm9yTW9kZTogXCJ4bWxcIixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IFwidGV4dC94bWxcIixcbiAgICBzaW5jZTogXCIwLjEuMFwiLFxuICAgIHBhcnNlcnM6IFtcInhtbFwiXSxcbiAgICBsaW5ndWlzdExhbmd1YWdlSWQ6IDQ2NTE2NTMyOCxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wieG1sXCJdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkxhYlZJRVdcIixcbiAgICBleHRlbnNpb25zOiBbXCIubHZwcm9qXCIsIFwiLmx2Y2xhc3NcIiwgXCIubHZsaWJcIl0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbFwiLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBcInhtbFwiLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogXCJ0ZXh0L3htbFwiLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogMTk0LFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJ4bWxcIl1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTWF2ZW4gUE9NXCIsXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbC5wb21cIixcbiAgICBjb2RlbWlycm9yTW9kZTogXCJ4bWxcIixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IFwidGV4dC94bWxcIixcbiAgICBncm91cDogXCJYTUxcIixcbiAgICBmaWxlbmFtZXM6IFtcInBvbS54bWxcIl0sXG4gICAgc2luY2U6IFwiMC4xLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ4bWxcIl0sXG4gICAgbGluZ3Vpc3RMYW5ndWFnZUlkOiAyMjYsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTVkdcIixcbiAgICBleHRlbnNpb25zOiBbXCIuc3ZnXCJdLFxuICAgIHRtU2NvcGU6IFwidGV4dC54bWwuc3ZnXCIsXG4gICAgY29kZW1pcnJvck1vZGU6IFwieG1sXCIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBcInRleHQveG1sXCIsXG4gICAgc2luY2U6IFwiMC4xLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ4bWxcIl0sXG4gICAgbGluZ3Vpc3RMYW5ndWFnZUlkOiAzMzcsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJXZWIgT250b2xvZ3kgTGFuZ3VhZ2VcIixcbiAgICBleHRlbnNpb25zOiBbXCIub3dsXCJdLFxuICAgIHRtU2NvcGU6IFwidGV4dC54bWxcIixcbiAgICBzaW5jZTogXCIwLjEuMFwiLFxuICAgIHBhcnNlcnM6IFtcInhtbFwiXSxcbiAgICBsaW5ndWlzdExhbmd1YWdlSWQ6IDM5NCxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wieG1sXCJdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlhNTFwiLFxuICAgIGV4dGVuc2lvbnM6IFtcbiAgICAgIFwiLmFkbWxcIixcbiAgICAgIFwiLmFkbXhcIixcbiAgICAgIFwiLmFudFwiLFxuICAgICAgXCIuYXhhbWxcIixcbiAgICAgIFwiLmF4bWxcIixcbiAgICAgIFwiLmJ1aWxkc1wiLFxuICAgICAgXCIuY2Nwcm9qXCIsXG4gICAgICBcIi5jY3htbFwiLFxuICAgICAgXCIuY2xpeG1sXCIsXG4gICAgICBcIi5jcHJvamVjdFwiLFxuICAgICAgXCIuY3NjZmdcIixcbiAgICAgIFwiLmNzZGVmXCIsXG4gICAgICBcIi5jc2xcIixcbiAgICAgIFwiLmNzcHJvalwiLFxuICAgICAgXCIuY3RcIixcbiAgICAgIFwiLmRlcHByb2pcIixcbiAgICAgIFwiLmRpdGFcIixcbiAgICAgIFwiLmRpdGFtYXBcIixcbiAgICAgIFwiLmRpdGF2YWxcIixcbiAgICAgIFwiLmRsbC5jb25maWdcIixcbiAgICAgIFwiLmRvdHNldHRpbmdzXCIsXG4gICAgICBcIi5maWx0ZXJzXCIsXG4gICAgICBcIi5mc3Byb2pcIixcbiAgICAgIFwiLmZ4bWxcIixcbiAgICAgIFwiLmdsYWRlXCIsXG4gICAgICBcIi5nbWxcIixcbiAgICAgIFwiLmdteFwiLFxuICAgICAgXCIuZ3B4XCIsXG4gICAgICBcIi5ncnhtbFwiLFxuICAgICAgXCIuZ3N0XCIsXG4gICAgICBcIi5oenBcIixcbiAgICAgIFwiLmltbFwiLFxuICAgICAgXCIuaW54XCIsXG4gICAgICBcIi5pdnlcIixcbiAgICAgIFwiLmplbGx5XCIsXG4gICAgICBcIi5qc3Byb2pcIixcbiAgICAgIFwiLmttbFwiLFxuICAgICAgXCIubGF1bmNoXCIsXG4gICAgICBcIi5tZHBvbGljeVwiLFxuICAgICAgXCIubWptbFwiLFxuICAgICAgXCIubW1cIixcbiAgICAgIFwiLm1vZFwiLFxuICAgICAgXCIubW9qb1wiLFxuICAgICAgXCIubXhtbFwiLFxuICAgICAgXCIubmF0dmlzXCIsXG4gICAgICBcIi5uY2xcIixcbiAgICAgIFwiLm5kcHJvalwiLFxuICAgICAgXCIubnByb2pcIixcbiAgICAgIFwiLm51c3BlY1wiLFxuICAgICAgXCIub2RkXCIsXG4gICAgICBcIi5vc21cIixcbiAgICAgIFwiLnBrZ3Byb2pcIixcbiAgICAgIFwiLnBsdWdpbnNwZWNcIixcbiAgICAgIFwiLnByb2pcIixcbiAgICAgIFwiLnByb3BzXCIsXG4gICAgICBcIi5wczF4bWxcIixcbiAgICAgIFwiLnBzYzFcIixcbiAgICAgIFwiLnB0XCIsXG4gICAgICBcIi5xaGVscFwiLFxuICAgICAgXCIucmRmXCIsXG4gICAgICBcIi5yZXNcIixcbiAgICAgIFwiLnJlc3hcIixcbiAgICAgIFwiLnJzXCIsXG4gICAgICBcIi5yc3NcIixcbiAgICAgIFwiLnJ1bnNldHRpbmdzXCIsXG4gICAgICBcIi5zY2hcIixcbiAgICAgIFwiLnNjeG1sXCIsXG4gICAgICBcIi5zZnByb2pcIixcbiAgICAgIFwiLnNocHJvalwiLFxuICAgICAgXCIuc2xueFwiLFxuICAgICAgXCIuc3JkZlwiLFxuICAgICAgXCIuc3Rvcnlib2FyZFwiLFxuICAgICAgXCIuc3VibGltZS1zbmlwcGV0XCIsXG4gICAgICBcIi5zd1wiLFxuICAgICAgXCIudGFyZ2V0c1wiLFxuICAgICAgXCIudG1sXCIsXG4gICAgICBcIi50eXBcIixcbiAgICAgIFwiLnVpXCIsXG4gICAgICBcIi51cmRmXCIsXG4gICAgICBcIi51eFwiLFxuICAgICAgXCIudmJwcm9qXCIsXG4gICAgICBcIi52Y3hwcm9qXCIsXG4gICAgICBcIi52c2l4bWFuaWZlc3RcIixcbiAgICAgIFwiLnZzc2V0dGluZ3NcIixcbiAgICAgIFwiLnZzdGVtcGxhdGVcIixcbiAgICAgIFwiLnZ4bWxcIixcbiAgICAgIFwiLndpeHByb2pcIixcbiAgICAgIFwiLndvcmtmbG93XCIsXG4gICAgICBcIi53c2RsXCIsXG4gICAgICBcIi53c2ZcIixcbiAgICAgIFwiLnd4aVwiLFxuICAgICAgXCIud3hsXCIsXG4gICAgICBcIi53eHNcIixcbiAgICAgIFwiLngzZFwiLFxuICAgICAgXCIueGFjcm9cIixcbiAgICAgIFwiLnhhbWxcIixcbiAgICAgIFwiLnhpYlwiLFxuICAgICAgXCIueGxmXCIsXG4gICAgICBcIi54bGlmZlwiLFxuICAgICAgXCIueG1pXCIsXG4gICAgICBcIi54bWxcIixcbiAgICAgIFwiLnhtbC5kaXN0XCIsXG4gICAgICBcIi54bXBcIixcbiAgICAgIFwiLnhwcm9qXCIsXG4gICAgICBcIi54c2RcIixcbiAgICAgIFwiLnhzcGVjXCIsXG4gICAgICBcIi54dWxcIixcbiAgICAgIFwiLnpjbWxcIlxuICAgIF0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbFwiLFxuICAgIGFsaWFzZXM6IFtcInJzc1wiLCBcInhzZFwiLCBcIndzZGxcIl0sXG4gICAgY29kZW1pcnJvck1vZGU6IFwieG1sXCIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBcInRleHQveG1sXCIsXG4gICAgZmlsZW5hbWVzOiBbXG4gICAgICBcIi5jbGFzc3BhdGhcIixcbiAgICAgIFwiLmNwcm9qZWN0XCIsXG4gICAgICBcIi5wcm9qZWN0XCIsXG4gICAgICBcIkFwcC5jb25maWdcIixcbiAgICAgIFwiTnVHZXQuY29uZmlnXCIsXG4gICAgICBcIlNldHRpbmdzLlN0eWxlQ29wXCIsXG4gICAgICBcIldlYi5EZWJ1Zy5jb25maWdcIixcbiAgICAgIFwiV2ViLlJlbGVhc2UuY29uZmlnXCIsXG4gICAgICBcIldlYi5jb25maWdcIixcbiAgICAgIFwicGFja2FnZXMuY29uZmlnXCJcbiAgICBdLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogMzk5LFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJ4bWxcIl1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiWE1MIFByb3BlcnR5IExpc3RcIixcbiAgICBleHRlbnNpb25zOiBbXG4gICAgICBcIi5wbGlzdFwiLFxuICAgICAgXCIuc3RUaGVtZVwiLFxuICAgICAgXCIudG1Db21tYW5kXCIsXG4gICAgICBcIi50bUxhbmd1YWdlXCIsXG4gICAgICBcIi50bVByZWZlcmVuY2VzXCIsXG4gICAgICBcIi50bVNuaXBwZXRcIixcbiAgICAgIFwiLnRtVGhlbWVcIlxuICAgIF0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbC5wbGlzdFwiLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBcInhtbFwiLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogXCJ0ZXh0L3htbFwiLFxuICAgIGdyb3VwOiBcIlhNTFwiLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogNzU2MjI4NzEsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJYUGFnZXNcIixcbiAgICBleHRlbnNpb25zOiBbXCIueHNwLWNvbmZpZ1wiLCBcIi54c3AubWV0YWRhdGFcIl0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbFwiLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBcInhtbFwiLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogXCJ0ZXh0L3htbFwiLFxuICAgIHNpbmNlOiBcIjAuMS4wXCIsXG4gICAgcGFyc2VyczogW1wieG1sXCJdLFxuICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogNDAwLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJ4bWxcIl1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiWFByb2NcIixcbiAgICBleHRlbnNpb25zOiBbXCIueHBsXCIsIFwiLnhwcm9jXCJdLFxuICAgIHRtU2NvcGU6IFwidGV4dC54bWxcIixcbiAgICBjb2RlbWlycm9yTW9kZTogXCJ4bWxcIixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IFwidGV4dC94bWxcIixcbiAgICBzaW5jZTogXCIwLjEuMFwiLFxuICAgIHBhcnNlcnM6IFtcInhtbFwiXSxcbiAgICBsaW5ndWlzdExhbmd1YWdlSWQ6IDQwMSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wieG1sXCJdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlhTTFRcIixcbiAgICBleHRlbnNpb25zOiBbXCIueHNsdFwiLCBcIi54c2xcIl0sXG4gICAgdG1TY29wZTogXCJ0ZXh0LnhtbC54c2xcIixcbiAgICBhbGlhc2VzOiBbXCJ4c2xcIl0sXG4gICAgY29kZW1pcnJvck1vZGU6IFwieG1sXCIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBcInRleHQveG1sXCIsXG4gICAgc2luY2U6IFwiMC4xLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ4bWxcIl0sXG4gICAgbGluZ3Vpc3RMYW5ndWFnZUlkOiA0MDQsXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInhtbFwiXVxuICB9XG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/languages.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@prettier/plugin-xml/src/parser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _xml_tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xml-tools/parser */ \"(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/api.js\");\n\n\nfunction createError(message, options) {\n  // TODO: Use `Error.prototype.cause` when we drop support for Node.js<18.7.0\n\n  // Construct an error similar to the ones thrown by Prettier.\n  const error = new SyntaxError(\n    message +\n      \" (\" +\n      options.loc.start.line +\n      \":\" +\n      options.loc.start.column +\n      \")\"\n  );\n\n  return Object.assign(error, options);\n}\n\nfunction simplifyCST(node) {\n  switch (node.name) {\n    case \"attribute\": {\n      const { Name, EQUALS, STRING } = node.children;\n\n      return {\n        name: \"attribute\",\n        Name: Name[0].image,\n        EQUALS: EQUALS[0].image,\n        STRING: STRING[0].image,\n        location: node.location\n      };\n    }\n    case \"chardata\": {\n      const { SEA_WS, TEXT } = node.children;\n\n      return {\n        name: \"chardata\",\n        SEA_WS: SEA_WS ? SEA_WS[0].image : null,\n        TEXT: TEXT ? TEXT[0].image : null,\n        location: node.location\n      };\n    }\n    case \"content\": {\n      const {\n        CData,\n        Comment,\n        chardata,\n        element,\n        PROCESSING_INSTRUCTION,\n        reference\n      } = node.children;\n\n      return {\n        name: \"content\",\n        CData: CData || [],\n        Comment: Comment || [],\n        chardata: (chardata || []).map(simplifyCST),\n        element: (element || []).map(simplifyCST),\n        PROCESSING_INSTRUCTION: PROCESSING_INSTRUCTION || [],\n        reference: (reference || []).map(simplifyCST),\n        location: node.location\n      };\n    }\n    case \"docTypeDecl\": {\n      const { DocType, Name, externalID, CLOSE } = node.children;\n\n      return {\n        name: \"docTypeDecl\",\n        DocType: DocType[0].image,\n        Name: Name[0].image,\n        externalID: externalID ? simplifyCST(externalID[0]) : null,\n        CLOSE: CLOSE[0].image,\n        location: node.location\n      };\n    }\n    case \"document\": {\n      const { docTypeDecl, element, misc, prolog } = node.children;\n\n      return {\n        name: \"document\",\n        docTypeDecl: docTypeDecl ? simplifyCST(docTypeDecl[0]) : null,\n        element: element ? simplifyCST(element[0]) : null,\n        misc: (misc || [])\n          .filter((child) => !child.children.SEA_WS)\n          .map(simplifyCST),\n        prolog: prolog ? simplifyCST(prolog[0]) : null,\n        location: node.location\n      };\n    }\n    case \"element\": {\n      const {\n        OPEN,\n        Name,\n        attribute,\n        START_CLOSE,\n        content,\n        SLASH_OPEN,\n        END_NAME,\n        END,\n        SLASH_CLOSE\n      } = node.children;\n\n      return {\n        name: \"element\",\n        OPEN: OPEN[0].image,\n        Name: Name[0].image,\n        attribute: (attribute || []).map(simplifyCST),\n        START_CLOSE: START_CLOSE ? START_CLOSE[0].image : null,\n        content: content ? simplifyCST(content[0]) : null,\n        SLASH_OPEN: SLASH_OPEN ? SLASH_OPEN[0].image : null,\n        END_NAME: END_NAME ? END_NAME[0].image : null,\n        END: END ? END[0].image : null,\n        SLASH_CLOSE: SLASH_CLOSE ? SLASH_CLOSE[0].image : null,\n        location: node.location\n      };\n    }\n    case \"externalID\": {\n      const { Public, PubIDLiteral, System, SystemLiteral } = node.children;\n\n      return {\n        name: \"externalID\",\n        Public: Public ? Public[0].image : null,\n        PubIDLiteral: PubIDLiteral ? PubIDLiteral[0].image : null,\n        System: System ? System[0].image : null,\n        SystemLiteral: SystemLiteral ? SystemLiteral[0].image : null,\n        location: node.location\n      };\n    }\n    case \"misc\": {\n      const { Comment, PROCESSING_INSTRUCTION, SEA_WS } = node.children;\n\n      return {\n        name: \"misc\",\n        Comment: Comment ? Comment[0].image : null,\n        PROCESSING_INSTRUCTION: PROCESSING_INSTRUCTION\n          ? PROCESSING_INSTRUCTION[0].image\n          : null,\n        SEA_WS: SEA_WS ? SEA_WS[0].image : null,\n        location: node.location\n      };\n    }\n    case \"prolog\": {\n      const { XMLDeclOpen, attribute, SPECIAL_CLOSE } = node.children;\n\n      return {\n        name: \"prolog\",\n        XMLDeclOpen: XMLDeclOpen[0].image,\n        attribute: (attribute || []).map(simplifyCST),\n        SPECIAL_CLOSE: SPECIAL_CLOSE[0].image,\n        location: node.location\n      };\n    }\n    case \"reference\": {\n      const { CharRef, EntityRef } = node.children;\n\n      return {\n        name: \"reference\",\n        CharRef: CharRef ? CharRef[0].image : null,\n        EntityRef: EntityRef ? EntityRef[0].image : null,\n        location: node.location\n      };\n    }\n    default:\n      throw new Error(`Unknown node type: ${node.name}`);\n  }\n}\n\nconst parser = {\n  parse(text) {\n    const { lexErrors, parseErrors, cst } = (0,_xml_tools_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(text);\n\n    // If there are any lexical errors, throw the first of them as an error.\n    if (lexErrors.length > 0) {\n      const lexError = lexErrors[0];\n      throw createError(lexError.message, {\n        loc: {\n          start: { line: lexError.line, column: lexError.column },\n          end: {\n            line: lexError.line,\n            column: lexError.column + lexError.length\n          }\n        }\n      });\n    }\n\n    // If there are any parse errors, throw the first of them as an error.\n    if (parseErrors.length > 0) {\n      const parseError = parseErrors[0];\n      throw createError(parseError.message, {\n        loc: {\n          start: {\n            line: parseError.token.startLine,\n            column: parseError.token.startColumn\n          },\n          end: {\n            line: parseError.token.endLine,\n            column: parseError.token.endColumn\n          }\n        }\n      });\n    }\n\n    // Otherwise return the CST.\n    return simplifyCST(cst);\n  },\n  astFormat: \"xml\",\n  locStart(node) {\n    return node.location.startOffset;\n  },\n  locEnd(node) {\n    return node.location.endOffset;\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parser);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcHJldHRpZXIvcGx1Z2luLXhtbC9zcmMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4Qzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksOEJBQThCLEVBQUUsd0RBQWE7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQThDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBwcmV0dGllclxccGx1Z2luLXhtbFxcc3JjXFxwYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgYXMgeG1sVG9vbHNQYXJzZSB9IGZyb20gXCJAeG1sLXRvb2xzL3BhcnNlclwiO1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gIC8vIFRPRE86IFVzZSBgRXJyb3IucHJvdG90eXBlLmNhdXNlYCB3aGVuIHdlIGRyb3Agc3VwcG9ydCBmb3IgTm9kZS5qczwxOC43LjBcblxuICAvLyBDb25zdHJ1Y3QgYW4gZXJyb3Igc2ltaWxhciB0byB0aGUgb25lcyB0aHJvd24gYnkgUHJldHRpZXIuXG4gIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKFxuICAgIG1lc3NhZ2UgK1xuICAgICAgXCIgKFwiICtcbiAgICAgIG9wdGlvbnMubG9jLnN0YXJ0LmxpbmUgK1xuICAgICAgXCI6XCIgK1xuICAgICAgb3B0aW9ucy5sb2Muc3RhcnQuY29sdW1uICtcbiAgICAgIFwiKVwiXG4gICk7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZXJyb3IsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeUNTVChub2RlKSB7XG4gIHN3aXRjaCAobm9kZS5uYW1lKSB7XG4gICAgY2FzZSBcImF0dHJpYnV0ZVwiOiB7XG4gICAgICBjb25zdCB7IE5hbWUsIEVRVUFMUywgU1RSSU5HIH0gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBcImF0dHJpYnV0ZVwiLFxuICAgICAgICBOYW1lOiBOYW1lWzBdLmltYWdlLFxuICAgICAgICBFUVVBTFM6IEVRVUFMU1swXS5pbWFnZSxcbiAgICAgICAgU1RSSU5HOiBTVFJJTkdbMF0uaW1hZ2UsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiY2hhcmRhdGFcIjoge1xuICAgICAgY29uc3QgeyBTRUFfV1MsIFRFWFQgfSA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwiY2hhcmRhdGFcIixcbiAgICAgICAgU0VBX1dTOiBTRUFfV1MgPyBTRUFfV1NbMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBURVhUOiBURVhUID8gVEVYVFswXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiY29udGVudFwiOiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIENEYXRhLFxuICAgICAgICBDb21tZW50LFxuICAgICAgICBjaGFyZGF0YSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgUFJPQ0VTU0lOR19JTlNUUlVDVElPTixcbiAgICAgICAgcmVmZXJlbmNlXG4gICAgICB9ID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJjb250ZW50XCIsXG4gICAgICAgIENEYXRhOiBDRGF0YSB8fCBbXSxcbiAgICAgICAgQ29tbWVudDogQ29tbWVudCB8fCBbXSxcbiAgICAgICAgY2hhcmRhdGE6IChjaGFyZGF0YSB8fCBbXSkubWFwKHNpbXBsaWZ5Q1NUKSxcbiAgICAgICAgZWxlbWVudDogKGVsZW1lbnQgfHwgW10pLm1hcChzaW1wbGlmeUNTVCksXG4gICAgICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT046IFBST0NFU1NJTkdfSU5TVFJVQ1RJT04gfHwgW10sXG4gICAgICAgIHJlZmVyZW5jZTogKHJlZmVyZW5jZSB8fCBbXSkubWFwKHNpbXBsaWZ5Q1NUKSxcbiAgICAgICAgbG9jYXRpb246IG5vZGUubG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJkb2NUeXBlRGVjbFwiOiB7XG4gICAgICBjb25zdCB7IERvY1R5cGUsIE5hbWUsIGV4dGVybmFsSUQsIENMT1NFIH0gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBcImRvY1R5cGVEZWNsXCIsXG4gICAgICAgIERvY1R5cGU6IERvY1R5cGVbMF0uaW1hZ2UsXG4gICAgICAgIE5hbWU6IE5hbWVbMF0uaW1hZ2UsXG4gICAgICAgIGV4dGVybmFsSUQ6IGV4dGVybmFsSUQgPyBzaW1wbGlmeUNTVChleHRlcm5hbElEWzBdKSA6IG51bGwsXG4gICAgICAgIENMT1NFOiBDTE9TRVswXS5pbWFnZSxcbiAgICAgICAgbG9jYXRpb246IG5vZGUubG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJkb2N1bWVudFwiOiB7XG4gICAgICBjb25zdCB7IGRvY1R5cGVEZWNsLCBlbGVtZW50LCBtaXNjLCBwcm9sb2cgfSA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwiZG9jdW1lbnRcIixcbiAgICAgICAgZG9jVHlwZURlY2w6IGRvY1R5cGVEZWNsID8gc2ltcGxpZnlDU1QoZG9jVHlwZURlY2xbMF0pIDogbnVsbCxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCA/IHNpbXBsaWZ5Q1NUKGVsZW1lbnRbMF0pIDogbnVsbCxcbiAgICAgICAgbWlzYzogKG1pc2MgfHwgW10pXG4gICAgICAgICAgLmZpbHRlcigoY2hpbGQpID0+ICFjaGlsZC5jaGlsZHJlbi5TRUFfV1MpXG4gICAgICAgICAgLm1hcChzaW1wbGlmeUNTVCksXG4gICAgICAgIHByb2xvZzogcHJvbG9nID8gc2ltcGxpZnlDU1QocHJvbG9nWzBdKSA6IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZWxlbWVudFwiOiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIE9QRU4sXG4gICAgICAgIE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgU1RBUlRfQ0xPU0UsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIFNMQVNIX09QRU4sXG4gICAgICAgIEVORF9OQU1FLFxuICAgICAgICBFTkQsXG4gICAgICAgIFNMQVNIX0NMT1NFXG4gICAgICB9ID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJlbGVtZW50XCIsXG4gICAgICAgIE9QRU46IE9QRU5bMF0uaW1hZ2UsXG4gICAgICAgIE5hbWU6IE5hbWVbMF0uaW1hZ2UsXG4gICAgICAgIGF0dHJpYnV0ZTogKGF0dHJpYnV0ZSB8fCBbXSkubWFwKHNpbXBsaWZ5Q1NUKSxcbiAgICAgICAgU1RBUlRfQ0xPU0U6IFNUQVJUX0NMT1NFID8gU1RBUlRfQ0xPU0VbMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBjb250ZW50OiBjb250ZW50ID8gc2ltcGxpZnlDU1QoY29udGVudFswXSkgOiBudWxsLFxuICAgICAgICBTTEFTSF9PUEVOOiBTTEFTSF9PUEVOID8gU0xBU0hfT1BFTlswXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIEVORF9OQU1FOiBFTkRfTkFNRSA/IEVORF9OQU1FWzBdLmltYWdlIDogbnVsbCxcbiAgICAgICAgRU5EOiBFTkQgPyBFTkRbMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBTTEFTSF9DTE9TRTogU0xBU0hfQ0xPU0UgPyBTTEFTSF9DTE9TRVswXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZXh0ZXJuYWxJRFwiOiB7XG4gICAgICBjb25zdCB7IFB1YmxpYywgUHViSURMaXRlcmFsLCBTeXN0ZW0sIFN5c3RlbUxpdGVyYWwgfSA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwiZXh0ZXJuYWxJRFwiLFxuICAgICAgICBQdWJsaWM6IFB1YmxpYyA/IFB1YmxpY1swXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIFB1YklETGl0ZXJhbDogUHViSURMaXRlcmFsID8gUHViSURMaXRlcmFsWzBdLmltYWdlIDogbnVsbCxcbiAgICAgICAgU3lzdGVtOiBTeXN0ZW0gPyBTeXN0ZW1bMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBTeXN0ZW1MaXRlcmFsOiBTeXN0ZW1MaXRlcmFsID8gU3lzdGVtTGl0ZXJhbFswXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibWlzY1wiOiB7XG4gICAgICBjb25zdCB7IENvbW1lbnQsIFBST0NFU1NJTkdfSU5TVFJVQ1RJT04sIFNFQV9XUyB9ID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJtaXNjXCIsXG4gICAgICAgIENvbW1lbnQ6IENvbW1lbnQgPyBDb21tZW50WzBdLmltYWdlIDogbnVsbCxcbiAgICAgICAgUFJPQ0VTU0lOR19JTlNUUlVDVElPTjogUFJPQ0VTU0lOR19JTlNUUlVDVElPTlxuICAgICAgICAgID8gUFJPQ0VTU0lOR19JTlNUUlVDVElPTlswXS5pbWFnZVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgU0VBX1dTOiBTRUFfV1MgPyBTRUFfV1NbMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBsb2NhdGlvbjogbm9kZS5sb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInByb2xvZ1wiOiB7XG4gICAgICBjb25zdCB7IFhNTERlY2xPcGVuLCBhdHRyaWJ1dGUsIFNQRUNJQUxfQ0xPU0UgfSA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwicHJvbG9nXCIsXG4gICAgICAgIFhNTERlY2xPcGVuOiBYTUxEZWNsT3BlblswXS5pbWFnZSxcbiAgICAgICAgYXR0cmlidXRlOiAoYXR0cmlidXRlIHx8IFtdKS5tYXAoc2ltcGxpZnlDU1QpLFxuICAgICAgICBTUEVDSUFMX0NMT1NFOiBTUEVDSUFMX0NMT1NFWzBdLmltYWdlLFxuICAgICAgICBsb2NhdGlvbjogbm9kZS5sb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInJlZmVyZW5jZVwiOiB7XG4gICAgICBjb25zdCB7IENoYXJSZWYsIEVudGl0eVJlZiB9ID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJyZWZlcmVuY2VcIixcbiAgICAgICAgQ2hhclJlZjogQ2hhclJlZiA/IENoYXJSZWZbMF0uaW1hZ2UgOiBudWxsLFxuICAgICAgICBFbnRpdHlSZWY6IEVudGl0eVJlZiA/IEVudGl0eVJlZlswXS5pbWFnZSA6IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBub2RlLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHtub2RlLm5hbWV9YCk7XG4gIH1cbn1cblxuY29uc3QgcGFyc2VyID0ge1xuICBwYXJzZSh0ZXh0KSB7XG4gICAgY29uc3QgeyBsZXhFcnJvcnMsIHBhcnNlRXJyb3JzLCBjc3QgfSA9IHhtbFRvb2xzUGFyc2UodGV4dCk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGxleGljYWwgZXJyb3JzLCB0aHJvdyB0aGUgZmlyc3Qgb2YgdGhlbSBhcyBhbiBlcnJvci5cbiAgICBpZiAobGV4RXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxleEVycm9yID0gbGV4RXJyb3JzWzBdO1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGV4RXJyb3IubWVzc2FnZSwge1xuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDogeyBsaW5lOiBsZXhFcnJvci5saW5lLCBjb2x1bW46IGxleEVycm9yLmNvbHVtbiB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgbGluZTogbGV4RXJyb3IubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbGV4RXJyb3IuY29sdW1uICsgbGV4RXJyb3IubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgYW55IHBhcnNlIGVycm9ycywgdGhyb3cgdGhlIGZpcnN0IG9mIHRoZW0gYXMgYW4gZXJyb3IuXG4gICAgaWYgKHBhcnNlRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcnNlRXJyb3IgPSBwYXJzZUVycm9yc1swXTtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKHBhcnNlRXJyb3IubWVzc2FnZSwge1xuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgbGluZTogcGFyc2VFcnJvci50b2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHBhcnNlRXJyb3IudG9rZW4uc3RhcnRDb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgbGluZTogcGFyc2VFcnJvci50b2tlbi5lbmRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBwYXJzZUVycm9yLnRva2VuLmVuZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgQ1NULlxuICAgIHJldHVybiBzaW1wbGlmeUNTVChjc3QpO1xuICB9LFxuICBhc3RGb3JtYXQ6IFwieG1sXCIsXG4gIGxvY1N0YXJ0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5sb2NhdGlvbi5zdGFydE9mZnNldDtcbiAgfSxcbiAgbG9jRW5kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5sb2NhdGlvbi5lbmRPZmZzZXQ7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/plugin.js":
/*!*********************************************************!*\
  !*** ./node_modules/@prettier/plugin-xml/src/plugin.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./languages.js */ \"(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/languages.js\");\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser.js */ \"(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/parser.js\");\n/* harmony import */ var _printer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./printer.js */ \"(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/printer.js\");\n\n\n\n\nconst plugin = {\n  languages: _languages_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  parsers: {\n    xml: _parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  },\n  printers: {\n    xml: _printer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  },\n  options: {\n    xmlSelfClosingSpace: {\n      type: \"boolean\",\n      category: \"XML\",\n      default: true,\n      description: \"Adds a space before self-closing tags.\",\n      since: \"1.1.0\"\n    },\n    xmlWhitespaceSensitivity: {\n      type: \"choice\",\n      category: \"XML\",\n      default: \"strict\",\n      description: \"How to handle whitespaces in XML.\",\n      choices: [\n        {\n          value: \"strict\",\n          description: \"Whitespaces are considered sensitive in all elements.\"\n        },\n        {\n          value: \"preserve\",\n          description:\n            \"Whitespaces within text nodes in XML elements and attributes are considered sensitive.\"\n        },\n        {\n          value: \"ignore\",\n          description: \"Whitespaces are considered insensitive in all elements.\"\n        }\n      ],\n      since: \"0.6.0\"\n    },\n    xmlSortAttributesByKey: {\n      type: \"boolean\",\n      category: \"XML\",\n      default: false,\n      description:\n        \"Orders XML attributes by key alphabetically while prioritizing xmlns attributes.\"\n    },\n    xmlQuoteAttributes: {\n      type: \"choice\",\n      category: \"XML\",\n      default: \"preserve\",\n      description: \"How to handle whitespaces in XML.\",\n      choices: [\n        {\n          value: \"preserve\",\n          description:\n            \"Quotes in attribute values will be preserved as written.\"\n        },\n        {\n          value: \"single\",\n          description:\n            \"Quotes in attribute values will be converted to consistent single quotes and other quotes in the string will be escaped.\"\n        },\n        {\n          value: \"double\",\n          description:\n            \"Quotes in attribute values will be converted to consistent double quotes and other quotes in the string will be escaped.\"\n        }\n      ]\n    }\n  },\n  defaultOptions: {\n    printWidth: 80,\n    tabWidth: 2\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcHJldHRpZXIvcGx1Z2luLXhtbC9zcmMvcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUM7QUFDTjtBQUNFOztBQUVuQztBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVMsa0RBQU07QUFDZixHQUFHO0FBQ0g7QUFDQSxTQUFTLG1EQUFPO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBwcmV0dGllclxccGx1Z2luLXhtbFxcc3JjXFxwbHVnaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxhbmd1YWdlcyBmcm9tIFwiLi9sYW5ndWFnZXMuanNcIjtcbmltcG9ydCBwYXJzZXIgZnJvbSBcIi4vcGFyc2VyLmpzXCI7XG5pbXBvcnQgcHJpbnRlciBmcm9tIFwiLi9wcmludGVyLmpzXCI7XG5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgbGFuZ3VhZ2VzLFxuICBwYXJzZXJzOiB7XG4gICAgeG1sOiBwYXJzZXJcbiAgfSxcbiAgcHJpbnRlcnM6IHtcbiAgICB4bWw6IHByaW50ZXJcbiAgfSxcbiAgb3B0aW9uczoge1xuICAgIHhtbFNlbGZDbG9zaW5nU3BhY2U6IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgY2F0ZWdvcnk6IFwiWE1MXCIsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiQWRkcyBhIHNwYWNlIGJlZm9yZSBzZWxmLWNsb3NpbmcgdGFncy5cIixcbiAgICAgIHNpbmNlOiBcIjEuMS4wXCJcbiAgICB9LFxuICAgIHhtbFdoaXRlc3BhY2VTZW5zaXRpdml0eToge1xuICAgICAgdHlwZTogXCJjaG9pY2VcIixcbiAgICAgIGNhdGVnb3J5OiBcIlhNTFwiLFxuICAgICAgZGVmYXVsdDogXCJzdHJpY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkhvdyB0byBoYW5kbGUgd2hpdGVzcGFjZXMgaW4gWE1MLlwiLFxuICAgICAgY2hvaWNlczogW1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwic3RyaWN0XCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiV2hpdGVzcGFjZXMgYXJlIGNvbnNpZGVyZWQgc2Vuc2l0aXZlIGluIGFsbCBlbGVtZW50cy5cIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgIFwiV2hpdGVzcGFjZXMgd2l0aGluIHRleHQgbm9kZXMgaW4gWE1MIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGFyZSBjb25zaWRlcmVkIHNlbnNpdGl2ZS5cIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwiaWdub3JlXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiV2hpdGVzcGFjZXMgYXJlIGNvbnNpZGVyZWQgaW5zZW5zaXRpdmUgaW4gYWxsIGVsZW1lbnRzLlwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBzaW5jZTogXCIwLjYuMFwiXG4gICAgfSxcbiAgICB4bWxTb3J0QXR0cmlidXRlc0J5S2V5OiB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGNhdGVnb3J5OiBcIlhNTFwiLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgXCJPcmRlcnMgWE1MIGF0dHJpYnV0ZXMgYnkga2V5IGFscGhhYmV0aWNhbGx5IHdoaWxlIHByaW9yaXRpemluZyB4bWxucyBhdHRyaWJ1dGVzLlwiXG4gICAgfSxcbiAgICB4bWxRdW90ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBjYXRlZ29yeTogXCJYTUxcIixcbiAgICAgIGRlZmF1bHQ6IFwicHJlc2VydmVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkhvdyB0byBoYW5kbGUgd2hpdGVzcGFjZXMgaW4gWE1MLlwiLFxuICAgICAgY2hvaWNlczogW1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgIFwiUXVvdGVzIGluIGF0dHJpYnV0ZSB2YWx1ZXMgd2lsbCBiZSBwcmVzZXJ2ZWQgYXMgd3JpdHRlbi5cIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwic2luZ2xlXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIlF1b3RlcyBpbiBhdHRyaWJ1dGUgdmFsdWVzIHdpbGwgYmUgY29udmVydGVkIHRvIGNvbnNpc3RlbnQgc2luZ2xlIHF1b3RlcyBhbmQgb3RoZXIgcXVvdGVzIGluIHRoZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogXCJkb3VibGVcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgIFwiUXVvdGVzIGluIGF0dHJpYnV0ZSB2YWx1ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY29uc2lzdGVudCBkb3VibGUgcXVvdGVzIGFuZCBvdGhlciBxdW90ZXMgaW4gdGhlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQuXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICBwcmludFdpZHRoOiA4MCxcbiAgICB0YWJXaWR0aDogMlxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/plugin.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/printer.js":
/*!**********************************************************!*\
  !*** ./node_modules/@prettier/plugin-xml/src/printer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var prettier_doc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier/doc */ \"(pages-dir-browser)/./node_modules/prettier/doc.mjs\");\n/* harmony import */ var _embed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./embed.js */ \"(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/embed.js\");\n\n\n\nconst { fill, group, hardline, indent, join, line, literalline, softline } =\n  prettier_doc__WEBPACK_IMPORTED_MODULE_0__.builders;\n\nconst ignoreStartComment = \"<!-- prettier-ignore-start -->\";\nconst ignoreEndComment = \"<!-- prettier-ignore-end -->\";\n\nfunction hasIgnoreRanges(comments) {\n  if (comments.length === 0) {\n    return false;\n  }\n\n  comments.sort((left, right) => left.startOffset - right.startOffset);\n\n  let startFound = false;\n  for (let idx = 0; idx < comments.length; idx += 1) {\n    if (comments[idx].image === ignoreStartComment) {\n      startFound = true;\n    } else if (startFound && comments[idx].image === ignoreEndComment) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isWhitespaceIgnorable(opts, name, attributes, content) {\n  // If the whitespace sensitivity setting is \"strict\", then we can't ignore the\n  // whitespace.\n  if (opts.xmlWhitespaceSensitivity === \"strict\") {\n    return false;\n  }\n\n  // If we have an xsl:text element, then we cannot ignore the whitespace.\n  if (name === \"xsl:text\") {\n    return false;\n  }\n\n  // If there is an xml:space attribute set to \"preserve\", then we can't ignore\n  // the whitespace.\n  if (\n    attributes.some(\n      (attribute) =>\n        attribute &&\n        attribute.Name === \"xml:space\" &&\n        attribute.STRING.slice(1, -1) === \"preserve\"\n    )\n  ) {\n    return false;\n  }\n\n  // If there are character data nodes in the content, then we can't ignore the\n  // whitespace.\n  if (content.CData.length > 0) {\n    return false;\n  }\n\n  // If there are comments in the content and the comments are ignore ranges,\n  // then we can't ignore the whitespace.\n  if (hasIgnoreRanges(content.Comment)) {\n    return false;\n  }\n\n  // Otherwise we can.\n  return true;\n}\n\nfunction printIToken(path) {\n  const node = path.getValue();\n\n  return {\n    offset: node.startOffset,\n    startLine: node.startLine,\n    endLine: node.endLine,\n    printed: node.image\n  };\n}\n\nfunction printAttribute(path, opts, print) {\n  const { Name, EQUALS, STRING } = path.getValue();\n\n  let attributeValue;\n  if (opts.xmlQuoteAttributes === \"double\") {\n    const content = STRING.slice(1, -1).replaceAll('\"', \"&quot;\");\n    attributeValue = `\"${content}\"`;\n  } else if (opts.xmlQuoteAttributes === \"single\") {\n    const content = STRING.slice(1, -1).replaceAll(\"'\", \"&apos;\");\n    attributeValue = `'${content}'`;\n  } else {\n    // preserve\n    attributeValue = STRING;\n  }\n\n  return [Name, EQUALS, attributeValue];\n}\n\nfunction printCharData(path, opts, print) {\n  const { SEA_WS, TEXT } = path.getValue();\n  const image = SEA_WS || TEXT;\n\n  return image\n    .split(/(\\n)/g)\n    .map((value, index) => (index % 2 === 0 ? value : literalline));\n}\n\nfunction printContentFragments(path, print) {\n  return [\n    ...path.map(printIToken, \"CData\"),\n    ...path.map(printIToken, \"Comment\"),\n    ...path.map(\n      (charDataPath) => ({\n        offset: charDataPath.getValue().location.startOffset,\n        printed: print(charDataPath)\n      }),\n      \"chardata\"\n    ),\n    ...path.map(\n      (elementPath) => ({\n        offset: elementPath.getValue().location.startOffset,\n        printed: print(elementPath)\n      }),\n      \"element\"\n    ),\n    ...path.map(printIToken, \"PROCESSING_INSTRUCTION\"),\n    ...path.map((referencePath) => {\n      const referenceNode = referencePath.getValue();\n\n      return {\n        offset: referenceNode.location.startOffset,\n        printed: print(referencePath)\n      };\n    }, \"reference\")\n  ];\n}\n\nfunction printContent(path, opts, print) {\n  let fragments = printContentFragments(path, print);\n  const { Comment } = path.getValue();\n\n  if (hasIgnoreRanges(Comment)) {\n    Comment.sort((left, right) => left.startOffset - right.startOffset);\n\n    const ignoreRanges = [];\n    let ignoreStart = null;\n\n    // Build up a list of ignored ranges from the original text based on\n    // the special prettier-ignore-* comments\n    Comment.forEach((comment) => {\n      if (comment.image === ignoreStartComment) {\n        ignoreStart = comment;\n      } else if (ignoreStart && comment.image === ignoreEndComment) {\n        ignoreRanges.push({\n          start: ignoreStart.startOffset,\n          end: comment.endOffset\n        });\n\n        ignoreStart = null;\n      }\n    });\n\n    // Filter the printed children to only include the ones that are\n    // outside of each of the ignored ranges\n    fragments = fragments.filter((fragment) =>\n      ignoreRanges.every(\n        ({ start, end }) => fragment.offset < start || fragment.offset > end\n      )\n    );\n\n    // Push each of the ignored ranges into the child list as its own\n    // element so that the original content is still included\n    ignoreRanges.forEach(({ start, end }) => {\n      const content = opts.originalText.slice(start, end + 1);\n\n      fragments.push({\n        offset: start,\n        printed: prettier_doc__WEBPACK_IMPORTED_MODULE_0__.utils.replaceEndOfLine(content)\n      });\n    });\n  }\n\n  fragments.sort((left, right) => left.offset - right.offset);\n  return group(fragments.map(({ printed }) => printed));\n}\n\nfunction printDocTypeDecl(path, opts, print) {\n  const { DocType, Name, externalID, CLOSE } = path.getValue();\n  const parts = [DocType, \" \", Name];\n\n  if (externalID) {\n    parts.push(\" \", path.call(print, \"externalID\"));\n  }\n\n  return group([...parts, CLOSE]);\n}\n\nfunction printDocument(path, opts, print) {\n  const { docTypeDecl, element, misc, prolog } = path.getValue();\n  const fragments = [];\n\n  if (docTypeDecl) {\n    fragments.push({\n      offset: docTypeDecl.location.startOffset,\n      printed: path.call(print, \"docTypeDecl\")\n    });\n  }\n\n  if (prolog) {\n    fragments.push({\n      offset: prolog.location.startOffset,\n      printed: path.call(print, \"prolog\")\n    });\n  }\n\n  path.each((miscPath) => {\n    const misc = miscPath.getValue();\n\n    fragments.push({\n      offset: misc.location.startOffset,\n      printed: print(miscPath)\n    });\n  }, \"misc\");\n\n  if (element) {\n    fragments.push({\n      offset: element.location.startOffset,\n      printed: path.call(print, \"element\")\n    });\n  }\n\n  fragments.sort((left, right) => left.offset - right.offset);\n\n  return [\n    join(\n      hardline,\n      fragments.map(({ printed }) => printed)\n    ),\n    hardline\n  ];\n}\n\nfunction printCharDataPreserve(path, print) {\n  let prevLocation;\n  const response = [];\n\n  path.each((charDataPath) => {\n    const chardata = charDataPath.getValue();\n    const location = chardata.location;\n    const content = print(charDataPath);\n\n    if (\n      prevLocation &&\n      location.startColumn &&\n      prevLocation.endColumn &&\n      location.startLine === prevLocation.endLine &&\n      location.startColumn === prevLocation.endColumn + 1\n    ) {\n      // continuation of previous fragment\n      const prevFragment = response[response.length - 1];\n      prevFragment.endLine = location.endLine;\n      prevFragment.printed = group([prevFragment.printed, content]);\n    } else {\n      response.push({\n        offset: location.startOffset,\n        startLine: location.startLine,\n        endLine: location.endLine,\n        printed: content,\n        whitespace: true\n      });\n    }\n    prevLocation = location;\n  }, \"chardata\");\n\n  return response;\n}\n\nfunction printCharDataIgnore(path) {\n  const response = [];\n\n  path.each((charDataPath) => {\n    const chardata = charDataPath.getValue();\n    if (!chardata.TEXT) {\n      return;\n    }\n\n    const content = chardata.TEXT.replaceAll(/^[\\t\\n\\r\\s]+|[\\t\\n\\r\\s]+$/g, \"\");\n    const printed = group(\n      content.split(/(\\n)/g).map((value) => {\n        if (value === \"\\n\") {\n          return literalline;\n        }\n\n        return fill(\n          value\n            .split(/\\b( +)\\b/g)\n            .map((segment, index) => (index % 2 === 0 ? segment : line))\n        );\n      })\n    );\n\n    const location = chardata.location;\n    response.push({\n      offset: location.startOffset,\n      startLine: location.startLine,\n      endLine: location.endLine,\n      printed\n    });\n  }, \"chardata\");\n\n  return response;\n}\n\nfunction printElementFragments(path, opts, print) {\n  const children = path.getValue();\n  let response = [];\n\n  response = response.concat(path.map(printIToken, \"Comment\"));\n\n  if (children.chardata.length > 0) {\n    if (\n      children.chardata.some((chardata) => !!chardata.TEXT) &&\n      opts.xmlWhitespaceSensitivity === \"preserve\"\n    ) {\n      response = response.concat(printCharDataPreserve(path, print));\n    } else {\n      response = response.concat(printCharDataIgnore(path, print));\n    }\n  }\n\n  response = response.concat(\n    path.map((elementPath) => {\n      const location = elementPath.getValue().location;\n\n      return {\n        offset: location.startOffset,\n        startLine: location.startLine,\n        endLine: location.endLine,\n        printed: print(elementPath)\n      };\n    }, \"element\")\n  );\n\n  response = response.concat(path.map(printIToken, \"PROCESSING_INSTRUCTION\"));\n\n  response = response.concat(\n    path.map((referencePath) => {\n      const referenceNode = referencePath.getValue();\n\n      return {\n        type: \"reference\",\n        offset: referenceNode.location.startOffset,\n        startLine: referenceNode.location.startLine,\n        endLine: referenceNode.location.endLine,\n        printed: print(referencePath)\n      };\n    }, \"reference\")\n  );\n\n  return response;\n}\n\nfunction printElement(path, opts, print) {\n  const {\n    OPEN,\n    Name,\n    attribute,\n    START_CLOSE,\n    content,\n    SLASH_OPEN,\n    END_NAME,\n    END,\n    SLASH_CLOSE\n  } = path.getValue();\n\n  const parts = [OPEN, Name];\n\n  if (attribute.length > 0) {\n    const attributes = path.map(\n      (attributePath) => ({\n        node: attributePath.getValue(),\n        printed: print(attributePath)\n      }),\n      \"attribute\"\n    );\n\n    if (opts.xmlSortAttributesByKey) {\n      attributes.sort((left, right) => {\n        const leftAttr = left.node.Name;\n        const rightAttr = right.node.Name;\n\n        // Check if the attributes are xmlns.\n        if (leftAttr === \"xmlns\") return -1;\n        if (rightAttr === \"xmlns\") return 1;\n\n        // Check if they are both in namespaces.\n        if (leftAttr.includes(\":\") && rightAttr.includes(\":\")) {\n          const [leftNS, leftKey] = leftAttr.split(\":\");\n          const [rightNS, rightKey] = rightAttr.split(\":\");\n\n          // If namespaces are equal, compare keys\n          if (leftNS === rightNS) return leftKey.localeCompare(rightKey);\n\n          // Handle the 1 but not both being an xmlns\n          if (leftNS === \"xmlns\") return -1;\n          if (rightNS === \"xmlns\") return 1;\n\n          return leftNS.localeCompare(rightNS);\n        }\n\n        // Check if the attributes have namespaces.\n        if (leftAttr.includes(\":\")) return -1;\n        if (rightAttr.includes(\":\")) return 1;\n\n        return leftAttr.localeCompare(rightAttr);\n      });\n    }\n\n    const separator = opts.singleAttributePerLine ? hardline : line;\n    parts.push(\n      indent([\n        line,\n        join(\n          separator,\n          attributes.map(({ printed }) => printed)\n        )\n      ])\n    );\n  }\n\n  // Determine the value that will go between the <, name, and attributes\n  // of an element and the /> of an element.\n  let space;\n  if (opts.bracketSameLine) {\n    space = opts.xmlSelfClosingSpace ? \" \" : \"\";\n  } else {\n    space = opts.xmlSelfClosingSpace ? line : softline;\n  }\n\n  if (SLASH_CLOSE) {\n    return group([...parts, space, SLASH_CLOSE]);\n  }\n\n  if (\n    content.chardata.length === 0 &&\n    content.CData.length === 0 &&\n    content.Comment.length === 0 &&\n    content.element.length === 0 &&\n    content.PROCESSING_INSTRUCTION.length === 0 &&\n    content.reference.length === 0\n  ) {\n    return group([...parts, space, \"/>\"]);\n  }\n\n  const openTag = group([\n    ...parts,\n    opts.bracketSameLine ? \"\" : softline,\n    START_CLOSE\n  ]);\n\n  const closeTag = group([SLASH_OPEN, END_NAME, END]);\n\n  if (isWhitespaceIgnorable(opts, Name, attribute, content)) {\n    const fragments = path.call(\n      (childrenPath) => printElementFragments(childrenPath, opts, print),\n      \"content\"\n    );\n\n    fragments.sort((left, right) => left.offset - right.offset);\n\n    if (\n      opts.xmlWhitespaceSensitivity === \"preserve\" &&\n      fragments.some(({ whitespace }) => whitespace)\n    ) {\n      return group([\n        openTag,\n        fragments.map(({ printed }) => printed),\n        closeTag\n      ]);\n    }\n\n    if (fragments.length === 0) {\n      return group([...parts, space, \"/>\"]);\n    }\n\n    // If the only content of this tag is chardata, then use a softline so\n    // that we won't necessarily break (to allow <foo>bar</foo>).\n    if (\n      fragments.length === 1 &&\n      content.chardata.filter((chardata) => chardata.TEXT).length === 1\n    ) {\n      return group([\n        openTag,\n        indent([softline, fragments[0].printed]),\n        softline,\n        closeTag\n      ]);\n    }\n\n    let delimiter = hardline;\n\n    // If the only content is both chardata and references, then use a softline\n    // so that we won't necessarily break.\n    if (\n      fragments.length ===\n      content.chardata.filter((chardata) => chardata.TEXT).length +\n        content.reference.length\n    ) {\n      delimiter = \" \";\n    }\n\n    const docs = [hardline];\n    let lastLine = fragments[0].startLine;\n\n    fragments.forEach((node, index) => {\n      if (index !== 0) {\n        if (node.startLine - lastLine >= 2) {\n          docs.push(hardline, hardline);\n        } else {\n          docs.push(delimiter);\n        }\n      }\n\n      docs.push(node.printed);\n      lastLine = node.endLine;\n    });\n\n    return group([openTag, indent(docs), hardline, closeTag]);\n  }\n\n  return group([openTag, indent(path.call(print, \"content\")), closeTag]);\n}\n\nfunction printExternalID(path, opts, print) {\n  const { Public, PubIDLiteral, System, SystemLiteral } = path.getValue();\n\n  if (System) {\n    return group([System, indent([line, SystemLiteral])]);\n  }\n\n  return group([\n    group([Public, indent([line, PubIDLiteral])]),\n    indent([line, SystemLiteral])\n  ]);\n}\n\nfunction printMisc(path, opts, print) {\n  const { Comment, PROCESSING_INSTRUCTION, SEA_WS } = path.getValue();\n\n  return Comment || PROCESSING_INSTRUCTION || SEA_WS;\n}\n\nfunction printProlog(path, opts, print) {\n  const { XMLDeclOpen, attribute, SPECIAL_CLOSE } = path.getValue();\n  const parts = [XMLDeclOpen];\n\n  if (attribute) {\n    parts.push(indent([softline, join(line, path.map(print, \"attribute\"))]));\n  }\n\n  return group([\n    ...parts,\n    opts.xmlSelfClosingSpace ? line : softline,\n    SPECIAL_CLOSE\n  ]);\n}\n\nfunction printReference(path, opts, print) {\n  const { CharRef, EntityRef } = path.getValue();\n\n  return CharRef || EntityRef;\n}\n\nconst printer = {\n  getVisitorKeys(node, nonTraversableKeys) {\n    return Object.keys(node).filter(\n      (key) => key !== \"location\" && key !== \"tokenType\"\n    );\n  },\n  embed: _embed_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  print(path, opts, print) {\n    const node = path.getValue();\n\n    switch (node.name) {\n      case \"attribute\":\n        return printAttribute(path, opts, print);\n      case \"chardata\":\n        return printCharData(path, opts, print);\n      case \"content\":\n        return printContent(path, opts, print);\n      case \"docTypeDecl\":\n        return printDocTypeDecl(path, opts, print);\n      case \"document\":\n        return printDocument(path, opts, print);\n      case \"element\":\n        return printElement(path, opts, print);\n      case \"externalID\":\n        return printExternalID(path, opts, print);\n      case \"misc\":\n        return printMisc(path, opts, print);\n      case \"prolog\":\n        return printProlog(path, opts, print);\n      case \"reference\":\n        return printReference(path, opts, print);\n      default:\n        throw new Error(`Unknown node type: ${node.name}`);\n    }\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (printer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcHJldHRpZXIvcGx1Z2luLXhtbC9zcmMvcHJpbnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDTDs7QUFFL0IsUUFBUSxtRUFBbUU7QUFDM0UsRUFBRSxrREFBWTs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx1QkFBdUI7O0FBRWpDO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QseUJBQXlCLFFBQVE7QUFDakMsSUFBSTtBQUNKLCtEQUErRDtBQUMvRCx5QkFBeUIsUUFBUTtBQUNqQyxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGVBQWU7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBUztBQUMxQixPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7O0FBRUE7QUFDQSxVQUFVLG1DQUFtQztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4Qzs7QUFFeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDBDQUEwQzs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBwcmV0dGllclxccGx1Z2luLXhtbFxcc3JjXFxwcmludGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGRvYyBmcm9tIFwicHJldHRpZXIvZG9jXCI7XG5pbXBvcnQgZW1iZWQgZnJvbSBcIi4vZW1iZWQuanNcIjtcblxuY29uc3QgeyBmaWxsLCBncm91cCwgaGFyZGxpbmUsIGluZGVudCwgam9pbiwgbGluZSwgbGl0ZXJhbGxpbmUsIHNvZnRsaW5lIH0gPVxuICBkb2MuYnVpbGRlcnM7XG5cbmNvbnN0IGlnbm9yZVN0YXJ0Q29tbWVudCA9IFwiPCEtLSBwcmV0dGllci1pZ25vcmUtc3RhcnQgLS0+XCI7XG5jb25zdCBpZ25vcmVFbmRDb21tZW50ID0gXCI8IS0tIHByZXR0aWVyLWlnbm9yZS1lbmQgLS0+XCI7XG5cbmZ1bmN0aW9uIGhhc0lnbm9yZVJhbmdlcyhjb21tZW50cykge1xuICBpZiAoY29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29tbWVudHMuc29ydCgobGVmdCwgcmlnaHQpID0+IGxlZnQuc3RhcnRPZmZzZXQgLSByaWdodC5zdGFydE9mZnNldCk7XG5cbiAgbGV0IHN0YXJ0Rm91bmQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY29tbWVudHMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgIGlmIChjb21tZW50c1tpZHhdLmltYWdlID09PSBpZ25vcmVTdGFydENvbW1lbnQpIHtcbiAgICAgIHN0YXJ0Rm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRGb3VuZCAmJiBjb21tZW50c1tpZHhdLmltYWdlID09PSBpZ25vcmVFbmRDb21tZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZUlnbm9yYWJsZShvcHRzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjb250ZW50KSB7XG4gIC8vIElmIHRoZSB3aGl0ZXNwYWNlIHNlbnNpdGl2aXR5IHNldHRpbmcgaXMgXCJzdHJpY3RcIiwgdGhlbiB3ZSBjYW4ndCBpZ25vcmUgdGhlXG4gIC8vIHdoaXRlc3BhY2UuXG4gIGlmIChvcHRzLnhtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSA9PT0gXCJzdHJpY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYW4geHNsOnRleHQgZWxlbWVudCwgdGhlbiB3ZSBjYW5ub3QgaWdub3JlIHRoZSB3aGl0ZXNwYWNlLlxuICBpZiAobmFtZSA9PT0gXCJ4c2w6dGV4dFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYW4geG1sOnNwYWNlIGF0dHJpYnV0ZSBzZXQgdG8gXCJwcmVzZXJ2ZVwiLCB0aGVuIHdlIGNhbid0IGlnbm9yZVxuICAvLyB0aGUgd2hpdGVzcGFjZS5cbiAgaWYgKFxuICAgIGF0dHJpYnV0ZXMuc29tZShcbiAgICAgIChhdHRyaWJ1dGUpID0+XG4gICAgICAgIGF0dHJpYnV0ZSAmJlxuICAgICAgICBhdHRyaWJ1dGUuTmFtZSA9PT0gXCJ4bWw6c3BhY2VcIiAmJlxuICAgICAgICBhdHRyaWJ1dGUuU1RSSU5HLnNsaWNlKDEsIC0xKSA9PT0gXCJwcmVzZXJ2ZVwiXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgY2hhcmFjdGVyIGRhdGEgbm9kZXMgaW4gdGhlIGNvbnRlbnQsIHRoZW4gd2UgY2FuJ3QgaWdub3JlIHRoZVxuICAvLyB3aGl0ZXNwYWNlLlxuICBpZiAoY29udGVudC5DRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGNvbW1lbnRzIGluIHRoZSBjb250ZW50IGFuZCB0aGUgY29tbWVudHMgYXJlIGlnbm9yZSByYW5nZXMsXG4gIC8vIHRoZW4gd2UgY2FuJ3QgaWdub3JlIHRoZSB3aGl0ZXNwYWNlLlxuICBpZiAoaGFzSWdub3JlUmFuZ2VzKGNvbnRlbnQuQ29tbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPdGhlcndpc2Ugd2UgY2FuLlxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJpbnRJVG9rZW4ocGF0aCkge1xuICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gIHJldHVybiB7XG4gICAgb2Zmc2V0OiBub2RlLnN0YXJ0T2Zmc2V0LFxuICAgIHN0YXJ0TGluZTogbm9kZS5zdGFydExpbmUsXG4gICAgZW5kTGluZTogbm9kZS5lbmRMaW5lLFxuICAgIHByaW50ZWQ6IG5vZGUuaW1hZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJpbnRBdHRyaWJ1dGUocGF0aCwgb3B0cywgcHJpbnQpIHtcbiAgY29uc3QgeyBOYW1lLCBFUVVBTFMsIFNUUklORyB9ID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gIGxldCBhdHRyaWJ1dGVWYWx1ZTtcbiAgaWYgKG9wdHMueG1sUXVvdGVBdHRyaWJ1dGVzID09PSBcImRvdWJsZVwiKSB7XG4gICAgY29uc3QgY29udGVudCA9IFNUUklORy5zbGljZSgxLCAtMSkucmVwbGFjZUFsbCgnXCInLCBcIiZxdW90O1wiKTtcbiAgICBhdHRyaWJ1dGVWYWx1ZSA9IGBcIiR7Y29udGVudH1cImA7XG4gIH0gZWxzZSBpZiAob3B0cy54bWxRdW90ZUF0dHJpYnV0ZXMgPT09IFwic2luZ2xlXCIpIHtcbiAgICBjb25zdCBjb250ZW50ID0gU1RSSU5HLnNsaWNlKDEsIC0xKS5yZXBsYWNlQWxsKFwiJ1wiLCBcIiZhcG9zO1wiKTtcbiAgICBhdHRyaWJ1dGVWYWx1ZSA9IGAnJHtjb250ZW50fSdgO1xuICB9IGVsc2Uge1xuICAgIC8vIHByZXNlcnZlXG4gICAgYXR0cmlidXRlVmFsdWUgPSBTVFJJTkc7XG4gIH1cblxuICByZXR1cm4gW05hbWUsIEVRVUFMUywgYXR0cmlidXRlVmFsdWVdO1xufVxuXG5mdW5jdGlvbiBwcmludENoYXJEYXRhKHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGNvbnN0IHsgU0VBX1dTLCBURVhUIH0gPSBwYXRoLmdldFZhbHVlKCk7XG4gIGNvbnN0IGltYWdlID0gU0VBX1dTIHx8IFRFWFQ7XG5cbiAgcmV0dXJuIGltYWdlXG4gICAgLnNwbGl0KC8oXFxuKS9nKVxuICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKGluZGV4ICUgMiA9PT0gMCA/IHZhbHVlIDogbGl0ZXJhbGxpbmUpKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDb250ZW50RnJhZ21lbnRzKHBhdGgsIHByaW50KSB7XG4gIHJldHVybiBbXG4gICAgLi4ucGF0aC5tYXAocHJpbnRJVG9rZW4sIFwiQ0RhdGFcIiksXG4gICAgLi4ucGF0aC5tYXAocHJpbnRJVG9rZW4sIFwiQ29tbWVudFwiKSxcbiAgICAuLi5wYXRoLm1hcChcbiAgICAgIChjaGFyRGF0YVBhdGgpID0+ICh7XG4gICAgICAgIG9mZnNldDogY2hhckRhdGFQYXRoLmdldFZhbHVlKCkubG9jYXRpb24uc3RhcnRPZmZzZXQsXG4gICAgICAgIHByaW50ZWQ6IHByaW50KGNoYXJEYXRhUGF0aClcbiAgICAgIH0pLFxuICAgICAgXCJjaGFyZGF0YVwiXG4gICAgKSxcbiAgICAuLi5wYXRoLm1hcChcbiAgICAgIChlbGVtZW50UGF0aCkgPT4gKHtcbiAgICAgICAgb2Zmc2V0OiBlbGVtZW50UGF0aC5nZXRWYWx1ZSgpLmxvY2F0aW9uLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBwcmludGVkOiBwcmludChlbGVtZW50UGF0aClcbiAgICAgIH0pLFxuICAgICAgXCJlbGVtZW50XCJcbiAgICApLFxuICAgIC4uLnBhdGgubWFwKHByaW50SVRva2VuLCBcIlBST0NFU1NJTkdfSU5TVFJVQ1RJT05cIiksXG4gICAgLi4ucGF0aC5tYXAoKHJlZmVyZW5jZVBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSByZWZlcmVuY2VQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogcmVmZXJlbmNlTm9kZS5sb2NhdGlvbi5zdGFydE9mZnNldCxcbiAgICAgICAgcHJpbnRlZDogcHJpbnQocmVmZXJlbmNlUGF0aClcbiAgICAgIH07XG4gICAgfSwgXCJyZWZlcmVuY2VcIilcbiAgXTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDb250ZW50KHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGxldCBmcmFnbWVudHMgPSBwcmludENvbnRlbnRGcmFnbWVudHMocGF0aCwgcHJpbnQpO1xuICBjb25zdCB7IENvbW1lbnQgfSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICBpZiAoaGFzSWdub3JlUmFuZ2VzKENvbW1lbnQpKSB7XG4gICAgQ29tbWVudC5zb3J0KChsZWZ0LCByaWdodCkgPT4gbGVmdC5zdGFydE9mZnNldCAtIHJpZ2h0LnN0YXJ0T2Zmc2V0KTtcblxuICAgIGNvbnN0IGlnbm9yZVJhbmdlcyA9IFtdO1xuICAgIGxldCBpZ25vcmVTdGFydCA9IG51bGw7XG5cbiAgICAvLyBCdWlsZCB1cCBhIGxpc3Qgb2YgaWdub3JlZCByYW5nZXMgZnJvbSB0aGUgb3JpZ2luYWwgdGV4dCBiYXNlZCBvblxuICAgIC8vIHRoZSBzcGVjaWFsIHByZXR0aWVyLWlnbm9yZS0qIGNvbW1lbnRzXG4gICAgQ29tbWVudC5mb3JFYWNoKChjb21tZW50KSA9PiB7XG4gICAgICBpZiAoY29tbWVudC5pbWFnZSA9PT0gaWdub3JlU3RhcnRDb21tZW50KSB7XG4gICAgICAgIGlnbm9yZVN0YXJ0ID0gY29tbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoaWdub3JlU3RhcnQgJiYgY29tbWVudC5pbWFnZSA9PT0gaWdub3JlRW5kQ29tbWVudCkge1xuICAgICAgICBpZ25vcmVSYW5nZXMucHVzaCh7XG4gICAgICAgICAgc3RhcnQ6IGlnbm9yZVN0YXJ0LnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgIGVuZDogY29tbWVudC5lbmRPZmZzZXRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWdub3JlU3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRmlsdGVyIHRoZSBwcmludGVkIGNoaWxkcmVuIHRvIG9ubHkgaW5jbHVkZSB0aGUgb25lcyB0aGF0IGFyZVxuICAgIC8vIG91dHNpZGUgb2YgZWFjaCBvZiB0aGUgaWdub3JlZCByYW5nZXNcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuZmlsdGVyKChmcmFnbWVudCkgPT5cbiAgICAgIGlnbm9yZVJhbmdlcy5ldmVyeShcbiAgICAgICAgKHsgc3RhcnQsIGVuZCB9KSA9PiBmcmFnbWVudC5vZmZzZXQgPCBzdGFydCB8fCBmcmFnbWVudC5vZmZzZXQgPiBlbmRcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gUHVzaCBlYWNoIG9mIHRoZSBpZ25vcmVkIHJhbmdlcyBpbnRvIHRoZSBjaGlsZCBsaXN0IGFzIGl0cyBvd25cbiAgICAvLyBlbGVtZW50IHNvIHRoYXQgdGhlIG9yaWdpbmFsIGNvbnRlbnQgaXMgc3RpbGwgaW5jbHVkZWRcbiAgICBpZ25vcmVSYW5nZXMuZm9yRWFjaCgoeyBzdGFydCwgZW5kIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBvcHRzLm9yaWdpbmFsVGV4dC5zbGljZShzdGFydCwgZW5kICsgMSk7XG5cbiAgICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgcHJpbnRlZDogZG9jLnV0aWxzLnJlcGxhY2VFbmRPZkxpbmUoY29udGVudClcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnJhZ21lbnRzLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0Lm9mZnNldCAtIHJpZ2h0Lm9mZnNldCk7XG4gIHJldHVybiBncm91cChmcmFnbWVudHMubWFwKCh7IHByaW50ZWQgfSkgPT4gcHJpbnRlZCkpO1xufVxuXG5mdW5jdGlvbiBwcmludERvY1R5cGVEZWNsKHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGNvbnN0IHsgRG9jVHlwZSwgTmFtZSwgZXh0ZXJuYWxJRCwgQ0xPU0UgfSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgY29uc3QgcGFydHMgPSBbRG9jVHlwZSwgXCIgXCIsIE5hbWVdO1xuXG4gIGlmIChleHRlcm5hbElEKSB7XG4gICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4dGVybmFsSURcIikpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwKFsuLi5wYXJ0cywgQ0xPU0VdKTtcbn1cblxuZnVuY3Rpb24gcHJpbnREb2N1bWVudChwYXRoLCBvcHRzLCBwcmludCkge1xuICBjb25zdCB7IGRvY1R5cGVEZWNsLCBlbGVtZW50LCBtaXNjLCBwcm9sb2cgfSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgY29uc3QgZnJhZ21lbnRzID0gW107XG5cbiAgaWYgKGRvY1R5cGVEZWNsKSB7XG4gICAgZnJhZ21lbnRzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBkb2NUeXBlRGVjbC5sb2NhdGlvbi5zdGFydE9mZnNldCxcbiAgICAgIHByaW50ZWQ6IHBhdGguY2FsbChwcmludCwgXCJkb2NUeXBlRGVjbFwiKVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb2xvZykge1xuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgIG9mZnNldDogcHJvbG9nLmxvY2F0aW9uLnN0YXJ0T2Zmc2V0LFxuICAgICAgcHJpbnRlZDogcGF0aC5jYWxsKHByaW50LCBcInByb2xvZ1wiKVxuICAgIH0pO1xuICB9XG5cbiAgcGF0aC5lYWNoKChtaXNjUGF0aCkgPT4ge1xuICAgIGNvbnN0IG1pc2MgPSBtaXNjUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgZnJhZ21lbnRzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBtaXNjLmxvY2F0aW9uLnN0YXJ0T2Zmc2V0LFxuICAgICAgcHJpbnRlZDogcHJpbnQobWlzY1BhdGgpXG4gICAgfSk7XG4gIH0sIFwibWlzY1wiKTtcblxuICBpZiAoZWxlbWVudCkge1xuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgIG9mZnNldDogZWxlbWVudC5sb2NhdGlvbi5zdGFydE9mZnNldCxcbiAgICAgIHByaW50ZWQ6IHBhdGguY2FsbChwcmludCwgXCJlbGVtZW50XCIpXG4gICAgfSk7XG4gIH1cblxuICBmcmFnbWVudHMuc29ydCgobGVmdCwgcmlnaHQpID0+IGxlZnQub2Zmc2V0IC0gcmlnaHQub2Zmc2V0KTtcblxuICByZXR1cm4gW1xuICAgIGpvaW4oXG4gICAgICBoYXJkbGluZSxcbiAgICAgIGZyYWdtZW50cy5tYXAoKHsgcHJpbnRlZCB9KSA9PiBwcmludGVkKVxuICAgICksXG4gICAgaGFyZGxpbmVcbiAgXTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDaGFyRGF0YVByZXNlcnZlKHBhdGgsIHByaW50KSB7XG4gIGxldCBwcmV2TG9jYXRpb247XG4gIGNvbnN0IHJlc3BvbnNlID0gW107XG5cbiAgcGF0aC5lYWNoKChjaGFyRGF0YVBhdGgpID0+IHtcbiAgICBjb25zdCBjaGFyZGF0YSA9IGNoYXJEYXRhUGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gY2hhcmRhdGEubG9jYXRpb247XG4gICAgY29uc3QgY29udGVudCA9IHByaW50KGNoYXJEYXRhUGF0aCk7XG5cbiAgICBpZiAoXG4gICAgICBwcmV2TG9jYXRpb24gJiZcbiAgICAgIGxvY2F0aW9uLnN0YXJ0Q29sdW1uICYmXG4gICAgICBwcmV2TG9jYXRpb24uZW5kQ29sdW1uICYmXG4gICAgICBsb2NhdGlvbi5zdGFydExpbmUgPT09IHByZXZMb2NhdGlvbi5lbmRMaW5lICYmXG4gICAgICBsb2NhdGlvbi5zdGFydENvbHVtbiA9PT0gcHJldkxvY2F0aW9uLmVuZENvbHVtbiArIDFcbiAgICApIHtcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBvZiBwcmV2aW91cyBmcmFnbWVudFxuICAgICAgY29uc3QgcHJldkZyYWdtZW50ID0gcmVzcG9uc2VbcmVzcG9uc2UubGVuZ3RoIC0gMV07XG4gICAgICBwcmV2RnJhZ21lbnQuZW5kTGluZSA9IGxvY2F0aW9uLmVuZExpbmU7XG4gICAgICBwcmV2RnJhZ21lbnQucHJpbnRlZCA9IGdyb3VwKFtwcmV2RnJhZ21lbnQucHJpbnRlZCwgY29udGVudF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZS5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBsb2NhdGlvbi5zdGFydE9mZnNldCxcbiAgICAgICAgc3RhcnRMaW5lOiBsb2NhdGlvbi5zdGFydExpbmUsXG4gICAgICAgIGVuZExpbmU6IGxvY2F0aW9uLmVuZExpbmUsXG4gICAgICAgIHByaW50ZWQ6IGNvbnRlbnQsXG4gICAgICAgIHdoaXRlc3BhY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwcmV2TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgfSwgXCJjaGFyZGF0YVwiKTtcblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIHByaW50Q2hhckRhdGFJZ25vcmUocGF0aCkge1xuICBjb25zdCByZXNwb25zZSA9IFtdO1xuXG4gIHBhdGguZWFjaCgoY2hhckRhdGFQYXRoKSA9PiB7XG4gICAgY29uc3QgY2hhcmRhdGEgPSBjaGFyRGF0YVBhdGguZ2V0VmFsdWUoKTtcbiAgICBpZiAoIWNoYXJkYXRhLlRFWFQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gY2hhcmRhdGEuVEVYVC5yZXBsYWNlQWxsKC9eW1xcdFxcblxcclxcc10rfFtcXHRcXG5cXHJcXHNdKyQvZywgXCJcIik7XG4gICAgY29uc3QgcHJpbnRlZCA9IGdyb3VwKFxuICAgICAgY29udGVudC5zcGxpdCgvKFxcbikvZykubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsbChcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgLnNwbGl0KC9cXGIoICspXFxiL2cpXG4gICAgICAgICAgICAubWFwKChzZWdtZW50LCBpbmRleCkgPT4gKGluZGV4ICUgMiA9PT0gMCA/IHNlZ21lbnQgOiBsaW5lKSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gY2hhcmRhdGEubG9jYXRpb247XG4gICAgcmVzcG9uc2UucHVzaCh7XG4gICAgICBvZmZzZXQ6IGxvY2F0aW9uLnN0YXJ0T2Zmc2V0LFxuICAgICAgc3RhcnRMaW5lOiBsb2NhdGlvbi5zdGFydExpbmUsXG4gICAgICBlbmRMaW5lOiBsb2NhdGlvbi5lbmRMaW5lLFxuICAgICAgcHJpbnRlZFxuICAgIH0pO1xuICB9LCBcImNoYXJkYXRhXCIpO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuZnVuY3Rpb24gcHJpbnRFbGVtZW50RnJhZ21lbnRzKHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICBsZXQgcmVzcG9uc2UgPSBbXTtcblxuICByZXNwb25zZSA9IHJlc3BvbnNlLmNvbmNhdChwYXRoLm1hcChwcmludElUb2tlbiwgXCJDb21tZW50XCIpKTtcblxuICBpZiAoY2hpbGRyZW4uY2hhcmRhdGEubGVuZ3RoID4gMCkge1xuICAgIGlmIChcbiAgICAgIGNoaWxkcmVuLmNoYXJkYXRhLnNvbWUoKGNoYXJkYXRhKSA9PiAhIWNoYXJkYXRhLlRFWFQpICYmXG4gICAgICBvcHRzLnhtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSA9PT0gXCJwcmVzZXJ2ZVwiXG4gICAgKSB7XG4gICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmNvbmNhdChwcmludENoYXJEYXRhUHJlc2VydmUocGF0aCwgcHJpbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5jb25jYXQocHJpbnRDaGFyRGF0YUlnbm9yZShwYXRoLCBwcmludCkpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3BvbnNlID0gcmVzcG9uc2UuY29uY2F0KFxuICAgIHBhdGgubWFwKChlbGVtZW50UGF0aCkgPT4ge1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBlbGVtZW50UGF0aC5nZXRWYWx1ZSgpLmxvY2F0aW9uO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IGxvY2F0aW9uLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBzdGFydExpbmU6IGxvY2F0aW9uLnN0YXJ0TGluZSxcbiAgICAgICAgZW5kTGluZTogbG9jYXRpb24uZW5kTGluZSxcbiAgICAgICAgcHJpbnRlZDogcHJpbnQoZWxlbWVudFBhdGgpXG4gICAgICB9O1xuICAgIH0sIFwiZWxlbWVudFwiKVxuICApO1xuXG4gIHJlc3BvbnNlID0gcmVzcG9uc2UuY29uY2F0KHBhdGgubWFwKHByaW50SVRva2VuLCBcIlBST0NFU1NJTkdfSU5TVFJVQ1RJT05cIikpO1xuXG4gIHJlc3BvbnNlID0gcmVzcG9uc2UuY29uY2F0KFxuICAgIHBhdGgubWFwKChyZWZlcmVuY2VQYXRoKSA9PiB7XG4gICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gcmVmZXJlbmNlUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInJlZmVyZW5jZVwiLFxuICAgICAgICBvZmZzZXQ6IHJlZmVyZW5jZU5vZGUubG9jYXRpb24uc3RhcnRPZmZzZXQsXG4gICAgICAgIHN0YXJ0TGluZTogcmVmZXJlbmNlTm9kZS5sb2NhdGlvbi5zdGFydExpbmUsXG4gICAgICAgIGVuZExpbmU6IHJlZmVyZW5jZU5vZGUubG9jYXRpb24uZW5kTGluZSxcbiAgICAgICAgcHJpbnRlZDogcHJpbnQocmVmZXJlbmNlUGF0aClcbiAgICAgIH07XG4gICAgfSwgXCJyZWZlcmVuY2VcIilcbiAgKTtcblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIHByaW50RWxlbWVudChwYXRoLCBvcHRzLCBwcmludCkge1xuICBjb25zdCB7XG4gICAgT1BFTixcbiAgICBOYW1lLFxuICAgIGF0dHJpYnV0ZSxcbiAgICBTVEFSVF9DTE9TRSxcbiAgICBjb250ZW50LFxuICAgIFNMQVNIX09QRU4sXG4gICAgRU5EX05BTUUsXG4gICAgRU5ELFxuICAgIFNMQVNIX0NMT1NFXG4gIH0gPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgY29uc3QgcGFydHMgPSBbT1BFTiwgTmFtZV07XG5cbiAgaWYgKGF0dHJpYnV0ZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHBhdGgubWFwKFxuICAgICAgKGF0dHJpYnV0ZVBhdGgpID0+ICh7XG4gICAgICAgIG5vZGU6IGF0dHJpYnV0ZVBhdGguZ2V0VmFsdWUoKSxcbiAgICAgICAgcHJpbnRlZDogcHJpbnQoYXR0cmlidXRlUGF0aClcbiAgICAgIH0pLFxuICAgICAgXCJhdHRyaWJ1dGVcIlxuICAgICk7XG5cbiAgICBpZiAob3B0cy54bWxTb3J0QXR0cmlidXRlc0J5S2V5KSB7XG4gICAgICBhdHRyaWJ1dGVzLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxlZnRBdHRyID0gbGVmdC5ub2RlLk5hbWU7XG4gICAgICAgIGNvbnN0IHJpZ2h0QXR0ciA9IHJpZ2h0Lm5vZGUuTmFtZTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXR0cmlidXRlcyBhcmUgeG1sbnMuXG4gICAgICAgIGlmIChsZWZ0QXR0ciA9PT0gXCJ4bWxuc1wiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChyaWdodEF0dHIgPT09IFwieG1sbnNcIikgcmV0dXJuIDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgYm90aCBpbiBuYW1lc3BhY2VzLlxuICAgICAgICBpZiAobGVmdEF0dHIuaW5jbHVkZXMoXCI6XCIpICYmIHJpZ2h0QXR0ci5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgICAgICBjb25zdCBbbGVmdE5TLCBsZWZ0S2V5XSA9IGxlZnRBdHRyLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICBjb25zdCBbcmlnaHROUywgcmlnaHRLZXldID0gcmlnaHRBdHRyLnNwbGl0KFwiOlwiKTtcblxuICAgICAgICAgIC8vIElmIG5hbWVzcGFjZXMgYXJlIGVxdWFsLCBjb21wYXJlIGtleXNcbiAgICAgICAgICBpZiAobGVmdE5TID09PSByaWdodE5TKSByZXR1cm4gbGVmdEtleS5sb2NhbGVDb21wYXJlKHJpZ2h0S2V5KTtcblxuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgMSBidXQgbm90IGJvdGggYmVpbmcgYW4geG1sbnNcbiAgICAgICAgICBpZiAobGVmdE5TID09PSBcInhtbG5zXCIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAocmlnaHROUyA9PT0gXCJ4bWxuc1wiKSByZXR1cm4gMTtcblxuICAgICAgICAgIHJldHVybiBsZWZ0TlMubG9jYWxlQ29tcGFyZShyaWdodE5TKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhdHRyaWJ1dGVzIGhhdmUgbmFtZXNwYWNlcy5cbiAgICAgICAgaWYgKGxlZnRBdHRyLmluY2x1ZGVzKFwiOlwiKSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAocmlnaHRBdHRyLmluY2x1ZGVzKFwiOlwiKSkgcmV0dXJuIDE7XG5cbiAgICAgICAgcmV0dXJuIGxlZnRBdHRyLmxvY2FsZUNvbXBhcmUocmlnaHRBdHRyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdHMuc2luZ2xlQXR0cmlidXRlUGVyTGluZSA/IGhhcmRsaW5lIDogbGluZTtcbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgaW5kZW50KFtcbiAgICAgICAgbGluZSxcbiAgICAgICAgam9pbihcbiAgICAgICAgICBzZXBhcmF0b3IsXG4gICAgICAgICAgYXR0cmlidXRlcy5tYXAoKHsgcHJpbnRlZCB9KSA9PiBwcmludGVkKVxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlIHRoYXQgd2lsbCBnbyBiZXR3ZWVuIHRoZSA8LCBuYW1lLCBhbmQgYXR0cmlidXRlc1xuICAvLyBvZiBhbiBlbGVtZW50IGFuZCB0aGUgLz4gb2YgYW4gZWxlbWVudC5cbiAgbGV0IHNwYWNlO1xuICBpZiAob3B0cy5icmFja2V0U2FtZUxpbmUpIHtcbiAgICBzcGFjZSA9IG9wdHMueG1sU2VsZkNsb3NpbmdTcGFjZSA/IFwiIFwiIDogXCJcIjtcbiAgfSBlbHNlIHtcbiAgICBzcGFjZSA9IG9wdHMueG1sU2VsZkNsb3NpbmdTcGFjZSA/IGxpbmUgOiBzb2Z0bGluZTtcbiAgfVxuXG4gIGlmIChTTEFTSF9DTE9TRSkge1xuICAgIHJldHVybiBncm91cChbLi4ucGFydHMsIHNwYWNlLCBTTEFTSF9DTE9TRV0pO1xuICB9XG5cbiAgaWYgKFxuICAgIGNvbnRlbnQuY2hhcmRhdGEubGVuZ3RoID09PSAwICYmXG4gICAgY29udGVudC5DRGF0YS5sZW5ndGggPT09IDAgJiZcbiAgICBjb250ZW50LkNvbW1lbnQubGVuZ3RoID09PSAwICYmXG4gICAgY29udGVudC5lbGVtZW50Lmxlbmd0aCA9PT0gMCAmJlxuICAgIGNvbnRlbnQuUFJPQ0VTU0lOR19JTlNUUlVDVElPTi5sZW5ndGggPT09IDAgJiZcbiAgICBjb250ZW50LnJlZmVyZW5jZS5sZW5ndGggPT09IDBcbiAgKSB7XG4gICAgcmV0dXJuIGdyb3VwKFsuLi5wYXJ0cywgc3BhY2UsIFwiLz5cIl0pO1xuICB9XG5cbiAgY29uc3Qgb3BlblRhZyA9IGdyb3VwKFtcbiAgICAuLi5wYXJ0cyxcbiAgICBvcHRzLmJyYWNrZXRTYW1lTGluZSA/IFwiXCIgOiBzb2Z0bGluZSxcbiAgICBTVEFSVF9DTE9TRVxuICBdKTtcblxuICBjb25zdCBjbG9zZVRhZyA9IGdyb3VwKFtTTEFTSF9PUEVOLCBFTkRfTkFNRSwgRU5EXSk7XG5cbiAgaWYgKGlzV2hpdGVzcGFjZUlnbm9yYWJsZShvcHRzLCBOYW1lLCBhdHRyaWJ1dGUsIGNvbnRlbnQpKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gcGF0aC5jYWxsKFxuICAgICAgKGNoaWxkcmVuUGF0aCkgPT4gcHJpbnRFbGVtZW50RnJhZ21lbnRzKGNoaWxkcmVuUGF0aCwgb3B0cywgcHJpbnQpLFxuICAgICAgXCJjb250ZW50XCJcbiAgICApO1xuXG4gICAgZnJhZ21lbnRzLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0Lm9mZnNldCAtIHJpZ2h0Lm9mZnNldCk7XG5cbiAgICBpZiAoXG4gICAgICBvcHRzLnhtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSA9PT0gXCJwcmVzZXJ2ZVwiICYmXG4gICAgICBmcmFnbWVudHMuc29tZSgoeyB3aGl0ZXNwYWNlIH0pID0+IHdoaXRlc3BhY2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZ3JvdXAoW1xuICAgICAgICBvcGVuVGFnLFxuICAgICAgICBmcmFnbWVudHMubWFwKCh7IHByaW50ZWQgfSkgPT4gcHJpbnRlZCksXG4gICAgICAgIGNsb3NlVGFnXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwKFsuLi5wYXJ0cywgc3BhY2UsIFwiLz5cIl0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IGNvbnRlbnQgb2YgdGhpcyB0YWcgaXMgY2hhcmRhdGEsIHRoZW4gdXNlIGEgc29mdGxpbmUgc29cbiAgICAvLyB0aGF0IHdlIHdvbid0IG5lY2Vzc2FyaWx5IGJyZWFrICh0byBhbGxvdyA8Zm9vPmJhcjwvZm9vPikuXG4gICAgaWYgKFxuICAgICAgZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgY29udGVudC5jaGFyZGF0YS5maWx0ZXIoKGNoYXJkYXRhKSA9PiBjaGFyZGF0YS5URVhUKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIHJldHVybiBncm91cChbXG4gICAgICAgIG9wZW5UYWcsXG4gICAgICAgIGluZGVudChbc29mdGxpbmUsIGZyYWdtZW50c1swXS5wcmludGVkXSksXG4gICAgICAgIHNvZnRsaW5lLFxuICAgICAgICBjbG9zZVRhZ1xuICAgICAgXSk7XG4gICAgfVxuXG4gICAgbGV0IGRlbGltaXRlciA9IGhhcmRsaW5lO1xuXG4gICAgLy8gSWYgdGhlIG9ubHkgY29udGVudCBpcyBib3RoIGNoYXJkYXRhIGFuZCByZWZlcmVuY2VzLCB0aGVuIHVzZSBhIHNvZnRsaW5lXG4gICAgLy8gc28gdGhhdCB3ZSB3b24ndCBuZWNlc3NhcmlseSBicmVhay5cbiAgICBpZiAoXG4gICAgICBmcmFnbWVudHMubGVuZ3RoID09PVxuICAgICAgY29udGVudC5jaGFyZGF0YS5maWx0ZXIoKGNoYXJkYXRhKSA9PiBjaGFyZGF0YS5URVhUKS5sZW5ndGggK1xuICAgICAgICBjb250ZW50LnJlZmVyZW5jZS5sZW5ndGhcbiAgICApIHtcbiAgICAgIGRlbGltaXRlciA9IFwiIFwiO1xuICAgIH1cblxuICAgIGNvbnN0IGRvY3MgPSBbaGFyZGxpbmVdO1xuICAgIGxldCBsYXN0TGluZSA9IGZyYWdtZW50c1swXS5zdGFydExpbmU7XG5cbiAgICBmcmFnbWVudHMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICBpZiAobm9kZS5zdGFydExpbmUgLSBsYXN0TGluZSA+PSAyKSB7XG4gICAgICAgICAgZG9jcy5wdXNoKGhhcmRsaW5lLCBoYXJkbGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jcy5wdXNoKGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZG9jcy5wdXNoKG5vZGUucHJpbnRlZCk7XG4gICAgICBsYXN0TGluZSA9IG5vZGUuZW5kTGluZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBncm91cChbb3BlblRhZywgaW5kZW50KGRvY3MpLCBoYXJkbGluZSwgY2xvc2VUYWddKTtcbiAgfVxuXG4gIHJldHVybiBncm91cChbb3BlblRhZywgaW5kZW50KHBhdGguY2FsbChwcmludCwgXCJjb250ZW50XCIpKSwgY2xvc2VUYWddKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRFeHRlcm5hbElEKHBhdGgsIG9wdHMsIHByaW50KSB7XG4gIGNvbnN0IHsgUHVibGljLCBQdWJJRExpdGVyYWwsIFN5c3RlbSwgU3lzdGVtTGl0ZXJhbCB9ID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gIGlmIChTeXN0ZW0pIHtcbiAgICByZXR1cm4gZ3JvdXAoW1N5c3RlbSwgaW5kZW50KFtsaW5lLCBTeXN0ZW1MaXRlcmFsXSldKTtcbiAgfVxuXG4gIHJldHVybiBncm91cChbXG4gICAgZ3JvdXAoW1B1YmxpYywgaW5kZW50KFtsaW5lLCBQdWJJRExpdGVyYWxdKV0pLFxuICAgIGluZGVudChbbGluZSwgU3lzdGVtTGl0ZXJhbF0pXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBwcmludE1pc2MocGF0aCwgb3B0cywgcHJpbnQpIHtcbiAgY29uc3QgeyBDb21tZW50LCBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OLCBTRUFfV1MgfSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICByZXR1cm4gQ29tbWVudCB8fCBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OIHx8IFNFQV9XUztcbn1cblxuZnVuY3Rpb24gcHJpbnRQcm9sb2cocGF0aCwgb3B0cywgcHJpbnQpIHtcbiAgY29uc3QgeyBYTUxEZWNsT3BlbiwgYXR0cmlidXRlLCBTUEVDSUFMX0NMT1NFIH0gPSBwYXRoLmdldFZhbHVlKCk7XG4gIGNvbnN0IHBhcnRzID0gW1hNTERlY2xPcGVuXTtcblxuICBpZiAoYXR0cmlidXRlKSB7XG4gICAgcGFydHMucHVzaChpbmRlbnQoW3NvZnRsaW5lLCBqb2luKGxpbmUsIHBhdGgubWFwKHByaW50LCBcImF0dHJpYnV0ZVwiKSldKSk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXAoW1xuICAgIC4uLnBhcnRzLFxuICAgIG9wdHMueG1sU2VsZkNsb3NpbmdTcGFjZSA/IGxpbmUgOiBzb2Z0bGluZSxcbiAgICBTUEVDSUFMX0NMT1NFXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBwcmludFJlZmVyZW5jZShwYXRoLCBvcHRzLCBwcmludCkge1xuICBjb25zdCB7IENoYXJSZWYsIEVudGl0eVJlZiB9ID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gIHJldHVybiBDaGFyUmVmIHx8IEVudGl0eVJlZjtcbn1cblxuY29uc3QgcHJpbnRlciA9IHtcbiAgZ2V0VmlzaXRvcktleXMobm9kZSwgbm9uVHJhdmVyc2FibGVLZXlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUpLmZpbHRlcihcbiAgICAgIChrZXkpID0+IGtleSAhPT0gXCJsb2NhdGlvblwiICYmIGtleSAhPT0gXCJ0b2tlblR5cGVcIlxuICAgICk7XG4gIH0sXG4gIGVtYmVkLFxuICBwcmludChwYXRoLCBvcHRzLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZVwiOlxuICAgICAgICByZXR1cm4gcHJpbnRBdHRyaWJ1dGUocGF0aCwgb3B0cywgcHJpbnQpO1xuICAgICAgY2FzZSBcImNoYXJkYXRhXCI6XG4gICAgICAgIHJldHVybiBwcmludENoYXJEYXRhKHBhdGgsIG9wdHMsIHByaW50KTtcbiAgICAgIGNhc2UgXCJjb250ZW50XCI6XG4gICAgICAgIHJldHVybiBwcmludENvbnRlbnQocGF0aCwgb3B0cywgcHJpbnQpO1xuICAgICAgY2FzZSBcImRvY1R5cGVEZWNsXCI6XG4gICAgICAgIHJldHVybiBwcmludERvY1R5cGVEZWNsKHBhdGgsIG9wdHMsIHByaW50KTtcbiAgICAgIGNhc2UgXCJkb2N1bWVudFwiOlxuICAgICAgICByZXR1cm4gcHJpbnREb2N1bWVudChwYXRoLCBvcHRzLCBwcmludCk7XG4gICAgICBjYXNlIFwiZWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gcHJpbnRFbGVtZW50KHBhdGgsIG9wdHMsIHByaW50KTtcbiAgICAgIGNhc2UgXCJleHRlcm5hbElEXCI6XG4gICAgICAgIHJldHVybiBwcmludEV4dGVybmFsSUQocGF0aCwgb3B0cywgcHJpbnQpO1xuICAgICAgY2FzZSBcIm1pc2NcIjpcbiAgICAgICAgcmV0dXJuIHByaW50TWlzYyhwYXRoLCBvcHRzLCBwcmludCk7XG4gICAgICBjYXNlIFwicHJvbG9nXCI6XG4gICAgICAgIHJldHVybiBwcmludFByb2xvZyhwYXRoLCBvcHRzLCBwcmludCk7XG4gICAgICBjYXNlIFwicmVmZXJlbmNlXCI6XG4gICAgICAgIHJldHVybiBwcmludFJlZmVyZW5jZShwYXRoLCBvcHRzLCBwcmludCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke25vZGUubmFtZX1gKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByaW50ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@prettier/plugin-xml/src/printer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/api.js":
/*!***************************************************!*\
  !*** ./node_modules/@xml-tools/parser/lib/api.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const { xmlLexer } = __webpack_require__(/*! ./lexer */ \"(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/lexer.js\");\nconst { xmlParser } = __webpack_require__(/*! ./parser */ \"(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/parser.js\");\n\nmodule.exports = {\n  parse: function parse(text) {\n    const lexResult = xmlLexer.tokenize(text);\n    // setting a new input will RESET the parser instance's state.\n    xmlParser.input = lexResult.tokens;\n    // any top level rule may be used as an entry point\n    const cst = xmlParser.document();\n\n    return {\n      cst: cst,\n      tokenVector: lexResult.tokens,\n      lexErrors: lexResult.errors,\n      parseErrors: xmlParser.errors,\n    };\n  },\n\n  BaseXmlCstVisitor: xmlParser.getBaseCstVisitorConstructor(),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeG1sLXRvb2xzL3BhcnNlci9saWIvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsa0ZBQVM7QUFDdEMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxvRkFBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQHhtbC10b29sc1xccGFyc2VyXFxsaWJcXGFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHhtbExleGVyIH0gPSByZXF1aXJlKFwiLi9sZXhlclwiKTtcbmNvbnN0IHsgeG1sUGFyc2VyIH0gPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodGV4dCkge1xuICAgIGNvbnN0IGxleFJlc3VsdCA9IHhtbExleGVyLnRva2VuaXplKHRleHQpO1xuICAgIC8vIHNldHRpbmcgYSBuZXcgaW5wdXQgd2lsbCBSRVNFVCB0aGUgcGFyc2VyIGluc3RhbmNlJ3Mgc3RhdGUuXG4gICAgeG1sUGFyc2VyLmlucHV0ID0gbGV4UmVzdWx0LnRva2VucztcbiAgICAvLyBhbnkgdG9wIGxldmVsIHJ1bGUgbWF5IGJlIHVzZWQgYXMgYW4gZW50cnkgcG9pbnRcbiAgICBjb25zdCBjc3QgPSB4bWxQYXJzZXIuZG9jdW1lbnQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjc3Q6IGNzdCxcbiAgICAgIHRva2VuVmVjdG9yOiBsZXhSZXN1bHQudG9rZW5zLFxuICAgICAgbGV4RXJyb3JzOiBsZXhSZXN1bHQuZXJyb3JzLFxuICAgICAgcGFyc2VFcnJvcnM6IHhtbFBhcnNlci5lcnJvcnMsXG4gICAgfTtcbiAgfSxcblxuICBCYXNlWG1sQ3N0VmlzaXRvcjogeG1sUGFyc2VyLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/api.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/lexer.js":
/*!*****************************************************!*\
  !*** ./node_modules/@xml-tools/parser/lib/lexer.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const { createToken: createTokenOrg, Lexer } = __webpack_require__(/*! chevrotain */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/api.js\");\n\n// A little mini DSL for easier lexer definition.\nconst fragments = {};\nconst f = fragments;\n\nfunction FRAGMENT(name, def) {\n  fragments[name] = typeof def === \"string\" ? def : def.source;\n}\n\nfunction makePattern(strings, ...args) {\n  let combined = \"\";\n  for (let i = 0; i < strings.length; i++) {\n    combined += strings[i];\n    if (i < args.length) {\n      let pattern = args[i];\n      // By wrapping in a RegExp (none) capturing group\n      // We enabled the safe usage of qualifiers and assertions.\n      combined += `(?:${pattern})`;\n    }\n  }\n  return new RegExp(combined);\n}\n\nconst tokensArray = [];\nconst tokensDictionary = {};\n\nfunction createToken(options) {\n  const newTokenType = createTokenOrg(options);\n  tokensArray.push(newTokenType);\n  tokensDictionary[options.name] = newTokenType;\n  return newTokenType;\n}\n\nFRAGMENT(\n  \"NameStartChar\",\n  \"(:|[a-zA-Z]|_|\\\\u2070-\\\\u218F|\\\\u2C00-\\\\u2FEF|\\\\u3001-\\\\uD7FF|\\\\uF900-\\\\uFDCF|\\\\uFDF0-\\\\uFFFD)\"\n);\n\nFRAGMENT(\n  \"NameChar\",\n  makePattern`${f.NameStartChar}|-|\\\\.|\\\\d|\\\\u00B7||[\\\\u0300-\\\\u036F]|[\\\\u203F-\\\\u2040]`\n);\nFRAGMENT(\"Name\", makePattern`${f.NameStartChar}(${f.NameChar})*`);\n\nconst Comment = createToken({\n  name: \"Comment\",\n  pattern: /<!--(.|\\r?\\n)*?-->/,\n  // A Comment may span multiple lines.\n  line_breaks: true,\n});\n\nconst CData = createToken({\n  name: \"CData\",\n  pattern: /<!\\[CDATA\\[(.|\\r?\\n)*?]]>/,\n  line_breaks: true,\n});\n\nconst DocType = createToken({\n  name: \"DocType\",\n  pattern: /<!DOCTYPE/,\n  push_mode: \"INSIDE\",\n});\n\nconst IgnoredDTD = createToken({\n  name: \"DTD\",\n  pattern: /<!.*?>/,\n  group: Lexer.SKIPPED,\n});\n\nconst EntityRef = createToken({\n  name: \"EntityRef\",\n  pattern: makePattern`&${f.Name};`,\n});\n\nconst CharRef = createToken({\n  name: \"CharRef\",\n  pattern: /&#\\d+;|&#x[a-fA-F0-9]/,\n});\n\nconst SEA_WS = createToken({\n  name: \"SEA_WS\",\n  pattern: /( |\\t|\\n|\\r\\n)+/,\n});\n\nconst XMLDeclOpen = createToken({\n  name: \"XMLDeclOpen\",\n  pattern: /<\\?xml[ \\t\\r\\n]/,\n  push_mode: \"INSIDE\",\n});\n\nconst SLASH_OPEN = createToken({\n  name: \"SLASH_OPEN\",\n  pattern: /<\\//,\n  push_mode: \"INSIDE\",\n});\n\nconst INVALID_SLASH_OPEN = createToken({\n  name: \"INVALID_SLASH_OPEN\",\n  pattern: /<\\//,\n  categories: [SLASH_OPEN],\n});\n\nconst PROCESSING_INSTRUCTION = createToken({\n  name: \"PROCESSING_INSTRUCTION\",\n  pattern: makePattern`<\\\\?${f.Name}.*\\\\?>`,\n});\n\nconst OPEN = createToken({ name: \"OPEN\", pattern: /</, push_mode: \"INSIDE\" });\n// Meant to avoid skipping '<' token in a partial sequence of elements.\n// Example of the problem this solves:\n// <\n// <from>john</from>\n//  - The second '<' will be skipped because in the mode \"INSIDE\" '<' is not recognized.\n//  - This means the AST will include only a single element instead of two\nconst INVALID_OPEN_INSIDE = createToken({\n  name: \"INVALID_OPEN_INSIDE\",\n  pattern: /</,\n  categories: [OPEN],\n});\n\nconst TEXT = createToken({ name: \"TEXT\", pattern: /[^<&]+/ });\n\nconst CLOSE = createToken({ name: \"CLOSE\", pattern: />/, pop_mode: true });\n\nconst SPECIAL_CLOSE = createToken({\n  name: \"SPECIAL_CLOSE\",\n  pattern: /\\?>/,\n  pop_mode: true,\n});\n\nconst SLASH_CLOSE = createToken({\n  name: \"SLASH_CLOSE\",\n  pattern: /\\/>/,\n  pop_mode: true,\n});\n\nconst SLASH = createToken({ name: \"SLASH\", pattern: /\\// });\n\nconst STRING = createToken({\n  name: \"STRING\",\n  pattern: /\"[^<\"]*\"|'[^<']*'/,\n});\n\nconst EQUALS = createToken({ name: \"EQUALS\", pattern: /=/ });\n\nconst Name = createToken({ name: \"Name\", pattern: makePattern`${f.Name}` });\n\nconst S = createToken({\n  name: \"S\",\n  pattern: /[ \\t\\r\\n]/,\n  group: Lexer.SKIPPED,\n});\n\nconst xmlLexerDefinition = {\n  defaultMode: \"OUTSIDE\",\n\n  modes: {\n    OUTSIDE: [\n      Comment,\n      CData,\n      DocType,\n      IgnoredDTD,\n      EntityRef,\n      CharRef,\n      SEA_WS,\n      XMLDeclOpen,\n      SLASH_OPEN,\n      PROCESSING_INSTRUCTION,\n      OPEN,\n      TEXT,\n    ],\n    INSIDE: [\n      // Tokens from `OUTSIDE` to improve error recovery behavior\n      Comment,\n      INVALID_SLASH_OPEN,\n      INVALID_OPEN_INSIDE,\n      // \"Real\" `INSIDE` tokens\n      CLOSE,\n      SPECIAL_CLOSE,\n      SLASH_CLOSE,\n      SLASH,\n      EQUALS,\n      STRING,\n      Name,\n      S,\n    ],\n  },\n};\n\nconst xmlLexer = new Lexer(xmlLexerDefinition, {\n  // Reducing the amount of position tracking can provide a small performance boost (<10%)\n  // Likely best to keep the full info for better error position reporting and\n  // to expose \"fuller\" ITokens from the Lexer.\n  positionTracking: \"full\",\n  ensureOptimizations: false,\n\n  // TODO: inspect definitions for XML line terminators\n  lineTerminatorCharacters: [\"\\n\"],\n  lineTerminatorsPattern: /\\n|\\r\\n/g,\n});\n\nmodule.exports = {\n  xmlLexer,\n  tokensDictionary,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeG1sLXRvb2xzL3BhcnNlci9saWIvbGV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSxxQ0FBcUMsRUFBRSxtQkFBTyxDQUFDLG9GQUFZOztBQUVuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBLCtCQUErQixnQkFBZ0IsR0FBRyxXQUFXOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEMsQ0FBQzs7QUFFRCwyQkFBMkIsaURBQWlEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwyQkFBMkIsaUNBQWlDOztBQUU1RCw0QkFBNEIsNkNBQTZDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDRCQUE0Qiw4QkFBOEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsNkJBQTZCLDhCQUE4Qjs7QUFFM0QsMkJBQTJCLHFDQUFxQyxPQUFPLEdBQUc7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEB4bWwtdG9vbHNcXHBhcnNlclxcbGliXFxsZXhlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZVRva2VuOiBjcmVhdGVUb2tlbk9yZywgTGV4ZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuXG4vLyBBIGxpdHRsZSBtaW5pIERTTCBmb3IgZWFzaWVyIGxleGVyIGRlZmluaXRpb24uXG5jb25zdCBmcmFnbWVudHMgPSB7fTtcbmNvbnN0IGYgPSBmcmFnbWVudHM7XG5cbmZ1bmN0aW9uIEZSQUdNRU5UKG5hbWUsIGRlZikge1xuICBmcmFnbWVudHNbbmFtZV0gPSB0eXBlb2YgZGVmID09PSBcInN0cmluZ1wiID8gZGVmIDogZGVmLnNvdXJjZTtcbn1cblxuZnVuY3Rpb24gbWFrZVBhdHRlcm4oc3RyaW5ncywgLi4uYXJncykge1xuICBsZXQgY29tYmluZWQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb21iaW5lZCArPSBzdHJpbmdzW2ldO1xuICAgIGlmIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGxldCBwYXR0ZXJuID0gYXJnc1tpXTtcbiAgICAgIC8vIEJ5IHdyYXBwaW5nIGluIGEgUmVnRXhwIChub25lKSBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgIC8vIFdlIGVuYWJsZWQgdGhlIHNhZmUgdXNhZ2Ugb2YgcXVhbGlmaWVycyBhbmQgYXNzZXJ0aW9ucy5cbiAgICAgIGNvbWJpbmVkICs9IGAoPzoke3BhdHRlcm59KWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKGNvbWJpbmVkKTtcbn1cblxuY29uc3QgdG9rZW5zQXJyYXkgPSBbXTtcbmNvbnN0IHRva2Vuc0RpY3Rpb25hcnkgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlVG9rZW4ob3B0aW9ucykge1xuICBjb25zdCBuZXdUb2tlblR5cGUgPSBjcmVhdGVUb2tlbk9yZyhvcHRpb25zKTtcbiAgdG9rZW5zQXJyYXkucHVzaChuZXdUb2tlblR5cGUpO1xuICB0b2tlbnNEaWN0aW9uYXJ5W29wdGlvbnMubmFtZV0gPSBuZXdUb2tlblR5cGU7XG4gIHJldHVybiBuZXdUb2tlblR5cGU7XG59XG5cbkZSQUdNRU5UKFxuICBcIk5hbWVTdGFydENoYXJcIixcbiAgXCIoOnxbYS16QS1aXXxffFxcXFx1MjA3MC1cXFxcdTIxOEZ8XFxcXHUyQzAwLVxcXFx1MkZFRnxcXFxcdTMwMDEtXFxcXHVEN0ZGfFxcXFx1RjkwMC1cXFxcdUZEQ0Z8XFxcXHVGREYwLVxcXFx1RkZGRClcIlxuKTtcblxuRlJBR01FTlQoXG4gIFwiTmFtZUNoYXJcIixcbiAgbWFrZVBhdHRlcm5gJHtmLk5hbWVTdGFydENoYXJ9fC18XFxcXC58XFxcXGR8XFxcXHUwMEI3fHxbXFxcXHUwMzAwLVxcXFx1MDM2Rl18W1xcXFx1MjAzRi1cXFxcdTIwNDBdYFxuKTtcbkZSQUdNRU5UKFwiTmFtZVwiLCBtYWtlUGF0dGVybmAke2YuTmFtZVN0YXJ0Q2hhcn0oJHtmLk5hbWVDaGFyfSkqYCk7XG5cbmNvbnN0IENvbW1lbnQgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiQ29tbWVudFwiLFxuICBwYXR0ZXJuOiAvPCEtLSgufFxccj9cXG4pKj8tLT4vLFxuICAvLyBBIENvbW1lbnQgbWF5IHNwYW4gbXVsdGlwbGUgbGluZXMuXG4gIGxpbmVfYnJlYWtzOiB0cnVlLFxufSk7XG5cbmNvbnN0IENEYXRhID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkNEYXRhXCIsXG4gIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbKC58XFxyP1xcbikqP11dPi8sXG4gIGxpbmVfYnJlYWtzOiB0cnVlLFxufSk7XG5cbmNvbnN0IERvY1R5cGUgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiRG9jVHlwZVwiLFxuICBwYXR0ZXJuOiAvPCFET0NUWVBFLyxcbiAgcHVzaF9tb2RlOiBcIklOU0lERVwiLFxufSk7XG5cbmNvbnN0IElnbm9yZWREVEQgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiRFREXCIsXG4gIHBhdHRlcm46IC88IS4qPz4vLFxuICBncm91cDogTGV4ZXIuU0tJUFBFRCxcbn0pO1xuXG5jb25zdCBFbnRpdHlSZWYgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiRW50aXR5UmVmXCIsXG4gIHBhdHRlcm46IG1ha2VQYXR0ZXJuYCYke2YuTmFtZX07YCxcbn0pO1xuXG5jb25zdCBDaGFyUmVmID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkNoYXJSZWZcIixcbiAgcGF0dGVybjogLyYjXFxkKzt8JiN4W2EtZkEtRjAtOV0vLFxufSk7XG5cbmNvbnN0IFNFQV9XUyA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJTRUFfV1NcIixcbiAgcGF0dGVybjogLyggfFxcdHxcXG58XFxyXFxuKSsvLFxufSk7XG5cbmNvbnN0IFhNTERlY2xPcGVuID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlhNTERlY2xPcGVuXCIsXG4gIHBhdHRlcm46IC88XFw/eG1sWyBcXHRcXHJcXG5dLyxcbiAgcHVzaF9tb2RlOiBcIklOU0lERVwiLFxufSk7XG5cbmNvbnN0IFNMQVNIX09QRU4gPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiU0xBU0hfT1BFTlwiLFxuICBwYXR0ZXJuOiAvPFxcLy8sXG4gIHB1c2hfbW9kZTogXCJJTlNJREVcIixcbn0pO1xuXG5jb25zdCBJTlZBTElEX1NMQVNIX09QRU4gPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiSU5WQUxJRF9TTEFTSF9PUEVOXCIsXG4gIHBhdHRlcm46IC88XFwvLyxcbiAgY2F0ZWdvcmllczogW1NMQVNIX09QRU5dLFxufSk7XG5cbmNvbnN0IFBST0NFU1NJTkdfSU5TVFJVQ1RJT04gPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiUFJPQ0VTU0lOR19JTlNUUlVDVElPTlwiLFxuICBwYXR0ZXJuOiBtYWtlUGF0dGVybmA8XFxcXD8ke2YuTmFtZX0uKlxcXFw/PmAsXG59KTtcblxuY29uc3QgT1BFTiA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJPUEVOXCIsIHBhdHRlcm46IC88LywgcHVzaF9tb2RlOiBcIklOU0lERVwiIH0pO1xuLy8gTWVhbnQgdG8gYXZvaWQgc2tpcHBpbmcgJzwnIHRva2VuIGluIGEgcGFydGlhbCBzZXF1ZW5jZSBvZiBlbGVtZW50cy5cbi8vIEV4YW1wbGUgb2YgdGhlIHByb2JsZW0gdGhpcyBzb2x2ZXM6XG4vLyA8XG4vLyA8ZnJvbT5qb2huPC9mcm9tPlxuLy8gIC0gVGhlIHNlY29uZCAnPCcgd2lsbCBiZSBza2lwcGVkIGJlY2F1c2UgaW4gdGhlIG1vZGUgXCJJTlNJREVcIiAnPCcgaXMgbm90IHJlY29nbml6ZWQuXG4vLyAgLSBUaGlzIG1lYW5zIHRoZSBBU1Qgd2lsbCBpbmNsdWRlIG9ubHkgYSBzaW5nbGUgZWxlbWVudCBpbnN0ZWFkIG9mIHR3b1xuY29uc3QgSU5WQUxJRF9PUEVOX0lOU0lERSA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJJTlZBTElEX09QRU5fSU5TSURFXCIsXG4gIHBhdHRlcm46IC88LyxcbiAgY2F0ZWdvcmllczogW09QRU5dLFxufSk7XG5cbmNvbnN0IFRFWFQgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiVEVYVFwiLCBwYXR0ZXJuOiAvW148Jl0rLyB9KTtcblxuY29uc3QgQ0xPU0UgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiQ0xPU0VcIiwgcGF0dGVybjogLz4vLCBwb3BfbW9kZTogdHJ1ZSB9KTtcblxuY29uc3QgU1BFQ0lBTF9DTE9TRSA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJTUEVDSUFMX0NMT1NFXCIsXG4gIHBhdHRlcm46IC9cXD8+LyxcbiAgcG9wX21vZGU6IHRydWUsXG59KTtcblxuY29uc3QgU0xBU0hfQ0xPU0UgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiU0xBU0hfQ0xPU0VcIixcbiAgcGF0dGVybjogL1xcLz4vLFxuICBwb3BfbW9kZTogdHJ1ZSxcbn0pO1xuXG5jb25zdCBTTEFTSCA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJTTEFTSFwiLCBwYXR0ZXJuOiAvXFwvLyB9KTtcblxuY29uc3QgU1RSSU5HID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlNUUklOR1wiLFxuICBwYXR0ZXJuOiAvXCJbXjxcIl0qXCJ8J1tePCddKicvLFxufSk7XG5cbmNvbnN0IEVRVUFMUyA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJFUVVBTFNcIiwgcGF0dGVybjogLz0vIH0pO1xuXG5jb25zdCBOYW1lID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIk5hbWVcIiwgcGF0dGVybjogbWFrZVBhdHRlcm5gJHtmLk5hbWV9YCB9KTtcblxuY29uc3QgUyA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJTXCIsXG4gIHBhdHRlcm46IC9bIFxcdFxcclxcbl0vLFxuICBncm91cDogTGV4ZXIuU0tJUFBFRCxcbn0pO1xuXG5jb25zdCB4bWxMZXhlckRlZmluaXRpb24gPSB7XG4gIGRlZmF1bHRNb2RlOiBcIk9VVFNJREVcIixcblxuICBtb2Rlczoge1xuICAgIE9VVFNJREU6IFtcbiAgICAgIENvbW1lbnQsXG4gICAgICBDRGF0YSxcbiAgICAgIERvY1R5cGUsXG4gICAgICBJZ25vcmVkRFRELFxuICAgICAgRW50aXR5UmVmLFxuICAgICAgQ2hhclJlZixcbiAgICAgIFNFQV9XUyxcbiAgICAgIFhNTERlY2xPcGVuLFxuICAgICAgU0xBU0hfT1BFTixcbiAgICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT04sXG4gICAgICBPUEVOLFxuICAgICAgVEVYVCxcbiAgICBdLFxuICAgIElOU0lERTogW1xuICAgICAgLy8gVG9rZW5zIGZyb20gYE9VVFNJREVgIHRvIGltcHJvdmUgZXJyb3IgcmVjb3ZlcnkgYmVoYXZpb3JcbiAgICAgIENvbW1lbnQsXG4gICAgICBJTlZBTElEX1NMQVNIX09QRU4sXG4gICAgICBJTlZBTElEX09QRU5fSU5TSURFLFxuICAgICAgLy8gXCJSZWFsXCIgYElOU0lERWAgdG9rZW5zXG4gICAgICBDTE9TRSxcbiAgICAgIFNQRUNJQUxfQ0xPU0UsXG4gICAgICBTTEFTSF9DTE9TRSxcbiAgICAgIFNMQVNILFxuICAgICAgRVFVQUxTLFxuICAgICAgU1RSSU5HLFxuICAgICAgTmFtZSxcbiAgICAgIFMsXG4gICAgXSxcbiAgfSxcbn07XG5cbmNvbnN0IHhtbExleGVyID0gbmV3IExleGVyKHhtbExleGVyRGVmaW5pdGlvbiwge1xuICAvLyBSZWR1Y2luZyB0aGUgYW1vdW50IG9mIHBvc2l0aW9uIHRyYWNraW5nIGNhbiBwcm92aWRlIGEgc21hbGwgcGVyZm9ybWFuY2UgYm9vc3QgKDwxMCUpXG4gIC8vIExpa2VseSBiZXN0IHRvIGtlZXAgdGhlIGZ1bGwgaW5mbyBmb3IgYmV0dGVyIGVycm9yIHBvc2l0aW9uIHJlcG9ydGluZyBhbmRcbiAgLy8gdG8gZXhwb3NlIFwiZnVsbGVyXCIgSVRva2VucyBmcm9tIHRoZSBMZXhlci5cbiAgcG9zaXRpb25UcmFja2luZzogXCJmdWxsXCIsXG4gIGVuc3VyZU9wdGltaXphdGlvbnM6IGZhbHNlLFxuXG4gIC8vIFRPRE86IGluc3BlY3QgZGVmaW5pdGlvbnMgZm9yIFhNTCBsaW5lIHRlcm1pbmF0b3JzXG4gIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczogW1wiXFxuXCJdLFxuICBsaW5lVGVybWluYXRvcnNQYXR0ZXJuOiAvXFxufFxcclxcbi9nLFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB4bWxMZXhlcixcbiAgdG9rZW5zRGljdGlvbmFyeSxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/lexer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/parser.js":
/*!******************************************************!*\
  !*** ./node_modules/@xml-tools/parser/lib/parser.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const { CstParser, tokenMatcher } = __webpack_require__(/*! chevrotain */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/api.js\");\nconst { tokensDictionary: t } = __webpack_require__(/*! ./lexer */ \"(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/lexer.js\");\n\nclass Parser extends CstParser {\n  constructor() {\n    super(t, {\n      maxLookahead: 1,\n      recoveryEnabled: true,\n      nodeLocationTracking: \"full\",\n    });\n\n    this.deletionRecoveryEnabled = true;\n\n    const $ = this;\n\n    $.RULE(\"document\", () => {\n      $.OPTION(() => {\n        $.SUBRULE($.prolog);\n      });\n\n      $.MANY(() => {\n        $.SUBRULE($.misc);\n      });\n\n      $.OPTION2(() => {\n        $.SUBRULE($.docTypeDecl);\n      });\n\n      $.MANY2(() => {\n        $.SUBRULE2($.misc);\n      });\n\n      $.SUBRULE($.element);\n\n      $.MANY3(() => {\n        $.SUBRULE3($.misc);\n      });\n    });\n\n    $.RULE(\"prolog\", () => {\n      $.CONSUME(t.XMLDeclOpen);\n      $.MANY(() => {\n        $.SUBRULE($.attribute);\n      });\n      $.CONSUME(t.SPECIAL_CLOSE);\n    });\n\n    // https://www.w3.org/TR/xml/#NT-doctypedecl\n    $.RULE(\"docTypeDecl\", () => {\n      $.CONSUME(t.DocType);\n      $.CONSUME(t.Name);\n\n      $.OPTION(() => {\n        $.SUBRULE($.externalID);\n      });\n\n      // The internal subSet part is intentionally not implemented because we do not at this\n      // time wish to implement a full DTD Parser as part of this project...\n      // https://www.w3.org/TR/xml/#NT-intSubset\n\n      $.CONSUME(t.CLOSE);\n    });\n\n    $.RULE(\"externalID\", () => {\n      // Using gates to assert the value of the \"Name\" Identifiers.\n      // We could use Categories to model un-reserved keywords, however I am not sure\n      // The added complexity is needed at this time...\n      $.OR([\n        {\n          GATE: () => $.LA(1).image === \"SYSTEM\",\n          ALT: () => {\n            $.CONSUME2(t.Name, { LABEL: \"System\" });\n            $.CONSUME(t.STRING, { LABEL: \"SystemLiteral\" });\n          },\n        },\n        {\n          GATE: () => $.LA(1).image === \"PUBLIC\",\n          ALT: () => {\n            $.CONSUME3(t.Name, { LABEL: \"Public\" });\n            $.CONSUME2(t.STRING, { LABEL: \"PubIDLiteral\" });\n            $.CONSUME3(t.STRING, { LABEL: \"SystemLiteral\" });\n          },\n        },\n      ]);\n    });\n\n    $.RULE(\"content\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.element) },\n          { ALT: () => $.SUBRULE($.chardata) },\n          { ALT: () => $.SUBRULE($.reference) },\n          { ALT: () => $.CONSUME(t.CData) },\n          { ALT: () => $.CONSUME(t.PROCESSING_INSTRUCTION) },\n          { ALT: () => $.CONSUME(t.Comment) },\n        ]);\n      });\n    });\n\n    $.RULE(\"element\", () => {\n      $.CONSUME(t.OPEN);\n      try {\n        this.deletionRecoveryEnabled = false;\n        // disabling single token deletion here\n        // because `<\n        //            </note>`\n        // will be parsed as: `<note>`\n        // and the next element will be lost\n        $.CONSUME(t.Name);\n      } finally {\n        this.deletionRecoveryEnabled = true;\n      }\n      $.MANY(() => {\n        $.SUBRULE($.attribute);\n      });\n\n      $.OR([\n        {\n          ALT: () => {\n            $.CONSUME(t.CLOSE, { LABEL: \"START_CLOSE\" });\n            $.SUBRULE($.content);\n            $.CONSUME(t.SLASH_OPEN);\n            $.CONSUME2(t.Name, { LABEL: \"END_NAME\" });\n            $.CONSUME2(t.CLOSE, { LABEL: \"END\" });\n          },\n        },\n        {\n          ALT: () => {\n            $.CONSUME(t.SLASH_CLOSE);\n          },\n        },\n      ]);\n    });\n\n    $.RULE(\"reference\", () => {\n      $.OR([\n        { ALT: () => $.CONSUME(t.EntityRef) },\n        { ALT: () => $.CONSUME(t.CharRef) },\n      ]);\n    });\n\n    $.RULE(\"attribute\", () => {\n      $.CONSUME(t.Name);\n      try {\n        this.deletionRecoveryEnabled = false;\n        // disabling single token deletion here\n        // because `attrib1 attrib2=\"666`\n        // will be parsed as: `attrib1=\"666`\n        $.CONSUME(t.EQUALS);\n        // disabling single token deletion here\n        // to avoid new elementName being\n        $.CONSUME(t.STRING);\n      } finally {\n        this.deletionRecoveryEnabled = true;\n      }\n    });\n\n    $.RULE(\"chardata\", () => {\n      $.OR([\n        { ALT: () => $.CONSUME(t.TEXT) },\n        { ALT: () => $.CONSUME(t.SEA_WS) },\n      ]);\n    });\n\n    $.RULE(\"misc\", () => {\n      $.OR([\n        { ALT: () => $.CONSUME(t.Comment) },\n        { ALT: () => $.CONSUME(t.PROCESSING_INSTRUCTION) },\n        { ALT: () => $.CONSUME(t.SEA_WS) },\n      ]);\n    });\n\n    this.performSelfAnalysis();\n  }\n\n  canRecoverWithSingleTokenDeletion(expectedTokType) {\n    if (this.deletionRecoveryEnabled === false) {\n      return false;\n    }\n    return super.canRecoverWithSingleTokenDeletion(expectedTokType);\n  }\n\n  // TODO: provide this fix upstream to chevrotain\n  // https://github.com/SAP/chevrotain/issues/1055\n  /* istanbul ignore next - should be tested as part of Chevrotain */\n  findReSyncTokenType() {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1);\n    let k = 2;\n    /* eslint-disable-next-line no-constant-condition -- see above comment */\n    while (true) {\n      const foundMatch = allPossibleReSyncTokTypes.find((resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== undefined) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n}\n\n// Re-use the same parser instance\nconst xmlParser = new Parser();\n\nmodule.exports = {\n  xmlParser,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeG1sLXRvb2xzL3BhcnNlci9saWIvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBWTtBQUN4RCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsa0ZBQVM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsa0NBQWtDLHdCQUF3QjtBQUMxRCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsbUNBQW1DLHVCQUF1QjtBQUMxRCxtQ0FBbUMsd0JBQXdCO0FBQzNELFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksbUNBQW1DO0FBQy9DLFlBQVksK0JBQStCO0FBQzNDLFlBQVksZ0RBQWdEO0FBQzVELFlBQVksaUNBQWlDO0FBQzdDO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQsa0NBQWtDLGNBQWM7QUFDaEQsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0MsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAeG1sLXRvb2xzXFxwYXJzZXJcXGxpYlxccGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgQ3N0UGFyc2VyLCB0b2tlbk1hdGNoZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuY29uc3QgeyB0b2tlbnNEaWN0aW9uYXJ5OiB0IH0gPSByZXF1aXJlKFwiLi9sZXhlclwiKTtcblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgQ3N0UGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodCwge1xuICAgICAgbWF4TG9va2FoZWFkOiAxLFxuICAgICAgcmVjb3ZlcnlFbmFibGVkOiB0cnVlLFxuICAgICAgbm9kZUxvY2F0aW9uVHJhY2tpbmc6IFwiZnVsbFwiLFxuICAgIH0pO1xuXG4gICAgdGhpcy5kZWxldGlvblJlY292ZXJ5RW5hYmxlZCA9IHRydWU7XG5cbiAgICBjb25zdCAkID0gdGhpcztcblxuICAgICQuUlVMRShcImRvY3VtZW50XCIsICgpID0+IHtcbiAgICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFKCQucHJvbG9nKTtcbiAgICAgIH0pO1xuXG4gICAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5taXNjKTtcbiAgICAgIH0pO1xuXG4gICAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5kb2NUeXBlRGVjbCk7XG4gICAgICB9KTtcblxuICAgICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRTIoJC5taXNjKTtcbiAgICAgIH0pO1xuXG4gICAgICAkLlNVQlJVTEUoJC5lbGVtZW50KTtcblxuICAgICAgJC5NQU5ZMygoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRTMoJC5taXNjKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJC5SVUxFKFwicHJvbG9nXCIsICgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LlhNTERlY2xPcGVuKTtcbiAgICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRSgkLmF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICAgICQuQ09OU1VNRSh0LlNQRUNJQUxfQ0xPU0UpO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jTlQtZG9jdHlwZWRlY2xcbiAgICAkLlJVTEUoXCJkb2NUeXBlRGVjbFwiLCAoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb2NUeXBlKTtcbiAgICAgICQuQ09OU1VNRSh0Lk5hbWUpO1xuXG4gICAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRSgkLmV4dGVybmFsSUQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSBpbnRlcm5hbCBzdWJTZXQgcGFydCBpcyBpbnRlbnRpb25hbGx5IG5vdCBpbXBsZW1lbnRlZCBiZWNhdXNlIHdlIGRvIG5vdCBhdCB0aGlzXG4gICAgICAvLyB0aW1lIHdpc2ggdG8gaW1wbGVtZW50IGEgZnVsbCBEVEQgUGFyc2VyIGFzIHBhcnQgb2YgdGhpcyBwcm9qZWN0Li4uXG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1pbnRTdWJzZXRcblxuICAgICAgJC5DT05TVU1FKHQuQ0xPU0UpO1xuICAgIH0pO1xuXG4gICAgJC5SVUxFKFwiZXh0ZXJuYWxJRFwiLCAoKSA9PiB7XG4gICAgICAvLyBVc2luZyBnYXRlcyB0byBhc3NlcnQgdGhlIHZhbHVlIG9mIHRoZSBcIk5hbWVcIiBJZGVudGlmaWVycy5cbiAgICAgIC8vIFdlIGNvdWxkIHVzZSBDYXRlZ29yaWVzIHRvIG1vZGVsIHVuLXJlc2VydmVkIGtleXdvcmRzLCBob3dldmVyIEkgYW0gbm90IHN1cmVcbiAgICAgIC8vIFRoZSBhZGRlZCBjb21wbGV4aXR5IGlzIG5lZWRlZCBhdCB0aGlzIHRpbWUuLi5cbiAgICAgICQuT1IoW1xuICAgICAgICB7XG4gICAgICAgICAgR0FURTogKCkgPT4gJC5MQSgxKS5pbWFnZSA9PT0gXCJTWVNURU1cIixcbiAgICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAgICQuQ09OU1VNRTIodC5OYW1lLCB7IExBQkVMOiBcIlN5c3RlbVwiIH0pO1xuICAgICAgICAgICAgJC5DT05TVU1FKHQuU1RSSU5HLCB7IExBQkVMOiBcIlN5c3RlbUxpdGVyYWxcIiB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgR0FURTogKCkgPT4gJC5MQSgxKS5pbWFnZSA9PT0gXCJQVUJMSUNcIixcbiAgICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAgICQuQ09OU1VNRTModC5OYW1lLCB7IExBQkVMOiBcIlB1YmxpY1wiIH0pO1xuICAgICAgICAgICAgJC5DT05TVU1FMih0LlNUUklORywgeyBMQUJFTDogXCJQdWJJRExpdGVyYWxcIiB9KTtcbiAgICAgICAgICAgICQuQ09OU1VNRTModC5TVFJJTkcsIHsgTEFCRUw6IFwiU3lzdGVtTGl0ZXJhbFwiIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgICQuUlVMRShcImNvbnRlbnRcIiwgKCkgPT4ge1xuICAgICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICAgJC5PUihbXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmVsZW1lbnQpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNoYXJkYXRhKSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5yZWZlcmVuY2UpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkNEYXRhKSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OKSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Db21tZW50KSB9LFxuICAgICAgICBdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJC5SVUxFKFwiZWxlbWVudFwiLCAoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5PUEVOKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGVsZXRpb25SZWNvdmVyeUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gZGlzYWJsaW5nIHNpbmdsZSB0b2tlbiBkZWxldGlvbiBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgYDxcbiAgICAgICAgLy8gICAgICAgICAgICA8L25vdGU+YFxuICAgICAgICAvLyB3aWxsIGJlIHBhcnNlZCBhczogYDxub3RlPmBcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IGVsZW1lbnQgd2lsbCBiZSBsb3N0XG4gICAgICAgICQuQ09OU1VNRSh0Lk5hbWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kZWxldGlvblJlY292ZXJ5RW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5hdHRyaWJ1dGUpO1xuICAgICAgfSk7XG5cbiAgICAgICQuT1IoW1xuICAgICAgICB7XG4gICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAkLkNPTlNVTUUodC5DTE9TRSwgeyBMQUJFTDogXCJTVEFSVF9DTE9TRVwiIH0pO1xuICAgICAgICAgICAgJC5TVUJSVUxFKCQuY29udGVudCk7XG4gICAgICAgICAgICAkLkNPTlNVTUUodC5TTEFTSF9PUEVOKTtcbiAgICAgICAgICAgICQuQ09OU1VNRTIodC5OYW1lLCB7IExBQkVMOiBcIkVORF9OQU1FXCIgfSk7XG4gICAgICAgICAgICAkLkNPTlNVTUUyKHQuQ0xPU0UsIHsgTEFCRUw6IFwiRU5EXCIgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgJC5DT05TVU1FKHQuU0xBU0hfQ0xPU0UpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgICQuUlVMRShcInJlZmVyZW5jZVwiLCAoKSA9PiB7XG4gICAgICAkLk9SKFtcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkVudGl0eVJlZikgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkNoYXJSZWYpIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgICQuUlVMRShcImF0dHJpYnV0ZVwiLCAoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5OYW1lKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGVsZXRpb25SZWNvdmVyeUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gZGlzYWJsaW5nIHNpbmdsZSB0b2tlbiBkZWxldGlvbiBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgYGF0dHJpYjEgYXR0cmliMj1cIjY2NmBcbiAgICAgICAgLy8gd2lsbCBiZSBwYXJzZWQgYXM6IGBhdHRyaWIxPVwiNjY2YFxuICAgICAgICAkLkNPTlNVTUUodC5FUVVBTFMpO1xuICAgICAgICAvLyBkaXNhYmxpbmcgc2luZ2xlIHRva2VuIGRlbGV0aW9uIGhlcmVcbiAgICAgICAgLy8gdG8gYXZvaWQgbmV3IGVsZW1lbnROYW1lIGJlaW5nXG4gICAgICAgICQuQ09OU1VNRSh0LlNUUklORyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmRlbGV0aW9uUmVjb3ZlcnlFbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICQuUlVMRShcImNoYXJkYXRhXCIsICgpID0+IHtcbiAgICAgICQuT1IoW1xuICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVEVYVCkgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlNFQV9XUykgfSxcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgJC5SVUxFKFwibWlzY1wiLCAoKSA9PiB7XG4gICAgICAkLk9SKFtcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkNvbW1lbnQpIH0sXG4gICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OKSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU0VBX1dTKSB9LFxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXMoKTtcbiAgfVxuXG4gIGNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5kZWxldGlvblJlY292ZXJ5RW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpO1xuICB9XG5cbiAgLy8gVE9ETzogcHJvdmlkZSB0aGlzIGZpeCB1cHN0cmVhbSB0byBjaGV2cm90YWluXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9TQVAvY2hldnJvdGFpbi9pc3N1ZXMvMTA1NVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSB0ZXN0ZWQgYXMgcGFydCBvZiBDaGV2cm90YWluICovXG4gIGZpbmRSZVN5bmNUb2tlblR5cGUoKSB7XG4gICAgY29uc3QgYWxsUG9zc2libGVSZVN5bmNUb2tUeXBlcyA9IHRoaXMuZmxhdHRlbkZvbGxvd1NldCgpO1xuICAgIC8vIHRoaXMgbG9vcCB3aWxsIGFsd2F5cyB0ZXJtaW5hdGUgYXMgRU9GIGlzIGFsd2F5cyBpbiB0aGUgZm9sbG93IHN0YWNrIGFuZCBhbHNvIGFsd2F5cyAodmlydHVhbGx5KSBpbiB0aGUgaW5wdXRcbiAgICBsZXQgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICBsZXQgayA9IDI7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAtLSBzZWUgYWJvdmUgY29tbWVudCAqL1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmb3VuZE1hdGNoID0gYWxsUG9zc2libGVSZVN5bmNUb2tUeXBlcy5maW5kKChyZXN5bmNUb2tUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbk1hdGNoID0gdG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgcmVzeW5jVG9rVHlwZSk7XG4gICAgICAgIHJldHVybiBjYW5NYXRjaDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZvdW5kTWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZm91bmRNYXRjaDtcbiAgICAgIH1cbiAgICAgIG5leHRUb2tlbiA9IHRoaXMuTEEoayk7XG4gICAgICBrKys7XG4gICAgfVxuICB9XG59XG5cbi8vIFJlLXVzZSB0aGUgc2FtZSBwYXJzZXIgaW5zdGFuY2VcbmNvbnN0IHhtbFBhcnNlciA9IG5ldyBQYXJzZXIoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHhtbFBhcnNlcixcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@xml-tools/parser/lib/parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/api.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/api.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alternation: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Alternation),\n/* harmony export */   Alternative: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Alternative),\n/* harmony export */   CstParser: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.CstParser),\n/* harmony export */   EMPTY_ALT: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ALT),\n/* harmony export */   EOF: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.EOF),\n/* harmony export */   EarlyExitException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.EarlyExitException),\n/* harmony export */   EmbeddedActionsParser: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.EmbeddedActionsParser),\n/* harmony export */   GAstVisitor: () => (/* reexport safe */ _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__.GAstVisitor),\n/* harmony export */   Lexer: () => (/* reexport safe */ _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.Lexer),\n/* harmony export */   LexerDefinitionErrorType: () => (/* reexport safe */ _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.LexerDefinitionErrorType),\n/* harmony export */   MismatchedTokenException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.MismatchedTokenException),\n/* harmony export */   NoViableAltException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.NoViableAltException),\n/* harmony export */   NonTerminal: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.NonTerminal),\n/* harmony export */   NotAllInputParsedException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.NotAllInputParsedException),\n/* harmony export */   Option: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Option),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   ParserDefinitionErrorType: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType),\n/* harmony export */   Repetition: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Repetition),\n/* harmony export */   RepetitionMandatory: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionMandatory),\n/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionMandatoryWithSeparator),\n/* harmony export */   RepetitionWithSeparator: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionWithSeparator),\n/* harmony export */   Rule: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Rule),\n/* harmony export */   Terminal: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Terminal),\n/* harmony export */   VERSION: () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_0__.VERSION),\n/* harmony export */   assignOccurrenceIndices: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.assignOccurrenceIndices),\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   createSyntaxDiagramsCode: () => (/* reexport safe */ _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__.createSyntaxDiagramsCode),\n/* harmony export */   createToken: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.createToken),\n/* harmony export */   createTokenInstance: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.createTokenInstance),\n/* harmony export */   defaultGrammarResolverErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultGrammarResolverErrorProvider),\n/* harmony export */   defaultGrammarValidatorErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultGrammarValidatorErrorProvider),\n/* harmony export */   defaultLexerErrorProvider: () => (/* reexport safe */ _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__.defaultLexerErrorProvider),\n/* harmony export */   defaultParserErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultParserErrorProvider),\n/* harmony export */   generateParserFactory: () => (/* reexport safe */ _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__.generateParserFactory),\n/* harmony export */   generateParserModule: () => (/* reexport safe */ _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__.generateParserModule),\n/* harmony export */   isRecognitionException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.isRecognitionException),\n/* harmony export */   resolveGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.resolveGrammar),\n/* harmony export */   serializeGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.serializeGrammar),\n/* harmony export */   serializeProduction: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.serializeProduction),\n/* harmony export */   tokenLabel: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenLabel),\n/* harmony export */   tokenMatcher: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenMatcher),\n/* harmony export */   tokenName: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenName),\n/* harmony export */   validateGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.validateGrammar)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/version.js\");\n/* harmony import */ var _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse/parser/parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scan/lexer_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse/errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse/exceptions_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scan/lexer_errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\");\n/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parse/grammar/gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse/grammar/gast/gast_visitor_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\n/* harmony import */ var _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parse/grammar/gast/gast_resolver_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\");\n/* harmony import */ var _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diagrams/render_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js\");\n/* harmony import */ var _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./generate/generate_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate_public.js\");\n/* istanbul ignore file - tricky to import some things from this module during testing */\n// semantic version\n\n\n\n// Tokens utilities\n\n// Other Utilities\n\n\n\n// grammar reflection API\n\n// GAST Utilities\n\n\n\n/* istanbul ignore next */\nfunction clearCache() {\n    console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n        \"\\n\\t It performs no action other than printing this message.\" +\n        \"\\n\\t Please avoid using it as it will be completely removed in the future\");\n}\n\n\nvar Parser = /** @class */ (function () {\n    function Parser() {\n        throw new Error(\"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n            \"See: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_7-0-0\");\n    }\n    return Parser;\n}());\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNvQztBQUMyRTtBQUN6QztBQUN0RTtBQUNrSDtBQUNsSDtBQUM4STtBQUNxQjtBQUM1RjtBQUN2RTtBQUM2TTtBQUM3TTtBQUN5RjtBQUNsQjtBQUM4QztBQUNySDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDb0U7QUFDcUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNpQjtBQUNsQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xcYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlIC0gdHJpY2t5IHRvIGltcG9ydCBzb21lIHRoaW5ncyBmcm9tIHRoaXMgbW9kdWxlIGR1cmluZyB0ZXN0aW5nICovXG4vLyBzZW1hbnRpYyB2ZXJzaW9uXG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuZXhwb3J0IHsgQ3N0UGFyc2VyLCBFbWJlZGRlZEFjdGlvbnNQYXJzZXIsIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIEVNUFRZX0FMVCB9IGZyb20gXCIuL3BhcnNlL3BhcnNlci9wYXJzZXJcIjtcbmV4cG9ydCB7IExleGVyLCBMZXhlckRlZmluaXRpb25FcnJvclR5cGUgfSBmcm9tIFwiLi9zY2FuL2xleGVyX3B1YmxpY1wiO1xuLy8gVG9rZW5zIHV0aWxpdGllc1xuZXhwb3J0IHsgY3JlYXRlVG9rZW4sIGNyZWF0ZVRva2VuSW5zdGFuY2UsIEVPRiwgdG9rZW5MYWJlbCwgdG9rZW5NYXRjaGVyLCB0b2tlbk5hbWUgfSBmcm9tIFwiLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbi8vIE90aGVyIFV0aWxpdGllc1xuZXhwb3J0IHsgZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXIsIGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciwgZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi9wYXJzZS9lcnJvcnNfcHVibGljXCI7XG5leHBvcnQgeyBFYXJseUV4aXRFeGNlcHRpb24sIGlzUmVjb2duaXRpb25FeGNlcHRpb24sIE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiwgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24sIE5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4vcGFyc2UvZXhjZXB0aW9uc19wdWJsaWNcIjtcbmV4cG9ydCB7IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWNcIjtcbi8vIGdyYW1tYXIgcmVmbGVjdGlvbiBBUElcbmV4cG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLy8gR0FTVCBVdGlsaXRpZXNcbmV4cG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIsIHNlcmlhbGl6ZVByb2R1Y3Rpb24gfSBmcm9tIFwiLi9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmV4cG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCB7IGFzc2lnbk9jY3VycmVuY2VJbmRpY2VzLCByZXNvbHZlR3JhbW1hciwgdmFsaWRhdGVHcmFtbWFyIH0gZnJvbSBcIi4vcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljXCI7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGNsZWFyQ2FjaGUgZnVuY3Rpb24gd2FzICdzb2Z0JyByZW1vdmVkIGZyb20gdGhlIENoZXZyb3RhaW4gQVBJLlwiICtcbiAgICAgICAgXCJcXG5cXHQgSXQgcGVyZm9ybXMgbm8gYWN0aW9uIG90aGVyIHRoYW4gcHJpbnRpbmcgdGhpcyBtZXNzYWdlLlwiICtcbiAgICAgICAgXCJcXG5cXHQgUGxlYXNlIGF2b2lkIHVzaW5nIGl0IGFzIGl0IHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkIGluIHRoZSBmdXR1cmVcIik7XG59XG5leHBvcnQgeyBjcmVhdGVTeW50YXhEaWFncmFtc0NvZGUgfSBmcm9tIFwiLi9kaWFncmFtcy9yZW5kZXJfcHVibGljXCI7XG5leHBvcnQgeyBnZW5lcmF0ZVBhcnNlckZhY3RvcnksIGdlbmVyYXRlUGFyc2VyTW9kdWxlIH0gZnJvbSBcIi4vZ2VuZXJhdGUvZ2VuZXJhdGVfcHVibGljXCI7XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFBhcnNlciBjbGFzcyBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgQ3N0UGFyc2VyIG9yIEVtYmVkZGVkQWN0aW9uc1BhcnNlciBpbnN0ZWFkLlxcdFxcblwiICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI183LTAtMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5leHBvcnQgeyBQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/api.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js":
/*!***********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSyntaxDiagramsCode: () => (/* binding */ createSyntaxDiagramsCode)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/version.js\");\n\nfunction createSyntaxDiagramsCode(grammar, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? \"https://unpkg.com/chevrotain@\" + _version__WEBPACK_IMPORTED_MODULE_0__.VERSION + \"/diagrams/\" : _c, _d = _b.css, css = _d === void 0 ? \"https://unpkg.com/chevrotain@\" + _version__WEBPACK_IMPORTED_MODULE_0__.VERSION + \"/diagrams/diagrams.css\" : _d;\n    var header = \"\\n<!-- This is a generated file -->\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\";\n    var cssHtml = \"\\n<link rel='stylesheet' href='\" + css + \"'>\\n\";\n    var scripts = \"\\n<script src='\" + resourceBase + \"vendor/railroad-diagrams.js'></script>\\n<script src='\" + resourceBase + \"src/diagrams_builder.js'></script>\\n<script src='\" + resourceBase + \"src/diagrams_behavior.js'></script>\\n<script src='\" + resourceBase + \"src/main.js'></script>\\n\";\n    var diagramsDiv = \"\\n<div id=\\\"diagrams\\\" align=\\\"center\\\"></div>    \\n\";\n    var serializedGrammar = \"\\n<script>\\n    window.serializedGrammar = \" + JSON.stringify(grammar, null, \"  \") + \";\\n</script>\\n\";\n    var initLogic = \"\\n<script>\\n    var diagramsDiv = document.getElementById(\\\"diagrams\\\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n</script>\\n\";\n    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);\n}\n//# sourceMappingURL=render_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2RpYWdyYW1zL3JlbmRlcl9wdWJsaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDOUI7QUFDUCxnQ0FBZ0MsNkZBQTZGLDZDQUFPLDJGQUEyRiw2Q0FBTztBQUN0TyxtSEFBbUgsOENBQThDO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSCw2RkFBNkYsNkVBQTZFO0FBQzFLO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xcZGlhZ3JhbXNcXHJlbmRlcl9wdWJsaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuLi92ZXJzaW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlKGdyYW1tYXIsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IucmVzb3VyY2VCYXNlLCByZXNvdXJjZUJhc2UgPSBfYyA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiICsgVkVSU0lPTiArIFwiL2RpYWdyYW1zL1wiIDogX2MsIF9kID0gX2IuY3NzLCBjc3MgPSBfZCA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiICsgVkVSU0lPTiArIFwiL2RpYWdyYW1zL2RpYWdyYW1zLmNzc1wiIDogX2Q7XG4gICAgdmFyIGhlYWRlciA9IFwiXFxuPCEtLSBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUgLS0+XFxuPCFET0NUWVBFIGh0bWw+XFxuPG1ldGEgY2hhcnNldD1cXFwidXRmLThcXFwiPlxcbjxzdHlsZT5cXG4gIGJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMzAsIDIwJSwgOTUlKVxcbiAgfVxcbjwvc3R5bGU+XFxuXFxuXCI7XG4gICAgdmFyIGNzc0h0bWwgPSBcIlxcbjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXCIgKyBjc3MgKyBcIic+XFxuXCI7XG4gICAgdmFyIHNjcmlwdHMgPSBcIlxcbjxzY3JpcHQgc3JjPSdcIiArIHJlc291cmNlQmFzZSArIFwidmVuZG9yL3JhaWxyb2FkLWRpYWdyYW1zLmpzJz48L3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIgKyByZXNvdXJjZUJhc2UgKyBcInNyYy9kaWFncmFtc19idWlsZGVyLmpzJz48L3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIgKyByZXNvdXJjZUJhc2UgKyBcInNyYy9kaWFncmFtc19iZWhhdmlvci5qcyc+PC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiICsgcmVzb3VyY2VCYXNlICsgXCJzcmMvbWFpbi5qcyc+PC9zY3JpcHQ+XFxuXCI7XG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gXCJcXG48ZGl2IGlkPVxcXCJkaWFncmFtc1xcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+PC9kaXY+ICAgIFxcblwiO1xuICAgIHZhciBzZXJpYWxpemVkR3JhbW1hciA9IFwiXFxuPHNjcmlwdD5cXG4gICAgd2luZG93LnNlcmlhbGl6ZWRHcmFtbWFyID0gXCIgKyBKU09OLnN0cmluZ2lmeShncmFtbWFyLCBudWxsLCBcIiAgXCIpICsgXCI7XFxuPC9zY3JpcHQ+XFxuXCI7XG4gICAgdmFyIGluaXRMb2dpYyA9IFwiXFxuPHNjcmlwdD5cXG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcImRpYWdyYW1zXFxcIik7XFxuICAgIG1haW4uZHJhd0RpYWdyYW1zRnJvbVNlcmlhbGl6ZWRHcmFtbWFyKHNlcmlhbGl6ZWRHcmFtbWFyLCBkaWFncmFtc0Rpdik7XFxuPC9zY3JpcHQ+XFxuXCI7XG4gICAgcmV0dXJuIChoZWFkZXIgKyBjc3NIdG1sICsgc2NyaXB0cyArIGRpYWdyYW1zRGl2ICsgc2VyaWFsaXplZEdyYW1tYXIgKyBpbml0TG9naWMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyX3B1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/generate/generate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   genAllRules: () => (/* binding */ genAllRules),\n/* harmony export */   genAlternation: () => (/* binding */ genAlternation),\n/* harmony export */   genClass: () => (/* binding */ genClass),\n/* harmony export */   genNonTerminal: () => (/* binding */ genNonTerminal),\n/* harmony export */   genRule: () => (/* binding */ genRule),\n/* harmony export */   genSingleAlt: () => (/* binding */ genSingleAlt),\n/* harmony export */   genTerminal: () => (/* binding */ genTerminal),\n/* harmony export */   genUmdModule: () => (/* binding */ genUmdModule),\n/* harmony export */   genWrapperFunction: () => (/* binding */ genWrapperFunction)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parse/grammar/gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nfunction genUmdModule(options) {\n    return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nfunction genWrapperFunction(options) {\n    return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nfunction genClass(options) {\n    // TODO: how to pass the token vocabulary? Constructor? other?\n    var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n    return result;\n}\nfunction genAllRules(rules) {\n    var rulesText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(rules, function (currRule) {\n        return genRule(currRule, 1);\n    });\n    return rulesText.join(\"\\n\");\n}\nfunction genRule(prod, n) {\n    var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"})\") + NL;\n    return result;\n}\nfunction genTerminal(prod, n) {\n    var name = prod.terminalType.name;\n    // TODO: potential performance optimization, avoid tokenMap Dictionary access\n    return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nfunction genNonTerminal(prod, n) {\n    return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nfunction genAlternation(prod, n) {\n    var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n    var alts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });\n    result += alts.join(\",\" + NL);\n    result += NL + indent(n, \"])\" + NL);\n    return result;\n}\nfunction genSingleAlt(prod, n) {\n    var result = indent(n, \"{\") + NL;\n    result += indent(n + 1, \"ALT: function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"}\") + NL;\n    result += indent(n, \"}\");\n    return result;\n}\nfunction genProd(prod, n) {\n    /* istanbul ignore else */\n    if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {\n        return genNonTerminal(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {\n        return genDSLRule(\"OPTION\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {\n        return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {\n        return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {\n        return genDSLRule(\"MANY_SEP\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {\n        return genDSLRule(\"MANY\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {\n        return genAlternation(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {\n        return genTerminal(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternative) {\n        return genDefinition(prod.definition, n);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction genDSLRule(dslName, prod, n) {\n    var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n    if (prod.separator) {\n        result += \"{\" + NL;\n        result +=\n            indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) + \",\" + NL;\n        result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n        result += indent(n, \"}\") + NL;\n    }\n    else {\n        result += genDefFunction(prod.definition, n + 1);\n    }\n    result += indent(n, \")\") + NL;\n    return result;\n}\nfunction genDefFunction(definition, n) {\n    var def = \"function() {\" + NL;\n    def += genDefinition(definition, n);\n    def += indent(n, \"}\") + NL;\n    return def;\n}\nfunction genDefinition(def, n) {\n    var result = \"\";\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(def, function (prod) {\n        result += genProd(prod, n + 1);\n    });\n    return result;\n}\nfunction indent(howMuch, text) {\n    var spaces = Array(howMuch * 4 + 1).join(\" \");\n    return spaces + text;\n}\n//# sourceMappingURL=generate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2dlbmVyYXRlL2dlbmVyYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQzBKO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5Q0FBeUMsdURBQXVELDRGQUE0RixRQUFRLHdEQUF3RCxvTkFBb04sUUFBUSxNQUFNLDRGQUE0RixPQUFPLEdBQUcsbUVBQW1FLDZDQUE2QyxvREFBb0QsR0FBRyxHQUFHO0FBQzl1QjtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0RUFBNEUseWZBQXlmO0FBQ3JrQjtBQUNBO0FBQ087QUFDUCxvQkFBb0IsaURBQUc7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1Asc0VBQXNFO0FBQ3RFO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsaURBQUcsc0NBQXNDLHFDQUFxQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCO0FBQzdCLDhDQUE4QztBQUM5QztBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0VBQVc7QUFDbkM7QUFDQTtBQUNBLDZCQUE2QixtRUFBTTtBQUNuQztBQUNBO0FBQ0EsNkJBQTZCLGdGQUFtQjtBQUNoRDtBQUNBO0FBQ0EsNkJBQTZCLDZGQUFnQztBQUM3RDtBQUNBO0FBQ0EsNkJBQTZCLG9GQUF1QjtBQUNwRDtBQUNBO0FBQ0EsNkJBQTZCLHVFQUFVO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsd0VBQVc7QUFDeEM7QUFDQTtBQUNBLDZCQUE2QixxRUFBUTtBQUNyQztBQUNBO0FBQ0EsNkJBQTZCLHdFQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQU87QUFDWDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xcZ2VuZXJhdGVcXGdlbmVyYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvckVhY2gsIG1hcCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgUmVwZXRpdGlvbk1hbmRhdG9yeSwgT3B0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFRlcm1pbmFsLCBOb25UZXJtaW5hbCwgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBSZXBldGl0aW9uIH0gZnJvbSBcIi4uL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLyoqXG4gKiBNaXNzaW5nIGZlYXR1cmVzXG4gKiAxLiBSdWxlIGFyZ3VtZW50c1xuICogMi4gR2F0ZXNcbiAqIDMuIGVtYmVkZGVkIGFjdGlvbnNcbiAqL1xudmFyIE5MID0gXCJcXG5cIjtcbmV4cG9ydCBmdW5jdGlvbiBnZW5VbWRNb2R1bGUob3B0aW9ucykge1xuICAgIHJldHVybiBcIlxcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XFxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXFxuICAgICAgICBkZWZpbmUoWydjaGV2cm90YWluJ10sIGZhY3RvcnkpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcXG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2NoZXZyb3RhaW4nKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeShyb290LmIpO1xcbiAgICB9XFxufSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKGNoZXZyb3RhaW4pIHtcXG5cXG5cIiArIGdlbkNsYXNzKG9wdGlvbnMpICsgXCJcXG4gICAgXFxucmV0dXJuIHtcXG4gICAgXCIgKyBvcHRpb25zLm5hbWUgKyBcIjogXCIgKyBvcHRpb25zLm5hbWUgKyBcIiBcXG59XFxufSkpO1xcblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbldyYXBwZXJGdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIFwiICAgIFxcblwiICsgZ2VuQ2xhc3Mob3B0aW9ucykgKyBcIlxcbnJldHVybiBuZXcgXCIgKyBvcHRpb25zLm5hbWUgKyBcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykgICAgXFxuXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQ2xhc3Mob3B0aW9ucykge1xuICAgIC8vIFRPRE86IGhvdyB0byBwYXNzIHRoZSB0b2tlbiB2b2NhYnVsYXJ5PyBDb25zdHJ1Y3Rvcj8gb3RoZXI/XG4gICAgdmFyIHJlc3VsdCA9IFwiXFxuZnVuY3Rpb24gXCIgKyBvcHRpb25zLm5hbWUgKyBcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xcbiAgICAvLyBpbnZva2Ugc3VwZXIgY29uc3RydWN0b3JcXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgZW1iZWRkZWQgYWN0aW9ucyBjdXJyZW50bHksIHNvIHdlIGNhbiAnaGFyZGNvZGUnXFxuICAgIC8vIFRoZSB1c2Ugb2YgQ3N0UGFyc2VyLlxcbiAgICBjaGV2cm90YWluLkNzdFBhcnNlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKVxcblxcbiAgICBjb25zdCAkID0gdGhpc1xcblxcbiAgICBcIiArIGdlbkFsbFJ1bGVzKG9wdGlvbnMucnVsZXMpICsgXCJcXG5cXG4gICAgLy8gdmVyeSBpbXBvcnRhbnQgdG8gY2FsbCB0aGlzIGFmdGVyIGFsbCB0aGUgcnVsZXMgaGF2ZSBiZWVuIGRlZmluZWQuXFxuICAgIC8vIG90aGVyd2lzZSB0aGUgcGFyc2VyIG1heSBub3Qgd29yayBjb3JyZWN0bHkgYXMgaXQgd2lsbCBsYWNrIGluZm9ybWF0aW9uXFxuICAgIC8vIGRlcml2ZWQgZHVyaW5nIHRoZSBzZWxmIGFuYWx5c2lzIHBoYXNlLlxcbiAgICB0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXModGhpcylcXG59XFxuXFxuLy8gaW5oZXJpdGFuY2UgYXMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBpbiB0aGUgcHJldmlvdXMgZGVjYWRlLi4uIDooXFxuXCIgKyBvcHRpb25zLm5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNoZXZyb3RhaW4uQ3N0UGFyc2VyLnByb3RvdHlwZSlcXG5cIiArIG9wdGlvbnMubmFtZSArIFwiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFwiICsgb3B0aW9ucy5uYW1lICsgXCIgICAgXFxuICAgIFwiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQWxsUnVsZXMocnVsZXMpIHtcbiAgICB2YXIgcnVsZXNUZXh0ID0gbWFwKHJ1bGVzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIGdlblJ1bGUoY3VyclJ1bGUsIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiBydWxlc1RleHQuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5SdWxlKHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwiJC5SVUxFKFxcXCJcIiArIHByb2QubmFtZSArIFwiXFxcIiwgZnVuY3Rpb24oKSB7XCIpICsgTkw7XG4gICAgcmVzdWx0ICs9IGdlbkRlZmluaXRpb24ocHJvZC5kZWZpbml0aW9uLCBuICsgMSk7XG4gICAgcmVzdWx0ICs9IGluZGVudChuICsgMSwgXCJ9KVwiKSArIE5MO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuVGVybWluYWwocHJvZCwgbikge1xuICAgIHZhciBuYW1lID0gcHJvZC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICAvLyBUT0RPOiBwb3RlbnRpYWwgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBhdm9pZCB0b2tlbk1hcCBEaWN0aW9uYXJ5IGFjY2Vzc1xuICAgIHJldHVybiBpbmRlbnQobiwgXCIkLkNPTlNVTUVcIiArIHByb2QuaWR4ICsgXCIodGhpcy50b2tlbnNNYXAuXCIgKyBuYW1lICsgXCIpXCIgKyBOTCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuTm9uVGVybWluYWwocHJvZCwgbikge1xuICAgIHJldHVybiBpbmRlbnQobiwgXCIkLlNVQlJVTEVcIiArIHByb2QuaWR4ICsgXCIoJC5cIiArIHByb2Qubm9uVGVybWluYWxOYW1lICsgXCIpXCIgKyBOTCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQWx0ZXJuYXRpb24ocHJvZCwgbikge1xuICAgIHZhciByZXN1bHQgPSBpbmRlbnQobiwgXCIkLk9SXCIgKyBwcm9kLmlkeCArIFwiKFtcIikgKyBOTDtcbiAgICB2YXIgYWx0cyA9IG1hcChwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChhbHREZWYpIHsgcmV0dXJuIGdlblNpbmdsZUFsdChhbHREZWYsIG4gKyAxKTsgfSk7XG4gICAgcmVzdWx0ICs9IGFsdHMuam9pbihcIixcIiArIE5MKTtcbiAgICByZXN1bHQgKz0gTkwgKyBpbmRlbnQobiwgXCJdKVwiICsgTkwpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuU2luZ2xlQWx0KHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwie1wiKSArIE5MO1xuICAgIHJlc3VsdCArPSBpbmRlbnQobiArIDEsIFwiQUxUOiBmdW5jdGlvbigpIHtcIikgKyBOTDtcbiAgICByZXN1bHQgKz0gZ2VuRGVmaW5pdGlvbihwcm9kLmRlZmluaXRpb24sIG4gKyAxKTtcbiAgICByZXN1bHQgKz0gaW5kZW50KG4gKyAxLCBcIn1cIikgKyBOTDtcbiAgICByZXN1bHQgKz0gaW5kZW50KG4sIFwifVwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuUHJvZChwcm9kLCBuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBnZW5Ob25UZXJtaW5hbChwcm9kLCBuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk9QVElPTlwiLCBwcm9kLCBuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJBVF9MRUFTVF9PTkVcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIkFUX0xFQVNUX09ORV9TRVBcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk1BTllfU0VQXCIsIHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk1BTllcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuQWx0ZXJuYXRpb24ocHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZ2VuVGVybWluYWwocHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSkge1xuICAgICAgICByZXR1cm4gZ2VuRGVmaW5pdGlvbihwcm9kLmRlZmluaXRpb24sIG4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5EU0xSdWxlKGRzbE5hbWUsIHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwiJC5cIiArIChkc2xOYW1lICsgcHJvZC5pZHgpICsgXCIoXCIpO1xuICAgIGlmIChwcm9kLnNlcGFyYXRvcikge1xuICAgICAgICByZXN1bHQgKz0gXCJ7XCIgKyBOTDtcbiAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICBpbmRlbnQobiArIDEsIFwiU0VQOiB0aGlzLnRva2Vuc01hcC5cIiArIHByb2Quc2VwYXJhdG9yLm5hbWUpICsgXCIsXCIgKyBOTDtcbiAgICAgICAgcmVzdWx0ICs9IFwiREVGOiBcIiArIGdlbkRlZkZ1bmN0aW9uKHByb2QuZGVmaW5pdGlvbiwgbiArIDIpICsgTkw7XG4gICAgICAgIHJlc3VsdCArPSBpbmRlbnQobiwgXCJ9XCIpICsgTkw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gZ2VuRGVmRnVuY3Rpb24ocHJvZC5kZWZpbml0aW9uLCBuICsgMSk7XG4gICAgfVxuICAgIHJlc3VsdCArPSBpbmRlbnQobiwgXCIpXCIpICsgTkw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbkRlZkZ1bmN0aW9uKGRlZmluaXRpb24sIG4pIHtcbiAgICB2YXIgZGVmID0gXCJmdW5jdGlvbigpIHtcIiArIE5MO1xuICAgIGRlZiArPSBnZW5EZWZpbml0aW9uKGRlZmluaXRpb24sIG4pO1xuICAgIGRlZiArPSBpbmRlbnQobiwgXCJ9XCIpICsgTkw7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGdlbkRlZmluaXRpb24oZGVmLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yRWFjaChkZWYsIGZ1bmN0aW9uIChwcm9kKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZW5Qcm9kKHByb2QsIG4gKyAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW5kZW50KGhvd011Y2gsIHRleHQpIHtcbiAgICB2YXIgc3BhY2VzID0gQXJyYXkoaG93TXVjaCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gc3BhY2VzICsgdGV4dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate_public.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/generate/generate_public.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateParserFactory: () => (/* binding */ generateParserFactory),\n/* harmony export */   generateParserModule: () => (/* binding */ generateParserModule)\n/* harmony export */ });\n/* harmony import */ var _generate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generate */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate.js\");\n\nfunction generateParserFactory(options) {\n    var wrapperText = (0,_generate__WEBPACK_IMPORTED_MODULE_0__.genWrapperFunction)({\n        name: options.name,\n        rules: options.rules\n    });\n    var constructorWrapper = new Function(\"tokenVocabulary\", \"config\", \"chevrotain\", wrapperText);\n    return function (config) {\n        return constructorWrapper(options.tokenVocabulary, config, \n        // TODO: check how the require is transpiled/webpacked\n        __webpack_require__(/*! ../api */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/api.js\"));\n    };\n}\nfunction generateParserModule(options) {\n    return (0,_generate__WEBPACK_IMPORTED_MODULE_0__.genUmdModule)({ name: options.name, rules: options.rules });\n}\n//# sourceMappingURL=generate_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2dlbmVyYXRlL2dlbmVyYXRlX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDdkQ7QUFDUCxzQkFBc0IsNkRBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsZ0ZBQVE7QUFDeEI7QUFDQTtBQUNPO0FBQ1AsV0FBVyx1REFBWSxHQUFHLDBDQUEwQztBQUNwRTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxnZW5lcmF0ZVxcZ2VuZXJhdGVfcHVibGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdlblVtZE1vZHVsZSwgZ2VuV3JhcHBlckZ1bmN0aW9uIH0gZnJvbSBcIi4vZ2VuZXJhdGVcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhcnNlckZhY3Rvcnkob3B0aW9ucykge1xuICAgIHZhciB3cmFwcGVyVGV4dCA9IGdlbldyYXBwZXJGdW5jdGlvbih7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgcnVsZXM6IG9wdGlvbnMucnVsZXNcbiAgICB9KTtcbiAgICB2YXIgY29uc3RydWN0b3JXcmFwcGVyID0gbmV3IEZ1bmN0aW9uKFwidG9rZW5Wb2NhYnVsYXJ5XCIsIFwiY29uZmlnXCIsIFwiY2hldnJvdGFpblwiLCB3cmFwcGVyVGV4dCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yV3JhcHBlcihvcHRpb25zLnRva2VuVm9jYWJ1bGFyeSwgY29uZmlnLCBcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaG93IHRoZSByZXF1aXJlIGlzIHRyYW5zcGlsZWQvd2VicGFja2VkXG4gICAgICAgIHJlcXVpcmUoXCIuLi9hcGlcIikpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXJzZXJNb2R1bGUob3B0aW9ucykge1xuICAgIHJldHVybiBnZW5VbWRNb2R1bGUoeyBuYW1lOiBvcHRpb25zLm5hbWUsIHJ1bGVzOiBvcHRpb25zLnJ1bGVzIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVfcHVibGljLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/generate/generate_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classNameFromInstance: () => (/* binding */ classNameFromInstance),\n/* harmony export */   defineNameProp: () => (/* binding */ defineNameProp),\n/* harmony export */   functionName: () => (/* binding */ functionName)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\nfunction classNameFromInstance(instance) {\n    return functionName(instance.constructor);\n}\nvar NAME = \"name\";\n/**\n * Utility to obtain Function names.\n * Note that there should not be an assumptions on the result of this function.\n * E.g: When running from minified source code the result may be auto generated.\n */\nfunction functionName(func) {\n    // Engines that support Function.prototype.name OR the nth (n>1) time after\n    // the name has been computed in the following else block.\n    var existingNameProp = func.name;\n    /* istanbul ignore else - too many hacks for IE/old versions of node.js here*/\n    if (existingNameProp) {\n        return existingNameProp;\n    }\n    else {\n        return \"anonymous\";\n    }\n}\n/**\n * @returns {boolean} - has the property been successfully defined\n */\nfunction defineNameProp(obj, nameValue) {\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);\n    /* istanbul ignore else -> will only run in old versions of node.js */\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(namePropDescriptor) || namePropDescriptor.configurable) {\n        Object.defineProperty(obj, NAME, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: nameValue\n        });\n        return true;\n    }\n    /* istanbul ignore next -> will only run in old versions of node.js */\n    return false;\n}\n//# sourceMappingURL=lang_extensions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2xhbmcvbGFuZ19leHRlbnNpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLHlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxsYW5nXFxsYW5nX2V4dGVuc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25OYW1lKGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbn1cbnZhciBOQU1FID0gXCJuYW1lXCI7XG4vKipcbiAqIFV0aWxpdHkgdG8gb2J0YWluIEZ1bmN0aW9uIG5hbWVzLlxuICogTm90ZSB0aGF0IHRoZXJlIHNob3VsZCBub3QgYmUgYW4gYXNzdW1wdGlvbnMgb24gdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uLlxuICogRS5nOiBXaGVuIHJ1bm5pbmcgZnJvbSBtaW5pZmllZCBzb3VyY2UgY29kZSB0aGUgcmVzdWx0IG1heSBiZSBhdXRvIGdlbmVyYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmdW5jKSB7XG4gICAgLy8gRW5naW5lcyB0aGF0IHN1cHBvcnQgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgT1IgdGhlIG50aCAobj4xKSB0aW1lIGFmdGVyXG4gICAgLy8gdGhlIG5hbWUgaGFzIGJlZW4gY29tcHV0ZWQgaW4gdGhlIGZvbGxvd2luZyBlbHNlIGJsb2NrLlxuICAgIHZhciBleGlzdGluZ05hbWVQcm9wID0gZnVuYy5uYW1lO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gdG9vIG1hbnkgaGFja3MgZm9yIElFL29sZCB2ZXJzaW9ucyBvZiBub2RlLmpzIGhlcmUqL1xuICAgIGlmIChleGlzdGluZ05hbWVQcm9wKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ05hbWVQcm9wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBoYXMgdGhlIHByb3BlcnR5IGJlZW4gc3VjY2Vzc2Z1bGx5IGRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZU5hbWVQcm9wKG9iaiwgbmFtZVZhbHVlKSB7XG4gICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBOQU1FKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtPiB3aWxsIG9ubHkgcnVuIGluIG9sZCB2ZXJzaW9ucyBvZiBub2RlLmpzICovXG4gICAgaWYgKGlzVW5kZWZpbmVkKG5hbWVQcm9wRGVzY3JpcHRvcikgfHwgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBOQU1FLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtPiB3aWxsIG9ubHkgcnVuIGluIG9sZCB2ZXJzaW9ucyBvZiBub2RlLmpzICovXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ19leHRlbnNpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/constants.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IN: () => (/* binding */ IN)\n/* harmony export */ });\n// TODO: can this be removed? where is it used?\nvar IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxwYXJzZVxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IGNhbiB0aGlzIGJlIHJlbW92ZWQ/IHdoZXJlIGlzIGl0IHVzZWQ/XG5leHBvcnQgdmFyIElOID0gXCJffklOfl9cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/constants.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js":
/*!**************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNoneTerminalToCst: () => (/* binding */ addNoneTerminalToCst),\n/* harmony export */   addTerminalToCst: () => (/* binding */ addTerminalToCst),\n/* harmony export */   setNodeLocationFull: () => (/* binding */ setNodeLocationFull),\n/* harmony export */   setNodeLocationOnlyOffset: () => (/* binding */ setNodeLocationOnlyOffset)\n/* harmony export */ });\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nfunction addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2NzdC9jc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxjc3RcXGNzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbm9kZUxvY2F0aW9uIHRyYWNraW5nIGlzIG5vdCBlZmZpY2llbnQgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWRcbiAqIHdoZW4gZXJyb3IgcmVjb3ZlcnkgaXMgZW5hYmxlZCBvciB0aGUgVG9rZW4gVmVjdG9yIGNvbnRhaW5zIHZpcnR1YWwgVG9rZW5zXG4gKiAoZS5nLCBQeXRob24gSW5kZW50L091dGRlbnQpXG4gKiBBcyBpdCBleGVjdXRlcyB0aGUgY2FsY3VsYXRpb24gZm9yIGV2ZXJ5IHNpbmdsZSB0ZXJtaW5hbC9ub25UZXJtaW5hbFxuICogYW5kIGRvZXMgbm90IHJlbHkgb24gdGhlIGZhY3QgdGhlIHRva2VuIHZlY3RvciBpcyAqKnNvcnRlZCoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0KGN1cnJOb2RlTG9jYXRpb24sIG5ld0xvY2F0aW9uSW5mbykge1xuICAgIC8vIEZpcnN0ICh2YWxpZCkgdXBkYXRlIGZvciB0aGlzIGNzdCBub2RlXG4gICAgaWYgKGlzTmFOKGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGFzc3VtcHRpb24xOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBlaXRoZXIgTmFOIG9yIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIC8vIGFzc3VtcHRpb24yOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBmdWxseSB2YWxpZCBpZiBpdCBleGlzdFxuICAgICAgICAvLyAoYm90aCBzdGFydC9lbmQgb2Zmc2V0cyBleGlzdCBhbmQgYXJlIG51bWJlcnMpLlxuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgfVxuICAgIC8vIE9uY2UgdGhlIHN0YXJ0T2Zmc2V0IGhhcyBiZWVuIHVwZGF0ZWQgd2l0aCBhIHZhbGlkIG51bWJlciBpdCBzaG91bGQgbmV2ZXIgcmVjZWl2ZVxuICAgIC8vIGFueSBmYXJ0aGVyIHVwZGF0ZXMgYXMgdGhlIFRva2VuIHZlY3RvciBpcyBzb3J0ZWQuXG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSB0byBjaGVjayB0aGlzIHRoaXMgY29uZGl0aW9uIGZvciBldmVyeSBuZXcgcG9zc2libGUgbG9jYXRpb24gaW5mb1xuICAgIC8vIGJlY2F1c2Ugd2l0aCBlcnJvciByZWNvdmVyeSBlbmFibGVkIHdlIG1heSBlbmNvdW50ZXIgaW52YWxpZCB0b2tlbnMgKE5hTiBsb2NhdGlvbiBwcm9wcylcbiAgICBlbHNlIGlmIChjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA8IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBub2RlTG9jYXRpb24gdHJhY2tpbmcgaXMgbm90IGVmZmljaWVudCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogd2hlbiBlcnJvciByZWNvdmVyeSBpcyBlbmFibGVkIG9yIHRoZSBUb2tlbiBWZWN0b3IgY29udGFpbnMgdmlydHVhbCBUb2tlbnNcbiAqIChlLmcsIFB5dGhvbiBJbmRlbnQvT3V0ZGVudClcbiAqIEFzIGl0IGV4ZWN1dGVzIHRoZSBjYWxjdWxhdGlvbiBmb3IgZXZlcnkgc2luZ2xlIHRlcm1pbmFsL25vblRlcm1pbmFsXG4gKiBhbmQgZG9lcyBub3QgcmVseSBvbiB0aGUgZmFjdCB0aGUgdG9rZW4gdmVjdG9yIGlzICoqc29ydGVkKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5vZGVMb2NhdGlvbkZ1bGwoY3Vyck5vZGVMb2NhdGlvbiwgbmV3TG9jYXRpb25JbmZvKSB7XG4gICAgLy8gRmlyc3QgKHZhbGlkKSB1cGRhdGUgZm9yIHRoaXMgY3N0IG5vZGVcbiAgICBpZiAoaXNOYU4oY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXNzdW1wdGlvbjE6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGVpdGhlciBOYU4gb3IgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgLy8gYXNzdW1wdGlvbjI6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGZ1bGx5IHZhbGlkIGlmIGl0IGV4aXN0XG4gICAgICAgIC8vIChhbGwgc3RhcnQvZW5kIHByb3BzIGV4aXN0IGFuZCBhcmUgbnVtYmVycykuXG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRDb2x1bW47XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRMaW5lID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0TGluZTtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZENvbHVtbiA9IG5ld0xvY2F0aW9uSW5mby5lbmRDb2x1bW47XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kTGluZSA9IG5ld0xvY2F0aW9uSW5mby5lbmRMaW5lO1xuICAgIH1cbiAgICAvLyBPbmNlIHRoZSBzdGFydCBwcm9wcyBoYXMgYmVlbiB1cGRhdGVkIHdpdGggYSB2YWxpZCBudW1iZXIgaXQgc2hvdWxkIG5ldmVyIHJlY2VpdmVcbiAgICAvLyBhbnkgZmFydGhlciB1cGRhdGVzIGFzIHRoZSBUb2tlbiB2ZWN0b3IgaXMgc29ydGVkLlxuICAgIC8vIFdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgdGhpcyB0aGlzIGNvbmRpdGlvbiBmb3IgZXZlcnkgbmV3IHBvc3NpYmxlIGxvY2F0aW9uIGluZm9cbiAgICAvLyBiZWNhdXNlIHdpdGggZXJyb3IgcmVjb3ZlcnkgZW5hYmxlZCB3ZSBtYXkgZW5jb3VudGVyIGludmFsaWQgdG9rZW5zIChOYU4gbG9jYXRpb24gcHJvcHMpXG4gICAgZWxzZSBpZiAoY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPCBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uZW5kQ29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZExpbmUgPSBuZXdMb2NhdGlvbkluZm8uZW5kTGluZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkVGVybWluYWxUb0NzdChub2RlLCB0b2tlbiwgdG9rZW5UeXBlTmFtZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuW3Rva2VuVHlwZU5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXSA9IFt0b2tlbl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3Rva2VuVHlwZU5hbWVdLnB1c2godG9rZW4pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGROb25lVGVybWluYWxUb0NzdChub2RlLCBydWxlTmFtZSwgcnVsZVJlc3VsdCkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuW3J1bGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdID0gW3J1bGVSZXN1bHRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltydWxlTmFtZV0ucHVzaChydWxlUmVzdWx0KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CstVisitorDefinitionError: () => (/* binding */ CstVisitorDefinitionError),\n/* harmony export */   createBaseSemanticVisitorConstructor: () => (/* binding */ createBaseSemanticVisitorConstructor),\n/* harmony export */   createBaseVisitorConstructorWithDefaults: () => (/* binding */ createBaseVisitorConstructorWithDefaults),\n/* harmony export */   defaultVisit: () => (/* binding */ defaultVisit),\n/* harmony export */   validateMissingCstMethods: () => (/* binding */ validateMissingCstMethods),\n/* harmony export */   validateRedundantMethods: () => (/* binding */ validateRedundantMethods),\n/* harmony export */   validateVisitor: () => (/* binding */ validateVisitor)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lang/lang_extensions */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\");\n\n\nfunction defaultVisit(ctx, param) {\n    var childrenNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.keys)(ctx);\n    var childrenNamesLength = childrenNames.length;\n    for (var i = 0; i < childrenNamesLength; i++) {\n        var currChildName = childrenNames[i];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n            var currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n    return undefined;\n}\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.defineNameProp)(derivedConstructor, grammarName + \"BaseSemantics\");\n    var semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(semanticDefinitionErrors)) {\n                var errorMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });\n                throw Error(\"Errors Detected in CST Visitor <\" + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.defineNameProp)(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    var withDefaultsProto = Object.create(baseConstructor.prototype);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nvar CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n    return missingErrors.concat(redundantErrors);\n}\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(ruleNames, function (currRuleName) {\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(visitorInstance[currRuleName])) {\n            return {\n                msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(visitorInstance.constructor) + \" CST Visitor.\",\n                type: CstVisitorDefinitionError.MISSING_METHOD,\n                methodName: currRuleName\n            };\n        }\n    });\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact)(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nfunction validateRedundantMethods(visitorInstance, ruleNames) {\n    var errors = [];\n    for (var prop in visitorInstance) {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(visitorInstance[prop]) &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(VALID_PROP_NAMES, prop) &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(ruleNames, prop)) {\n            errors.push({\n                msg: \"Redundant visitor method: <\" + prop + \"> on \" + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(visitorInstance.constructor) + \" CST Visitor\\n\" +\n                    \"There is no Grammar Rule corresponding to this method's name.\\n\",\n                type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n                methodName: prop\n            });\n        }\n    }\n    return errors;\n}\n//# sourceMappingURL=cst_visitor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2NzdC9jc3RfdmlzaXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUg7QUFDM0M7QUFDbkU7QUFDUCx3QkFBd0Isa0RBQUk7QUFDNUI7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxRUFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixxREFBTztBQUN4QixvQ0FBb0MsaURBQUcscURBQXFELDBCQUEwQjtBQUN0SCxpRUFBaUUsbUVBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFjO0FBQ2xCO0FBQ0EsSUFBSSxxREFBTztBQUNYO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhEQUE4RDtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaURBQUc7QUFDcEIsYUFBYSx3REFBVTtBQUN2QjtBQUNBLDRFQUE0RSxtRUFBWTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHFEQUFPO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLHdEQUFVO0FBQ3RCLGFBQWEsc0RBQVE7QUFDckIsYUFBYSxzREFBUTtBQUNyQjtBQUNBLHNFQUFzRSxtRUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGNzdFxcY3N0X3Zpc2l0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcGFjdCwgY29udGFpbnMsIGZvckVhY2gsIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBrZXlzLCBtYXAgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGRlZmluZU5hbWVQcm9wLCBmdW5jdGlvbk5hbWUgfSBmcm9tIFwiLi4vLi4vbGFuZy9sYW5nX2V4dGVuc2lvbnNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0VmlzaXQoY3R4LCBwYXJhbSkge1xuICAgIHZhciBjaGlsZHJlbk5hbWVzID0ga2V5cyhjdHgpO1xuICAgIHZhciBjaGlsZHJlbk5hbWVzTGVuZ3RoID0gY2hpbGRyZW5OYW1lcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5hbWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJDaGlsZE5hbWUgPSBjaGlsZHJlbk5hbWVzW2ldO1xuICAgICAgICB2YXIgY3VyckNoaWxkQXJyYXkgPSBjdHhbY3VyckNoaWxkTmFtZV07XG4gICAgICAgIHZhciBjdXJyQ2hpbGRBcnJheUxlbmd0aCA9IGN1cnJDaGlsZEFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXJyQ2hpbGRBcnJheUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VyckNoaWxkID0gY3VyckNoaWxkQXJyYXlbal07XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIFRva2VucyBDaGlsZHJlbiBhbmQgQ3N0Tm9kZSBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGN1cnJDaGlsZC50b2tlblR5cGVJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbY3VyckNoaWxkLm5hbWVdKGN1cnJDaGlsZC5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHRWaXNpdCBkb2VzIG5vdCBzdXBwb3J0IGdlbmVyaWMgb3V0IHBhcmFtXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcykge1xuICAgIHZhciBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICBkZWZpbmVOYW1lUHJvcChkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzXCIpO1xuICAgIHZhciBzZW1hbnRpY1Byb3RvID0ge1xuICAgICAgICB2aXNpdDogZnVuY3Rpb24gKGNzdE5vZGUsIHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBlbmFibGVzIHdyaXRpbmcgbW9yZSBjb25jaXNlIHZpc2l0b3IgbWV0aG9kcyB3aGVuIENzdE5vZGUgaGFzIG9ubHkgYSBzaW5nbGUgY2hpbGRcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBDU1QgTm9kZSdzIGNoaWxkcmVuIGRpY3Rpb25hcnkgY2FuIG5ldmVyIGhhdmUgZW1wdHkgYXJyYXlzIGFzIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIGRlZmluZWQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcnJheS5cbiAgICAgICAgICAgICAgICBjc3ROb2RlID0gY3N0Tm9kZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuYWJsZXMgcGFzc2luZyBvcHRpb25hbCBDc3ROb2RlcyBjb25jaXNlbHkuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY3N0Tm9kZS5uYW1lXShjc3ROb2RlLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlVmlzaXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbWFudGljRGVmaW5pdGlvbkVycm9ycyA9IHZhbGlkYXRlVmlzaXRvcih0aGlzLCBydWxlTmFtZXMpO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHNlbWFudGljRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IG1hcChzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChjdXJyRGVmRXJyb3IpIHsgcmV0dXJuIGN1cnJEZWZFcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3JzIERldGVjdGVkIGluIENTVCBWaXNpdG9yIDxcIiArIGZ1bmN0aW9uTmFtZSh0aGlzLmNvbnN0cnVjdG9yKSArIFwiPjpcXG5cXHRcIiArIChcIlwiICsgZXJyb3JNZXNzYWdlcy5qb2luKFwiXFxuXFxuXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcblxcdFwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gc2VtYW50aWNQcm90bztcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGVyaXZlZENvbnN0cnVjdG9yO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5fUlVMRV9OQU1FUyA9IHJ1bGVOYW1lcztcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcywgYmFzZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGRlcml2ZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYWNjb3JkaW5nIHRvOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL1xuICAgIC8vIG5hbWU/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkZ1bmN0aW9uJTJGbmFtZVxuICAgIGRlZmluZU5hbWVQcm9wKGRlcml2ZWRDb25zdHJ1Y3RvciwgZ3JhbW1hck5hbWUgKyBcIkJhc2VTZW1hbnRpY3NXaXRoRGVmYXVsdHNcIik7XG4gICAgdmFyIHdpdGhEZWZhdWx0c1Byb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlQ29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBmb3JFYWNoKHJ1bGVOYW1lcywgZnVuY3Rpb24gKHJ1bGVOYW1lKSB7XG4gICAgICAgIHdpdGhEZWZhdWx0c1Byb3RvW3J1bGVOYW1lXSA9IGRlZmF1bHRWaXNpdDtcbiAgICB9KTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gd2l0aERlZmF1bHRzUHJvdG87XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlcml2ZWRDb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IHZhciBDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yO1xuKGZ1bmN0aW9uIChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yKSB7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiUkVEVU5EQU5UX01FVEhPRFwiXSA9IDBdID0gXCJSRURVTkRBTlRfTUVUSE9EXCI7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiTUlTU0lOR19NRVRIT0RcIl0gPSAxXSA9IFwiTUlTU0lOR19NRVRIT0RcIjtcbn0pKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgfHwgKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVmlzaXRvcih2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBtaXNzaW5nRXJyb3JzID0gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcyk7XG4gICAgdmFyIHJlZHVuZGFudEVycm9ycyA9IHZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcyk7XG4gICAgcmV0dXJuIG1pc3NpbmdFcnJvcnMuY29uY2F0KHJlZHVuZGFudEVycm9ycyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBlcnJvcnMgPSBtYXAocnVsZU5hbWVzLCBmdW5jdGlvbiAoY3VyclJ1bGVOYW1lKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbih2aXNpdG9ySW5zdGFuY2VbY3VyclJ1bGVOYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbXNnOiBcIk1pc3NpbmcgdmlzaXRvciBtZXRob2Q6IDxcIiArIGN1cnJSdWxlTmFtZSArIFwiPiBvbiBcIiArIGZ1bmN0aW9uTmFtZSh2aXNpdG9ySW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgQ1NUIFZpc2l0b3IuXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvci5NSVNTSU5HX01FVEhPRCxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiBjdXJyUnVsZU5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29tcGFjdChlcnJvcnMpO1xufVxudmFyIFZBTElEX1BST1BfTkFNRVMgPSBbXCJjb25zdHJ1Y3RvclwiLCBcInZpc2l0XCIsIFwidmFsaWRhdGVWaXNpdG9yXCJdO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHZpc2l0b3JJbnN0YW5jZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2aXNpdG9ySW5zdGFuY2VbcHJvcF0pICYmXG4gICAgICAgICAgICAhY29udGFpbnMoVkFMSURfUFJPUF9OQU1FUywgcHJvcCkgJiZcbiAgICAgICAgICAgICFjb250YWlucyhydWxlTmFtZXMsIHByb3ApKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbXNnOiBcIlJlZHVuZGFudCB2aXNpdG9yIG1ldGhvZDogPFwiICsgcHJvcCArIFwiPiBvbiBcIiArIGZ1bmN0aW9uTmFtZSh2aXNpdG9ySW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgQ1NUIFZpc2l0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgaXMgbm8gR3JhbW1hciBSdWxlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRob2QncyBuYW1lLlxcblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IuUkVEVU5EQU5UX01FVEhPRCxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiBwcm9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0X3Zpc2l0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/errors_public.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultGrammarResolverErrorProvider: () => (/* binding */ defaultGrammarResolverErrorProvider),\n/* harmony export */   defaultGrammarValidatorErrorProvider: () => (/* binding */ defaultGrammarValidatorErrorProvider),\n/* harmony export */   defaultParserErrorProvider: () => (/* binding */ defaultParserErrorProvider)\n/* harmony export */ });\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grammar/gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grammar/gast/gast */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\n\n\nvar defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.hasTokenLabel)(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \" + (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(expected) + \" <--\"\n            : \"token of type --> \" + expected.name + \" <--\";\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reduce)(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(allLookAheadPaths, function (currPath) {\n                return \"[\" + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(currPath, function (currTokenType) { return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType); }).join(\", \") + \"]\";\n            });\n            var nextValidSequenceItems = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(expectedIterationPaths, function (currPath) {\n                return \"[\" + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(currPath, function (currTokenType) { return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType); }).join(\",\") + \"]\";\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(defaultParserErrorProvider);\nvar defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nvar defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__.getProductionDslName)(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(options.prefixPath, function (currTok) {\n            return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(options.prefixPath, function (currtok) {\n            return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__.getProductionDslName)(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.map(options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\n            .concat([ruleName])\n            .join(\" --> \");\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2Vycm9yc19wdWJsaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRTtBQUMxQjtBQUNZO0FBQ3FCO0FBQ2Q7QUFDcEQ7QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLGtFQUFhO0FBQ3BDO0FBQ0EsdUJBQXVCLCtEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBTSx3REFBd0QscUNBQXFDO0FBQ3ZJLDBDQUEwQyxpREFBRztBQUM3Qyw2QkFBNkIsaURBQUcsc0NBQXNDLE9BQU8sK0RBQVUsa0JBQWtCO0FBQ3pHLGFBQWE7QUFDYix5Q0FBeUMsaURBQUcsb0RBQW9ELDJDQUEyQztBQUMzSTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpREFBRztBQUM3Qyw2QkFBNkIsaURBQUcsc0NBQXNDLE9BQU8sK0RBQVUsa0JBQWtCO0FBQ3pHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQVE7QUFDeEM7QUFDQTtBQUNBLHFDQUFxQyxrRUFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBSztBQUNqQztBQUNBLHNCQUFzQix3RUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsaURBQUc7QUFDekIsbUJBQW1CLCtEQUFVO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixpREFBRztBQUN6QixtQkFBbUIsK0RBQVU7QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQix3RUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFTLGtEQUFrRCx1QkFBdUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QywyREFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGVycm9yc19wdWJsaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzVG9rZW5MYWJlbCwgdG9rZW5MYWJlbCB9IGZyb20gXCIuLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgZmlyc3QsIG1hcCwgcmVkdWNlIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBOb25UZXJtaW5hbCwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmltcG9ydCB7IGdldFByb2R1Y3Rpb25Ec2xOYW1lIH0gZnJvbSBcIi4vZ3JhbW1hci9nYXN0L2dhc3RcIjtcbmV4cG9ydCB2YXIgZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIgPSB7XG4gICAgYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IF9hLmV4cGVjdGVkLCBhY3R1YWwgPSBfYS5hY3R1YWwsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHZhciBoYXNMYWJlbCA9IGhhc1Rva2VuTGFiZWwoZXhwZWN0ZWQpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRNc2cgPSBoYXNMYWJlbFxuICAgICAgICAgICAgPyBcIi0tPiBcIiArIHRva2VuTGFiZWwoZXhwZWN0ZWQpICsgXCIgPC0tXCJcbiAgICAgICAgICAgIDogXCJ0b2tlbiBvZiB0eXBlIC0tPiBcIiArIGV4cGVjdGVkLm5hbWUgKyBcIiA8LS1cIjtcbiAgICAgICAgdmFyIG1zZyA9IFwiRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWRNc2cgKyBcIiBidXQgZm91bmQgLS0+ICdcIiArIGFjdHVhbC5pbWFnZSArIFwiJyA8LS1cIjtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGZpcnN0UmVkdW5kYW50ID0gX2EuZmlyc3RSZWR1bmRhbnQsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHJldHVybiBcIlJlZHVuZGFudCBpbnB1dCwgZXhwZWN0aW5nIEVPRiBidXQgZm91bmQ6IFwiICsgZmlyc3RSZWR1bmRhbnQuaW1hZ2U7XG4gICAgfSxcbiAgICBidWlsZE5vVmlhYmxlQWx0TWVzc2FnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFBhdGhzUGVyQWx0ID0gX2EuZXhwZWN0ZWRQYXRoc1BlckFsdCwgYWN0dWFsID0gX2EuYWN0dWFsLCBwcmV2aW91cyA9IF9hLnByZXZpb3VzLCBjdXN0b21Vc2VyRGVzY3JpcHRpb24gPSBfYS5jdXN0b21Vc2VyRGVzY3JpcHRpb24sIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHZhciBlcnJQcmVmaXggPSBcIkV4cGVjdGluZzogXCI7XG4gICAgICAgIC8vIFRPRE86IGlzc3VlOiBObyBWaWFibGUgQWx0ZXJuYXRpdmUgRXJyb3IgbWF5IGhhdmUgaW5jb21wbGV0ZSBkZXRhaWxzLiAjNTAyXG4gICAgICAgIHZhciBhY3R1YWxUZXh0ID0gZmlyc3QoYWN0dWFsKS5pbWFnZTtcbiAgICAgICAgdmFyIGVyclN1ZmZpeCA9IFwiXFxuYnV0IGZvdW5kOiAnXCIgKyBhY3R1YWxUZXh0ICsgXCInXCI7XG4gICAgICAgIGlmIChjdXN0b21Vc2VyRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjdXN0b21Vc2VyRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWxsTG9va0FoZWFkUGF0aHMgPSByZWR1Y2UoZXhwZWN0ZWRQYXRoc1BlckFsdCwgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdFBhdGhzKSB7IHJldHVybiByZXN1bHQuY29uY2F0KGN1cnJBbHRQYXRocyk7IH0sIFtdKTtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsaWRUb2tlblNlcXVlbmNlcyA9IG1hcChhbGxMb29rQWhlYWRQYXRocywgZnVuY3Rpb24gKGN1cnJQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgbWFwKGN1cnJQYXRoLCBmdW5jdGlvbiAoY3VyclRva2VuVHlwZSkgeyByZXR1cm4gdG9rZW5MYWJlbChjdXJyVG9rZW5UeXBlKTsgfSkuam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsaWRTZXF1ZW5jZUl0ZW1zID0gbWFwKG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLCBmdW5jdGlvbiAoaXRlbU1zZywgaWR4KSB7IHJldHVybiBcIiAgXCIgKyAoaWR4ICsgMSkgKyBcIi4gXCIgKyBpdGVtTXNnOyB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkRGVzY3JpcHRpb24gPSBcIm9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6XFxuXCIgKyBuZXh0VmFsaWRTZXF1ZW5jZUl0ZW1zLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY2FsY3VsYXRlZERlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBidWlsZEVhcmx5RXhpdE1lc3NhZ2U6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRJdGVyYXRpb25QYXRocyA9IF9hLmV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIGFjdHVhbCA9IF9hLmFjdHVhbCwgY3VzdG9tVXNlckRlc2NyaXB0aW9uID0gX2EuY3VzdG9tVXNlckRlc2NyaXB0aW9uLCBydWxlTmFtZSA9IF9hLnJ1bGVOYW1lO1xuICAgICAgICB2YXIgZXJyUHJlZml4ID0gXCJFeHBlY3Rpbmc6IFwiO1xuICAgICAgICAvLyBUT0RPOiBpc3N1ZTogTm8gVmlhYmxlIEFsdGVybmF0aXZlIEVycm9yIG1heSBoYXZlIGluY29tcGxldGUgZGV0YWlscy4gIzUwMlxuICAgICAgICB2YXIgYWN0dWFsVGV4dCA9IGZpcnN0KGFjdHVhbCkuaW1hZ2U7XG4gICAgICAgIHZhciBlcnJTdWZmaXggPSBcIlxcbmJ1dCBmb3VuZDogJ1wiICsgYWN0dWFsVGV4dCArIFwiJ1wiO1xuICAgICAgICBpZiAoY3VzdG9tVXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY3VzdG9tVXNlckRlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gbWFwKGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIG1hcChjdXJyUGF0aCwgZnVuY3Rpb24gKGN1cnJUb2tlblR5cGUpIHsgcmV0dXJuIHRva2VuTGFiZWwoY3VyclRva2VuVHlwZSk7IH0pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkRGVzY3JpcHRpb24gPSBcImV4cGVjdGluZyBhdCBsZWFzdCBvbmUgaXRlcmF0aW9uIHdoaWNoIHN0YXJ0cyB3aXRoIG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6OlxcbiAgXCIgK1xuICAgICAgICAgICAgICAgIChcIjxcIiArIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLmpvaW4oXCIgLFwiKSArIFwiPlwiKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjYWxjdWxhdGVkRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcik7XG5leHBvcnQgdmFyIGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkUnVsZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIHVuZGVmaW5lZFJ1bGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiSW52YWxpZCBncmFtbWFyLCByZWZlcmVuY2UgdG8gYSBydWxlIHdoaWNoIGlzIG5vdCBkZWZpbmVkOiAtPlwiICtcbiAgICAgICAgICAgIHVuZGVmaW5lZFJ1bGUubm9uVGVybWluYWxOYW1lICtcbiAgICAgICAgICAgIFwiPC1cXG5cIiArXG4gICAgICAgICAgICBcImluc2lkZSB0b3AgbGV2ZWwgcnVsZTogLT5cIiArXG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGUubmFtZSArXG4gICAgICAgICAgICBcIjwtXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcjogZnVuY3Rpb24gKHRvcExldmVsUnVsZSwgZHVwbGljYXRlUHJvZHMpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQocHJvZCkge1xuICAgICAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcExldmVsTmFtZSA9IHRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZHVwbGljYXRlUHJvZCA9IGZpcnN0KGR1cGxpY2F0ZVByb2RzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZHVwbGljYXRlUHJvZC5pZHg7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBleHRyYUFyZ3VtZW50ID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBoYXNFeHBsaWNpdEluZGV4ID0gaW5kZXggPiAwO1xuICAgICAgICB2YXIgbXNnID0gXCItPlwiICsgZHNsTmFtZSArIChoYXNFeHBsaWNpdEluZGV4ID8gaW5kZXggOiBcIlwiKSArIFwiPC0gXCIgKyAoZXh0cmFBcmd1bWVudCA/IFwid2l0aCBhcmd1bWVudDogLT5cIiArIGV4dHJhQXJndW1lbnQgKyBcIjwtXCIgOiBcIlwiKSArIFwiXFxuICAgICAgICAgICAgICAgICAgYXBwZWFycyBtb3JlIHRoYW4gb25jZSAoXCIgKyBkdXBsaWNhdGVQcm9kcy5sZW5ndGggKyBcIiB0aW1lcykgaW4gdGhlIHRvcCBsZXZlbCBydWxlOiAtPlwiICsgdG9wTGV2ZWxOYW1lICsgXCI8LS4gICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXFxuICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgIC8vIHdoaXRlIHNwYWNlIHRyaW1taW5nIHRpbWUhIGJldHRlciB0byB0cmltIGFmdGVyd2FyZHMgYXMgaXQgYWxsb3dzIHRvIHVzZSBXRUxMIGZvcm1hdHRlZCBtdWx0aSBsaW5lIHRlbXBsYXRlIHN0cmluZ3MuLi5cbiAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1sgXFx0XSsvZywgXCIgXCIpO1xuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvXFxzXFxzKy9nLCBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkTmFtZXNwYWNlQ29uZmxpY3RFcnJvcjogZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiTmFtZXNwYWNlIGNvbmZsaWN0IGZvdW5kIGluIGdyYW1tYXIuXFxuXCIgK1xuICAgICAgICAgICAgKFwiVGhlIGdyYW1tYXIgaGFzIGJvdGggYSBUZXJtaW5hbChUb2tlbikgYW5kIGEgTm9uLVRlcm1pbmFsKFJ1bGUpIG5hbWVkOiA8XCIgKyBydWxlLm5hbWUgKyBcIj4uXFxuXCIpICtcbiAgICAgICAgICAgIFwiVG8gcmVzb2x2ZSB0aGlzIG1ha2Ugc3VyZSBlYWNoIFRlcm1pbmFsIGFuZCBOb24tVGVybWluYWwgbmFtZXMgYXJlIHVuaXF1ZVxcblwiICtcbiAgICAgICAgICAgIFwiVGhpcyBpcyBlYXN5IHRvIGFjY29tcGxpc2ggYnkgdXNpbmcgdGhlIGNvbnZlbnRpb24gdGhhdCBUZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGFuIHVwcGVyY2FzZSBsZXR0ZXJcXG5cIiArXG4gICAgICAgICAgICBcImFuZCBOb24tVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhIGxvd2VyIGNhc2UgbGV0dGVyLlwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcGF0aE1zZyA9IG1hcChvcHRpb25zLnByZWZpeFBhdGgsIGZ1bmN0aW9uIChjdXJyVG9rKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5MYWJlbChjdXJyVG9rKTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgb2NjdXJyZW5jZSA9IG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4ID09PSAwID8gXCJcIiA6IG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4O1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJBbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzOiA8XCIgKyBvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpICsgXCI+IGR1ZSB0byBjb21tb24gbG9va2FoZWFkIHByZWZpeFxcblwiICtcbiAgICAgICAgICAgIChcImluIDxPUlwiICsgb2NjdXJyZW5jZSArIFwiPiBpbnNpZGUgPFwiICsgb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZSArIFwiPiBSdWxlLFxcblwiKSArXG4gICAgICAgICAgICAoXCI8XCIgKyBwYXRoTXNnICsgXCI+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5cIikgK1xuICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQ09NTU9OX1BSRUZJWFxcblwiICtcbiAgICAgICAgICAgIFwiRm9yIEZ1cnRoZXIgZGV0YWlscy5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhNc2cgPSBtYXAob3B0aW9ucy5wcmVmaXhQYXRoLCBmdW5jdGlvbiAoY3VycnRvaykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuTGFiZWwoY3VycnRvayk7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgdmFyIGN1cnJNZXNzYWdlID0gXCJBbWJpZ3VvdXMgQWx0ZXJuYXRpdmVzIERldGVjdGVkOiA8XCIgKyBvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpICsgXCI+IGluIDxPUlwiICsgb2NjdXJyZW5jZSArIFwiPlwiICtcbiAgICAgICAgICAgIChcIiBpbnNpZGUgPFwiICsgb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZSArIFwiPiBSdWxlLFxcblwiKSArXG4gICAgICAgICAgICAoXCI8XCIgKyBwYXRoTXNnICsgXCI+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5cIik7XG4gICAgICAgIGN1cnJNZXNzYWdlID1cbiAgICAgICAgICAgIGN1cnJNZXNzYWdlICtcbiAgICAgICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNBTUJJR1VPVVNfQUxURVJOQVRJVkVTXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiRm9yIEZ1cnRoZXIgZGV0YWlscy5cIjtcbiAgICAgICAgcmV0dXJuIGN1cnJNZXNzYWdlO1xuICAgIH0sXG4gICAgYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRzbE5hbWUgPSBnZXRQcm9kdWN0aW9uRHNsTmFtZShvcHRpb25zLnJlcGV0aXRpb24pO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXBldGl0aW9uLmlkeCAhPT0gMCkge1xuICAgICAgICAgICAgZHNsTmFtZSArPSBvcHRpb25zLnJlcGV0aXRpb24uaWR4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIlRoZSByZXBldGl0aW9uIDxcIiArIGRzbE5hbWUgKyBcIj4gd2l0aGluIFJ1bGUgPFwiICsgb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZSArIFwiPiBjYW4gbmV2ZXIgY29uc3VtZSBhbnkgdG9rZW5zLlxcblwiICtcbiAgICAgICAgICAgIFwiVGhpcyBjb3VsZCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICAvLyBUT0RPOiByZW1vdmUgLSBgZXJyb3JzX3B1YmxpY2AgZnJvbSBueWMuY29uZmlnLmpzIGV4Y2x1ZGVcbiAgICAvLyAgICAgICBvbmNlIHRoaXMgbWV0aG9kIGlzIGZ1bGx5IHJlbW92ZWQgZnJvbSB0aGlzIGZpbGVcbiAgICBidWlsZFRva2VuTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gXCJkZXByZWNhdGVkXCI7XG4gICAgfSxcbiAgICBidWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8XCIgKyAob3B0aW9ucy5lbXB0eUNob2ljZUlkeCArIDEpICsgXCI+XCIgK1xuICAgICAgICAgICAgKFwiIGluIDxPUlwiICsgb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggKyBcIj4gaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZS5cXG5cIikgK1xuICAgICAgICAgICAgXCJPbmx5IHRoZSBsYXN0IGFsdGVybmF0aXZlIG1heSBiZSBhbiBlbXB0eSBhbHRlcm5hdGl2ZS5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJBbiBBbHRlcm5hdGlvbiBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMjU2IGFsdGVybmF0aXZlczpcXG5cIiArXG4gICAgICAgICAgICAoXCI8T1JcIiArIG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4ICsgXCI+IGluc2lkZSA8XCIgKyBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lICsgXCI+IFJ1bGUuXFxuIGhhcyBcIiArIChvcHRpb25zLmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoICsgMSkgKyBcIiBhbHRlcm5hdGl2ZXMuXCIpO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWU7XG4gICAgICAgIHZhciBwYXRoTmFtZXMgPSB1dGlscy5tYXAob3B0aW9ucy5sZWZ0UmVjdXJzaW9uUGF0aCwgZnVuY3Rpb24gKGN1cnJSdWxlKSB7IHJldHVybiBjdXJyUnVsZS5uYW1lOyB9KTtcbiAgICAgICAgdmFyIGxlZnRSZWN1cnNpdmVQYXRoID0gcnVsZU5hbWUgKyBcIiAtLT4gXCIgKyBwYXRoTmFtZXNcbiAgICAgICAgICAgIC5jb25jYXQoW3J1bGVOYW1lXSlcbiAgICAgICAgICAgIC5qb2luKFwiIC0tPiBcIik7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIkxlZnQgUmVjdXJzaW9uIGZvdW5kIGluIGdyYW1tYXIuXFxuXCIgK1xuICAgICAgICAgICAgKFwicnVsZTogPFwiICsgcnVsZU5hbWUgKyBcIj4gY2FuIGJlIGludm9rZWQgZnJvbSBpdHNlbGYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpXFxuXCIpICtcbiAgICAgICAgICAgIChcIndpdGhvdXQgY29uc3VtaW5nIGFueSBUb2tlbnMuIFRoZSBncmFtbWFyIHBhdGggdGhhdCBjYXVzZXMgdGhpcyBpczogXFxuIFwiICsgbGVmdFJlY3Vyc2l2ZVBhdGggKyBcIlxcblwiKSArXG4gICAgICAgICAgICBcIiBUbyBmaXggdGhpcyByZWZhY3RvciB5b3VyIGdyYW1tYXIgdG8gcmVtb3ZlIHRoZSBsZWZ0IHJlY3Vyc2lvbi5cXG5cIiArXG4gICAgICAgICAgICBcInNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTExfcGFyc2VyI0xlZnRfRmFjdG9yaW5nLlwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgLy8gVE9ETzogcmVtb3ZlIC0gYGVycm9yc19wdWJsaWNgIGZyb20gbnljLmNvbmZpZy5qcyBleGNsdWRlXG4gICAgLy8gICAgICAgb25jZSB0aGlzIG1ldGhvZCBpcyBmdWxseSByZW1vdmVkIGZyb20gdGhpcyBmaWxlXG4gICAgYnVpbGRJbnZhbGlkUnVsZU5hbWVFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIFwiZGVwcmVjYXRlZFwiO1xuICAgIH0sXG4gICAgYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWU7XG4gICAgICAgIGlmIChvcHRpb25zLnRvcExldmVsUnVsZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyck1zZyA9IFwiRHVwbGljYXRlIGRlZmluaXRpb24sIHJ1bGU6IC0+XCIgKyBydWxlTmFtZSArIFwiPC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPlwiICsgb3B0aW9ucy5ncmFtbWFyTmFtZSArIFwiPC1cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzX3B1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EarlyExitException: () => (/* binding */ EarlyExitException),\n/* harmony export */   MismatchedTokenException: () => (/* binding */ MismatchedTokenException),\n/* harmony export */   NoViableAltException: () => (/* binding */ NoViableAltException),\n/* harmony export */   NotAllInputParsedException: () => (/* binding */ NotAllInputParsedException),\n/* harmony export */   isRecognitionException: () => (/* binding */ isRecognitionException)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nfunction isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nvar RecognitionException = /** @class */ (function (_super) {\n    __extends(RecognitionException, _super);\n    function RecognitionException(message, token) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, message) || this;\n        _this.token = token;\n        _this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, _this.constructor);\n        }\n        return _this;\n    }\n    return RecognitionException;\n}(Error));\nvar MismatchedTokenException = /** @class */ (function (_super) {\n    __extends(MismatchedTokenException, _super);\n    function MismatchedTokenException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = MISMATCHED_TOKEN_EXCEPTION;\n        return _this;\n    }\n    return MismatchedTokenException;\n}(RecognitionException));\n\nvar NoViableAltException = /** @class */ (function (_super) {\n    __extends(NoViableAltException, _super);\n    function NoViableAltException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = NO_VIABLE_ALT_EXCEPTION;\n        return _this;\n    }\n    return NoViableAltException;\n}(RecognitionException));\n\nvar NotAllInputParsedException = /** @class */ (function (_super) {\n    __extends(NotAllInputParsedException, _super);\n    function NotAllInputParsedException(message, token) {\n        var _this = _super.call(this, message, token) || this;\n        _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n        return _this;\n    }\n    return NotAllInputParsedException;\n}(RecognitionException));\n\nvar EarlyExitException = /** @class */ (function (_super) {\n    __extends(EarlyExitException, _super);\n    function EarlyExitException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = EARLY_EXIT_EXCEPTION;\n        return _this;\n    }\n    return EarlyExitException;\n}(RecognitionException));\n\n//# sourceMappingURL=exceptions_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDeUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFdBQVcsc0RBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDK0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM2QjtBQUM5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGV4Y2VwdGlvbnNfcHVibGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBjb250YWlucyB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xudmFyIE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OID0gXCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIjtcbnZhciBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTiA9IFwiTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcbnZhciBFQVJMWV9FWElUX0VYQ0VQVElPTiA9IFwiRWFybHlFeGl0RXhjZXB0aW9uXCI7XG52YXIgTk9UX0FMTF9JTlBVVF9QQVJTRURfRVhDRVBUSU9OID0gXCJOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvblwiO1xudmFyIFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUyA9IFtcbiAgICBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTixcbiAgICBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTixcbiAgICBFQVJMWV9FWElUX0VYQ0VQVElPTixcbiAgICBOT1RfQUxMX0lOUFVUX1BBUlNFRF9FWENFUFRJT05cbl07XG5PYmplY3QuZnJlZXplKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUyk7XG4vLyBoYWNrcyB0byBieXBhc3Mgbm8gc3VwcG9ydCBmb3IgY3VzdG9tIEVycm9ycyBpbiBqYXZhc2NyaXB0L3R5cGVzY3JpcHRcbmV4cG9ydCBmdW5jdGlvbiBpc1JlY29nbml0aW9uRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgLy8gY2FuJ3QgZG8gaW5zdGFuY2VvZiBvbiBoYWNrZWQgY3VzdG9tIGpzIGV4Y2VwdGlvbnNcbiAgICByZXR1cm4gY29udGFpbnMoUkVDT0dOSVRJT05fRVhDRVBUSU9OX05BTUVTLCBlcnJvci5uYW1lKTtcbn1cbnZhciBSZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjb2duaXRpb25FeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVjb2duaXRpb25FeGNlcHRpb24obWVzc2FnZSwgdG9rZW4pIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICBfdGhpcy5yZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICAvLyBmaXggcHJvdG90eXBlIGNoYWluIHdoZW4gdHlwZXNjcmlwdCB0YXJnZXQgaXMgRVM1XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFY4IHdvcmthcm91bmQgdG8gcmVtb3ZlIGNvbnN0cnVjdG9yIGZyb20gc3RhY2t0cmFjZSB3aGVuIHR5cGVzY3JpcHQgdGFyZ2V0IGlzIEVTNSAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBfdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVjb2duaXRpb25FeGNlcHRpb247XG59KEVycm9yKSk7XG52YXIgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UsIHRva2VuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgX3RoaXMubmFtZSA9IE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb247XG59KFJlY29nbml0aW9uRXhjZXB0aW9uKSk7XG5leHBvcnQgeyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gfTtcbnZhciBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9WaWFibGVBbHRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9WaWFibGVBbHRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICBfdGhpcy5uYW1lID0gTk9fVklBQkxFX0FMVF9FWENFUFRJT047XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5vVmlhYmxlQWx0RXhjZXB0aW9uO1xufShSZWNvZ25pdGlvbkV4Y2VwdGlvbikpO1xuZXhwb3J0IHsgTm9WaWFibGVBbHRFeGNlcHRpb24gfTtcbnZhciBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBOT1RfQUxMX0lOUFVUX1BBUlNFRF9FWENFUFRJT047XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uO1xufShSZWNvZ25pdGlvbkV4Y2VwdGlvbikpO1xuZXhwb3J0IHsgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24gfTtcbnZhciBFYXJseUV4aXRFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVhcmx5RXhpdEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFYXJseUV4aXRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICBfdGhpcy5uYW1lID0gRUFSTFlfRVhJVF9FWENFUFRJT047XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEVhcmx5RXhpdEV4Y2VwdGlvbjtcbn0oUmVjb2duaXRpb25FeGNlcHRpb24pKTtcbmV4cG9ydCB7IEVhcmx5RXhpdEV4Y2VwdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uc19wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OccurrenceValidationCollector: () => (/* binding */ OccurrenceValidationCollector),\n/* harmony export */   RepetionCollector: () => (/* binding */ RepetionCollector),\n/* harmony export */   checkPrefixAlternativesAmbiguities: () => (/* binding */ checkPrefixAlternativesAmbiguities),\n/* harmony export */   getFirstNoneTerminal: () => (/* binding */ getFirstNoneTerminal),\n/* harmony export */   identifyProductionForDuplicates: () => (/* binding */ identifyProductionForDuplicates),\n/* harmony export */   validateAmbiguousAlternationAlternatives: () => (/* binding */ validateAmbiguousAlternationAlternatives),\n/* harmony export */   validateEmptyOrAlternative: () => (/* binding */ validateEmptyOrAlternative),\n/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar),\n/* harmony export */   validateNoLeftRecursion: () => (/* binding */ validateNoLeftRecursion),\n/* harmony export */   validateRuleDoesNotAlreadyExist: () => (/* binding */ validateRuleDoesNotAlreadyExist),\n/* harmony export */   validateRuleIsOverridden: () => (/* binding */ validateRuleIsOverridden),\n/* harmony export */   validateSomeNonEmptyLookaheadPath: () => (/* binding */ validateSomeNonEmptyLookaheadPath),\n/* harmony export */   validateTooManyAlts: () => (/* binding */ validateTooManyAlts)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser/parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n/* harmony import */ var _lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookahead */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpreter */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n    var duplicateErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(leftRecursionErrors, _utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)) {\n        emptyAltErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tooManyAltsErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)));\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values(duplicates), function (currDuplicates) {\n        var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(firstProd);\n        var defError = {\n            message: msg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_6__.GAstVisitor));\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(validNextSteps, function (currRefRule) {\n            var newPath = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(errorsFromNextSteps));\n    }\n}\nfunction getFirstNoneTerminal(definition) {\n    var result = [];\n    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Alternative ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Option ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.RepetitionMandatory ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.RepetitionMandatoryWithSeparator ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.RepetitionWithSeparator ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isOptionalProd)(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_6__.GAstVisitor));\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (errors, currOr) {\n        var exceptLast = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.dropRight(currOr.definition);\n        var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = (0,_interpreter__WEBPACK_IMPORTED_MODULE_4__.nextPossibleTokensAfter)([currAlternative], [], null, 1);\n            if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact(currErrors));\n    }, []);\n    return errors;\n}\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/SAP/chevrotain/issues/869\n    ors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reject)(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_6__.GAstVisitor));\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(allRuleProductions, function (currProd) {\n            var prodType = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getProdType)(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.containsPath)(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !(0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.containsPath)(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.findAll)(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(tokenTypes, function (currToken) { return currToken.name; });\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvY2hlY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUMwQztBQUNrRTtBQUNoRDtBQUNNO0FBQ3FFO0FBQ2hGO0FBQ29KO0FBQ25KO0FBQ2xEO0FBQ1AsMEJBQTBCLDZDQUFTO0FBQ25DO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw2Q0FBUztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBSyxzQkFBc0IsaURBQU87QUFDMUMseUJBQXlCLGlEQUFHO0FBQzVCO0FBQ0EsU0FBUztBQUNULDhCQUE4QixpREFBRztBQUNqQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQUc7QUFDL0I7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLGlEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLFlBQVksaURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBYTtBQUN4QyxxQkFBcUIsOENBQVU7QUFDL0I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDZDQUFTLENBQUMsZ0RBQVk7QUFDdkMsd0JBQXdCLCtDQUFXO0FBQ25DO0FBQ0Esc0JBQXNCLGdFQUFvQjtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLHFFQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsV0FBVyxnRUFBb0I7QUFDL0I7QUFDQTtBQUNBLHdCQUF3Qix1REFBUTtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCLDBEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsa0VBQVc7QUFDNEI7QUFDbEM7QUFDUDtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLHFFQUF5QjtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxTQUFTLGtEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQXlCO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxRQUFRLGlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCLHFFQUF5QjtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQWdCO0FBQzdDLGtDQUFrQyw2Q0FBUztBQUMzQywwQkFBMEIsa0RBQWM7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkIsaURBQWE7QUFDMUM7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLGlEQUFhO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQVc7QUFDL0I7QUFDQSw2QkFBNkIsMERBQVc7QUFDeEM7QUFDQTtBQUNBLGtDQUFrQywwREFBZTtBQUNqRCw2QkFBNkIscURBQU07QUFDbkMsNkJBQTZCLGtFQUFtQjtBQUNoRCw2QkFBNkIsK0VBQWdDO0FBQzdELDZCQUE2QixzRUFBdUI7QUFDcEQsNkJBQTZCLHlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQSxrQ0FBa0MsMERBQVc7QUFDN0M7QUFDQSxpQkFBaUIsaURBQWEsQ0FBQyw2Q0FBUztBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyx1REFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFjO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsOENBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxrRUFBVztBQUNOO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFZO0FBQzdCLHlCQUF5QixtREFBZTtBQUN4Qyx5QkFBeUIsNkNBQVM7QUFDbEMscUNBQXFDLHFFQUF1QjtBQUM1RCxnQkFBZ0IsaURBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEIscUVBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLGlEQUFhO0FBQzFDLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTSwwQkFBMEIsMkNBQTJDO0FBQ3JGLGlCQUFpQixnREFBWTtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsa0VBQVc7QUFDZ0I7QUFDdEI7QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0IscUVBQXlCO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBLElBQUkscURBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFPO0FBQ2YsMkJBQTJCLHVEQUFXO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsNEVBQWdDO0FBQ3hEO0FBQ0EsZ0JBQWdCLHFEQUFPLENBQUMscURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEIscUVBQXlCO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBLFlBQVkscURBQU87QUFDbkI7QUFDQSxvQkFBb0Isd0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUIsd0RBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLDZDQUFTO0FBQzlCLDBCQUEwQixpREFBRyxpREFBaUQsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQixxRUFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixvREFBTTtBQUNoQyw4QkFBOEIsaURBQUc7QUFDakMscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxJQUFJLHFEQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscURBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBb0I7QUFDcEMsU0FBUztBQUNULG1DQUFtQyxpREFBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLHFFQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBRyxvQ0FBb0Msd0JBQXdCO0FBQ3BGLElBQUkscURBQU87QUFDWDtBQUNBLFlBQVksc0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFFQUF5QjtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxncmFtbWFyXFxjaGVja3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgY29udGFpbnMsIGV2ZXJ5LCBmaW5kQWxsLCBmbGF0dGVuLCBmb3JFYWNoLCBpc0VtcHR5LCBtYXAsIHJlZHVjZSwgcmVqZWN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IGdldFByb2R1Y3Rpb25Ec2xOYW1lLCBpc09wdGlvbmFsUHJvZCB9IGZyb20gXCIuL2dhc3QvZ2FzdFwiO1xuaW1wb3J0IHsgY29udGFpbnNQYXRoLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCwgZ2V0TG9va2FoZWFkUGF0aHNGb3JPciwgZ2V0UHJvZFR5cGUsIGlzU3RyaWN0UHJlZml4T2ZQYXRoIH0gZnJvbSBcIi4vbG9va2FoZWFkXCI7XG5pbXBvcnQgeyBuZXh0UG9zc2libGVUb2tlbnNBZnRlciB9IGZyb20gXCIuL2ludGVycHJldGVyXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUgYXMgQWx0ZXJuYXRpdmVHQVNULCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgR0FzdFZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIodG9wTGV2ZWxzLCBnbG9iYWxNYXhMb29rYWhlYWQsIHRva2VuVHlwZXMsIGVyck1zZ1Byb3ZpZGVyLCBncmFtbWFyTmFtZSkge1xuICAgIHZhciBkdXBsaWNhdGVFcnJvcnMgPSB1dGlscy5tYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcExldmVsKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKGN1cnJUb3BMZXZlbCwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHZhciBsZWZ0UmVjdXJzaW9uRXJyb3JzID0gdXRpbHMubWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbihjdXJyVG9wUnVsZSwgY3VyclRvcFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICB2YXIgZW1wdHlBbHRFcnJvcnMgPSBbXTtcbiAgICB2YXIgYW1iaWd1b3VzQWx0c0Vycm9ycyA9IFtdO1xuICAgIHZhciBlbXB0eVJlcGV0aXRpb25FcnJvcnMgPSBbXTtcbiAgICAvLyBsZWZ0IHJlY3Vyc2lvbiBjb3VsZCBjYXVzZSBpbmZpbml0ZSBsb29wcyBpbiB0aGUgZm9sbG93aW5nIHZhbGlkYXRpb25zLlxuICAgIC8vIEl0IGlzIHNhZmVzdCB0byBmaXJzdCBoYXZlIHRoZSB1c2VyIGZpeCB0aGUgbGVmdCByZWN1cnNpb24gZXJyb3JzIGZpcnN0IGFuZCBvbmx5IHRoZW4gZXhhbWluZSBGdXJ0aGVyIGlzc3Vlcy5cbiAgICBpZiAoZXZlcnkobGVmdFJlY3Vyc2lvbkVycm9ycywgaXNFbXB0eSkpIHtcbiAgICAgICAgZW1wdHlBbHRFcnJvcnMgPSBtYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUVtcHR5T3JBbHRlcm5hdGl2ZShjdXJyVG9wUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYW1iaWd1b3VzQWx0c0Vycm9ycyA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyVG9wUnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoY3VyclRvcFJ1bGUsIGdsb2JhbE1heExvb2thaGVhZCwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1wdHlSZXBldGl0aW9uRXJyb3JzID0gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoKHRvcExldmVscywgZ2xvYmFsTWF4TG9va2FoZWFkLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfVxuICAgIHZhciB0ZXJtc05hbWVzcGFjZUNvbmZsaWN0RXJyb3JzID0gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgdmFyIHRvb01hbnlBbHRzRXJyb3JzID0gbWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1clJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVG9vTWFueUFsdHMoY3VyUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHZhciBkdXBsaWNhdGVSdWxlc0Vycm9yID0gbWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1clJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QoY3VyUnVsZSwgdG9wTGV2ZWxzLCBncmFtbWFyTmFtZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAodXRpbHMuZmxhdHRlbihkdXBsaWNhdGVFcnJvcnMuY29uY2F0KGVtcHR5UmVwZXRpdGlvbkVycm9ycywgbGVmdFJlY3Vyc2lvbkVycm9ycywgZW1wdHlBbHRFcnJvcnMsIGFtYmlndW91c0FsdHNFcnJvcnMsIHRlcm1zTmFtZXNwYWNlQ29uZmxpY3RFcnJvcnMsIHRvb01hbnlBbHRzRXJyb3JzLCBkdXBsaWNhdGVSdWxlc0Vycm9yKSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEdXBsaWNhdGVQcm9kdWN0aW9ucyh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgIHZhciBhbGxSdWxlUHJvZHVjdGlvbnMgPSBjb2xsZWN0b3JWaXNpdG9yLmFsbFByb2R1Y3Rpb25zO1xuICAgIHZhciBwcm9kdWN0aW9uR3JvdXBzID0gdXRpbHMuZ3JvdXBCeShhbGxSdWxlUHJvZHVjdGlvbnMsIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMpO1xuICAgIHZhciBkdXBsaWNhdGVzID0gdXRpbHMucGljayhwcm9kdWN0aW9uR3JvdXBzLCBmdW5jdGlvbiAoY3Vyckdyb3VwKSB7XG4gICAgICAgIHJldHVybiBjdXJyR3JvdXAubGVuZ3RoID4gMTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gdXRpbHMubWFwKHV0aWxzLnZhbHVlcyhkdXBsaWNhdGVzKSwgZnVuY3Rpb24gKGN1cnJEdXBsaWNhdGVzKSB7XG4gICAgICAgIHZhciBmaXJzdFByb2QgPSB1dGlscy5maXJzdChjdXJyRHVwbGljYXRlcyk7XG4gICAgICAgIHZhciBtc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZUZvdW5kRXJyb3IodG9wTGV2ZWxSdWxlLCBjdXJyRHVwbGljYXRlcyk7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZmlyc3RQcm9kKTtcbiAgICAgICAgdmFyIGRlZkVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUFJPRFVDVElPTlMsXG4gICAgICAgICAgICBydWxlTmFtZTogdG9wTGV2ZWxSdWxlLm5hbWUsXG4gICAgICAgICAgICBkc2xOYW1lOiBkc2xOYW1lLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogZmlyc3RQcm9kLmlkeFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyYW0gPSBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChmaXJzdFByb2QpO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIGRlZkVycm9yLnBhcmFtZXRlciA9IHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZFcnJvcjtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMocHJvZCkge1xuICAgIHJldHVybiBnZXRQcm9kdWN0aW9uRHNsTmFtZShwcm9kKSArIFwiXyNfXCIgKyBwcm9kLmlkeCArIFwiXyNfXCIgKyBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKTtcbn1cbmZ1bmN0aW9uIGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpIHtcbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBwcm9kLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxudmFyIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAoc3VicnVsZSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goc3VicnVsZSk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChvcHRpb24pO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAob3IpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG9yKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0ZXJtaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgeyBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciB9O1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QocnVsZSwgYWxsUnVsZXMsIGNsYXNzTmFtZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG9jY3VycmVuY2VzID0gcmVkdWNlKGFsbFJ1bGVzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJSdWxlKSB7XG4gICAgICAgIGlmIChjdXJSdWxlLm5hbWUgPT09IHJ1bGUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCAwKTtcbiAgICBpZiAob2NjdXJyZW5jZXMgPiAxKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRPRE86IGlzIHRoZXJlIGFueXdheSB0byBnZXQgb25seSB0aGUgcnVsZSBuYW1lcyBvZiBydWxlcyBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXIgZ3JhbW1hcnM/XG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBJR3JhbW1hckVycm9yUHJvdmlkZXIgYmVjYXVzZSB0aGUgdmFsaWRhdGlvbiBjYW5ub3QgYmUgcGVyZm9ybWVkIG9uXG4vLyBUaGUgZ3JhbW1hciBzdHJ1Y3R1cmUsIG9ubHkgYXQgcnVudGltZS5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4ocnVsZU5hbWUsIGRlZmluZWRSdWxlc05hbWVzLCBjbGFzc05hbWUpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGVyck1zZztcbiAgICBpZiAoIXV0aWxzLmNvbnRhaW5zKGRlZmluZWRSdWxlc05hbWVzLCBydWxlTmFtZSkpIHtcbiAgICAgICAgZXJyTXNnID1cbiAgICAgICAgICAgIFwiSW52YWxpZCBydWxlIG92ZXJyaWRlLCBydWxlOiAtPlwiICsgcnVsZU5hbWUgKyBcIjwtIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHRoZSBncmFtbWFyOiAtPlwiICsgY2xhc3NOYW1lICsgXCI8LVwiICtcbiAgICAgICAgICAgICAgICBcImFzIGl0IGlzIG5vdCBkZWZpbmVkIGluIGFueSBvZiB0aGUgc3VwZXIgZ3JhbW1hcnMgXCI7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX09WRVJSSURFLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKHRvcFJ1bGUsIGN1cnJSdWxlLCBlcnJNc2dQcm92aWRlciwgcGF0aCkge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFtdOyB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBuZXh0Tm9uVGVybWluYWxzID0gZ2V0Rmlyc3ROb25lVGVybWluYWwoY3VyclJ1bGUuZGVmaW5pdGlvbik7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHkobmV4dE5vblRlcm1pbmFscykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gdG9wUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZm91bmRMZWZ0UmVjdXJzaW9uID0gdXRpbHMuY29udGFpbnMobmV4dE5vblRlcm1pbmFscywgdG9wUnVsZSk7XG4gICAgICAgIGlmIChmb3VuZExlZnRSZWN1cnNpb24pIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZExlZnRSZWN1cnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJlY3Vyc2lvblBhdGg6IHBhdGhcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFRlRfUkVDVVJTSU9OLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgYXJlIG9ubHkgbG9va2luZyBmb3IgY3ljbGljIHBhdGhzIGxlYWRpbmcgYmFjayB0byB0aGUgc3BlY2lmaWMgdG9wUnVsZVxuICAgICAgICAvLyBvdGhlciBjeWNsaWMgcGF0aHMgYXJlIGlnbm9yZWQsIHdlIHN0aWxsIG5lZWQgdGhpcyBkaWZmZXJlbmNlIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLi4uXG4gICAgICAgIHZhciB2YWxpZE5leHRTdGVwcyA9IHV0aWxzLmRpZmZlcmVuY2UobmV4dE5vblRlcm1pbmFscywgcGF0aC5jb25jYXQoW3RvcFJ1bGVdKSk7XG4gICAgICAgIHZhciBlcnJvcnNGcm9tTmV4dFN0ZXBzID0gdXRpbHMubWFwKHZhbGlkTmV4dFN0ZXBzLCBmdW5jdGlvbiAoY3VyclJlZlJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gdXRpbHMuY2xvbmVBcnIocGF0aCk7XG4gICAgICAgICAgICBuZXdQYXRoLnB1c2goY3VyclJlZlJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKHRvcFJ1bGUsIGN1cnJSZWZSdWxlLCBlcnJNc2dQcm92aWRlciwgbmV3UGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh1dGlscy5mbGF0dGVuKGVycm9yc0Zyb21OZXh0U3RlcHMpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3ROb25lVGVybWluYWwoZGVmaW5pdGlvbikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAodXRpbHMuaXNFbXB0eShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgZmlyc3RQcm9kID0gdXRpbHMuZmlyc3QoZGVmaW5pdGlvbik7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZmlyc3RQcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmVHQVNUIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChmaXJzdFByb2QuZGVmaW5pdGlvbikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBlYWNoIHN1YiBkZWZpbml0aW9uIGluIGFsdGVybmF0aW9uIGlzIGEgRkxBVFxuICAgICAgICByZXN1bHQgPSB1dGlscy5mbGF0dGVuKHV0aWxzLm1hcChmaXJzdFByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGN1cnJTdWJEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGaXJzdE5vbmVUZXJtaW5hbChjdXJyU3ViRGVmLmRlZmluaXRpb24pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0UHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gc2VlLCBtb3ZlIGFsb25nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbiAgICB2YXIgaXNGaXJzdE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoZmlyc3RQcm9kKTtcbiAgICB2YXIgaGFzTW9yZSA9IGRlZmluaXRpb24ubGVuZ3RoID4gMTtcbiAgICBpZiAoaXNGaXJzdE9wdGlvbmFsICYmIGhhc01vcmUpIHtcbiAgICAgICAgdmFyIHJlc3QgPSB1dGlscy5kcm9wKGRlZmluaXRpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChyZXN0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbnZhciBPckNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3JDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3JDb2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbHRlcm5hdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPckNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpb25zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3JDb2xsZWN0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUodG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIHZhciBvcnMgPSBvckNvbGxlY3Rvci5hbHRlcm5hdGlvbnM7XG4gICAgdmFyIGVycm9ycyA9IHV0aWxzLnJlZHVjZShvcnMsIGZ1bmN0aW9uIChlcnJvcnMsIGN1cnJPcikge1xuICAgICAgICB2YXIgZXhjZXB0TGFzdCA9IHV0aWxzLmRyb3BSaWdodChjdXJyT3IuZGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBjdXJyRXJyb3JzID0gdXRpbHMubWFwKGV4Y2VwdExhc3QsIGZ1bmN0aW9uIChjdXJyQWx0ZXJuYXRpdmUsIGN1cnJBbHRJZHgpIHtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZUZpcnN0SW5BbHQgPSBuZXh0UG9zc2libGVUb2tlbnNBZnRlcihbY3VyckFsdGVybmF0aXZlXSwgW10sIG51bGwsIDEpO1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRW1wdHkocG9zc2libGVGaXJzdEluQWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wTGV2ZWxSdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGN1cnJPcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Q2hvaWNlSWR4OiBjdXJyQWx0SWR4XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PTkVfTEFTVF9FTVBUWV9BTFQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogY3Vyck9yLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGN1cnJBbHRJZHggKyAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodXRpbHMuY29tcGFjdChjdXJyRXJyb3JzKSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyh0b3BMZXZlbFJ1bGUsIGdsb2JhbE1heExvb2thaGVhZCwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIC8vIE5ldyBIYW5kbGluZyBvZiBpZ25vcmluZyBhbWJpZ3VpdGllc1xuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL1NBUC9jaGV2cm90YWluL2lzc3Vlcy84NjlcbiAgICBvcnMgPSByZWplY3Qob3JzLCBmdW5jdGlvbiAoY3Vyck9yKSB7IHJldHVybiBjdXJyT3IuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWU7IH0pO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5yZWR1Y2Uob3JzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyT3IpIHtcbiAgICAgICAgdmFyIGN1cnJPY2N1cnJlbmNlID0gY3Vyck9yLmlkeDtcbiAgICAgICAgdmFyIGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJPci5tYXhMb29rYWhlYWQgfHwgZ2xvYmFsTWF4TG9va2FoZWFkO1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihjdXJyT2NjdXJyZW5jZSwgdG9wTGV2ZWxSdWxlLCBhY3R1YWxNYXhMb29rYWhlYWQsIGN1cnJPcik7XG4gICAgICAgIHZhciBhbHRzQW1iaWd1aXR5RXJyb3JzID0gY2hlY2tBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGN1cnJPciwgdG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIHZhciBhbHRzUHJlZml4QW1iaWd1aXR5RXJyb3JzID0gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGN1cnJPciwgdG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGFsdHNBbWJpZ3VpdHlFcnJvcnMsIGFsdHNQcmVmaXhBbWJpZ3VpdHlFcnJvcnMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxudmFyIFJlcGV0aW9uQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGlvbkNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBSZXBldGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBSZXBldGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGV0aW9uQ29sbGVjdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZXhwb3J0IHsgUmVwZXRpb25Db2xsZWN0b3IgfTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRvb01hbnlBbHRzKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5yZWR1Y2Uob3JzLCBmdW5jdGlvbiAoZXJyb3JzLCBjdXJyT3IpIHtcbiAgICAgICAgaWYgKGN1cnJPci5kZWZpbml0aW9uLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BMZXZlbFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBjdXJyT3JcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRvcExldmVsUnVsZS5uYW1lLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoKHRvcExldmVsUnVsZXMsIG1heExvb2thaGVhZCwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZm9yRWFjaCh0b3BMZXZlbFJ1bGVzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgdmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgUmVwZXRpb25Db2xsZWN0b3IoKTtcbiAgICAgICAgY3VyclRvcFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICB2YXIgYWxsUnVsZVByb2R1Y3Rpb25zID0gY29sbGVjdG9yVmlzaXRvci5hbGxQcm9kdWN0aW9ucztcbiAgICAgICAgZm9yRWFjaChhbGxSdWxlUHJvZHVjdGlvbnMsIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgdmFyIHByb2RUeXBlID0gZ2V0UHJvZFR5cGUoY3VyclByb2QpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCBtYXhMb29rYWhlYWQ7XG4gICAgICAgICAgICB2YXIgY3Vyck9jY3VycmVuY2UgPSBjdXJyUHJvZC5pZHg7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChjdXJyT2NjdXJyZW5jZSwgY3VyclRvcFJ1bGUsIHByb2RUeXBlLCBhY3R1YWxNYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgdmFyIHBhdGhzSW5zaWRlUHJvZHVjdGlvbiA9IHBhdGhzWzBdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoZmxhdHRlbihwYXRoc0luc2lkZVByb2R1Y3Rpb24pKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBjdXJyVG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZXRpdGlvbjogY3VyclByb2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19OT05fRU1QVFlfTE9PS0FIRUFELFxuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogY3VyclRvcFJ1bGUubmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gY2hlY2tBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBmb3VuZEFtYmlndW91c1BhdGhzID0gW107XG4gICAgdmFyIGlkZW50aWNhbEFtYmlndWl0aWVzID0gcmVkdWNlKGFsdGVybmF0aXZlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgY3VyckFsdElkeCkge1xuICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAoYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyQWx0SWR4XS5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgdmFyIGFsdHNDdXJyUGF0aEFwcGVhcnNJbiA9IFtjdXJyQWx0SWR4XTtcbiAgICAgICAgICAgIGZvckVhY2goYWx0ZXJuYXRpdmVzLCBmdW5jdGlvbiAoY3Vyck90aGVyQWx0LCBjdXJyT3RoZXJBbHRJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckFsdElkeCAhPT0gY3Vyck90aGVyQWx0SWR4ICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zUGF0aChjdXJyT3RoZXJBbHQsIGN1cnJQYXRoKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBcIm90aGVyXCIgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyT3RoZXJBbHRJZHhdLmlnbm9yZUFtYmlndWl0aWVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdHNDdXJyUGF0aEFwcGVhcnNJbi5wdXNoKGN1cnJPdGhlckFsdElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWx0c0N1cnJQYXRoQXBwZWFyc0luLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnNQYXRoKGZvdW5kQW1iaWd1b3VzUGF0aHMsIGN1cnJQYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kQW1iaWd1b3VzUGF0aHMucHVzaChjdXJyUGF0aCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhbHRzOiBhbHRzQ3VyclBhdGhBcHBlYXJzSW4sXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN1cnJQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgY3VyckVycm9ycyA9IHV0aWxzLm1hcChpZGVudGljYWxBbWJpZ3VpdGllcywgZnVuY3Rpb24gKGN1cnJBbWJEZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBhbWJnSW5kaWNlcyA9IG1hcChjdXJyQW1iRGVzY3JpcHRvci5hbHRzLCBmdW5jdGlvbiAoY3VyckFsdElkeCkgeyByZXR1cm4gY3VyckFsdElkeCArIDE7IH0pO1xuICAgICAgICB2YXIgY3Vyck1lc3NhZ2UgPSBlcnJNc2dQcm92aWRlci5idWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgYW1iaWd1aXR5SW5kaWNlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICBwcmVmaXhQYXRoOiBjdXJyQW1iRGVzY3JpcHRvci5wYXRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogY3Vyck1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19BTFRTLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IGFsdGVybmF0aW9uLmlkeCxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlczogW2N1cnJBbWJEZXNjcmlwdG9yLmFsdHNdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAvLyBmbGF0dGVuXG4gICAgdmFyIHBhdGhzQW5kSW5kaWNlcyA9IHJlZHVjZShhbHRlcm5hdGl2ZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkge1xuICAgICAgICB2YXIgY3VyclBhdGhzQW5kSWR4ID0gbWFwKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWR4OiBpZHgsIHBhdGg6IGN1cnJQYXRoIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJyUGF0aHNBbmRJZHgpO1xuICAgIH0sIFtdKTtcbiAgICBmb3JFYWNoKHBhdGhzQW5kSW5kaWNlcywgZnVuY3Rpb24gKGN1cnJQYXRoQW5kSWR4KSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZUdhc3QgPSBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJQYXRoQW5kSWR4LmlkeF07XG4gICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIGFsdGVybmF0aXZlXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZUdhc3QuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0SWR4ID0gY3VyclBhdGhBbmRJZHguaWR4O1xuICAgICAgICB2YXIgdGFyZ2V0UGF0aCA9IGN1cnJQYXRoQW5kSWR4LnBhdGg7XG4gICAgICAgIHZhciBwcmVmaXhBbWJpZ3VpdGllc1BhdGhzQW5kSW5kaWNlcyA9IGZpbmRBbGwocGF0aHNBbmRJbmRpY2VzLCBmdW5jdGlvbiAoc2VhcmNoUGF0aEFuZElkeCkge1xuICAgICAgICAgICAgLy8gcHJlZml4IGFtYmlndWl0eSBjYW4gb25seSBiZSBjcmVhdGVkIGZyb20gbG93ZXIgaWR4IChoaWdoZXIgcHJpb3JpdHkpIHBhdGhcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBcIm90aGVyXCIgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIGFsdGVybmF0aW9uLmRlZmluaXRpb25bc2VhcmNoUGF0aEFuZElkeC5pZHhdLmlnbm9yZUFtYmlndWl0aWVzICE9PVxuICAgICAgICAgICAgICAgIHRydWUgJiZcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRoQW5kSWR4LmlkeCA8IHRhcmdldElkeCAmJlxuICAgICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZvciBzdHJpY3QgcHJlZml4IGJlY2F1c2UgaWRlbnRpY2FsIGxvb2thaGVhZHNcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGJlIGRldGVjdGVkIHVzaW5nIGEgZGlmZmVyZW50IHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgaXNTdHJpY3RQcmVmaXhPZlBhdGgoc2VhcmNoUGF0aEFuZElkeC5wYXRoLCB0YXJnZXRQYXRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VyclBhdGhQcmVmaXhFcnJvcnMgPSBtYXAocHJlZml4QW1iaWd1aXRpZXNQYXRoc0FuZEluZGljZXMsIGZ1bmN0aW9uIChjdXJyQW1iUGF0aEFuZElkeCkge1xuICAgICAgICAgICAgdmFyIGFtYmdJbmRpY2VzID0gW2N1cnJBbWJQYXRoQW5kSWR4LmlkeCArIDEsIHRhcmdldElkeCArIDFdO1xuICAgICAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBhbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogYWx0ZXJuYXRpb24uaWR4O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJNc2dQcm92aWRlci5idWlsZEFsdGVybmF0aW9uUHJlZml4QW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogcnVsZSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICAgICAgYW1iaWd1aXR5SW5kaWNlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICAgICAgcHJlZml4UGF0aDogY3VyckFtYlBhdGhBbmRJZHgucGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfUFJFRklYX0FMVFMsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlOiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogYW1iZ0luZGljZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGN1cnJQYXRoUHJlZml4RXJyb3JzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdG9rZW5OYW1lcyA9IG1hcCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva2VuKSB7IHJldHVybiBjdXJyVG9rZW4ubmFtZTsgfSk7XG4gICAgZm9yRWFjaCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICB2YXIgY3VyclJ1bGVOYW1lID0gY3VyclJ1bGUubmFtZTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRva2VuTmFtZXMsIGN1cnJSdWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3IoY3VyclJ1bGUpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0UsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJSdWxlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   firstForBranching: () => (/* binding */ firstForBranching),\n/* harmony export */   firstForSequence: () => (/* binding */ firstForSequence),\n/* harmony export */   firstForTerminal: () => (/* binding */ firstForTerminal)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if ((0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isSequenceProd)(prod)) {\n        return firstForSequence(prod);\n    }\n    else if ((0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isBranchingProd)(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isOptionalProd)(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)(firstSet);\n}\nfunction firstForBranching(prod) {\n    var allAlternativesFirsts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(allAlternativesFirsts));\n}\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZmlyc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1RDtBQUNJO0FBQ21CO0FBQ3ZFO0FBQ1A7QUFDQSx3QkFBd0IsMERBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQVE7QUFDckM7QUFDQTtBQUNBLGFBQWEsMERBQWM7QUFDM0I7QUFDQTtBQUNBLGFBQWEsMkRBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQUk7QUFDZjtBQUNPO0FBQ1AsZ0NBQWdDLGlEQUFHO0FBQ25DO0FBQ0EsS0FBSztBQUNMLFdBQVcsa0RBQUksQ0FBQyxxREFBTztBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxwYXJzZVxcZ3JhbW1hclxcZmlyc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5pcSwgbWFwLCBmbGF0dGVuIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBOb25UZXJtaW5hbCwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBpc0JyYW5jaGluZ1Byb2QsIGlzT3B0aW9uYWxQcm9kLCBpc1NlcXVlbmNlUHJvZCB9IGZyb20gXCIuL2dhc3QvZ2FzdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBpbiB0aGVvcnkgY2F1c2UgaW5maW5pdGUgbG9vcHMgaWZcbiAgICAgICAgLy8gKDEpIHByb2QgQSByZWZzIHByb2QgQi5cbiAgICAgICAgLy8gKDIpIHByb2QgQiByZWZzIHByb2QgQVxuICAgICAgICAvLyAoMykgQUIgY2FuIG1hdGNoIHRoZSBlbXB0eSBzZXRcbiAgICAgICAgLy8gaW4gb3RoZXIgd29yZHMgYSBjeWNsZSB3aGVyZSBldmVyeXRoaW5nIGlzIG9wdGlvbmFsIHNvIHRoZSBmaXJzdCB3aWxsIGtlZXBcbiAgICAgICAgLy8gbG9va2luZyBhaGVhZCBmb3IgdGhlIG5leHQgb3B0aW9uYWwgcGFydCBhbmQgd2lsbCBuZXZlciBleGl0XG4gICAgICAgIC8vIGN1cnJlbnRseSB0aGVyZSBpcyBubyBzYWZlZ3VhcmQgZm9yIHRoaXMgdW5pcXVlIGVkZ2UgY2FzZSBiZWNhdXNlXG4gICAgICAgIC8vICgxKSBub3Qgc3VyZSBhIGdyYW1tYXIgaW4gd2hpY2ggdGhpcyBjYW4gaGFwcGVuIGlzIHVzZWZ1bCBmb3IgYW55dGhpbmcgKHByb2R1Y3RpdmUpXG4gICAgICAgIHJldHVybiBmaXJzdChwcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEZvclRlcm1pbmFsKHByb2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NlcXVlbmNlUHJvZChwcm9kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JTZXF1ZW5jZShwcm9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCcmFuY2hpbmdQcm9kKHByb2QpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEZvckJyYW5jaGluZyhwcm9kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCkge1xuICAgIHZhciBmaXJzdFNldCA9IFtdO1xuICAgIHZhciBzZXEgPSBwcm9kLmRlZmluaXRpb247XG4gICAgdmFyIG5leHRTdWJQcm9kSWR4ID0gMDtcbiAgICB2YXIgaGFzSW5uZXJQcm9kc1JlbWFpbmluZyA9IHNlcS5sZW5ndGggPiBuZXh0U3ViUHJvZElkeDtcbiAgICB2YXIgY3VyclN1YlByb2Q7XG4gICAgLy8gc28gd2UgZW50ZXIgdGhlIGxvb3AgYXQgbGVhc3Qgb25jZSAoaWYgdGhlIGRlZmluaXRpb24gaXMgbm90IGVtcHR5XG4gICAgdmFyIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsID0gdHJ1ZTtcbiAgICAvLyBzY2FuIGEgc2VxdWVuY2UgdW50aWwgaXQncyBlbmQgb3IgdW50aWwgd2UgaGF2ZSBmb3VuZCBhIE5PTkUgb3B0aW9uYWwgcHJvZHVjdGlvbiBpbiBpdFxuICAgIHdoaWxlIChoYXNJbm5lclByb2RzUmVtYWluaW5nICYmIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsKSB7XG4gICAgICAgIGN1cnJTdWJQcm9kID0gc2VxW25leHRTdWJQcm9kSWR4XTtcbiAgICAgICAgaXNMYXN0SW5uZXJQcm9kT3B0aW9uYWwgPSBpc09wdGlvbmFsUHJvZChjdXJyU3ViUHJvZCk7XG4gICAgICAgIGZpcnN0U2V0ID0gZmlyc3RTZXQuY29uY2F0KGZpcnN0KGN1cnJTdWJQcm9kKSk7XG4gICAgICAgIG5leHRTdWJQcm9kSWR4ID0gbmV4dFN1YlByb2RJZHggKyAxO1xuICAgICAgICBoYXNJbm5lclByb2RzUmVtYWluaW5nID0gc2VxLmxlbmd0aCA+IG5leHRTdWJQcm9kSWR4O1xuICAgIH1cbiAgICByZXR1cm4gdW5pcShmaXJzdFNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RGb3JCcmFuY2hpbmcocHJvZCkge1xuICAgIHZhciBhbGxBbHRlcm5hdGl2ZXNGaXJzdHMgPSBtYXAocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoaW5uZXJQcm9kKSB7XG4gICAgICAgIHJldHVybiBmaXJzdChpbm5lclByb2QpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmlxKGZsYXR0ZW4oYWxsQWx0ZXJuYXRpdmVzRmlyc3RzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RGb3JUZXJtaW5hbCh0ZXJtaW5hbCkge1xuICAgIHJldHVybiBbdGVybWluYWwudGVybWluYWxUeXBlXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResyncFollowsWalker: () => (/* binding */ ResyncFollowsWalker),\n/* harmony export */   buildBetweenProdsFollowPrefix: () => (/* binding */ buildBetweenProdsFollowPrefix),\n/* harmony export */   buildInProdFollowPrefix: () => (/* binding */ buildInProdFollowPrefix),\n/* harmony export */   computeAllProdsFollows: () => (/* binding */ computeAllProdsFollows)\n/* harmony export */ });\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./first */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/constants.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nvar ResyncFollowsWalker = /** @class */ (function (_super) {\n    __extends(ResyncFollowsWalker, _super);\n    function ResyncFollowsWalker(topProd) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.follows = {};\n        return _this;\n    }\n    ResyncFollowsWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.follows;\n    };\n    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    };\n    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        var fullRest = currRest.concat(prevRest);\n        var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Alternative({ definition: fullRest });\n        var t_in_topProd_follows = (0,_first__WEBPACK_IMPORTED_MODULE_1__.first)(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    };\n    return ResyncFollowsWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));\n\nfunction computeAllProdsFollows(topProductions) {\n    var reSyncFollows = {};\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(topProductions, function (topProd) {\n        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.assign)(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + _constants__WEBPACK_IMPORTED_MODULE_3__.IN;\n}\nfunction buildInProdFollowPrefix(terminal) {\n    var terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + _constants__WEBPACK_IMPORTED_MODULE_3__.IN;\n}\n//# sourceMappingURL=follow.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZm9sbG93LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDbUM7QUFDSjtBQUNvQjtBQUNsQjtBQUNlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBVyxHQUFHLHNCQUFzQjtBQUMvRCxtQ0FBbUMsNkNBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDZDQUFVO0FBQ21CO0FBQ3hCO0FBQ1A7QUFDQSxJQUFJLHFEQUFPO0FBQ1g7QUFDQSxRQUFRLG9EQUFNO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLDRDQUE0QywwQ0FBRTtBQUM5QztBQUNPO0FBQ1A7QUFDQSx5Q0FBeUMsMENBQUU7QUFDM0M7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGZvbGxvdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgUmVzdFdhbGtlciB9IGZyb20gXCIuL3Jlc3RcIjtcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSBcIi4vZmlyc3RcIjtcbmltcG9ydCB7IGFzc2lnbiwgZm9yRWFjaCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgSU4gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGl2ZSB9IGZyb20gXCIuL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbi8vIFRoaXMgUmVzeW5jRm9sbG93c1dhbGtlciBjb21wdXRlcyBhbGwgb2YgdGhlIGZvbGxvd3MgcmVxdWlyZWQgZm9yIFJFU1lOQ1xuLy8gKHNraXBwaW5nIHJlZmVyZW5jZSBwcm9kdWN0aW9uKS5cbnZhciBSZXN5bmNGb2xsb3dzV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN5bmNGb2xsb3dzV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3luY0ZvbGxvd3NXYWxrZXIodG9wUHJvZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgX3RoaXMuZm9sbG93cyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc3luY0ZvbGxvd3NXYWxrZXIucHJvdG90eXBlLnN0YXJ0V2Fsa2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGxvd3M7XG4gICAgfTtcbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS53YWxrVGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nISBqdXN0IGxpa2UgaW4gdGhlIHB1YmxpYyBzZWN0b3IgYWZ0ZXIgMTM6MDBcbiAgICB9O1xuICAgIFJlc3luY0ZvbGxvd3NXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgZm9sbG93TmFtZSA9IGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KHJlZlByb2QucmVmZXJlbmNlZFJ1bGUsIHJlZlByb2QuaWR4KSArXG4gICAgICAgICAgICB0aGlzLnRvcFByb2QubmFtZTtcbiAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgdmFyIHJlc3RQcm9kID0gbmV3IEFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgIHZhciB0X2luX3RvcFByb2RfZm9sbG93cyA9IGZpcnN0KHJlc3RQcm9kKTtcbiAgICAgICAgdGhpcy5mb2xsb3dzW2ZvbGxvd05hbWVdID0gdF9pbl90b3BQcm9kX2ZvbGxvd3M7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzeW5jRm9sbG93c1dhbGtlcjtcbn0oUmVzdFdhbGtlcikpO1xuZXhwb3J0IHsgUmVzeW5jRm9sbG93c1dhbGtlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModG9wUHJvZHVjdGlvbnMpIHtcbiAgICB2YXIgcmVTeW5jRm9sbG93cyA9IHt9O1xuICAgIGZvckVhY2godG9wUHJvZHVjdGlvbnMsIGZ1bmN0aW9uICh0b3BQcm9kKSB7XG4gICAgICAgIHZhciBjdXJyUmVmc0ZvbGxvdyA9IG5ldyBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICBhc3NpZ24ocmVTeW5jRm9sbG93cywgY3VyclJlZnNGb2xsb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZVN5bmNGb2xsb3dzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KGlubmVyLCBvY2N1cmVuY2VJblBhcmVudCkge1xuICAgIHJldHVybiBpbm5lci5uYW1lICsgb2NjdXJlbmNlSW5QYXJlbnQgKyBJTjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEluUHJvZEZvbGxvd1ByZWZpeCh0ZXJtaW5hbCkge1xuICAgIHZhciB0ZXJtaW5hbE5hbWUgPSB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICByZXR1cm4gdGVybWluYWxOYW1lICsgdGVybWluYWwuaWR4ICsgSU47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2xsb3cuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DslMethodsCollectorVisitor: () => (/* binding */ DslMethodsCollectorVisitor),\n/* harmony export */   collectMethods: () => (/* binding */ collectMethods),\n/* harmony export */   getProductionDslName: () => (/* binding */ getProductionDslName),\n/* harmony export */   isBranchingProd: () => (/* binding */ isBranchingProd),\n/* harmony export */   isOptionalProd: () => (/* binding */ isOptionalProd),\n/* harmony export */   isSequenceProd: () => (/* binding */ isSequenceProd)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast_visitor_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nfunction isSequenceProd(prod) {\n    return (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternative ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Rule);\n}\nfunction isOptionalProd(prod, alreadyVisited) {\n    if (alreadyVisited === void 0) { alreadyVisited = []; }\n    var isDirectlyOptional = prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.some)(prod.definition, function (subProd) {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal && (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.AbstractProduction) {\n        if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(prod.definition, function (subProd) {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nfunction isBranchingProd(prod) {\n    return prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation;\n}\nfunction getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nvar DslMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(DslMethodsCollectorVisitor, _super);\n    function DslMethodsCollectorVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // A minus is never valid in an identifier name\n        _this.separator = \"-\";\n        _this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n        return _this;\n    }\n    DslMethodsCollectorVisitor.prototype.reset = function () {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    };\n    DslMethodsCollectorVisitor.prototype.visitTerminal = function (terminal) {\n        var key = terminal.terminalType.name + this.separator + \"Terminal\";\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(this.dslMethods, key)) {\n            this.dslMethods[key] = [];\n        }\n        this.dslMethods[key].push(terminal);\n    };\n    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function (subrule) {\n        var key = subrule.nonTerminalName + this.separator + \"Terminal\";\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(this.dslMethods, key)) {\n            this.dslMethods[key] = [];\n        }\n        this.dslMethods[key].push(subrule);\n    };\n    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n        this.dslMethods.option.push(option);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n        this.dslMethods.repetition.push(many);\n    };\n    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n        this.dslMethods.alternation.push(or);\n    };\n    return DslMethodsCollectorVisitor;\n}(_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__.GAstVisitor));\n\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    var dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=gast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDaUU7QUFDNEk7QUFDMUo7QUFDN0M7QUFDUCw0QkFBNEIscURBQVc7QUFDdkMsd0JBQXdCLGdEQUFNO0FBQzlCLHdCQUF3QixvREFBVTtBQUNsQyx3QkFBd0IsNkRBQW1CO0FBQzNDLHdCQUF3QiwwRUFBZ0M7QUFDeEQsd0JBQXdCLGlFQUF1QjtBQUMvQyx3QkFBd0Isa0RBQVE7QUFDaEMsd0JBQXdCLDhDQUFJO0FBQzVCO0FBQ087QUFDUCxxQ0FBcUM7QUFDckMsNkNBQTZDLGdEQUFNO0FBQ25ELHdCQUF3QixvREFBVTtBQUNsQyx3QkFBd0IsaUVBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBVztBQUNuQztBQUNBLGVBQWUsa0RBQUk7QUFDbkI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIscURBQVcsSUFBSSxzREFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNERBQWtCO0FBQy9DLDRCQUE0QixxREFBVztBQUN2QztBQUNBO0FBQ0EsZUFBZSxtREFBSztBQUNwQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwyQkFBMkIscURBQVc7QUFDdEM7QUFDTztBQUNQO0FBQ0Esd0JBQXdCLHFEQUFXO0FBQ25DO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQU07QUFDbkM7QUFDQTtBQUNBLDZCQUE2QixxREFBVztBQUN4QztBQUNBO0FBQ0EsNkJBQTZCLDZEQUFtQjtBQUNoRDtBQUNBO0FBQ0EsNkJBQTZCLDBFQUFnQztBQUM3RDtBQUNBO0FBQ0EsNkJBQTZCLGlFQUF1QjtBQUNwRDtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFVO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw2REFBVztBQUN5QjtBQUN0QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGdhc3RcXGdhc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IGNvbnRhaW5zLCBldmVyeSwgaGFzLCBzb21lIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb2R1Y3Rpb24sIEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1NlcXVlbmNlUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUnVsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPcHRpb25hbFByb2QocHJvZCwgYWxyZWFkeVZpc2l0ZWQpIHtcbiAgICBpZiAoYWxyZWFkeVZpc2l0ZWQgPT09IHZvaWQgMCkgeyBhbHJlYWR5VmlzaXRlZCA9IFtdOyB9XG4gICAgdmFyIGlzRGlyZWN0bHlPcHRpb25hbCA9IHByb2QgaW5zdGFuY2VvZiBPcHRpb24gfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24gfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yO1xuICAgIGlmIChpc0RpcmVjdGx5T3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIG5vdGUgdGhhdCB0aGlzIGNhbiBjYXVzZSBpbmZpbml0ZSBsb29wIGlmIG9uZSBvcHRpb25hbCBlbXB0eSBUT1AgcHJvZHVjdGlvbiBoYXMgYSBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIGFub3RoZXJcbiAgICAvLyBlbXB0eSBvcHRpb25hbCB0b3AgcnVsZVxuICAgIC8vIG1heSBiZSBpbmRpcmVjdGx5IG9wdGlvbmFsICgoQT9CP0M/KSB8IChEP0U/Rj8pKVxuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgLy8gZm9yIE9SIGl0cyBlbm91Z2ggZm9yIGp1c3Qgb25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgdG8gYmUgb3B0aW9uYWxcbiAgICAgICAgcmV0dXJuIHNvbWUocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoc3ViUHJvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWxQcm9kKHN1YlByb2QsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCAmJiBjb250YWlucyhhbHJlYWR5VmlzaXRlZCwgcHJvZCkpIHtcbiAgICAgICAgLy8gYXZvaWRpbmcgc3RhY2sgb3ZlcmZsb3cgZHVlIHRvIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBYnN0cmFjdFByb2R1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgYWxyZWFkeVZpc2l0ZWQucHVzaChwcm9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlcnkocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoc3ViUHJvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWxQcm9kKHN1YlByb2QsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJhbmNoaW5nUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9kdWN0aW9uRHNsTmFtZShwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBcIlNVQlJVTEVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gXCJPUFRJT05cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9SXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiBcIkFUX0xFQVNUX09ORVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiTUFOWV9TRVBcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiTUFOWVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiQ09OU1VNRVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG52YXIgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gQSBtaW51cyBpcyBuZXZlciB2YWxpZCBpbiBhbiBpZGVudGlmaWVyIG5hbWVcbiAgICAgICAgX3RoaXMuc2VwYXJhdG9yID0gXCItXCI7XG4gICAgICAgIF90aGlzLmRzbE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBvcHRpb246IFtdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uV2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5OiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzID0ge1xuICAgICAgICAgICAgb3B0aW9uOiBbXSxcbiAgICAgICAgICAgIGFsdGVybmF0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeTogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHZhciBrZXkgPSB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZSArIHRoaXMuc2VwYXJhdG9yICsgXCJUZXJtaW5hbFwiO1xuICAgICAgICBpZiAoIWhhcyh0aGlzLmRzbE1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZHNsTWV0aG9kc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0ucHVzaCh0ZXJtaW5hbCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbCA9IGZ1bmN0aW9uIChzdWJydWxlKSB7XG4gICAgICAgIHZhciBrZXkgPSBzdWJydWxlLm5vblRlcm1pbmFsTmFtZSArIHRoaXMuc2VwYXJhdG9yICsgXCJUZXJtaW5hbFwiO1xuICAgICAgICBpZiAoIWhhcyh0aGlzLmRzbE1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZHNsTWV0aG9kc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0ucHVzaChzdWJydWxlKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLm9wdGlvbi5wdXNoKG9wdGlvbik7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChtYW55U2VwKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uV2l0aFNlcGFyYXRvci5wdXNoKG1hbnlTZXApO1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChhdExlYXN0T25lKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uTWFuZGF0b3J5LnB1c2goYXRMZWFzdE9uZSk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvci5wdXNoKGF0TGVhc3RPbmVTZXApO1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChtYW55KSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uLnB1c2gobWFueSk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChvcikge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMuYWx0ZXJuYXRpb24ucHVzaChvcik7XG4gICAgfTtcbiAgICByZXR1cm4gRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgeyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciB9O1xudmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoKTtcbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0TWV0aG9kcyhydWxlKSB7XG4gICAgY29sbGVjdG9yVmlzaXRvci5yZXNldCgpO1xuICAgIHJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgIHZhciBkc2xNZXRob2RzID0gY29sbGVjdG9yVmlzaXRvci5kc2xNZXRob2RzO1xuICAgIC8vIGF2b2lkIHVuY2xlYW5lZCByZWZlcmVuY2VzXG4gICAgY29sbGVjdG9yVmlzaXRvci5yZXNldCgpO1xuICAgIHJldHVybiBkc2xNZXRob2RzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProduction: () => (/* binding */ AbstractProduction),\n/* harmony export */   Alternation: () => (/* binding */ Alternation),\n/* harmony export */   Alternative: () => (/* binding */ Alternative),\n/* harmony export */   NonTerminal: () => (/* binding */ NonTerminal),\n/* harmony export */   Option: () => (/* binding */ Option),\n/* harmony export */   Repetition: () => (/* binding */ Repetition),\n/* harmony export */   RepetitionMandatory: () => (/* binding */ RepetitionMandatory),\n/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* binding */ RepetitionMandatoryWithSeparator),\n/* harmony export */   RepetitionWithSeparator: () => (/* binding */ RepetitionWithSeparator),\n/* harmony export */   Rule: () => (/* binding */ Rule),\n/* harmony export */   Terminal: () => (/* binding */ Terminal),\n/* harmony export */   serializeGrammar: () => (/* binding */ serializeGrammar),\n/* harmony export */   serializeProduction: () => (/* binding */ serializeProduction)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar AbstractProduction = /** @class */ (function () {\n    function AbstractProduction(_definition) {\n        this._definition = _definition;\n    }\n    Object.defineProperty(AbstractProduction.prototype, \"definition\", {\n        get: function () {\n            return this._definition;\n        },\n        set: function (value) {\n            this._definition = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    AbstractProduction.prototype.accept = function (visitor) {\n        visitor.visit(this);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(this.definition, function (prod) {\n            prod.accept(visitor);\n        });\n    };\n    return AbstractProduction;\n}());\n\nvar NonTerminal = /** @class */ (function (_super) {\n    __extends(NonTerminal, _super);\n    function NonTerminal(options) {\n        var _this = _super.call(this, []) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    Object.defineProperty(NonTerminal.prototype, \"definition\", {\n        get: function () {\n            if (this.referencedRule !== undefined) {\n                return this.referencedRule.definition;\n            }\n            return [];\n        },\n        set: function (definition) {\n            // immutable\n        },\n        enumerable: false,\n        configurable: true\n    });\n    NonTerminal.prototype.accept = function (visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    };\n    return NonTerminal;\n}(AbstractProduction));\n\nvar Rule = /** @class */ (function (_super) {\n    __extends(Rule, _super);\n    function Rule(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.orgText = \"\";\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Rule;\n}(AbstractProduction));\n\nvar Alternative = /** @class */ (function (_super) {\n    __extends(Alternative, _super);\n    function Alternative(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.ignoreAmbiguities = false;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Alternative;\n}(AbstractProduction));\n\nvar Option = /** @class */ (function (_super) {\n    __extends(Option, _super);\n    function Option(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Option;\n}(AbstractProduction));\n\nvar RepetitionMandatory = /** @class */ (function (_super) {\n    __extends(RepetitionMandatory, _super);\n    function RepetitionMandatory(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionMandatory;\n}(AbstractProduction));\n\nvar RepetitionMandatoryWithSeparator = /** @class */ (function (_super) {\n    __extends(RepetitionMandatoryWithSeparator, _super);\n    function RepetitionMandatoryWithSeparator(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionMandatoryWithSeparator;\n}(AbstractProduction));\n\nvar Repetition = /** @class */ (function (_super) {\n    __extends(Repetition, _super);\n    function Repetition(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Repetition;\n}(AbstractProduction));\n\nvar RepetitionWithSeparator = /** @class */ (function (_super) {\n    __extends(RepetitionWithSeparator, _super);\n    function RepetitionWithSeparator(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionWithSeparator;\n}(AbstractProduction));\n\nvar Alternation = /** @class */ (function (_super) {\n    __extends(Alternation, _super);\n    function Alternation(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        _this.ignoreAmbiguities = false;\n        _this.hasPredicates = false;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    Object.defineProperty(Alternation.prototype, \"definition\", {\n        get: function () {\n            return this._definition;\n        },\n        set: function (value) {\n            this._definition = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Alternation;\n}(AbstractProduction));\n\nvar Terminal = /** @class */ (function () {\n    function Terminal(options) {\n        this.idx = 1;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));\n    }\n    Terminal.prototype.accept = function (visitor) {\n        visitor.visit(this);\n    };\n    return Terminal;\n}());\n\nfunction serializeGrammar(topRules) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topRules, serializeProduction);\n}\nfunction serializeProduction(node) {\n    function convertDefinition(definition) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        return {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx\n        };\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Terminal) {\n        var serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__.tokenLabel)(node.terminalType),\n            idx: node.idx\n        };\n        var pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=gast_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzJFO0FBQ25CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSxxREFBTztBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQzZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTSxRQUFRLGtEQUFJLHlCQUF5Qix5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2lCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzJDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFNLFFBQVEsa0RBQUkseUJBQXlCLHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2tDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTSxRQUFRLGtEQUFJLHlCQUF5Qix5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ3NCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU0sT0FBTyxrREFBSSx5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21CO0FBQ2I7QUFDUCxXQUFXLGlEQUFHO0FBQ2Q7QUFDTztBQUNQO0FBQ0EsZUFBZSxpREFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsOEJBQThCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDhCQUE4QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0RBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxwYXJzZVxcZ3JhbW1hclxcZ2FzdFxcZ2FzdF9wdWJsaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IGFzc2lnbiwgZm9yRWFjaCwgaXNSZWdFeHAsIG1hcCwgcGljayB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgdG9rZW5MYWJlbCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbnZhciBBYnN0cmFjdFByb2R1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RQcm9kdWN0aW9uKF9kZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBfZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0UHJvZHVjdGlvbi5wcm90b3R5cGUsIFwiZGVmaW5pdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdFByb2R1Y3Rpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXQodGhpcyk7XG4gICAgICAgIGZvckVhY2godGhpcy5kZWZpbml0aW9uLCBmdW5jdGlvbiAocHJvZCkge1xuICAgICAgICAgICAgcHJvZC5hY2NlcHQodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0UHJvZHVjdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBBYnN0cmFjdFByb2R1Y3Rpb24gfTtcbnZhciBOb25UZXJtaW5hbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9uVGVybWluYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9uVGVybWluYWwob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbXSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uVGVybWluYWwucHJvdG90eXBlLCBcImRlZmluaXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZWRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VkUnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAvLyBpbW11dGFibGVcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vblRlcm1pbmFsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgICAgICAvLyBkb24ndCB2aXNpdCBjaGlsZHJlbiBvZiBhIHJlZmVyZW5jZSwgd2Ugd2lsbCBnZXQgY3ljbGljIGluZmluaXRlIGxvb3BzIGlmIHdlIGRvIHNvXG4gICAgfTtcbiAgICByZXR1cm4gTm9uVGVybWluYWw7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgTm9uVGVybWluYWwgfTtcbnZhciBSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSdWxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJ1bGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9yZ1RleHQgPSBcIlwiO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSdWxlO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJ1bGUgfTtcbnZhciBBbHRlcm5hdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWx0ZXJuYXRpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWx0ZXJuYXRpdmUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlnbm9yZUFtYmlndWl0aWVzID0gZmFsc2U7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFsdGVybmF0aXZlO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IEFsdGVybmF0aXZlIH07XG52YXIgT3B0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3B0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBPcHRpb247XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgT3B0aW9uIH07XG52YXIgUmVwZXRpdGlvbk1hbmRhdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpdGlvbk1hbmRhdG9yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGl0aW9uTWFuZGF0b3J5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXBldGl0aW9uTWFuZGF0b3J5O1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJlcGV0aXRpb25NYW5kYXRvcnkgfTtcbnZhciBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIH07XG52YXIgUmVwZXRpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGl0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXBldGl0aW9uO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJlcGV0aXRpb24gfTtcbnZhciBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIH07XG52YXIgQWx0ZXJuYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFsdGVybmF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsdGVybmF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBfdGhpcy5pZ25vcmVBbWJpZ3VpdGllcyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5oYXNQcmVkaWNhdGVzID0gZmFsc2U7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFsdGVybmF0aW9uLnByb3RvdHlwZSwgXCJkZWZpbml0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBBbHRlcm5hdGlvbjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBBbHRlcm5hdGlvbiB9O1xudmFyIFRlcm1pbmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgfVxuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlcm1pbmFsO1xufSgpKTtcbmV4cG9ydCB7IFRlcm1pbmFsIH07XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplR3JhbW1hcih0b3BSdWxlcykge1xuICAgIHJldHVybiBtYXAodG9wUnVsZXMsIHNlcmlhbGl6ZVByb2R1Y3Rpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVByb2R1Y3Rpb24obm9kZSkge1xuICAgIGZ1bmN0aW9uIGNvbnZlcnREZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG1hcChkZWZpbml0aW9uLCBzZXJpYWxpemVQcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk5vblRlcm1pbmFsXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFsdGVybmF0aXZlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT3B0aW9uXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uTWFuZGF0b3J5XCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3JcIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBzZXBhcmF0b3I6IChzZXJpYWxpemVQcm9kdWN0aW9uKG5ldyBUZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogbm9kZS5zZXBhcmF0b3IgfSkpKSxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc2VyaWFsaXplUHJvZHVjdGlvbihuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IG5vZGUuc2VwYXJhdG9yIH0pKSksXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25cIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBbHRlcm5hdGlvblwiLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkVGVybWluYWwgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIlRlcm1pbmFsXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLnRlcm1pbmFsVHlwZS5uYW1lLFxuICAgICAgICAgICAgbGFiZWw6IHRva2VuTGFiZWwobm9kZS50ZXJtaW5hbFR5cGUpLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGF0dGVybiA9IG5vZGUudGVybWluYWxUeXBlLlBBVFRFUk47XG4gICAgICAgIGlmIChub2RlLnRlcm1pbmFsVHlwZS5QQVRURVJOKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkVGVybWluYWwucGF0dGVybiA9IGlzUmVnRXhwKHBhdHRlcm4pXG4gICAgICAgICAgICAgICAgPyBwYXR0ZXJuLnNvdXJjZVxuICAgICAgICAgICAgICAgIDogcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZFRlcm1pbmFsO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUnVsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSdWxlXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBvcmdUZXh0OiBub2RlLm9yZ1RleHQsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfcHVibGljLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignOccurrenceIndices: () => (/* binding */ assignOccurrenceIndices),\n/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar),\n/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _resolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resolver */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js\");\n/* harmony import */ var _checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../checks */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\n\n\nfunction resolveGrammar(options) {\n    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.defaults)(options, {\n        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarResolverErrorProvider\n    });\n    var topRulesTable = {};\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(options.rules, function (rule) {\n        topRulesTable[rule.name] = rule;\n    });\n    return (0,_resolver__WEBPACK_IMPORTED_MODULE_1__.resolveGrammar)(topRulesTable, options.errMsgProvider);\n}\nfunction validateGrammar(options) {\n    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.defaults)(options, {\n        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider\n    });\n    return (0,_checks__WEBPACK_IMPORTED_MODULE_2__.validateGrammar)(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\nfunction assignOccurrenceIndices(options) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(options.rules, function (currRule) {\n        var methodsCollector = new _gast__WEBPACK_IMPORTED_MODULE_4__.DslMethodsCollectorVisitor();\n        currRule.accept(methodsCollector);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(methodsCollector.dslMethods, function (methods) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(methods, function (currMethod, arrIdx) {\n                currMethod.idx = arrIdx + 1;\n            });\n        });\n    });\n}\n//# sourceMappingURL=gast_resolver_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5RDtBQUNTO0FBQ0E7QUFDOEM7QUFDNUQ7QUFDN0M7QUFDUCxjQUFjLHNEQUFRO0FBQ3RCLHdCQUF3QiwrRUFBbUM7QUFDM0QsS0FBSztBQUNMO0FBQ0EsSUFBSSxxREFBTztBQUNYO0FBQ0EsS0FBSztBQUNMLFdBQVcseURBQWlCO0FBQzVCO0FBQ087QUFDUCxjQUFjLHNEQUFRO0FBQ3RCLHdCQUF3QixnRkFBb0M7QUFDNUQsS0FBSztBQUNMLFdBQVcsd0RBQWtCO0FBQzdCO0FBQ087QUFDUCxJQUFJLHFEQUFPO0FBQ1gsbUNBQW1DLDZEQUEwQjtBQUM3RDtBQUNBLFFBQVEscURBQU87QUFDZixZQUFZLHFEQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGdhc3RcXGdhc3RfcmVzb2x2ZXJfcHVibGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmF1bHRzLCBmb3JFYWNoIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciBhcyBvcmdSZXNvbHZlR3JhbW1hciB9IGZyb20gXCIuLi9yZXNvbHZlclwiO1xuaW1wb3J0IHsgdmFsaWRhdGVHcmFtbWFyIGFzIG9yZ1ZhbGlkYXRlR3JhbW1hciB9IGZyb20gXCIuLi9jaGVja3NcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vZXJyb3JzX3B1YmxpY1wiO1xuaW1wb3J0IHsgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0XCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlclxuICAgIH0pO1xuICAgIHZhciB0b3BSdWxlc1RhYmxlID0ge307XG4gICAgZm9yRWFjaChvcHRpb25zLnJ1bGVzLCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB0b3BSdWxlc1RhYmxlW3J1bGUubmFtZV0gPSBydWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBvcmdSZXNvbHZlR3JhbW1hcih0b3BSdWxlc1RhYmxlLCBvcHRpb25zLmVyck1zZ1Byb3ZpZGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXJcbiAgICB9KTtcbiAgICByZXR1cm4gb3JnVmFsaWRhdGVHcmFtbWFyKG9wdGlvbnMucnVsZXMsIG9wdGlvbnMubWF4TG9va2FoZWFkLCBvcHRpb25zLnRva2VuVHlwZXMsIG9wdGlvbnMuZXJyTXNnUHJvdmlkZXIsIG9wdGlvbnMuZ3JhbW1hck5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk9jY3VycmVuY2VJbmRpY2VzKG9wdGlvbnMpIHtcbiAgICBmb3JFYWNoKG9wdGlvbnMucnVsZXMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICB2YXIgbWV0aG9kc0NvbGxlY3RvciA9IG5ldyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcigpO1xuICAgICAgICBjdXJyUnVsZS5hY2NlcHQobWV0aG9kc0NvbGxlY3Rvcik7XG4gICAgICAgIGZvckVhY2gobWV0aG9kc0NvbGxlY3Rvci5kc2xNZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICAgICAgZm9yRWFjaChtZXRob2RzLCBmdW5jdGlvbiAoY3Vyck1ldGhvZCwgYXJySWR4KSB7XG4gICAgICAgICAgICAgICAgY3Vyck1ldGhvZC5pZHggPSBhcnJJZHggKyAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZXNvbHZlcl9wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAstVisitor: () => (/* binding */ GAstVisitor)\n/* harmony export */ });\n/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\nvar GAstVisitor = /** @class */ (function () {\n    function GAstVisitor() {\n    }\n    GAstVisitor.prototype.visit = function (node) {\n        var nodeAny = node;\n        switch (nodeAny.constructor) {\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Alternative:\n                return this.visitAlternative(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Option:\n                return this.visitOption(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Repetition:\n                return this.visitRepetition(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Alternation:\n                return this.visitAlternation(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Terminal:\n                return this.visitTerminal(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Rule:\n                return this.visitRule(nodeAny);\n            /* istanbul ignore next */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    };\n    GAstVisitor.prototype.visitNonTerminal = function (node) { };\n    GAstVisitor.prototype.visitAlternative = function (node) { };\n    GAstVisitor.prototype.visitOption = function (node) { };\n    GAstVisitor.prototype.visitRepetition = function (node) { };\n    GAstVisitor.prototype.visitRepetitionMandatory = function (node) { };\n    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) { };\n    GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) { };\n    GAstVisitor.prototype.visitAlternation = function (node) { };\n    GAstVisitor.prototype.visitTerminal = function (node) { };\n    GAstVisitor.prototype.visitRule = function (node) { };\n    return GAstVisitor;\n}());\n\n//# sourceMappingURL=gast_visitor_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBMO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBVztBQUM1QjtBQUNBLGlCQUFpQixxREFBVztBQUM1QjtBQUNBLGlCQUFpQixnREFBTTtBQUN2QjtBQUNBLGlCQUFpQiw2REFBbUI7QUFDcEM7QUFDQSxpQkFBaUIsMEVBQWdDO0FBQ2pEO0FBQ0EsaUJBQWlCLGlFQUF1QjtBQUN4QztBQUNBLGlCQUFpQixvREFBVTtBQUMzQjtBQUNBLGlCQUFpQixxREFBVztBQUM1QjtBQUNBLGlCQUFpQixrREFBUTtBQUN6QjtBQUNBLGlCQUFpQiw4Q0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNzQjtBQUN2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGdhc3RcXGdhc3RfdmlzaXRvcl9wdWJsaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJ1bGUsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdF9wdWJsaWNcIjtcbnZhciBHQXN0VmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHQXN0VmlzaXRvcigpIHtcbiAgICB9XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVBbnkgPSBub2RlO1xuICAgICAgICBzd2l0Y2ggKG5vZGVBbnkuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgTm9uVGVybWluYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXROb25UZXJtaW5hbChub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgQWx0ZXJuYXRpdmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbHRlcm5hdGl2ZShub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgT3B0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0T3B0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSZXBldGl0aW9uTWFuZGF0b3J5OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeShub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb24obm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIEFsdGVybmF0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWx0ZXJuYXRpb24obm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0VGVybWluYWwobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJ1bGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSdWxlKG5vZGVBbnkpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aXZlID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICByZXR1cm4gR0FzdFZpc2l0b3I7XG59KCkpO1xuZXhwb3J0IHsgR0FzdFZpc2l0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfdmlzaXRvcl9wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractNextPossibleTokensWalker: () => (/* binding */ AbstractNextPossibleTokensWalker),\n/* harmony export */   AbstractNextTerminalAfterProductionWalker: () => (/* binding */ AbstractNextTerminalAfterProductionWalker),\n/* harmony export */   NextAfterTokenWalker: () => (/* binding */ NextAfterTokenWalker),\n/* harmony export */   NextTerminalAfterAtLeastOneSepWalker: () => (/* binding */ NextTerminalAfterAtLeastOneSepWalker),\n/* harmony export */   NextTerminalAfterAtLeastOneWalker: () => (/* binding */ NextTerminalAfterAtLeastOneWalker),\n/* harmony export */   NextTerminalAfterManySepWalker: () => (/* binding */ NextTerminalAfterManySepWalker),\n/* harmony export */   NextTerminalAfterManyWalker: () => (/* binding */ NextTerminalAfterManyWalker),\n/* harmony export */   nextPossibleTokensAfter: () => (/* binding */ nextPossibleTokensAfter),\n/* harmony export */   possiblePathsFrom: () => (/* binding */ possiblePathsFrom)\n/* harmony export */ });\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./first */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));\n\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternative({ definition: fullRest });\n            this.possibleTokTypes = (0,_first__WEBPACK_IMPORTED_MODULE_2__.first)(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));\n\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternative({ definition: prod.definition }),\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                    definition: [new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                    definition: [new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternation) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(prod.definition, function (currAlt) {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(targetDef, i)\n    });\n    return result;\n}\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.last)(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),\n                ruleStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(currRuleStack),\n                occurrenceStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.NonTerminal) {\n            var newRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDbUM7QUFDbUU7QUFDdkU7QUFDK0o7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVEsaUNBQWlDO0FBQ2xFLCtCQUErQixzREFBUSx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDZDQUFVO0FBQ2dDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQVcsR0FBRyxzQkFBc0I7QUFDbkUsb0NBQW9DLDZDQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw2Q0FBVTtBQUN5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBTTtBQUN2QztBQUNBLDBDQUEwQyx1REFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFNO0FBQzFDO0FBQ0EsNkNBQTZDLHVEQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDeUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbURBQU07QUFDN0M7QUFDQSxnREFBZ0QsdURBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1EQUFNO0FBQzFEO0FBQ0EsNkRBQTZELHVEQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDK0M7QUFDekM7QUFDUCwrQkFBK0I7QUFDL0I7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFXO0FBQ3ZDO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQVc7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQyxxREFBTTtBQUN2QztBQUNBO0FBQ0EsaUNBQWlDLGtFQUFtQjtBQUNwRDtBQUNBLG9CQUFvQix5REFBVTtBQUM5QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0VBQWdDO0FBQ2pFO0FBQ0Esb0JBQW9CLDBEQUFXLEdBQUcsNkJBQTZCO0FBQy9ELG9CQUFvQix5REFBVTtBQUM5QixxQ0FBcUMsdURBQVEsR0FBRyw4QkFBOEI7QUFDOUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzRUFBdUI7QUFDeEQ7QUFDQSxvQkFBb0IseURBQVU7QUFDOUIscUNBQXFDLHVEQUFRLEdBQUcsOEJBQThCO0FBQzlFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseURBQVU7QUFDM0M7QUFDQSxvQkFBb0IseURBQVU7QUFDOUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFXO0FBQzVDLFlBQVkscURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFPO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQyx1REFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQUk7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxxREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQUk7QUFDekIsMkJBQTJCLHVEQUFTO0FBQ3BDLGlDQUFpQyx1REFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQVc7QUFDNUMsK0JBQStCLHNEQUFRO0FBQ3ZDO0FBQ0EscUNBQXFDLHNEQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxrREFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQW1CO0FBQ3BEO0FBQ0Esc0NBQXNDLHlEQUFVO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0VBQW9FLGtEQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0VBQWdDO0FBQ2pFO0FBQ0Esb0NBQW9DLHVEQUFRO0FBQzVDO0FBQ0EsYUFBYTtBQUNiLHNDQUFzQyx5REFBVTtBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9FQUFvRSxrREFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNFQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFRO0FBQzVDO0FBQ0EsYUFBYTtBQUNiLG9DQUFvQyx5REFBVTtBQUM5QztBQUNBO0FBQ0EsYUFBYTtBQUNiLGtFQUFrRSxrREFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5REFBVTtBQUM5QztBQUNBO0FBQ0EsYUFBYTtBQUNiLGtFQUFrRSxrREFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFXO0FBQzVDO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtEQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFXO0FBQzVDO0FBQ0E7QUFDQSw0Q0FBNEMsa0RBQUk7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlDQUFpQyxtREFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBUTtBQUMvQjtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGludGVycHJldGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdFwiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGRyb3AsIGRyb3BSaWdodCwgZmlyc3QgYXMgX2ZpcnN0LCBmb3JFYWNoLCBpc0VtcHR5LCBsYXN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuL2ZpcnN0XCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG52YXIgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyKHRvcFByb2QsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBfdGhpcy5wb3NzaWJsZVRva1R5cGVzID0gW107XG4gICAgICAgIF90aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IFwiXCI7XG4gICAgICAgIF90aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIF90aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzQXRFbmRPZlBhdGggPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhdGgucnVsZVN0YWNrWzBdICE9PSB0aGlzLnRvcFByb2QubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcGF0aCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSB3YWxrZXIncyB0b3AgUnVsZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tdXRhYmxlIGZvciB0aGUgd2luXG4gICAgICAgIHRoaXMucnVsZVN0YWNrID0gY2xvbmVBcnIodGhpcy5wYXRoLnJ1bGVTdGFjaykucmV2ZXJzZSgpOyAvLyBpbnRlbGlqIGJ1ZyByZXF1aXJlcyBhc3NlcnRpb25cbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sgPSBjbG9uZUFycih0aGlzLnBhdGgub2NjdXJyZW5jZVN0YWNrKS5yZXZlcnNlKCk7IC8vIGludGVsaWogYnVnIHJlcXVpcmVzIGFzc2VydGlvblxuICAgICAgICAvLyBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhlIGZpcnN0IHByb2R1Y3Rpb24gaXMgdmFsaWQsIHdlIG5vdyBzZWVrIHRoZSAybmQgcHJvZHVjdGlvblxuICAgICAgICB0aGlzLnJ1bGVTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZVRva1R5cGVzO1xuICAgIH07XG4gICAgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAocHJvZCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKHByZXZSZXN0ID09PSB2b2lkIDApIHsgcHJldlJlc3QgPSBbXTsgfVxuICAgICAgICAvLyBzdG9wIHNjYW5uaW5nIG9uY2Ugd2UgZm91bmQgdGhlIHBhdGhcbiAgICAgICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGsuY2FsbCh0aGlzLCBwcm9kLCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gZm91bmQgdGhlIG5leHQgcHJvZHVjdGlvbiwgbmVlZCB0byBrZWVwIHdhbGtpbmcgaW4gaXRcbiAgICAgICAgaWYgKHJlZlByb2QucmVmZXJlbmNlZFJ1bGUubmFtZSA9PT0gdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgJiZcbiAgICAgICAgICAgIHJlZlByb2QuaWR4ID09PSB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgICAgICB0aGlzLndhbGsocmVmUHJvZC5yZWZlcmVuY2VkUnVsZSwgZnVsbFJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUudXBkYXRlRXhwZWN0ZWROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBuZWVkIHRvIGNvbnN1bWUgdGhlIFRlcm1pbmFsXG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMucnVsZVN0YWNrKSkge1xuICAgICAgICAgICAgLy8gbXVzdCByZXNldCBuZXh0UHJvZHVjdGlvblhYWCB0byBhdm9pZCB3YWxraW5nIGRvd24gYW5vdGhlciBUb3AgTGV2ZWwgcHJvZHVjdGlvbiB3aGlsZSB3aGF0IHdlIGFyZVxuICAgICAgICAgICAgLy8gcmVhbGx5IHNlZWtpbmcgaXMgdGhlIGxhc3QgVGVybWluYWwuLi5cbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNBdEVuZE9mUGF0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IHRoaXMucnVsZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UgPSB0aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyO1xufShSZXN0V2Fsa2VyKSk7XG5leHBvcnQgeyBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlciB9O1xudmFyIE5leHRBZnRlclRva2VuV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0QWZ0ZXJUb2tlbldhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0QWZ0ZXJUb2tlbldhbGtlcih0b3BQcm9kLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRvcFByb2QsIHBhdGgpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxOYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIF90aGlzLm5leHRUZXJtaW5hbE5hbWUgPSBfdGhpcy5wYXRoLmxhc3RUb2submFtZTtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IF90aGlzLnBhdGgubGFzdFRva09jY3VycmVuY2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmV4dEFmdGVyVG9rZW5XYWxrZXIucHJvdG90eXBlLndhbGtUZXJtaW5hbCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXRFbmRPZlBhdGggJiZcbiAgICAgICAgICAgIHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lID09PSB0aGlzLm5leHRUZXJtaW5hbE5hbWUgJiZcbiAgICAgICAgICAgIHRlcm1pbmFsLmlkeCA9PT0gdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICAhdGhpcy5mb3VuZCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHZhciByZXN0UHJvZCA9IG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IGZ1bGxSZXN0IH0pO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZVRva1R5cGVzID0gZmlyc3QocmVzdFByb2QpO1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0QWZ0ZXJUb2tlbldhbGtlcjtcbn0oQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRBZnRlclRva2VuV2Fsa2VyIH07XG4vKipcbiAqIFRoaXMgd2Fsa2VyIG9ubHkgXCJ3YWxrc1wiIGEgc2luZ2xlIFwiVE9QXCIgbGV2ZWwgaW4gdGhlIEdyYW1tYXIgQXN0LCB0aGlzIG1lYW5zXG4gKiBpdCBuZXZlciBcImZvbGxvd3NcIiBwcm9kdWN0aW9uIHJlZnNcbiAqL1xudmFyIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcih0b3BSdWxlLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvcFJ1bGUgPSB0b3BSdWxlO1xuICAgICAgICBfdGhpcy5vY2N1cnJlbmNlID0gb2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMucmVzdWx0ID0ge1xuICAgICAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRW5kT2ZSdWxlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BSdWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyO1xufShSZXN0V2Fsa2VyKSk7XG5leHBvcnQgeyBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciB9O1xudmFyIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIucHJvdG90eXBlLndhbGtNYW55ID0gZnVuY3Rpb24gKG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKG1hbnlQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlck1hbnkgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJNYW55ID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlck1hbnkgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlck1hbnkudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyTWFueS5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtNYW55LmNhbGwodGhpcywgbWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXI7XG59KEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKSk7XG5leHBvcnQgeyBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIgfTtcbnZhciBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueVNlcCA9IGZ1bmN0aW9uIChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChtYW55U2VwUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QWZ0ZXJNYW55U2VwID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyTWFueVNlcCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJNYW55U2VwIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJNYW55U2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlck1hbnlTZXAuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrTWFueVNlcC5jYWxsKHRoaXMsIG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyO1xufShBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcikpO1xuZXhwb3J0IHsgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyIH07XG52YXIgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZVByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlckF0TGVhc3RPbmUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyQXRMZWFzdE9uZSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyQXRMZWFzdE9uZS50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUuY2FsbCh0aGlzLCBhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlciB9O1xuLy8gVE9ETzogcmVkdWNlIGNvZGUgZHVwbGljYXRpb24gaW4gdGhlIEFmdGVyV2Fsa2Vyc1xudmFyIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwID0gZnVuY3Rpb24gKGF0bGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKGF0bGVhc3RPbmVTZXBQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAuY2FsbCh0aGlzLCBhdGxlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3NpYmxlUGF0aHNGcm9tKHRhcmdldERlZiwgbWF4TGVuZ3RoLCBjdXJyUGF0aCkge1xuICAgIGlmIChjdXJyUGF0aCA9PT0gdm9pZCAwKSB7IGN1cnJQYXRoID0gW107IH1cbiAgICAvLyBhdm9pZCBzaWRlIGVmZmVjdHNcbiAgICBjdXJyUGF0aCA9IGNsb25lQXJyKGN1cnJQYXRoKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gcmVtYWluaW5nUGF0aFdpdGgobmV4dERlZikge1xuICAgICAgICByZXR1cm4gbmV4dERlZi5jb25jYXQoZHJvcCh0YXJnZXREZWYsIGkgKyAxKSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSBwb3NzaWJsZVBhdGhzRnJvbShyZW1haW5pbmdQYXRoV2l0aChkZWZpbml0aW9uKSwgbWF4TGVuZ3RoLCBjdXJyUGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGFsdGVybmF0aXZlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbmRhdG9yeSBwcm9kdWN0aW9ucyB3aWxsIGhhbHQgdGhlIGxvb3AgYXMgdGhlIHBhdGhzIGNvbXB1dGVkIGZyb20gdGhlaXIgcmVjdXJzaXZlIGNhbGxzIHdpbGwgYWxyZWFkeSBjb250YWluIHRoZVxuICAgICAqIGZvbGxvd2luZyAocmVzdCkgb2YgdGhlIHRhcmdldERlZi5cbiAgICAgKlxuICAgICAqIEZvciBvcHRpb25hbCBwcm9kdWN0aW9ucyAoT3B0aW9uL1JlcGV0aXRpb24vLi4uKSB0aGUgbG9vcCB3aWxsIGNvbnRpbnVlIHRvIHJlcHJlc2VudCB0aGUgcGF0aHMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGVcbiAgICAgKiB0aGUgb3B0aW9uYWwgcHJvZHVjdGlvbi5cbiAgICAgKi9cbiAgICB3aGlsZSAoY3VyclBhdGgubGVuZ3RoIDwgbWF4TGVuZ3RoICYmIGkgPCB0YXJnZXREZWYubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcm9kID0gdGFyZ2V0RGVmW2ldO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGVmID0gW1xuICAgICAgICAgICAgICAgIG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yIH0pXS5jb25jYXQocHJvZC5kZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yIH0pXS5jb25jYXQocHJvZC5kZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICAgICAgdmFyIG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgZm9yRWFjaChwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIGxpbWl0ZWQgY2hlY2sgZm9yIGVtcHR5IGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgICAgIC8vICAgSXQgd291bGQgcHJldmVudCBhIGNvbW1vbiBjYXNlIG9mIGluZmluaXRlIGxvb3BzIGR1cmluZyBwYXJzZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gICBIb3dldmVyICoqaW4tZGlyZWN0bHkqKiBlbXB0eSBhbHRlcm5hdGl2ZXMgbWF5IHN0aWxsIGNhdXNlIGlzc3Vlcy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShjdXJyQWx0LmRlZmluaXRpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKGN1cnJBbHQuZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgY3VyclBhdGgucHVzaChwcm9kLnRlcm1pbmFsVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBwYXJ0aWFsUGF0aDogY3VyclBhdGgsXG4gICAgICAgIHN1ZmZpeERlZjogZHJvcCh0YXJnZXREZWYsIGkpXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXh0UG9zc2libGVUb2tlbnNBZnRlcihpbml0aWFsRGVmLCB0b2tlblZlY3RvciwgdG9rTWF0Y2hlciwgbWF4TG9va0FoZWFkKSB7XG4gICAgdmFyIEVYSVRfTk9OX1RFUk1JTkFMID0gXCJFWElUX05PTkVfVEVSTUlOQUxcIjtcbiAgICAvLyB0byBhdm9pZCBjcmVhdGluZyBhIG5ldyBBcnJheSBlYWNoIHRpbWUuXG4gICAgdmFyIEVYSVRfTk9OX1RFUk1JTkFMX0FSUiA9IFtFWElUX05PTl9URVJNSU5BTF07XG4gICAgdmFyIEVYSVRfQUxURVJOQVRJVkUgPSBcIkVYSVRfQUxURVJOQVRJVkVcIjtcbiAgICB2YXIgZm91bmRDb21wbGV0ZVBhdGggPSBmYWxzZTtcbiAgICB2YXIgdG9rZW5WZWN0b3JMZW5ndGggPSB0b2tlblZlY3Rvci5sZW5ndGg7XG4gICAgdmFyIG1pbmltYWxBbHRlcm5hdGl2ZXNJbmRleCA9IHRva2VuVmVjdG9yTGVuZ3RoIC0gbWF4TG9va0FoZWFkIC0gMTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHBvc3NpYmxlUGF0aHMgPSBbXTtcbiAgICBwb3NzaWJsZVBhdGhzLnB1c2goe1xuICAgICAgICBpZHg6IC0xLFxuICAgICAgICBkZWY6IGluaXRpYWxEZWYsXG4gICAgICAgIHJ1bGVTdGFjazogW10sXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogW11cbiAgICB9KTtcbiAgICB3aGlsZSAoIWlzRW1wdHkocG9zc2libGVQYXRocykpIHtcbiAgICAgICAgdmFyIGN1cnJQYXRoID0gcG9zc2libGVQYXRocy5wb3AoKTtcbiAgICAgICAgLy8gc2tpcCBhbHRlcm5hdGl2ZXMgaWYgbm8gbW9yZSByZXN1bHRzIGNhbiBiZSBmb3VuZCAoYXNzdW1pbmcgZGV0ZXJtaW5pc3RpYyBncmFtbWFyIHdpdGggZml4ZWQgbG9va2FoZWFkKVxuICAgICAgICBpZiAoY3VyclBhdGggPT09IEVYSVRfQUxURVJOQVRJVkUpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZENvbXBsZXRlUGF0aCAmJlxuICAgICAgICAgICAgICAgIGxhc3QocG9zc2libGVQYXRocykuaWR4IDw9IG1pbmltYWxBbHRlcm5hdGl2ZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpcnJlbGV2YW50IGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyRGVmID0gY3VyclBhdGguZGVmO1xuICAgICAgICB2YXIgY3VycklkeCA9IGN1cnJQYXRoLmlkeDtcbiAgICAgICAgdmFyIGN1cnJSdWxlU3RhY2sgPSBjdXJyUGF0aC5ydWxlU3RhY2s7XG4gICAgICAgIHZhciBjdXJyT2NjdXJyZW5jZVN0YWNrID0gY3VyclBhdGgub2NjdXJyZW5jZVN0YWNrO1xuICAgICAgICAvLyBGb3IgRXhhbXBsZTogYW4gZW1wdHkgcGF0aCBjb3VsZCBleGlzdCBpbiBhIHZhbGlkIGdyYW1tYXIgaW4gdGhlIGNhc2Ugb2YgYW4gRU1QVFlfQUxUXG4gICAgICAgIGlmIChpc0VtcHR5KGN1cnJEZWYpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZCA9IGN1cnJEZWZbMF07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9kID09PSBFWElUX05PTl9URVJNSU5BTCkge1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBkcm9wUmlnaHQoY3VyclJ1bGVTdGFjayksXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBkcm9wUmlnaHQoY3Vyck9jY3VycmVuY2VTdGFjaylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChjdXJySWR4IDwgdG9rZW5WZWN0b3JMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZHggPSBjdXJySWR4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsVG9rZW4gPSB0b2tlblZlY3RvcltuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9rTWF0Y2hlcihhY3R1YWxUb2tlbiwgcHJvZC50ZXJtaW5hbFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeDogbmV4dElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJJZHggPT09IHRva2VuVmVjdG9yTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIElHTk9SRSBBQk9WRSBFTFNFXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW5UeXBlOiBwcm9kLnRlcm1pbmFsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuT2NjdXJyZW5jZTogcHJvZC5pZHgsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm91bmRDb21wbGV0ZVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgIHZhciBuZXdSdWxlU3RhY2sgPSBjbG9uZUFycihjdXJyUnVsZVN0YWNrKTtcbiAgICAgICAgICAgIG5ld1J1bGVTdGFjay5wdXNoKHByb2Qubm9uVGVybWluYWxOYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXdPY2N1cnJlbmNlU3RhY2sgPSBjbG9uZUFycihjdXJyT2NjdXJyZW5jZVN0YWNrKTtcbiAgICAgICAgICAgIG5ld09jY3VycmVuY2VTdGFjay5wdXNoKHByb2QuaWR4KTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBwcm9kLmRlZmluaXRpb24uY29uY2F0KEVYSVRfTk9OX1RFUk1JTkFMX0FSUiwgZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBuZXdPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGhvdXQgPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOihUSEUgTkVXIG9wZXJhdG9ycyBoZXJlIHRha2UgYSB3aGlsZS4uLikgKGNvbnZlcnQgb25jZT8pXG4gICAgICAgICAgICB2YXIgc2Vjb25kSXRlcmF0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbc2Vjb25kSXRlcmF0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIFRPRE86KFRIRSBORVcgb3BlcmF0b3JzIGhlcmUgdGFrZSBhIHdoaWxlLi4uKSAoY29udmVydCBvbmNlPylcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JHYXN0ID0gbmV3IFRlcm1pbmFsKHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRJdGVyYXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW3NlcGFyYXRvckdhc3RdLmNvbmNhdChwcm9kLmRlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtzZWNvbmRJdGVyYXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRob3V0KTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIG1hcmtlciB0byBhdm9pZCBiYWNrdHJhY2tpbmcgcGF0aHMgd2hvc2UgaGlnaGVyIHByaW9yaXR5IGFsdGVybmF0aXZlcyBhbHJlYWR5IG1hdGNoZWRcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JHYXN0ID0gbmV3IFRlcm1pbmFsKHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBudGhSZXBldGl0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtzZXBhcmF0b3JHYXN0XS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbbnRoUmVwZXRpdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRob3V0KTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIG1hcmtlciB0byBhdm9pZCBiYWNrdHJhY2tpbmcgcGF0aHMgd2hvc2UgaGlnaGVyIHByaW9yaXR5IGFsdGVybmF0aXZlcyBhbHJlYWR5IG1hdGNoZWRcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGFuIGVtcHR5IHJlcGV0aXRpb24gd2lsbCBjYXVzZSBpbmZpbml0ZSBsb29wcyBoZXJlLCB3aWxsIHRoZSBwYXJzZXIgZGV0ZWN0IHRoaXMgaW4gc2VsZkFuYWx5c2lzP1xuICAgICAgICAgICAgdmFyIG50aFJlcGV0aXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtudGhSZXBldGl0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHByb2QuZGVmaW5pdGlvbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyQWx0ID0gcHJvZC5kZWZpbml0aW9uW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyQWx0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgICAgICBkZWY6IGN1cnJBbHQuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goY3VyckFsdFBhdGgpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUnVsZSkge1xuICAgICAgICAgICAgLy8gbGFzdCBiZWNhdXNlIHdlIHNob3VsZCBvbmx5IGVuY291bnRlciBhdCBtb3N0IGEgc2luZ2xlIG9uZSBvZiB0aGVzZSBwZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChleHBhbmRUb3BMZXZlbFJ1bGUocHJvZCwgY3VycklkeCwgY3VyclJ1bGVTdGFjaywgY3Vyck9jY3VycmVuY2VTdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXhwYW5kVG9wTGV2ZWxSdWxlKHRvcFJ1bGUsIGN1cnJJZHgsIGN1cnJSdWxlU3RhY2ssIGN1cnJPY2N1cnJlbmNlU3RhY2spIHtcbiAgICB2YXIgbmV3UnVsZVN0YWNrID0gY2xvbmVBcnIoY3VyclJ1bGVTdGFjayk7XG4gICAgbmV3UnVsZVN0YWNrLnB1c2godG9wUnVsZS5uYW1lKTtcbiAgICB2YXIgbmV3Q3Vyck9jY3VycmVuY2VTdGFjayA9IGNsb25lQXJyKGN1cnJPY2N1cnJlbmNlU3RhY2spO1xuICAgIC8vIHRvcCBydWxlIGlzIGFsd2F5cyBhc3N1bWVkIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBvY2N1cnJlbmNlIGluZGV4IDFcbiAgICBuZXdDdXJyT2NjdXJyZW5jZVN0YWNrLnB1c2goMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICBkZWY6IHRvcFJ1bGUuZGVmaW5pdGlvbixcbiAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3Q3Vyck9jY3VycmVuY2VTdGFja1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnByZXRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AT_LEAST_ONE_IDX: () => (/* binding */ AT_LEAST_ONE_IDX),\n/* harmony export */   AT_LEAST_ONE_SEP_IDX: () => (/* binding */ AT_LEAST_ONE_SEP_IDX),\n/* harmony export */   BITS_FOR_ALT_IDX: () => (/* binding */ BITS_FOR_ALT_IDX),\n/* harmony export */   BITS_FOR_METHOD_TYPE: () => (/* binding */ BITS_FOR_METHOD_TYPE),\n/* harmony export */   BITS_FOR_OCCURRENCE_IDX: () => (/* binding */ BITS_FOR_OCCURRENCE_IDX),\n/* harmony export */   BITS_FOR_RULE_IDX: () => (/* binding */ BITS_FOR_RULE_IDX),\n/* harmony export */   MANY_IDX: () => (/* binding */ MANY_IDX),\n/* harmony export */   MANY_SEP_IDX: () => (/* binding */ MANY_SEP_IDX),\n/* harmony export */   OPTION_IDX: () => (/* binding */ OPTION_IDX),\n/* harmony export */   OR_IDX: () => (/* binding */ OR_IDX),\n/* harmony export */   getKeyForAutomaticLookahead: () => (/* binding */ getKeyForAutomaticLookahead)\n/* harmony export */ });\n// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nvar BITS_FOR_METHOD_TYPE = 4;\nvar BITS_FOR_OCCURRENCE_IDX = 8;\nvar BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nvar BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n/* tslint:disable */\nvar OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nvar OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n/* tslint:enable */\n// this actually returns a number, but it is always used as a string (object prop key)\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    /* tslint:disable */\n    return occurrence | dslMethodIdx | ruleIdx;\n    /* tslint:enable */\n}\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIva2V5cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGtleXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9va2FoZWFkIGtleXMgYXJlIDMyQml0IGludGVnZXJzIGluIHRoZSBmb3JtXG4vLyBUVFRUVFRUVC1aWlpaWlpaWlpaWlotWVlZWS1YWFhYWFhYWFxuLy8gWFhYWCAtPiBPY2N1cnJlbmNlIEluZGV4IGJpdG1hcC5cbi8vIFlZWVkgLT4gRFNMIE1ldGhvZCBUeXBlIGJpdG1hcC5cbi8vIFpaWlpaWlpaWlpaWlpaWiAtPiBSdWxlIHNob3J0IEluZGV4IGJpdG1hcC5cbi8vIFRUVFRUVFRUVCAtPiBhbHRlcm5hdGlvbiBhbHRlcm5hdGl2ZSBpbmRleCBiaXRtYXBcbmV4cG9ydCB2YXIgQklUU19GT1JfTUVUSE9EX1RZUEUgPSA0O1xuZXhwb3J0IHZhciBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCA9IDg7XG5leHBvcnQgdmFyIEJJVFNfRk9SX1JVTEVfSURYID0gMTI7XG4vLyBUT0RPOiB2YWxpZGF0aW9uLCB0aGlzIG1lYW5zIHRoYXQgdGhlcmUgbWF5IGF0IG1vc3QgMl44IC0tPiAyNTYgYWx0ZXJuYXRpdmVzIGZvciBhbiBhbHRlcm5hdGlvbi5cbmV4cG9ydCB2YXIgQklUU19GT1JfQUxUX0lEWCA9IDg7XG4vLyBzaG9ydCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIG1hcHBpbmcga2V5cy5cbi8vIGJlaW5nIHNob3J0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSB3aGVuIGNvbXBvc2luZyBLRVlTIGZvciBtYXBzIG91dCBvZiB0aGVzZVxuLy8gVGhlIDUgLSA4IGJpdHMgKDE2IHBvc3NpYmxlIHZhbHVlcywgYXJlIHJlc2VydmVkIGZvciB0aGUgRFNMIG1ldGhvZCBpbmRpY2VzKVxuLyogdHNsaW50OmRpc2FibGUgKi9cbmV4cG9ydCB2YXIgT1JfSURYID0gMSA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgT1BUSU9OX0lEWCA9IDIgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIE1BTllfSURYID0gMyA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgQVRfTEVBU1RfT05FX0lEWCA9IDQgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIE1BTllfU0VQX0lEWCA9IDUgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIEFUX0xFQVNUX09ORV9TRVBfSURYID0gNiA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbi8qIHRzbGludDplbmFibGUgKi9cbi8vIHRoaXMgYWN0dWFsbHkgcmV0dXJucyBhIG51bWJlciwgYnV0IGl0IGlzIGFsd2F5cyB1c2VkIGFzIGEgc3RyaW5nIChvYmplY3QgcHJvcCBrZXkpXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHJ1bGVJZHgsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkge1xuICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgcmV0dXJuIG9jY3VycmVuY2UgfCBkc2xNZXRob2RJZHggfCBydWxlSWR4O1xuICAgIC8qIHRzbGludDplbmFibGUgKi9cbn1cbnZhciBCSVRTX1NUQVJUX0ZPUl9BTFRfSURYID0gMzIgLSBCSVRTX0ZPUl9BTFRfSURYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROD_TYPE: () => (/* binding */ PROD_TYPE),\n/* harmony export */   areTokenCategoriesNotUsed: () => (/* binding */ areTokenCategoriesNotUsed),\n/* harmony export */   buildAlternativesLookAheadFunc: () => (/* binding */ buildAlternativesLookAheadFunc),\n/* harmony export */   buildLookaheadFuncForOptionalProd: () => (/* binding */ buildLookaheadFuncForOptionalProd),\n/* harmony export */   buildLookaheadFuncForOr: () => (/* binding */ buildLookaheadFuncForOr),\n/* harmony export */   buildSingleAlternativeLookaheadFunction: () => (/* binding */ buildSingleAlternativeLookaheadFunction),\n/* harmony export */   containsPath: () => (/* binding */ containsPath),\n/* harmony export */   getLookaheadPathsForOptionalProd: () => (/* binding */ getLookaheadPathsForOptionalProd),\n/* harmony export */   getLookaheadPathsForOr: () => (/* binding */ getLookaheadPathsForOr),\n/* harmony export */   getProdType: () => (/* binding */ getProdType),\n/* harmony export */   isStrictPrefixOfPath: () => (/* binding */ isStrictPrefixOfPath),\n/* harmony export */   lookAheadSequenceFromAlternatives: () => (/* binding */ lookAheadSequenceFromAlternatives)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interpreter */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rest */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scan/tokens */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcherNoCategories\n        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcherNoCategories\n        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(alts, function (currAlt) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(alts, function (currAlt) {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(currAlt);\n        });\n        var choiceToAlt_1 = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(singleTokenAlts, function (result, currAlt, idx) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAlt, function (currTokType) {\n                if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(alt);\n        if (singleTokensTypes.length === 1 &&\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_2__.RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__.GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(altsDefs, function (currAlt) { return (0,_interpreter__WEBPACK_IMPORTED_MODULE_1__.possiblePathsFrom)([currAlt], 1); });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(partialAlts, function (currAltPaths) {\n        var dict = {};\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(suffixDef) || currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = (0,_interpreter__WEBPACK_IMPORTED_MODULE_1__.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Alternative({ definition: insideDef });\n    var afterFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Alternative({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(lookAheadPaths, function (singleAltPaths) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(singleAltPaths, function (singlePath) {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(singlePath, function (token) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(token.categoryMatches); });\n        });\n    });\n}\n//# sourceMappingURL=lookahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDc0Y7QUFDckM7QUFDZDtBQUMyRDtBQUNzRjtBQUM1SDtBQUNsRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDeEI7QUFDUDtBQUNBLHdCQUF3QixxREFBTTtBQUM5QjtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQW1CO0FBQ2hEO0FBQ0E7QUFDQSw2QkFBNkIsK0VBQWdDO0FBQzdEO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXVCO0FBQ3BEO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsVUFBVSw0RUFBa0M7QUFDNUMsVUFBVSxnRUFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsNEVBQWtDO0FBQzVDLFVBQVUsZ0VBQXNCO0FBQ2hDO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0NBQWtDLG1EQUFLO0FBQ3ZDLGVBQWUsbURBQUs7QUFDcEI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaURBQUcsOEJBQThCLHNCQUFzQjtBQUNwRiw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFHO0FBQ2pDLG1CQUFtQixxREFBTztBQUMxQixTQUFTO0FBQ1QsNEJBQTRCLG9EQUFNO0FBQ2xDLFlBQVkscURBQU87QUFDbkIscUJBQXFCLGlEQUFHO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IscURBQU87QUFDdkIseUJBQXlCLGlEQUFHO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtDQUFrQyxtREFBSztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBTztBQUN2QztBQUNBLFlBQVkscURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQU07QUFDdEM7QUFDQSxnQkFBZ0IscURBQU87QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDZDQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGtFQUFXO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQkFBc0IsaURBQUcsZ0NBQWdDLE9BQU8sK0RBQWlCLGlCQUFpQjtBQUNsRztBQUNBLHFCQUFxQixpREFBRztBQUN4QjtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBLFlBQVkscURBQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0RBQWlCO0FBQ3RFO0FBQ0E7QUFDQSxvQkFBb0IscURBQU87QUFDM0I7QUFDQSx3QkFBd0IscURBQU87QUFDL0I7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBZSxHQUFHLHVCQUF1QjtBQUNsRSx3QkFBd0IsMERBQWUsR0FBRyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNPO0FBQ1Asc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEsbURBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDTztBQUNQLFdBQVcsbURBQUs7QUFDaEIsZUFBZSxtREFBSztBQUNwQixtQkFBbUIsbURBQUssZ0NBQWdDLE9BQU8scURBQU8sMEJBQTBCO0FBQ2hHLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXGxvb2thaGVhZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgbWFwLCByZWR1Y2UsIGV2ZXJ5LCBpc0VtcHR5LCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IHBvc3NpYmxlUGF0aHNGcm9tIH0gZnJvbSBcIi4vaW50ZXJwcmV0ZXJcIjtcbmltcG9ydCB7IFJlc3RXYWxrZXIgfSBmcm9tIFwiLi9yZXN0XCI7XG5pbXBvcnQgeyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzIH0gZnJvbSBcIi4uLy4uL3NjYW4vdG9rZW5zXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUgYXMgQWx0ZXJuYXRpdmVHQVNULCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciB9IGZyb20gXCIuL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljXCI7XG5leHBvcnQgdmFyIFBST0RfVFlQRTtcbihmdW5jdGlvbiAoUFJPRF9UWVBFKSB7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIk9QVElPTlwiXSA9IDBdID0gXCJPUFRJT05cIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTlwiXSA9IDFdID0gXCJSRVBFVElUSU9OXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fTUFOREFUT1JZXCJdID0gMl0gPSBcIlJFUEVUSVRJT05fTUFOREFUT1JZXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SXCJdID0gM10gPSBcIlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIl0gPSA0XSA9IFwiUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJBTFRFUk5BVElPTlwiXSA9IDVdID0gXCJBTFRFUk5BVElPTlwiO1xufSkoUFJPRF9UWVBFIHx8IChQUk9EX1RZUEUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2RUeXBlKHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuT1BUSU9OO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5BTFRFUk5BVElPTjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBtYXhMb29rYWhlYWQsIGhhc1ByZWRpY2F0ZXMsIGR5bmFtaWNUb2tlbnNFbmFibGVkLCBsYUZ1bmNCdWlsZGVyKSB7XG4gICAgdmFyIGxvb2tBaGVhZFBhdGhzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgbWF4TG9va2FoZWFkKTtcbiAgICB2YXIgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbGFGdW5jQnVpbGRlcihsb29rQWhlYWRQYXRocywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG4vKipcbiAqICBXaGVuIGRlYWxpbmcgd2l0aCBhbiBPcHRpb25hbCBwcm9kdWN0aW9uIChPUFRJT04vTUFOWS8ybmQgaXRlcmF0aW9uIG9mIEFUX0xFQVNUX09ORS8uLi4pIHdlIG5lZWQgdG8gY29tcGFyZVxuICogIHRoZSBsb29rYWhlYWQgXCJpbnNpZGVcIiB0aGUgcHJvZHVjdGlvbiBhbmQgdGhlIGxvb2thaGVhZCBpbW1lZGlhdGVseSBcImFmdGVyXCIgaXQgaW4gdGhlIHNhbWUgdG9wIGxldmVsIHJ1bGUgKGNvbnRleHQgZnJlZSkuXG4gKlxuICogIEV4YW1wbGU6IGdpdmVuIGEgcHJvZHVjdGlvbjpcbiAqICBBQkMoREUpP0RGXG4gKlxuICogIFRoZSBvcHRpb25hbCAnKERFKT8nIHNob3VsZCBvbmx5IGJlIGVudGVyZWQgaWYgd2Ugc2VlICdERScuIGEgc2luZ2xlIFRva2VuICdEJyBpcyBub3Qgc3VmZmljaWVudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d29cbiAqICBhbHRlcm5hdGl2ZXMuXG4gKlxuICogIEByZXR1cm5zIEEgTG9va2FoZWFkIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgSUZGIHRoZSBwYXJzZXIgc2hvdWxkIHBhcnNlIHRoZSBPcHRpb25hbCBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIGxvb2thaGVhZEJ1aWxkZXIpIHtcbiAgICB2YXIgbG9va0FoZWFkUGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIGspO1xuICAgIHZhciB0b2tlbk1hdGNoZXIgPSBhcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkKGxvb2tBaGVhZFBhdGhzKVxuICAgICAgICA/IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgOiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyO1xuICAgIHJldHVybiBsb29rYWhlYWRCdWlsZGVyKGxvb2tBaGVhZFBhdGhzWzBdLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMoYWx0cywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgIHZhciBudW1PZkFsdHMgPSBhbHRzLmxlbmd0aDtcbiAgICB2YXIgYXJlQWxsT25lVG9rZW5Mb29rYWhlYWQgPSBldmVyeShhbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICByZXR1cm4gZXZlcnkoY3VyckFsdCwgZnVuY3Rpb24gKGN1cnJQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclBhdGgubGVuZ3RoID09PSAxO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIHZlcnNpb24gdGFrZXMgaW50byBhY2NvdW50IHRoZSBwcmVkaWNhdGVzIGFzIHdlbGwuXG4gICAgaWYgKGhhc1ByZWRpY2F0ZXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGNob3NlbiBhbHRlcm5hdGl2ZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvckFsdHMpIHtcbiAgICAgICAgICAgIC8vIHVuZm9ydHVuYXRlbHkgdGhlIHByZWRpY2F0ZXMgbXVzdCBiZSBleHRyYWN0ZWQgZXZlcnkgc2luZ2xlIHRpbWVcbiAgICAgICAgICAgIC8vIGFzIHRoZXkgY2Fubm90IGJlIGNhY2hlZCBkdWUgdG8gcmVmZXJlbmNlcyB0byBwYXJhbWV0ZXJzKHZhcnMpIHdoaWNoIGFyZSBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgaW4gdGhlIGNvbW1vbiBjYXNlIG9mIG5vIHByZWRpY2F0ZXMsIG5vIGNwdSB0aW1lIHdpbGwgYmUgd2FzdGVkIG9uIHRoaXMgKHNlZSBlbHNlIGJsb2NrKVxuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZXMgPSBtYXAob3JBbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkgeyByZXR1cm4gY3VyckFsdC5HQVRFOyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtT2ZBbHRzOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJOdW1PZlBhdGhzID0gY3VyckFsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQcmVkaWNhdGUgPSBwcmVkaWNhdGVzW3RdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyUHJlZGljYXRlICE9PSB1bmRlZmluZWQgJiYgY3VyclByZWRpY2F0ZS5jYWxsKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJlZGljYXRlIGRvZXMgbm90IG1hdGNoIHRoZXJlIGlzIG5vIHBvaW50IGluIGNoZWNraW5nIHRoZSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFBhdGg6IGZvciAodmFyIGogPSAwOyBqIDwgY3Vyck51bU9mUGF0aHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGggPSBjdXJyQWx0W2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIGN1cnJQYXRoW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaCBpbiBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbmV4dFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHBhdGggdGhhdCBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyB3b3JrIGZvciBhbiBlbXB0eSBBTFQgYXMgdGhlIGxvb3Agd2lsbCBiZSBza2lwcGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSBwYXRocyBmb3IgdGhlIGN1cnJlbnQgYWx0ZXJuYXRpdmUgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgYWx0ZXJuYXRpdmVzIGNvdWxkIGJlIG1hdGNoZWRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAgICAgLy8gYSBzaW5nbGUgdG9rZW4gbG9va2FoZWFkLiBUaGVzZSBPcHRpbWl6YXRpb25zIGNhbm5vdCB3b3JrIGlmIGR5bmFtaWNhbGx5IGRlZmluZWQgVG9rZW5zIGFyZSB1c2VkLlxuICAgICAgICB2YXIgc2luZ2xlVG9rZW5BbHRzID0gbWFwKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihjdXJyQWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjaG9pY2VUb0FsdF8xID0gcmVkdWNlKHNpbmdsZVRva2VuQWx0cywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgaWR4KSB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzKHJlc3VsdCwgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIGZ1bmN0aW9uIChjdXJyRXh0ZW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhcyhyZXN1bHQsIGN1cnJFeHRlbmRpbmdUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdF8xW25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxvb2thaGVhZCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgdGhlIHByZWRpY2F0ZXMgYXQgYWxsLlxuICAgICAgICAvLyB0aGlzIGNhdXNlcyBjb2RlIGR1cGxpY2F0aW9uIHdoaWNoIGlzIGludGVudGlvbmFsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJBbHQgPSBhbHRzW3RdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyTnVtT2ZQYXRocyA9IGN1cnJBbHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJOdW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoID0gY3VyckFsdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoTGVuZ3RoID0gY3VyclBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJQYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gd29yayBmb3IgYW4gZW1wdHkgQUxUIGFzIHRoZSBsb29wIHdpbGwgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgZm9yIHRoZSBjdXJyZW50IGFsdGVybmF0aXZlIG1hdGNoZWRcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIGFsdGVybmF0aXZlcyBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24oYWx0LCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgdmFyIGFyZUFsbE9uZVRva2VuTG9va2FoZWFkID0gZXZlcnkoYWx0LCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICB2YXIgbnVtT2ZQYXRocyA9IGFsdC5sZW5ndGg7XG4gICAgLy8gb3B0aW1pemVkIChjb21tb24pIGNhc2Ugb2YgYWxsIHRoZSBsb29rYWhlYWRzIHBhdGhzIHJlcXVpcmluZyBvbmx5XG4gICAgLy8gYSBzaW5nbGUgdG9rZW4gbG9va2FoZWFkLlxuICAgIGlmIChhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIHNpbmdsZVRva2Vuc1R5cGVzID0gZmxhdHRlbihhbHQpO1xuICAgICAgICBpZiAoc2luZ2xlVG9rZW5zVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBpc0VtcHR5KHNpbmdsZVRva2Vuc1R5cGVzWzBdLmNhdGVnb3J5TWF0Y2hlcykpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZFRva2VuVHlwZSA9IHNpbmdsZVRva2Vuc1R5cGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVG9rZW5VbmlxdWVLZXlfMSA9IGV4cGVjdGVkVG9rZW5UeXBlLnRva2VuVHlwZUlkeDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4ID09PSBleHBlY3RlZFRva2VuVW5pcXVlS2V5XzE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNob2ljZVRvQWx0XzIgPSByZWR1Y2Uoc2luZ2xlVG9rZW5zVHlwZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJUb2tUeXBlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIGZ1bmN0aW9uIChjdXJyRXh0ZW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyckV4dGVuZGluZ1R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRfMltuZXh0VG9rZW4udG9rZW5UeXBlSWR4XSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXh0UGF0aDogZm9yICh2YXIgaiA9IDA7IGogPCBudW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGggPSBhbHRbal07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoTGVuZ3RoID0gY3VyclBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaCBpbiBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIG1hdGNoZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG52YXIgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyKHRvcFByb2QsIHRhcmdldE9jY3VycmVuY2UsIHRhcmdldFByb2RUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICBfdGhpcy50YXJnZXRPY2N1cnJlbmNlID0gdGFyZ2V0T2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BQcm9kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdERlZjtcbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIGV4cGVjdGVkUHJvZFR5cGUsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAobm9kZS5pZHggPT09IHRoaXMudGFyZ2V0T2NjdXJyZW5jZSAmJlxuICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9kVHlwZSA9PT0gZXhwZWN0ZWRQcm9kVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN0RGVmID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgZG8gbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIEdyYW1tYXIgYXN0IGFmdGVyIHdlIGhhdmUgZm91bmQgdGhlIHRhcmdldFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa09wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQob3B0aW9uUHJvZCwgUFJPRF9UWVBFLk9QVElPTiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgb3B0aW9uUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQoYXRMZWFzdE9uZVByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcCA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KGF0TGVhc3RPbmVTZXBQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa01hbnkgPSBmdW5jdGlvbiAobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55UHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa01hbnlTZXAgPSBmdW5jdGlvbiAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55U2VwUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXI7XG59KFJlc3RXYWxrZXIpKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiBhIHRhcmdldCBwcm9kdWN0aW9uIGluIGEgdG9wIGxldmVsIGxldmVsIHJ1bGUuXG4gKi9cbnZhciBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IodGFyZ2V0T2NjdXJyZW5jZSwgdGFyZ2V0UHJvZFR5cGUsIHRhcmdldFJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXRPY2N1cnJlbmNlID0gdGFyZ2V0T2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UmVmID0gdGFyZ2V0UmVmO1xuICAgICAgICBfdGhpcy5yZXN1bHQgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUuY2hlY2tJc1RhcmdldCA9IGZ1bmN0aW9uIChub2RlLCBleHBlY3RlZFByb2ROYW1lKSB7XG4gICAgICAgIGlmIChub2RlLmlkeCA9PT0gdGhpcy50YXJnZXRPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID09PSBleHBlY3RlZFByb2ROYW1lICYmXG4gICAgICAgICAgICAodGhpcy50YXJnZXRSZWYgPT09IHVuZGVmaW5lZCB8fCBub2RlID09PSB0aGlzLnRhcmdldFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbm9kZS5kZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLk9QVElPTik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuQUxURVJOQVRJT04pO1xuICAgIH07XG4gICAgcmV0dXJuIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMoc2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgc29ydCBvZiBoYXNoIGZ1bmN0aW9uIGJldHdlZW4gYSBQYXRoIGluIHRoZSBncmFtbWFyIGFuZCBhIHN0cmluZy5cbiAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgbXVsdGlwbGUgXCJoYXNoZXNcIiB0byBzdXBwb3J0IHRoZSBzY2VuYXJpbyBvZiB0b2tlbiBjYXRlZ29yaWVzLlxuICogLSAgQSBzaW5nbGUgcGF0aCB3aXRoIGNhdGVnb3JpZXMgbWF5IG1hdGNoIG11bHRpcGxlICoqYWN0dWFsKiogcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb0hhc2hLZXlzKHBhdGgpIHtcbiAgICB2YXIga2V5cyA9IFtcIlwiXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva1R5cGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgbG9uZ2VyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyU2hvcnRlcktleSA9IGtleXNbal07XG4gICAgICAgICAgICBsb25nZXJLZXlzLnB1c2goY3VyclNob3J0ZXJLZXkgKyBcIl9cIiArIHRva1R5cGUudG9rZW5UeXBlSWR4KTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcmllc0tleVN1ZmZpeCA9IFwiX1wiICsgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNbdF07XG4gICAgICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgY2F0ZWdvcmllc0tleVN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGxvbmdlcktleXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBJbXBlcmF0aXZlIHN0eWxlIGR1ZSB0byBiZWluZyBjYWxsZWQgZnJvbSBhIGhvdCBzcG90XG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlUHJlZml4SGFzaChhbHRLbm93blBhdGhzS2V5cywgc2VhcmNoUGF0aEtleXMsIGlkeCkge1xuICAgIGZvciAodmFyIGN1cnJBbHRJZHggPSAwOyBjdXJyQWx0SWR4IDwgYWx0S25vd25QYXRoc0tleXMubGVuZ3RoOyBjdXJyQWx0SWR4KyspIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRlc3QgdnMgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgICAgICBpZiAoY3VyckFsdElkeCA9PT0gaWR4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBbHRLbm93blBhdGhzS2V5cyA9IGFsdEtub3duUGF0aHNLZXlzW2N1cnJBbHRJZHhdO1xuICAgICAgICBmb3IgKHZhciBzZWFyY2hJZHggPSAwOyBzZWFyY2hJZHggPCBzZWFyY2hQYXRoS2V5cy5sZW5ndGg7IHNlYXJjaElkeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoS2V5ID0gc2VhcmNoUGF0aEtleXNbc2VhcmNoSWR4XTtcbiAgICAgICAgICAgIGlmIChvdGhlckFsdEtub3duUGF0aHNLZXlzW3NlYXJjaEtleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9uZSBvZiB0aGUgU2VhcmNoUGF0aEtleXMgd2VyZSBmb3VuZCBpbiBhbnkgb2YgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyhhbHRzRGVmcywgaykge1xuICAgIHZhciBwYXJ0aWFsQWx0cyA9IG1hcChhbHRzRGVmcywgZnVuY3Rpb24gKGN1cnJBbHQpIHsgcmV0dXJuIHBvc3NpYmxlUGF0aHNGcm9tKFtjdXJyQWx0XSwgMSk7IH0pO1xuICAgIHZhciBmaW5hbFJlc3VsdCA9IGluaXRpYWxpemVBcnJheU9mQXJyYXlzKHBhcnRpYWxBbHRzLmxlbmd0aCk7XG4gICAgdmFyIGFsdHNIYXNoZXMgPSBtYXAocGFydGlhbEFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0UGF0aHMpIHtcbiAgICAgICAgdmFyIGRpY3QgPSB7fTtcbiAgICAgICAgZm9yRWFjaChjdXJyQWx0UGF0aHMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHBhdGhUb0hhc2hLZXlzKGl0ZW0ucGFydGlhbFBhdGgpO1xuICAgICAgICAgICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoY3VycktleSkge1xuICAgICAgICAgICAgICAgIGRpY3RbY3VycktleV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9KTtcbiAgICB2YXIgbmV3RGF0YSA9IHBhcnRpYWxBbHRzO1xuICAgIC8vIG1heExvb2thaGVhZCBsb29wXG4gICAgZm9yICh2YXIgcGF0aExlbmd0aCA9IDE7IHBhdGhMZW5ndGggPD0gazsgcGF0aExlbmd0aCsrKSB7XG4gICAgICAgIHZhciBjdXJyRGF0YXNldCA9IG5ld0RhdGE7XG4gICAgICAgIG5ld0RhdGEgPSBpbml0aWFsaXplQXJyYXlPZkFycmF5cyhjdXJyRGF0YXNldC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChhbHRJZHgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlcyA9IGN1cnJEYXRhc2V0W2FsdElkeF07XG4gICAgICAgICAgICAvLyBwYXRocyBpbiBjdXJyZW50IGFsdGVybmF0aXZlIGxvb3BcbiAgICAgICAgICAgIGZvciAodmFyIGN1cnJQYXRoSWR4ID0gMDsgY3VyclBhdGhJZHggPCBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlcy5sZW5ndGg7IGN1cnJQYXRoSWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhQcmVmaXggPSBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlc1tjdXJyUGF0aElkeF0ucGFydGlhbFBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHN1ZmZpeERlZiA9IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzW2N1cnJQYXRoSWR4XS5zdWZmaXhEZWY7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEtleXMgPSBwYXRoVG9IYXNoS2V5cyhjdXJyUGF0aFByZWZpeCk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVW5pcXVlID0gaXNVbmlxdWVQcmVmaXhIYXNoKGFsdHNIYXNoZXMsIHByZWZpeEtleXMsIGFsdElkeCk7XG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIHRoZSBsaW5lIGZvciB0aGlzIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5pcXVlIHx8IGlzRW1wdHkoc3VmZml4RGVmKSB8fCBjdXJyUGF0aFByZWZpeC5sZW5ndGggPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJBbHRSZXN1bHQgPSBmaW5hbFJlc3VsdFthbHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDYW4gd2UgaW1wbGVtZW50IGEgY29udGFpbnNQYXRoIHVzaW5nIE1hcHMvRGljdGlvbmFyaWVzP1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQYXRoKGN1cnJBbHRSZXN1bHQsIGN1cnJQYXRoUHJlZml4KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbHRSZXN1bHQucHVzaChjdXJyUGF0aFByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIG5ldyAga2V5cyBmb3IgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJlZml4S2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyS2V5ID0gcHJlZml4S2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRzSGFzaGVzW2FsdElkeF1bY3VycktleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBsb25nZXIgcGF0aHNcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzID0gcG9zc2libGVQYXRoc0Zyb20oc3VmZml4RGVmLCBwYXRoTGVuZ3RoICsgMSwgY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2FsdElkeF0gPSBuZXdEYXRhW2FsdElkeF0uY29uY2F0KG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGtleXMgZm9yIG5ldyBrbm93biBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeEtleXMgPSBwYXRoVG9IYXNoS2V5cyhpdGVtLnBhcnRpYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gocHJlZml4S2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdHNIYXNoZXNbYWx0SWR4XVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFsdGVybmF0aXZlcyBsb29wXG4gICAgICAgIGZvciAodmFyIGFsdElkeCA9IDA7IGFsdElkeCA8IGN1cnJEYXRhc2V0Lmxlbmd0aDsgYWx0SWR4KyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoYWx0SWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgaywgb3JQcm9kKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3Iob2NjdXJyZW5jZSwgUFJPRF9UWVBFLkFMVEVSTkFUSU9OLCBvclByb2QpO1xuICAgIHJ1bGVHcmFtbWFyLmFjY2VwdCh2aXNpdG9yKTtcbiAgICByZXR1cm4gbG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzKHZpc2l0b3IucmVzdWx0LCBrKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIGspIHtcbiAgICB2YXIgaW5zaWRlRGVmVmlzaXRvciA9IG5ldyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcihvY2N1cnJlbmNlLCBwcm9kVHlwZSk7XG4gICAgcnVsZUdyYW1tYXIuYWNjZXB0KGluc2lkZURlZlZpc2l0b3IpO1xuICAgIHZhciBpbnNpZGVEZWYgPSBpbnNpZGVEZWZWaXNpdG9yLnJlc3VsdDtcbiAgICB2YXIgYWZ0ZXJEZWZXYWxrZXIgPSBuZXcgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIocnVsZUdyYW1tYXIsIG9jY3VycmVuY2UsIHByb2RUeXBlKTtcbiAgICB2YXIgYWZ0ZXJEZWYgPSBhZnRlckRlZldhbGtlci5zdGFydFdhbGtpbmcoKTtcbiAgICB2YXIgaW5zaWRlRmxhdCA9IG5ldyBBbHRlcm5hdGl2ZUdBU1QoeyBkZWZpbml0aW9uOiBpbnNpZGVEZWYgfSk7XG4gICAgdmFyIGFmdGVyRmxhdCA9IG5ldyBBbHRlcm5hdGl2ZUdBU1QoeyBkZWZpbml0aW9uOiBhZnRlckRlZiB9KTtcbiAgICByZXR1cm4gbG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzKFtpbnNpZGVGbGF0LCBhZnRlckZsYXRdLCBrKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1BhdGgoYWx0ZXJuYXRpdmUsIHNlYXJjaFBhdGgpIHtcbiAgICBjb21wYXJlT3RoZXJQYXRoOiBmb3IgKHZhciBpID0gMDsgaSA8IGFsdGVybmF0aXZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlclBhdGggPSBhbHRlcm5hdGl2ZVtpXTtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5sZW5ndGggIT09IHNlYXJjaFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyUGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFRvayA9IHNlYXJjaFBhdGhbal07XG4gICAgICAgICAgICB2YXIgb3RoZXJUb2sgPSBvdGhlclBhdGhbal07XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdUb2tlbnMgPSBzZWFyY2hUb2sgPT09IG90aGVyVG9rIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb2suY2F0ZWdvcnlNYXRjaGVzTWFwW3NlYXJjaFRvay50b2tlblR5cGVJZHhdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdUb2tlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgY29tcGFyZU90aGVyUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaWN0UHJlZml4T2ZQYXRoKHByZWZpeCwgb3RoZXIpIHtcbiAgICByZXR1cm4gKHByZWZpeC5sZW5ndGggPCBvdGhlci5sZW5ndGggJiZcbiAgICAgICAgZXZlcnkocHJlZml4LCBmdW5jdGlvbiAodG9rVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJUb2tUeXBlID0gb3RoZXJbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiAodG9rVHlwZSA9PT0gb3RoZXJUb2tUeXBlIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcFt0b2tUeXBlLnRva2VuVHlwZUlkeF0pO1xuICAgICAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocykge1xuICAgIHJldHVybiBldmVyeShsb29rQWhlYWRQYXRocywgZnVuY3Rpb24gKHNpbmdsZUFsdFBhdGhzKSB7XG4gICAgICAgIHJldHVybiBldmVyeShzaW5nbGVBbHRQYXRocywgZnVuY3Rpb24gKHNpbmdsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVyeShzaW5nbGVQYXRoLCBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIGlzRW1wdHkodG9rZW4uY2F0ZWdvcnlNYXRjaGVzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9va2FoZWFkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GastRefResolverVisitor: () => (/* binding */ GastRefResolverVisitor),\n/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar)\n/* harmony export */ });\n/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser/parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nfunction resolveGrammar(topLevels, errMsgProvider) {\n    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nvar GastRefResolverVisitor = /** @class */ (function (_super) {\n    __extends(GastRefResolverVisitor, _super);\n    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {\n        var _this = _super.call(this) || this;\n        _this.nameToTopRule = nameToTopRule;\n        _this.errMsgProvider = errMsgProvider;\n        _this.errors = [];\n        return _this;\n    }\n    GastRefResolverVisitor.prototype.resolveRefs = function () {\n        var _this = this;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.values)(this.nameToTopRule), function (prod) {\n            _this.currTopLevel = prod;\n            prod.accept(_this);\n        });\n    };\n    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {\n        var ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    };\n    return GastRefResolverVisitor;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__.GAstVisitor));\n\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzREO0FBQ1Q7QUFDSztBQUNsRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU8sQ0FBQyxvREFBTTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFFQUF5QjtBQUMvQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxrRUFBVztBQUNxQjtBQUNsQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXHJlc29sdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IGZvckVhY2gsIHZhbHVlcyB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgR0FzdFZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlR3JhbW1hcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIHJlZlJlc29sdmVyID0gbmV3IEdhc3RSZWZSZXNvbHZlclZpc2l0b3IodG9wTGV2ZWxzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgcmVmUmVzb2x2ZXIucmVzb2x2ZVJlZnMoKTtcbiAgICByZXR1cm4gcmVmUmVzb2x2ZXIuZXJyb3JzO1xufVxudmFyIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdhc3RSZWZSZXNvbHZlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2FzdFJlZlJlc29sdmVyVmlzaXRvcihuYW1lVG9Ub3BSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lVG9Ub3BSdWxlID0gbmFtZVRvVG9wUnVsZTtcbiAgICAgICAgX3RoaXMuZXJyTXNnUHJvdmlkZXIgPSBlcnJNc2dQcm92aWRlcjtcbiAgICAgICAgX3RoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR2FzdFJlZlJlc29sdmVyVmlzaXRvci5wcm90b3R5cGUucmVzb2x2ZVJlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvckVhY2godmFsdWVzKHRoaXMubmFtZVRvVG9wUnVsZSksIGZ1bmN0aW9uIChwcm9kKSB7XG4gICAgICAgICAgICBfdGhpcy5jdXJyVG9wTGV2ZWwgPSBwcm9kO1xuICAgICAgICAgICAgcHJvZC5hY2NlcHQoX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5uYW1lVG9Ub3BSdWxlW25vZGUubm9uVGVybWluYWxOYW1lXTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLmVyck1zZ1Byb3ZpZGVyLmJ1aWxkUnVsZU5vdEZvdW5kRXJyb3IodGhpcy5jdXJyVG9wTGV2ZWwsIG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRVNPTFZFRF9TVUJSVUxFX1JFRixcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogdGhpcy5jdXJyVG9wTGV2ZWwubmFtZSxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkUmVmTmFtZTogbm9kZS5ub25UZXJtaW5hbE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2VkUnVsZSA9IHJlZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdhc3RSZWZSZXNvbHZlclZpc2l0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgeyBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RestWalker: () => (/* binding */ RestWalker)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(prod.definition, function (subProd, index) {\n            var currRest = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.drop)(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternative) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternative({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({\n            definition: [new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvcmVzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDdUk7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxRQUFRLHFEQUFPO0FBQ2YsMkJBQTJCLGtEQUFJO0FBQy9CO0FBQ0EsbUNBQW1DLDBEQUFXO0FBQzlDO0FBQ0E7QUFDQSx3Q0FBd0MsdURBQVE7QUFDaEQ7QUFDQTtBQUNBLHdDQUF3QywwREFBVztBQUNuRDtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFNO0FBQzlDO0FBQ0E7QUFDQSx3Q0FBd0Msa0VBQW1CO0FBQzNEO0FBQ0E7QUFDQSx3Q0FBd0MsK0VBQWdDO0FBQ3hFO0FBQ0E7QUFDQSx3Q0FBd0Msc0VBQXVCO0FBQy9EO0FBQ0E7QUFDQSx3Q0FBd0MseURBQVU7QUFDbEQ7QUFDQTtBQUNBLHdDQUF3QywwREFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFNLEdBQUcsdUNBQXVDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQU0sR0FBRyxpQ0FBaUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFXLEdBQUcsbUJBQW1CO0FBQ25FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLHFEQUFNO0FBQ2xCLDZCQUE2Qix1REFBUSxHQUFHLG9DQUFvQztBQUM1RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXGdyYW1tYXJcXHJlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJvcCwgZm9yRWFjaCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLyoqXG4gKiAgQSBHcmFtbWFyIFdhbGtlciB0aGF0IGNvbXB1dGVzIHRoZSBcInJlbWFpbmluZ1wiIGdyYW1tYXIgXCJhZnRlclwiIGEgcHJvZHVjdGlvbnMgaW4gdGhlIGdyYW1tYXIuXG4gKi9cbnZhciBSZXN0V2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3RXYWxrZXIoKSB7XG4gICAgfVxuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAocHJvZCwgcHJldlJlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByZXZSZXN0ID09PSB2b2lkIDApIHsgcHJldlJlc3QgPSBbXTsgfVxuICAgICAgICBmb3JFYWNoKHByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKHN1YlByb2QsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VyclJlc3QgPSBkcm9wKHByb2QuZGVmaW5pdGlvbiwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa1Byb2RSZWYoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtUZXJtaW5hbChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa0ZsYXQoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrT3B0aW9uKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtBdExlYXN0T25lKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrQXRMZWFzdE9uZVNlcChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa01hbnlTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa01hbnkoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtPcihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrVGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkgeyB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkgeyB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtGbGF0ID0gZnVuY3Rpb24gKGZsYXRQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDREVGID0+IGFmdGVyIHRoZSBEIHRoZSByZXN0IGlzIEVGXG4gICAgICAgIHZhciBmdWxsT3JSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGZsYXRQcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhERSk/RiA9PiBhZnRlciB0aGUgKERFKT8gdGhlIHJlc3QgaXMgRlxuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhvcHRpb25Qcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKStGID0+IGFmdGVyIHRoZSAoREUpKyB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgdmFyIGZ1bGxBdExlYXN0T25lUmVzdCA9IFtcbiAgICAgICAgICAgIG5ldyBPcHRpb24oeyBkZWZpbml0aW9uOiBhdExlYXN0T25lUHJvZC5kZWZpbml0aW9uIH0pXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lUHJvZCwgZnVsbEF0TGVhc3RPbmVSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDIERFKCxERSkqIEYgPT4gYWZ0ZXIgdGhlICgsREUpKyB0aGUgcmVzdCBpcyAoLERFKT9GXG4gICAgICAgIHZhciBmdWxsQXRMZWFzdE9uZVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lU2VwUHJvZCwgZnVsbEF0TGVhc3RPbmVTZXBSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtNYW55ID0gZnVuY3Rpb24gKG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKSpGID0+IGFmdGVyIHRoZSAoREUpKiB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgdmFyIGZ1bGxNYW55UmVzdCA9IFtcbiAgICAgICAgICAgIG5ldyBPcHRpb24oeyBkZWZpbml0aW9uOiBtYW55UHJvZC5kZWZpbml0aW9uIH0pXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55UHJvZCwgZnVsbE1hbnlSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtNYW55U2VwID0gZnVuY3Rpb24gKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDIChERSgsREUpKik/IEYgPT4gYWZ0ZXIgdGhlICgsREUpKiB0aGUgcmVzdCBpcyAoLERFKT9GXG4gICAgICAgIHZhciBmdWxsTWFueVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55U2VwUHJvZCwgZnVsbE1hbnlTZXBSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtPciA9IGZ1bmN0aW9uIChvclByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBQkMoRHxFfEYpRyA9PiB3aGVuIGZpbmRpbmcgdGhlIChEfEV8RikgdGhlIHJlc3QgaXMgR1xuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIC8vIHdhbGsgYWxsIGRpZmZlcmVudCBhbHRlcm5hdGl2ZXNcbiAgICAgICAgZm9yRWFjaChvclByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGFsdCkge1xuICAgICAgICAgICAgLy8gd3JhcHBpbmcgZWFjaCBhbHRlcm5hdGl2ZSBpbiBhIHNpbmdsZSBkZWZpbml0aW9uIHdyYXBwZXJcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGVycm9ycyBpbiBjb21wdXRpbmcgdGhlIHJlc3Qgb2YgdGhhdCBhbHRlcm5hdGl2ZSBpbiB0aGUgaW52b2NhdGlvbiB0byBjb21wdXRlSW5Qcm9kRm9sbG93c1xuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBmb3IgT1IoW2FsdDEsYWx0Ml0pIGFsdDIgd2lsbCBiZSBjb25zaWRlcmVkIGluICdyZXN0JyBvZiBhbHQxXG4gICAgICAgICAgICB2YXIgcHJvZFdyYXBwZXIgPSBuZXcgQWx0ZXJuYXRpdmUoeyBkZWZpbml0aW9uOiBbYWx0XSB9KTtcbiAgICAgICAgICAgIF90aGlzLndhbGsocHJvZFdyYXBwZXIsIGZ1bGxPclJlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXN0V2Fsa2VyO1xufSgpKTtcbmV4cG9ydCB7IFJlc3RXYWxrZXIgfTtcbmZ1bmN0aW9uIHJlc3RGb3JSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihyZXBTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICB2YXIgcmVwU2VwUmVzdCA9IFtcbiAgICAgICAgbmV3IE9wdGlvbih7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBbbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiByZXBTZXBQcm9kLnNlcGFyYXRvciB9KV0uY29uY2F0KHJlcFNlcFByb2QuZGVmaW5pdGlvbilcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIHZhciBmdWxsUmVwU2VwUmVzdCA9IHJlcFNlcFJlc3QuY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgcmV0dXJuIGZ1bGxSZXBTZXBSZXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CstParser: () => (/* binding */ CstParser),\n/* harmony export */   DEFAULT_PARSER_CONFIG: () => (/* binding */ DEFAULT_PARSER_CONFIG),\n/* harmony export */   DEFAULT_RULE_CONFIG: () => (/* binding */ DEFAULT_RULE_CONFIG),\n/* harmony export */   EMPTY_ALT: () => (/* binding */ EMPTY_ALT),\n/* harmony export */   END_OF_FILE: () => (/* binding */ END_OF_FILE),\n/* harmony export */   EmbeddedActionsParser: () => (/* binding */ EmbeddedActionsParser),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   ParserDefinitionErrorType: () => (/* binding */ ParserDefinitionErrorType)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_follow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../grammar/follow */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../grammar/gast/gast_resolver_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\");\n/* harmony import */ var _traits_recoverable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./traits/recoverable */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\");\n/* harmony import */ var _traits_looksahead__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./traits/looksahead */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js\");\n/* harmony import */ var _traits_tree_builder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./traits/tree_builder */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js\");\n/* harmony import */ var _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./traits/lexer_adapter */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js\");\n/* harmony import */ var _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./traits/recognizer_api */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js\");\n/* harmony import */ var _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./traits/recognizer_engine */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js\");\n/* harmony import */ var _traits_error_handler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./traits/error_handler */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js\");\n/* harmony import */ var _traits_context_assist__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./traits/context_assist */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js\");\n/* harmony import */ var _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./traits/gast_recorder */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js\");\n/* harmony import */ var _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./traits/perf_tracer */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar END_OF_FILE = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__.createTokenInstance)(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__.EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nvar DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false\n});\nvar DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: function () { return undefined; },\n    resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value) {\n    if (value === void 0) { value = undefined; }\n    return function () {\n        return value;\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        var that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"skipValidations\")\n            ? config.skipValidations\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    Parser.performSelfAnalysis = function (parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    };\n    Parser.prototype.performSelfAnalysis = function () {\n        var _this = this;\n        this.TRACE_INIT(\"performSelfAnalysis\", function () {\n            var defErrorsMsgs;\n            _this.selfAnalysisDone = true;\n            var className = _this.className;\n            _this.TRACE_INIT(\"toFastProps\", function () {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.toFastProperties)(_this);\n            });\n            _this.TRACE_INIT(\"Grammar Recording\", function () {\n                try {\n                    _this.enableRecording();\n                    // Building the GAST\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(_this.definedRulesNames, function (currRuleName) {\n                        var wrappedRule = _this[currRuleName];\n                        var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        var recordedRuleGast = undefined;\n                        _this.TRACE_INIT(currRuleName + \" Rule\", function () {\n                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    _this.disableRecording();\n                }\n            });\n            var resolverErrors = [];\n            _this.TRACE_INIT(\"Grammar Resolving\", function () {\n                resolverErrors = (0,_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_4__.resolveGrammar)({\n                    rules: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache)\n                });\n                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?\n            });\n            _this.TRACE_INIT(\"Grammar Validations\", function () {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(resolverErrors) && _this.skipValidations === false) {\n                    var validationErrors = (0,_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_4__.validateGrammar)({\n                        rules: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache),\n                        maxLookahead: _this.maxLookahead,\n                        tokenTypes: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.tokensMap),\n                        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider,\n                        grammarName: className\n                    });\n                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(_this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (_this.recoveryEnabled) {\n                    _this.TRACE_INIT(\"computeAllProdsFollows\", function () {\n                        var allFollows = (0,_grammar_follow__WEBPACK_IMPORTED_MODULE_1__.computeAllProdsFollows)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache));\n                        _this.resyncFollows = allFollows;\n                    });\n                }\n                _this.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n                    _this.preComputeLookaheadFunctions((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(_this.definitionErrors)) {\n                defErrorsMsgs = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(_this.definitionErrors, function (defError) { return defError.message; });\n                throw new Error(\"Parser Definition Errors detected:\\n \" + defErrorsMsgs.join(\"\\n-------------------------------\\n\"));\n            }\n        });\n    };\n    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n    // (normally during the parser's constructor).\n    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n    // for example: duplicate rule names, referencing an unresolved subrule, ect...\n    // This flag should not be enabled during normal usage, it is used in special situations, for example when\n    // needing to display the parser definition errors in some GUI(online playground).\n    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n    return Parser;\n}());\n\n(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.applyMixins)(Parser, [\n    _traits_recoverable__WEBPACK_IMPORTED_MODULE_5__.Recoverable,\n    _traits_looksahead__WEBPACK_IMPORTED_MODULE_6__.LooksAhead,\n    _traits_tree_builder__WEBPACK_IMPORTED_MODULE_7__.TreeBuilder,\n    _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_8__.LexerAdapter,\n    _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_10__.RecognizerEngine,\n    _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_9__.RecognizerApi,\n    _traits_error_handler__WEBPACK_IMPORTED_MODULE_11__.ErrorHandler,\n    _traits_context_assist__WEBPACK_IMPORTED_MODULE_12__.ContentAssist,\n    _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_13__.GastRecorder,\n    _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_14__.PerformanceTracer\n]);\nvar CstParser = /** @class */ (function (_super) {\n    __extends(CstParser, _super);\n    function CstParser(tokenVocabulary, config) {\n        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }\n        var _this = this;\n        var configClone = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(config);\n        configClone.outputCst = true;\n        _this = _super.call(this, tokenVocabulary, configClone) || this;\n        return _this;\n    }\n    return CstParser;\n}(Parser));\n\nvar EmbeddedActionsParser = /** @class */ (function (_super) {\n    __extends(EmbeddedActionsParser, _super);\n    function EmbeddedActionsParser(tokenVocabulary, config) {\n        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }\n        var _this = this;\n        var configClone = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(config);\n        configClone.outputCst = false;\n        _this = _super.call(this, tokenVocabulary, configClone) || this;\n        return _this;\n    }\n    return EmbeddedActionsParser;\n}(Parser));\n\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci9wYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQytHO0FBQ3JEO0FBQ1M7QUFDZ0M7QUFDYjtBQUNwQztBQUNGO0FBQ0c7QUFDRTtBQUNFO0FBQ007QUFDUjtBQUNFO0FBQ0Y7QUFDRztBQUNsRCxrQkFBa0Isd0VBQW1CLENBQUMsb0RBQUc7QUFDaEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNFQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUCxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQ3hEO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQWdCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQ0FBaUMsa0ZBQWM7QUFDL0MsMkJBQTJCLG9EQUFNO0FBQ2pDLGlCQUFpQjtBQUNqQiwyRkFBMkY7QUFDM0YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTztBQUMzQiwyQ0FBMkMsbUZBQWU7QUFDMUQsK0JBQStCLG9EQUFNO0FBQ3JDO0FBQ0Esb0NBQW9DLG9EQUFNO0FBQzFDLHdDQUF3QyxnRkFBb0M7QUFDNUU7QUFDQSxxQkFBcUI7QUFDckIsaUdBQWlHO0FBQ2pHO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLHFEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1RUFBc0IsQ0FBQyxvREFBTTtBQUN0RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdURBQXVELG9EQUFNO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFPO0FBQ3hCLGdDQUFnQyxpREFBRywrQ0FBK0MsMEJBQTBCO0FBQzVHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNpQjtBQUNsQix5REFBVztBQUNYLElBQUksNERBQVc7QUFDZixJQUFJLDBEQUFVO0FBQ2QsSUFBSSw2REFBVztBQUNmLElBQUksK0RBQVk7QUFDaEIsSUFBSSx3RUFBZ0I7QUFDcEIsSUFBSSxpRUFBYTtBQUNqQixJQUFJLGdFQUFZO0FBQ2hCLElBQUksa0VBQWE7QUFDakIsSUFBSSxnRUFBWTtBQUNoQixJQUFJLG1FQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDBCQUEwQixzREFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSwwQkFBMEIsc0RBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDZ0M7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgYXBwbHlNaXhpbnMsIGNsb25lT2JqLCBmb3JFYWNoLCBoYXMsIGlzRW1wdHksIG1hcCwgdG9GYXN0UHJvcGVydGllcywgdmFsdWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWxsUHJvZHNGb2xsb3dzIH0gZnJvbSBcIi4uL2dyYW1tYXIvZm9sbG93XCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsIGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4uL2Vycm9yc19wdWJsaWNcIjtcbmltcG9ydCB7IHJlc29sdmVHcmFtbWFyLCB2YWxpZGF0ZUdyYW1tYXIgfSBmcm9tIFwiLi4vZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljXCI7XG5pbXBvcnQgeyBSZWNvdmVyYWJsZSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvdmVyYWJsZVwiO1xuaW1wb3J0IHsgTG9va3NBaGVhZCB9IGZyb20gXCIuL3RyYWl0cy9sb29rc2FoZWFkXCI7XG5pbXBvcnQgeyBUcmVlQnVpbGRlciB9IGZyb20gXCIuL3RyYWl0cy90cmVlX2J1aWxkZXJcIjtcbmltcG9ydCB7IExleGVyQWRhcHRlciB9IGZyb20gXCIuL3RyYWl0cy9sZXhlcl9hZGFwdGVyXCI7XG5pbXBvcnQgeyBSZWNvZ25pemVyQXBpIH0gZnJvbSBcIi4vdHJhaXRzL3JlY29nbml6ZXJfYXBpXCI7XG5pbXBvcnQgeyBSZWNvZ25pemVyRW5naW5lIH0gZnJvbSBcIi4vdHJhaXRzL3JlY29nbml6ZXJfZW5naW5lXCI7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tIFwiLi90cmFpdHMvZXJyb3JfaGFuZGxlclwiO1xuaW1wb3J0IHsgQ29udGVudEFzc2lzdCB9IGZyb20gXCIuL3RyYWl0cy9jb250ZXh0X2Fzc2lzdFwiO1xuaW1wb3J0IHsgR2FzdFJlY29yZGVyIH0gZnJvbSBcIi4vdHJhaXRzL2dhc3RfcmVjb3JkZXJcIjtcbmltcG9ydCB7IFBlcmZvcm1hbmNlVHJhY2VyIH0gZnJvbSBcIi4vdHJhaXRzL3BlcmZfdHJhY2VyXCI7XG5leHBvcnQgdmFyIEVORF9PRl9GSUxFID0gY3JlYXRlVG9rZW5JbnN0YW5jZShFT0YsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuT2JqZWN0LmZyZWV6ZShFTkRfT0ZfRklMRSk7XG5leHBvcnQgdmFyIERFRkFVTFRfUEFSU0VSX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlY292ZXJ5RW5hYmxlZDogZmFsc2UsXG4gICAgbWF4TG9va2FoZWFkOiAzLFxuICAgIGR5bmFtaWNUb2tlbnNFbmFibGVkOiBmYWxzZSxcbiAgICBvdXRwdXRDc3Q6IHRydWUsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLFxuICAgIG5vZGVMb2NhdGlvblRyYWNraW5nOiBcIm5vbmVcIixcbiAgICB0cmFjZUluaXRQZXJmOiBmYWxzZSxcbiAgICBza2lwVmFsaWRhdGlvbnM6IGZhbHNlXG59KTtcbmV4cG9ydCB2YXIgREVGQVVMVF9SVUxFX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlY292ZXJ5VmFsdWVGdW5jOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgcmVzeW5jRW5hYmxlZDogdHJ1ZVxufSk7XG5leHBvcnQgdmFyIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGU7XG4oZnVuY3Rpb24gKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUpIHtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfTkFNRVwiXSA9IDBdID0gXCJJTlZBTElEX1JVTEVfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkRVUExJQ0FURV9SVUxFX05BTUVcIl0gPSAxXSA9IFwiRFVQTElDQVRFX1JVTEVfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfUlVMRV9PVkVSUklERVwiXSA9IDJdID0gXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUFJPRFVDVElPTlNcIl0gPSAzXSA9IFwiRFVQTElDQVRFX1BST0RVQ1RJT05TXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiXSA9IDRdID0gXCJVTlJFU09MVkVEX1NVQlJVTEVfUkVGXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTEVGVF9SRUNVUlNJT05cIl0gPSA1XSA9IFwiTEVGVF9SRUNVUlNJT05cIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT05FX0xBU1RfRU1QVFlfQUxUXCJdID0gNl0gPSBcIk5PTkVfTEFTVF9FTVBUWV9BTFRcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJBTUJJR1VPVVNfQUxUU1wiXSA9IDddID0gXCJBTUJJR1VPVVNfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIl0gPSA4XSA9IFwiQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfVE9LRU5fTkFNRVwiXSA9IDldID0gXCJJTlZBTElEX1RPS0VOX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT19OT05fRU1QVFlfTE9PS0FIRUFEXCJdID0gMTBdID0gXCJOT19OT05fRU1QVFlfTE9PS0FIRUFEXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX1BSRUZJWF9BTFRTXCJdID0gMTFdID0gXCJBTUJJR1VPVVNfUFJFRklYX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJUT09fTUFOWV9BTFRTXCJdID0gMTJdID0gXCJUT09fTUFOWV9BTFRTXCI7XG59KShQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIHx8IChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBFTVBUWV9BTFQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuc2VsZkFuYWx5c2lzRG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoYXQuaW5pdEVycm9ySGFuZGxlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRMZXhlckFkYXB0ZXIoKTtcbiAgICAgICAgdGhhdC5pbml0TG9va3NBaGVhZChjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRSZWNvZ25pemVyRW5naW5lKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UmVjb3ZlcmFibGUoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0VHJlZUJ1aWxkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0Q29udGVudEFzc2lzdCgpO1xuICAgICAgICB0aGF0LmluaXRHYXN0UmVjb3JkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UGVyZm9ybWFuY2VUcmFjZXIoY29uZmlnKTtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwiaWdub3JlZElzc3Vlc1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxpZ25vcmVkSXNzdWVzPiBJUGFyc2VyQ29uZmlnIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0aGUgPElHTk9SRV9BTUJJR1VJVElFUz4gZmxhZyBvbiB0aGUgcmVsZXZhbnQgRFNMIG1ldGhvZCBpbnN0ZWFkLlxcblxcdFwiICtcbiAgICAgICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNJR05PUklOR19BTUJJR1VJVElFU1xcblxcdFwiICtcbiAgICAgICAgICAgICAgICBcIkZvciBmdXJ0aGVyIGRldGFpbHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcFZhbGlkYXRpb25zID0gaGFzKGNvbmZpZywgXCJza2lwVmFsaWRhdGlvbnNcIilcbiAgICAgICAgICAgID8gY29uZmlnLnNraXBWYWxpZGF0aW9uc1xuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcuc2tpcFZhbGlkYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQGRlcHJlY2F0ZWQgdXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkXG4gICAgICovXG4gICAgUGFyc2VyLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAocGFyc2VySW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgKipzdGF0aWMqKiBgcGVyZm9ybVNlbGZBbmFseXNpc2AgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIgK1xuICAgICAgICAgICAgXCJcXHRcXG5Vc2UgdGhlICoqaW5zdGFuY2UqKiBtZXRob2Qgd2l0aCB0aGUgc2FtZSBuYW1lIGluc3RlYWQuXCIpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wZXJmb3JtU2VsZkFuYWx5c2lzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJwZXJmb3JtU2VsZkFuYWx5c2lzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWZFcnJvcnNNc2dzO1xuICAgICAgICAgICAgX3RoaXMuc2VsZkFuYWx5c2lzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX3RoaXMuY2xhc3NOYW1lO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgdm9vZG9vIG1hZ2ljIHRoZSBwYXJzZXIgd291bGQgYmUgeDMteDQgc2xvd2VyXG4gICAgICAgICAgICAgICAgLy8gSXQgc2VlbXMgaXQgaXMgYmV0dGVyIHRvIGludm9rZSBgdG9GYXN0UHJvcGVydGllc2AgKipiZWZvcmUqKlxuICAgICAgICAgICAgICAgIC8vIEFueSBtYW5pcHVsYXRpb25zIG9mIHRoZSBgdGhpc2Agb2JqZWN0IGRvbmUgZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgICAgICAgICAgdG9GYXN0UHJvcGVydGllcyhfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFJlY29yZGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW5hYmxlUmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkaW5nIHRoZSBHQVNUXG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2goX3RoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIGZ1bmN0aW9uIChjdXJyUnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkUnVsZSA9IF90aGlzW2N1cnJSdWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxHcmFtbWFyQWN0aW9uID0gd3JhcHBlZFJ1bGVbXCJvcmlnaW5hbEdyYW1tYXJBY3Rpb25cIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkZWRSdWxlR2FzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoY3VyclJ1bGVOYW1lICsgXCIgUnVsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWRSdWxlR2FzdCA9IF90aGlzLnRvcExldmVsUnVsZVJlY29yZChjdXJyUnVsZU5hbWUsIG9yaWdpbmFsR3JhbW1hckFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlW2N1cnJSdWxlTmFtZV0gPSByZWNvcmRlZFJ1bGVHYXN0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2FibGVSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlckVycm9ycyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkdyYW1tYXIgUmVzb2x2aW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlckVycm9ycyA9IHJlc29sdmVHcmFtbWFyKHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHZhbHVlcyhfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2guYXBwbHkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycywgcmVzb2x2ZXJFcnJvcnMpOyAvLyBtdXRhYmlsaXR5IGZvciB0aGUgd2luP1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBWYWxpZGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBwZXJmb3JtIGFkZGl0aW9uYWwgZ3JhbW1hciB2YWxpZGF0aW9ucyBJRkYgbm8gcmVzb2x2aW5nIGVycm9ycyBoYXZlIG9jY3VycmVkLlxuICAgICAgICAgICAgICAgIC8vIGFzIHVucmVzb2x2ZWQgZ3JhbW1hciBtYXkgbGVhZCB0byB1bmhhbmRsZWQgcnVudGltZSBleGNlcHRpb25zIGluIHRoZSBmb2xsb3cgdXAgdmFsaWRhdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkocmVzb2x2ZXJFcnJvcnMpICYmIF90aGlzLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0ZUdyYW1tYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHZhbHVlcyhfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMb29rYWhlYWQ6IF90aGlzLm1heExvb2thaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IHZhbHVlcyhfdGhpcy50b2tlbnNNYXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXJOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseShfdGhpcy5kZWZpbml0aW9uRXJyb3JzLCB2YWxpZGF0aW9uRXJyb3JzKTsgLy8gbXV0YWJpbGl0eSBmb3IgdGhlIHdpbj9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgYW5hbHlzaXMgbWF5IGZhaWwgaWYgdGhlIGdyYW1tYXIgaXMgbm90IHBlcmZlY3RseSB2YWxpZFxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0cyBvZiB0aGVzZSBjb21wdXRhdGlvbnMgYXJlIG5vdCBuZWVkZWQgdW5sZXNzIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiY29tcHV0ZUFsbFByb2RzRm9sbG93c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsRm9sbG93cyA9IGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN5bmNGb2xsb3dzID0gYWxsRm9sbG93cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyh2YWx1ZXMoX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUGFyc2VyLkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HICYmXG4gICAgICAgICAgICAgICAgIWlzRW1wdHkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBkZWZFcnJvcnNNc2dzID0gbWFwKF90aGlzLmRlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChkZWZFcnJvcikgeyByZXR1cm4gZGVmRXJyb3IubWVzc2FnZTsgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIERlZmluaXRpb24gRXJyb3JzIGRldGVjdGVkOlxcbiBcIiArIGRlZkVycm9yc01zZ3Muam9pbihcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFNldCB0aGlzIGZsYWcgdG8gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgUGFyc2VyIHRvIHRocm93IGVycm9yIHdoZW4gcHJvYmxlbXMgaW4gaXQncyBkZWZpbml0aW9uIGFyZSBkZXRlY3RlZC5cbiAgICAvLyAobm9ybWFsbHkgZHVyaW5nIHRoZSBwYXJzZXIncyBjb25zdHJ1Y3RvcikuXG4gICAgLy8gVGhpcyBpcyBhIGRlc2lnbiB0aW1lIGZsYWcsIGl0IHdpbGwgbm90IGFmZmVjdCB0aGUgcnVudGltZSBlcnJvciBoYW5kbGluZyBvZiB0aGUgcGFyc2VyLCBqdXN0IGRlc2lnbiB0aW1lIGVycm9ycyxcbiAgICAvLyBmb3IgZXhhbXBsZTogZHVwbGljYXRlIHJ1bGUgbmFtZXMsIHJlZmVyZW5jaW5nIGFuIHVucmVzb2x2ZWQgc3VicnVsZSwgZWN0Li4uXG4gICAgLy8gVGhpcyBmbGFnIHNob3VsZCBub3QgYmUgZW5hYmxlZCBkdXJpbmcgbm9ybWFsIHVzYWdlLCBpdCBpcyB1c2VkIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgZm9yIGV4YW1wbGUgd2hlblxuICAgIC8vIG5lZWRpbmcgdG8gZGlzcGxheSB0aGUgcGFyc2VyIGRlZmluaXRpb24gZXJyb3JzIGluIHNvbWUgR1VJKG9ubGluZSBwbGF5Z3JvdW5kKS5cbiAgICBQYXJzZXIuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcgPSBmYWxzZTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmV4cG9ydCB7IFBhcnNlciB9O1xuYXBwbHlNaXhpbnMoUGFyc2VyLCBbXG4gICAgUmVjb3ZlcmFibGUsXG4gICAgTG9va3NBaGVhZCxcbiAgICBUcmVlQnVpbGRlcixcbiAgICBMZXhlckFkYXB0ZXIsXG4gICAgUmVjb2duaXplckVuZ2luZSxcbiAgICBSZWNvZ25pemVyQXBpLFxuICAgIEVycm9ySGFuZGxlcixcbiAgICBDb250ZW50QXNzaXN0LFxuICAgIEdhc3RSZWNvcmRlcixcbiAgICBQZXJmb3JtYW5jZVRyYWNlclxuXSk7XG52YXIgQ3N0UGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDc3RQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3N0UGFyc2VyKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBERUZBVUxUX1BBUlNFUl9DT05GSUc7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZ0Nsb25lID0gY2xvbmVPYmooY29uZmlnKTtcbiAgICAgICAgY29uZmlnQ2xvbmUub3V0cHV0Q3N0ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0b2tlblZvY2FidWxhcnksIGNvbmZpZ0Nsb25lKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDc3RQYXJzZXI7XG59KFBhcnNlcikpO1xuZXhwb3J0IHsgQ3N0UGFyc2VyIH07XG52YXIgRW1iZWRkZWRBY3Rpb25zUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbWJlZGRlZEFjdGlvbnNQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWRkZWRBY3Rpb25zUGFyc2VyKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBERUZBVUxUX1BBUlNFUl9DT05GSUc7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZ0Nsb25lID0gY2xvbmVPYmooY29uZmlnKTtcbiAgICAgICAgY29uZmlnQ2xvbmUub3V0cHV0Q3N0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdG9rZW5Wb2NhYnVsYXJ5LCBjb25maWdDbG9uZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRW1iZWRkZWRBY3Rpb25zUGFyc2VyO1xufShQYXJzZXIpKTtcbmV4cG9ydCB7IEVtYmVkZGVkQWN0aW9uc1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentAssist: () => (/* binding */ ContentAssist)\n/* harmony export */ });\n/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/interpreter */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\n\nvar ContentAssist = /** @class */ (function () {\n    function ContentAssist() {\n    }\n    ContentAssist.prototype.initContentAssist = function () { };\n    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {\n        var startRuleGast = this.gastProductionsCache[startRuleName];\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(startRuleGast)) {\n            throw Error(\"Rule ->\" + startRuleName + \"<- does not exist in this grammar.\");\n        }\n        return (0,_grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    };\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {\n        var topRuleName = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(grammarPath.ruleStack);\n        var gastProductions = this.getGAstProductions();\n        var topProduction = gastProductions[topRuleName];\n        var nextPossibleTokenTypes = new _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__.NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    };\n    return ContentAssist;\n}());\n\n//# sourceMappingURL=context_assist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvY29udGV4dF9hc3Npc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBGO0FBQ2hDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVc7QUFDdkI7QUFDQTtBQUNBLGVBQWUsNkVBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFLO0FBQy9CO0FBQ0E7QUFDQSx5Q0FBeUMsc0VBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDd0I7QUFDekIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHRyYWl0c1xcY29udGV4dF9hc3Npc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dEFmdGVyVG9rZW5XYWxrZXIsIG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXJcIjtcbmltcG9ydCB7IGZpcnN0LCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xudmFyIENvbnRlbnRBc3Npc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudEFzc2lzdCgpIHtcbiAgICB9XG4gICAgQ29udGVudEFzc2lzdC5wcm90b3R5cGUuaW5pdENvbnRlbnRBc3Npc3QgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29udGVudEFzc2lzdC5wcm90b3R5cGUuY29tcHV0ZUNvbnRlbnRBc3Npc3QgPSBmdW5jdGlvbiAoc3RhcnRSdWxlTmFtZSwgcHJlY2VkaW5nSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0UnVsZUdhc3QgPSB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlW3N0YXJ0UnVsZU5hbWVdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoc3RhcnRSdWxlR2FzdCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiUnVsZSAtPlwiICsgc3RhcnRSdWxlTmFtZSArIFwiPC0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncmFtbWFyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW3N0YXJ0UnVsZUdhc3RdLCBwcmVjZWRpbmdJbnB1dCwgdGhpcy50b2tlbk1hdGNoZXIsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGEgbWVtYmVyIG1ldGhvZCBvciBhIHV0aWxpdHk/IGl0IGRvZXMgbm90IGhhdmUgYW55IHN0YXRlIG9yIHVzYWdlIG9mICd0aGlzJy4uLlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIG1vcmUgZXhwbGljaXRseSBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJP1xuICAgIENvbnRlbnRBc3Npc3QucHJvdG90eXBlLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMgPSBmdW5jdGlvbiAoZ3JhbW1hclBhdGgpIHtcbiAgICAgICAgdmFyIHRvcFJ1bGVOYW1lID0gZmlyc3QoZ3JhbW1hclBhdGgucnVsZVN0YWNrKTtcbiAgICAgICAgdmFyIGdhc3RQcm9kdWN0aW9ucyA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCk7XG4gICAgICAgIHZhciB0b3BQcm9kdWN0aW9uID0gZ2FzdFByb2R1Y3Rpb25zW3RvcFJ1bGVOYW1lXTtcbiAgICAgICAgdmFyIG5leHRQb3NzaWJsZVRva2VuVHlwZXMgPSBuZXcgTmV4dEFmdGVyVG9rZW5XYWxrZXIodG9wUHJvZHVjdGlvbiwgZ3JhbW1hclBhdGgpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5UeXBlcztcbiAgICB9O1xuICAgIHJldHVybiBDb250ZW50QXNzaXN0O1xufSgpKTtcbmV4cG9ydCB7IENvbnRlbnRBc3Npc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHRfYXNzaXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler)\n/* harmony export */ });\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../exceptions_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../grammar/lookahead */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider\n            : _parser__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_0__.isRecognitionException)(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        get: function () {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__.EarlyExitException(msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__.NoViableAltException(errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\n\n//# sourceMappingURL=error_handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZXJyb3JfaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRztBQUN0RDtBQUM4QztBQUNqRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlEQUFHO0FBQ3ZDO0FBQ0EsY0FBYywwREFBcUI7QUFDbkM7QUFDQTtBQUNBLFlBQVksMEVBQXNCO0FBQ2xDO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVE7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvRkFBZ0M7QUFDM0U7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msa0VBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwRUFBc0I7QUFDakU7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msb0VBQW9CO0FBQ3REO0FBQ0E7QUFDQSxDQUFDO0FBQ3VCO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxwYXJzZVxccGFyc2VyXFx0cmFpdHNcXGVycm9yX2hhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWFybHlFeGl0RXhjZXB0aW9uLCBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGhhcyB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QsIGdldExvb2thaGVhZFBhdGhzRm9yT3IgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sb29rYWhlYWRcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbnZhciBFcnJvckhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xuICAgIH1cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmluaXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyID0gaGFzKGNvbmZpZywgXCJlcnJvck1lc3NhZ2VQcm92aWRlclwiKVxuICAgICAgICAgICAgPyBjb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXJcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLmVycm9yTWVzc2FnZVByb3ZpZGVyO1xuICAgIH07XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5TQVZFX0VSUk9SID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChpc1JlY29nbml0aW9uRXhjZXB0aW9uKGVycm9yKSkge1xuICAgICAgICAgICAgZXJyb3IuY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IHRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpLFxuICAgICAgICAgICAgICAgIHJ1bGVPY2N1cnJlbmNlU3RhY2s6IGNsb25lQXJyKHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVHJ5aW5nIHRvIHNhdmUgYW4gRXJyb3Igd2hpY2ggaXMgbm90IGEgUmVjb2duaXRpb25FeGNlcHRpb25cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckhhbmRsZXIucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyKHRoaXMuX2Vycm9ycyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0Vycm9ycykge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gbmV3RXJyb3JzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgY2FjaGluZyB0aGUgZXJyb3IgbWVzc2FnZSBjb21wdXRlZCBpbmZvcm1hdGlvblxuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmFpc2VFYXJseUV4aXRFeGNlcHRpb24gPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgcHJvZFR5cGUsIHVzZXJEZWZpbmVkRXJyTXNnKSB7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICB2YXIgcnVsZUdyYW1tYXIgPSB0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW3J1bGVOYW1lXTtcbiAgICAgICAgdmFyIGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgdmFyIGluc2lkZVByb2RQYXRocyA9IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmVbMF07XG4gICAgICAgIHZhciBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKHtcbiAgICAgICAgICAgIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHM6IGluc2lkZVByb2RQYXRocyxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuTEEoMCksXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IHVzZXJEZWZpbmVkRXJyTXNnLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IEVhcmx5RXhpdEV4Y2VwdGlvbihtc2csIHRoaXMuTEEoMSksIHRoaXMuTEEoMCkpKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIGNhY2hpbmcgdGhlIGVycm9yIG1lc3NhZ2UgY29tcHV0ZWQgaW5mb3JtYXRpb25cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJhaXNlTm9BbHRFeGNlcHRpb24gPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgZXJyTXNnVHlwZXMpIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIHZhciBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbcnVsZU5hbWVdO1xuICAgICAgICAvLyBUT0RPOiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yIGNhbiBiZSBzbG93IGZvciBsYXJnZSBlbm91Z2ggbWF4TG9va2FoZWFkIGFuZCBjZXJ0YWluIGdyYW1tYXJzLCBjb25zaWRlciBjYWNoaW5nID9cbiAgICAgICAgdmFyIGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgICAgIHZhciBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICB2YXIgZXJyTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vVmlhYmxlQWx0TWVzc2FnZSh7XG4gICAgICAgICAgICBleHBlY3RlZFBhdGhzUGVyQWx0OiBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlLFxuICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWxUb2tlbnMsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNUb2tlbixcbiAgICAgICAgICAgIGN1c3RvbVVzZXJEZXNjcmlwdGlvbjogZXJyTXNnVHlwZXMsXG4gICAgICAgICAgICBydWxlTmFtZTogdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24oZXJyTXNnLCB0aGlzLkxBKDEpLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xufSgpKTtcbmV4cG9ydCB7IEVycm9ySGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfaGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GastRecorder: () => (/* binding */ GastRecorder)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scan/lexer_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scan/tokens */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../grammar/keys */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n\n\n\n\n\n\n\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, _grammar_keys__WEBPACK_IMPORTED_MODULE_6__.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__.createToken)({ name: \"RECORDING_PHASE_TOKEN\", pattern: _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.Lexer.NA });\n(0,_scan_tokens__WEBPACK_IMPORTED_MODULE_3__.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return _parser__WEBPACK_IMPORTED_MODULE_5__.END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!(0,_scan_tokens__WEBPACK_IMPORTED_MODULE_3__.hasShortKeyProperty)(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);\n        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal({\n            idx: occurrence,\n            terminalType: tokType\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);\n    var grammarAction = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.some)(alts, function (currAlt) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(alts, function (currAlt) {\n        var currAltFlat = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZ2FzdF9yZWNvcmRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRjtBQUNzSDtBQUN4SjtBQUMyQjtBQUNDO0FBQ3ZDO0FBQ3FCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQXVCO0FBQ3hELFVBQVUsZ0VBQVcsR0FBRyx3Q0FBd0MscURBQUssS0FBSztBQUMxRSwrREFBaUI7QUFDakIsNEJBQTRCLHdFQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyREFBSSxHQUFHLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkRBQU07QUFDM0M7QUFDQTtBQUNBLDhCQUE4QiwwRUFBbUI7QUFDakQ7QUFDQTtBQUNBLDhCQUE4Qix1RkFBZ0M7QUFDOUQ7QUFDQTtBQUNBLDhCQUE4QixpRUFBVTtBQUN4QztBQUNBO0FBQ0EsOEJBQThCLDhFQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFJO0FBQzNCO0FBQ0Esa0NBQWtDLGtFQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQUk7QUFDM0Isa0NBQWtDLCtEQUFRO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3VCO0FBQ3hCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsbUJBQW1CLGtEQUFJO0FBQ3ZCLHdCQUF3Qix3REFBVTtBQUNsQyx3Q0FBd0MsaUNBQWlDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFJO0FBQ3ZCO0FBQ0EscUJBQXFCLHFEQUFPO0FBQzVCO0FBQ0Esd0JBQXdCLGtFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLGlEQUFHO0FBQ1g7QUFDQTtBQUNBLHdCQUF3QixrREFBSSw0QkFBNEIsT0FBTyx3REFBVSxpQkFBaUI7QUFDMUY7QUFDQTtBQUNBLElBQUkscURBQU87QUFDWCw4QkFBOEIsa0VBQVcsR0FBRyxnQkFBZ0I7QUFDNUQ7QUFDQSxZQUFZLGlEQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHRyYWl0c1xcZ2FzdF9yZWNvcmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRnVuY3Rpb24sIHBlZWssIHNvbWUgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vbGV4ZXJfcHVibGljXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgaGFzU2hvcnRLZXlQcm9wZXJ0eSB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc1wiO1xuaW1wb3J0IHsgY3JlYXRlVG9rZW4sIGNyZWF0ZVRva2VuSW5zdGFuY2UgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBFTkRfT0ZfRklMRSB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbmltcG9ydCB7IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIva2V5c1wiO1xudmFyIFJFQ09SRElOR19OVUxMX09CSkVDVCA9IHtcbiAgICBkZXNjcmlwdGlvbjogXCJUaGlzIE9iamVjdCBpbmRpY2F0ZXMgdGhlIFBhcnNlciBpcyBkdXJpbmcgUmVjb3JkaW5nIFBoYXNlXCJcbn07XG5PYmplY3QuZnJlZXplKFJFQ09SRElOR19OVUxMX09CSkVDVCk7XG52YXIgSEFORExFX1NFUEFSQVRPUiA9IHRydWU7XG52YXIgTUFYX01FVEhPRF9JRFggPSBNYXRoLnBvdygyLCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCkgLSAxO1xudmFyIFJGVCA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJSRUNPUkRJTkdfUEhBU0VfVE9LRU5cIiwgcGF0dGVybjogTGV4ZXIuTkEgfSk7XG5hdWdtZW50VG9rZW5UeXBlcyhbUkZUXSk7XG52YXIgUkVDT1JESU5HX1BIQVNFX1RPS0VOID0gY3JlYXRlVG9rZW5JbnN0YW5jZShSRlQsIFwiVGhpcyBJVG9rZW4gaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgIFwiXCIgK1xuICAgIFwiU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL2ludGVybmFscy5odG1sI2dyYW1tYXItcmVjb3JkaW5nIGZvciBkZXRhaWxzXCIsIFxuLy8gVXNpbmcgXCItMVwiIGluc3RlYWQgb2YgTmFOIChhcyBpbiBFT0YpIGJlY2F1c2UgYW4gYWN0dWFsIG51bWJlciBpcyBsZXNzIGxpa2VseSB0b1xuLy8gY2F1c2UgZXJyb3JzIGlmIHRoZSBvdXRwdXQgb2YgTEEgb3IgQ09OU1VNRSB3b3VsZCBiZSAoaW5jb3JyZWN0bHkpIHVzZWQgZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4tMSwgLTEsIC0xLCAtMSwgLTEsIC0xKTtcbk9iamVjdC5mcmVlemUoUkVDT1JESU5HX1BIQVNFX1RPS0VOKTtcbnZhciBSRUNPUkRJTkdfUEhBU0VfQ1NUTk9ERSA9IHtcbiAgICBuYW1lOiBcIlRoaXMgQ1NUTm9kZSBpbmRpY2F0ZXMgdGhlIFBhcnNlciBpcyBpbiBSZWNvcmRpbmcgUGhhc2VcXG5cXHRcIiArXG4gICAgICAgIFwiU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL2ludGVybmFscy5odG1sI2dyYW1tYXItcmVjb3JkaW5nIGZvciBkZXRhaWxzXCIsXG4gICAgY2hpbGRyZW46IHt9XG59O1xuLyoqXG4gKiBUaGlzIHRyYWl0IGhhbmRsZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBHQVNUIHN0cnVjdHVyZSBmb3IgQ2hldnJvdGFpbiBHcmFtbWFyc1xuICovXG52YXIgR2FzdFJlY29yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhc3RSZWNvcmRlcigpIHtcbiAgICB9XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5pbml0R2FzdFJlY29yZGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5lbmFibGVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiRW5hYmxlIFJlY29yZGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGkgPiAwID8gaSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJDT05TVU1FXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJTVUJSVUxFXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJPUFRJT05cIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiT1JcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsUmVjb3JkKGFyZzEsIGkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJNQU5ZXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk1BTllfU0VQXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiQVRfTEVBU1RfT05FXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIkFUX0xFQVNUX09ORV9TRVBcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXYXJuaW5nIERhcmsgVm9vZG9vIE1hZ2ljIHVwY29taW5nIVxuICAgICAgICAgICAgICogV2UgYXJlIFwicmVwbGFjaW5nXCIgdGhlIHB1YmxpYyBwYXJzaW5nIERTTCBtZXRob2RzIEFQSVxuICAgICAgICAgICAgICogV2l0aCAqKm5ldyoqIGFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9ucyBvbiB0aGUgUGFyc2VyICoqaW5zdGFuY2UqKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNvIGZhciB0aGlzIGlzIHRoZSBvbmx5IHdheSBJJ3ZlIGZvdW5kIHRvIGF2b2lkIHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb25zIGR1cmluZyBwYXJzaW5nIHRpbWUuXG4gICAgICAgICAgICAgKiAtIEFwcHJveCAzMCUgcGVyZm9ybWFuY2UgcmVncmVzc2lvbiB3YXMgbWVhc3VyZWQgb24gQ2hyb21lIDc1IENhbmFyeSB3aGVuIGF0dGVtcHRpbmcgdG8gcmVwbGFjZSB0aGUgXCJpbnRlcm5hbFwiXG4gICAgICAgICAgICAgKiAgIGltcGxlbWVudGF0aW9ucyBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRFNMIG1ldGhvZHMgd2l0aCB0aGUgaWR4KHN1ZmZpeCkgYXMgYW4gYXJndW1lbnRcbiAgICAgICAgICAgIF90aGlzW1wiY29uc3VtZVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4LCBhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcInN1YnJ1bGVcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsUmVjb3JkKGFyZzEsIGlkeCwgYXJnMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXNbXCJvcHRpb25cIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcIm9yXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcIm1hbnlcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW55SW50ZXJuYWxSZWNvcmQoaWR4LCBhcmcxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcImF0TGVhc3RPbmVcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQoaWR4LCBhcmcxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5BQ1RJT04gPSBfdGhpcy5BQ1RJT05fUkVDT1JEO1xuICAgICAgICAgICAgX3RoaXMuQkFDS1RSQUNLID0gX3RoaXMuQkFDS1RSQUNLX1JFQ09SRDtcbiAgICAgICAgICAgIF90aGlzLkxBID0gX3RoaXMuTEFfUkVDT1JEO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuZGlzYWJsZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5SRUNPUkRJTkdfUEhBU0UgPSBmYWxzZTtcbiAgICAgICAgLy8gQnkgZGVsZXRpbmcgdGhlc2UgKippbnN0YW5jZSoqIHByb3BlcnRpZXMsIGFueSBmdXR1cmUgaW52b2NhdGlvblxuICAgICAgICAvLyB3aWxsIGJlIGRlZmVycmVkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2RzIG9uIHRoZSAqKnByb3RvdHlwZSoqIG9iamVjdFxuICAgICAgICAvLyBUaGlzIHNlZW1zIHRvIGdldCByaWQgb2YgYW55IGluY29ycmVjdCBvcHRpbWl6YXRpb25zIHRoYXQgVjggbWF5XG4gICAgICAgIC8vIGRvIGR1cmluZyB0aGUgcmVjb3JkaW5nIHBoYXNlLlxuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJEZWxldGluZyBSZWNvcmRpbmcgbWV0aG9kc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJDT05TVU1FXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIlNVQlJVTEVcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiT1BUSU9OXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIk9SXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIk1BTllcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiTUFOWV9TRVBcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiQVRfTEVBU1RfT05FXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIkFUX0xFQVNUX09ORV9TRVBcIiArIGlkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJjb25zdW1lXCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wic3VicnVsZVwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIm9wdGlvblwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIm9yXCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wibWFueVwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcImF0TGVhc3RPbmVcIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuQUNUSU9OO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLkJBQ0tUUkFDSztcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5MQTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBpcyB0aGVyZSBhbnkgd2F5IHRvIHVzZSB0aGlzIG1ldGhvZCB0byBjaGVjayBub1xuICAgIC8vICAgUGFyc2VyIG1ldGhvZHMgYXJlIGNhbGxlZCBpbnNpZGUgYW4gQUNUSU9OP1xuICAgIC8vICAgTWF5YmUgdHJ5L2NhdGNoL2ZpbmFsbHkgb24gQUNUSU9OUyB3aGlsZSBkaXNhYmxpbmcgdGhlIHJlY29yZGVycyBzdGF0ZSBjaGFuZ2VzP1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuQUNUSU9OX1JFQ09SRCA9IGZ1bmN0aW9uIChpbXBsKSB7XG4gICAgICAgIC8vIE5PLU9QIGR1cmluZyByZWNvcmRpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLy8gRXhlY3V0aW5nIGJhY2t0cmFja2luZyBsb2dpYyB3aWxsIGJyZWFrIG91ciByZWNvcmRpbmcgbG9naWMgYXNzdW1wdGlvbnNcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLkJBQ0tUUkFDS19SRUNPUkQgPSBmdW5jdGlvbiAoZ3JhbW1hclJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgfTtcbiAgICAvLyBMQSBpcyBwYXJ0IG9mIHRoZSBvZmZpY2lhbCBBUEkgYW5kIG1heSBiZSB1c2VkIGZvciBjdXN0b20gbG9va2FoZWFkIGxvZ2ljXG4gICAgLy8gYnkgZW5kIHVzZXJzIHdobyBtYXkgZm9yZ2V0IHRvIHdyYXAgaXQgaW4gQUNUSU9OIG9yIGluc2lkZSBhIEdBVEVcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLkxBX1JFQ09SRCA9IGZ1bmN0aW9uIChob3dNdWNoKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgdGhlIFJFQ09SRF9QSEFTRV9UT0tFTiBoZXJlIGJlY2F1c2Ugc29tZW9uZSBtYXkgZGVwZW5kXG4gICAgICAgIC8vIE9uIExBIHJldHVybiBFT0YgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgc28gYW4gaW5maW5pdGUgbG9vcCBtYXkgb2NjdXIuXG4gICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUudG9wTGV2ZWxSdWxlUmVjb3JkID0gZnVuY3Rpb24gKG5hbWUsIGRlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG5ld1RvcExldmVsUnVsZSA9IG5ldyBSdWxlKHsgZGVmaW5pdGlvbjogW10sIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBuZXdUb3BMZXZlbFJ1bGUubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wdXNoKG5ld1RvcExldmVsUnVsZSk7XG4gICAgICAgICAgICBkZWYuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1RvcExldmVsUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuXFx0IFRoaXMgZXJyb3Igd2FzIHRocm93biBkdXJpbmcgdGhlIFwiZ3JhbW1hciByZWNvcmRpbmcgcGhhc2VcIiBGb3IgbW9yZSBpbmZvIHNlZTpcXG5cXHQnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG11dGFiaWxpdHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBlcnJvciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBwYXJzaW5nIERTTFxuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZFByb2QuY2FsbCh0aGlzLCBPcHRpb24sIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUubWFueUludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uLCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUub3JJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRPclByb2QuY2FsbCh0aGlzLCBhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuc3VicnVsZUludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICAgICAgaWYgKCFydWxlVG9DYWxsIHx8IGhhcyhydWxlVG9DYWxsLCBcInJ1bGVOYW1lXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiPFNVQlJVTEVcIiArIGdldElkeFN1ZmZpeChvY2N1cnJlbmNlKSArIFwiPiBhcmd1bWVudCBpcyBpbnZhbGlkXCIgK1xuICAgICAgICAgICAgICAgIChcIiBleHBlY3RpbmcgYSBQYXJzZXIgbWV0aG9kIHJlZmVyZW5jZSBidXQgZ290OiA8XCIgKyBKU09OLnN0cmluZ2lmeShydWxlVG9DYWxsKSArIFwiPlwiKSArXG4gICAgICAgICAgICAgICAgKFwiXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPFwiICsgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2tbMF0ubmFtZSArIFwiPlwiKSk7XG4gICAgICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gcnVsZVRvQ2FsbFtcInJ1bGVOYW1lXCJdO1xuICAgICAgICB2YXIgbmV3Tm9uZVRlcm1pbmFsID0gbmV3IE5vblRlcm1pbmFsKHtcbiAgICAgICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgIG5vblRlcm1pbmFsTmFtZTogcnVsZU5hbWUsXG4gICAgICAgICAgICAvLyBUaGUgcmVzb2x2aW5nIG9mIHRoZSBgcmVmZXJlbmNlZFJ1bGVgIHByb3BlcnR5IHdpbGwgYmUgZG9uZSBvbmNlIGFsbCB0aGUgUnVsZSdzIEdBU1RzIGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICByZWZlcmVuY2VkUnVsZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2UHJvZC5kZWZpbml0aW9uLnB1c2gobmV3Tm9uZVRlcm1pbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Q3N0ID8gUkVDT1JESU5HX1BIQVNFX0NTVE5PREUgOiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgICAgIGlmICghaGFzU2hvcnRLZXlQcm9wZXJ0eSh0b2tUeXBlKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiPENPTlNVTUVcIiArIGdldElkeFN1ZmZpeChvY2N1cnJlbmNlKSArIFwiPiBhcmd1bWVudCBpcyBpbnZhbGlkXCIgK1xuICAgICAgICAgICAgICAgIChcIiBleHBlY3RpbmcgYSBUb2tlblR5cGUgcmVmZXJlbmNlIGJ1dCBnb3Q6IDxcIiArIEpTT04uc3RyaW5naWZ5KHRva1R5cGUpICsgXCI+XCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXG4gaW5zaWRlIHRvcCBsZXZlbCBydWxlOiA8XCIgKyB0aGlzLnJlY29yZGluZ1Byb2RTdGFja1swXS5uYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgICAgICB2YXIgbmV3Tm9uZVRlcm1pbmFsID0gbmV3IFRlcm1pbmFsKHtcbiAgICAgICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogdG9rVHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiBSRUNPUkRJTkdfUEhBU0VfVE9LRU47XG4gICAgfTtcbiAgICByZXR1cm4gR2FzdFJlY29yZGVyO1xufSgpKTtcbmV4cG9ydCB7IEdhc3RSZWNvcmRlciB9O1xuZnVuY3Rpb24gcmVjb3JkUHJvZChwcm9kQ29uc3RydWN0b3IsIG1haW5Qcm9kQXJnLCBvY2N1cnJlbmNlLCBoYW5kbGVTZXApIHtcbiAgICBpZiAoaGFuZGxlU2VwID09PSB2b2lkIDApIHsgaGFuZGxlU2VwID0gZmFsc2U7IH1cbiAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgIHZhciBncmFtbWFyQWN0aW9uID0gaXNGdW5jdGlvbihtYWluUHJvZEFyZykgPyBtYWluUHJvZEFyZyA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICB2YXIgbmV3UHJvZCA9IG5ldyBwcm9kQ29uc3RydWN0b3IoeyBkZWZpbml0aW9uOiBbXSwgaWR4OiBvY2N1cnJlbmNlIH0pO1xuICAgIGlmIChoYW5kbGVTZXApIHtcbiAgICAgICAgbmV3UHJvZC5zZXBhcmF0b3IgPSBtYWluUHJvZEFyZy5TRVA7XG4gICAgfVxuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTUFYX0xPT0tBSEVBRFwiKSkge1xuICAgICAgICBuZXdQcm9kLm1heExvb2thaGVhZCA9IG1haW5Qcm9kQXJnLk1BWF9MT09LQUhFQUQ7XG4gICAgfVxuICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3UHJvZCk7XG4gICAgZ3JhbW1hckFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdQcm9kKTtcbiAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gUkVDT1JESU5HX05VTExfT0JKRUNUO1xufVxuZnVuY3Rpb24gcmVjb3JkT3JQcm9kKG1haW5Qcm9kQXJnLCBvY2N1cnJlbmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgIC8vIE9ubHkgYW4gYXJyYXkgb2YgYWx0ZXJuYXRpdmVzXG4gICAgdmFyIGhhc09wdGlvbnMgPSBpc0FycmF5KG1haW5Qcm9kQXJnKSA9PT0gZmFsc2U7XG4gICAgdmFyIGFsdHMgPSBoYXNPcHRpb25zID09PSBmYWxzZSA/IG1haW5Qcm9kQXJnIDogbWFpblByb2RBcmcuREVGO1xuICAgIHZhciBuZXdPclByb2QgPSBuZXcgQWx0ZXJuYXRpb24oe1xuICAgICAgICBkZWZpbml0aW9uOiBbXSxcbiAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICBpZ25vcmVBbWJpZ3VpdGllczogaGFzT3B0aW9ucyAmJiBtYWluUHJvZEFyZy5JR05PUkVfQU1CSUdVSVRJRVMgPT09IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaGFzKG1haW5Qcm9kQXJnLCBcIk1BWF9MT09LQUhFQURcIikpIHtcbiAgICAgICAgbmV3T3JQcm9kLm1heExvb2thaGVhZCA9IG1haW5Qcm9kQXJnLk1BWF9MT09LQUhFQUQ7XG4gICAgfVxuICAgIHZhciBoYXNQcmVkaWNhdGVzID0gc29tZShhbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkgeyByZXR1cm4gaXNGdW5jdGlvbihjdXJyQWx0LkdBVEUpOyB9KTtcbiAgICBuZXdPclByb2QuaGFzUHJlZGljYXRlcyA9IGhhc1ByZWRpY2F0ZXM7XG4gICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld09yUHJvZCk7XG4gICAgZm9yRWFjaChhbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICB2YXIgY3VyckFsdEZsYXQgPSBuZXcgQWx0ZXJuYXRpdmUoeyBkZWZpbml0aW9uOiBbXSB9KTtcbiAgICAgICAgbmV3T3JQcm9kLmRlZmluaXRpb24ucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGlmIChoYXMoY3VyckFsdCwgXCJJR05PUkVfQU1CSUdVSVRJRVNcIikpIHtcbiAgICAgICAgICAgIGN1cnJBbHRGbGF0Lmlnbm9yZUFtYmlndWl0aWVzID0gY3VyckFsdC5JR05PUkVfQU1CSUdVSVRJRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKippbXBsaWNpdCoqIGlnbm9yZUFtYmlndWl0aWVzIGR1ZSB0byB1c2FnZSBvZiBnYXRlXG4gICAgICAgIGVsc2UgaWYgKGhhcyhjdXJyQWx0LCBcIkdBVEVcIikpIHtcbiAgICAgICAgICAgIGN1cnJBbHRGbGF0Lmlnbm9yZUFtYmlndWl0aWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGN1cnJBbHQuQUxULmNhbGwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJFQ09SRElOR19OVUxMX09CSkVDVDtcbn1cbmZ1bmN0aW9uIGdldElkeFN1ZmZpeChpZHgpIHtcbiAgICByZXR1cm4gaWR4ID09PSAwID8gXCJcIiA6IFwiXCIgKyBpZHg7XG59XG5mdW5jdGlvbiBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKGlkeCkge1xuICAgIGlmIChpZHggPCAwIHx8IGlkeCA+IE1BWF9NRVRIT0RfSURYKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVGhlIHN0YWNrIHRyYWNlIHdpbGwgY29udGFpbiBhbGwgdGhlIG5lZWRlZCBkZXRhaWxzXG4gICAgICAgIFwiSW52YWxpZCBEU0wgTWV0aG9kIGlkeCB2YWx1ZTogPFwiICsgaWR4ICsgXCI+XFxuXFx0XCIgK1xuICAgICAgICAgICAgKFwiSWR4IHZhbHVlIG11c3QgYmUgYSBub25lIG5lZ2F0aXZlIHZhbHVlIHNtYWxsZXIgdGhhbiBcIiArIChNQVhfTUVUSE9EX0lEWCArIDEpKSk7XG4gICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZWNvcmRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexerAdapter: () => (/* binding */ LexerAdapter)\n/* harmony export */ });\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */ (function () {\n    function LexerAdapter() {\n    }\n    LexerAdapter.prototype.initLexerAdapter = function () {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    };\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\n        get: function () {\n            return this.tokVector;\n        },\n        set: function (newInput) {\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            if (this.selfAnalysisDone !== true) {\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n            }\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            this.reset();\n            this.tokVector = newInput;\n            this.tokVectorLength = newInput.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // skips a token and returns the next token\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return _parser__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;\n        }\n    };\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LexerAdapter.prototype.LA = function (howMuch) {\n        var soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return _parser__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    };\n    LexerAdapter.prototype.consumeToken = function () {\n        this.currIdx++;\n    };\n    LexerAdapter.prototype.exportLexerState = function () {\n        return this.currIdx;\n    };\n    LexerAdapter.prototype.importLexerState = function (newState) {\n        this.currIdx = newState;\n    };\n    LexerAdapter.prototype.resetLexerState = function () {\n        this.currIdx = -1;\n    };\n    LexerAdapter.prototype.moveToTerminatedState = function () {\n        this.currIdx = this.tokVector.length - 1;\n    };\n    LexerAdapter.prototype.getLexerPosition = function () {\n        return this.exportLexerState();\n    };\n    return LexerAdapter;\n}());\n\n//# sourceMappingURL=lexer_adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvbGV4ZXJfYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDdUI7QUFDeEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHRyYWl0c1xcbGV4ZXJfYWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTkRfT0ZfRklMRSB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgYWJzdHJhY3Rpbmcgb3ZlciB0aGUgaW50ZXJhY3Rpb24gd2l0aCBMZXhlciBvdXRwdXQgKFRva2VuIHZlY3RvcikuXG4gKlxuICogVGhpcyBjb3VsZCBiZSBnZW5lcmFsaXplZCB0byBzdXBwb3J0IG90aGVyIGtpbmRzIG9mIGxleGVycywgZS5nLlxuICogLSBKdXN0IGluIFRpbWUgTGV4aW5nIC8gTGV4ZXItTGVzcyBwYXJzaW5nLlxuICogLSBTdHJlYW1pbmcgTGV4ZXIuXG4gKi9cbnZhciBMZXhlckFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXJBZGFwdGVyKCkge1xuICAgIH1cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmluaXRMZXhlckFkYXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9rVmVjdG9yID0gW107XG4gICAgICAgIHRoaXMudG9rVmVjdG9yTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXJBZGFwdGVyLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rVmVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdJbnB1dCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGB0aGlzIHBhcmFtZXRlcmAgbm90IHN1cHBvcnRlZCBpbiBzZXR0ZXJzL2dldHRlcnNcbiAgICAgICAgICAgIC8vICAgLSBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9mdW5jdGlvbnMuaHRtbCN0aGlzLXBhcmFtZXRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGZBbmFseXNpc0RvbmUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk1pc3NpbmcgPHBlcmZvcm1TZWxmQW5hbHlzaXM+IGludm9jYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgUGFyc2VyJ3MgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGB0aGlzIHBhcmFtZXRlcmAgbm90IHN1cHBvcnRlZCBpbiBzZXR0ZXJzL2dldHRlcnNcbiAgICAgICAgICAgIC8vICAgLSBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9mdW5jdGlvbnMuaHRtbCN0aGlzLXBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMudG9rVmVjdG9yID0gbmV3SW5wdXQ7XG4gICAgICAgICAgICB0aGlzLnRva1ZlY3Rvckxlbmd0aCA9IG5ld0lucHV0Lmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIHNraXBzIGEgdG9rZW4gYW5kIHJldHVybnMgdGhlIG5leHQgdG9rZW5cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLlNLSVBfVE9LRU4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJJZHggPD0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBMZXhlciAoYWNjZXNzaW5nIFRva2VuIHZlY3RvcikgcmVsYXRlZCBtZXRob2RzIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIHRvIGltcGxlbWVudCBsYXp5IGxleGVyc1xuICAgIC8vIG9yIGxleGVycyBkZXBlbmRlbnQgb24gcGFyc2VyIGNvbnRleHQuXG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5MQSA9IGZ1bmN0aW9uIChob3dNdWNoKSB7XG4gICAgICAgIHZhciBzb3VnaHRJZHggPSB0aGlzLmN1cnJJZHggKyBob3dNdWNoO1xuICAgICAgICBpZiAoc291Z2h0SWR4IDwgMCB8fCB0aGlzLnRva1ZlY3Rvckxlbmd0aCA8PSBzb3VnaHRJZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva1ZlY3Rvcltzb3VnaHRJZHhdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmNvbnN1bWVUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4Kys7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmV4cG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJJZHg7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmltcG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLnJlc2V0TGV4ZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMTtcbiAgICB9O1xuICAgIExleGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0TGV4ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyQWRhcHRlcjtcbn0oKSk7XG5leHBvcnQgeyBMZXhlckFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyX2FkYXB0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LooksAhead: () => (/* binding */ LooksAhead)\n/* harmony export */ });\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/lookahead */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/keys */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/gast/gast */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\n\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */ (function () {\n    function LooksAhead() {\n    }\n    LooksAhead.prototype.initLooksAhead = function (config) {\n        this.dynamicTokensEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, \"maxLookahead\")\n            ? config.maxLookahead\n            : _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.maxLookahead;\n        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n        this.lookAheadFuncsCache = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isES2015MapSupported)() ? new Map() : [];\n        // Performance optimization on newer engines that support ES6 Map\n        // For larger Maps this is slightly faster than using a plain object (array in our case).\n        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isES2015MapSupported)()) {\n            this.getLaFuncFromCache = this.getLaFuncFromMap;\n            this.setLaFuncCache = this.setLaFuncCacheUsingMap;\n        }\n        else {\n            this.getLaFuncFromCache = this.getLaFuncFromObj;\n            this.setLaFuncCache = this.setLaFuncUsingObj;\n        }\n    };\n    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n        var _this = this;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(rules, function (currRule) {\n            _this.TRACE_INIT(currRule.name + \" Rule Lookahead\", function () {\n                var _a = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.collectMethods)(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(alternation, function (currProd) {\n                    var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    _this.TRACE_INIT(\"\" + (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd) + prodIdx, function () {\n                        var laFunc = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n                        var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.OR_IDX, currProd.idx);\n                        _this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetition, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.MANY_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));\n                });\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(option, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.OPTION_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.OPTION, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));\n                });\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionMandatory, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.AT_LEAST_ONE_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));\n                });\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionMandatoryWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.AT_LEAST_ONE_SEP_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));\n                });\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.MANY_SEP_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));\n                });\n            });\n        });\n    };\n    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        var _this = this;\n        this.TRACE_INIT(\"\" + dslMethodName + (prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n            var laFunc = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n            var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            _this.setLaFuncCache(key, laFunc);\n        });\n    };\n    LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n        return (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);\n    };\n    LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n        return (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n    };\n    // this actually returns a number, but it is always used as a string (object prop key)\n    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        return (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n    };\n    /* istanbul ignore next */\n    LooksAhead.prototype.getLaFuncFromCache = function (key) {\n        return undefined;\n    };\n    LooksAhead.prototype.getLaFuncFromMap = function (key) {\n        return this.lookAheadFuncsCache.get(key);\n    };\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    LooksAhead.prototype.getLaFuncFromObj = function (key) {\n        return this.lookAheadFuncsCache[key];\n    };\n    /* istanbul ignore next */\n    LooksAhead.prototype.setLaFuncCache = function (key, value) { };\n    LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    };\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {\n        this.lookAheadFuncsCache[key] = value;\n    };\n    return LooksAhead;\n}());\n\n//# sourceMappingURL=looksahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvbG9va3NhaGVhZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBeUw7QUFDL0c7QUFDeEI7QUFDbUc7QUFDdEU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaURBQUc7QUFDdkM7QUFDQSxjQUFjLDBEQUFxQjtBQUNuQyw0QkFBNEIsaURBQUc7QUFDL0I7QUFDQSxjQUFjLDBEQUFxQjtBQUNuQztBQUNBLG1DQUFtQyxrRUFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFPO0FBQ2Y7QUFDQSx5QkFBeUIsa0VBQWM7QUFDdkMsZ0JBQWdCLHFEQUFPO0FBQ3ZCO0FBQ0EsMENBQTBDLHdFQUFvQjtBQUM5RCxxQ0FBcUMsMkVBQXVCO0FBQzVELGtDQUFrQywwRUFBMkIsMkNBQTJDLGlEQUFNO0FBQzlHO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixnQkFBZ0IscURBQU87QUFDdkIsdUVBQXVFLG1EQUFRLEVBQUUseURBQVMsb0NBQW9DLHdFQUFvQjtBQUNsSixpQkFBaUI7QUFDakIsZ0JBQWdCLHFEQUFPO0FBQ3ZCLHVFQUF1RSxxREFBVSxFQUFFLHlEQUFTLGdDQUFnQyx3RUFBb0I7QUFDaEosaUJBQWlCO0FBQ2pCLGdCQUFnQixxREFBTztBQUN2Qix1RUFBdUUsMkRBQWdCLEVBQUUseURBQVMsOENBQThDLHdFQUFvQjtBQUNwSyxpQkFBaUI7QUFDakIsZ0JBQWdCLHFEQUFPO0FBQ3ZCLHVFQUF1RSwrREFBb0IsRUFBRSx5REFBUyw2REFBNkQsd0VBQW9CO0FBQ3ZMLGlCQUFpQjtBQUNqQixnQkFBZ0IscURBQU87QUFDdkIsdUVBQXVFLHVEQUFZLEVBQUUseURBQVMsbURBQW1ELHdFQUFvQjtBQUNySyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxRkFBaUM7QUFDMUQsc0JBQXNCLDBFQUEyQjtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSwyRkFBdUM7QUFDdEQ7QUFDQTtBQUNBLGVBQWUsa0ZBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwRUFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxwYXJzZVxccGFyc2VyXFx0cmFpdHNcXGxvb2tzYWhlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jLCBidWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2QsIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yLCBidWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24sIFBST0RfVFlQRSB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZFwiO1xuaW1wb3J0IHsgZm9yRWFjaCwgaGFzLCBpc0VTMjAxNU1hcFN1cHBvcnRlZCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHsgQVRfTEVBU1RfT05FX0lEWCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCwgTUFOWV9JRFgsIE1BTllfU0VQX0lEWCwgT1BUSU9OX0lEWCwgT1JfSURYIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIva2V5c1wiO1xuaW1wb3J0IHsgY29sbGVjdE1ldGhvZHMsIGdldFByb2R1Y3Rpb25Ec2xOYW1lIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvZ2FzdC9nYXN0XCI7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGZvciB0aGUgbG9va2FoZWFkIHJlbGF0ZWQgdXRpbGl0aWVzIGFuZCBvcHRpbWl6YXRpb25zLlxuICovXG52YXIgTG9va3NBaGVhZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb29rc0FoZWFkKCkge1xuICAgIH1cbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5pbml0TG9va3NBaGVhZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCA9IGhhcyhjb25maWcsIFwiZHluYW1pY1Rva2Vuc0VuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLmR5bmFtaWNUb2tlbnNFbmFibGVkXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5keW5hbWljVG9rZW5zRW5hYmxlZDtcbiAgICAgICAgdGhpcy5tYXhMb29rYWhlYWQgPSBoYXMoY29uZmlnLCBcIm1heExvb2thaGVhZFwiKVxuICAgICAgICAgICAgPyBjb25maWcubWF4TG9va2FoZWFkXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5tYXhMb29rYWhlYWQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVXNpbmcgcGxhaW4gYXJyYXkgYXMgZGljdGlvbmFyeSB3aWxsIGJlIHRlc3RlZCBvbiBvbGRlciBub2RlLmpzIHZlcnNpb25zIGFuZCBJRTExICovXG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZSA9IGlzRVMyMDE1TWFwU3VwcG9ydGVkKCkgPyBuZXcgTWFwKCkgOiBbXTtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIG9uIG5ld2VyIGVuZ2luZXMgdGhhdCBzdXBwb3J0IEVTNiBNYXBcbiAgICAgICAgLy8gRm9yIGxhcmdlciBNYXBzIHRoaXMgaXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gdXNpbmcgYSBwbGFpbiBvYmplY3QgKGFycmF5IGluIG91ciBjYXNlKS5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBUaGUgZWxzZSBicmFuY2ggd2lsbCBiZSB0ZXN0ZWQgb24gb2xkZXIgbm9kZS5qcyB2ZXJzaW9ucyBhbmQgSUUxMSAqL1xuICAgICAgICBpZiAoaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUgPSB0aGlzLmdldExhRnVuY0Zyb21NYXA7XG4gICAgICAgICAgICB0aGlzLnNldExhRnVuY0NhY2hlID0gdGhpcy5zZXRMYUZ1bmNDYWNoZVVzaW5nTWFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUgPSB0aGlzLmdldExhRnVuY0Zyb21PYmo7XG4gICAgICAgICAgICB0aGlzLnNldExhRnVuY0NhY2hlID0gdGhpcy5zZXRMYUZ1bmNVc2luZ09iajtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyA9IGZ1bmN0aW9uIChydWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoKHJ1bGVzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoY3VyclJ1bGUubmFtZSArIFwiIFJ1bGUgTG9va2FoZWFkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBjb2xsZWN0TWV0aG9kcyhjdXJyUnVsZSksIGFsdGVybmF0aW9uID0gX2EuYWx0ZXJuYXRpb24sIHJlcGV0aXRpb24gPSBfYS5yZXBldGl0aW9uLCBvcHRpb24gPSBfYS5vcHRpb24sIHJlcGV0aXRpb25NYW5kYXRvcnkgPSBfYS5yZXBldGl0aW9uTWFuZGF0b3J5LCByZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IF9hLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCByZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IF9hLnJlcGV0aXRpb25XaXRoU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIGZvckVhY2goYWx0ZXJuYXRpb24sIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZElkeCA9IGN1cnJQcm9kLmlkeCA9PT0gMCA/IFwiXCIgOiBjdXJyUHJvZC5pZHg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJcIiArIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSArIHByb2RJZHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYUZ1bmMgPSBidWlsZExvb2thaGVhZEZ1bmNGb3JPcihjdXJyUHJvZC5pZHgsIGN1cnJSdWxlLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQgfHwgX3RoaXMubWF4TG9va2FoZWFkLCBjdXJyUHJvZC5oYXNQcmVkaWNhdGVzLCBfdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCwgX3RoaXMubG9va0FoZWFkQnVpbGRlckZvckFsdGVybmF0aXZlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKF90aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnRbY3VyclJ1bGUubmFtZV0sIE9SX0lEWCwgY3VyclByb2QuaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldExhRnVuY0NhY2hlKGtleSwgbGFGdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgTUFOWV9JRFgsIFBST0RfVFlQRS5SRVBFVElUSU9OLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChvcHRpb24sIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBPUFRJT05fSURYLCBQUk9EX1RZUEUuT1BUSU9OLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uTWFuZGF0b3J5LCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgQVRfTEVBU1RfT05FX0lEWCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVMb29rYWhlYWRGdW5jKGN1cnJSdWxlLCBjdXJyUHJvZC5pZHgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgTUFOWV9TRVBfSURYLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuY29tcHV0ZUxvb2thaGVhZEZ1bmMgPSBmdW5jdGlvbiAocnVsZSwgcHJvZE9jY3VycmVuY2UsIHByb2RLZXksIHByb2RUeXBlLCBwcm9kTWF4TG9va2FoZWFkLCBkc2xNZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIlwiICsgZHNsTWV0aG9kTmFtZSArIChwcm9kT2NjdXJyZW5jZSA9PT0gMCA/IFwiXCIgOiBwcm9kT2NjdXJyZW5jZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYUZ1bmMgPSBidWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2QocHJvZE9jY3VycmVuY2UsIHJ1bGUsIHByb2RNYXhMb29rYWhlYWQgfHwgX3RoaXMubWF4TG9va2FoZWFkLCBfdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIF90aGlzLmxvb2tBaGVhZEJ1aWxkZXJGb3JPcHRpb25hbCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKF90aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnRbcnVsZS5uYW1lXSwgcHJvZEtleSwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICAgICAgX3RoaXMuc2V0TGFGdW5jQ2FjaGUoa2V5LCBsYUZ1bmMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmxvb2tBaGVhZEJ1aWxkZXJGb3JPcHRpb25hbCA9IGZ1bmN0aW9uIChhbHQsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbihhbHQsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUubG9va0FoZWFkQnVpbGRlckZvckFsdGVybmF0aXZlcyA9IGZ1bmN0aW9uIChhbHRzLCBoYXNQcmVkaWNhdGVzLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMoYWx0cywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG4gICAgfTtcbiAgICAvLyB0aGlzIGFjdHVhbGx5IHJldHVybnMgYSBudW1iZXIsIGJ1dCBpdCBpcyBhbHdheXMgdXNlZCBhcyBhIHN0cmluZyAob2JqZWN0IHByb3Aga2V5KVxuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCA9IGZ1bmN0aW9uIChkc2xNZXRob2RJZHgsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGN1cnJSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHJldHVybiBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoY3VyclJ1bGVTaG9ydE5hbWUsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmdldExhRnVuY0Zyb21DYWNoZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmdldExhRnVuY0Zyb21NYXAgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuZ2V0KGtleSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFVzaW5nIHBsYWluIGFycmF5IGFzIGRpY3Rpb25hcnkgd2lsbCBiZSB0ZXN0ZWQgb24gb2xkZXIgbm9kZS5qcyB2ZXJzaW9ucyBhbmQgSUUxMSAqL1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmdldExhRnVuY0Zyb21PYmogPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGVba2V5XTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyB9O1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLnNldExhRnVuY0NhY2hlVXNpbmdNYXAgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBVc2luZyBwbGFpbiBhcnJheSBhcyBkaWN0aW9uYXJ5IHdpbGwgYmUgdGVzdGVkIG9uIG9sZGVyIG5vZGUuanMgdmVyc2lvbnMgYW5kIElFMTEgKi9cbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5zZXRMYUZ1bmNVc2luZ09iaiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZVtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gTG9va3NBaGVhZDtcbn0oKSk7XG5leHBvcnQgeyBMb29rc0FoZWFkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb29rc2FoZWFkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceTracer: () => (/* binding */ PerformanceTracer)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar PerformanceTracer = /** @class */ (function () {\n    function PerformanceTracer() {\n    }\n    PerformanceTracer.prototype.initPerformanceTracer = function (config) {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"traceInitPerf\")) {\n            var userTraceInitPerf = config.traceInitPerf;\n            var traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf;\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = _parser__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    };\n    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.timer)(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    return PerformanceTracer;\n}());\n\n//# sourceMappingURL=perf_tracer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcGVyZl90cmFjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBQ0E7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXHBhcnNlclxcdHJhaXRzXFxwZXJmX3RyYWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXMsIHRpbWVyIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGZvciBydW50aW1lIHBhcnNpbmcgZXJyb3JzLlxuICovXG52YXIgUGVyZm9ybWFuY2VUcmFjZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVyZm9ybWFuY2VUcmFjZXIoKSB7XG4gICAgfVxuICAgIFBlcmZvcm1hbmNlVHJhY2VyLnByb3RvdHlwZS5pbml0UGVyZm9ybWFuY2VUcmFjZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcInRyYWNlSW5pdFBlcmZcIikpIHtcbiAgICAgICAgICAgIHZhciB1c2VyVHJhY2VJbml0UGVyZiA9IGNvbmZpZy50cmFjZUluaXRQZXJmO1xuICAgICAgICAgICAgdmFyIHRyYWNlSXNOdW1iZXIgPSB0eXBlb2YgdXNlclRyYWNlSW5pdFBlcmYgPT09IFwibnVtYmVyXCI7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gdHJhY2VJc051bWJlclxuICAgICAgICAgICAgICAgID8gdXNlclRyYWNlSW5pdFBlcmZcbiAgICAgICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gdHJhY2VJc051bWJlclxuICAgICAgICAgICAgICAgID8gdXNlclRyYWNlSW5pdFBlcmYgPiAwXG4gICAgICAgICAgICAgICAgOiB1c2VyVHJhY2VJbml0UGVyZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSAwO1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gREVGQVVMVF9QQVJTRVJfQ09ORklHLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQgPSAtMTtcbiAgICB9O1xuICAgIFBlcmZvcm1hbmNlVHJhY2VyLnByb3RvdHlwZS5UUkFDRV9JTklUID0gZnVuY3Rpb24gKHBoYXNlRGVzYywgcGhhc2VJbXBsKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gb3B0aW1pemUgdGhpcyB1c2luZyBOT09QIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgICAvLyBJdCBpcyBub3QgY2FsbGVkIGluIGEgaG90IHNwb3QuLi5cbiAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0UGVyZiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQrKztcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBuZXcgQXJyYXkodGhpcy50cmFjZUluaXRJbmRlbnQgKyAxKS5qb2luKFwiXFx0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCArIFwiLS0+IDxcIiArIHBoYXNlRGVzYyArIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IHRpbWVyKHBoYXNlSW1wbCksIHRpbWUgPSBfYS50aW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBEaWZmaWN1bHQgdG8gcmVwcm9kdWNlIHNwZWNpZmljIHBlcmZvcm1hbmNlIGJlaGF2aW9yICg+MTBtcykgaW4gdGVzdHMgKi9cbiAgICAgICAgICAgIHZhciB0cmFjZU1ldGhvZCA9IHRpbWUgPiAxMCA/IGNvbnNvbGUud2FybiA6IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgIHRyYWNlTWV0aG9kKGluZGVudCArIFwiPC0tIDxcIiArIHBoYXNlRGVzYyArIFwiPiB0aW1lOiBcIiArIHRpbWUgKyBcIm1zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQtLTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwaGFzZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBlcmZvcm1hbmNlVHJhY2VyO1xufSgpKTtcbmV4cG9ydCB7IFBlcmZvcm1hbmNlVHJhY2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmX3RyYWNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RecognizerApi: () => (/* binding */ RecognizerApi)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../exceptions_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/checks */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../grammar/gast/gast_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n\n\n\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nvar RecognizerApi = /** @class */ (function () {\n    function RecognizerApi() {\n    }\n    RecognizerApi.prototype.ACTION = function (impl) {\n        return impl.call(this);\n    };\n    RecognizerApi.prototype.consume = function (idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    };\n    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    };\n    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    };\n    RecognizerApi.prototype.or = function (idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    };\n    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.CONSUME = function (tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    };\n    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    };\n    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    };\n    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    };\n    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    };\n    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    };\n    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    };\n    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    };\n    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    };\n    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    };\n    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    };\n    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    };\n    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    };\n    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    };\n    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    };\n    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    };\n    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    };\n    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    };\n    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    };\n    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    };\n    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    };\n    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    };\n    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    };\n    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    };\n    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    };\n    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    };\n    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    };\n    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    };\n    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    };\n    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    };\n    RecognizerApi.prototype.OR = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    };\n    RecognizerApi.prototype.OR1 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    };\n    RecognizerApi.prototype.OR2 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    };\n    RecognizerApi.prototype.OR3 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    };\n    RecognizerApi.prototype.OR4 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    };\n    RecognizerApi.prototype.OR5 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    };\n    RecognizerApi.prototype.OR6 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    };\n    RecognizerApi.prototype.OR7 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    };\n    RecognizerApi.prototype.OR8 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    };\n    RecognizerApi.prototype.OR9 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    };\n    RecognizerApi.prototype.MANY = function (actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY_SEP = function (options) {\n        this.manySepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.MANY_SEP1 = function (options) {\n        this.manySepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.MANY_SEP2 = function (options) {\n        this.manySepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.MANY_SEP3 = function (options) {\n        this.manySepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.MANY_SEP4 = function (options) {\n        this.manySepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.MANY_SEP5 = function (options) {\n        this.manySepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.MANY_SEP6 = function (options) {\n        this.manySepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.MANY_SEP7 = function (options) {\n        this.manySepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.MANY_SEP8 = function (options) {\n        this.manySepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.MANY_SEP9 = function (options) {\n        this.manySepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.RULE = function (name, implementation, config) {\n        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_RULE_CONFIG; }\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(this.definedRulesNames, name)) {\n            var errMsg = _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className\n            });\n            var error = {\n                message: errMsg,\n                type: _parser__WEBPACK_IMPORTED_MODULE_2__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        var ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {\n        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_RULE_CONFIG; }\n        var ruleErrors = [];\n        ruleErrors = ruleErrors.concat((0,_grammar_checks__WEBPACK_IMPORTED_MODULE_4__.validateRuleIsOverridden)(name, this.definedRulesNames, this.className));\n        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win\n        var ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            var orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_1__.isRecognitionException)(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    };\n    // GAST export APIs\n    RecognizerApi.prototype.getGAstProductions = function () {\n        return this.gastProductionsCache;\n    };\n    RecognizerApi.prototype.getSerializedGastProductions = function () {\n        return (0,_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.serializeGrammar)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(this.gastProductionsCache));\n    };\n    return RecognizerApi;\n}());\n\n//# sourceMappingURL=recognizer_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb2duaXplcl9hcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3RDtBQUNTO0FBQ1U7QUFDQTtBQUNYO0FBQ0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsd0RBQW1CO0FBQzdELFlBQVksc0RBQVE7QUFDcEIseUJBQXlCLGdGQUFvQztBQUM3RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IsOERBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsd0RBQW1CO0FBQzdEO0FBQ0EsdUNBQXVDLHlFQUF3QjtBQUMvRCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBFQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBZ0IsQ0FBQyxvREFBTTtBQUN0QztBQUNBO0FBQ0EsQ0FBQztBQUN3QjtBQUN6QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXHBhcnNlclxcdHJhaXRzXFxyZWNvZ25pemVyX2FwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb250YWlucywgdmFsdWVzIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JVTEVfQ09ORklHLCBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHsgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4uLy4uL2Vycm9yc19wdWJsaWNcIjtcbmltcG9ydCB7IHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbiB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2NoZWNrc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplR3JhbW1hciB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgaW1wbGVtZW50aW5nIHRoZSBwdWJsaWMgQVBJXG4gKiBmb3IgZGVmaW5pbmcgQ2hldnJvdGFpbiBwYXJzZXJzLCBpLmU6XG4gKiAtIENPTlNVTUVcbiAqIC0gUlVMRVxuICogLSBPUFRJT05cbiAqIC0gLi4uXG4gKi9cbnZhciBSZWNvZ25pemVyQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY29nbml6ZXJBcGkoKSB7XG4gICAgfVxuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFDVElPTiA9IGZ1bmN0aW9uIChpbXBsKSB7XG4gICAgICAgIHJldHVybiBpbXBsLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKGlkeCwgdG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgaWR4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLnN1YnJ1bGUgPSBmdW5jdGlvbiAoaWR4LCBydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCBpZHgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIGlkeCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChpZHgsIGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCBpZHgpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uIChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnlJbnRlcm5hbChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLmF0TGVhc3RPbmUgPSBmdW5jdGlvbiAoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoaWR4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDAsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTEgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FMiA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUUzID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTQgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FNSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA1LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU2ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDYsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTcgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FOCA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU5ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRSA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUxID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTIgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFMyA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU0ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTUgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNiA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA2LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU3ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTggPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgOCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFOSA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04xID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAxKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjIgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDIpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OMyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT040ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA0KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjUgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDUpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT043ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA3KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjggPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDgpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OOSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgOSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUiA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgMCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjEgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDEpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IyID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SMyA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgMyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjQgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDQpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I1ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA1KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SNiA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgNik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjcgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDcpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I4ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SOSA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgOSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDAsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlkxID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDEsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlkyID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDIsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlkzID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDMsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk0ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDQsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk1ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDUsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk2ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDYsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk3ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDcsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk4ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlk5ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDksIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQMSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVAzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQNCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA2ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg2LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQNyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgwLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUxID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgxLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUyID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDIsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTMgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FNCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg0LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU1ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDUsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTYgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FNyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg3LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU4ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTkgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQOCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoOCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQOSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5SVUxFID0gZnVuY3Rpb24gKG5hbWUsIGltcGxlbWVudGF0aW9uLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUlVMRV9DT05GSUc7IH1cbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBuYW1lLFxuICAgICAgICAgICAgICAgIGdyYW1tYXJOYW1lOiB0aGlzLmNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmluZWRSdWxlc05hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIHZhciBydWxlSW1wbGVtZW50YXRpb24gPSB0aGlzLmRlZmluZVJ1bGUobmFtZSwgaW1wbGVtZW50YXRpb24sIGNvbmZpZyk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBydWxlSW1wbGVtZW50YXRpb247XG4gICAgICAgIHJldHVybiBydWxlSW1wbGVtZW50YXRpb247XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PVkVSUklERV9SVUxFID0gZnVuY3Rpb24gKG5hbWUsIGltcGwsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gREVGQVVMVF9SVUxFX0NPTkZJRzsgfVxuICAgICAgICB2YXIgcnVsZUVycm9ycyA9IFtdO1xuICAgICAgICBydWxlRXJyb3JzID0gcnVsZUVycm9ycy5jb25jYXQodmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuKG5hbWUsIHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIHRoaXMuY2xhc3NOYW1lKSk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoLmFwcGx5KHRoaXMuZGVmaW5pdGlvbkVycm9ycywgcnVsZUVycm9ycyk7IC8vIG11dGFiaWxpdHkgZm9yIHRoZSB3aW5cbiAgICAgICAgdmFyIHJ1bGVJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZGVmaW5lUnVsZShuYW1lLCBpbXBsLCBjb25maWcpO1xuICAgICAgICB0aGlzW25hbWVdID0gcnVsZUltcGxlbWVudGF0aW9uO1xuICAgICAgICByZXR1cm4gcnVsZUltcGxlbWVudGF0aW9uO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQkFDS1RSQUNLID0gZnVuY3Rpb24gKGdyYW1tYXJSdWxlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIG9yZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnB1c2goMSk7XG4gICAgICAgICAgICB2YXIgb3JnU3RhdGUgPSB0aGlzLnNhdmVSZWNvZ1N0YXRlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdyYW1tYXJSdWxlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGV4Y2VwdGlvbiB3YXMgdGhyb3duIHdlIGhhdmUgc3VjY2VlZCBwYXJzaW5nIHRoZSBydWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsb2FkUmVjb2dTdGF0ZShvcmdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gR0FTVCBleHBvcnQgQVBJc1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLmdldEdBc3RQcm9kdWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGU7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5nZXRTZXJpYWxpemVkR2FzdFByb2R1Y3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplR3JhbW1hcih2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXJBcGk7XG59KCkpO1xuZXhwb3J0IHsgUmVjb2duaXplckFwaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb2duaXplcl9hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RecognizerEngine: () => (/* binding */ RecognizerEngine)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/keys */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../exceptions_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/lookahead */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/interpreter */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _recoverable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./recoverable */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../scan/tokens */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../lang/lang_extensions */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__.classNameFromInstance)(this);\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcherNoCategories;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(tokenVocabulary)) {\n            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokenVocabulary, \"modes\") &&\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary.modes)), _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.isTokenType)) {\n            var allTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary.modes));\n            var uniqueTokens = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)(allTokenTypes);\n            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(tokenVocabulary)) {\n            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        /* tslint:disable */\n        this.tokensMap[\"EOF\"] = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__.EOF;\n        // TODO: This check may not be accurate for multi mode lexers\n        var noTokenCategoriesUsed = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary), function (tokenConstructor) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(tokenConstructor.categoryMatches); });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcherNoCategories\n            : _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        (0,_scan_tokens__WEBPACK_IMPORTED_MODULE_8__.augmentTokenTypes)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"resyncEnabled\")\n            ? config.resyncEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc\n            : _parser__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        /* tslint:disable */\n        var shortName = this.ruleShortNameIdx << (_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.BITS_FOR_METHOD_TYPE + _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.BITS_FOR_OCCURRENCE_IDX);\n        /* tslint:enable */\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        function invokeRuleWithTry(args) {\n            try {\n                if (this.outputCst === true) {\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                else {\n                    return impl.apply(this, args);\n                }\n            }\n            catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            }\n            finally {\n                this.ruleFinallyStateUpdate();\n            }\n        }\n        var wrappedGrammarRule;\n        wrappedGrammarRule = function (idxInCallingRule, args) {\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n            return invokeRuleWithTry.call(this, args);\n        };\n        var ruleNamePropName = \"ruleName\";\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\n        wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_2__.isRecognitionException)(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, occurrence);\n        var alts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(altsOrOpts)\n            ? altsOrOpts\n            : altsOrOpts.DEF;\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            ruleResult = ruleToCall.call(this, idx, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_2__.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === _recoverable__WEBPACK_IMPORTED_MODULE_6__.IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName, shortName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__.EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\n\n//# sourceMappingURL=recognizer_engine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb2duaXplcl9lbmdpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBaUk7QUFDc0M7QUFDaEQ7QUFDbkU7QUFDNkg7QUFDakk7QUFDVztBQUNUO0FBQ2dGO0FBQzVEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEVBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQU87QUFDbkIsNkJBQTZCLG9EQUFNO0FBQ25DO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxpQkFBaUIsaURBQUc7QUFDcEIsWUFBWSxtREFBSyxDQUFDLHFEQUFPLENBQUMsb0RBQU0sMEJBQTBCLHFEQUFXO0FBQ3JFLGdDQUFnQyxxREFBTyxDQUFDLG9EQUFNO0FBQzlDLCtCQUErQixrREFBSTtBQUNuQyw2QkFBNkIsb0RBQU07QUFDbkM7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLGlCQUFpQixzREFBUTtBQUN6Qiw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvREFBRztBQUNuQztBQUNBLG9DQUFvQyxtREFBSyxDQUFDLG9EQUFNLGlEQUFpRCxPQUFPLHFEQUFPLHFDQUFxQztBQUNwSjtBQUNBLGNBQWMsNEVBQWtDO0FBQ2hELGNBQWMsZ0VBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWlCLENBQUMsb0RBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFHO0FBQy9CO0FBQ0EsY0FBYyx3REFBbUI7QUFDakMsZ0NBQWdDLGlEQUFHO0FBQ25DO0FBQ0EsY0FBYyx3REFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtEQUFvQixHQUFHLGtFQUF1QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxREFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkRBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QseURBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCwyREFBZ0Isa0JBQWtCLG1GQUFpQztBQUN6TDtBQUNBO0FBQ0EscURBQXFELCtEQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNGQUFvQztBQUNwRCx1Q0FBdUMsK0RBQW9CLGtCQUFrQixzRkFBb0M7QUFDakg7QUFDQTtBQUNBLCtEQUErRCx5REFBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbURBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxtREFBUSxrQkFBa0IsNkVBQTJCO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsdURBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUE4QjtBQUM5Qyx1Q0FBdUMsdURBQVksa0JBQWtCLGdGQUE4QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0RBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlEQUFNO0FBQzNELG1CQUFtQixxREFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQywwRUFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEVBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQyx3RUFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0VBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0RBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMkI7QUFDNUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHRyYWl0c1xccmVjb2duaXplcl9lbmdpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVBcnIsIGNsb25lT2JqLCBldmVyeSwgZmxhdHRlbiwgaGFzLCBpc0FycmF5LCBpc0VtcHR5LCBpc09iamVjdCwgcmVkdWNlLCB1bmlxLCB2YWx1ZXMgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IEFUX0xFQVNUX09ORV9JRFgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBCSVRTX0ZPUl9NRVRIT0RfVFlQRSwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFgsIE1BTllfSURYLCBNQU5ZX1NFUF9JRFgsIE9QVElPTl9JRFgsIE9SX0lEWCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2tleXNcIjtcbmltcG9ydCB7IGlzUmVjb2duaXRpb25FeGNlcHRpb24sIE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiwgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWNcIjtcbmltcG9ydCB7IFBST0RfVFlQRSB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZFwiO1xuaW1wb3J0IHsgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyLCBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIsIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciwgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXJcIjtcbmltcG9ydCB7IERFRkFVTFRfUlVMRV9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTiB9IGZyb20gXCIuL3JlY292ZXJhYmxlXCI7XG5pbXBvcnQgeyBFT0YgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgaXNUb2tlblR5cGUsIHRva2VuU3RydWN0dXJlZE1hdGNoZXIsIHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZUZyb21JbnN0YW5jZSB9IGZyb20gXCIuLi8uLi8uLi9sYW5nL2xhbmdfZXh0ZW5zaW9uc1wiO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcnVudGltZSBwYXJzaW5nIGVuZ2luZVxuICogVXNlZCBieSB0aGUgb2ZmaWNpYWwgQVBJIChyZWNvZ25pemVyX2FwaS50cylcbiAqL1xudmFyIFJlY29nbml6ZXJFbmdpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb2duaXplckVuZ2luZSgpIHtcbiAgICB9XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuaW5pdFJlY29nbml6ZXJFbmdpbmUgPSBmdW5jdGlvbiAodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIC8vIFRPRE86IHdvdWxkIHVzaW5nIGFuIEVTNiBNYXAgb3IgcGxhaW4gb2JqZWN0IGJlIGZhc3RlciAoQ1NUIGJ1aWxkaW5nIHNjZW5hcmlvKVxuICAgICAgICB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwgPSB7fTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0ID0ge307XG4gICAgICAgIHRoaXMucnVsZVNob3J0TmFtZUlkeCA9IDI1NjtcbiAgICAgICAgdGhpcy50b2tlbk1hdGNoZXIgPSB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzO1xuICAgICAgICB0aGlzLmRlZmluZWRSdWxlc05hbWVzID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zTWFwID0ge307XG4gICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSA9IHt9O1xuICAgICAgICBpZiAoaGFzKGNvbmZpZywgXCJzZXJpYWxpemVkR3JhbW1hclwiKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyJ3MgY29uZmlndXJhdGlvbiBjYW4gbm8gbG9uZ2VyIGNvbnRhaW4gYSA8c2VyaWFsaXplZEdyYW1tYXI+IHByb3BlcnR5LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNi0wLTBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRGb3IgRnVydGhlciBkZXRhaWxzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9ubHkgY2hlY2tzIGZvciBUb2tlbiB2b2NhYnVsYXJpZXMgcHJvdmlkZWQgYXMgYXJyYXlzLlxuICAgICAgICAgICAgLy8gVGhhdCBpcyBnb29kIGVub3VnaCBiZWNhdXNlIHRoZSBtYWluIG9iamVjdGl2ZSBpcyB0byBkZXRlY3QgdXNlcnMgb2YgcHJlLVY0LjAgQVBJc1xuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYWxsIGVkZ2UgY2FzZXMgb2YgZW1wdHkgVG9rZW4gdm9jYWJ1bGFyaWVzLlxuICAgICAgICAgICAgaWYgKGlzRW1wdHkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBUb2tlbiBWb2NhYnVsYXJ5IGNhbm5vdCBiZSBlbXB0eS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Tm90ZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBmb3IgdGhlIHBhcnNlciBjb25zdHJ1Y3RvclxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRpcyBubyBsb25nZXIgYSBUb2tlbiB2ZWN0b3IgKHNpbmNlIHY0LjApLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5Wb2NhYnVsYXJ5WzBdLnN0YXJ0T2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyIGNvbnN0cnVjdG9yIG5vIGxvbmdlciBhY2NlcHRzIGEgdG9rZW4gdmVjdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI180LTAtMFxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgRnVydGhlciBkZXRhaWxzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9IHJlZHVjZSh0b2tlblZvY2FidWxhcnksIGZ1bmN0aW9uIChhY2MsIHRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICBhY2NbdG9rVHlwZS5uYW1lXSA9IHRva1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXModG9rZW5Wb2NhYnVsYXJ5LCBcIm1vZGVzXCIpICYmXG4gICAgICAgICAgICBldmVyeShmbGF0dGVuKHZhbHVlcyh0b2tlblZvY2FidWxhcnkubW9kZXMpKSwgaXNUb2tlblR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgYWxsVG9rZW5UeXBlcyA9IGZsYXR0ZW4odmFsdWVzKHRva2VuVm9jYWJ1bGFyeS5tb2RlcykpO1xuICAgICAgICAgICAgdmFyIHVuaXF1ZVRva2VucyA9IHVuaXEoYWxsVG9rZW5UeXBlcyk7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9IHJlZHVjZSh1bmlxdWVUb2tlbnMsIGZ1bmN0aW9uIChhY2MsIHRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICBhY2NbdG9rVHlwZS5uYW1lXSA9IHRva1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9IGNsb25lT2JqKHRva2VuVm9jYWJ1bGFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8dG9rZW5zRGljdGlvbmFyeT4gYXJndW1lbnQgbXVzdCBiZSBBbiBBcnJheSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMsXCIgK1xuICAgICAgICAgICAgICAgIFwiIEEgZGljdGlvbmFyeSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMgb3IgYW4gSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHdheXMgYWRkIEVPRiB0byB0aGUgdG9rZW5OYW1lcyAtPiBjb25zdHJ1Y3RvcnMgbWFwLiBpdCBpcyB1c2VmdWwgdG8gYXNzdXJlIGFsbCB0aGUgaW5wdXQgaGFzIGJlZW5cbiAgICAgICAgLy8gcGFyc2VkIHdpdGggYSBjbGVhciBlcnJvciBtZXNzYWdlIChcImV4cGVjdGluZyBFT0YgYnV0IGZvdW5kIC4uLlwiKVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgICAgICB0aGlzLnRva2Vuc01hcFtcIkVPRlwiXSA9IEVPRjtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBtYXkgbm90IGJlIGFjY3VyYXRlIGZvciBtdWx0aSBtb2RlIGxleGVyc1xuICAgICAgICB2YXIgbm9Ub2tlbkNhdGVnb3JpZXNVc2VkID0gZXZlcnkodmFsdWVzKHRva2VuVm9jYWJ1bGFyeSksIGZ1bmN0aW9uICh0b2tlbkNvbnN0cnVjdG9yKSB7IHJldHVybiBpc0VtcHR5KHRva2VuQ29uc3RydWN0b3IuY2F0ZWdvcnlNYXRjaGVzKTsgfSk7XG4gICAgICAgIHRoaXMudG9rZW5NYXRjaGVyID0gbm9Ub2tlbkNhdGVnb3JpZXNVc2VkXG4gICAgICAgICAgICA/IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICAgICAgLy8gQmVjYXVzZSBFUzIwMTUrIHN5bnRheCBzaG91bGQgYmUgc3VwcG9ydGVkIGZvciBjcmVhdGluZyBUb2tlbiBjbGFzc2VzXG4gICAgICAgIC8vIFdlIGNhbm5vdCBhc3N1bWUgdGhhdCB0aGUgVG9rZW4gY2xhc3NlcyB3ZXJlIGNyZWF0ZWQgdXNpbmcgdGhlIFwiZXh0ZW5kVG9rZW5cIiB1dGlsaXRpZXNcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG11c3QgYXVnbWVudCB0aGUgVG9rZW4gY2xhc3NlcyBib3RoIG9uIExleGVyIGluaXRpYWxpemF0aW9uIGFuZCBvbiBQYXJzZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgYXVnbWVudFRva2VuVHlwZXModmFsdWVzKHRoaXMudG9rZW5zTWFwKSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5kZWZpbmVSdWxlID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBpbXBsLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJHcmFtbWFyIHJ1bGUgPFwiICsgcnVsZU5hbWUgKyBcIj4gbWF5IG5vdCBiZSBkZWZpbmVkIGFmdGVyIHRoZSAncGVyZm9ybVNlbGZBbmFseXNpcycgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCdcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgdGhhdCBhbGwgZ3JhbW1hciBydWxlIGRlZmluaXRpb25zIGFyZSBkb25lIGJlZm9yZSAncGVyZm9ybVNlbGZBbmFseXNpcycgaXMgY2FsbGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzeW5jRW5hYmxlZCA9IGhhcyhjb25maWcsIFwicmVzeW5jRW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcucmVzeW5jRW5hYmxlZFxuICAgICAgICAgICAgOiBERUZBVUxUX1JVTEVfQ09ORklHLnJlc3luY0VuYWJsZWQ7XG4gICAgICAgIHZhciByZWNvdmVyeVZhbHVlRnVuYyA9IGhhcyhjb25maWcsIFwicmVjb3ZlcnlWYWx1ZUZ1bmNcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5VmFsdWVGdW5jXG4gICAgICAgICAgICA6IERFRkFVTFRfUlVMRV9DT05GSUcucmVjb3ZlcnlWYWx1ZUZ1bmM7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogVXNlIHNtYWxsIGludGVnZXJzIGFzIGtleXMgZm9yIHRoZSBsb25nZXIgaHVtYW4gcmVhZGFibGUgXCJmdWxsXCIgcnVsZSBuYW1lcy5cbiAgICAgICAgLy8gdGhpcyBncmVhdGx5IGltcHJvdmVzIE1hcCBhY2Nlc3MgdGltZSAoYXMgbXVjaCBhcyA4JSBmb3Igc29tZSBwZXJmb3JtYW5jZSBiZW5jaG1hcmtzKS5cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgICAgdmFyIHNob3J0TmFtZSA9IHRoaXMucnVsZVNob3J0TmFtZUlkeCA8PCAoQklUU19GT1JfTUVUSE9EX1RZUEUgKyBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cbiAgICAgICAgdGhpcy5ydWxlU2hvcnROYW1lSWR4Kys7XG4gICAgICAgIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdID0gcnVsZU5hbWU7XG4gICAgICAgIHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtydWxlTmFtZV0gPSBzaG9ydE5hbWU7XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZVJ1bGVXaXRoVHJ5KGFyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3QgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZShjc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VSdWxlQ2F0Y2goZSwgcmVzeW5jRW5hYmxlZCwgcmVjb3ZlcnlWYWx1ZUZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlRmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZWRHcmFtbWFyUnVsZTtcbiAgICAgICAgd3JhcHBlZEdyYW1tYXJSdWxlID0gZnVuY3Rpb24gKGlkeEluQ2FsbGluZ1J1bGUsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChpZHhJbkNhbGxpbmdSdWxlID09PSB2b2lkIDApIHsgaWR4SW5DYWxsaW5nUnVsZSA9IDA7IH1cbiAgICAgICAgICAgIHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShzaG9ydE5hbWUsIHJ1bGVOYW1lLCBpZHhJbkNhbGxpbmdSdWxlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VSdWxlV2l0aFRyeS5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcnVsZU5hbWVQcm9wTmFtZSA9IFwicnVsZU5hbWVcIjtcbiAgICAgICAgd3JhcHBlZEdyYW1tYXJSdWxlW3J1bGVOYW1lUHJvcE5hbWVdID0gcnVsZU5hbWU7XG4gICAgICAgIHdyYXBwZWRHcmFtbWFyUnVsZVtcIm9yaWdpbmFsR3JhbW1hckFjdGlvblwiXSA9IGltcGw7XG4gICAgICAgIHJldHVybiB3cmFwcGVkR3JhbW1hclJ1bGU7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5pbnZva2VSdWxlQ2F0Y2ggPSBmdW5jdGlvbiAoZSwgcmVzeW5jRW5hYmxlZENvbmZpZywgcmVjb3ZlcnlWYWx1ZUZ1bmMpIHtcbiAgICAgICAgdmFyIGlzRmlyc3RJbnZva2VkUnVsZSA9IHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDE7XG4gICAgICAgIC8vIG5vdGUgdGhlIHJlU3luYyBpcyBhbHdheXMgZW5hYmxlZCBmb3IgdGhlIGZpcnN0IHJ1bGUgaW52b2NhdGlvbiwgYmVjYXVzZSB3ZSBtdXN0IGFsd2F5cyBiZSBhYmxlIHRvXG4gICAgICAgIC8vIHJlU3luYyB3aXRoIEVPRiBhbmQganVzdCBvdXRwdXQgc29tZSBJTlZBTElEIFBhcnNlVHJlZVxuICAgICAgICAvLyBkdXJpbmcgYmFja3RyYWNraW5nIHJlU3luYyByZWNvdmVyeSBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIHdlIGNhbid0IGJlIGNlcnRhaW4gdGhlIGJhY2t0cmFja2luZ1xuICAgICAgICAvLyBwYXRoIGlzIHJlYWxseSB0aGUgbW9zdCB2YWxpZCBvbmVcbiAgICAgICAgdmFyIHJlU3luY0VuYWJsZWQgPSByZXN5bmNFbmFibGVkQ29uZmlnICYmICF0aGlzLmlzQmFja1RyYWNraW5nKCkgJiYgdGhpcy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIGlmIChpc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2dFcnJvciA9IGU7XG4gICAgICAgICAgICBpZiAocmVTeW5jRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHZhciByZVN5bmNUb2tUeXBlID0gdGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0KHJlU3luY1Rva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29nRXJyb3IucmVzeW5jZWRUb2tlbnMgPSB0aGlzLnJlU3luY1RvKHJlU3luY1Rva1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsQ3N0UmVzdWx0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQ3N0UmVzdWx0LnJlY292ZXJlZE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWxDc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3ZlcnlWYWx1ZUZ1bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbENzdFJlc3VsdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbENzdFJlc3VsdC5yZWNvdmVyZWROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29nRXJyb3IucGFydGlhbENzdFJlc3VsdCA9IHBhcnRpYWxDc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgaGFuZGxlZCBGdXJ0aGVyIHVwIHRoZSBjYWxsIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlY29nRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGaXJzdEludm9rZWRSdWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGEgUmVkdW5kYW50IGlucHV0IGVycm9yIHdpbGwgYmUgY3JlYXRlZCBhcyB3ZWxsIGFuZCB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBpbmRlZWQgdGhlIGNhc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJzZXIgc2hvdWxkIG5ldmVyIHRocm93IG9uZSBvZiBpdHMgb3duIGVycm9ycyBvdXRzaWRlIGl0cyBmbG93LlxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgZXJyb3IgcmVjb3ZlcnkgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3ZlcnlWYWx1ZUZ1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvIGJlIHJlY292ZXJlZCBGdXJ0aGVyIHVwIHRoZSBjYWxsIHN0YWNrXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVjb2dFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNvbWUgb3RoZXIgRXJyb3IgdHlwZSB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgKGZvciBleGFtcGxlIGEgYnVpbHQgaW4gSmF2YVNjcmlwdCBFcnJvcilcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHBhcnNpbmcgRFNMXG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWwgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE9QVElPTl9JRFgsIG9jY3VycmVuY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSwga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb29rQWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8xID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzEuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsTG9naWMgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2tBaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICB2YXIgcHJlZGljYXRlO1xuICAgICAgICBpZiAoYWN0aW9uT1JNZXRob2REZWYuREVGICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzIgPSBsb29rQWhlYWRGdW5jO1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2FsbChfdGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb25fMi5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgYWN0aW9uT1JNZXRob2REZWYuRVJSX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IHdoaWxlIGl0IG1heSBzZWVtIHRoYXQgdGhpcyBjYW4gY2F1c2UgYW4gZXJyb3IgYmVjYXVzZSBieSB1c2luZyBhIHJlY3Vyc2l2ZSBjYWxsIHRvXG4gICAgICAgIC8vIEFUX0xFQVNUX09ORSB3ZSBjaGFuZ2UgdGhlIGdyYW1tYXIgdG8gQVRfTEVBU1RfVFdPLCBBVF9MRUFTVF9USFJFRSAuLi4gLCB0aGUgcG9zc2libGUgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgLy8gZnJvbSB0aGUgdHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkoLi4uKSB3aWxsIG9ubHkgaGFwcGVuIElGRiB0aGVyZSByZWFsbHkgYXJlIFRXTy9USFJFRS8uLi4uIGl0ZW1zLlxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuU0VQO1xuICAgICAgICB2YXIgZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgLy8gMXN0IGl0ZXJhdGlvblxuICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gIFRPRE86IE9wdGltaXphdGlvbiBjYW4gbW92ZSB0aGlzIGZ1bmN0aW9uIGNvbnN0cnVjdGlvbiBpbnRvIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIGl0IGlzIG9ubHkgbmVlZGVkIGluIGVycm9yIHJlY292ZXJ5IHNjZW5hcmlvcy5cbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hdGNoZXIoX3RoaXMuTEEoMSksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMm5kLi5udGggaXRlcmF0aW9uc1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBDT05TVU1FIHdpbGwgbmV2ZXIgZW50ZXIgcmVjb3ZlcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlclxuICAgICAgICAgICAgXSwgc2VwYXJhdG9yTG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbihwcm9kT2NjdXJyZW5jZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLCBvcHRpb25zLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55SW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnlJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsTG9naWMgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2thaGVhZEZ1bmN0aW9uID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8zID0gbG9va2FoZWFkRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgbG9va2FoZWFkRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2FsbChfdGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb25fMy5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdFN0dWNrID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGxvb2thaGVhZEZ1bmN0aW9uLmNhbGwodGhpcykgPT09IHRydWUgJiYgbm90U3R1Y2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5tYW55SW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rYWhlYWRGdW5jdGlvbiwgTUFOWV9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsIFxuICAgICAgICAvLyBUaGUgbm90U3R1Y2sgcGFyYW1ldGVyIGlzIG9ubHkgcmVsZXZhbnQgd2hlbiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiXG4gICAgICAgIC8vIGlzIGludm9rZWQgZnJvbSBtYW55SW50ZXJuYWwsIGluIHRoZSBNQU5ZX1NFUCBjYXNlIGFuZCBBVF9MRUFTVF9PTkVbX1NFUF1cbiAgICAgICAgLy8gQW4gaW5maW5pdGUgbG9vcCBjYW5ub3Qgb2NjdXIgYXM6XG4gICAgICAgIC8vIC0gRWl0aGVyIHRoZSBsb29rYWhlYWQgaXMgZ3VhcmFudGVlZCB0byBjb25zdW1lIHNvbWV0aGluZyAoU2luZ2xlIFRva2VuIFNlcGFyYXRvcilcbiAgICAgICAgLy8gLSBBVF9MRUFTVF9PTkUgYnkgZGVmaW5pdGlvbiBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChvciBlcnJvciBvdXQpLlxuICAgICAgICBub3RTdHVjayk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChNQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbiA9IG9wdGlvbnMuREVGO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIHZhciBmaXJzdEl0ZXJhdGlvbkxhRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIC8vIDFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKGZpcnN0SXRlcmF0aW9uTGFGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWF0Y2hlcihfdGhpcy5MQSgxKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAybmQuLm50aCBpdGVyYXRpb25zXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgY2hlY2tzIHRoYXQgdGhlIHNlcGFyYXRvciByZWFsbHkgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIGZvciBjaGVja2luZyBpbmZpbml0ZSBsb29wIGhlcmUgZHVlIHRvIGNvbnN1bWluZyB0aGUgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCwgW1xuICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXJcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgc2VwYXJhdG9yLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBhY3Rpb24sIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKSB7XG4gICAgICAgIHdoaWxlIChzZXBhcmF0b3JMb29rQWhlYWRGdW5jKCkpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjYW4gb25seSBhcnJpdmUgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciBhbiBlcnJvclxuICAgICAgICAvLyBoYXMgb2NjdXJyZWQgKGhlbmNlIHRoZSBuYW1lICdzZWNvbmQnKSBzbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIElGIHdpbGwgYWx3YXlzIGJlIGVudGVyZWQsIGl0cyBwb3NzaWJsZSB0byByZW1vdmUgaXQuLi5cbiAgICAgICAgLy8gaG93ZXZlciBpdCBpcyBrZXB0IHRvIGF2b2lkIGNvbmZ1c2lvbiBhbmQgYmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuZXh0VGVybWluYWxBZnRlcldhbGtlclxuICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmRvU2luZ2xlUmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGJlZm9yZUl0ZXJhdGlvbiA9IHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO1xuICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGFmdGVySXRlcmF0aW9uID0gdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7XG4gICAgICAgIC8vIFRoaXMgYm9vbGVhbiB3aWxsIGluZGljYXRlIGlmIHRoaXMgcmVwZXRpdGlvbiBwcm9ncmVzc2VkXG4gICAgICAgIC8vIG9yIGlmIHdlIGFyZSBcInN0dWNrXCIgKHBvdGVudGlhbCBpbmZpbml0ZSBsb29wIGluIHRoZSByZXBldGl0aW9uKS5cbiAgICAgICAgcmV0dXJuIGFmdGVySXRlcmF0aW9uID4gYmVmb3JlSXRlcmF0aW9uO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3JJbnRlcm5hbCA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE9SX0lEWCwgb2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBhbHRzID0gaXNBcnJheShhbHRzT3JPcHRzKVxuICAgICAgICAgICAgPyBhbHRzT3JPcHRzXG4gICAgICAgICAgICA6IGFsdHNPck9wdHMuREVGO1xuICAgICAgICB2YXIgbGFGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobGFLZXkpO1xuICAgICAgICB2YXIgYWx0SWR4VG9UYWtlID0gbGFGdW5jLmNhbGwodGhpcywgYWx0cyk7XG4gICAgICAgIGlmIChhbHRJZHhUb1Rha2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNob3NlbkFsdGVybmF0aXZlID0gYWx0c1thbHRJZHhUb1Rha2VdO1xuICAgICAgICAgICAgcmV0dXJuIGNob3NlbkFsdGVybmF0aXZlLkFMVC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihvY2N1cnJlbmNlLCBhbHRzT3JPcHRzLkVSUl9NU0cpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnBvcCgpO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQXRFbmRPZklucHV0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RSZWR1bmRhbnRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0UmVkdW5kYW50OiBmaXJzdFJlZHVuZGFudFRvayxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5TQVZFX0VSUk9SKG5ldyBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbihlcnJNc2csIGZpcnN0UmVkdW5kYW50VG9rKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnN1YnJ1bGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBpZHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGVSZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuQVJHUyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJ1bGVSZXN1bHQgPSBydWxlVG9DYWxsLmNhbGwodGhpcywgaWR4LCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKHJ1bGVSZXN1bHQsIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkxBQkVMICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuTEFCRUxcbiAgICAgICAgICAgICAgICA6IHJ1bGVUb0NhbGwucnVsZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VicnVsZUludGVybmFsRXJyb3IoZSwgb3B0aW9ucywgcnVsZVRvQ2FsbC5ydWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnN1YnJ1bGVJbnRlcm5hbEVycm9yID0gZnVuY3Rpb24gKGUsIG9wdGlvbnMsIHJ1bGVOYW1lKSB7XG4gICAgICAgIGlmIChpc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpICYmIGUucGFydGlhbENzdFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNzdFBvc3ROb25UZXJtaW5hbChlLnBhcnRpYWxDc3RSZXN1bHQsIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkxBQkVMICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuTEFCRUxcbiAgICAgICAgICAgICAgICA6IHJ1bGVOYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlLnBhcnRpYWxDc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbCA9IGZ1bmN0aW9uICh0b2tUeXBlLCBpZHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbnN1bWVkVG9rZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIHRva1R5cGUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lZFRva2VuID0gbmV4dFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lSW50ZXJuYWxFcnJvcih0b2tUeXBlLCBuZXh0VG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlRnJvbUNvbnN1bXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdW1lZFRva2VuID0gdGhpcy5jb25zdW1lSW50ZXJuYWxSZWNvdmVyeSh0b2tUeXBlLCBpZHgsIGVGcm9tQ29uc3VtcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3N0UG9zdFRlcm1pbmFsKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkxBQkVMICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgOiB0b2tUeXBlLm5hbWUsIGNvbnN1bWVkVG9rZW4pO1xuICAgICAgICByZXR1cm4gY29uc3VtZWRUb2tlbjtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbEVycm9yID0gZnVuY3Rpb24gKHRva1R5cGUsIG5leHRUb2tlbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXNnO1xuICAgICAgICB2YXIgcHJldmlvdXNUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5FUlJfTVNHKSB7XG4gICAgICAgICAgICBtc2cgPSBvcHRpb25zLkVSUl9NU0c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0b2tUeXBlLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogbmV4dFRva2VuLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1Rva2VuLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obXNnLCBuZXh0VG9rZW4sIHByZXZpb3VzVG9rZW4pKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5ID0gZnVuY3Rpb24gKHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbikge1xuICAgICAgICAvLyBubyByZWNvdmVyeSBhbGxvd2VkIGR1cmluZyBiYWNrdHJhY2tpbmcsIG90aGVyd2lzZSBiYWNrdHJhY2tpbmcgbWF5IHJlY292ZXIgaW52YWxpZCBzeW50YXggYW5kIGFjY2VwdCBpdFxuICAgICAgICAvLyBidXQgdGhlIG9yaWdpbmFsIHN5bnRheCBjb3VsZCBoYXZlIGJlZW4gcGFyc2VkIHN1Y2Nlc3NmdWxseSB3aXRob3V0IGFueSBiYWNrdHJhY2tpbmcgKyByZWNvdmVyeVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQgJiZcbiAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGNoZWNraW5nIG9mIHRoZSBleGNlcHRpb24gdHlwZS4gUGVyaGFwcyBUeXBlc2NyaXB0IGV4dGVuZGluZyBleHByZXNzaW9ucz9cbiAgICAgICAgICAgIGVGcm9tQ29uc3VtcHRpb24ubmFtZSA9PT0gXCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIiAmJlxuICAgICAgICAgICAgIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSkge1xuICAgICAgICAgICAgdmFyIGZvbGxvd3MgPSB0aGlzLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeSh0b2tUeXBlLCBpZHgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cnlJblJ1bGVSZWNvdmVyeSh0b2tUeXBlLCBmb2xsb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlRnJvbUluUnVsZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVGcm9tSW5SdWxlUmVjb3ZlcnkubmFtZSA9PT0gSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGluIFJ1bGVSZWNvdmVyeS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yIGluIG9yZGVyIHRvIHRyaWdnZXIgcmVTeW5jIGVycm9yIHJlY292ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlRnJvbUluUnVsZVJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnNhdmVSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlcnJvcnMgaXMgYSBnZXR0ZXIgd2hpY2ggd2lsbCBjbG9uZSB0aGUgZXJyb3JzIGFycmF5XG4gICAgICAgIHZhciBzYXZlZEVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICB2YXIgc2F2ZWRSdWxlU3RhY2sgPSBjbG9uZUFycih0aGlzLlJVTEVfU1RBQ0spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBzYXZlZEVycm9ycyxcbiAgICAgICAgICAgIGxleGVyU3RhdGU6IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLFxuICAgICAgICAgICAgUlVMRV9TVEFDSzogc2F2ZWRSdWxlU3RhY2ssXG4gICAgICAgICAgICBDU1RfU1RBQ0s6IHRoaXMuQ1NUX1NUQUNLXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5yZWxvYWRSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbmV3U3RhdGUuZXJyb3JzO1xuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUobmV3U3RhdGUubGV4ZXJTdGF0ZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IG5ld1N0YXRlLlJVTEVfU1RBQ0s7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHNob3J0TmFtZSwgZnVsbE5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpIHtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChpZHhJbkNhbGxpbmdSdWxlKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnB1c2goc2hvcnROYW1lKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShmdWxsTmFtZSwgc2hvcnROYW1lKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQmFja1RyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLmxlbmd0aCAhPT0gMDtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmdldEN1cnJSdWxlRnVsbE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoc2hvcnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbc2hvcnROYW1lXTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQXRFbmRPZklucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgRU9GKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIC8vIFRPRE86IGV4dHJhY3QgYSBzcGVjaWZpYyByZXNldCBmb3IgVHJlZUJ1aWxkZXIgdHJhaXRcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBSZWNvZ25pemVyRW5naW5lO1xufSgpKTtcbmV4cG9ydCB7IFJlY29nbml6ZXJFbmdpbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfZW5naW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EOF_FOLLOW_KEY: () => (/* binding */ EOF_FOLLOW_KEY),\n/* harmony export */   IN_RULE_RECOVERY_EXCEPTION: () => (/* binding */ IN_RULE_RECOVERY_EXCEPTION),\n/* harmony export */   InRuleRecoveryException: () => (/* binding */ InRuleRecoveryException),\n/* harmony export */   Recoverable: () => (/* binding */ Recoverable),\n/* harmony export */   attemptInRepetitionRecovery: () => (/* binding */ attemptInRepetitionRecovery)\n/* harmony export */ });\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../exceptions_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/constants.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n\nvar EOF_FOLLOW_KEY = {};\nvar IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nfunction InRuleRecoveryException(message) {\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.flatten)(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF];\n        }\n        var followName = followKey.ruleName + followKey.idxInCallingRule + _constants__WEBPACK_IMPORTED_MODULE_3__.IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.RULE_STACK, function (currShortName) {\n            return _this.shortRuleNameToFullName(currShortName);\n        });\n    };\n    return Recoverable;\n}());\n\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF;\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb3ZlcmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNnQztBQUNwQztBQUM5QjtBQUNhO0FBQzNDO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFHO0FBQ2xDO0FBQ0EsY0FBYywwREFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3RUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0Qix3RUFBd0I7QUFDcEQ7QUFDQSxtQ0FBbUMsdURBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBSTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBRztBQUM3QjtBQUNBLFNBQVM7QUFDVCxlQUFlLHFEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBRztBQUN2QjtBQUNBLDJFQUEyRSwwQ0FBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFHO0FBQ2xCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ2hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xccGFyc2VcXHBhcnNlclxcdHJhaXRzXFxyZWNvdmVyYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBjbG9uZUFyciwgY29udGFpbnMsIGRyb3BSaWdodCwgZmluZCwgZmxhdHRlbiwgaGFzLCBpc0VtcHR5LCBtYXAgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiO1xuaW1wb3J0IHsgSU4gfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5leHBvcnQgdmFyIEVPRl9GT0xMT1dfS0VZID0ge307XG5leHBvcnQgdmFyIElOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OID0gXCJJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvblwiO1xuZXhwb3J0IGZ1bmN0aW9uIEluUnVsZVJlY292ZXJ5RXhjZXB0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZXJyb3IgcmVjb3ZlcnkgYW5kIGZhdWx0IHRvbGVyYW50IGxvZ2ljXG4gKi9cbnZhciBSZWNvdmVyYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvdmVyYWJsZSgpIHtcbiAgICB9XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmluaXRSZWNvdmVyYWJsZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5maXJzdEFmdGVyUmVwTWFwID0ge307XG4gICAgICAgIHRoaXMucmVzeW5jRm9sbG93cyA9IHt9O1xuICAgICAgICB0aGlzLnJlY292ZXJ5RW5hYmxlZCA9IGhhcyhjb25maWcsIFwicmVjb3ZlcnlFbmFibGVkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZWNvdmVyeUVuYWJsZWRcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLnJlY292ZXJ5RW5hYmxlZDtcbiAgICAgICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBOT09QIHdpbGwgYmUgaW5saW5lZCB3aGljaFxuICAgICAgICAvLyBlZmZlY3RpdmVseSBtZWFucyB0aGF0IHRoaXMgb3B0aW9uYWwgZmVhdHVyZSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAvLyB3aGVuIG5vdCB1c2VkLlxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5ID0gYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0VG9rZW5Ub0luc2VydCA9IGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHZhciB0b2tUb0luc2VydCA9IGNyZWF0ZVRva2VuSW5zdGFuY2UodG9rVHlwZSwgXCJcIiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gICAgICAgIHRva1RvSW5zZXJ0LmlzSW5zZXJ0ZWRJblJlY292ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva1RvSW5zZXJ0O1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblRva2VuVHlwZUJlSW5zZXJ0ZWRJblJlY292ZXJ5ID0gZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUudHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkgPSBmdW5jdGlvbiAoZ3JhbW1hclJ1bGUsIGdyYW1tYXJSdWxlQXJncywgbG9va0FoZWFkRnVuYywgZXhwZWN0ZWRUb2tUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRPRE86IGNhbiB0aGUgcmVzeW5jVG9rZW5UeXBlIGJlIGNhY2hlZD9cbiAgICAgICAgdmFyIHJlU3luY1Rva1R5cGUgPSB0aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKTtcbiAgICAgICAgdmFyIHNhdmVkTGV4ZXJTdGF0ZSA9IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICB2YXIgcmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHBhc3NlZFJlc3luY1BvaW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBuZXh0VG9rZW5XaXRob3V0UmVzeW5jID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGN1cnJUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHZhciBnZW5lcmF0ZUVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gX3RoaXMuTEEoMCk7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgcHJlZW1wdGl2ZWx5IHJlLXN5bmNpbmcgYmVmb3JlIGFuIGVycm9yIGhhcyBiZWVuIGRldGVjdGVkLCB0aGVyZWZvciB3ZSBtdXN0IHJlcHJvZHVjZVxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIHRoYXQgd291bGQgaGF2ZSBiZWVuIHRocm93blxuICAgICAgICAgICAgdmFyIG1zZyA9IF90aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFRva1R5cGUsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiBuZXh0VG9rZW5XaXRob3V0UmVzeW5jLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1Rva2VuLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBfdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihtc2csIG5leHRUb2tlbldpdGhvdXRSZXN5bmMsIF90aGlzLkxBKDApKTtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0b2tlbiBoZXJlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIGNhdXNlIG9mIHRoZSBlcnJvciwgdGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcmVzeW5jZWRUb2tlbnMgcHJvcGVydHkuXG4gICAgICAgICAgICBlcnJvci5yZXN5bmNlZFRva2VucyA9IGRyb3BSaWdodChyZXN5bmNlZFRva2Vucyk7XG4gICAgICAgICAgICBfdGhpcy5TQVZFX0VSUk9SKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKCFwYXNzZWRSZXN5bmNQb2ludCkge1xuICAgICAgICAgICAgLy8gcmUtc3luY2VkIHRvIGEgcG9pbnQgd2hlcmUgd2UgY2FuIHNhZmVseSBleGl0IHRoZSByZXBldGl0aW9uL1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKGN1cnJUb2tlbiwgZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBtdXN0IHJldHVybiBoZXJlIHRvIGF2b2lkIHJldmVydGluZyB0aGUgaW5wdXRJZHhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIHNraXBwZWQgZW5vdWdoIHRva2VucyBzbyB3ZSBjYW4gcmVzeW5jIHJpZ2h0IGJhY2sgaW50byBhbm90aGVyIGl0ZXJhdGlvbiBvZiB0aGUgcmVwZXRpdGlvbiBncmFtbWFyIHJ1bGVcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUVycm9yTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZSBpbnZvY2F0aW9uIGluIG90aGVyIHRvIHN1cHBvcnQgbXVsdGlwbGUgcmUtc3luY3MgaW4gdGhlIHNhbWUgdG9wIGxldmVsIHJlcGV0aXRpb24gZ3JhbW1hciBydWxlXG4gICAgICAgICAgICAgICAgZ3JhbW1hclJ1bGUuYXBwbHkodGhpcywgZ3JhbW1hclJ1bGVBcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG11c3QgcmV0dXJuIGhlcmUgdG8gYXZvaWQgcmV2ZXJ0aW5nIHRoZSBpbnB1dElkeFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50b2tlbk1hdGNoZXIoY3VyclRva2VuLCByZVN5bmNUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgIHBhc3NlZFJlc3luY1BvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJUb2tlbiA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9SZXN5bmNUb2tlbnMoY3VyclRva2VuLCByZXN5bmNlZFRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2VyZSB1bmFibGUgdG8gZmluZCBhIENMT1NFUiBwb2ludCB0byByZXN5bmMgaW5zaWRlIHRoZSBSZXBldGl0aW9uLCByZXNldCB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFRoZSBwYXJzaW5nIGV4Y2VwdGlvbiB3ZSB3ZXJlIHRyeWluZyB0byBwcmV2ZW50IHdpbGwgaGFwcGVuIGluIHRoZSBORVhUIHBhcnNpbmcgc3RlcC4gaXQgbWF5IGJlIGhhbmRsZWQgYnlcbiAgICAgICAgLy8gXCJiZXR3ZWVuIHJ1bGVzXCIgcmVzeW5jIHJlY292ZXJ5IGxhdGVyIGluIHRoZSBmbG93LlxuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUoc2F2ZWRMZXhlclN0YXRlKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5zaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQgPSBmdW5jdGlvbiAoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgsIG5vdFN0dWNrKSB7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSBvZiBhcnJpdmluZyBmcm9tIGEgTUFOWSByZXBldGl0aW9uIHdoaWNoIGlzIHN0dWNrXG4gICAgICAgIC8vIEF0dGVtcHRpbmcgcmVjb3ZlcnkgaW4gdGhpcyBjYXNlIGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgaWYgKG5vdFN0dWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZ3VtZW50cyB0byB0cnkgYW5kIHBlcmZvcm0gcmVzeW5jIGludG8gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBtYW55IGFyZSBtaXNzaW5nXG4gICAgICAgIGlmIChleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9PT0gdW5kZWZpbmVkIHx8IG5leHRUb2tJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcmVjb3ZlciwgbmV4dCB0b2tlbiBpcyB3aGF0IHdlIGV4cGVjdC4uLlxuICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnkgaXMgZGlzYWJsZWQgZHVyaW5nIGJhY2t0cmFja2luZyBhcyBpdCBjYW4gbWFrZSB0aGUgcGFyc2VyIGlnbm9yZSBhIHZhbGlkIGdyYW1tYXIgcGF0aFxuICAgICAgICAvLyBhbmQgcHJlZmVyIHNvbWUgYmFja3RyYWNraW5nIHBhdGggdGhhdCBpbmNsdWRlcyByZWNvdmVyZWQgZXJyb3JzLlxuICAgICAgICBpZiAodGhpcy5pc0JhY2tUcmFja2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuIHBlcmZvcm0gaW5SdWxlIHJlY292ZXJ5IChzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uKSB3ZSBhbHdheXMgcHJlZmVyIHRoYXQgcmVjb3ZlcnkgYWxnb3JpdGhtXG4gICAgICAgIC8vIGJlY2F1c2UgaWYgaXQgd29ya3MsIGl0IG1ha2VzIHRoZSBsZWFzdCBhbW91bnQgb2YgY2hhbmdlcyB0byB0aGUgaW5wdXQgc3RyZWFtIChncmVlZHkgYWxnb3JpdGhtKVxuICAgICAgICAvL25vaW5zcGVjdGlvbiBSZWR1bmRhbnRJZlN0YXRlbWVudEpTXG4gICAgICAgIGlmICh0aGlzLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeShleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gRXJyb3IgUmVjb3ZlcnkgZnVuY3Rpb25hbGl0eVxuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkgPSBmdW5jdGlvbiAodG9rVHlwZSwgdG9rSWR4SW5SdWxlKSB7XG4gICAgICAgIHZhciBncmFtbWFyUGF0aCA9IHRoaXMuZ2V0Q3VycmVudEdyYW1tYXJQYXRoKHRva1R5cGUsIHRva0lkeEluUnVsZSk7XG4gICAgICAgIHZhciBmb2xsb3dzID0gdGhpcy5nZXROZXh0UG9zc2libGVUb2tlblR5cGVzKGdyYW1tYXJQYXRoKTtcbiAgICAgICAgcmV0dXJuIGZvbGxvd3M7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUudHJ5SW5SdWxlUmVjb3ZlcnkgPSBmdW5jdGlvbiAoZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSkge1xuICAgICAgICAgICAgdmFyIHRva1RvSW5zZXJ0ID0gdGhpcy5nZXRUb2tlblRvSW5zZXJ0KGV4cGVjdGVkVG9rVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rVG9JbnNlcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uKGV4cGVjdGVkVG9rVHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHRUb2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEluUnVsZVJlY292ZXJ5RXhjZXB0aW9uKFwic2FkIHNhZCBwYW5kYVwiKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5QZXJmb3JtSW5SdWxlUmVjb3ZlcnkgPSBmdW5jdGlvbiAoZXhwZWN0ZWRUb2tlbiwgZm9sbG93cykge1xuICAgICAgICByZXR1cm4gKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbihleHBlY3RlZFRva2VuLCBmb2xsb3dzKSB8fFxuICAgICAgICAgICAgdGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24oZXhwZWN0ZWRUb2tlbikpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24gPSBmdW5jdGlvbiAoZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeShleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbXVzdCBrbm93IHRoZSBwb3NzaWJsZSBmb2xsb3dpbmcgdG9rZW5zIHRvIHBlcmZvcm0gc2luZ2xlIHRva2VuIGluc2VydGlvblxuICAgICAgICBpZiAoaXNFbXB0eShmb2xsb3dzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaXNtYXRjaGVkVG9rID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGlzTWlzTWF0Y2hlZFRva0luRm9sbG93cyA9IGZpbmQoZm9sbG93cywgZnVuY3Rpb24gKHBvc3NpYmxlRm9sbG93c1Rva1R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hdGNoZXIobWlzbWF0Y2hlZFRvaywgcG9zc2libGVGb2xsb3dzVG9rVHlwZSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3M7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rVHlwZSkge1xuICAgICAgICB2YXIgaXNOZXh0VG9rZW5XaGF0SXNFeHBlY3RlZCA9IHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMiksIGV4cGVjdGVkVG9rVHlwZSk7XG4gICAgICAgIHJldHVybiBpc05leHRUb2tlbldoYXRJc0V4cGVjdGVkO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldCA9IGZ1bmN0aW9uICh0b2tlblR5cGVJZHgpIHtcbiAgICAgICAgdmFyIGZvbGxvd0tleSA9IHRoaXMuZ2V0Q3VyckZvbGxvd0tleSgpO1xuICAgICAgICB2YXIgY3VycmVudFJ1bGVSZVN5bmNTZXQgPSB0aGlzLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoZm9sbG93S2V5KTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGN1cnJlbnRSdWxlUmVTeW5jU2V0LCB0b2tlblR5cGVJZHgpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmZpbmRSZVN5bmNUb2tlblR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbGxQb3NzaWJsZVJlU3luY1Rva1R5cGVzID0gdGhpcy5mbGF0dGVuRm9sbG93U2V0KCk7XG4gICAgICAgIC8vIHRoaXMgbG9vcCB3aWxsIGFsd2F5cyB0ZXJtaW5hdGUgYXMgRU9GIGlzIGFsd2F5cyBpbiB0aGUgZm9sbG93IHN0YWNrIGFuZCBhbHNvIGFsd2F5cyAodmlydHVhbGx5KSBpbiB0aGUgaW5wdXRcbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHZhciBrID0gMjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rZW5UeXBlID0gbmV4dFRva2VuLnRva2VuVHlwZTtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhhbGxQb3NzaWJsZVJlU3luY1Rva1R5cGVzLCBuZXh0VG9rZW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VG9rZW5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFRva2VuID0gdGhpcy5MQShrKTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEN1cnJGb2xsb3dLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoZSBsZW5ndGggaXMgYXQgbGVhc3Qgb25lIGFzIHdlIGFsd2F5cyBhZGQgdGhlIHJ1bGVOYW1lIHRvIHRoZSBzdGFjayBiZWZvcmUgaW52b2tpbmcgdGhlIHJ1bGUuXG4gICAgICAgIGlmICh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gRU9GX0ZPTExPV19LRVk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHZhciBjdXJyUnVsZUlkeCA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCgpO1xuICAgICAgICB2YXIgcHJldlJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBydWxlTmFtZTogdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShjdXJyUnVsZVNob3J0TmFtZSksXG4gICAgICAgICAgICBpZHhJbkNhbGxpbmdSdWxlOiBjdXJyUnVsZUlkeCxcbiAgICAgICAgICAgIGluUnVsZTogdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShwcmV2UnVsZVNob3J0TmFtZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5idWlsZEZ1bGxGb2xsb3dLZXlTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cGxpY2l0UnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICB2YXIgZXhwbGljaXRPY2N1cnJlbmNlU3RhY2sgPSB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIG1hcChleHBsaWNpdFJ1bGVTdGFjaywgZnVuY3Rpb24gKHJ1bGVOYW1lLCBpZHgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU9GX0ZPTExPV19LRVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBfdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgICAgICAgaWR4SW5DYWxsaW5nUnVsZTogZXhwbGljaXRPY2N1cnJlbmNlU3RhY2tbaWR4XSxcbiAgICAgICAgICAgICAgICBpblJ1bGU6IF90aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGV4cGxpY2l0UnVsZVN0YWNrW2lkeCAtIDFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZmxhdHRlbkZvbGxvd1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZvbGxvd1N0YWNrID0gbWFwKHRoaXMuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSwgZnVuY3Rpb24gKGN1cnJLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGN1cnJLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oZm9sbG93U3RhY2spO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkgPSBmdW5jdGlvbiAoZm9sbG93S2V5KSB7XG4gICAgICAgIGlmIChmb2xsb3dLZXkgPT09IEVPRl9GT0xMT1dfS0VZKSB7XG4gICAgICAgICAgICByZXR1cm4gW0VPRl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGxvd05hbWUgPSBmb2xsb3dLZXkucnVsZU5hbWUgKyBmb2xsb3dLZXkuaWR4SW5DYWxsaW5nUnVsZSArIElOICsgZm9sbG93S2V5LmluUnVsZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzeW5jRm9sbG93c1tmb2xsb3dOYW1lXTtcbiAgICB9O1xuICAgIC8vIEl0IGRvZXMgbm90IG1ha2UgYW55IHNlbnNlIHRvIGluY2x1ZGUgYSB2aXJ0dWFsIEVPRiB0b2tlbiBpbiB0aGUgbGlzdCBvZiByZXN5bmNlZCB0b2tlbnNcbiAgICAvLyBhcyBFT0YgZG9lcyBub3QgcmVhbGx5IGV4aXN0IGFuZCB0aHVzIGRvZXMgbm90IGNvbnRhaW4gYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiAobGluZS9jb2x1bW4gbnVtYmVycylcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuYWRkVG9SZXN5bmNUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4sIHJlc3luY1Rva2Vucykge1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5NYXRjaGVyKHRva2VuLCBFT0YpKSB7XG4gICAgICAgICAgICByZXN5bmNUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3luY1Rva2VucztcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5yZVN5bmNUbyA9IGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHZhciByZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICB2YXIgbmV4dFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHdoaWxlICh0aGlzLnRva2VuTWF0Y2hlcihuZXh0VG9rLCB0b2tUeXBlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5leHRUb2sgPSB0aGlzLlNLSVBfVE9LRU4oKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVG9SZXN5bmNUb2tlbnMobmV4dFRvaywgcmVzeW5jZWRUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHRva2VuIGlzIG5vdCBwYXJ0IG9mIHRoZSBlcnJvci5cbiAgICAgICAgcmV0dXJuIGRyb3BSaWdodChyZXN5bmNlZFRva2Vucyk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5ID0gZnVuY3Rpb24gKHByb2RGdW5jLCBhcmdzLCBsb29rYWhlYWRGdW5jLCBkc2xNZXRob2RJZHgsIHByb2RPY2N1cnJlbmNlLCBuZXh0VG9rc1dhbGtlciwgbm90U3R1Y2spIHtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCB0aGlzIGlzIGEgTk8tT1BcbiAgICAgICAgLy8gVGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBpcyB3aXRoIHRoZSBmdW5jdGlvbihub3QgbWV0aG9kKSBiZWxvd1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEN1cnJlbnRHcmFtbWFyUGF0aCA9IGZ1bmN0aW9uICh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpIHtcbiAgICAgICAgdmFyIHBhdGhSdWxlU3RhY2sgPSB0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKTtcbiAgICAgICAgdmFyIHBhdGhPY2N1cnJlbmNlU3RhY2sgPSBjbG9uZUFycih0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyk7XG4gICAgICAgIHZhciBncmFtbWFyUGF0aCA9IHtcbiAgICAgICAgICAgIHJ1bGVTdGFjazogcGF0aFJ1bGVTdGFjayxcbiAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogcGF0aE9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIGxhc3RUb2s6IHRva1R5cGUsXG4gICAgICAgICAgICBsYXN0VG9rT2NjdXJyZW5jZTogdG9rSWR4SW5SdWxlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBncmFtbWFyUGF0aDtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWFwKHRoaXMuUlVMRV9TVEFDSywgZnVuY3Rpb24gKGN1cnJTaG9ydE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShjdXJyU2hvcnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3ZlcmFibGU7XG59KCkpO1xuZXhwb3J0IHsgUmVjb3ZlcmFibGUgfTtcbmV4cG9ydCBmdW5jdGlvbiBhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UsIG5leHRUb2tzV2Fsa2VyLCBub3RTdHVjaykge1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChkc2xNZXRob2RJZHgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICB2YXIgZmlyc3RBZnRlclJlcEluZm8gPSB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXBba2V5XTtcbiAgICBpZiAoZmlyc3RBZnRlclJlcEluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY3VyclJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIHZhciBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbY3VyclJ1bGVOYW1lXTtcbiAgICAgICAgdmFyIHdhbGtlciA9IG5ldyBuZXh0VG9rc1dhbGtlcihydWxlR3JhbW1hciwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBmaXJzdEFmdGVyUmVwSW5mbyA9IHdhbGtlci5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgdGhpcy5maXJzdEFmdGVyUmVwTWFwW2tleV0gPSBmaXJzdEFmdGVyUmVwSW5mbztcbiAgICB9XG4gICAgdmFyIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID0gZmlyc3RBZnRlclJlcEluZm8udG9rZW47XG4gICAgdmFyIG5leHRUb2tJZHggPSBmaXJzdEFmdGVyUmVwSW5mby5vY2N1cnJlbmNlO1xuICAgIHZhciBpc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJSZXBJbmZvLmlzRW5kT2ZSdWxlO1xuICAgIC8vIHNwZWNpYWwgZWRnZSBjYXNlIG9mIGEgVE9QIG1vc3QgcmVwZXRpdGlvbiBhZnRlciB3aGljaCB0aGUgaW5wdXQgc2hvdWxkIEVORC5cbiAgICAvLyB0aGlzIHdpbGwgZm9yY2UgYW4gYXR0ZW1wdCBmb3IgaW5SdWxlIHJlY292ZXJ5IGluIHRoYXQgc2NlbmFyaW8uXG4gICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFbmRPZlJ1bGUgJiZcbiAgICAgICAgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IEVPRjtcbiAgICAgICAgbmV4dFRva0lkeCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZEluUmVwZXRpdGlvblJlY292ZXJ5QmVUcmllZChleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgbmV4dFRva0lkeCwgbm90U3R1Y2spKSB7XG4gICAgICAgIC8vIFRPRE86IHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaW5zdGVhZCBvZiBwYXNzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGhlcmUsIHdlIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXJncyBwYXJhbSAob3IgY3JlYXRlIGEgbmV3IG9uZSkgYW5kIG1ha2Ugc3VyZSB0aGUgbG9va2FoZWFkIGZ1bmMgaXMgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyB0byBhdm9pZCBzZWFyY2hpbmcgdGhlIGNhY2hlIGZvciBpdCBvbmNlIG1vcmUuXG4gICAgICAgIHRoaXMudHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvdmVyYWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeBuilder: () => (/* binding */ TreeBuilder)\n/* harmony export */ });\n/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../cst/cst */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../cst/cst_visitor */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : _parser__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            this.cstFinallyStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            this.cstPostTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            this.cstPostNonTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;\n                    this.setNodeLocationFromNode = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;\n                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset;\n                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                this.setInitialNodeLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        (0,_cst_cst__WEBPACK_IMPORTED_MODULE_0__.addTerminalToCst)(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        (0,_cst_cst__WEBPACK_IMPORTED_MODULE_0__.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = (0,_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__.createBaseSemanticVisitorConstructor)(this.className, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.keys)(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = (0,_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__.createBaseVisitorConstructorWithDefaults)(this.className, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.keys)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    return TreeBuilder;\n}());\n\n//# sourceMappingURL=tree_builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvdHJlZV9idWlsZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVIO0FBQ25EO0FBQ21EO0FBQ3JFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlEQUFHO0FBQ3ZDO0FBQ0EsY0FBYywwREFBcUI7QUFDbkM7QUFDQSw0Q0FBNEMsOENBQUk7QUFDaEQseUNBQXlDLDhDQUFJO0FBQzdDLG1DQUFtQyw4Q0FBSTtBQUN2QyxzQ0FBc0MsOENBQUk7QUFDMUMsK0JBQStCLDhDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlEQUFtQjtBQUN2RSxtREFBbUQseURBQW1CO0FBQ3RFLHVDQUF1Qyw4Q0FBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOENBQUk7QUFDeEQsbURBQW1ELDhDQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrREFBeUI7QUFDN0UsbURBQW1ELCtEQUF5QjtBQUM1RSx1Q0FBdUMsOENBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhDQUFJO0FBQ3hELG1EQUFtRCw4Q0FBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUFJO0FBQ3BELCtDQUErQyw4Q0FBSTtBQUNuRCxtQ0FBbUMsOENBQUk7QUFDdkMsOENBQThDLDhDQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBVztBQUN2QiwrQ0FBK0Msc0ZBQW9DLGlCQUFpQixrREFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFXO0FBQ3ZCLGlDQUFpQywwRkFBd0MsaUJBQWlCLGtEQUFJO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDc0I7QUFDdkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHBhcnNlXFxwYXJzZXJcXHRyYWl0c1xcdHJlZV9idWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZE5vbmVUZXJtaW5hbFRvQ3N0LCBhZGRUZXJtaW5hbFRvQ3N0LCBzZXROb2RlTG9jYXRpb25GdWxsLCBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0IH0gZnJvbSBcIi4uLy4uL2NzdC9jc3RcIjtcbmltcG9ydCB7IGhhcywgaXNVbmRlZmluZWQsIGtleXMsIE5PT1AgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3RvciwgY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cyB9IGZyb20gXCIuLi8uLi9jc3QvY3N0X3Zpc2l0b3JcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIENTVCBidWlsZGluZyBsb2dpYy5cbiAqL1xudmFyIFRyZWVCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVCdWlsZGVyKCkge1xuICAgIH1cbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuaW5pdFRyZWVCdWlsZGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICAvLyBvdXRwdXRDc3QgaXMgbm8gbG9uZ2VyIGV4cG9zZWQvZGVmaW5lZCBpbiB0aGUgcHViaWMgQVBJXG4gICAgICAgIHRoaXMub3V0cHV0Q3N0ID0gY29uZmlnLm91dHB1dENzdDtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRpb25UcmFja2luZyA9IGhhcyhjb25maWcsIFwibm9kZUxvY2F0aW9uVHJhY2tpbmdcIilcbiAgICAgICAgICAgID8gY29uZmlnLm5vZGVMb2NhdGlvblRyYWNraW5nXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5ub2RlTG9jYXRpb25UcmFja2luZztcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dENzdCkge1xuICAgICAgICAgICAgdGhpcy5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RGaW5hbGx5U3RhdGVVcGRhdGUgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IE5PT1A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoL2Z1bGwvaS50ZXN0KHRoaXMubm9kZUxvY2F0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gc2V0Tm9kZUxvY2F0aW9uRnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IHNldE5vZGVMb2NhdGlvbkZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gdGhpcy5jc3RQb3N0UnVsZUZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9IHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5T2Zmc2V0L2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IHNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IHRoaXMuY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvbm9uZS9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gTk9PUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8bm9kZUxvY2F0aW9uVHJhY2tpbmc+IGNvbmZpZyBvcHRpb246IFxcXCJcIiArIGNvbmZpZy5ub2RlTG9jYXRpb25UcmFja2luZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3ZlcnkgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWd1bGFyID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgZXJyb3IgcmVjb3ZlcnkgdGhlIHN0YXJ0aW5nIExvY2F0aW9uIG9mIGEgbmV3IENzdE5vZGUgaXMgZ3VhcmFudGVlZFxuICAgICAgICAgICAgLy8gVG8gYmUgdGhlIG5leHQgVG9rZW4ncyBzdGFydE9mZnNldCAoZm9yIHZhbGlkIGlucHV0cykuXG4gICAgICAgICAgICAvLyBGb3IgaW52YWxpZCBpbnB1dHMgdGhlcmUgd29uJ3QgYmUgYW55IENTVE91dHB1dCBzbyB0aGlzIHBvdGVudGlhbFxuICAgICAgICAgICAgLy8gaW5hY2N1cmFjeSBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0aGlzLkxBKDEpLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5ID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBzdGFydExpbmU6IE5hTixcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBOYU4sXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZExpbmU6IE5hTixcbiAgICAgICAgICAgIGVuZENvbHVtbjogTmFOXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqICBAc2VlIHNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhciBmb3IgZXhwbGFuYXRpb24gd2h5IHRoaXMgd29ya1xuICBcbiAgICAgICAqIEBwYXJhbSBjc3ROb2RlXG4gICAgICAgKi9cbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogbmV4dFRva2VuLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnRMaW5lOiBuZXh0VG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IG5leHRUb2tlbi5zdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kTGluZTogTmFOLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAoZnVsbFJ1bGVOYW1lLCBzaG9ydE5hbWUpIHtcbiAgICAgICAgdmFyIGNzdE5vZGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBmdWxsUnVsZU5hbWUsXG4gICAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uKGNzdE5vZGUpO1xuICAgICAgICB0aGlzLkNTVF9TVEFDSy5wdXNoKGNzdE5vZGUpO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucG9wKCk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0UG9zdFJ1bGVGdWxsID0gZnVuY3Rpb24gKHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIHZhciBwcmV2VG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICB2YXIgbG9jID0gcnVsZUNzdE5vZGUubG9jYXRpb247XG4gICAgICAgIC8vIElmIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgaXQgbWVhbnMgd2UgY29uc3VtZWQgYXQgbGVhc3Qgb25lIFRva2VuXG4gICAgICAgIC8vIEluIHRoaXMgQ3N0Tm9kZS5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICAgICAgbG9jLmVuZExpbmUgPSBwcmV2VG9rZW4uZW5kTGluZTtcbiAgICAgICAgICAgIGxvYy5lbmRDb2x1bW4gPSBwcmV2VG9rZW4uZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgICAgIGxvYy5zdGFydExpbmUgPSBOYU47XG4gICAgICAgICAgICBsb2Muc3RhcnRDb2x1bW4gPSBOYU47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RQb3N0UnVsZU9ubHlPZmZzZXQgPSBmdW5jdGlvbiAocnVsZUNzdE5vZGUpIHtcbiAgICAgICAgdmFyIHByZXZUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIHZhciBsb2MgPSBydWxlQ3N0Tm9kZS5sb2NhdGlvbjtcbiAgICAgICAgLy8gSWYgdGhpcyBjb25kaXRpb24gaXMgdHJ1ZSBpdCBtZWFucyB3ZSBjb25zdW1lZCBhdCBsZWFzdCBvbmUgVG9rZW5cbiAgICAgICAgLy8gSW4gdGhpcyBDc3ROb2RlLlxuICAgICAgICBpZiAobG9jLnN0YXJ0T2Zmc2V0IDw9IHByZXZUb2tlbi5zdGFydE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbG9jLmVuZE9mZnNldCA9IHByZXZUb2tlbi5lbmRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJlbXB0eVwiIENzdE5vZGUgZWRnZSBjYXNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9jLnN0YXJ0T2Zmc2V0ID0gTmFOO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0UG9zdFRlcm1pbmFsID0gZnVuY3Rpb24gKGtleSwgY29uc3VtZWRUb2tlbikge1xuICAgICAgICB2YXIgcm9vdENzdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICBhZGRUZXJtaW5hbFRvQ3N0KHJvb3RDc3QsIGNvbnN1bWVkVG9rZW4sIGtleSk7XG4gICAgICAgIC8vIFRoaXMgaXMgb25seSB1c2VkIHdoZW4gKipib3RoKiogZXJyb3IgcmVjb3ZlcnkgYW5kIENTVCBPdXRwdXQgYXJlIGVuYWJsZWQuXG4gICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuKHJvb3RDc3QubG9jYXRpb24sIGNvbnN1bWVkVG9rZW4pO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3ROb25UZXJtaW5hbCA9IGZ1bmN0aW9uIChydWxlQ3N0UmVzdWx0LCBydWxlTmFtZSkge1xuICAgICAgICB2YXIgcHJlQ3N0Tm9kZSA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICBhZGROb25lVGVybWluYWxUb0NzdChwcmVDc3ROb2RlLCBydWxlTmFtZSwgcnVsZUNzdFJlc3VsdCk7XG4gICAgICAgIC8vIFRoaXMgaXMgb25seSB1c2VkIHdoZW4gKipib3RoKiogZXJyb3IgcmVjb3ZlcnkgYW5kIENTVCBPdXRwdXQgYXJlIGVuYWJsZWQuXG4gICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUocHJlQ3N0Tm9kZS5sb2NhdGlvbiwgcnVsZUNzdFJlc3VsdC5sb2NhdGlvbik7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHZhciBuZXdCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yKHRoaXMuY2xhc3NOYW1lLCBrZXlzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvciA9IG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKHRoaXMuY2xhc3NOYW1lLCBrZXlzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpLCB0aGlzLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSk7XG4gICAgICAgICAgICB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHJldHVybiBydWxlU3RhY2tbcnVsZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICByZXR1cm4gcnVsZVN0YWNrW3J1bGVTdGFjay5sZW5ndGggLSAyXTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2NjdXJyZW5jZVN0YWNrID0gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7XG4gICAgICAgIHJldHVybiBvY2N1cnJlbmNlU3RhY2tbb2NjdXJyZW5jZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVCdWlsZGVyO1xufSgpKTtcbmV4cG9ydCB7IFRyZWVCdWlsZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlX2J1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer.js":
/*!***********************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MODE: () => (/* binding */ DEFAULT_MODE),\n/* harmony export */   LineTerminatorOptimizedTester: () => (/* binding */ LineTerminatorOptimizedTester),\n/* harmony export */   MODES: () => (/* binding */ MODES),\n/* harmony export */   SUPPORT_STICKY: () => (/* binding */ SUPPORT_STICKY),\n/* harmony export */   addStartOfInput: () => (/* binding */ addStartOfInput),\n/* harmony export */   addStickyFlag: () => (/* binding */ addStickyFlag),\n/* harmony export */   analyzeTokenTypes: () => (/* binding */ analyzeTokenTypes),\n/* harmony export */   buildLineBreakIssueMessage: () => (/* binding */ buildLineBreakIssueMessage),\n/* harmony export */   charCodeToOptimizedIndex: () => (/* binding */ charCodeToOptimizedIndex),\n/* harmony export */   cloneEmptyGroups: () => (/* binding */ cloneEmptyGroups),\n/* harmony export */   disableSticky: () => (/* binding */ disableSticky),\n/* harmony export */   enableSticky: () => (/* binding */ enableSticky),\n/* harmony export */   findDuplicatePatterns: () => (/* binding */ findDuplicatePatterns),\n/* harmony export */   findEmptyMatchRegExps: () => (/* binding */ findEmptyMatchRegExps),\n/* harmony export */   findEndOfInputAnchor: () => (/* binding */ findEndOfInputAnchor),\n/* harmony export */   findInvalidGroupType: () => (/* binding */ findInvalidGroupType),\n/* harmony export */   findInvalidPatterns: () => (/* binding */ findInvalidPatterns),\n/* harmony export */   findMissingPatterns: () => (/* binding */ findMissingPatterns),\n/* harmony export */   findModesThatDoNotExist: () => (/* binding */ findModesThatDoNotExist),\n/* harmony export */   findStartOfInputAnchor: () => (/* binding */ findStartOfInputAnchor),\n/* harmony export */   findUnreachablePatterns: () => (/* binding */ findUnreachablePatterns),\n/* harmony export */   findUnsupportedFlags: () => (/* binding */ findUnsupportedFlags),\n/* harmony export */   isCustomPattern: () => (/* binding */ isCustomPattern),\n/* harmony export */   isShortPattern: () => (/* binding */ isShortPattern),\n/* harmony export */   minOptimizationVal: () => (/* binding */ minOptimizationVal),\n/* harmony export */   performRuntimeChecks: () => (/* binding */ performRuntimeChecks),\n/* harmony export */   performWarningRuntimeChecks: () => (/* binding */ performWarningRuntimeChecks),\n/* harmony export */   validatePatterns: () => (/* binding */ validatePatterns)\n/* harmony export */ });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"(pages-dir-browser)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _reg_exp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reg_exp */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar PATTERN = \"PATTERN\";\nvar DEFAULT_MODE = \"defaultMode\";\nvar MODES = \"modes\";\nvar SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction disableSticky() {\n    SUPPORT_STICKY = false;\n}\nfunction enableSticky() {\n    SUPPORT_STICKY = true;\n}\nfunction analyzeTokenTypes(tokenTypes, options) {\n    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.defaults)(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function (msg, action) { return action(); }\n    });\n    var tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n    });\n    var onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reject)(tokenTypes, function (currType) {\n            return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA;\n        });\n    });\n    var hasCustom = false;\n    var allTransformedPatterns;\n    tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (currType) {\n            var currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currPattern)) {\n                var regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\" &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\"\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(currPattern, \"exec\")) {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    var wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    var patternIdxToType;\n    var patternIdxToGroup;\n    var patternIdxToLongerAltIdx;\n    var patternIdxToPushMode;\n    var patternIdxToPopMode;\n    tracer(\"misc mapping\", function () {\n        patternIdxToType = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });\n        patternIdxToGroup = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {\n            var groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(groupName)) {\n                return groupName;\n            }\n            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {\n            var longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                var longerAltIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.indexOf)(onlyRelevantTypes, longerAltType);\n                return longerAltIdx;\n            }\n        });\n        patternIdxToPushMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });\n        patternIdxToPopMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(clazz, \"POP_MODE\");\n        });\n    });\n    var patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (tokType) { return false; });\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (tokType) {\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, \"LINE_BREAKS\")) {\n                    return tokType.LINE_BREAKS;\n                }\n                else {\n                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n                        return (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);\n                    }\n                }\n            });\n        }\n    });\n    var patternIdxToIsCustom;\n    var patternIdxToShort;\n    var emptyGroups;\n    var patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(allTransformedPatterns, isShortPattern);\n        emptyGroups = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(onlyRelevantTypes, function (acc, clazz) {\n            var groupName = clazz.GROUP;\n            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(groupName) && !(groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(allTransformedPatterns, function (x, idx) {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdx[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    var canBeOptimized = true;\n    var charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n            charCodeToPatternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(onlyRelevantTypes, function (result, currTokType, idx) {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    var charCode = currTokType.PATTERN.charCodeAt(0);\n                    var optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(currTokType.START_CHARS_HINT)) {\n                    var lastOptimizedIdx_1;\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(currTokType.START_CHARS_HINT, function (charOrInt) {\n                        var charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n                            lastOptimizedIdx_1 = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)(\"\" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg +\n                                (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        var optimizedCodes = (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(optimizedCodes, function (code) {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)(\"\" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg +\n                            (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    tracer(\"ArrayPacking\", function () {\n        charCodeToPatternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.packArray)(charCodeToPatternIdxToConfig);\n    });\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\nfunction validatePatterns(tokenTypes, validModesNames) {\n    var errors = [];\n    var missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    var invalidResult = findInvalidPatterns(missingResult.valid);\n    var validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    var errors = [];\n    var withRegExpPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currTokType) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currTokType[PATTERN]);\n    });\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n    var tokenTypesWithMissingPattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        return !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(currType, PATTERN);\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypesWithMissingPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.difference)(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors: errors, valid: valid };\n}\nfunction findInvalidPatterns(tokenTypes) {\n    var tokenTypesWithInvalidPattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern) &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern) &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, \"exec\") &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern));\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.difference)(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors: errors, valid: valid };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n    var EndAnchorFinder = /** @class */ (function (_super) {\n        __extends(EndAnchorFinder, _super);\n        function EndAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n            this.found = true;\n        };\n        return EndAnchorFinder;\n    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));\n    var invalidRegex = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);\n            var endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findEmptyMatchRegExps(tokenTypes) {\n    var matchesEmptyString = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern.test(\"\");\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(matchesEmptyString, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n    var StartAnchorFinder = /** @class */ (function (_super) {\n        __extends(StartAnchorFinder, _super);\n        function StartAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n            this.found = true;\n        };\n        return StartAnchorFinder;\n    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));\n    var invalidRegex = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);\n            var startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findUnsupportedFlags(tokenTypes) {\n    var invalidFlags = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidFlags, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nfunction findDuplicatePatterns(tokenTypes) {\n    var found = [];\n    var identicalPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypes, function (outerType) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(tokenTypes, function (result, innerType) {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)(found, innerType) &&\n                innerType.PATTERN !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.compact)(identicalPatterns);\n    var duplicatePatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(setOfIdentical, function (currType) {\n            return currType.name;\n        });\n        var dupPatternSrc = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.first)(setOfIdentical).PATTERN;\n        return {\n            message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" +\n                (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\nfunction findInvalidGroupType(tokenTypes) {\n    var invalidTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (clazz) {\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(clazz, \"GROUP\")) {\n            return false;\n        }\n        var group = clazz.GROUP;\n        return group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED && group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA && !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(group);\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidTypes, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n    var invalidModes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (clazz) {\n        return (clazz.PUSH_MODE !== undefined && !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)(validModes, clazz.PUSH_MODE));\n    });\n    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" +\n            \"which does not exist\";\n        return {\n            message: msg,\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType]\n        };\n    });\n    return errors;\n}\nfunction findUnreachablePatterns(tokenTypes) {\n    var errors = [];\n    var canBeTested = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern)) {\n            result.push({ str: pattern, idx: idx, tokenType: tokType });\n        }\n        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx: idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(tokenTypes, function (tokType, testIdx) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(canBeTested, function (_a) {\n            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" +\n                    (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") +\n                    \"in the lexer's definition.\\n\" +\n                    \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n                errors.push({\n                    message: msg,\n                    type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType]\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    var metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.find)(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) === undefined);\n}\nfunction addStartOfInput(pattern) {\n    var flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nfunction addStickyFlag(pattern) {\n    var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"\" + pattern.source, flags);\n}\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var errors = [];\n    // some run time checks to help the end users.\n    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n    }\n    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES) &&\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, DEFAULT_MODE) &&\n        !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" +\n                \"which does not exist\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES)) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(lexerDefinition.modes, function (currModeValue, currModeName) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(currModeValue, function (currTokType, currIdx) {\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(currTokType)) {\n                    errors.push({\n                        message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" +\n                            (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n                        type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var warnings = [];\n    var hasAnyLineBreak = false;\n    var allTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.compact)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.mapValues)(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));\n    var concreteTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reject)(allTokenTypes, function (currType) { return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA; });\n    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(concreteTokenTypes, function (tokType) {\n            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                var message = buildLineBreakIssueMessage(tokType, currIssue);\n                var warningDescriptor = {\n                    message: message,\n                    type: currIssue.issue,\n                    tokenType: tokType\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if ((0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n    }\n    return warnings;\n}\nfunction cloneEmptyGroups(emptyGroups) {\n    var clonedResult = {};\n    var groupKeys = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.keys)(emptyGroups);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nfunction isCustomPattern(tokenType) {\n    var pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern)) {\n        return false;\n    }\n    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction isShortPattern(pattern) {\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nvar LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        var len = text.length;\n        for (var i = this.lastIndex; i < len; i++) {\n            var c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(tokType.PATTERN)) {\n            try {\n                (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        }\n        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            (\"\\t Root cause: \" + details.errMsg + \".\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    var charCodes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(charsOrCodes, function (numOrString) {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(numOrString) && numOrString.length > 0) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nvar minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nfunction charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var i = 0; i < 65536; i++) {\n            /* tslint:disable */\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n            /* tslint:enable */\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vbGV4ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDaUQ7QUFDZTtBQUMwTDtBQUNsSjtBQUN6RDtBQUNoRDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsY0FBYyxzREFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixvREFBTTtBQUNsQyx5Q0FBeUMsZ0RBQUs7QUFDOUMsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBRztBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCLGlEQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBRywwQ0FBMEMsK0JBQStCO0FBQ3ZHLDRCQUE0QixpREFBRztBQUMvQjtBQUNBO0FBQ0EsOEJBQThCLGdEQUFLO0FBQ25DO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVE7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQix5REFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1DQUFtQyxpREFBRztBQUN0QztBQUNBO0FBQ0EsbUNBQW1DLHFEQUFPO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLGlEQUFHLHVDQUF1Qyx5QkFBeUI7QUFDbEcsOEJBQThCLGlEQUFHO0FBQ2pDLG1CQUFtQixpREFBRztBQUN0QixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBRyx5Q0FBeUMsZUFBZTtBQUNuRztBQUNBLDRDQUE0QyxpREFBRztBQUMvQyxvQkFBb0IsaURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQWdCO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBRztBQUNsQyw0QkFBNEIsaURBQUc7QUFDL0Isc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0EsZ0JBQWdCLHNEQUFRLCtCQUErQixnREFBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYiw2QkFBNkIsaURBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvREFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFPO0FBQ2hDO0FBQ0Esb0JBQW9CLHFEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHlCQUF5QixzREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVcsTUFBTSxpRUFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUVBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFPO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFXLE1BQU0saUVBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVEQUFTO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFNO0FBQ25DLGVBQWUsc0RBQVE7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1Q0FBdUMsb0RBQU07QUFDN0MsZ0JBQWdCLGlEQUFHO0FBQ25CLEtBQUs7QUFDTCxpQkFBaUIsaURBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQXdCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLHdEQUFVO0FBQzFCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsdUNBQXVDLG9EQUFNO0FBQzdDO0FBQ0EsaUJBQWlCLHNEQUFRO0FBQ3pCLGFBQWEsd0RBQVU7QUFDdkIsYUFBYSxpREFBRztBQUNoQixhQUFhLHNEQUFRO0FBQ3JCLEtBQUs7QUFDTCxpQkFBaUIsaURBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCLGdDQUFnQyxnQkFBZ0I7QUFDbkgsa0JBQWtCLG1FQUF3QjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQix3REFBVTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssQ0FBQyw0REFBaUI7QUFDdkIsdUJBQXVCLG9EQUFNO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixpREFBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCw2QkFBNkIsb0RBQU07QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsaURBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQXdCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxDQUFDLDREQUFpQjtBQUN2Qix1QkFBdUIsb0RBQU07QUFDN0I7QUFDQTtBQUNBLDRCQUE0Qiw2REFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGlEQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUF3QjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixvREFBTTtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixpREFBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLGlEQUFHO0FBQy9CLGVBQWUsb0RBQU07QUFDckI7QUFDQSxpQkFBaUIsc0RBQVE7QUFDekIsc0NBQXNDLGdEQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCx3QkFBd0IscURBQU87QUFDL0IsNEJBQTRCLG9EQUFNO0FBQ2xDO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixpREFBRztBQUNwQiw2QkFBNkIsaURBQUc7QUFDaEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLG1EQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCx1QkFBdUIsb0RBQU07QUFDN0IsYUFBYSxpREFBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQUssc0JBQXNCLGdEQUFLLFFBQVEsc0RBQVE7QUFDekUsS0FBSztBQUNMLGlCQUFpQixpREFBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCx1QkFBdUIsb0RBQU07QUFDN0Isa0RBQWtELHNEQUFRO0FBQzFELEtBQUs7QUFDTCxpQkFBaUIsaURBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQXdCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQkFBc0Isb0RBQU07QUFDNUI7QUFDQSx3QkFBd0IsZ0RBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFRO0FBQ3BCLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQSxpQkFBaUIsc0RBQVE7QUFDekIsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUkscURBQU87QUFDWCxRQUFRLHFEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBd0I7QUFDbEQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFVO0FBQ3ZCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsYUFBYSxpREFBRztBQUNoQjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsWUFBWSxrREFBSSw4QkFBOEIsNENBQTRDO0FBQzFGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsU0FBUyxpREFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUF3QjtBQUMxQyxTQUFTO0FBQ1Q7QUFDQSxTQUFTLGlEQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQXdCO0FBQzFDLFNBQVM7QUFDVDtBQUNBLFFBQVEsaURBQUc7QUFDWCxRQUFRLGlEQUFHO0FBQ1gsU0FBUyxpREFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUMsU0FBUztBQUNUO0FBQ0EsUUFBUSxpREFBRztBQUNYLFFBQVEscURBQU87QUFDZixZQUFZLHFEQUFPO0FBQ25CLG9CQUFvQix5REFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQXdCO0FBQ3RELHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFPLENBQUMscURBQU8sQ0FBQyx1REFBUyw4Q0FBOEMsa0JBQWtCO0FBQ2pILDZCQUE2QixvREFBTSxzQ0FBc0MsNkJBQTZCLGdEQUFLLE1BQU07QUFDakg7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0Isa0RBQUk7QUFDeEIsSUFBSSxxREFBTztBQUNYO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSxzREFBUTtBQUNoQjtBQUNBO0FBQ0EsYUFBYSx3REFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHNEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVE7QUFDcEI7QUFDQSxnQkFBZ0IsMERBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxtRUFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBCQUEwQixtRUFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtRUFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFHO0FBQ3ZCLFlBQVksc0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBTztBQUNmO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHNjYW5cXGxleGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBCYXNlUmVnRXhwVmlzaXRvciB9IGZyb20gXCJyZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4vbGV4ZXJfcHVibGljXCI7XG5pbXBvcnQgeyBjb21wYWN0LCBjb250YWlucywgZGVmYXVsdHMsIGRpZmZlcmVuY2UsIGZpbHRlciwgZmluZCwgZmlyc3QsIGZsYXR0ZW4sIGZvckVhY2gsIGhhcywgaW5kZXhPZiwgaXNBcnJheSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwga2V5cywgbWFwLCBtYXBWYWx1ZXMsIHBhY2tBcnJheSwgUFJJTlRfRVJST1IsIHJlZHVjZSwgcmVqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjYW5NYXRjaENoYXJDb2RlLCBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2csIGdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzIH0gZnJvbSBcIi4vcmVnX2V4cFwiO1xuaW1wb3J0IHsgZ2V0UmVnRXhwQXN0IH0gZnJvbSBcIi4vcmVnX2V4cF9wYXJzZXJcIjtcbnZhciBQQVRURVJOID0gXCJQQVRURVJOXCI7XG5leHBvcnQgdmFyIERFRkFVTFRfTU9ERSA9IFwiZGVmYXVsdE1vZGVcIjtcbmV4cG9ydCB2YXIgTU9ERVMgPSBcIm1vZGVzXCI7XG5leHBvcnQgdmFyIFNVUFBPUlRfU1RJQ0tZID0gdHlwZW9mIG5ldyBSZWdFeHAoXCIoPzopXCIpLnN0aWNreSA9PT0gXCJib29sZWFuXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZVRva2VuVHlwZXModG9rZW5UeXBlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHVzZVN0aWNreTogU1VQUE9SVF9TVElDS1ksXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgc2FmZU1vZGU6IGZhbHNlLFxuICAgICAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICAgICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBbXCJcXHJcIiwgXCJcXG5cIl0sXG4gICAgICAgIHRyYWNlcjogZnVuY3Rpb24gKG1zZywgYWN0aW9uKSB7IHJldHVybiBhY3Rpb24oKTsgfVxuICAgIH0pO1xuICAgIHZhciB0cmFjZXIgPSBvcHRpb25zLnRyYWNlcjtcbiAgICB0cmFjZXIoXCJpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdENoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleE1hcCgpO1xuICAgIH0pO1xuICAgIHZhciBvbmx5UmVsZXZhbnRUeXBlcztcbiAgICB0cmFjZXIoXCJSZWplY3QgTGV4ZXIuTkFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmx5UmVsZXZhbnRUeXBlcyA9IHJlamVjdCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyVHlwZVtQQVRURVJOXSA9PT0gTGV4ZXIuTkE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICB2YXIgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucztcbiAgICB0cmFjZXIoXCJUcmFuc2Zvcm0gUGF0dGVybnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICAgICAgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucyA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY3VyclBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAoY3VyclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ0V4cFNvdXJjZSA9IGN1cnJQYXR0ZXJuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAocmVnRXhwU291cmNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZXNlIHJlZ0V4cCBtZXRhIGNoYXJhY3RlcnMgd2hpY2ggY2FuIGFwcGVhciBpbiBhIGxlbmd0aCBvbmUgcmVnRXhwXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCJeXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIiRcIiAmJlxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiLlwiICYmXG4gICAgICAgICAgICAgICAgICAgICFjdXJyUGF0dGVybi5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZ0V4cFNvdXJjZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlWzBdID09PSBcIlxcXFxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBtZXRhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAhY29udGFpbnMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJXXCJcbiAgICAgICAgICAgICAgICAgICAgXSwgcmVnRXhwU291cmNlWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGVkIG1ldGEgQ2hhcmFjdGVyczogL1xcKy8gL1xcWy9cbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVkdW5kYW50IGVzY2FwaW5nOiAvXFxhL1xuICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBlc2NhcGluZyBcIlxcXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cFNvdXJjZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKGN1cnJQYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRTdGFydE9mSW5wdXQoY3VyclBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY3VyclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaGFzQ3VzdG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmMgLSBjdXN0b20gcGF0dGVybnMgZG8gbm90IHJlcXVpcmUgYW55IHRyYW5zZm9ybWF0aW9ucywgb25seSB3cmFwcGluZyBpbiBhIFJlZ0V4cCBMaWtlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiB7IGV4ZWM6IGN1cnJQYXR0ZXJuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXMoY3VyclBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY3VyclBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkUmVnRXhwU3RyaW5nID0gY3VyclBhdHRlcm4ucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlZFJlZ0V4cFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKHdyYXBwZWRSZWdFeHApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dCh3cmFwcGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcGF0dGVybklkeFRvVHlwZTtcbiAgICB2YXIgcGF0dGVybklkeFRvR3JvdXA7XG4gICAgdmFyIHBhdHRlcm5JZHhUb0xvbmdlckFsdElkeDtcbiAgICB2YXIgcGF0dGVybklkeFRvUHVzaE1vZGU7XG4gICAgdmFyIHBhdHRlcm5JZHhUb1BvcE1vZGU7XG4gICAgdHJhY2VyKFwibWlzYyBtYXBwaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvVHlwZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7IHJldHVybiBjdXJyVHlwZS50b2tlblR5cGVJZHg7IH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Hcm91cCA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4ID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIHZhciBsb25nZXJBbHRUeXBlID0gY2xhenouTE9OR0VSX0FMVDtcbiAgICAgICAgICAgIGlmIChsb25nZXJBbHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdElkeCA9IGluZGV4T2Yob25seVJlbGV2YW50VHlwZXMsIGxvbmdlckFsdFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb25nZXJBbHRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9QdXNoTW9kZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiBjbGF6ei5QVVNIX01PREU7IH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Qb3BNb2RlID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIHJldHVybiBoYXMoY2xhenosIFwiUE9QX01PREVcIik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvcjtcbiAgICB0cmFjZXIoXCJMaW5lIFRlcm1pbmF0b3IgSGFuZGxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMgPSBnZXRDaGFyQ29kZXMob3B0aW9ucy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpO1xuICAgICAgICBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvciA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKHRva1R5cGUpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb25UcmFja2luZyAhPT0gXCJvbmx5T2Zmc2V0XCIpIHtcbiAgICAgICAgICAgIHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rVHlwZS5MSU5FX0JSRUFLUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbk1hdGNoQ2hhckNvZGUobGluZVRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Jc0N1c3RvbTtcbiAgICB2YXIgcGF0dGVybklkeFRvU2hvcnQ7XG4gICAgdmFyIGVtcHR5R3JvdXBzO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgdHJhY2VyKFwiTWlzYyBNYXBwaW5nICMyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvSXNDdXN0b20gPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGlzQ3VzdG9tUGF0dGVybik7XG4gICAgICAgIHBhdHRlcm5JZHhUb1Nob3J0ID0gbWFwKGFsbFRyYW5zZm9ybWVkUGF0dGVybnMsIGlzU2hvcnRQYXR0ZXJuKTtcbiAgICAgICAgZW1wdHlHcm91cHMgPSByZWR1Y2Uob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChhY2MsIGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZ3JvdXBOYW1lKSAmJiAhKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkpIHtcbiAgICAgICAgICAgICAgICBhY2NbZ3JvdXBOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSBtYXAoYWxsVHJhbnNmb3JtZWRQYXR0ZXJucywgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zW2lkeF0sXG4gICAgICAgICAgICAgICAgbG9uZ2VyQWx0OiBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhbaWR4XSxcbiAgICAgICAgICAgICAgICBjYW5MaW5lVGVybWluYXRvcjogcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3JbaWR4XSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbTogcGF0dGVybklkeFRvSXNDdXN0b21baWR4XSxcbiAgICAgICAgICAgICAgICBzaG9ydDogcGF0dGVybklkeFRvU2hvcnRbaWR4XSxcbiAgICAgICAgICAgICAgICBncm91cDogcGF0dGVybklkeFRvR3JvdXBbaWR4XSxcbiAgICAgICAgICAgICAgICBwdXNoOiBwYXR0ZXJuSWR4VG9QdXNoTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHBvcDogcGF0dGVybklkeFRvUG9wTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZUlkeDogcGF0dGVybklkeFRvVHlwZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb25seVJlbGV2YW50VHlwZXNbaWR4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGNhbkJlT3B0aW1pemVkID0gdHJ1ZTtcbiAgICB2YXIgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgIGlmICghb3B0aW9ucy5zYWZlTW9kZSkge1xuICAgICAgICB0cmFjZXIoXCJGaXJzdCBDaGFyIE9wdGltaXphdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gcmVkdWNlKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyVG9rVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyVG9rVHlwZS5QQVRURVJOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IGN1cnJUb2tUeXBlLlBBVFRFUk4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBvcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE9wdGltaXplZElkeF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLlNUQVJUX0NIQVJTX0hJTlQsIGZ1bmN0aW9uIChjaGFyT3JJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHR5cGVvZiBjaGFyT3JJbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoYXJPckludC5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGFyT3JJbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyck9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgdGhlIGNvbmZpZyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gRGlmZmljdWx0IHRvIGNoZWNrIHRoaXMgc2NlbmFyaW8gZWZmZWN0cyBhcyBpdCBpcyBvbmx5IGEgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgb3B0aW1pemF0aW9uIHRoYXQgZG9lcyBub3QgY2hhbmdlIGNvcnJlY3RuZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE9wdGltaXplZElkeF8xICE9PSBjdXJyT3B0aW1pemVkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE9wdGltaXplZElkeF8xID0gY3Vyck9wdGltaXplZElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgY3Vyck9wdGltaXplZElkeCwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAoY3VyclRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJUb2tUeXBlLlBBVFRFUk4udW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQUklOVF9FUlJPUihcIlwiICsgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFx0VW5hYmxlIHRvIGFuYWx5emUgPCBcIiArIGN1cnJUb2tUeXBlLlBBVFRFUk4udG9TdHJpbmcoKSArIFwiID4gcGF0dGVybi5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoZSByZWdleHAgdW5pY29kZSBmbGFnIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTklDT0RFX09QVElNSVpFXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGltaXplZENvZGVzID0gZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXMoY3VyclRva1R5cGUuUEFUVEVSTiwgb3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgY29kZSB3aWxsIG9ubHkgYmUgZW1wdHkgZ2l2ZW4gYW4gZW1wdHkgcmVnRXhwIG9yIGZhaWx1cmUgb2YgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2hvdWxkIGJlIGEgZGlmZmVyZW50IHZhbGlkYXRpb24gYW5kIHRoZSBzZWNvbmQgY2Fubm90IGJlIHRlc3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG9wdGltaXplZENvZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCB1bmRlcnN0YW5kIHdoYXQgY29kZXMgbWF5IHN0YXJ0IHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3B0aW1pemF0aW9uIGNvcnJlY3RuZXNzIHJlcXVpcmVzIGtub3dpbmcgc3RhcnQgY29kZXMgZm9yIEFMTCBwYXR0ZXJucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWN0dWFsbHkgc3VyZSB0aGlzIGlzIGFuIGVycm9yLCBubyBkZWJ1ZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gob3B0aW1pemVkQ29kZXMsIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIGNvZGUsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQUklOVF9FUlJPUihcIlwiICsgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXHRUb2tlblR5cGU6IDxcIiArIGN1cnJUb2tUeXBlLm5hbWUgKyBcIj4gaXMgdXNpbmcgYSBjdXN0b20gdG9rZW4gcGF0dGVybiB3aXRob3V0IHByb3ZpZGluZyA8c3RhcnRfY2hhcnNfaGludD4gcGFyYW1ldGVyLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fT1BUSU1JWkVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYWNlcihcIkFycmF5UGFja2luZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBwYWNrQXJyYXkoY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHlHcm91cHM6IGVtcHR5R3JvdXBzLFxuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWc6IHBhdHRlcm5JZHhUb0NvbmZpZyxcbiAgICAgICAgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZzogY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyxcbiAgICAgICAgaGFzQ3VzdG9tOiBoYXNDdXN0b20sXG4gICAgICAgIGNhbkJlT3B0aW1pemVkOiBjYW5CZU9wdGltaXplZFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJucyh0b2tlblR5cGVzLCB2YWxpZE1vZGVzTmFtZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG1pc3NpbmdSZXN1bHQgPSBmaW5kTWlzc2luZ1BhdHRlcm5zKHRva2VuVHlwZXMpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQobWlzc2luZ1Jlc3VsdC5lcnJvcnMpO1xuICAgIHZhciBpbnZhbGlkUmVzdWx0ID0gZmluZEludmFsaWRQYXR0ZXJucyhtaXNzaW5nUmVzdWx0LnZhbGlkKTtcbiAgICB2YXIgdmFsaWRUb2tlblR5cGVzID0gaW52YWxpZFJlc3VsdC52YWxpZDtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGludmFsaWRSZXN1bHQuZXJyb3JzKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlUmVnRXhwUGF0dGVybih2YWxpZFRva2VuVHlwZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRJbnZhbGlkR3JvdXBUeXBlKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZE1vZGVzVGhhdERvTm90RXhpc3QodmFsaWRUb2tlblR5cGVzLCB2YWxpZE1vZGVzTmFtZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJlZ0V4cFBhdHRlcm4odG9rZW5UeXBlcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgd2l0aFJlZ0V4cFBhdHRlcm5zID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gaXNSZWdFeHAoY3VyclRva1R5cGVbUEFUVEVSTl0pO1xuICAgIH0pO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEVuZE9mSW5wdXRBbmNob3Iod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kU3RhcnRPZklucHV0QW5jaG9yKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFVuc3VwcG9ydGVkRmxhZ3Mod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kRHVwbGljYXRlUGF0dGVybnMod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kRW1wdHlNYXRjaFJlZ0V4cHMod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWlzc2luZ1BhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuICFoYXMoY3VyclR5cGUsIFBBVFRFUk4pO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAodG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gbWlzc2luZyBzdGF0aWMgJ1BBVFRFUk4nIHByb3BlcnR5XCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTUlTU0lOR19QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciB2YWxpZCA9IGRpZmZlcmVuY2UodG9rZW5UeXBlcywgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybik7XG4gICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcnMsIHZhbGlkOiB2YWxpZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbnZhbGlkUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciB0b2tlblR5cGVzV2l0aEludmFsaWRQYXR0ZXJuID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gKCFpc1JlZ0V4cChwYXR0ZXJuKSAmJlxuICAgICAgICAgICAgIWlzRnVuY3Rpb24ocGF0dGVybikgJiZcbiAgICAgICAgICAgICFoYXMocGF0dGVybiwgXCJleGVjXCIpICYmXG4gICAgICAgICAgICAhaXNTdHJpbmcocGF0dGVybikpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAodG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybiwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW4gb25seSBiZSBhIFJlZ0V4cCwgYVwiICtcbiAgICAgICAgICAgICAgICBcIiBGdW5jdGlvbiBtYXRjaGluZyB0aGUge0N1c3RvbVBhdHRlcm5NYXRjaGVyRnVuY30gdHlwZSBvciBhbiBPYmplY3QgbWF0Y2hpbmcgdGhlIHtJQ3VzdG9tUGF0dGVybn0gaW50ZXJmYWNlLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgdmFsaWQgPSBkaWZmZXJlbmNlKHRva2VuVHlwZXMsIHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4pO1xuICAgIHJldHVybiB7IGVycm9yczogZXJyb3JzLCB2YWxpZDogdmFsaWQgfTtcbn1cbnZhciBlbmRfb2ZfaW5wdXQgPSAvW15cXFxcXVtcXCRdLztcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRW5kT2ZJbnB1dEFuY2hvcih0b2tlblR5cGVzKSB7XG4gICAgdmFyIEVuZEFuY2hvckZpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVuZEFuY2hvckZpbmRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW5kQW5jaG9yRmluZGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEVuZEFuY2hvckZpbmRlci5wcm90b3R5cGUudmlzaXRFbmRBbmNob3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbmRBbmNob3JGaW5kZXI7XG4gICAgfShCYXNlUmVnRXhwVmlzaXRvcikpO1xuICAgIHZhciBpbnZhbGlkUmVnZXggPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhwQXN0ID0gZ2V0UmVnRXhwQXN0KHBhdHRlcm4pO1xuICAgICAgICAgICAgdmFyIGVuZEFuY2hvclZpc2l0b3IgPSBuZXcgRW5kQW5jaG9yRmluZGVyKCk7XG4gICAgICAgICAgICBlbmRBbmNob3JWaXNpdG9yLnZpc2l0KHJlZ2V4cEFzdCk7XG4gICAgICAgICAgICByZXR1cm4gZW5kQW5jaG9yVmlzaXRvci5mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIGluIGNhc2Ugb2YgcnVudGltZSBleGNlcHRpb25zIHdpdGggcmVnZXhwLXRvLWFzdC5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2Fubm90IGVuc3VyZSBhbiBlcnJvciBpbiByZWdleHAtdG8tYXN0Ki9cbiAgICAgICAgICAgIHJldHVybiBlbmRfb2ZfaW5wdXQudGVzdChwYXR0ZXJuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKGludmFsaWRSZWdleCwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgUmVnRXhwIEFuY2hvciBFcnJvcjpcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2Fubm90IGNvbnRhaW4gZW5kIG9mIGlucHV0IGFuY2hvciAnJCdcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWUgc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FT0lfQU5DSE9SX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEVtcHR5TWF0Y2hSZWdFeHBzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgbWF0Y2hlc0VtcHR5U3RyaW5nID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KFwiXCIpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAobWF0Y2hlc0VtcHR5U3RyaW5nLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG11c3Qgbm90IG1hdGNoIGFuIGVtcHR5IHN0cmluZ1wiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVNUFRZX01BVENIX1BBVFRFUk4sXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbnZhciBzdGFydF9vZl9pbnB1dCA9IC9bXlxcXFxbXVtcXF5dfF5cXF4vO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdGFydE9mSW5wdXRBbmNob3IodG9rZW5UeXBlcykge1xuICAgIHZhciBTdGFydEFuY2hvckZpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFN0YXJ0QW5jaG9yRmluZGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTdGFydEFuY2hvckZpbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBTdGFydEFuY2hvckZpbmRlci5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0YXJ0QW5jaG9yRmluZGVyO1xuICAgIH0oQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbiAgICB2YXIgaW52YWxpZFJlZ2V4ID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4cEFzdCA9IGdldFJlZ0V4cEFzdChwYXR0ZXJuKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuY2hvclZpc2l0b3IgPSBuZXcgU3RhcnRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIHN0YXJ0QW5jaG9yVmlzaXRvci52aXNpdChyZWdleHBBc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0QW5jaG9yVmlzaXRvci5mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIGluIGNhc2Ugb2YgcnVudGltZSBleGNlcHRpb25zIHdpdGggcmVnZXhwLXRvLWFzdC5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2Fubm90IGVuc3VyZSBhbiBlcnJvciBpbiByZWdleHAtdG8tYXN0Ki9cbiAgICAgICAgICAgIHJldHVybiBzdGFydF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZFJlZ2V4LCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBzdGFydCBvZiBpbnB1dCBhbmNob3IgJ14nXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5TT0lfQU5DSE9SX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZFVuc3VwcG9ydGVkRmxhZ3ModG9rZW5UeXBlcykge1xuICAgIHZhciBpbnZhbGlkRmxhZ3MgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHJldHVybiBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwICYmIChwYXR0ZXJuLm11bHRpbGluZSB8fCBwYXR0ZXJuLmdsb2JhbCk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChpbnZhbGlkRmxhZ3MsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgbWF5IE5PVCBjb250YWluIGdsb2JhbCgnZycpIG9yIG11bHRpbGluZSgnbScpXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5TVVBQT1JURURfRkxBR1NfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRoaXMgY2FuIG9ubHkgdGVzdCBmb3IgaWRlbnRpY2FsIGR1cGxpY2F0ZSBSZWdFeHBzLCBub3Qgc2VtYW50aWNhbGx5IGVxdWl2YWxlbnQgb25lcy5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIHZhciBpZGVudGljYWxQYXR0ZXJucyA9IG1hcCh0b2tlblR5cGVzLCBmdW5jdGlvbiAob3V0ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2UodG9rZW5UeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgaW5uZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAob3V0ZXJUeXBlLlBBVFRFUk4uc291cmNlID09PSBpbm5lclR5cGUuUEFUVEVSTi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnMoZm91bmQsIGlubmVyVHlwZSkgJiZcbiAgICAgICAgICAgICAgICBpbm5lclR5cGUuUEFUVEVSTiAhPT0gTGV4ZXIuTkEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyBkdXBsaWNhdGVzIGluIHRoZSByZXN1bHQsIGVhY2ggVG9rZW4gVHlwZSBtYXkgb25seSBhcHBlYXIgaW4gb25lIFwic2V0XCJcbiAgICAgICAgICAgICAgICAvLyBpbiBlc3NlbmNlIHdlIGFyZSBjcmVhdGluZyBFcXVpdmFsZW5jZSBjbGFzc2VzIG9uIGVxdWFsaXR5IHJlbGF0aW9uLlxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goaW5uZXJUeXBlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbm5lclR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgfSk7XG4gICAgaWRlbnRpY2FsUGF0dGVybnMgPSBjb21wYWN0KGlkZW50aWNhbFBhdHRlcm5zKTtcbiAgICB2YXIgZHVwbGljYXRlUGF0dGVybnMgPSBmaWx0ZXIoaWRlbnRpY2FsUGF0dGVybnMsIGZ1bmN0aW9uIChjdXJySWRlbnRpY2FsU2V0KSB7XG4gICAgICAgIHJldHVybiBjdXJySWRlbnRpY2FsU2V0Lmxlbmd0aCA+IDE7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChkdXBsaWNhdGVQYXR0ZXJucywgZnVuY3Rpb24gKHNldE9mSWRlbnRpY2FsKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGVOYW1lcyA9IG1hcChzZXRPZklkZW50aWNhbCwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclR5cGUubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkdXBQYXR0ZXJuU3JjID0gZmlyc3Qoc2V0T2ZJZGVudGljYWwpLlBBVFRFUk47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBzYW1lIFJlZ0V4cCBwYXR0ZXJuIC0+XCIgKyBkdXBQYXR0ZXJuU3JjICsgXCI8LVwiICtcbiAgICAgICAgICAgICAgICAoXCJoYXMgYmVlbiB1c2VkIGluIGFsbCBvZiB0aGUgZm9sbG93aW5nIFRva2VuIFR5cGVzOiBcIiArIHRva2VuVHlwZU5hbWVzLmpvaW4oXCIsIFwiKSArIFwiIDwtXCIpLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QQVRURVJOU19GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IHNldE9mSWRlbnRpY2FsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW52YWxpZEdyb3VwVHlwZSh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGludmFsaWRUeXBlcyA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKCFoYXMoY2xhenosIFwiR1JPVVBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBjbGF6ei5HUk9VUDtcbiAgICAgICAgcmV0dXJuIGdyb3VwICE9PSBMZXhlci5TS0lQUEVEICYmIGdyb3VwICE9PSBMZXhlci5OQSAmJiAhaXNTdHJpbmcoZ3JvdXApO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZFR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ0dST1VQJyBjYW4gb25seSBiZSBMZXhlci5TS0lQUEVEL0xleGVyLk5BL0EgU3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1vZGVzVGhhdERvTm90RXhpc3QodG9rZW5UeXBlcywgdmFsaWRNb2Rlcykge1xuICAgIHZhciBpbnZhbGlkTW9kZXMgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIHJldHVybiAoY2xhenouUFVTSF9NT0RFICE9PSB1bmRlZmluZWQgJiYgIWNvbnRhaW5zKHZhbGlkTW9kZXMsIGNsYXp6LlBVU0hfTU9ERSkpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZE1vZGVzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB2YXIgbXNnID0gXCJUb2tlbiBUeXBlOiAtPlwiICsgdG9rVHlwZS5uYW1lICsgXCI8LSBzdGF0aWMgJ1BVU0hfTU9ERScgdmFsdWUgY2Fubm90IHJlZmVyIHRvIGEgTGV4ZXIgTW9kZSAtPlwiICsgdG9rVHlwZS5QVVNIX01PREUgKyBcIjwtXCIgK1xuICAgICAgICAgICAgXCJ3aGljaCBkb2VzIG5vdCBleGlzdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFt0b2tUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZFVucmVhY2hhYmxlUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgY2FuQmVUZXN0ZWQgPSByZWR1Y2UodG9rZW5UeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgdG9rVHlwZSwgaWR4KSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdG9rVHlwZS5QQVRURVJOO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gTGV4ZXIuTkEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYSBtb3JlIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiBmb3IgYWxsIGZvcm1zIG9mIHJlZ0V4cHMgd291bGQgcmVxdWlyZVxuICAgICAgICAvLyBkZWVwZXIgcmVnRXhwIGFuYWx5c2lzIGNhcGFiaWxpdGllc1xuICAgICAgICBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc3RyOiBwYXR0ZXJuLCBpZHg6IGlkeCwgdG9rZW5UeXBlOiB0b2tUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pICYmIG5vTWV0YUNoYXIocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc3RyOiBwYXR0ZXJuLnNvdXJjZSwgaWR4OiBpZHgsIHRva2VuVHlwZTogdG9rVHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIGZ1bmN0aW9uICh0b2tUeXBlLCB0ZXN0SWR4KSB7XG4gICAgICAgIGZvckVhY2goY2FuQmVUZXN0ZWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IF9hLnN0ciwgaWR4ID0gX2EuaWR4LCB0b2tlblR5cGUgPSBfYS50b2tlblR5cGU7XG4gICAgICAgICAgICBpZiAodGVzdElkeCA8IGlkeCAmJiB0ZXN0VG9rZW5UeXBlKHN0ciwgdG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlRva2VuOiAtPlwiICsgdG9rZW5UeXBlLm5hbWUgKyBcIjwtIGNhbiBuZXZlciBiZSBtYXRjaGVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiQmVjYXVzZSBpdCBhcHBlYXJzIEFGVEVSIHRoZSBUb2tlbiBUeXBlIC0+XCIgKyB0b2tUeXBlLm5hbWUgKyBcIjwtXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJpbiB0aGUgbGV4ZXIncyBkZWZpbml0aW9uLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5SRUFDSEFCTEVcIjtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOUkVBQ0hBQkxFX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IFt0b2tUeXBlLCB0b2tlblR5cGVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiB0ZXN0VG9rZW5UeXBlKHN0ciwgcGF0dGVybikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgIHZhciByZWdFeHBBcnJheSA9IHBhdHRlcm4uZXhlYyhzdHIpO1xuICAgICAgICByZXR1cm4gcmVnRXhwQXJyYXkgIT09IG51bGwgJiYgcmVnRXhwQXJyYXkuaW5kZXggPT09IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGF0dGVybikpIHtcbiAgICAgICAgLy8gbWFpbnRhaW4gdGhlIEFQSSBvZiBjdXN0b20gcGF0dGVybnNcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4oc3RyLCAwLCBbXSwge30pO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXMocGF0dGVybiwgXCJleGVjXCIpKSB7XG4gICAgICAgIC8vIG1haW50YWluIHRoZSBBUEkgb2YgY3VzdG9tIHBhdHRlcm5zXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLmV4ZWMoc3RyLCAwLCBbXSwge30pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGF0dGVybiA9PT0gc3RyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub01ldGFDaGFyKHJlZ0V4cCkge1xuICAgIC8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwXG4gICAgdmFyIG1ldGFDaGFycyA9IFtcbiAgICAgICAgXCIuXCIsXG4gICAgICAgIFwiXFxcXFwiLFxuICAgICAgICBcIltcIixcbiAgICAgICAgXCJdXCIsXG4gICAgICAgIFwifFwiLFxuICAgICAgICBcIl5cIixcbiAgICAgICAgXCIkXCIsXG4gICAgICAgIFwiKFwiLFxuICAgICAgICBcIilcIixcbiAgICAgICAgXCI/XCIsXG4gICAgICAgIFwiKlwiLFxuICAgICAgICBcIitcIixcbiAgICAgICAgXCJ7XCJcbiAgICBdO1xuICAgIHJldHVybiAoZmluZChtZXRhQ2hhcnMsIGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiByZWdFeHAuc291cmNlLmluZGV4T2YoY2hhcikgIT09IC0xOyB9KSA9PT0gdW5kZWZpbmVkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdGFydE9mSW5wdXQocGF0dGVybikge1xuICAgIHZhciBmbGFncyA9IHBhdHRlcm4uaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIjtcbiAgICAvLyBhbHdheXMgd3JhcHBpbmcgaW4gYSBub25lIGNhcHR1cmluZyBncm91cCBwcmVjZWRlZCBieSAnXicgdG8gbWFrZSBzdXJlIG1hdGNoaW5nIGNhbiBvbmx5IHdvcmsgb24gc3RhcnQgb2YgaW5wdXQuXG4gICAgLy8gZHVwbGljYXRlL3JlZHVuZGFudCBzdGFydCBvZiBpbnB1dCBtYXJrZXJzIGhhdmUgbm8gbWVhbmluZyAoL15eXl5BLyA9PT0gL15BLylcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHBhdHRlcm4uc291cmNlICsgXCIpXCIsIGZsYWdzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdGlja3lGbGFnKHBhdHRlcm4pIHtcbiAgICB2YXIgZmxhZ3MgPSBwYXR0ZXJuLmlnbm9yZUNhc2UgPyBcIml5XCIgOiBcInlcIjtcbiAgICAvLyBhbHdheXMgd3JhcHBpbmcgaW4gYSBub25lIGNhcHR1cmluZyBncm91cCBwcmVjZWRlZCBieSAnXicgdG8gbWFrZSBzdXJlIG1hdGNoaW5nIGNhbiBvbmx5IHdvcmsgb24gc3RhcnQgb2YgaW5wdXQuXG4gICAgLy8gZHVwbGljYXRlL3JlZHVuZGFudCBzdGFydCBvZiBpbnB1dCBtYXJrZXJzIGhhdmUgbm8gbWVhbmluZyAoL15eXl5BLyA9PT0gL15BLylcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgcGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJmb3JtUnVudGltZUNoZWNrcyhsZXhlckRlZmluaXRpb24sIHRyYWNrTGluZXMsIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAvLyBzb21lIHJ1biB0aW1lIGNoZWNrcyB0byBoZWxwIHRoZSBlbmQgdXNlcnMuXG4gICAgaWYgKCFoYXMobGV4ZXJEZWZpbml0aW9uLCBERUZBVUxUX01PREUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIERFRkFVTFRfTU9ERSArXG4gICAgICAgICAgICAgICAgXCI+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXFxuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIiArXG4gICAgICAgICAgICAgICAgTU9ERVMgK1xuICAgICAgICAgICAgICAgIFwiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGhhcyhsZXhlckRlZmluaXRpb24sIE1PREVTKSAmJlxuICAgICAgICBoYXMobGV4ZXJEZWZpbml0aW9uLCBERUZBVUxUX01PREUpICYmXG4gICAgICAgICFoYXMobGV4ZXJEZWZpbml0aW9uLm1vZGVzLCBsZXhlckRlZmluaXRpb24uZGVmYXVsdE1vZGUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGggYSBcIiArIERFRkFVTFRfTU9ERSArIFwiOiA8XCIgKyBsZXhlckRlZmluaXRpb24uZGVmYXVsdE1vZGUgKyBcIj5cIiArXG4gICAgICAgICAgICAgICAgXCJ3aGljaCBkb2VzIG5vdCBleGlzdFxcblwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpKSB7XG4gICAgICAgIGZvckVhY2gobGV4ZXJEZWZpbml0aW9uLm1vZGVzLCBmdW5jdGlvbiAoY3Vyck1vZGVWYWx1ZSwgY3Vyck1vZGVOYW1lKSB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJNb2RlVmFsdWUsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSwgY3VycklkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB1c2luZyBhbiB1bmRlZmluZWQgVG9rZW4gVHlwZS4gTW9kZTpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiPFwiICsgY3Vyck1vZGVOYW1lICsgXCI+IGF0IGluZGV4OiA8XCIgKyBjdXJySWR4ICsgXCI+XFxuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MobGV4ZXJEZWZpbml0aW9uLCB0cmFja0xpbmVzLCBsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICB2YXIgaGFzQW55TGluZUJyZWFrID0gZmFsc2U7XG4gICAgdmFyIGFsbFRva2VuVHlwZXMgPSBjb21wYWN0KGZsYXR0ZW4obWFwVmFsdWVzKGxleGVyRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKHRva1R5cGVzKSB7IHJldHVybiB0b2tUeXBlczsgfSkpKTtcbiAgICB2YXIgY29uY3JldGVUb2tlblR5cGVzID0gcmVqZWN0KGFsbFRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkgeyByZXR1cm4gY3VyclR5cGVbUEFUVEVSTl0gPT09IExleGVyLk5BOyB9KTtcbiAgICB2YXIgdGVybWluYXRvckNoYXJDb2RlcyA9IGdldENoYXJDb2RlcyhsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpO1xuICAgIGlmICh0cmFja0xpbmVzKSB7XG4gICAgICAgIGZvckVhY2goY29uY3JldGVUb2tlblR5cGVzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJJc3N1ZSA9IGNoZWNrTGluZUJyZWFrc0lzc3Vlcyh0b2tUeXBlLCB0ZXJtaW5hdG9yQ2hhckNvZGVzKTtcbiAgICAgICAgICAgIGlmIChjdXJySXNzdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZSh0b2tUeXBlLCBjdXJySXNzdWUpO1xuICAgICAgICAgICAgICAgIHZhciB3YXJuaW5nRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY3Vycklzc3VlLmlzc3VlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHRva1R5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2god2FybmluZ0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhdHRlbXB0IHRvIHNjYW4gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBzcGVjaWZpZWQgdGhlIGxpbmVfYnJlYWtzIG9wdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva1R5cGUuTElORV9CUkVBS1MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FueUxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5NYXRjaENoYXJDb2RlKHRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FueUxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHJhY2tMaW5lcyAmJiAhaGFzQW55TGluZUJyZWFrKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJXYXJuaW5nOiBObyBMSU5FX0JSRUFLUyBGb3VuZC5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRUaGlzIExleGVyIGhhcyBiZWVuIGRlZmluZWQgdG8gdHJhY2sgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uLFxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdEJ1dCBub25lIG9mIHRoZSBUb2tlbiBUeXBlcyBjYW4gYmUgaWRlbnRpZmllZCBhcyBtYXRjaGluZyBhIGxpbmUgdGVybWluYXRvci5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjTElORV9CUkVBS1MgXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTElORV9CUkVBS1NfRkxBR1NcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3YXJuaW5ncztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVtcHR5R3JvdXBzKGVtcHR5R3JvdXBzKSB7XG4gICAgdmFyIGNsb25lZFJlc3VsdCA9IHt9O1xuICAgIHZhciBncm91cEtleXMgPSBrZXlzKGVtcHR5R3JvdXBzKTtcbiAgICBmb3JFYWNoKGdyb3VwS2V5cywgZnVuY3Rpb24gKGN1cnJLZXkpIHtcbiAgICAgICAgdmFyIGN1cnJHcm91cFZhbHVlID0gZW1wdHlHcm91cHNbY3VycktleV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0FycmF5KGN1cnJHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgY2xvbmVkUmVzdWx0W2N1cnJLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lZFJlc3VsdDtcbn1cbi8vIFRPRE86IHJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG5leHBvcnQgZnVuY3Rpb24gaXNDdXN0b21QYXR0ZXJuKHRva2VuVHlwZSkge1xuICAgIHZhciBwYXR0ZXJuID0gdG9rZW5UeXBlLlBBVFRFUk47XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBhdHRlcm4pKSB7XG4gICAgICAgIC8vIEN1c3RvbVBhdHRlcm5NYXRjaGVyRnVuYyAtIGN1c3RvbSBwYXR0ZXJucyBkbyBub3QgcmVxdWlyZSBhbnkgdHJhbnNmb3JtYXRpb25zLCBvbmx5IHdyYXBwaW5nIGluIGEgUmVnRXhwIExpa2Ugb2JqZWN0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXMocGF0dGVybiwgXCJleGVjXCIpKSB7XG4gICAgICAgIC8vIElDdXN0b21QYXR0ZXJuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Nob3J0UGF0dGVybihwYXR0ZXJuKSB7XG4gICAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBGYXN0ZXIgdGhhbiB1c2luZyBhIFJlZ0V4cCBmb3IgZGVmYXVsdCBuZXdsaW5lIGRldGVjdGlvbiBkdXJpbmcgbGV4aW5nLlxuICovXG5leHBvcnQgdmFyIExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyID0ge1xuICAgIC8vIGltcGxlbWVudHMgL1xcbnxcXHJcXG4/L2cudGVzdFxuICAgIHRlc3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGFzdEluZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBsYXN0SW5kZXg6IDBcbn07XG5mdW5jdGlvbiBjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMpIHtcbiAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBkZWNsYXJlZCB0aGUgbGluZV9icmVha3Mgb3B0aW9uIHdlIHdpbGwgcmVzcGVjdCB0aGVpciBjaG9pY2VcbiAgICAgICAgLy8gYW5kIGFzc3VtZSBpdCBpcyBjb3JyZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNSZWdFeHAodG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW5NYXRjaENoYXJDb2RlKGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzLCB0b2tUeXBlLlBBVFRFUk4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHRvIHRlc3QgdGhpcyB3ZSB3b3VsZCBoYXZlIHRvIG1vY2sgPGNhbk1hdGNoQ2hhckNvZGU+IHRvIHRocm93IGFuIGVycm9yICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SLFxuICAgICAgICAgICAgICAgICAgICBlcnJNc2c6IGUubWVzc2FnZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwgcGF0dGVybnMgY2FuIGFsd2F5cyBiZSBhbmFseXplZCB0byBkZXRlY3QgbGluZSB0ZXJtaW5hdG9yIHVzYWdlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDdXN0b21QYXR0ZXJuKHRva1R5cGUpKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gdG9rZW4gdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB7IGlzc3VlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2UodG9rVHlwZSwgZGV0YWlscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGRldGFpbHMuaXNzdWUgPT09IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SKSB7XG4gICAgICAgIHJldHVybiAoXCJXYXJuaW5nOiB1bmFibGUgdG8gaWRlbnRpZnkgbGluZSB0ZXJtaW5hdG9yIHVzYWdlIGluIHBhdHRlcm4uXFxuXCIgK1xuICAgICAgICAgICAgKFwiXFx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDxcIiArIHRva1R5cGUubmFtZSArIFwiPiBUb2tlbiBUeXBlXFxuXCIpICtcbiAgICAgICAgICAgIChcIlxcdCBSb290IGNhdXNlOiBcIiArIGRldGFpbHMuZXJyTXNnICsgXCIuXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNJREVOVElGWV9URVJNSU5BVE9SXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXRhaWxzLmlzc3VlID09PSBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUspIHtcbiAgICAgICAgcmV0dXJuIChcIldhcm5pbmc6IEEgQ3VzdG9tIFRva2VuIFBhdHRlcm4gc2hvdWxkIHNwZWNpZnkgdGhlIDxsaW5lX2JyZWFrcz4gb3B0aW9uLlxcblwiICtcbiAgICAgICAgICAgIChcIlxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8XCIgKyB0b2tUeXBlLm5hbWUgKyBcIj4gVG9rZW4gVHlwZVxcblwiKSArXG4gICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ1VTVE9NX0xJTkVfQlJFQUtcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoYXJDb2RlcyhjaGFyc09yQ29kZXMpIHtcbiAgICB2YXIgY2hhckNvZGVzID0gbWFwKGNoYXJzT3JDb2RlcywgZnVuY3Rpb24gKG51bU9yU3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhudW1PclN0cmluZykgJiYgbnVtT3JTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bU9yU3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtT3JTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2hhckNvZGVzO1xufVxuZnVuY3Rpb24gYWRkVG9NYXBPZkFycmF5cyhtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAobWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXBba2V5XSA9IFt2YWx1ZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgdmFyIG1pbk9wdGltaXphdGlvblZhbCA9IDI1Njtcbi8qKlxuICogV2UgYWUgbWFwcGluZyBjaGFyQ29kZSBhYm92ZSBBU0NJICgyNTYpIGludG8gYnVja2V0cyBlYWNoIGluIHRoZSBzaXplIG9mIDI1Ni5cbiAqIFRoaXMgaXMgYmVjYXVzZSBBU0NJIGFyZSB0aGUgbW9zdCBjb21tb24gc3RhcnQgY2hhcnMgc28gZWFjaCBvbmUgb2YgdGhvc2Ugd2lsbCBnZXQgaXRzIG93blxuICogcG9zc2libGUgdG9rZW4gY29uZmlncyB2ZWN0b3IuXG4gKlxuICogVG9rZW5zIHN0YXJ0aW5nIHdpdGggY2hhckNvZGVzIFwiYWJvdmVcIiBBU0NJIGFyZSB1bmNvbW1vbiwgc28gd2UgY2FuIFwiYWZmb3JkXCJcbiAqIHRvIHBsYWNlIHRoZXNlIGludG8gYnVja2V0cyBvZiBwb3NzaWJsZSB0b2tlbiBjb25maWdzLCBXaGF0IHdlIGdhaW4gZnJvbVxuICogdGhpcyBpcyBhdm9pZGluZyB0aGUgY2FzZSBvZiBjcmVhdGluZyBhbiBvcHRpbWl6YXRpb24gJ2NoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcnXG4gKiB3aGljaCB3b3VsZCBjb250YWluIDEwLDAwMCsgYXJyYXlzIG9mIHNtYWxsIHNpemUgKGUuZyB1bmljb2RlIElkZW50aWZpZXJzIHNjZW5hcmlvKS5cbiAqIE91ciAnY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZycgbWF4IHNpemUgd2lsbCBub3cgYmU6XG4gKiAyNTYgKyAoMl4xNiAvIDJeOCkgLSAxID09PSA1MTFcbiAqXG4gKiBub3RlIHRoZSBoYWNrIGZvciBmYXN0IGRpdmlzaW9uIGludGVnZXIgcGFydCBleHRyYWN0aW9uXG4gKiBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MjI4NTI4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPCBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgPyBjaGFyQ29kZVxuICAgICAgICA6IGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXBbY2hhckNvZGVdO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgY29tcHJvbWlzZSBiZXR3ZWVuIGNvbGQgc3RhcnQgLyBob3QgcnVubmluZyBwZXJmb3JtYW5jZVxuICogQ3JlYXRpbmcgdGhpcyBhcnJheSB0YWtlcyB+M21zIG9uIGEgbW9kZXJuIG1hY2hpbmUsXG4gKiBCdXQgaWYgd2UgcGVyZm9ybSB0aGUgY29tcHV0YXRpb24gYXQgcnVudGltZSBhcyBuZWVkZWQgdGhlIENTUyBMZXhlciBiZW5jaG1hcmtcbiAqIHBlcmZvcm1hbmNlIGRlZ3JhZGVzIGJ5IH4xMCVcbiAqXG4gKiBUT0RPOiBQZXJoYXBzIGl0IHNob3VsZCBiZSBsYXp5IGluaXRpYWxpemVkIG9ubHkgaWYgYSBjaGFyQ29kZSA+IDI1NSBpcyB1c2VkLlxuICovXG52YXIgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IFtdO1xuZnVuY3Rpb24gaW5pdENoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleE1hcCgpIHtcbiAgICBpZiAoaXNFbXB0eShjaGFyQ29kZVRvT3B0aW1pemVkSWR4TWFwKSkge1xuICAgICAgICBjaGFyQ29kZVRvT3B0aW1pemVkSWR4TWFwID0gbmV3IEFycmF5KDY1NTM2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgICAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcFtpXSA9IGkgPiAyNTUgPyAyNTUgKyB+fihpIC8gMjU1KSA6IGk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultLexerErrorProvider: () => (/* binding */ defaultLexerErrorProvider)\n/* harmony export */ });\nvar defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage: function (token) {\n        return \"Unable to pop Lexer Mode after encountering Token ->\" + token.image + \"<- The Mode Stack is empty\";\n    },\n    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {\n        return (\"unexpected character: ->\" + fullText.charAt(startOffset) + \"<- at offset: \" + startOffset + \",\" + (\" skipped \" + length + \" characters.\"));\n    }\n};\n//# sourceMappingURL=lexer_errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHNjYW5cXGxleGVyX2Vycm9yc19wdWJsaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIHBvcCBMZXhlciBNb2RlIGFmdGVyIGVuY291bnRlcmluZyBUb2tlbiAtPlwiICsgdG9rZW4uaW1hZ2UgKyBcIjwtIFRoZSBNb2RlIFN0YWNrIGlzIGVtcHR5XCI7XG4gICAgfSxcbiAgICBidWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZTogZnVuY3Rpb24gKGZ1bGxUZXh0LCBzdGFydE9mZnNldCwgbGVuZ3RoLCBsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIChcInVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAtPlwiICsgZnVsbFRleHQuY2hhckF0KHN0YXJ0T2Zmc2V0KSArIFwiPC0gYXQgb2Zmc2V0OiBcIiArIHN0YXJ0T2Zmc2V0ICsgXCIsXCIgKyAoXCIgc2tpcHBlZCBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfZXJyb3JzX3B1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lexer: () => (/* binding */ Lexer),\n/* harmony export */   LexerDefinitionErrorType: () => (/* binding */ LexerDefinitionErrorType)\n/* harmony export */ });\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scan/lexer_errors_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\n\n\n\n\n\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        var _this = this;\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.config = undefined;\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.merge)(DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = _lexer__WEBPACK_IMPORTED_MODULE_0__.LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(lexerDefinition)) {\n                    actualDefinition = { modes: {} };\n                    actualDefinition.modes[_lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE] = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(lexerDefinition);\n                    actualDefinition[_lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE] = _lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE;\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneObj)(lexerDefinition);\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reject)(currModeValue, function (currTokType) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(currTokType); });\n            });\n            var allModeNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.keys)(actualDefinition.modes);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.validatePatterns)(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(_this.lexerDefinitionErrors)) {\n                        (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.analyzeTokenTypes)(currModDef, {\n                                lineTerminatorCharacters: _this.config\n                                    .lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT.bind(_this)\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.merge)(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (_lexer__WEBPACK_IMPORTED_MODULE_0__.SUPPORT_STICKY) {\n                    _this.chopInput = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.IDENTITY;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.IDENTITY;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reduce)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.clearRegExpParserCache)();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.toFastProperties)(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.lexerDefinitionErrors)) {\n            var allErrMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        var lexResult = this.tokenizeInternal(text, initialMode);\n        return lexResult;\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.cloneEmptyGroups)(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns = undefined;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.charCodeToOptimizedIndex)(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n                    column: popToken.startColumn !== undefined\n                        ? popToken.startColumn\n                        : undefined,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.last)(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAltIdx = currConfig.longerAlt;\n                    if (longerAltIdx !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltConfig = patternIdxToConfig[longerAltIdx];\n                        var longerAltPattern = longerAltConfig.pattern;\n                        altPayload = null;\n                        // single Char can never be a longer alt so no need to test it.\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        if (longerAltConfig.isCustom === true) {\n                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                            if (match !== null) {\n                                matchAltImage = match[0];\n                                if (match.payload !== undefined) {\n                                    altPayload = match.payload;\n                                }\n                            }\n                            else {\n                                matchAltImage = null;\n                            }\n                        }\n                        else {\n                            this.updateLastIndex(longerAltPattern, offset);\n                            matchAltImage = this.match(longerAltPattern, text, offset);\n                        }\n                        if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                            matchedImage = matchAltImage;\n                            payload = altPayload;\n                            currConfig = longerAltConfig;\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !==\n                                    null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.createTokenInstance = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return null;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n        return 666;\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.handlePayload = function (token, payload) { };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n    Lexer.prototype.match = function (pattern, text, offset) {\n        return null;\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : regExpArray;\n    };\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.timer)(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\n\n//# sourceMappingURL=lexer_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vbGV4ZXJfcHVibGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBME47QUFDOUI7QUFDL0k7QUFDMkI7QUFDZDtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdGQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUVBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQU87QUFDM0IseUNBQXlDO0FBQ3pDLDJDQUEyQyxnREFBWSxJQUFJLHNEQUFRO0FBQ25FLHFDQUFxQyxnREFBWSxJQUFJLGdEQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFRO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxRkFBcUYsNERBQW9CO0FBQ3pHLGlCQUFpQjtBQUNqQjtBQUNBLHVGQUF1RixtRUFBMkI7QUFDbEgsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBTztBQUNuQix1REFBdUQsb0RBQU0seUNBQXlDLE9BQU8seURBQVcsZ0JBQWdCO0FBQ3hJLGFBQWE7QUFDYiwrQkFBK0Isa0RBQUk7QUFDbkMsWUFBWSxxREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Rix3REFBZ0I7QUFDN0cseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFPO0FBQy9CLHdCQUF3QiwwREFBaUI7QUFDekM7QUFDQTtBQUNBLGtEQUFrRCx5REFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtREFBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxpQkFBaUIscURBQU87QUFDeEI7QUFDQSxxQ0FBcUMsaURBQUc7QUFDeEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CLGdCQUFnQiwyREFBYTtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWM7QUFDbEMsc0NBQXNDLGtEQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4Q0FBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQUk7QUFDNUM7QUFDQTtBQUNBLDZDQUE2QyxrREFBUTtBQUNyRDtBQUNBO0FBQ0EsNkRBQTZELDhDQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxvREFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtREFBbUQscURBQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsdUVBQXNCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiw4REFBZ0I7QUFDaEMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLGFBQWEscURBQU87QUFDcEIsaUNBQWlDLGlEQUFHO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnQjtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xcc2NhblxcbGV4ZXJfcHVibGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFuYWx5emVUb2tlblR5cGVzLCBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgsIGNsb25lRW1wdHlHcm91cHMsIERFRkFVTFRfTU9ERSwgTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXIsIHBlcmZvcm1SdW50aW1lQ2hlY2tzLCBwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MsIFNVUFBPUlRfU1RJQ0tZLCB2YWxpZGF0ZVBhdHRlcm5zIH0gZnJvbSBcIi4vbGV4ZXJcIjtcbmltcG9ydCB7IGNsb25lQXJyLCBjbG9uZU9iaiwgZm9yRWFjaCwgSURFTlRJVFksIGlzQXJyYXksIGlzRW1wdHksIGlzVW5kZWZpbmVkLCBrZXlzLCBsYXN0LCBtYXAsIG1lcmdlLCBOT09QLCBQUklOVF9XQVJOSU5HLCByZWR1Y2UsIHJlamVjdCwgdGltZXIsIHRvRmFzdFByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzIH0gZnJvbSBcIi4vdG9rZW5zXCI7XG5pbXBvcnQgeyBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4uL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpY1wiO1xuaW1wb3J0IHsgY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSB9IGZyb20gXCIuL3JlZ19leHBfcGFyc2VyXCI7XG5leHBvcnQgdmFyIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZTtcbihmdW5jdGlvbiAoTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1JU1NJTkdfUEFUVEVSTlwiXSA9IDBdID0gXCJNSVNTSU5HX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9QQVRURVJOXCJdID0gMV0gPSBcIklOVkFMSURfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJFT0lfQU5DSE9SX0ZPVU5EXCJdID0gMl0gPSBcIkVPSV9BTkNIT1JfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIl0gPSAzXSA9IFwiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EXCJdID0gNF0gPSBcIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX0dST1VQX1RZUEVfRk9VTkRcIl0gPSA1XSA9IFwiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVFwiXSA9IDZdID0gXCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiXSA9IDddID0gXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVwiXSA9IDhdID0gXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIl0gPSA5XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIl0gPSAxMF0gPSBcIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlNPSV9BTkNIT1JfRk9VTkRcIl0gPSAxMV0gPSBcIlNPSV9BTkNIT1JfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiXSA9IDEyXSA9IFwiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT19MSU5FX0JSRUFLU19GTEFHU1wiXSA9IDEzXSA9IFwiTk9fTElORV9CUkVBS1NfRkxBR1NcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5SRUFDSEFCTEVfUEFUVEVSTlwiXSA9IDE0XSA9IFwiVU5SRUFDSEFCTEVfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJJREVOVElGWV9URVJNSU5BVE9SXCJdID0gMTVdID0gXCJJREVOVElGWV9URVJNSU5BVE9SXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNVU1RPTV9MSU5FX0JSRUFLXCJdID0gMTZdID0gXCJDVVNUT01fTElORV9CUkVBS1wiO1xufSkoTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIHx8IChMZXhlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xudmFyIERFRkFVTFRfTEVYRVJfQ09ORklHID0ge1xuICAgIGRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nOiBmYWxzZSxcbiAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICBsaW5lVGVybWluYXRvcnNQYXR0ZXJuOiAvXFxufFxcclxcbj8vZyxcbiAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IFtcIlxcblwiLCBcIlxcclwiXSxcbiAgICBlbnN1cmVPcHRpbWl6YXRpb25zOiBmYWxzZSxcbiAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIsXG4gICAgdHJhY2VJbml0UGVyZjogZmFsc2UsXG4gICAgc2tpcFZhbGlkYXRpb25zOiBmYWxzZVxufTtcbk9iamVjdC5mcmVlemUoREVGQVVMVF9MRVhFUl9DT05GSUcpO1xudmFyIExleGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyKGxleGVyRGVmaW5pdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBERUZBVUxUX0xFWEVSX0NPTkZJRzsgfVxuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbiA9IGxleGVyRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nID0gW107XG4gICAgICAgIHRoaXMucGF0dGVybklkeFRvQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IHt9O1xuICAgICAgICB0aGlzLm1vZGVzID0gW107XG4gICAgICAgIHRoaXMuZW1wdHlHcm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudHJhY2tTdGFydExpbmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFja0VuZExpbmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b20gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExleGVyIGNvbnN0cnVjdG9yIGlzIG5vdyBhbiBJTGV4ZXJDb25maWcgT2JqZWN0LlxcblwiICtcbiAgICAgICAgICAgICAgICBcImEgYm9vbGVhbiAybmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBkZWZhdWx0cyBmdW5jP1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG1lcmdlKERFRkFVTFRfTEVYRVJfQ09ORklHLCBjb25maWcpO1xuICAgICAgICB2YXIgdHJhY2VJbml0VmFsID0gdGhpcy5jb25maWcudHJhY2VJbml0UGVyZjtcbiAgICAgICAgaWYgKHRyYWNlSW5pdFZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHJhY2VJbml0VmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gdHJhY2VJbml0VmFsO1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25zdHJ1Y3RvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIHZhciBoYXNPbmx5U2luZ2xlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiTGV4ZXIgQ29uZmlnIGhhbmRsaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4gPT09XG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfTEVYRVJfQ09ORklHLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIGJ1aWx0LWluIGltcGxlbWVudGF0aW9uIGZvciB0aGUgZGVmYXVsdHMgZGVmaW5pdGlvbiBvZiBsaW5lVGVybWluYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4gPSBMaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9MRVhFUl9DT05GSUcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkVycm9yOiBNaXNzaW5nIDxsaW5lVGVybWluYXRvckNoYXJhY3RlcnM+IHByb3BlcnR5IG9uIHRoZSBMZXhlciBjb25maWcuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNNSVNTSU5HX0xJTkVfVEVSTV9DSEFSU1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNhZmVNb2RlICYmIGNvbmZpZy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdcInNhZmVNb2RlXCIgYW5kIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrU3RhcnRMaW5lcyA9IC9mdWxsfG9ubHlTdGFydC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrRW5kTGluZXMgPSAvZnVsbC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgU2luZ2xlTW9kZUxleGVyRGVmaW5pdGlvbiBpbnRvIGEgSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShsZXhlckRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24gPSB7IG1vZGVzOiB7fSB9O1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uLm1vZGVzW0RFRkFVTFRfTU9ERV0gPSBjbG9uZUFycihsZXhlckRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uW0RFRkFVTFRfTU9ERV0gPSBERUZBVUxUX01PREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb252ZXJzaW9uIG5lZWRlZCwgaW5wdXQgc2hvdWxkIGFscmVhZHkgYmUgYSBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgIGhhc09ubHlTaW5nbGVNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24gPSBjbG9uZU9iaihsZXhlckRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1SdW50aW1lQ2hlY2tzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChwZXJmb3JtUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCBfdGhpcy50cmFja1N0YXJ0TGluZXMsIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyA9IF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcuY29uY2F0KHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCBfdGhpcy50cmFja1N0YXJ0TGluZXMsIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBleHRyYSByb2J1c3RuZXNzIHRvIGF2b2lkIHRocm93aW5nIGFuIG5vbmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbi5tb2RlcyA9IGFjdHVhbERlZmluaXRpb24ubW9kZXNcbiAgICAgICAgICAgICAgICA/IGFjdHVhbERlZmluaXRpb24ubW9kZXNcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgLy8gYW4gZXJyb3Igb2YgdW5kZWZpbmVkIFRva2VuVHlwZXMgd2lsbCBiZSBkZXRlY3RlZCBpbiBcInBlcmZvcm1SdW50aW1lQ2hlY2tzXCIgYWJvdmUuXG4gICAgICAgICAgICAvLyB0aGlzIHRyYW5zZm9ybWF0aW9uIGlzIHRvIGluY3JlYXNlIHJvYnVzdG5lc3MgaW4gdGhlIGNhc2Ugb2YgcGFydGlhbGx5IGludmFsaWQgbGV4ZXIgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIGZvckVhY2goYWN0dWFsRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKGN1cnJNb2RlVmFsdWUsIGN1cnJNb2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXNbY3Vyck1vZGVOYW1lXSA9IHJlamVjdChjdXJyTW9kZVZhbHVlLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHsgcmV0dXJuIGlzVW5kZWZpbmVkKGN1cnJUb2tUeXBlKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxNb2RlTmFtZXMgPSBrZXlzKGFjdHVhbERlZmluaXRpb24ubW9kZXMpO1xuICAgICAgICAgICAgZm9yRWFjaChhY3R1YWxEZWZpbml0aW9uLm1vZGVzLCBmdW5jdGlvbiAoY3Vyck1vZERlZiwgY3Vyck1vZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiTW9kZTogPFwiICsgY3Vyck1vZE5hbWUgKyBcIj4gcHJvY2Vzc2luZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVzLnB1c2goY3Vyck1vZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJ2YWxpZGF0ZVBhdHRlcm5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KHZhbGlkYXRlUGF0dGVybnMoY3Vyck1vZERlZiwgYWxsTW9kZU5hbWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWZpbml0aW9uIGVycm9ycyB3ZXJlIGVuY291bnRlcmVkLCB0aGUgYW5hbHlzaXMgcGhhc2UgbWF5IGZhaWwgdW5leHBlY3RlZGx5L1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBhIGxleGVyIHdpdGggZGVmaW5pdGlvbiBlcnJvcnMgbWF5IG5ldmVyIGJlIHVzZWQsIHRoZXJlIGlzIG5vIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHBlcmZvcm1pbmcgdGhlIGFuYWx5c2lzIGFueWhvdy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWdtZW50VG9rZW5UeXBlcyhjdXJyTW9kRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyQW5hbHl6ZVJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImFuYWx5emVUb2tlblR5cGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xID0gYW5hbHl6ZVRva2VuVHlwZXMoY3Vyck1vZERlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IF90aGlzLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25UcmFja2luZzogY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuc3VyZU9wdGltaXphdGlvbnM6IGNvbmZpZy5lbnN1cmVPcHRpbWl6YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWZlTW9kZTogY29uZmlnLnNhZmVNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXI6IF90aGlzLlRSQUNFX0lOSVQuYmluZChfdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF0dGVybklkeFRvQ29uZmlnW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMS5wYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMS5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1wdHlHcm91cHMgPSBtZXJnZShfdGhpcy5lbXB0eUdyb3VwcywgY3VyckFuYWx5emVSZXN1bHRfMS5lbXB0eUdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYXNDdXN0b20gPSBjdXJyQW5hbHl6ZVJlc3VsdF8xLmhhc0N1c3RvbSB8fCBfdGhpcy5oYXNDdXN0b207XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xLmNhbkJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmRlZmF1bHRNb2RlID0gYWN0dWFsRGVmaW5pdGlvbi5kZWZhdWx0TW9kZTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLmNvbmZpZy5kZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlcyA9IG1hcChfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsRXJyTWVzc2FnZXNTdHJpbmcgPSBhbGxFcnJNZXNzYWdlcy5qb2luKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIgKyBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHByaW50IHdhcm5pbmcgaWYgdGhlcmUgYXJlIG5vIGVycm9ycywgVGhpcyB3aWxsIGF2b2lkIHBsXG4gICAgICAgICAgICBmb3JFYWNoKF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcsIGZ1bmN0aW9uICh3YXJuaW5nRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIFBSSU5UX1dBUk5JTkcod2FybmluZ0Rlc2NyaXB0b3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDaG9vc2luZyBzdWItbWV0aG9kcyBpbXBsZW1lbnRhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgcmVsZXZhbnQgaW50ZXJuYWwgaW1wbGVtZW50YXRpb25zIGZvciB0aGlzIHNwZWNpZmljIHBhcnNlci5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGJlIGluLWxpbmVkIGJ5IHRoZSBKYXZhU2NyaXB0IGVuZ2luZVxuICAgICAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgb3B0aW1hbCBwZXJmb3JtYW5jZSBpbiBlYWNoIHNjZW5hcmlvLlxuICAgICAgICAgICAgICAgIGlmIChTVVBQT1JUX1NUSUNLWSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaG9wSW5wdXQgPSBJREVOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0Y2ggPSBfdGhpcy5tYXRjaFdpdGhUZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTGFzdEluZGV4ID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0Y2ggPSBfdGhpcy5tYXRjaFdpdGhFeGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzT25seVNpbmdsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9kZXMgPSBOT09QO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhY2tTdGFydExpbmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTmV3Q29sdW1uID0gSURFTlRJVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFja0VuZExpbmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvZnVsbC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBfdGhpcy5jcmVhdGVGdWxsVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5U3RhcnQvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gX3RoaXMuY3JlYXRlU3RhcnRPbmx5VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5T2Zmc2V0L2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IF90aGlzLmNyZWF0ZU9mZnNldE9ubHlUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXFxcIlwiICsgX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oYXNDdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkVG9rZW4gPSBfdGhpcy5hZGRUb2tlblVzaW5nUHVzaDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGF5bG9hZCA9IF90aGlzLmhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkVG9rZW4gPSBfdGhpcy5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYXlsb2FkID0gX3RoaXMuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkZhaWxlZCBPcHRpbWl6YXRpb24gV2FybmluZ3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB1bk9wdGltaXplZE1vZGVzID0gcmVkdWNlKF90aGlzLmNhbk1vZGVCZU9wdGltaXplZCwgZnVuY3Rpb24gKGNhbm5vdEJlT3B0aW1pemVkLCBjYW5CZU9wdGltaXplZCwgbW9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkJlT3B0aW1pemVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Fubm90QmVPcHRpbWl6ZWQucHVzaChtb2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbm5vdEJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMgJiYgIWlzRW1wdHkodW5PcHRpbWl6ZWRNb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJMZXhlciBNb2RlczogPCBcIiArIHVuT3B0aW1pemVkTW9kZXMuam9pbihcIiwgXCIpICsgXCIgPiBjYW5ub3QgYmUgb3B0aW1pemVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXHQgRGlzYWJsZSB0aGUgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgbGV4ZXIgY29uZmlnIGZsYWcgdG8gc2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIHJ1biB0aGUgbGV4ZXIgaW4gYW4gdW4tb3B0aW1pemVkIG1vZGUuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdCBPciBpbnNwZWN0IHRoZSBjb25zb2xlIGxvZyBmb3IgZGV0YWlscyBvbiBob3cgdG8gcmVzb2x2ZSB0aGVzZSBpc3N1ZXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImNsZWFyUmVnRXhwUGFyc2VyQ2FjaGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BlcnRpZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRvRmFzdFByb3BlcnRpZXMoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgaWYgKGluaXRpYWxNb2RlID09PSB2b2lkIDApIHsgaW5pdGlhbE1vZGUgPSB0aGlzLmRlZmF1bHRNb2RlOyB9XG4gICAgICAgIGlmICghaXNFbXB0eSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlcyA9IG1hcCh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBUb2tlbml6ZSBiZWNhdXNlIEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiICtcbiAgICAgICAgICAgICAgICBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxleFJlc3VsdCA9IHRoaXMudG9rZW5pemVJbnRlcm5hbCh0ZXh0LCBpbml0aWFsTW9kZSk7XG4gICAgICAgIHJldHVybiBsZXhSZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBpcyBxdWl0ZSBhIGJpdCBvZiBkdXBsaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIFwidG9rZW5pemVJbnRlcm5hbExhenlcIlxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgZHVlIHRvIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb25zLlxuICAgIExleGVyLnByb3RvdHlwZS50b2tlbml6ZUludGVybmFsID0gZnVuY3Rpb24gKHRleHQsIGluaXRpYWxNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpLCBqLCBtYXRjaEFsdEltYWdlLCBsb25nZXJBbHRJZHgsIG1hdGNoZWRJbWFnZSwgcGF5bG9hZCwgYWx0UGF5bG9hZCwgaW1hZ2VMZW5ndGgsIGdyb3VwLCB0b2tUeXBlLCBuZXdUb2tlbiwgZXJyTGVuZ3RoLCBkcm9wcGVkQ2hhciwgbXNnLCBtYXRjaDtcbiAgICAgICAgdmFyIG9yZ1RleHQgPSB0ZXh0O1xuICAgICAgICB2YXIgb3JnTGVuZ3RoID0gb3JnVGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF0Y2hlZFRva2Vuc0luZGV4ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSB0b2tlbnNBcnJheSB0byB0aGUgXCJndWVzc2VkXCIgc2l6ZS5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxpdHRsZSB3aWxsIHN0aWxsIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGFycmF5IHJlLXNpemVzIG9uIHB1c2hlcy5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxhcmdlIChUZXN0ZWQgYnkgZ3Vlc3NpbmcgeDQgdG9vIGxhcmdlKSBtYXkgY29zdCBhIGJpdCBtb3JlIG9mIG1lbW9yeVxuICAgICAgICAvLyBidXQgd291bGQgc3RpbGwgaGF2ZSBhIGZhc3RlciBydW50aW1lIGJ5IGF2b2lkaW5nIChBbGwgYnV0IG9uZSkgYXJyYXkgcmVzaXppbmcuXG4gICAgICAgIHZhciBndWVzc2VkTnVtYmVyT2ZUb2tlbnMgPSB0aGlzLmhhc0N1c3RvbVxuICAgICAgICAgICAgPyAwIC8vIHdpbGwgYnJlYWsgY3VzdG9tIHRva2VuIHBhdHRlcm4gQVBJcyB0aGUgbWF0Y2hlZFRva2VucyBhcnJheSB3aWxsIGNvbnRhaW4gdW5kZWZpbmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoIC8gMTApO1xuICAgICAgICB2YXIgbWF0Y2hlZFRva2VucyA9IG5ldyBBcnJheShndWVzc2VkTnVtYmVyT2ZUb2tlbnMpO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZ3JvdXBzID0gY2xvbmVFbXB0eUdyb3Vwcyh0aGlzLmVtcHR5R3JvdXBzKTtcbiAgICAgICAgdmFyIHRyYWNrTGluZXMgPSB0aGlzLnRyYWNrU3RhcnRMaW5lcztcbiAgICAgICAgdmFyIGxpbmVUZXJtaW5hdG9yUGF0dGVybiA9IHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm47XG4gICAgICAgIHZhciBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHBhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgICAgICB2YXIgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICAgICAgdmFyIG1vZGVTdGFjayA9IFtdO1xuICAgICAgICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICAgICAgICBPYmplY3QuZnJlZXplKGVtcHR5QXJyYXkpO1xuICAgICAgICB2YXIgZ2V0UG9zc2libGVQYXR0ZXJucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3coKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKTtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZVBhdHRlcm5zID0gY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbb3B0aW1pemVkQ2hhcklkeF07XG4gICAgICAgICAgICBpZiAocG9zc2libGVQYXR0ZXJucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQYXR0ZXJucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9wX21vZGUgPSBmdW5jdGlvbiAocG9wVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHBlcmhhcHMgYXZvaWQgdGhpcyBlcnJvciBpbiB0aGUgZWRnZSBjYXNlIHRoZXJlIGlzIG5vIG1vcmUgaW5wdXQ/XG4gICAgICAgICAgICBpZiAobW9kZVN0YWNrLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYm90aCBhIFBPUF9NT0RFIGFuZCBhIFBVU0hfTU9ERSB0aGlzIGlzIGluLWZhY3QgYSBcInRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgIC8vIFNvIG5vIGVycm9yIHNob3VsZCBvY2N1ci5cbiAgICAgICAgICAgICAgICBwb3BUb2tlbi50b2tlblR5cGUuUFVTSF9NT0RFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSB0cnkgdG8gcG9wIHRoZSBsYXN0IG1vZGUgdGhlcmUgbGV4ZXIgd2lsbCBubyBsb25nZXIgaGF2ZSBBTlkgbW9kZS5cbiAgICAgICAgICAgICAgICAvLyB0aHVzIHRoZSBwb3AgaXMgaWdub3JlZCwgYW4gZXJyb3Igd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgbGV4ZXIgd2lsbCBjb250aW51ZSBwYXJzaW5nIGluIHRoZSBwcmV2aW91cyBtb2RlLlxuICAgICAgICAgICAgICAgIHZhciBtc2dfMSA9IF90aGlzLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZShwb3BUb2tlbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvcFRva2VuLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBwb3BUb2tlbi5zdGFydExpbmUgIT09IHVuZGVmaW5lZCA/IHBvcFRva2VuLnN0YXJ0TGluZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBwb3BUb2tlbi5zdGFydENvbHVtbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBvcFRva2VuLnN0YXJ0Q29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBwb3BUb2tlbi5pbWFnZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ18xXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld01vZGUgPSBsYXN0KG1vZGVTdGFjayk7XG4gICAgICAgICAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gX3RoaXMucGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgICAgIGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gX3RoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNhbkJlT3B0aW1pemVkID0gX3RoaXMuY2FuTW9kZUJlT3B0aW1pemVkW25ld01vZGVdICYmIF90aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnICYmIG1vZGVDYW5CZU9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHB1c2hfbW9kZShuZXdNb2RlKSB7XG4gICAgICAgICAgICBtb2RlU3RhY2sucHVzaChuZXdNb2RlKTtcbiAgICAgICAgICAgIGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1vZGVDYW5CZU9wdGltaXplZCA9IHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkW25ld01vZGVdICYmIHRoaXMuY29uZmlnLnNhZmVNb2RlID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyAmJiBtb2RlQ2FuQmVPcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHBhdHRlcm4gc2VlbXMgdG8gYXZvaWQgYSBWOCBkZS1vcHRpbWl6YXRpb24sIGFsdGhvdWdoIHRoYXQgZGUtb3B0aW1pemF0aW9uIGRvZXMgbm90XG4gICAgICAgIC8vIHNlZW0gdG8gbWF0dGVyIHBlcmZvcm1hbmNlIHdpc2UuXG4gICAgICAgIHB1c2hfbW9kZS5jYWxsKHRoaXMsIGluaXRpYWxNb2RlKTtcbiAgICAgICAgdmFyIGN1cnJDb25maWc7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBvcmdMZW5ndGgpIHtcbiAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXJDb2RlID0gb3JnVGV4dC5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICB2YXIgY2hvc2VuUGF0dGVybklkeFRvQ29uZmlnID0gZ2V0UG9zc2libGVQYXR0ZXJucyhuZXh0Q2hhckNvZGUpO1xuICAgICAgICAgICAgdmFyIGNob3NlblBhdHRlcm5zTGVuZ3RoID0gY2hvc2VuUGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaG9zZW5QYXR0ZXJuc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdHRlcm4gPSBjdXJyQ29uZmlnLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVDaGFyQ29kZSA9IGN1cnJDb25maWcuc2hvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUNoYXJDb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID09PSBzaW5nbGVDaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IGN1cnJQYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJDb25maWcuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBjdXJyUGF0dGVybi5leGVjKG9yZ1RleHQsIG9mZnNldCwgbWF0Y2hlZFRva2VucywgZ3JvdXBzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gbWF0Y2gucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4KGN1cnJQYXR0ZXJuLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSB0aGlzLm1hdGNoKGN1cnJQYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZEltYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoaXMgcGF0dGVybiBtYXRjaGVkIHdlIG11c3QgdHJ5IGEgYW5vdGhlciBsb25nZXIgYWx0ZXJuYXRpdmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgdG8gcHJpb3JpdGl6ZSBrZXl3b3JkcyBvdmVyIGlkZW50aWZpZXJzXG4gICAgICAgICAgICAgICAgICAgIGxvbmdlckFsdElkeCA9IGN1cnJDb25maWcubG9uZ2VyQWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9uZ2VyQWx0SWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1pY3JvIG9wdGltaXplLCBhdm9pZCBleHRyYSBwcm9wIGFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgc2F2aW5nL2xpbmtpbmcgbG9uZ2VyQWx0IG9uIHRoZSBvcmlnaW5hbCBjb25maWc/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZ2VyQWx0Q29uZmlnID0gcGF0dGVybklkeFRvQ29uZmlnW2xvbmdlckFsdElkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZ2VyQWx0UGF0dGVybiA9IGxvbmdlckFsdENvbmZpZy5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0UGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgQ2hhciBjYW4gbmV2ZXIgYmUgYSBsb25nZXIgYWx0IHNvIG5vIG5lZWQgdG8gdGVzdCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbnVhbGx5IGluLWxpbmVkIGJlY2F1c2UgPiA2MDAgY2hhcnMgd29uJ3QgYmUgaW4tbGluZWQgaW4gVjhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb25nZXJBbHRDb25maWcuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGxvbmdlckFsdFBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0UGF5bG9hZCA9IG1hdGNoLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4KGxvbmdlckFsdFBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IHRoaXMubWF0Y2gobG9uZ2VyQWx0UGF0dGVybiwgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEFsdEltYWdlICYmIG1hdGNoQWx0SW1hZ2UubGVuZ3RoID4gbWF0Y2hlZEltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG1hdGNoQWx0SW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IGFsdFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGxvbmdlckFsdENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEltYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VMZW5ndGggPSBtYXRjaGVkSW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGdyb3VwID0gY3VyckNvbmZpZy5ncm91cDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tUeXBlID0gY3VyckNvbmZpZy50b2tlblR5cGVJZHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFwib2Zmc2V0ICsgaW1hZ2VMZW5ndGhcIiBhbmQgdGhlIG5ldyBjb2x1bW4gbWF5IGJlIGNvbXB1dGVkIHR3aWNlIGluIGNhc2Ugb2YgXCJmdWxsXCIgbG9jYXRpb24gaW5mb3JtYXRpb24gaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZUZ1bGxUb2tlbiBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UobWF0Y2hlZEltYWdlLCBvZmZzZXQsIHRva1R5cGUsIGN1cnJDb25maWcudG9rZW5UeXBlLCBsaW5lLCBjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXlsb2FkKG5ld1Rva2VuLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgTk9PUCBpbiBjYXNlIHRoZXJlIGFyZSBubyBzcGVjaWFsIGdyb3Vwcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFRva2Vuc0luZGV4ID0gdGhpcy5hZGRUb2tlbihtYXRjaGVkVG9rZW5zLCBtYXRjaGVkVG9rZW5zSW5kZXgsIG5ld1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChuZXdUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2hvcElucHV0KHRleHQsIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBpbWFnZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXRoIG5ld2xpbmVzIHRoZSBjb2x1bW4gbWF5IGJlIGFzc2lnbmVkIHR3aWNlXG4gICAgICAgICAgICAgICAgY29sdW1uID0gdGhpcy5jb21wdXRlTmV3Q29sdW1uKGNvbHVtbiwgaW1hZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0xpbmVzID09PSB0cnVlICYmIGN1cnJDb25maWcuY2FuTGluZVRlcm1pbmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bU9mTFRzSW5NYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFRlcm1pbmF0b3IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0TFRFbmRPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVUZXJtaW5hdG9yUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRlcm1pbmF0b3IgPSBsaW5lVGVybWluYXRvclBhdHRlcm4udGVzdChtYXRjaGVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kVGVybWluYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMVEVuZE9mZnNldCA9IGxpbmVUZXJtaW5hdG9yUGF0dGVybi5sYXN0SW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bU9mTFRzSW5NYXRjaCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChmb3VuZFRlcm1pbmF0b3IgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtT2ZMVHNJbk1hdGNoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIG51bU9mTFRzSW5NYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGltYWdlTGVuZ3RoIC0gbGFzdExURW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbihuZXdUb2tlbiwgZ3JvdXAsIGxhc3RMVEVuZE9mZnNldCwgbnVtT2ZMVHNJbk1hdGNoLCBsaW5lLCBjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIE5PT1AgaWYgbm8gbW9kZXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW9kZXMoY3VyckNvbmZpZywgcG9wX21vZGUsIHB1c2hfbW9kZSwgbmV3VG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnksIGRyb3AgY2hhcmFjdGVycyB1bnRpbCB3ZSBpZGVudGlmeSBhIHZhbGlkIHRva2VuJ3Mgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JTdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JMaW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWZvdW5kUmVzeW5jUG9pbnQgJiYgb2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3AgY2hhcnMgdW50aWwgd2Ugc3VjY2VlZCBpbiBtYXRjaGluZyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgZHJvcHBlZENoYXIgPSBvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWRlbnRpdHkgRnVuYyAod2hlbiBzdGlja3kgZmxhZyBpcyBlbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jaG9wSW5wdXQodGV4dCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckNvbmZpZ18xID0gcGF0dGVybklkeFRvQ29uZmlnW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXR0ZXJuID0gY3VyckNvbmZpZ18xLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnXzEuc2hvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlQ2hhckNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ1RleHQuY2hhckNvZGVBdChvZmZzZXQpID09PSBzaW5nbGVDaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQ29uZmlnXzEuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3VwcykgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgoY3VyclBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IGN1cnJQYXR0ZXJuLmV4ZWModGV4dCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRSZXN5bmNQb2ludCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVyckxlbmd0aCA9IG9mZnNldCAtIGVycm9yU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgcmUtc3luY2VkIG9yIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgdGV4dFxuICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKG9yZ1RleHQsIGVycm9yU3RhcnRPZmZzZXQsIGVyckxlbmd0aCwgZXJyb3JMaW5lLCBlcnJvckNvbHVtbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGVycm9yU3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVycm9yTGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlcnJvckNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBlcnJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRvIGhhdmUgY3VzdG9tIHBhdHRlcm5zIHdoaWNoIHB1c2ggZGlyZWN0bHkgaW50byB0aGVcbiAgICAgICAgLy8gVE9ETzogY3VzdG9tIHRva2VucyBzaG91bGQgbm90IHB1c2ggZGlyZWN0bHk/P1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ3VzdG9tKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBndWVzc2VkIGEgdG9vIGxhcmdlIHNpemUgZm9yIHRoZSB0b2tlbnMgYXJyYXkgdGhpcyB3aWxsIHNocmluayBpdCB0byB0aGUgcmlnaHQgc2l6ZS5cbiAgICAgICAgICAgIG1hdGNoZWRUb2tlbnMubGVuZ3RoID0gbWF0Y2hlZFRva2Vuc0luZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IG1hdGNoZWRUb2tlbnMsXG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlTW9kZXMgPSBmdW5jdGlvbiAoY29uZmlnLCBwb3BfbW9kZSwgcHVzaF9tb2RlLCBuZXdUb2tlbikge1xuICAgICAgICBpZiAoY29uZmlnLnBvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byBzYXZlIHRoZSBQVVNIX01PREUgcHJvcGVydHkgYXMgaWYgdGhlIG1vZGUgaXMgcG9wcGVkXG4gICAgICAgICAgICAvLyBwYXR0ZXJuSWR4VG9Qb3BNb2RlIGlzIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgbmV3IG1vZGUgYWZ0ZXIgcG9wcGluZyB0aGUgc3RhY2tcbiAgICAgICAgICAgIHZhciBwdXNoTW9kZSA9IGNvbmZpZy5wdXNoO1xuICAgICAgICAgICAgcG9wX21vZGUobmV3VG9rZW4pO1xuICAgICAgICAgICAgaWYgKHB1c2hNb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBwdXNoTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLnB1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgY29uZmlnLnB1c2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuY2hvcElucHV0ID0gZnVuY3Rpb24gKHRleHQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcobGVuZ3RoKTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS51cGRhdGVMYXN0SW5kZXggPSBmdW5jdGlvbiAocmVnRXhwLCBuZXdMYXN0SW5kZXgpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IG5ld0xhc3RJbmRleDtcbiAgICB9O1xuICAgIC8vIFRPRE86IGRlY3JlYXNlIHRoaXMgdW5kZXIgNjAwIGNoYXJhY3RlcnM/IGluc3BlY3Qgc3RyaXBwaW5nIGNvbW1lbnRzIG9wdGlvbiBpbiBUU0MgY29tcGlsZXJcbiAgICBMZXhlci5wcm90b3R5cGUudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24gPSBmdW5jdGlvbiAobmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRJZHgsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdENoYXJJc0xULCBmaXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYSBub25lIHNraXBwZWQgbXVsdGkgbGluZSBUb2tlbiwgbmVlZCB0byB1cGRhdGUgZW5kTGluZS9lbmRDb2x1bW5cbiAgICAgICAgICAgIGxhc3RDaGFySXNMVCA9IGxhc3RMVElkeCA9PT0gaW1hZ2VMZW5ndGggLSAxO1xuICAgICAgICAgICAgZml4Rm9yRW5kaW5nSW5MVCA9IGxhc3RDaGFySXNMVCA/IC0xIDogMDtcbiAgICAgICAgICAgIGlmICghKG51bU9mTFRzSW5NYXRjaCA9PT0gMSAmJiBsYXN0Q2hhcklzTFQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSB0b2tlbiBlbmRzIGluIGEgTFQgdGhhdCBsYXN0IExUIG9ubHkgYWZmZWN0cyB0aGUgbGluZSBudW1iZXJpbmcgb2YgZm9sbG93aW5nIFRva2Vuc1xuICAgICAgICAgICAgICAgIG5ld1Rva2VuLmVuZExpbmUgPSBsaW5lICsgZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBMVCBpbiBhIHRva2VuIGRvZXMgbm90IGFmZmVjdCB0aGUgZW5kQ29sdW1uIGVpdGhlciBhcyB0aGUgW2NvbHVtblN0YXJ0IC4uLiBjb2x1bW5FbmQpXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVzaXZlIHRvIGV4Y2x1c2l2ZSByYW5nZS5cbiAgICAgICAgICAgICAgICBuZXdUb2tlbi5lbmRDb2x1bW4gPSBjb2x1bW4gLSAxICsgLWZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHNpbmdsZSBMVCBpbiB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB0b2tlbiwgbm8gbmVlZCB0byBtb2RpZnkgdGhlIGVuZExpbmUvRW5kQ29sdW1uXG4gICAgICAgIH1cbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jb21wdXRlTmV3Q29sdW1uID0gZnVuY3Rpb24gKG9sZENvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9sZENvbHVtbiArIGltYWdlTGVuZ3RoO1xuICAgIH07XG4gICAgLy8gUGxhY2UgaG9sZGVyLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjb3JyZWN0IHZhcmlhbnQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhdGlvblRyYWNraW5nIG9wdGlvbiBhdCBydW50aW1lLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gcGxhY2UgaG9sZGVyICovXG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuY3JlYXRlT2Zmc2V0T25seVRva2VuID0gZnVuY3Rpb24gKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVTdGFydE9ubHlUb2tlbiA9IGZ1bmN0aW9uIChpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydENvbHVtbixcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVGdWxsVG9rZW4gPSBmdW5jdGlvbiAoaW1hZ2UsIHN0YXJ0T2Zmc2V0LCB0b2tlblR5cGVJZHgsIHRva2VuVHlwZSwgc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogc3RhcnRPZmZzZXQgKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogc3RhcnRDb2x1bW4gKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICB0b2tlblR5cGVJZHg6IHRva2VuVHlwZUlkeCxcbiAgICAgICAgICAgIHRva2VuVHlwZTogdG9rZW5UeXBlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBQbGFjZSBob2xkZXIsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvcnJlY3QgdmFyaWFudCBhY2NvcmRpbmcgdG8gdGhlIGxvY2F0aW9uVHJhY2tpbmcgb3B0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgKi9cbiAgICBMZXhlci5wcm90b3R5cGUuYWRkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHJldHVybiA2NjY7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ1B1c2ggPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yLnB1c2godG9rZW5Ub0FkZCk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzID0gZnVuY3Rpb24gKHRva2VuVmVjdG9yLCBpbmRleCwgdG9rZW5Ub0FkZCkge1xuICAgICAgICB0b2tlblZlY3RvcltpbmRleF0gPSB0b2tlblRvQWRkO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICAvLyBQbGFjZSBob2xkZXIsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvcnJlY3QgdmFyaWFudCBhY2NvcmRpbmcgdG8gdGhlIGhhc0N1c3RvbSBmbGFnIG9wdGlvbiBhdCBydW50aW1lLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gcGxhY2UgaG9sZGVyICovXG4gICAgTGV4ZXIucHJvdG90eXBlLmhhbmRsZVBheWxvYWQgPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHsgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tID0gZnVuY3Rpb24gKHRva2VuLCBwYXlsb2FkKSB7IH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tID0gZnVuY3Rpb24gKHRva2VuLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbi5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaG9zZW4gYWx0ZXJuYXRpdmUgYXQgcnVudGltZSAqL1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUubWF0Y2hXaXRoVGVzdCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gcGF0dGVybi50ZXN0KHRleHQpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhvZmZzZXQsIHBhdHRlcm4ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaFdpdGhFeGVjID0gZnVuY3Rpb24gKHBhdHRlcm4sIHRleHQpIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICByZXR1cm4gcmVnRXhwQXJyYXkgIT09IG51bGwgPyByZWdFeHBBcnJheVswXSA6IHJlZ0V4cEFycmF5O1xuICAgIH07XG4gICAgLy8gRHVwbGljYXRlZCBmcm9tIHRoZSBwYXJzZXIncyBwZXJmIHRyYWNlIHRyYWl0IHRvIGFsbG93IGZ1dHVyZSBleHRyYWN0aW9uXG4gICAgLy8gb2YgdGhlIGxleGVyIHRvIGEgc2VwYXJhdGUgcGFja2FnZS5cbiAgICBMZXhlci5wcm90b3R5cGUuVFJBQ0VfSU5JVCA9IGZ1bmN0aW9uIChwaGFzZURlc2MsIHBoYXNlSW1wbCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIG9wdGltaXplIHRoaXMgdXNpbmcgTk9PUCBwYXR0ZXJuIGJlY2F1c2VcbiAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdFBlcmYgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50Kys7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbmV3IEFycmF5KHRoaXMudHJhY2VJbml0SW5kZW50ICsgMSkuam9pbihcIlxcdFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQgKyBcIi0tPiA8XCIgKyBwaGFzZURlc2MgKyBcIj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSB0aW1lcihwaGFzZUltcGwpLCB0aW1lID0gX2EudGltZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gRGlmZmljdWx0IHRvIHJlcHJvZHVjZSBzcGVjaWZpYyBwZXJmb3JtYW5jZSBiZWhhdmlvciAoPjEwbXMpIGluIHRlc3RzICovXG4gICAgICAgICAgICB2YXIgdHJhY2VNZXRob2QgPSB0aW1lID4gMTAgPyBjb25zb2xlLndhcm4gOiBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICB0cmFjZU1ldGhvZChpbmRlbnQgKyBcIjwtLSA8XCIgKyBwaGFzZURlc2MgKyBcIj4gdGltZTogXCIgKyB0aW1lICsgXCJtc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50LS07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGhhc2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExleGVyLlNLSVBQRUQgPSBcIlRoaXMgbWFya3MgYSBza2lwcGVkIFRva2VuIHBhdHRlcm4sIHRoaXMgbWVhbnMgZWFjaCB0b2tlbiBpZGVudGlmaWVkIGJ5IGl0IHdpbGxcIiArXG4gICAgICAgIFwiYmUgY29uc3VtZWQgYW5kIHRoZW4gdGhyb3duIGludG8gb2JsaXZpb24sIHRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgdG8gY29tcGxldGVseSBpZ25vcmUgd2hpdGVzcGFjZS5cIjtcbiAgICBMZXhlci5OQSA9IC9OT1RfQVBQTElDQUJMRS87XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbmV4cG9ydCB7IExleGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js":
/*!*************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canMatchCharCode: () => (/* binding */ canMatchCharCode),\n/* harmony export */   failedOptimizationPrefixMsg: () => (/* binding */ failedOptimizationPrefixMsg),\n/* harmony export */   firstCharOptimizedIndices: () => (/* binding */ firstCharOptimizedIndices),\n/* harmony export */   getOptimizedStartCodesIndices: () => (/* binding */ getOptimizedStartCodesIndices)\n/* harmony export */ });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"(pages-dir-browser)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reg_exp_parser */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lexer */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nvar failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)(\"\" + failedOptimizationPrefixMsg +\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_ERROR)(failedOptimizationPrefixMsg + \"\\n\" +\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\n                (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.VERSION + \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal) {\n                                        var minUnOptVal = range.from >= _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal\n                                            ? range.from\n                                            : _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal;\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(minUnOptVal);\n                                        var maxOptIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.values)(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(ast.value)\n        ? (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.every)(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(pattern, function (char) {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vcmVnX2V4cC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzBEO0FBQ2tEO0FBQzdEO0FBQ3VCO0FBQ3ZFO0FBQ087QUFDQTtBQUNQLDBDQUEwQztBQUMxQztBQUNBLGtCQUFrQiw2REFBWTtBQUM5QixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVc7QUFDdkI7QUFDQSxpRUFBaUUsa0RBQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVCQUF1QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUscUNBQXFDLHNEQUFrQixFQUFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzREFBa0I7QUFDdEUsd0VBQXdFLHNEQUFrQjtBQUMxRjtBQUNBLDhDQUE4QyxzREFBa0I7QUFDaEU7QUFDQSx3REFBd0QsZ0VBQXdCO0FBQ2hGLHdEQUF3RCxnRUFBd0I7QUFDaEYseUVBQXlFLHlCQUF5QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBTTtBQUNqQjtBQUNBO0FBQ0EsMkJBQTJCLGdFQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRUFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQUk7QUFDZjtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBSSwwQ0FBMEMsZ0VBQWdFO0FBQ2xJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFPO0FBQ2xCLFVBQVUsbURBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsNERBQWlCO0FBQ1o7QUFDUDtBQUNBLGtCQUFrQiw2REFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFJO0FBQ3BCLG1CQUFtQixzREFBUTtBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxzY2FuXFxyZWdfZXhwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBWRVJTSU9OLCBCYXNlUmVnRXhwVmlzaXRvciB9IGZyb20gXCJyZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBmb3JFYWNoLCBjb250YWlucywgUFJJTlRfRVJST1IsIFBSSU5UX1dBUk5JTkcsIGZpbmQsIGlzQXJyYXksIGV2ZXJ5LCB2YWx1ZXMgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGdldFJlZ0V4cEFzdCB9IGZyb20gXCIuL3JlZ19leHBfcGFyc2VyXCI7XG5pbXBvcnQgeyBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgsIG1pbk9wdGltaXphdGlvblZhbCB9IGZyb20gXCIuL2xleGVyXCI7XG52YXIgY29tcGxlbWVudEVycm9yTWVzc2FnZSA9IFwiQ29tcGxlbWVudCBTZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBmaXJzdCBjaGFyIG9wdGltaXphdGlvblwiO1xuZXhwb3J0IHZhciBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2cgPSAnVW5hYmxlIHRvIHVzZSBcImZpcnN0IGNoYXJcIiBsZXhlciBvcHRpbWl6YXRpb25zOlxcbic7XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXMocmVnRXhwLCBlbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgaWYgKGVuc3VyZU9wdGltaXphdGlvbnMgPT09IHZvaWQgMCkgeyBlbnN1cmVPcHRpbWl6YXRpb25zID0gZmFsc2U7IH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgYXN0ID0gZ2V0UmVnRXhwQXN0KHJlZ0V4cCk7XG4gICAgICAgIHZhciBmaXJzdENoYXJzID0gZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QudmFsdWUsIHt9LCBhc3QuZmxhZ3MuaWdub3JlQ2FzZSk7XG4gICAgICAgIHJldHVybiBmaXJzdENoYXJzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAvLyBUZXN0aW5nIHRoaXMgcmVsaWVzIG9uIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgaGF2aW5nIGEgYnVnLi4uICovXG4gICAgICAgIC8vIFRPRE86IG9ubHkgdGhlIGVsc2UgYnJhbmNoIG5lZWRzIHRvIGJlIGlnbm9yZWQsIHRyeSB0byBmaXggd2l0aCBuZXdlciBwcmV0dGllciAvIHRzY1xuICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBjb21wbGVtZW50RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIFBSSU5UX1dBUk5JTkcoXCJcIiArIGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyArXG4gICAgICAgICAgICAgICAgICAgIChcIlxcdFVuYWJsZSB0byBvcHRpbWl6ZTogPCBcIiArIHJlZ0V4cC50b1N0cmluZygpICsgXCIgPlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Q29tcGxlbWVudCBTZXRzIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IG9wdGltaXplZC5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NPTVBMRU1FTlQgZm9yIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1zZ1N1ZmZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCA9XG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNSRUdFWFBfUEFSU0lORyBmb3IgZGV0YWlscy5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFBSSU5UX0VSUk9SKGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyArIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgIChcIlxcdEZhaWxlZCBwYXJzaW5nOiA8IFwiICsgcmVnRXhwLnRvU3RyaW5nKCkgKyBcIiA+XFxuXCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXHRVc2luZyB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5IHZlcnNpb246IFwiICsgVkVSU0lPTiArIFwiXFxuXCIpICtcbiAgICAgICAgICAgICAgICBcIlxcdFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYmQ4Mi9yZWdleHAtdG8tYXN0L2lzc3Vlc1wiICtcbiAgICAgICAgICAgICAgICBtc2dTdWZmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdCwgcmVzdWx0LCBpZ25vcmVDYXNlKSB7XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlIFwiRGlzanVuY3Rpb25cIjpcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QudmFsdWVbaV0sIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFsdGVybmF0aXZlXCI6XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBhc3QudmFsdWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB0ZXJtc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRlcm1zIHRoYXQgY2Fubm90IGVmZmVjdCB0aGUgZmlyc3QgY2hhciByZXN1bHRzXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXJtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIGJhY2sgcmVmZXJlbmNlIGNhbm5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNoYXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaWYgYSBiYWNrIHJlZmVyZW5jZSBpcyB0aGUgZmlyc3QgcHJvZHVjdGlvbiB0aGFuIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyb3VwIGJlaW5nIHJlZmVyZW5jZWQgaGFzIGhhZCB0byBjb21lIEJFRk9SRSBzbyBpdHMgY29kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwQmFja1JlZmVyZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIGRvIG5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOb25Xb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXRvbSA9IHRlcm07XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdG9tLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNoYXJhY3RlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbS5jb21wbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoY29tcGxlbWVudEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGF0b20udmFsdWUsIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KGNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3Qgb3B0aW1pemUgd2hlbiBpZ25vcmVDYXNlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVDYXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByYW5nZUNvZGUgPSByYW5nZS5mcm9tOyByYW5nZUNvZGUgPD0gcmFuZ2UudG87IHJhbmdlQ29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQocmFuZ2VDb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiAoMiBvcmRlcnMgb2YgbWFnbml0dWRlIGxlc3Mgd29yayBmb3IgdmVyeSBsYXJnZSByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHVub3B0aW1pemVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmFuZ2VDb2RlID0gcmFuZ2UuZnJvbTsgcmFuZ2VDb2RlIDw9IHJhbmdlLnRvICYmIHJhbmdlQ29kZSA8IG1pbk9wdGltaXphdGlvblZhbDsgcmFuZ2VDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChyYW5nZUNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXNzIGNvbW1vbiBjaGFyQ29kZSB3aGVyZSB3ZSBvcHRpbWl6ZSBmb3IgZmFzdGVyIGluaXQgdGltZSwgYnkgdXNpbmcgbGFyZ2VyIFwiYnVja2V0c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gPj0gbWluT3B0aW1pemF0aW9uVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pblVuT3B0VmFsID0gcmFuZ2UuZnJvbSA+PSBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWluT3B0aW1pemF0aW9uVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhVbk9wdFZhbCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5PcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWluVW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhPcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWF4VW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN1cnJPcHRJZHggPSBtaW5PcHRJZHg7IGN1cnJPcHRJZHggPD0gbWF4T3B0SWR4OyBjdXJyT3B0SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJPcHRJZHhdID0gY3Vyck9wdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb24gRXhoYXVzdGl2ZSBNYXRjaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBhIG1hbmRhdG9yeSBwcm9kdWN0aW9uLCBubyBtb3JlICoqc3RhcnQqKiBjb2RlcyBjYW4gYmUgZm91bmQgb24gdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsUXVhbnRpZmllciA9IGF0b20ucXVhbnRpZmllciAhPT0gdW5kZWZpbmVkICYmIGF0b20ucXVhbnRpZmllci5hdExlYXN0ID09PSAwO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIG1heSBiZSBvcHRpb25hbCBkdWUgdG8gZW1wdHkgY29udGVudHMgLyg/OikvXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgZXZlcnl0aGluZyBpbnNpZGUgaXQgaXMgb3B0aW9uYWwgLygoYSk/KS9cbiAgICAgICAgICAgICAgICAoYXRvbS50eXBlID09PSBcIkdyb3VwXCIgJiYgaXNXaG9sZU9wdGlvbmFsKGF0b20pID09PSBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB0ZXJtIGlzIG5vdCBhIGdyb3VwIGl0IG1heSBvbmx5IGJlIG9wdGlvbmFsIGlmIGl0IGhhcyBhbiBvcHRpb25hbCBxdWFudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIChhdG9tLnR5cGUgIT09IFwiR3JvdXBcIiAmJiBpc09wdGlvbmFsUXVhbnRpZmllciA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaCFcIik7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoKVxuICAgIHJldHVybiB2YWx1ZXMocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KGNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSkge1xuICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNvZGUpO1xuICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgaWYgKGlnbm9yZUNhc2UgPT09IHRydWUpIHtcbiAgICAgICAgaGFuZGxlSWdub3JlQ2FzZShjb2RlLCByZXN1bHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KSB7XG4gICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIHZhciB1cHBlckNoYXIgPSBjaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXBwZXJDaGFyICE9PSBjaGFyKSB7XG4gICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KHVwcGVyQ2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmVzdWx0W29wdGltaXplZENoYXJJZHhdID0gb3B0aW1pemVkQ2hhcklkeDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsb3dlckNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGxvd2VyQ2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ29kZShzZXROb2RlLCB0YXJnZXRDaGFyQ29kZXMpIHtcbiAgICByZXR1cm4gZmluZChzZXROb2RlLnZhbHVlLCBmdW5jdGlvbiAoY29kZU9yUmFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlT3JSYW5nZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKHRhcmdldENoYXJDb2RlcywgY29kZU9yUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgIHZhciByYW5nZV8xID0gY29kZU9yUmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gKGZpbmQodGFyZ2V0Q2hhckNvZGVzLCBmdW5jdGlvbiAodGFyZ2V0Q29kZSkgeyByZXR1cm4gcmFuZ2VfMS5mcm9tIDw9IHRhcmdldENvZGUgJiYgdGFyZ2V0Q29kZSA8PSByYW5nZV8xLnRvOyB9KSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNXaG9sZU9wdGlvbmFsKGFzdCkge1xuICAgIGlmIChhc3QucXVhbnRpZmllciAmJiBhc3QucXVhbnRpZmllci5hdExlYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFzdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KGFzdC52YWx1ZSlcbiAgICAgICAgPyBldmVyeShhc3QudmFsdWUsIGlzV2hvbGVPcHRpb25hbClcbiAgICAgICAgOiBpc1dob2xlT3B0aW9uYWwoYXN0LnZhbHVlKTtcbn1cbnZhciBDaGFyQ29kZUZpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhckNvZGVGaW5kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhckNvZGVGaW5kZXIodGFyZ2V0Q2hhckNvZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldENoYXJDb2RlcyA9IHRhcmdldENoYXJDb2RlcztcbiAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFyQ29kZUZpbmRlci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8ga2VlcCBsb29raW5nLi4uXG4gICAgICAgIGlmICh0aGlzLmZvdW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dpdGNoIGxvb2thaGVhZHMgYXMgdGhleSBkbyBub3QgYWN0dWFsbHkgY29uc3VtZSBhbnkgY2hhcmFjdGVycyB0aHVzXG4gICAgICAgIC8vIGZpbmRpbmcgYSBjaGFyQ29kZSBhdCBsb29rYWhlYWQgY29udGV4dCBkb2VzIG5vdCBtZWFuIHRoYXQgcmVnZXhwIGNhbiBhY3R1YWxseSBjb250YWluIGl0IGluIGEgbWF0Y2guXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdExvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiTmVnYXRpdmVMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbi5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG4gICAgQ2hhckNvZGVGaW5kZXIucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMudGFyZ2V0Q2hhckNvZGVzLCBub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJDb2RlRmluZGVyLnByb3RvdHlwZS52aXNpdFNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbXBsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChmaW5kQ29kZShub2RlLCB0aGlzLnRhcmdldENoYXJDb2RlcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbmRDb2RlKG5vZGUsIHRoaXMudGFyZ2V0Q2hhckNvZGVzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDaGFyQ29kZUZpbmRlcjtcbn0oQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbmV4cG9ydCBmdW5jdGlvbiBjYW5NYXRjaENoYXJDb2RlKGNoYXJDb2RlcywgcGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHZhciBhc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgIHZhciBjaGFyQ29kZUZpbmRlciA9IG5ldyBDaGFyQ29kZUZpbmRlcihjaGFyQ29kZXMpO1xuICAgICAgICBjaGFyQ29kZUZpbmRlci52aXNpdChhc3QpO1xuICAgICAgICByZXR1cm4gY2hhckNvZGVGaW5kZXIuZm91bmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKGZpbmQocGF0dGVybiwgZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhjaGFyQ29kZXMsIGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ19leHAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearRegExpParserCache: () => (/* binding */ clearRegExpParserCache),\n/* harmony export */   getRegExpAst: () => (/* binding */ getRegExpAst)\n/* harmony export */ });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"(pages-dir-browser)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n\nvar regExpAstCache = {};\nvar regExpParser = new regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.RegExpParser();\nfunction getRegExpAst(regExp) {\n    var regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        var regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nfunction clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vcmVnX2V4cF9wYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2QztBQUM3QztBQUNBLHVCQUF1Qix1REFBWTtBQUM1QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHNjYW5cXHJlZ19leHBfcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZ0V4cFBhcnNlciB9IGZyb20gXCJyZWdleHAtdG8tYXN0XCI7XG52YXIgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbnZhciByZWdFeHBQYXJzZXIgPSBuZXcgUmVnRXhwUGFyc2VyKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVnRXhwQXN0KHJlZ0V4cCkge1xuICAgIHZhciByZWdFeHBTdHIgPSByZWdFeHAudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnRXhwQXN0Q2FjaGUuaGFzT3duUHJvcGVydHkocmVnRXhwU3RyKSkge1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0Q2FjaGVbcmVnRXhwU3RyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZWdFeHBBc3QgPSByZWdFeHBQYXJzZXIucGF0dGVybihyZWdFeHBTdHIpO1xuICAgICAgICByZWdFeHBBc3RDYWNoZVtyZWdFeHBTdHJdID0gcmVnRXhwQXN0O1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclJlZ0V4cFBhcnNlckNhY2hlKCkge1xuICAgIHJlZ0V4cEFzdENhY2hlID0ge307XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdfZXhwX3BhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/tokens.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignCategoriesMapProp: () => (/* binding */ assignCategoriesMapProp),\n/* harmony export */   assignCategoriesTokensProp: () => (/* binding */ assignCategoriesTokensProp),\n/* harmony export */   assignTokenDefaultProps: () => (/* binding */ assignTokenDefaultProps),\n/* harmony export */   augmentTokenTypes: () => (/* binding */ augmentTokenTypes),\n/* harmony export */   expandCategories: () => (/* binding */ expandCategories),\n/* harmony export */   hasCategoriesProperty: () => (/* binding */ hasCategoriesProperty),\n/* harmony export */   hasExtendingTokensTypesMapProperty: () => (/* binding */ hasExtendingTokensTypesMapProperty),\n/* harmony export */   hasExtendingTokensTypesProperty: () => (/* binding */ hasExtendingTokensTypesProperty),\n/* harmony export */   hasShortKeyProperty: () => (/* binding */ hasShortKeyProperty),\n/* harmony export */   isTokenType: () => (/* binding */ isTokenType),\n/* harmony export */   singleAssignCategoriesToksMap: () => (/* binding */ singleAssignCategoriesToksMap),\n/* harmony export */   tokenIdxToClass: () => (/* binding */ tokenIdxToClass),\n/* harmony export */   tokenShortNameIdx: () => (/* binding */ tokenShortNameIdx),\n/* harmony export */   tokenStructuredMatcher: () => (/* binding */ tokenStructuredMatcher),\n/* harmony export */   tokenStructuredMatcherNoCategories: () => (/* binding */ tokenStructuredMatcherNoCategories)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nvar tokenShortNameIdx = 1;\nvar tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nfunction expandCategories(tokenTypes) {\n    var result = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr)(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.difference)(categories, result);\n        result = result.concat(newCategories);\n        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nfunction assignTokenDefaultProps(tokenTypes) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nfunction assignCategoriesTokensProp(tokenTypes) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nfunction assignCategoriesMapProp(tokenTypes) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nfunction hasShortKeyProperty(tokType) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, \"tokenTypeIdx\");\n}\nfunction hasCategoriesProperty(tokType) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, \"CATEGORIES\");\n}\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, \"categoryMatches\");\n}\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, \"categoryMatchesMap\");\n}\nfunction isTokenType(tokType) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vdG9rZW5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUg7QUFDaEg7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQLGlCQUFpQixzREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQU8sQ0FBQyxxREFBTyxDQUFDLGlEQUFHLHNDQUFzQyxnQ0FBZ0M7QUFDOUcsNEJBQTRCLHdEQUFVO0FBQ3RDO0FBQ0EsWUFBWSxxREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHFEQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUCxJQUFJLHFEQUFPO0FBQ1g7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQLElBQUkscURBQU87QUFDWDtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1AsSUFBSSxxREFBTztBQUNYO0FBQ0EsS0FBSztBQUNMLElBQUkscURBQU87QUFDWDtBQUNBO0FBQ0EsYUFBYSxzREFBUTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUCxXQUFXLGlEQUFHO0FBQ2Q7QUFDTztBQUNQLFdBQVcsaURBQUc7QUFDZDtBQUNPO0FBQ1AsV0FBVyxpREFBRztBQUNkO0FBQ087QUFDUCxXQUFXLGlEQUFHO0FBQ2Q7QUFDTztBQUNQLFdBQVcsaURBQUc7QUFDZDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxzY2FuXFx0b2tlbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVBcnIsIGNvbXBhY3QsIGNvbnRhaW5zLCBkaWZmZXJlbmNlLCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRW1wdHksIG1hcCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGluc3RhbmNlVHlwZSA9IHRva0luc3RhbmNlLnRva2VuVHlwZUlkeDtcbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSB0b2tDb25zdHJ1Y3Rvci50b2tlblR5cGVJZHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRva0NvbnN0cnVjdG9yLmlzUGFyZW50ID09PSB0cnVlICYmXG4gICAgICAgICAgICB0b2tDb25zdHJ1Y3Rvci5jYXRlZ29yeU1hdGNoZXNNYXBbaW5zdGFuY2VUeXBlXSA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuLy8gT3B0aW1pemVkIHRva2VuTWF0Y2hlciBpbiBjYXNlIG91ciBncmFtbWFyIGRvZXMgbm90IHVzZSB0b2tlbiBjYXRlZ29yaWVzXG4vLyBCZWluZyBzbyB0aW55IGl0IGlzIG11Y2ggbW9yZSBsaWtlbHkgdG8gYmUgaW4tbGluZWQgYW5kIHRoaXMgYXZvaWQgdGhlIGZ1bmN0aW9uIGNhbGwgb3ZlcmhlYWRcbmV4cG9ydCBmdW5jdGlvbiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva2VuLnRva2VuVHlwZUlkeCA9PT0gdG9rVHlwZS50b2tlblR5cGVJZHg7XG59XG5leHBvcnQgdmFyIHRva2VuU2hvcnROYW1lSWR4ID0gMTtcbmV4cG9ydCB2YXIgdG9rZW5JZHhUb0NsYXNzID0ge307XG5leHBvcnQgZnVuY3Rpb24gYXVnbWVudFRva2VuVHlwZXModG9rZW5UeXBlcykge1xuICAgIC8vIGNvbGxlY3QgdGhlIHBhcmVudCBUb2tlbiBUeXBlcyBhcyB3ZWxsLlxuICAgIHZhciB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXNBbmRQYXJlbnRzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRDYXRlZ29yaWVzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVBcnIodG9rZW5UeXBlcyk7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSB0b2tlblR5cGVzO1xuICAgIHZhciBzZWFyY2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChzZWFyY2hpbmcpIHtcbiAgICAgICAgY2F0ZWdvcmllcyA9IGNvbXBhY3QoZmxhdHRlbihtYXAoY2F0ZWdvcmllcywgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7IHJldHVybiBjdXJyVG9rVHlwZS5DQVRFR09SSUVTOyB9KSkpO1xuICAgICAgICB2YXIgbmV3Q2F0ZWdvcmllcyA9IGRpZmZlcmVuY2UoY2F0ZWdvcmllcywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChuZXdDYXRlZ29yaWVzKTtcbiAgICAgICAgaWYgKGlzRW1wdHkobmV3Q2F0ZWdvcmllcykpIHtcbiAgICAgICAgICAgIHNlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgaWYgKCFoYXNTaG9ydEtleVByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgdG9rZW5JZHhUb0NsYXNzW3Rva2VuU2hvcnROYW1lSWR4XSA9IGN1cnJUb2tUeXBlO1xuICAgICAgICAgICAgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4ID0gdG9rZW5TaG9ydE5hbWVJZHgrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBDQVRFR09SSUVTPyA6IFRva2VuVHlwZSB8IFRva2VuVHlwZVtdXG4gICAgICAgIGlmIChoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpICYmXG4gICAgICAgICAgICAhaXNBcnJheShjdXJyVG9rVHlwZS5DQVRFR09SSUVTKVxuICAgICAgICAvLyAmJlxuICAgICAgICAvLyAhaXNVbmRlZmluZWQoY3VyclRva1R5cGUuQ0FURUdPUklFUy5QQVRURVJOKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbY3VyclRva1R5cGUuQ0FURUdPUklFU107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5DQVRFR09SSUVTID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwID0ge307XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRpb25zXG4gICAgICAgIGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcCwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMucHVzaCh0b2tlbklkeFRvQ2xhc3Nba2V5XS50b2tlblR5cGVJZHgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzTWFwUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAoW10sIGN1cnJUb2tUeXBlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChwYXRoLCBuZXh0Tm9kZSkge1xuICAgIGZvckVhY2gocGF0aCwgZnVuY3Rpb24gKHBhdGhOb2RlKSB7XG4gICAgICAgIG5leHROb2RlLmNhdGVnb3J5TWF0Y2hlc01hcFtwYXRoTm9kZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKG5leHROb2RlLkNBVEVHT1JJRVMsIGZ1bmN0aW9uIChuZXh0Q2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBwYXRoLmNvbmNhdChuZXh0Tm9kZSk7XG4gICAgICAgIC8vIGF2b2lkcyBpbmZpbml0ZSBsb29wcyBkdWUgdG8gY3ljbGljIGNhdGVnb3JpZXMuXG4gICAgICAgIGlmICghY29udGFpbnMobmV3UGF0aCwgbmV4dENhdGVnb3J5KSkge1xuICAgICAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAobmV3UGF0aCwgbmV4dENhdGVnb3J5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Nob3J0S2V5UHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQ2F0ZWdvcmllc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiQ0FURUdPUklFU1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJjYXRlZ29yeU1hdGNoZXNNYXBcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGUodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EOF: () => (/* binding */ EOF),\n/* harmony export */   createToken: () => (/* binding */ createToken),\n/* harmony export */   createTokenInstance: () => (/* binding */ createTokenInstance),\n/* harmony export */   hasTokenLabel: () => (/* binding */ hasTokenLabel),\n/* harmony export */   tokenLabel: () => (/* binding */ tokenLabel),\n/* harmony export */   tokenMatcher: () => (/* binding */ tokenMatcher),\n/* harmony export */   tokenName: () => (/* binding */ tokenName)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer_public */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n\n\n\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nfunction tokenName(tokType) {\n    return tokType.name;\n}\nfunction hasTokenLabel(obj) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(obj.LABEL) && obj.LABEL !== \"\";\n}\nvar PARENT = \"parent\";\nvar CATEGORIES = \"categories\";\nvar LABEL = \"label\";\nvar GROUP = \"group\";\nvar PUSH_MODE = \"push_mode\";\nvar POP_MODE = \"pop_mode\";\nvar LONGER_ALT = \"longer_alt\";\nvar LINE_BREAKS = \"line_breaks\";\nvar START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    var pattern = config.pattern;\n    var tokenType = {};\n    tokenType.name = config.name;\n    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, PARENT)) {\n        throw (\"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.\");\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)([tokenType]);\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nvar EOF = createToken({ name: \"EOF\", pattern: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA });\n(0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n    };\n}\nfunction tokenMatcher(token, tokType) {\n    return (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcher)(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vdG9rZW5zX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ3JCO0FBQzhCO0FBQzlEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVc7QUFDcEI7QUFDQTtBQUNBLFFBQVEsaURBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBaUI7QUFDckIsUUFBUSxpREFBRztBQUNYO0FBQ0E7QUFDQSxRQUFRLGlEQUFHO0FBQ1g7QUFDQTtBQUNBLFFBQVEsaURBQUc7QUFDWDtBQUNBO0FBQ0EsUUFBUSxpREFBRztBQUNYO0FBQ0E7QUFDQSxRQUFRLGlEQUFHO0FBQ1g7QUFDQTtBQUNBLFFBQVEsaURBQUc7QUFDWDtBQUNBO0FBQ0EsUUFBUSxpREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLHNCQUFzQixnREFBSyxLQUFLO0FBQy9ELDBEQUFpQjtBQUNWO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLCtEQUFzQjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcY2hldnJvdGFpblxcbGliX2VzbVxcc3JjXFxzY2FuXFx0b2tlbnNfcHVibGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhcywgaXNTdHJpbmcsIGlzVW5kZWZpbmVkIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuL2xleGVyX3B1YmxpY1wiO1xuaW1wb3J0IHsgYXVnbWVudFRva2VuVHlwZXMsIHRva2VuU3RydWN0dXJlZE1hdGNoZXIgfSBmcm9tIFwiLi90b2tlbnNcIjtcbmV4cG9ydCBmdW5jdGlvbiB0b2tlbkxhYmVsKHRva1R5cGUpIHtcbiAgICBpZiAoaGFzVG9rZW5MYWJlbCh0b2tUeXBlKSkge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5MQUJFTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tUeXBlLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuTmFtZSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva1R5cGUubmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNUb2tlbkxhYmVsKG9iaikge1xuICAgIHJldHVybiBpc1N0cmluZyhvYmouTEFCRUwpICYmIG9iai5MQUJFTCAhPT0gXCJcIjtcbn1cbnZhciBQQVJFTlQgPSBcInBhcmVudFwiO1xudmFyIENBVEVHT1JJRVMgPSBcImNhdGVnb3JpZXNcIjtcbnZhciBMQUJFTCA9IFwibGFiZWxcIjtcbnZhciBHUk9VUCA9IFwiZ3JvdXBcIjtcbnZhciBQVVNIX01PREUgPSBcInB1c2hfbW9kZVwiO1xudmFyIFBPUF9NT0RFID0gXCJwb3BfbW9kZVwiO1xudmFyIExPTkdFUl9BTFQgPSBcImxvbmdlcl9hbHRcIjtcbnZhciBMSU5FX0JSRUFLUyA9IFwibGluZV9icmVha3NcIjtcbnZhciBTVEFSVF9DSEFSU19ISU5UID0gXCJzdGFydF9jaGFyc19oaW50XCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVG9rZW4oY29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuSW50ZXJuYWwoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuSW50ZXJuYWwoY29uZmlnKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBjb25maWcucGF0dGVybjtcbiAgICB2YXIgdG9rZW5UeXBlID0ge307XG4gICAgdG9rZW5UeXBlLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHBhdHRlcm4pKSB7XG4gICAgICAgIHRva2VuVHlwZS5QQVRURVJOID0gcGF0dGVybjtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFBBUkVOVCkpIHtcbiAgICAgICAgdGhyb3cgKFwiVGhlIHBhcmVudCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxcblwiICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL2dpdGh1Yi5jb20vU0FQL2NoZXZyb3RhaW4vaXNzdWVzLzU2NCNpc3N1ZWNvbW1lbnQtMzQ5MDYyMzQ2IGZvciBkZXRhaWxzLlwiKTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIENBVEVHT1JJRVMpKSB7XG4gICAgICAgIC8vIGNhc3RpbmcgdG8gQU5ZIGFzIHRoaXMgd2lsbCBiZSBmaXhlZCBpbnNpZGUgYGF1Z21lbnRUb2tlblR5cGVzYGBcbiAgICAgICAgdG9rZW5UeXBlLkNBVEVHT1JJRVMgPSBjb25maWdbQ0FURUdPUklFU107XG4gICAgfVxuICAgIGF1Z21lbnRUb2tlblR5cGVzKFt0b2tlblR5cGVdKTtcbiAgICBpZiAoaGFzKGNvbmZpZywgTEFCRUwpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MQUJFTCA9IGNvbmZpZ1tMQUJFTF07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBHUk9VUCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkdST1VQID0gY29uZmlnW0dST1VQXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFBPUF9NT0RFKSkge1xuICAgICAgICB0b2tlblR5cGUuUE9QX01PREUgPSBjb25maWdbUE9QX01PREVdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgUFVTSF9NT0RFKSkge1xuICAgICAgICB0b2tlblR5cGUuUFVTSF9NT0RFID0gY29uZmlnW1BVU0hfTU9ERV07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBMT05HRVJfQUxUKSkge1xuICAgICAgICB0b2tlblR5cGUuTE9OR0VSX0FMVCA9IGNvbmZpZ1tMT05HRVJfQUxUXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIExJTkVfQlJFQUtTKSkge1xuICAgICAgICB0b2tlblR5cGUuTElORV9CUkVBS1MgPSBjb25maWdbTElORV9CUkVBS1NdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgU1RBUlRfQ0hBUlNfSElOVCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlNUQVJUX0NIQVJTX0hJTlQgPSBjb25maWdbU1RBUlRfQ0hBUlNfSElOVF07XG4gICAgfVxuICAgIHJldHVybiB0b2tlblR5cGU7XG59XG5leHBvcnQgdmFyIEVPRiA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJFT0ZcIiwgcGF0dGVybjogTGV4ZXIuTkEgfSk7XG5hdWdtZW50VG9rZW5UeXBlcyhbRU9GXSk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVG9rZW5JbnN0YW5jZSh0b2tUeXBlLCBpbWFnZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldDogZW5kT2Zmc2V0LFxuICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgZW5kTGluZTogZW5kTGluZSxcbiAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICBlbmRDb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tUeXBlLnRva2VuVHlwZUlkeCxcbiAgICAgICAgdG9rZW5UeXBlOiB0b2tUeXBlXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbk1hdGNoZXIodG9rZW4sIHRva1R5cGUpIHtcbiAgICByZXR1cm4gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcih0b2tlbiwgdG9rVHlwZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnNfcHVibGljLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/utils/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDENTITY: () => (/* binding */ IDENTITY),\n/* harmony export */   NOOP: () => (/* binding */ NOOP),\n/* harmony export */   PRINT_ERROR: () => (/* binding */ PRINT_ERROR),\n/* harmony export */   PRINT_WARNING: () => (/* binding */ PRINT_WARNING),\n/* harmony export */   applyMixins: () => (/* binding */ applyMixins),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   assignNoOverwrite: () => (/* binding */ assignNoOverwrite),\n/* harmony export */   cloneArr: () => (/* binding */ cloneArr),\n/* harmony export */   cloneObj: () => (/* binding */ cloneObj),\n/* harmony export */   compact: () => (/* binding */ compact),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   drop: () => (/* binding */ drop),\n/* harmony export */   dropRight: () => (/* binding */ dropRight),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   findAll: () => (/* binding */ findAll),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   indexOf: () => (/* binding */ indexOf),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isES2015MapSupported: () => (/* binding */ isES2015MapSupported),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   packArray: () => (/* binding */ packArray),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   peek: () => (/* binding */ peek),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   reject: () => (/* binding */ reject),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   timer: () => (/* binding */ timer),\n/* harmony export */   toFastProperties: () => (/* binding */ toFastProperties),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   zipObject: () => (/* binding */ zipObject)\n/* harmony export */ });\n/*\n Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.\n These utils should replace usage of lodash in the production code base. not because they are any better...\n but for the purpose of being a dependency free library.\n\n The hotspots in the code are already written in imperative style for performance reasons.\n so writing several dozen utils which may be slower than the original lodash, does not matter as much\n considering they will not be invoked in hotspots...\n */\nfunction isEmpty(arr) {\n    return arr && arr.length === 0;\n}\nfunction keys(obj) {\n    if (obj === undefined || obj === null) {\n        return [];\n    }\n    return Object.keys(obj);\n}\nfunction values(obj) {\n    var vals = [];\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n        vals.push(obj[keys[i]]);\n    }\n    return vals;\n}\nfunction mapValues(obj, callback) {\n    var result = [];\n    var objKeys = keys(obj);\n    for (var idx = 0; idx < objKeys.length; idx++) {\n        var currKey = objKeys[idx];\n        result.push(callback.call(null, obj[currKey], currKey));\n    }\n    return result;\n}\nfunction map(arr, callback) {\n    var result = [];\n    for (var idx = 0; idx < arr.length; idx++) {\n        result.push(callback.call(null, arr[idx], idx));\n    }\n    return result;\n}\nfunction flatten(arr) {\n    var result = [];\n    for (var idx = 0; idx < arr.length; idx++) {\n        var currItem = arr[idx];\n        if (Array.isArray(currItem)) {\n            result = result.concat(flatten(currItem));\n        }\n        else {\n            result.push(currItem);\n        }\n    }\n    return result;\n}\nfunction first(arr) {\n    return isEmpty(arr) ? undefined : arr[0];\n}\nfunction last(arr) {\n    var len = arr && arr.length;\n    return len ? arr[len - 1] : undefined;\n}\nfunction forEach(collection, iteratorCallback) {\n    /* istanbul ignore else */\n    if (Array.isArray(collection)) {\n        for (var i = 0; i < collection.length; i++) {\n            iteratorCallback.call(null, collection[i], i);\n        }\n    }\n    else if (isObject(collection)) {\n        var colKeys = keys(collection);\n        for (var i = 0; i < colKeys.length; i++) {\n            var key = colKeys[i];\n            var value = collection[key];\n            iteratorCallback.call(null, value, key);\n        }\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction isString(item) {\n    return typeof item === \"string\";\n}\nfunction isUndefined(item) {\n    return item === undefined;\n}\nfunction isFunction(item) {\n    return item instanceof Function;\n}\nfunction drop(arr, howMuch) {\n    if (howMuch === void 0) { howMuch = 1; }\n    return arr.slice(howMuch, arr.length);\n}\nfunction dropRight(arr, howMuch) {\n    if (howMuch === void 0) { howMuch = 1; }\n    return arr.slice(0, arr.length - howMuch);\n}\nfunction filter(arr, predicate) {\n    var result = [];\n    if (Array.isArray(arr)) {\n        for (var i = 0; i < arr.length; i++) {\n            var item = arr[i];\n            if (predicate.call(null, item)) {\n                result.push(item);\n            }\n        }\n    }\n    return result;\n}\nfunction reject(arr, predicate) {\n    return filter(arr, function (item) { return !predicate(item); });\n}\nfunction pick(obj, predicate) {\n    var keys = Object.keys(obj);\n    var result = {};\n    for (var i = 0; i < keys.length; i++) {\n        var currKey = keys[i];\n        var currItem = obj[currKey];\n        if (predicate(currItem)) {\n            result[currKey] = currItem;\n        }\n    }\n    return result;\n}\nfunction has(obj, prop) {\n    if (isObject(obj)) {\n        return obj.hasOwnProperty(prop);\n    }\n    return false;\n}\nfunction contains(arr, item) {\n    return find(arr, function (currItem) { return currItem === item; }) !== undefined ? true : false;\n}\n/**\n * shallow clone\n */\nfunction cloneArr(arr) {\n    var newArr = [];\n    for (var i = 0; i < arr.length; i++) {\n        newArr.push(arr[i]);\n    }\n    return newArr;\n}\n/**\n * shallow clone\n */\nfunction cloneObj(obj) {\n    var clonedObj = {};\n    for (var key in obj) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = obj[key];\n        }\n    }\n    return clonedObj;\n}\nfunction find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (predicate.call(null, item)) {\n            return item;\n        }\n    }\n    return undefined;\n}\nfunction findAll(arr, predicate) {\n    var found = [];\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (predicate.call(null, item)) {\n            found.push(item);\n        }\n    }\n    return found;\n}\nfunction reduce(arrOrObj, iterator, initial) {\n    var isArr = Array.isArray(arrOrObj);\n    var vals = isArr ? arrOrObj : values(arrOrObj);\n    var objKeys = isArr ? [] : keys(arrOrObj);\n    var accumulator = initial;\n    for (var i = 0; i < vals.length; i++) {\n        accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);\n    }\n    return accumulator;\n}\nfunction compact(arr) {\n    return reject(arr, function (item) { return item === null || item === undefined; });\n}\nfunction uniq(arr, identity) {\n    if (identity === void 0) { identity = function (item) { return item; }; }\n    var identities = [];\n    return reduce(arr, function (result, currItem) {\n        var currIdentity = identity(currItem);\n        if (contains(identities, currIdentity)) {\n            return result;\n        }\n        else {\n            identities.push(currIdentity);\n            return result.concat(currItem);\n        }\n    }, []);\n}\nfunction partial(func) {\n    var restArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        restArgs[_i - 1] = arguments[_i];\n    }\n    var firstArg = [null];\n    var allArgs = firstArg.concat(restArgs);\n    return Function.bind.apply(func, allArgs);\n}\nfunction isArray(obj) {\n    return Array.isArray(obj);\n}\nfunction isRegExp(obj) {\n    return obj instanceof RegExp;\n}\nfunction isObject(obj) {\n    return obj instanceof Object;\n}\nfunction every(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!predicate(arr[i], i)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction difference(arr, values) {\n    return reject(arr, function (item) { return contains(values, item); });\n}\nfunction some(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (predicate(arr[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction indexOf(arr, value) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === value) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction sortBy(arr, orderFunc) {\n    var result = cloneArr(arr);\n    result.sort(function (a, b) { return orderFunc(a) - orderFunc(b); });\n    return result;\n}\nfunction zipObject(keys, values) {\n    if (keys.length !== values.length) {\n        throw Error(\"can't zipObject with different number of keys and values!\");\n    }\n    var result = {};\n    for (var i = 0; i < keys.length; i++) {\n        result[keys[i]] = values[i];\n    }\n    return result;\n}\n/**\n * mutates! (and returns) target\n */\nfunction assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var curSource = sources[i];\n        var currSourceKeys = keys(curSource);\n        for (var j = 0; j < currSourceKeys.length; j++) {\n            var currKey = currSourceKeys[j];\n            target[currKey] = curSource[currKey];\n        }\n    }\n    return target;\n}\n/**\n * mutates! (and returns) target\n */\nfunction assignNoOverwrite(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var curSource = sources[i];\n        var currSourceKeys = keys(curSource);\n        for (var j = 0; j < currSourceKeys.length; j++) {\n            var currKey = currSourceKeys[j];\n            if (!has(target, currKey)) {\n                target[currKey] = curSource[currKey];\n            }\n        }\n    }\n    return target;\n}\nfunction defaults() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return assignNoOverwrite.apply(null, [{}].concat(sources));\n}\nfunction groupBy(arr, groupKeyFunc) {\n    var result = {};\n    forEach(arr, function (item) {\n        var currGroupKey = groupKeyFunc(item);\n        var currGroupArr = result[currGroupKey];\n        if (currGroupArr) {\n            currGroupArr.push(item);\n        }\n        else {\n            result[currGroupKey] = [item];\n        }\n    });\n    return result;\n}\n/**\n * Merge obj2 into obj1.\n * Will overwrite existing properties with the same name\n */\nfunction merge(obj1, obj2) {\n    var result = cloneObj(obj1);\n    var keys2 = keys(obj2);\n    for (var i = 0; i < keys2.length; i++) {\n        var key = keys2[i];\n        var value = obj2[key];\n        result[key] = value;\n    }\n    return result;\n}\nfunction NOOP() { }\nfunction IDENTITY(item) {\n    return item;\n}\n/**\n * Will return a new packed array with same values.\n */\nfunction packArray(holeyArr) {\n    var result = [];\n    for (var i = 0; i < holeyArr.length; i++) {\n        var orgValue = holeyArr[i];\n        result.push(orgValue !== undefined ? orgValue : undefined);\n    }\n    return result;\n}\nfunction PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(\"Error: \" + msg);\n    }\n}\nfunction PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(\"Warning: \" + msg);\n    }\n}\nfunction isES2015MapSupported() {\n    return typeof Map === \"function\";\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        var baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n            if (propName === \"constructor\") {\n                return;\n            }\n            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nfunction toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    var fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    eval(toBecomeFast);\n}\nfunction peek(arr) {\n    return arr[arr.length - 1];\n}\n/* istanbul ignore next - for performance tracing*/\nfunction timer(func) {\n    var start = new Date().getTime();\n    var val = func();\n    var end = new Date().getTime();\n    var total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3V0aWxzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlDQUF5QywwQkFBMEI7QUFDbkU7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUNBQXlDLDZDQUE2QztBQUN0RjtBQUNPO0FBQ1AsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlDQUF5QyxnQ0FBZ0M7QUFDekU7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQ0FBa0MscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGNoZXZyb3RhaW5cXGxpYl9lc21cXHNyY1xcdXRpbHNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVXRpbHMgdXNpbmcgbG9kYXNoIHN0eWxlIEFQSS4gKG5vdCBuZWNlc3NhcmlseSAxMDAlIGNvbXBsaWFudCkgZm9yIGZ1bmN0aW9uYWwgYW5kIG90aGVyIHV0aWxzLlxuIFRoZXNlIHV0aWxzIHNob3VsZCByZXBsYWNlIHVzYWdlIG9mIGxvZGFzaCBpbiB0aGUgcHJvZHVjdGlvbiBjb2RlIGJhc2UuIG5vdCBiZWNhdXNlIHRoZXkgYXJlIGFueSBiZXR0ZXIuLi5cbiBidXQgZm9yIHRoZSBwdXJwb3NlIG9mIGJlaW5nIGEgZGVwZW5kZW5jeSBmcmVlIGxpYnJhcnkuXG5cbiBUaGUgaG90c3BvdHMgaW4gdGhlIGNvZGUgYXJlIGFscmVhZHkgd3JpdHRlbiBpbiBpbXBlcmF0aXZlIHN0eWxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuIHNvIHdyaXRpbmcgc2V2ZXJhbCBkb3plbiB1dGlscyB3aGljaCBtYXkgYmUgc2xvd2VyIHRoYW4gdGhlIG9yaWdpbmFsIGxvZGFzaCwgZG9lcyBub3QgbWF0dGVyIGFzIG11Y2hcbiBjb25zaWRlcmluZyB0aGV5IHdpbGwgbm90IGJlIGludm9rZWQgaW4gaG90c3BvdHMuLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoYXJyKSB7XG4gICAgcmV0dXJuIGFyciAmJiBhcnIubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgICB2YXIgdmFscyA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFscy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWxzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBvYmpLZXlzID0ga2V5cyhvYmopO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IG9iaktleXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgY3VycktleSA9IG9iaktleXNbaWR4XTtcbiAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbChudWxsLCBvYmpbY3VycktleV0sIGN1cnJLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXAoYXJyLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKG51bGwsIGFycltpZHhdLCBpZHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgY3Vyckl0ZW0gPSBhcnJbaWR4XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3Vyckl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZW4oY3Vyckl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycikge1xuICAgIHJldHVybiBpc0VtcHR5KGFycikgPyB1bmRlZmluZWQgOiBhcnJbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICB2YXIgbGVuID0gYXJyICYmIGFyci5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbiA/IGFycltsZW4gLSAxXSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdG9yQ2FsbGJhY2spIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3JDYWxsYmFjay5jYWxsKG51bGwsIGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBjb2xLZXlzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY29sS2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2FsbGJhY2suY2FsbChudWxsLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoaXRlbSkge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRyb3AoYXJyLCBob3dNdWNoKSB7XG4gICAgaWYgKGhvd011Y2ggPT09IHZvaWQgMCkgeyBob3dNdWNoID0gMTsgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoaG93TXVjaCwgYXJyLmxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZHJvcFJpZ2h0KGFyciwgaG93TXVjaCkge1xuICAgIGlmIChob3dNdWNoID09PSB2b2lkIDApIHsgaG93TXVjaCA9IDE7IH1cbiAgICByZXR1cm4gYXJyLnNsaWNlKDAsIGFyci5sZW5ndGggLSBob3dNdWNoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwobnVsbCwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlamVjdChhcnIsIHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmaWx0ZXIoYXJyLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIXByZWRpY2F0ZShpdGVtKTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIHByZWRpY2F0ZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyS2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIGN1cnJJdGVtID0gb2JqW2N1cnJLZXldO1xuICAgICAgICBpZiAocHJlZGljYXRlKGN1cnJJdGVtKSkge1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJLZXldID0gY3Vyckl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXMob2JqLCBwcm9wKSB7XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKGFyciwgaXRlbSkge1xuICAgIHJldHVybiBmaW5kKGFyciwgZnVuY3Rpb24gKGN1cnJJdGVtKSB7IHJldHVybiBjdXJySXRlbSA9PT0gaXRlbTsgfSkgIT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcbn1cbi8qKlxuICogc2hhbGxvdyBjbG9uZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVBcnIoYXJyKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG59XG4vKipcbiAqIHNoYWxsb3cgY2xvbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lT2JqKG9iaikge1xuICAgIHZhciBjbG9uZWRPYmogPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBjbG9uZWRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRPYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyW2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwobnVsbCwgaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEFsbChhcnIsIHByZWRpY2F0ZSkge1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyW2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwobnVsbCwgaXRlbSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZShhcnJPck9iaiwgaXRlcmF0b3IsIGluaXRpYWwpIHtcbiAgICB2YXIgaXNBcnIgPSBBcnJheS5pc0FycmF5KGFyck9yT2JqKTtcbiAgICB2YXIgdmFscyA9IGlzQXJyID8gYXJyT3JPYmogOiB2YWx1ZXMoYXJyT3JPYmopO1xuICAgIHZhciBvYmpLZXlzID0gaXNBcnIgPyBbXSA6IGtleXMoYXJyT3JPYmopO1xuICAgIHZhciBhY2N1bXVsYXRvciA9IGluaXRpYWw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0b3IuY2FsbChudWxsLCBhY2N1bXVsYXRvciwgdmFsc1tpXSwgaXNBcnIgPyBpIDogb2JqS2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0KGFycikge1xuICAgIHJldHVybiByZWplY3QoYXJyLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB1bmRlZmluZWQ7IH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuaXEoYXJyLCBpZGVudGl0eSkge1xuICAgIGlmIChpZGVudGl0eSA9PT0gdm9pZCAwKSB7IGlkZW50aXR5ID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH07IH1cbiAgICB2YXIgaWRlbnRpdGllcyA9IFtdO1xuICAgIHJldHVybiByZWR1Y2UoYXJyLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJySXRlbSkge1xuICAgICAgICB2YXIgY3VycklkZW50aXR5ID0gaWRlbnRpdHkoY3Vyckl0ZW0pO1xuICAgICAgICBpZiAoY29udGFpbnMoaWRlbnRpdGllcywgY3VycklkZW50aXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkZW50aXRpZXMucHVzaChjdXJySWRlbnRpdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoY3Vyckl0ZW0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgIHZhciByZXN0QXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHJlc3RBcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZmlyc3RBcmcgPSBbbnVsbF07XG4gICAgdmFyIGFsbEFyZ3MgPSBmaXJzdEFyZy5jb25jYXQocmVzdEFyZ3MpO1xuICAgIHJldHVybiBGdW5jdGlvbi5iaW5kLmFwcGx5KGZ1bmMsIGFsbEFyZ3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUmVnRXhwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gZXZlcnkoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJbaV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnIsIHZhbHVlcykge1xuICAgIHJldHVybiByZWplY3QoYXJyLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gY29udGFpbnModmFsdWVzLCBpdGVtKTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc29tZShhcnIsIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyLCB2YWx1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5KGFyciwgb3JkZXJGdW5jKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNsb25lQXJyKGFycik7XG4gICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIG9yZGVyRnVuYyhhKSAtIG9yZGVyRnVuYyhiKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiY2FuJ3QgemlwT2JqZWN0IHdpdGggZGlmZmVyZW50IG51bWJlciBvZiBrZXlzIGFuZCB2YWx1ZXMhXCIpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtrZXlzW2ldXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogbXV0YXRlcyEgKGFuZCByZXR1cm5zKSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyU291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgdmFyIGN1cnJTb3VyY2VLZXlzID0ga2V5cyhjdXJTb3VyY2UpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJTb3VyY2VLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VycktleSA9IGN1cnJTb3VyY2VLZXlzW2pdO1xuICAgICAgICAgICAgdGFyZ2V0W2N1cnJLZXldID0gY3VyU291cmNlW2N1cnJLZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIG11dGF0ZXMhIChhbmQgcmV0dXJucykgdGFyZ2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Ob092ZXJ3cml0ZSh0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyU291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgdmFyIGN1cnJTb3VyY2VLZXlzID0ga2V5cyhjdXJTb3VyY2UpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJTb3VyY2VLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VycktleSA9IGN1cnJTb3VyY2VLZXlzW2pdO1xuICAgICAgICAgICAgaWYgKCFoYXModGFyZ2V0LCBjdXJyS2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtjdXJyS2V5XSA9IGN1clNvdXJjZVtjdXJyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduTm9PdmVyd3JpdGUuYXBwbHkobnVsbCwgW3t9XS5jb25jYXQoc291cmNlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBncm91cEtleUZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjdXJyR3JvdXBLZXkgPSBncm91cEtleUZ1bmMoaXRlbSk7XG4gICAgICAgIHZhciBjdXJyR3JvdXBBcnIgPSByZXN1bHRbY3Vyckdyb3VwS2V5XTtcbiAgICAgICAgaWYgKGN1cnJHcm91cEFycikge1xuICAgICAgICAgICAgY3Vyckdyb3VwQXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbY3Vyckdyb3VwS2V5XSA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIG9iajIgaW50byBvYmoxLlxuICogV2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVPYmoob2JqMSk7XG4gICAgdmFyIGtleXMyID0ga2V5cyhvYmoyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqMltrZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIE5PT1AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBJREVOVElUWShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgbmV3IHBhY2tlZCBhcnJheSB3aXRoIHNhbWUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja0FycmF5KGhvbGV5QXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yZ1ZhbHVlID0gaG9sZXlBcnJbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG9yZ1ZhbHVlICE9PSB1bmRlZmluZWQgPyBvcmdWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfRVJST1IobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBjYW4ndCBvdmVycmlkZSBnbG9iYWwuY29uc29sZSBpbiBub2RlLmpzICovXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IFwiICsgbXNnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfV0FSTklORyhtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGNhbid0IG92ZXJyaWRlIGdsb2JhbC5jb25zb2xlIGluIG5vZGUuanMqL1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgZG9jcyBhY2NvcmRpbmdseVxuICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIiArIG1zZyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRVMyMDE1TWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGJhc2VDdG9ycykge1xuICAgIGJhc2VDdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChiYXNlQ3Rvcikge1xuICAgICAgICB2YXIgYmFzZVByb3RvID0gYmFzZUN0b3IucHJvdG90eXBlO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlUHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXNlUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VQcm90bywgcHJvcE5hbWUpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIEFjY2Vzc29yc1xuICAgICAgICAgICAgaWYgKGJhc2VQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgIChiYXNlUHJvcERlc2NyaXB0b3IuZ2V0IHx8IGJhc2VQcm9wRGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDdG9yLnByb3RvdHlwZSwgcHJvcE5hbWUsIGJhc2VQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbcHJvcE5hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyBiYXNlIG9uOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL2Jsb2IvYjk3YzBkMmQ0ODdlOGM1MDc2ZThiZDg5N2UwZGNkNDYyMmQzMTg0Ni9zcmMvdXRpbC5qcyNMMjAxLUwyMTZcbmV4cG9ydCBmdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKHRvQmVjb21lRmFzdCkge1xuICAgIGZ1bmN0aW9uIEZha2VDb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8vIElmIG91ciBvYmplY3QgaXMgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIGl0IHdvdWxkIHJlY2VpdmVcbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gdG9CZWNvbWVGYXN0O1xuICAgIHZhciBmYWtlSW5zdGFuY2UgPSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgZnVuY3Rpb24gZmFrZUFjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmYWtlSW5zdGFuY2UuYmFyO1xuICAgIH1cbiAgICAvLyBoZWxwIFY4IHVuZGVyc3RhbmQgdGhpcyBpcyBhIFwicmVhbFwiIHByb3RvdHlwZSBieSBhY3R1YWxseSB1c2luZ1xuICAgIC8vIHRoZSBmYWtlIGluc3RhbmNlLlxuICAgIGZha2VBY2Nlc3MoKTtcbiAgICBmYWtlQWNjZXNzKCk7XG4gICAgcmV0dXJuIHRvQmVjb21lRmFzdDtcbiAgICAvLyBFdmFsIHByZXZlbnRzIG9wdGltaXphdGlvbiBvZiB0aGlzIG1ldGhvZCAoZXZlbiB0aG91Z2ggdGhpcyBpcyBkZWFkIGNvZGUpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBldmFsKHRvQmVjb21lRmFzdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlayhhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gZm9yIHBlcmZvcm1hbmNlIHRyYWNpbmcqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGZ1bmMpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdmFsID0gZnVuYygpO1xuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdG90YWwgPSBlbmQgLSBzdGFydDtcbiAgICByZXR1cm4geyB0aW1lOiB0b3RhbCwgdmFsdWU6IHZhbCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/utils/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/version.js":
/*!********************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/version.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\n// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nvar VERSION = \"7.1.1\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxjaGV2cm90YWluXFxsaWJfZXNtXFxzcmNcXHZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbmVlZHMgYSBzZXBhcmF0ZSBtb2R1bGUgYXMgdGhpcyBpcyByZXF1aXJlZCBpbnNpZGUgY2hldnJvdGFpbiBwcm9kdWN0aXZlIGNvZGVcbi8vIGFuZCBhbHNvIGluIHRoZSBlbnRyeSBwb2ludCBmb3Igd2VicGFjayhhcGkudHMpLlxuLy8gQSBzZXBhcmF0ZSBmaWxlIGF2b2lkcyBjeWNsaWMgZGVwZW5kZW5jaWVzIGFuZCB3ZWJwYWNrIGVycm9ycy5cbmV4cG9ydCB2YXIgVkVSU0lPTiA9IFwiNy4xLjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/chevrotain/lib_esm/src/version.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/prettier/doc.mjs":
/*!***************************************!*\
  !*** ./node_modules/prettier/doc.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   builders: () => (/* binding */ builders),\n/* harmony export */   \"default\": () => (/* binding */ public_default),\n/* harmony export */   printer: () => (/* binding */ printer),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/document/public.js\nvar public_exports = {};\n__export(public_exports, {\n  builders: () => builders,\n  printer: () => printer,\n  utils: () => utils\n});\n\n// src/document/constants.js\nvar DOC_TYPE_STRING = \"string\";\nvar DOC_TYPE_ARRAY = \"array\";\nvar DOC_TYPE_CURSOR = \"cursor\";\nvar DOC_TYPE_INDENT = \"indent\";\nvar DOC_TYPE_ALIGN = \"align\";\nvar DOC_TYPE_TRIM = \"trim\";\nvar DOC_TYPE_GROUP = \"group\";\nvar DOC_TYPE_FILL = \"fill\";\nvar DOC_TYPE_IF_BREAK = \"if-break\";\nvar DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";\nvar DOC_TYPE_LINE_SUFFIX = \"line-suffix\";\nvar DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";\nvar DOC_TYPE_LINE = \"line\";\nvar DOC_TYPE_LABEL = \"label\";\nvar DOC_TYPE_BREAK_PARENT = \"break-parent\";\nvar VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([\n  DOC_TYPE_CURSOR,\n  DOC_TYPE_INDENT,\n  DOC_TYPE_ALIGN,\n  DOC_TYPE_TRIM,\n  DOC_TYPE_GROUP,\n  DOC_TYPE_FILL,\n  DOC_TYPE_IF_BREAK,\n  DOC_TYPE_INDENT_IF_BREAK,\n  DOC_TYPE_LINE_SUFFIX,\n  DOC_TYPE_LINE_SUFFIX_BOUNDARY,\n  DOC_TYPE_LINE,\n  DOC_TYPE_LABEL,\n  DOC_TYPE_BREAK_PARENT\n]);\n\n// scripts/build/shims/at.js\nvar at = (isOptionalObject, object, index) => {\n  if (isOptionalObject && (object === void 0 || object === null)) {\n    return;\n  }\n  if (Array.isArray(object) || typeof object === \"string\") {\n    return object[index < 0 ? object.length + index : index];\n  }\n  return object.at(index);\n};\nvar at_default = at;\n\n// node_modules/trim-newlines/index.js\nfunction trimNewlinesEnd(string) {\n  let end = string.length;\n  while (end > 0 && (string[end - 1] === \"\\r\" || string[end - 1] === \"\\n\")) {\n    end--;\n  }\n  return end < string.length ? string.slice(0, end) : string;\n}\n\n// src/document/utils/get-doc-type.js\nfunction getDocType(doc) {\n  if (typeof doc === \"string\") {\n    return DOC_TYPE_STRING;\n  }\n  if (Array.isArray(doc)) {\n    return DOC_TYPE_ARRAY;\n  }\n  if (!doc) {\n    return;\n  }\n  const { type } = doc;\n  if (VALID_OBJECT_DOC_TYPES.has(type)) {\n    return type;\n  }\n}\nvar get_doc_type_default = getDocType;\n\n// src/document/invalid-doc-error.js\nvar disjunctionListFormat = (list) => new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);\nfunction getDocErrorMessage(doc) {\n  const type = doc === null ? \"null\" : typeof doc;\n  if (type !== \"string\" && type !== \"object\") {\n    return `Unexpected doc '${type}', \nExpected it to be 'string' or 'object'.`;\n  }\n  if (get_doc_type_default(doc)) {\n    throw new Error(\"doc is valid.\");\n  }\n  const objectType = Object.prototype.toString.call(doc);\n  if (objectType !== \"[object Object]\") {\n    return `Unexpected doc '${objectType}'.`;\n  }\n  const EXPECTED_TYPE_VALUES = disjunctionListFormat(\n    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)\n  );\n  return `Unexpected doc.type '${doc.type}'.\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;\n}\nvar InvalidDocError = class extends Error {\n  name = \"InvalidDocError\";\n  constructor(doc) {\n    super(getDocErrorMessage(doc));\n    this.doc = doc;\n  }\n};\nvar invalid_doc_error_default = InvalidDocError;\n\n// src/document/utils/traverse-doc.js\nvar traverseDocOnExitStackMarker = {};\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  const docsStack = [doc];\n  while (docsStack.length > 0) {\n    const doc2 = docsStack.pop();\n    if (doc2 === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n    if (onExit) {\n      docsStack.push(doc2, traverseDocOnExitStackMarker);\n    }\n    const docType = get_doc_type_default(doc2);\n    if (!docType) {\n      throw new invalid_doc_error_default(doc2);\n    }\n    if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {\n      continue;\n    }\n    switch (docType) {\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;\n        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(parts[i]);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n        docsStack.push(doc2.flatContents, doc2.breakContents);\n        break;\n      case DOC_TYPE_GROUP:\n        if (shouldTraverseConditionalGroups && doc2.expandedStates) {\n          for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(doc2.expandedStates[i]);\n          }\n        } else {\n          docsStack.push(doc2.contents);\n        }\n        break;\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        docsStack.push(doc2.contents);\n        break;\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nvar traverse_doc_default = traverseDoc;\n\n// src/document/utils.js\nfunction mapDoc(doc, cb) {\n  if (typeof doc === \"string\") {\n    return cb(doc);\n  }\n  const mapped = /* @__PURE__ */ new Map();\n  return rec(doc);\n  function rec(doc2) {\n    if (mapped.has(doc2)) {\n      return mapped.get(doc2);\n    }\n    const result = process2(doc2);\n    mapped.set(doc2, result);\n    return result;\n  }\n  function process2(doc2) {\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_ARRAY:\n        return cb(doc2.map(rec));\n      case DOC_TYPE_FILL:\n        return cb({ ...doc2, parts: doc2.parts.map(rec) });\n      case DOC_TYPE_IF_BREAK:\n        return cb({\n          ...doc2,\n          breakContents: rec(doc2.breakContents),\n          flatContents: rec(doc2.flatContents)\n        });\n      case DOC_TYPE_GROUP: {\n        let { expandedStates, contents } = doc2;\n        if (expandedStates) {\n          expandedStates = expandedStates.map(rec);\n          contents = expandedStates[0];\n        } else {\n          contents = rec(contents);\n        }\n        return cb({ ...doc2, contents, expandedStates });\n      }\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        return cb({ ...doc2, contents: rec(doc2.contents) });\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        return cb(doc2);\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nfunction findInDoc(doc, fn, defaultValue) {\n  let result = defaultValue;\n  let shouldSkipFurtherProcessing = false;\n  function findInDocOnEnterFn(doc2) {\n    if (shouldSkipFurtherProcessing) {\n      return false;\n    }\n    const maybeResult = fn(doc2);\n    if (maybeResult !== void 0) {\n      shouldSkipFurtherProcessing = true;\n      result = maybeResult;\n    }\n  }\n  traverse_doc_default(doc, findInDocOnEnterFn);\n  return result;\n}\nfunction willBreakFn(doc) {\n  if (doc.type === DOC_TYPE_GROUP && doc.break) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_LINE && doc.hard) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_BREAK_PARENT) {\n    return true;\n  }\n}\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = at_default(\n      /* isOptionalObject */\n      false,\n      groupStack,\n      -1\n    );\n    if (!parentGroup.expandedStates && !parentGroup.break) {\n      parentGroup.break = \"propagated\";\n    }\n  }\n  return null;\n}\nfunction propagateBreaks(doc) {\n  const alreadyVisitedSet = /* @__PURE__ */ new Set();\n  const groupStack = [];\n  function propagateBreaksOnEnterFn(doc2) {\n    if (doc2.type === DOC_TYPE_BREAK_PARENT) {\n      breakParentGroup(groupStack);\n    }\n    if (doc2.type === DOC_TYPE_GROUP) {\n      groupStack.push(doc2);\n      if (alreadyVisitedSet.has(doc2)) {\n        return false;\n      }\n      alreadyVisitedSet.add(doc2);\n    }\n  }\n  function propagateBreaksOnExitFn(doc2) {\n    if (doc2.type === DOC_TYPE_GROUP) {\n      const group2 = groupStack.pop();\n      if (group2.break) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n  traverse_doc_default(\n    doc,\n    propagateBreaksOnEnterFn,\n    propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true\n  );\n}\nfunction removeLinesFn(doc) {\n  if (doc.type === DOC_TYPE_LINE && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  }\n  if (doc.type === DOC_TYPE_IF_BREAK) {\n    return doc.flatContents;\n  }\n  return doc;\n}\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\nfunction stripTrailingHardlineFromParts(parts) {\n  parts = [...parts];\n  while (parts.length >= 2 && at_default(\n    /* isOptionalObject */\n    false,\n    parts,\n    -2\n  ).type === DOC_TYPE_LINE && at_default(\n    /* isOptionalObject */\n    false,\n    parts,\n    -1\n  ).type === DOC_TYPE_BREAK_PARENT) {\n    parts.length -= 2;\n  }\n  if (parts.length > 0) {\n    const lastPart = stripTrailingHardlineFromDoc(at_default(\n      /* isOptionalObject */\n      false,\n      parts,\n      -1\n    ));\n    parts[parts.length - 1] = lastPart;\n  }\n  return parts;\n}\nfunction stripTrailingHardlineFromDoc(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_GROUP:\n    case DOC_TYPE_LINE_SUFFIX:\n    case DOC_TYPE_LABEL: {\n      const contents = stripTrailingHardlineFromDoc(doc.contents);\n      return { ...doc, contents };\n    }\n    case DOC_TYPE_IF_BREAK:\n      return {\n        ...doc,\n        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),\n        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)\n      };\n    case DOC_TYPE_FILL:\n      return { ...doc, parts: stripTrailingHardlineFromParts(doc.parts) };\n    case DOC_TYPE_ARRAY:\n      return stripTrailingHardlineFromParts(doc);\n    case DOC_TYPE_STRING:\n      return trimNewlinesEnd(doc);\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction stripTrailingHardline(doc) {\n  return stripTrailingHardlineFromDoc(cleanDoc(doc));\n}\nfunction cleanDocFn(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_FILL:\n      if (doc.parts.every((part) => part === \"\")) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_GROUP:\n      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n        return \"\";\n      }\n      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n        return doc.contents;\n      }\n      break;\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_LINE_SUFFIX:\n      if (!doc.contents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_IF_BREAK:\n      if (!doc.flatContents && !doc.breakContents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_ARRAY: {\n      const parts = [];\n      for (const part of doc) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];\n        if (typeof currentPart === \"string\" && typeof at_default(\n          /* isOptionalObject */\n          false,\n          parts,\n          -1\n        ) === \"string\") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return \"\";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return parts;\n    }\n    case DOC_TYPE_STRING:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_LABEL:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction cleanDoc(doc) {\n  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n}\nfunction replaceEndOfLine(doc, replacement = literalline) {\n  return mapDoc(\n    doc,\n    (currentDoc) => typeof currentDoc === \"string\" ? join(replacement, currentDoc.split(\"\\n\")) : currentDoc\n  );\n}\nfunction canBreakFn(doc) {\n  if (doc.type === DOC_TYPE_LINE) {\n    return true;\n  }\n}\nfunction canBreak(doc) {\n  return findInDoc(doc, canBreakFn, false);\n}\n\n// src/document/utils/assert-doc.js\nvar noop = () => {\n};\nvar assertDoc =  true ? noop : 0;\nvar assertDocArray =  true ? noop : 0;\nvar assertDocFillParts =  true ? noop : (\n  /**\n   * @param {Doc[]} parts\n   */\n  0\n);\n\n// src/document/builders.js\nfunction indent(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_INDENT, contents };\n}\nfunction align(widthOrString, contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };\n}\nfunction group(contents, opts = {}) {\n  assertDoc(contents);\n  assertDocArray(\n    opts.expandedStates,\n    /* optional */\n    true\n  );\n  return {\n    type: DOC_TYPE_GROUP,\n    id: opts.id,\n    contents,\n    break: Boolean(opts.shouldBreak),\n    expandedStates: opts.expandedStates\n  };\n}\nfunction dedentToRoot(contents) {\n  return align(Number.NEGATIVE_INFINITY, contents);\n}\nfunction markAsRoot(contents) {\n  return align({ type: \"root\" }, contents);\n}\nfunction dedent(contents) {\n  return align(-1, contents);\n}\nfunction conditionalGroup(states, opts) {\n  return group(states[0], { ...opts, expandedStates: states });\n}\nfunction fill(parts) {\n  assertDocFillParts(parts);\n  return { type: DOC_TYPE_FILL, parts };\n}\nfunction ifBreak(breakContents, flatContents = \"\", opts = {}) {\n  assertDoc(breakContents);\n  if (flatContents !== \"\") {\n    assertDoc(flatContents);\n  }\n  return {\n    type: DOC_TYPE_IF_BREAK,\n    breakContents,\n    flatContents,\n    groupId: opts.groupId\n  };\n}\nfunction indentIfBreak(contents, opts) {\n  assertDoc(contents);\n  return {\n    type: DOC_TYPE_INDENT_IF_BREAK,\n    contents,\n    groupId: opts.groupId,\n    negate: opts.negate\n  };\n}\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_LINE_SUFFIX, contents };\n}\nvar lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };\nvar breakParent = { type: DOC_TYPE_BREAK_PARENT };\nvar trim = { type: DOC_TYPE_TRIM };\nvar hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };\nvar literallineWithoutBreakParent = {\n  type: DOC_TYPE_LINE,\n  hard: true,\n  literal: true\n};\nvar line = { type: DOC_TYPE_LINE };\nvar softline = { type: DOC_TYPE_LINE, soft: true };\nvar hardline = [hardlineWithoutBreakParent, breakParent];\nvar literalline = [literallineWithoutBreakParent, breakParent];\nvar cursor = { type: DOC_TYPE_CURSOR };\nfunction join(separator, docs) {\n  assertDoc(separator);\n  assertDocArray(docs);\n  const parts = [];\n  for (let i = 0; i < docs.length; i++) {\n    if (i !== 0) {\n      parts.push(separator);\n    }\n    parts.push(docs[i]);\n  }\n  return parts;\n}\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  assertDoc(doc);\n  let aligned = doc;\n  if (size > 0) {\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    aligned = align(size % tabWidth, aligned);\n    aligned = align(Number.NEGATIVE_INFINITY, aligned);\n  }\n  return aligned;\n}\nfunction label(label2, contents) {\n  assertDoc(contents);\n  return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;\n}\n\n// scripts/build/shims/string-replace-all.js\nvar stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {\n  if (isOptionalObject && (original === void 0 || original === null)) {\n    return;\n  }\n  if (original.replaceAll) {\n    return original.replaceAll(pattern, replacement);\n  }\n  if (pattern.global) {\n    return original.replace(pattern, replacement);\n  }\n  return original.split(pattern).join(replacement);\n};\nvar string_replace_all_default = stringReplaceAll;\n\n// src/common/end-of-line.js\nfunction convertEndOfLineToChars(value) {\n  switch (value) {\n    case \"cr\":\n      return \"\\r\";\n    case \"crlf\":\n      return \"\\r\\n\";\n    default:\n      return \"\\n\";\n  }\n}\n\n// node_modules/emoji-regex/index.mjs\nvar emoji_regex_default = () => {\n  return /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE89\\uDE8F-\\uDEC2\\uDEC6\\uDECE-\\uDEDC\\uDEDF-\\uDEE9]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n\n// node_modules/get-east-asian-width/lookup.js\nfunction isFullWidth(x) {\n  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;\n}\nfunction isWide(x) {\n  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;\n}\n\n// node_modules/get-east-asian-width/index.js\nvar _isNarrowWidth = (codePoint) => !(isFullWidth(codePoint) || isWide(codePoint));\n\n// src/utils/get-string-width.js\nvar notAsciiRegex = /[^\\x20-\\x7F]/u;\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n  text = text.replace(emoji_regex_default(), \"  \");\n  let width = 0;\n  for (const character of text) {\n    const codePoint = character.codePointAt(0);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    width += _isNarrowWidth(codePoint) ? 1 : 2;\n  }\n  return width;\n}\nvar get_string_width_default = getStringWidth;\n\n// src/document/printer.js\nvar MODE_BREAK = Symbol(\"MODE_BREAK\");\nvar MODE_FLAT = Symbol(\"MODE_FLAT\");\nvar CURSOR_PLACEHOLDER = Symbol(\"cursor\");\nvar DOC_FILL_PRINTED_LENGTH = Symbol(\"DOC_FILL_PRINTED_LENGTH\");\nfunction rootIndent() {\n  return { value: \"\", length: 0, queue: [] };\n}\nfunction makeIndent(ind, options) {\n  return generateInd(ind, { type: \"indent\" }, options);\n}\nfunction makeAlign(indent2, widthOrDoc, options) {\n  if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n    return indent2.root || rootIndent();\n  }\n  if (widthOrDoc < 0) {\n    return generateInd(indent2, { type: \"dedent\" }, options);\n  }\n  if (!widthOrDoc) {\n    return indent2;\n  }\n  if (widthOrDoc.type === \"root\") {\n    return { ...indent2, root: indent2 };\n  }\n  const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n  return generateInd(indent2, { type: alignType, n: widthOrDoc }, options);\n}\nfunction generateInd(ind, newPart, options) {\n  const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n  let value = \"\";\n  let length = 0;\n  let lastTabs = 0;\n  let lastSpaces = 0;\n  for (const part of queue) {\n    switch (part.type) {\n      case \"indent\":\n        flush();\n        if (options.useTabs) {\n          addTabs(1);\n        } else {\n          addSpaces(options.tabWidth);\n        }\n        break;\n      case \"stringAlign\":\n        flush();\n        value += part.n;\n        length += part.n.length;\n        break;\n      case \"numberAlign\":\n        lastTabs += 1;\n        lastSpaces += part.n;\n        break;\n      default:\n        throw new Error(`Unexpected type '${part.type}'`);\n    }\n  }\n  flushSpaces();\n  return { ...ind, value, length, queue };\n  function addTabs(count) {\n    value += \"\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n    resetLast();\n  }\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n    resetLast();\n  }\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\nfunction trim2(out) {\n  let trimCount = 0;\n  let cursorCount = 0;\n  let outIndex = out.length;\n  outer: while (outIndex--) {\n    const last = out[outIndex];\n    if (last === CURSOR_PLACEHOLDER) {\n      cursorCount++;\n      continue;\n    }\n    if (false) {}\n    for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {\n      const char = last[charIndex];\n      if (char === \" \" || char === \"\t\") {\n        trimCount++;\n      } else {\n        out[outIndex] = last.slice(0, charIndex + 1);\n        break outer;\n      }\n    }\n  }\n  if (trimCount > 0 || cursorCount > 0) {\n    out.length = outIndex + 1;\n    while (cursorCount-- > 0) {\n      out.push(CURSOR_PLACEHOLDER);\n    }\n  }\n  return trimCount;\n}\nfunction fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {\n  if (width === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  const out = [];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[--restIdx]);\n      continue;\n    }\n    const { mode, doc } = cmds.pop();\n    const docType = get_doc_type_default(doc);\n    switch (docType) {\n      case DOC_TYPE_STRING:\n        out.push(doc);\n        width -= get_string_width_default(doc);\n        break;\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts;\n        const end = doc[DOC_FILL_PRINTED_LENGTH] ?? 0;\n        for (let i = parts.length - 1; i >= end; i--) {\n          cmds.push({ mode, doc: parts[i] });\n        }\n        break;\n      }\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n        cmds.push({ mode, doc: doc.contents });\n        break;\n      case DOC_TYPE_TRIM:\n        width += trim2(out);\n        break;\n      case DOC_TYPE_GROUP: {\n        if (mustBeFlat && doc.break) {\n          return false;\n        }\n        const groupMode = doc.break ? MODE_BREAK : mode;\n        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(\n          /* isOptionalObject */\n          false,\n          doc.expandedStates,\n          -1\n        ) : doc.contents;\n        cmds.push({ mode: groupMode, doc: contents });\n        break;\n      }\n      case DOC_TYPE_IF_BREAK: {\n        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n        if (contents) {\n          cmds.push({ mode, doc: contents });\n        }\n        break;\n      }\n      case DOC_TYPE_LINE:\n        if (mode === MODE_BREAK || doc.hard) {\n          return true;\n        }\n        if (!doc.soft) {\n          out.push(\" \");\n          width--;\n        }\n        break;\n      case DOC_TYPE_LINE_SUFFIX:\n        hasLineSuffix = true;\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (hasLineSuffix) {\n          return false;\n        }\n        break;\n    }\n  }\n  return false;\n}\nfunction printDocToString(doc, options) {\n  const groupModeMap = {};\n  const width = options.printWidth;\n  const newLine = convertEndOfLineToChars(options.endOfLine);\n  let pos = 0;\n  const cmds = [{ ind: rootIndent(), mode: MODE_BREAK, doc }];\n  const out = [];\n  let shouldRemeasure = false;\n  const lineSuffix2 = [];\n  let printedCursorCount = 0;\n  propagateBreaks(doc);\n  while (cmds.length > 0) {\n    const { ind, mode, doc: doc2 } = cmds.pop();\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_STRING: {\n        const formatted = newLine !== \"\\n\" ? string_replace_all_default(\n          /* isOptionalObject */\n          false,\n          doc2,\n          \"\\n\",\n          newLine\n        ) : doc2;\n        out.push(formatted);\n        if (cmds.length > 0) {\n          pos += get_string_width_default(formatted);\n        }\n        break;\n      }\n      case DOC_TYPE_ARRAY:\n        for (let i = doc2.length - 1; i >= 0; i--) {\n          cmds.push({ ind, mode, doc: doc2[i] });\n        }\n        break;\n      case DOC_TYPE_CURSOR:\n        if (printedCursorCount >= 2) {\n          throw new Error(\"There are too many 'cursor' in doc.\");\n        }\n        out.push(CURSOR_PLACEHOLDER);\n        printedCursorCount++;\n        break;\n      case DOC_TYPE_INDENT:\n        cmds.push({ ind: makeIndent(ind, options), mode, doc: doc2.contents });\n        break;\n      case DOC_TYPE_ALIGN:\n        cmds.push({\n          ind: makeAlign(ind, doc2.n, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        pos -= trim2(out);\n        break;\n      case DOC_TYPE_GROUP:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!shouldRemeasure) {\n              cmds.push({\n                ind,\n                mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                doc: doc2.contents\n              });\n              break;\n            }\n          // fallthrough\n          case MODE_BREAK: {\n            shouldRemeasure = false;\n            const next = { ind, mode: MODE_FLAT, doc: doc2.contents };\n            const rem = width - pos;\n            const hasLineSuffix = lineSuffix2.length > 0;\n            if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {\n              cmds.push(next);\n            } else {\n              if (doc2.expandedStates) {\n                const mostExpanded = at_default(\n                  /* isOptionalObject */\n                  false,\n                  doc2.expandedStates,\n                  -1\n                );\n                if (doc2.break) {\n                  cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });\n                  break;\n                } else {\n                  for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                    if (i >= doc2.expandedStates.length) {\n                      cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });\n                      break;\n                    } else {\n                      const state = doc2.expandedStates[i];\n                      const cmd = { ind, mode: MODE_FLAT, doc: state };\n                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {\n                        cmds.push(cmd);\n                        break;\n                      }\n                    }\n                  }\n                }\n              } else {\n                cmds.push({ ind, mode: MODE_BREAK, doc: doc2.contents });\n              }\n            }\n            break;\n          }\n        }\n        if (doc2.id) {\n          groupModeMap[doc2.id] = at_default(\n            /* isOptionalObject */\n            false,\n            cmds,\n            -1\n          ).mode;\n        }\n        break;\n      // Fills each line with as much code as possible before moving to a new\n      // line with the same indentation.\n      //\n      // Expects doc.parts to be an array of alternating content and\n      // whitespace. The whitespace contains the linebreaks.\n      //\n      // For example:\n      //   [\"I\", line, \"love\", line, \"monkeys\"]\n      // or\n      //   [{ type: group, ... }, softline, { type: group, ... }]\n      //\n      // It uses this parts structure to handle three main layout cases:\n      // * The first two content items fit on the same line without\n      //   breaking\n      //   -> output the first content item and the whitespace \"flat\".\n      // * Only the first content item fits on the line without breaking\n      //   -> output the first content item \"flat\" and the whitespace with\n      //   \"break\".\n      // * Neither content item fits on the line without breaking\n      //   -> output the first content item and the whitespace with \"break\".\n      case DOC_TYPE_FILL: {\n        const rem = width - pos;\n        const offset = doc2[DOC_FILL_PRINTED_LENGTH] ?? 0;\n        const { parts } = doc2;\n        const length = parts.length - offset;\n        if (length === 0) {\n          break;\n        }\n        const content = parts[offset + 0];\n        const whitespace = parts[offset + 1];\n        const contentFlatCmd = { ind, mode: MODE_FLAT, doc: content };\n        const contentBreakCmd = { ind, mode: MODE_BREAK, doc: content };\n        const contentFits = fits(\n          contentFlatCmd,\n          [],\n          rem,\n          lineSuffix2.length > 0,\n          groupModeMap,\n          true\n        );\n        if (length === 1) {\n          if (contentFits) {\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        const whitespaceFlatCmd = { ind, mode: MODE_FLAT, doc: whitespace };\n        const whitespaceBreakCmd = { ind, mode: MODE_BREAK, doc: whitespace };\n        if (length === 2) {\n          if (contentFits) {\n            cmds.push(whitespaceFlatCmd, contentFlatCmd);\n          } else {\n            cmds.push(whitespaceBreakCmd, contentBreakCmd);\n          }\n          break;\n        }\n        const secondContent = parts[offset + 2];\n        const remainingCmd = {\n          ind,\n          mode,\n          doc: { ...doc2, [DOC_FILL_PRINTED_LENGTH]: offset + 2 }\n        };\n        const firstAndSecondContentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: [content, whitespace, secondContent]\n        };\n        const firstAndSecondContentFits = fits(\n          firstAndSecondContentFlatCmd,\n          [],\n          rem,\n          lineSuffix2.length > 0,\n          groupModeMap,\n          true\n        );\n        if (firstAndSecondContentFits) {\n          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n        } else if (contentFits) {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n        } else {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n      case DOC_TYPE_INDENT_IF_BREAK: {\n        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n        if (groupMode === MODE_BREAK) {\n          const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n          if (breakContents) {\n            cmds.push({ ind, mode, doc: breakContents });\n          }\n        }\n        if (groupMode === MODE_FLAT) {\n          const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n          if (flatContents) {\n            cmds.push({ ind, mode, doc: flatContents });\n          }\n        }\n        break;\n      }\n      case DOC_TYPE_LINE_SUFFIX:\n        lineSuffix2.push({ ind, mode, doc: doc2.contents });\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (lineSuffix2.length > 0) {\n          cmds.push({ ind, mode, doc: hardlineWithoutBreakParent });\n        }\n        break;\n      case DOC_TYPE_LINE:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!doc2.hard) {\n              if (!doc2.soft) {\n                out.push(\" \");\n                pos += 1;\n              }\n              break;\n            } else {\n              shouldRemeasure = true;\n            }\n          // fallthrough\n          case MODE_BREAK:\n            if (lineSuffix2.length > 0) {\n              cmds.push({ ind, mode, doc: doc2 }, ...lineSuffix2.reverse());\n              lineSuffix2.length = 0;\n              break;\n            }\n            if (doc2.literal) {\n              if (ind.root) {\n                out.push(newLine, ind.root.value);\n                pos = ind.root.length;\n              } else {\n                out.push(newLine);\n                pos = 0;\n              }\n            } else {\n              pos -= trim2(out);\n              out.push(newLine + ind.value);\n              pos = ind.length;\n            }\n            break;\n        }\n        break;\n      case DOC_TYPE_LABEL:\n        cmds.push({ ind, mode, doc: doc2.contents });\n        break;\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n    if (cmds.length === 0 && lineSuffix2.length > 0) {\n      cmds.push(...lineSuffix2.reverse());\n      lineSuffix2.length = 0;\n    }\n  }\n  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);\n  if (cursorPlaceholderIndex !== -1) {\n    const otherCursorPlaceholderIndex = out.indexOf(\n      CURSOR_PLACEHOLDER,\n      cursorPlaceholderIndex + 1\n    );\n    if (otherCursorPlaceholderIndex === -1) {\n      return {\n        formatted: out.filter((char) => char !== CURSOR_PLACEHOLDER).join(\"\")\n      };\n    }\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n  return { formatted: out.join(\"\") };\n}\n\n// src/document/public.js\nvar builders = {\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  fill,\n  lineSuffix,\n  lineSuffixBoundary,\n  cursor,\n  breakParent,\n  ifBreak,\n  trim,\n  indent,\n  indentIfBreak,\n  align,\n  addAlignmentToDoc,\n  markAsRoot,\n  dedentToRoot,\n  dedent,\n  hardlineWithoutBreakParent,\n  literallineWithoutBreakParent,\n  label,\n  // TODO: Remove this in v4\n  concat: (parts) => parts\n};\nvar printer = { printDocToString };\nvar utils = {\n  willBreak,\n  traverseDoc: traverse_doc_default,\n  findInDoc,\n  mapDoc,\n  removeLines,\n  stripTrailingHardline,\n  replaceEndOfLine,\n  canBreak\n};\n\n// with-default-export:src/document/public.js\nvar public_default = public_exports;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmV0dGllci9kb2MubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxxQkFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFJLFVBQVUsQ0FTN0I7QUFDRCxxQkFBcUIsS0FBSSxVQUFVLENBVWxDO0FBQ0QseUJBQXlCLEtBQUk7QUFDN0I7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxFQUFFLENBa0JDO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBRVY7QUFDTCwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pELHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBDQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQXlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUEwQztBQUN4RTtBQUNBLGtCQUFrQjtBQUNsQixrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0Esa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixjQUFjLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxwcmV0dGllclxcZG9jLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvZG9jdW1lbnQvcHVibGljLmpzXG52YXIgcHVibGljX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHB1YmxpY19leHBvcnRzLCB7XG4gIGJ1aWxkZXJzOiAoKSA9PiBidWlsZGVycyxcbiAgcHJpbnRlcjogKCkgPT4gcHJpbnRlcixcbiAgdXRpbHM6ICgpID0+IHV0aWxzXG59KTtcblxuLy8gc3JjL2RvY3VtZW50L2NvbnN0YW50cy5qc1xudmFyIERPQ19UWVBFX1NUUklORyA9IFwic3RyaW5nXCI7XG52YXIgRE9DX1RZUEVfQVJSQVkgPSBcImFycmF5XCI7XG52YXIgRE9DX1RZUEVfQ1VSU09SID0gXCJjdXJzb3JcIjtcbnZhciBET0NfVFlQRV9JTkRFTlQgPSBcImluZGVudFwiO1xudmFyIERPQ19UWVBFX0FMSUdOID0gXCJhbGlnblwiO1xudmFyIERPQ19UWVBFX1RSSU0gPSBcInRyaW1cIjtcbnZhciBET0NfVFlQRV9HUk9VUCA9IFwiZ3JvdXBcIjtcbnZhciBET0NfVFlQRV9GSUxMID0gXCJmaWxsXCI7XG52YXIgRE9DX1RZUEVfSUZfQlJFQUsgPSBcImlmLWJyZWFrXCI7XG52YXIgRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLID0gXCJpbmRlbnQtaWYtYnJlYWtcIjtcbnZhciBET0NfVFlQRV9MSU5FX1NVRkZJWCA9IFwibGluZS1zdWZmaXhcIjtcbnZhciBET0NfVFlQRV9MSU5FX1NVRkZJWF9CT1VOREFSWSA9IFwibGluZS1zdWZmaXgtYm91bmRhcnlcIjtcbnZhciBET0NfVFlQRV9MSU5FID0gXCJsaW5lXCI7XG52YXIgRE9DX1RZUEVfTEFCRUwgPSBcImxhYmVsXCI7XG52YXIgRE9DX1RZUEVfQlJFQUtfUEFSRU5UID0gXCJicmVhay1wYXJlbnRcIjtcbnZhciBWQUxJRF9PQkpFQ1RfRE9DX1RZUEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBET0NfVFlQRV9DVVJTT1IsXG4gIERPQ19UWVBFX0lOREVOVCxcbiAgRE9DX1RZUEVfQUxJR04sXG4gIERPQ19UWVBFX1RSSU0sXG4gIERPQ19UWVBFX0dST1VQLFxuICBET0NfVFlQRV9GSUxMLFxuICBET0NfVFlQRV9JRl9CUkVBSyxcbiAgRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLLFxuICBET0NfVFlQRV9MSU5FX1NVRkZJWCxcbiAgRE9DX1RZUEVfTElORV9TVUZGSVhfQk9VTkRBUlksXG4gIERPQ19UWVBFX0xJTkUsXG4gIERPQ19UWVBFX0xBQkVMLFxuICBET0NfVFlQRV9CUkVBS19QQVJFTlRcbl0pO1xuXG4vLyBzY3JpcHRzL2J1aWxkL3NoaW1zL2F0LmpzXG52YXIgYXQgPSAoaXNPcHRpb25hbE9iamVjdCwgb2JqZWN0LCBpbmRleCkgPT4ge1xuICBpZiAoaXNPcHRpb25hbE9iamVjdCAmJiAob2JqZWN0ID09PSB2b2lkIDAgfHwgb2JqZWN0ID09PSBudWxsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0W2luZGV4IDwgMCA/IG9iamVjdC5sZW5ndGggKyBpbmRleCA6IGluZGV4XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0LmF0KGluZGV4KTtcbn07XG52YXIgYXRfZGVmYXVsdCA9IGF0O1xuXG4vLyBub2RlX21vZHVsZXMvdHJpbS1uZXdsaW5lcy9pbmRleC5qc1xuZnVuY3Rpb24gdHJpbU5ld2xpbmVzRW5kKHN0cmluZykge1xuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKGVuZCA+IDAgJiYgKHN0cmluZ1tlbmQgLSAxXSA9PT0gXCJcXHJcIiB8fCBzdHJpbmdbZW5kIC0gMV0gPT09IFwiXFxuXCIpKSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIGVuZCA8IHN0cmluZy5sZW5ndGggPyBzdHJpbmcuc2xpY2UoMCwgZW5kKSA6IHN0cmluZztcbn1cblxuLy8gc3JjL2RvY3VtZW50L3V0aWxzL2dldC1kb2MtdHlwZS5qc1xuZnVuY3Rpb24gZ2V0RG9jVHlwZShkb2MpIHtcbiAgaWYgKHR5cGVvZiBkb2MgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gRE9DX1RZUEVfU1RSSU5HO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICByZXR1cm4gRE9DX1RZUEVfQVJSQVk7XG4gIH1cbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyB0eXBlIH0gPSBkb2M7XG4gIGlmIChWQUxJRF9PQkpFQ1RfRE9DX1RZUEVTLmhhcyh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59XG52YXIgZ2V0X2RvY190eXBlX2RlZmF1bHQgPSBnZXREb2NUeXBlO1xuXG4vLyBzcmMvZG9jdW1lbnQvaW52YWxpZC1kb2MtZXJyb3IuanNcbnZhciBkaXNqdW5jdGlvbkxpc3RGb3JtYXQgPSAobGlzdCkgPT4gbmV3IEludGwuTGlzdEZvcm1hdChcImVuLVVTXCIsIHsgdHlwZTogXCJkaXNqdW5jdGlvblwiIH0pLmZvcm1hdChsaXN0KTtcbmZ1bmN0aW9uIGdldERvY0Vycm9yTWVzc2FnZShkb2MpIHtcbiAgY29uc3QgdHlwZSA9IGRvYyA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGRvYztcbiAgaWYgKHR5cGUgIT09IFwic3RyaW5nXCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBgVW5leHBlY3RlZCBkb2MgJyR7dHlwZX0nLCBcbkV4cGVjdGVkIGl0IHRvIGJlICdzdHJpbmcnIG9yICdvYmplY3QnLmA7XG4gIH1cbiAgaWYgKGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb2MgaXMgdmFsaWQuXCIpO1xuICB9XG4gIGNvbnN0IG9iamVjdFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jKTtcbiAgaWYgKG9iamVjdFR5cGUgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICByZXR1cm4gYFVuZXhwZWN0ZWQgZG9jICcke29iamVjdFR5cGV9Jy5gO1xuICB9XG4gIGNvbnN0IEVYUEVDVEVEX1RZUEVfVkFMVUVTID0gZGlzanVuY3Rpb25MaXN0Rm9ybWF0KFxuICAgIFsuLi5WQUxJRF9PQkpFQ1RfRE9DX1RZUEVTXS5tYXAoKHR5cGUyKSA9PiBgJyR7dHlwZTJ9J2ApXG4gICk7XG4gIHJldHVybiBgVW5leHBlY3RlZCBkb2MudHlwZSAnJHtkb2MudHlwZX0nLlxuRXhwZWN0ZWQgaXQgdG8gYmUgJHtFWFBFQ1RFRF9UWVBFX1ZBTFVFU30uYDtcbn1cbnZhciBJbnZhbGlkRG9jRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiSW52YWxpZERvY0Vycm9yXCI7XG4gIGNvbnN0cnVjdG9yKGRvYykge1xuICAgIHN1cGVyKGdldERvY0Vycm9yTWVzc2FnZShkb2MpKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgfVxufTtcbnZhciBpbnZhbGlkX2RvY19lcnJvcl9kZWZhdWx0ID0gSW52YWxpZERvY0Vycm9yO1xuXG4vLyBzcmMvZG9jdW1lbnQvdXRpbHMvdHJhdmVyc2UtZG9jLmpzXG52YXIgdHJhdmVyc2VEb2NPbkV4aXRTdGFja01hcmtlciA9IHt9O1xuZnVuY3Rpb24gdHJhdmVyc2VEb2MoZG9jLCBvbkVudGVyLCBvbkV4aXQsIHNob3VsZFRyYXZlcnNlQ29uZGl0aW9uYWxHcm91cHMpIHtcbiAgY29uc3QgZG9jc1N0YWNrID0gW2RvY107XG4gIHdoaWxlIChkb2NzU3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGRvYzIgPSBkb2NzU3RhY2sucG9wKCk7XG4gICAgaWYgKGRvYzIgPT09IHRyYXZlcnNlRG9jT25FeGl0U3RhY2tNYXJrZXIpIHtcbiAgICAgIG9uRXhpdChkb2NzU3RhY2sucG9wKCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvbkV4aXQpIHtcbiAgICAgIGRvY3NTdGFjay5wdXNoKGRvYzIsIHRyYXZlcnNlRG9jT25FeGl0U3RhY2tNYXJrZXIpO1xuICAgIH1cbiAgICBjb25zdCBkb2NUeXBlID0gZ2V0X2RvY190eXBlX2RlZmF1bHQoZG9jMik7XG4gICAgaWYgKCFkb2NUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgaW52YWxpZF9kb2NfZXJyb3JfZGVmYXVsdChkb2MyKTtcbiAgICB9XG4gICAgaWYgKChvbkVudGVyID09IG51bGwgPyB2b2lkIDAgOiBvbkVudGVyKGRvYzIpKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRvY1R5cGUpIHtcbiAgICAgIGNhc2UgRE9DX1RZUEVfQVJSQVk6XG4gICAgICBjYXNlIERPQ19UWVBFX0ZJTEw6IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBkb2NUeXBlID09PSBET0NfVFlQRV9BUlJBWSA/IGRvYzIgOiBkb2MyLnBhcnRzO1xuICAgICAgICBmb3IgKGxldCBpYyA9IHBhcnRzLmxlbmd0aCwgaSA9IGljIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBkb2NzU3RhY2sucHVzaChwYXJ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIERPQ19UWVBFX0lGX0JSRUFLOlxuICAgICAgICBkb2NzU3RhY2sucHVzaChkb2MyLmZsYXRDb250ZW50cywgZG9jMi5icmVha0NvbnRlbnRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0dST1VQOlxuICAgICAgICBpZiAoc2hvdWxkVHJhdmVyc2VDb25kaXRpb25hbEdyb3VwcyAmJiBkb2MyLmV4cGFuZGVkU3RhdGVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaWMgPSBkb2MyLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCwgaSA9IGljIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGRvY3NTdGFjay5wdXNoKGRvYzIuZXhwYW5kZWRTdGF0ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2NzU3RhY2sucHVzaChkb2MyLmNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfQUxJR046XG4gICAgICBjYXNlIERPQ19UWVBFX0lOREVOVDpcbiAgICAgIGNhc2UgRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLOlxuICAgICAgY2FzZSBET0NfVFlQRV9MQUJFTDpcbiAgICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVg6XG4gICAgICAgIGRvY3NTdGFjay5wdXNoKGRvYzIuY29udGVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfU1RSSU5HOlxuICAgICAgY2FzZSBET0NfVFlQRV9DVVJTT1I6XG4gICAgICBjYXNlIERPQ19UWVBFX1RSSU06XG4gICAgICBjYXNlIERPQ19UWVBFX0xJTkVfU1VGRklYX0JPVU5EQVJZOlxuICAgICAgY2FzZSBET0NfVFlQRV9MSU5FOlxuICAgICAgY2FzZSBET0NfVFlQRV9CUkVBS19QQVJFTlQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfZG9jX2Vycm9yX2RlZmF1bHQoZG9jMik7XG4gICAgfVxuICB9XG59XG52YXIgdHJhdmVyc2VfZG9jX2RlZmF1bHQgPSB0cmF2ZXJzZURvYztcblxuLy8gc3JjL2RvY3VtZW50L3V0aWxzLmpzXG5mdW5jdGlvbiBtYXBEb2MoZG9jLCBjYikge1xuICBpZiAodHlwZW9mIGRvYyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjYihkb2MpO1xuICB9XG4gIGNvbnN0IG1hcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiByZWMoZG9jKTtcbiAgZnVuY3Rpb24gcmVjKGRvYzIpIHtcbiAgICBpZiAobWFwcGVkLmhhcyhkb2MyKSkge1xuICAgICAgcmV0dXJuIG1hcHBlZC5nZXQoZG9jMik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3MyKGRvYzIpO1xuICAgIG1hcHBlZC5zZXQoZG9jMiwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3MyKGRvYzIpIHtcbiAgICBzd2l0Y2ggKGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYzIpKSB7XG4gICAgICBjYXNlIERPQ19UWVBFX0FSUkFZOlxuICAgICAgICByZXR1cm4gY2IoZG9jMi5tYXAocmVjKSk7XG4gICAgICBjYXNlIERPQ19UWVBFX0ZJTEw6XG4gICAgICAgIHJldHVybiBjYih7IC4uLmRvYzIsIHBhcnRzOiBkb2MyLnBhcnRzLm1hcChyZWMpIH0pO1xuICAgICAgY2FzZSBET0NfVFlQRV9JRl9CUkVBSzpcbiAgICAgICAgcmV0dXJuIGNiKHtcbiAgICAgICAgICAuLi5kb2MyLFxuICAgICAgICAgIGJyZWFrQ29udGVudHM6IHJlYyhkb2MyLmJyZWFrQ29udGVudHMpLFxuICAgICAgICAgIGZsYXRDb250ZW50czogcmVjKGRvYzIuZmxhdENvbnRlbnRzKVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgRE9DX1RZUEVfR1JPVVA6IHtcbiAgICAgICAgbGV0IHsgZXhwYW5kZWRTdGF0ZXMsIGNvbnRlbnRzIH0gPSBkb2MyO1xuICAgICAgICBpZiAoZXhwYW5kZWRTdGF0ZXMpIHtcbiAgICAgICAgICBleHBhbmRlZFN0YXRlcyA9IGV4cGFuZGVkU3RhdGVzLm1hcChyZWMpO1xuICAgICAgICAgIGNvbnRlbnRzID0gZXhwYW5kZWRTdGF0ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudHMgPSByZWMoY29udGVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYih7IC4uLmRvYzIsIGNvbnRlbnRzLCBleHBhbmRlZFN0YXRlcyB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRE9DX1RZUEVfQUxJR046XG4gICAgICBjYXNlIERPQ19UWVBFX0lOREVOVDpcbiAgICAgIGNhc2UgRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLOlxuICAgICAgY2FzZSBET0NfVFlQRV9MQUJFTDpcbiAgICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVg6XG4gICAgICAgIHJldHVybiBjYih7IC4uLmRvYzIsIGNvbnRlbnRzOiByZWMoZG9jMi5jb250ZW50cykgfSk7XG4gICAgICBjYXNlIERPQ19UWVBFX1NUUklORzpcbiAgICAgIGNhc2UgRE9DX1RZUEVfQ1VSU09SOlxuICAgICAgY2FzZSBET0NfVFlQRV9UUklNOlxuICAgICAgY2FzZSBET0NfVFlQRV9MSU5FX1NVRkZJWF9CT1VOREFSWTpcbiAgICAgIGNhc2UgRE9DX1RZUEVfTElORTpcbiAgICAgIGNhc2UgRE9DX1RZUEVfQlJFQUtfUEFSRU5UOlxuICAgICAgICByZXR1cm4gY2IoZG9jMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgaW52YWxpZF9kb2NfZXJyb3JfZGVmYXVsdChkb2MyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRJbkRvYyhkb2MsIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgbGV0IHJlc3VsdCA9IGRlZmF1bHRWYWx1ZTtcbiAgbGV0IHNob3VsZFNraXBGdXJ0aGVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBmdW5jdGlvbiBmaW5kSW5Eb2NPbkVudGVyRm4oZG9jMikge1xuICAgIGlmIChzaG91bGRTa2lwRnVydGhlclByb2Nlc3NpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWF5YmVSZXN1bHQgPSBmbihkb2MyKTtcbiAgICBpZiAobWF5YmVSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkU2tpcEZ1cnRoZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IG1heWJlUmVzdWx0O1xuICAgIH1cbiAgfVxuICB0cmF2ZXJzZV9kb2NfZGVmYXVsdChkb2MsIGZpbmRJbkRvY09uRW50ZXJGbik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWxsQnJlYWtGbihkb2MpIHtcbiAgaWYgKGRvYy50eXBlID09PSBET0NfVFlQRV9HUk9VUCAmJiBkb2MuYnJlYWspIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZG9jLnR5cGUgPT09IERPQ19UWVBFX0xJTkUgJiYgZG9jLmhhcmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZG9jLnR5cGUgPT09IERPQ19UWVBFX0JSRUFLX1BBUkVOVCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiB3aWxsQnJlYWsoZG9jKSB7XG4gIHJldHVybiBmaW5kSW5Eb2MoZG9jLCB3aWxsQnJlYWtGbiwgZmFsc2UpO1xufVxuZnVuY3Rpb24gYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKSB7XG4gIGlmIChncm91cFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXJlbnRHcm91cCA9IGF0X2RlZmF1bHQoXG4gICAgICAvKiBpc09wdGlvbmFsT2JqZWN0ICovXG4gICAgICBmYWxzZSxcbiAgICAgIGdyb3VwU3RhY2ssXG4gICAgICAtMVxuICAgICk7XG4gICAgaWYgKCFwYXJlbnRHcm91cC5leHBhbmRlZFN0YXRlcyAmJiAhcGFyZW50R3JvdXAuYnJlYWspIHtcbiAgICAgIHBhcmVudEdyb3VwLmJyZWFrID0gXCJwcm9wYWdhdGVkXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlQnJlYWtzKGRvYykge1xuICBjb25zdCBhbHJlYWR5VmlzaXRlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGdyb3VwU3RhY2sgPSBbXTtcbiAgZnVuY3Rpb24gcHJvcGFnYXRlQnJlYWtzT25FbnRlckZuKGRvYzIpIHtcbiAgICBpZiAoZG9jMi50eXBlID09PSBET0NfVFlQRV9CUkVBS19QQVJFTlQpIHtcbiAgICAgIGJyZWFrUGFyZW50R3JvdXAoZ3JvdXBTdGFjayk7XG4gICAgfVxuICAgIGlmIChkb2MyLnR5cGUgPT09IERPQ19UWVBFX0dST1VQKSB7XG4gICAgICBncm91cFN0YWNrLnB1c2goZG9jMik7XG4gICAgICBpZiAoYWxyZWFkeVZpc2l0ZWRTZXQuaGFzKGRvYzIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFscmVhZHlWaXNpdGVkU2V0LmFkZChkb2MyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGFnYXRlQnJlYWtzT25FeGl0Rm4oZG9jMikge1xuICAgIGlmIChkb2MyLnR5cGUgPT09IERPQ19UWVBFX0dST1VQKSB7XG4gICAgICBjb25zdCBncm91cDIgPSBncm91cFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGdyb3VwMi5icmVhaykge1xuICAgICAgICBicmVha1BhcmVudEdyb3VwKGdyb3VwU3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmF2ZXJzZV9kb2NfZGVmYXVsdChcbiAgICBkb2MsXG4gICAgcHJvcGFnYXRlQnJlYWtzT25FbnRlckZuLFxuICAgIHByb3BhZ2F0ZUJyZWFrc09uRXhpdEZuLFxuICAgIC8qIHNob3VsZFRyYXZlcnNlQ29uZGl0aW9uYWxHcm91cHMgKi9cbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiByZW1vdmVMaW5lc0ZuKGRvYykge1xuICBpZiAoZG9jLnR5cGUgPT09IERPQ19UWVBFX0xJTkUgJiYgIWRvYy5oYXJkKSB7XG4gICAgcmV0dXJuIGRvYy5zb2Z0ID8gXCJcIiA6IFwiIFwiO1xuICB9XG4gIGlmIChkb2MudHlwZSA9PT0gRE9DX1RZUEVfSUZfQlJFQUspIHtcbiAgICByZXR1cm4gZG9jLmZsYXRDb250ZW50cztcbiAgfVxuICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGluZXMoZG9jKSB7XG4gIHJldHVybiBtYXBEb2MoZG9jLCByZW1vdmVMaW5lc0ZuKTtcbn1cbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdIYXJkbGluZUZyb21QYXJ0cyhwYXJ0cykge1xuICBwYXJ0cyA9IFsuLi5wYXJ0c107XG4gIHdoaWxlIChwYXJ0cy5sZW5ndGggPj0gMiAmJiBhdF9kZWZhdWx0KFxuICAgIC8qIGlzT3B0aW9uYWxPYmplY3QgKi9cbiAgICBmYWxzZSxcbiAgICBwYXJ0cyxcbiAgICAtMlxuICApLnR5cGUgPT09IERPQ19UWVBFX0xJTkUgJiYgYXRfZGVmYXVsdChcbiAgICAvKiBpc09wdGlvbmFsT2JqZWN0ICovXG4gICAgZmFsc2UsXG4gICAgcGFydHMsXG4gICAgLTFcbiAgKS50eXBlID09PSBET0NfVFlQRV9CUkVBS19QQVJFTlQpIHtcbiAgICBwYXJ0cy5sZW5ndGggLT0gMjtcbiAgfVxuICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gc3RyaXBUcmFpbGluZ0hhcmRsaW5lRnJvbURvYyhhdF9kZWZhdWx0KFxuICAgICAgLyogaXNPcHRpb25hbE9iamVjdCAqL1xuICAgICAgZmFsc2UsXG4gICAgICBwYXJ0cyxcbiAgICAgIC0xXG4gICAgKSk7XG4gICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPSBsYXN0UGFydDtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBzdHJpcFRyYWlsaW5nSGFyZGxpbmVGcm9tRG9jKGRvYykge1xuICBzd2l0Y2ggKGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYykpIHtcbiAgICBjYXNlIERPQ19UWVBFX0lOREVOVDpcbiAgICBjYXNlIERPQ19UWVBFX0lOREVOVF9JRl9CUkVBSzpcbiAgICBjYXNlIERPQ19UWVBFX0dST1VQOlxuICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVg6XG4gICAgY2FzZSBET0NfVFlQRV9MQUJFTDoge1xuICAgICAgY29uc3QgY29udGVudHMgPSBzdHJpcFRyYWlsaW5nSGFyZGxpbmVGcm9tRG9jKGRvYy5jb250ZW50cyk7XG4gICAgICByZXR1cm4geyAuLi5kb2MsIGNvbnRlbnRzIH07XG4gICAgfVxuICAgIGNhc2UgRE9DX1RZUEVfSUZfQlJFQUs6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kb2MsXG4gICAgICAgIGJyZWFrQ29udGVudHM6IHN0cmlwVHJhaWxpbmdIYXJkbGluZUZyb21Eb2MoZG9jLmJyZWFrQ29udGVudHMpLFxuICAgICAgICBmbGF0Q29udGVudHM6IHN0cmlwVHJhaWxpbmdIYXJkbGluZUZyb21Eb2MoZG9jLmZsYXRDb250ZW50cylcbiAgICAgIH07XG4gICAgY2FzZSBET0NfVFlQRV9GSUxMOlxuICAgICAgcmV0dXJuIHsgLi4uZG9jLCBwYXJ0czogc3RyaXBUcmFpbGluZ0hhcmRsaW5lRnJvbVBhcnRzKGRvYy5wYXJ0cykgfTtcbiAgICBjYXNlIERPQ19UWVBFX0FSUkFZOlxuICAgICAgcmV0dXJuIHN0cmlwVHJhaWxpbmdIYXJkbGluZUZyb21QYXJ0cyhkb2MpO1xuICAgIGNhc2UgRE9DX1RZUEVfU1RSSU5HOlxuICAgICAgcmV0dXJuIHRyaW1OZXdsaW5lc0VuZChkb2MpO1xuICAgIGNhc2UgRE9DX1RZUEVfQUxJR046XG4gICAgY2FzZSBET0NfVFlQRV9DVVJTT1I6XG4gICAgY2FzZSBET0NfVFlQRV9UUklNOlxuICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVhfQk9VTkRBUlk6XG4gICAgY2FzZSBET0NfVFlQRV9MSU5FOlxuICAgIGNhc2UgRE9DX1RZUEVfQlJFQUtfUEFSRU5UOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBpbnZhbGlkX2RvY19lcnJvcl9kZWZhdWx0KGRvYyk7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn1cbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdIYXJkbGluZShkb2MpIHtcbiAgcmV0dXJuIHN0cmlwVHJhaWxpbmdIYXJkbGluZUZyb21Eb2MoY2xlYW5Eb2MoZG9jKSk7XG59XG5mdW5jdGlvbiBjbGVhbkRvY0ZuKGRvYykge1xuICBzd2l0Y2ggKGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYykpIHtcbiAgICBjYXNlIERPQ19UWVBFX0ZJTEw6XG4gICAgICBpZiAoZG9jLnBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiBwYXJ0ID09PSBcIlwiKSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRE9DX1RZUEVfR1JPVVA6XG4gICAgICBpZiAoIWRvYy5jb250ZW50cyAmJiAhZG9jLmlkICYmICFkb2MuYnJlYWsgJiYgIWRvYy5leHBhbmRlZFN0YXRlcykge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkb2MuY29udGVudHMudHlwZSA9PT0gRE9DX1RZUEVfR1JPVVAgJiYgZG9jLmNvbnRlbnRzLmlkID09PSBkb2MuaWQgJiYgZG9jLmNvbnRlbnRzLmJyZWFrID09PSBkb2MuYnJlYWsgJiYgZG9jLmNvbnRlbnRzLmV4cGFuZGVkU3RhdGVzID09PSBkb2MuZXhwYW5kZWRTdGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGRvYy5jb250ZW50cztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRE9DX1RZUEVfQUxJR046XG4gICAgY2FzZSBET0NfVFlQRV9JTkRFTlQ6XG4gICAgY2FzZSBET0NfVFlQRV9JTkRFTlRfSUZfQlJFQUs6XG4gICAgY2FzZSBET0NfVFlQRV9MSU5FX1NVRkZJWDpcbiAgICAgIGlmICghZG9jLmNvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBET0NfVFlQRV9JRl9CUkVBSzpcbiAgICAgIGlmICghZG9jLmZsYXRDb250ZW50cyAmJiAhZG9jLmJyZWFrQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIERPQ19UWVBFX0FSUkFZOiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGRvYykge1xuICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY3VycmVudFBhcnQsIC4uLnJlc3RQYXJ0c10gPSBBcnJheS5pc0FycmF5KHBhcnQpID8gcGFydCA6IFtwYXJ0XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UGFydCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYXRfZGVmYXVsdChcbiAgICAgICAgICAvKiBpc09wdGlvbmFsT2JqZWN0ICovXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgLTFcbiAgICAgICAgKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdICs9IGN1cnJlbnRQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2goY3VycmVudFBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goLi4ucmVzdFBhcnRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgY2FzZSBET0NfVFlQRV9TVFJJTkc6XG4gICAgY2FzZSBET0NfVFlQRV9DVVJTT1I6XG4gICAgY2FzZSBET0NfVFlQRV9UUklNOlxuICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVhfQk9VTkRBUlk6XG4gICAgY2FzZSBET0NfVFlQRV9MSU5FOlxuICAgIGNhc2UgRE9DX1RZUEVfTEFCRUw6XG4gICAgY2FzZSBET0NfVFlQRV9CUkVBS19QQVJFTlQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IGludmFsaWRfZG9jX2Vycm9yX2RlZmF1bHQoZG9jKTtcbiAgfVxuICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gY2xlYW5Eb2MoZG9jKSB7XG4gIHJldHVybiBtYXBEb2MoZG9jLCAoY3VycmVudERvYykgPT4gY2xlYW5Eb2NGbihjdXJyZW50RG9jKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlRW5kT2ZMaW5lKGRvYywgcmVwbGFjZW1lbnQgPSBsaXRlcmFsbGluZSkge1xuICByZXR1cm4gbWFwRG9jKFxuICAgIGRvYyxcbiAgICAoY3VycmVudERvYykgPT4gdHlwZW9mIGN1cnJlbnREb2MgPT09IFwic3RyaW5nXCIgPyBqb2luKHJlcGxhY2VtZW50LCBjdXJyZW50RG9jLnNwbGl0KFwiXFxuXCIpKSA6IGN1cnJlbnREb2NcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbkJyZWFrRm4oZG9jKSB7XG4gIGlmIChkb2MudHlwZSA9PT0gRE9DX1RZUEVfTElORSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBjYW5CcmVhayhkb2MpIHtcbiAgcmV0dXJuIGZpbmRJbkRvYyhkb2MsIGNhbkJyZWFrRm4sIGZhbHNlKTtcbn1cblxuLy8gc3JjL2RvY3VtZW50L3V0aWxzL2Fzc2VydC1kb2MuanNcbnZhciBub29wID0gKCkgPT4ge1xufTtcbnZhciBhc3NlcnREb2MgPSB0cnVlID8gbm9vcCA6IGZ1bmN0aW9uKGRvYykge1xuICB0cmF2ZXJzZV9kb2NfZGVmYXVsdChkb2MsIChkb2MyKSA9PiB7XG4gICAgaWYgKGNoZWNrZWQuaGFzKGRvYzIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jMiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY2hlY2tlZC5hZGQoZG9jMik7XG4gICAgfVxuICB9KTtcbn07XG52YXIgYXNzZXJ0RG9jQXJyYXkgPSB0cnVlID8gbm9vcCA6IGZ1bmN0aW9uKGRvY3MsIG9wdGlvbmFsID0gZmFsc2UpIHtcbiAgaWYgKG9wdGlvbmFsICYmICFkb2NzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShkb2NzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGRvYyBhcnJheS5cIik7XG4gIH1cbiAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgIGFzc2VydERvYyhkb2MpO1xuICB9XG59O1xudmFyIGFzc2VydERvY0ZpbGxQYXJ0cyA9IHRydWUgPyBub29wIDogKFxuICAvKipcbiAgICogQHBhcmFtIHtEb2NbXX0gcGFydHNcbiAgICovXG4gIGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgYXNzZXJ0RG9jQXJyYXkocGFydHMpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzRW1wdHlEb2MoYXRfZGVmYXVsdChcbiAgICAgIC8qIGlzT3B0aW9uYWxPYmplY3QgKi9cbiAgICAgIGZhbHNlLFxuICAgICAgcGFydHMsXG4gICAgICAtMVxuICAgICkpKSB7XG4gICAgICBwYXJ0cyA9IHBhcnRzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaSwgZG9jXSBvZiBwYXJ0cy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpICUgMiA9PT0gMSAmJiAhaXNWYWxpZFNlcGFyYXRvcihkb2MpKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRfZG9jX3R5cGVfZGVmYXVsdChkb2MpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgbm9uLWxpbmUtYnJlYWsgZG9jIGF0ICR7aX0uIERvYyB0eXBlIGlzICR7dHlwZX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuKTtcblxuLy8gc3JjL2RvY3VtZW50L2J1aWxkZXJzLmpzXG5mdW5jdGlvbiBpbmRlbnQoY29udGVudHMpIHtcbiAgYXNzZXJ0RG9jKGNvbnRlbnRzKTtcbiAgcmV0dXJuIHsgdHlwZTogRE9DX1RZUEVfSU5ERU5ULCBjb250ZW50cyB9O1xufVxuZnVuY3Rpb24gYWxpZ24od2lkdGhPclN0cmluZywgY29udGVudHMpIHtcbiAgYXNzZXJ0RG9jKGNvbnRlbnRzKTtcbiAgcmV0dXJuIHsgdHlwZTogRE9DX1RZUEVfQUxJR04sIGNvbnRlbnRzLCBuOiB3aWR0aE9yU3RyaW5nIH07XG59XG5mdW5jdGlvbiBncm91cChjb250ZW50cywgb3B0cyA9IHt9KSB7XG4gIGFzc2VydERvYyhjb250ZW50cyk7XG4gIGFzc2VydERvY0FycmF5KFxuICAgIG9wdHMuZXhwYW5kZWRTdGF0ZXMsXG4gICAgLyogb3B0aW9uYWwgKi9cbiAgICB0cnVlXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9DX1RZUEVfR1JPVVAsXG4gICAgaWQ6IG9wdHMuaWQsXG4gICAgY29udGVudHMsXG4gICAgYnJlYWs6IEJvb2xlYW4ob3B0cy5zaG91bGRCcmVhayksXG4gICAgZXhwYW5kZWRTdGF0ZXM6IG9wdHMuZXhwYW5kZWRTdGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZGVudFRvUm9vdChjb250ZW50cykge1xuICByZXR1cm4gYWxpZ24oTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBjb250ZW50cyk7XG59XG5mdW5jdGlvbiBtYXJrQXNSb290KGNvbnRlbnRzKSB7XG4gIHJldHVybiBhbGlnbih7IHR5cGU6IFwicm9vdFwiIH0sIGNvbnRlbnRzKTtcbn1cbmZ1bmN0aW9uIGRlZGVudChjb250ZW50cykge1xuICByZXR1cm4gYWxpZ24oLTEsIGNvbnRlbnRzKTtcbn1cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsR3JvdXAoc3RhdGVzLCBvcHRzKSB7XG4gIHJldHVybiBncm91cChzdGF0ZXNbMF0sIHsgLi4ub3B0cywgZXhwYW5kZWRTdGF0ZXM6IHN0YXRlcyB9KTtcbn1cbmZ1bmN0aW9uIGZpbGwocGFydHMpIHtcbiAgYXNzZXJ0RG9jRmlsbFBhcnRzKHBhcnRzKTtcbiAgcmV0dXJuIHsgdHlwZTogRE9DX1RZUEVfRklMTCwgcGFydHMgfTtcbn1cbmZ1bmN0aW9uIGlmQnJlYWsoYnJlYWtDb250ZW50cywgZmxhdENvbnRlbnRzID0gXCJcIiwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydERvYyhicmVha0NvbnRlbnRzKTtcbiAgaWYgKGZsYXRDb250ZW50cyAhPT0gXCJcIikge1xuICAgIGFzc2VydERvYyhmbGF0Q29udGVudHMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9DX1RZUEVfSUZfQlJFQUssXG4gICAgYnJlYWtDb250ZW50cyxcbiAgICBmbGF0Q29udGVudHMsXG4gICAgZ3JvdXBJZDogb3B0cy5ncm91cElkXG4gIH07XG59XG5mdW5jdGlvbiBpbmRlbnRJZkJyZWFrKGNvbnRlbnRzLCBvcHRzKSB7XG4gIGFzc2VydERvYyhjb250ZW50cyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLLFxuICAgIGNvbnRlbnRzLFxuICAgIGdyb3VwSWQ6IG9wdHMuZ3JvdXBJZCxcbiAgICBuZWdhdGU6IG9wdHMubmVnYXRlXG4gIH07XG59XG5mdW5jdGlvbiBsaW5lU3VmZml4KGNvbnRlbnRzKSB7XG4gIGFzc2VydERvYyhjb250ZW50cyk7XG4gIHJldHVybiB7IHR5cGU6IERPQ19UWVBFX0xJTkVfU1VGRklYLCBjb250ZW50cyB9O1xufVxudmFyIGxpbmVTdWZmaXhCb3VuZGFyeSA9IHsgdHlwZTogRE9DX1RZUEVfTElORV9TVUZGSVhfQk9VTkRBUlkgfTtcbnZhciBicmVha1BhcmVudCA9IHsgdHlwZTogRE9DX1RZUEVfQlJFQUtfUEFSRU5UIH07XG52YXIgdHJpbSA9IHsgdHlwZTogRE9DX1RZUEVfVFJJTSB9O1xudmFyIGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50ID0geyB0eXBlOiBET0NfVFlQRV9MSU5FLCBoYXJkOiB0cnVlIH07XG52YXIgbGl0ZXJhbGxpbmVXaXRob3V0QnJlYWtQYXJlbnQgPSB7XG4gIHR5cGU6IERPQ19UWVBFX0xJTkUsXG4gIGhhcmQ6IHRydWUsXG4gIGxpdGVyYWw6IHRydWVcbn07XG52YXIgbGluZSA9IHsgdHlwZTogRE9DX1RZUEVfTElORSB9O1xudmFyIHNvZnRsaW5lID0geyB0eXBlOiBET0NfVFlQRV9MSU5FLCBzb2Z0OiB0cnVlIH07XG52YXIgaGFyZGxpbmUgPSBbaGFyZGxpbmVXaXRob3V0QnJlYWtQYXJlbnQsIGJyZWFrUGFyZW50XTtcbnZhciBsaXRlcmFsbGluZSA9IFtsaXRlcmFsbGluZVdpdGhvdXRCcmVha1BhcmVudCwgYnJlYWtQYXJlbnRdO1xudmFyIGN1cnNvciA9IHsgdHlwZTogRE9DX1RZUEVfQ1VSU09SIH07XG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciwgZG9jcykge1xuICBhc3NlcnREb2Moc2VwYXJhdG9yKTtcbiAgYXNzZXJ0RG9jQXJyYXkoZG9jcyk7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHBhcnRzLnB1c2goZG9jc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gYWRkQWxpZ25tZW50VG9Eb2MoZG9jLCBzaXplLCB0YWJXaWR0aCkge1xuICBhc3NlcnREb2MoZG9jKTtcbiAgbGV0IGFsaWduZWQgPSBkb2M7XG4gIGlmIChzaXplID4gMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5mbG9vcihzaXplIC8gdGFiV2lkdGgpOyArK2kpIHtcbiAgICAgIGFsaWduZWQgPSBpbmRlbnQoYWxpZ25lZCk7XG4gICAgfVxuICAgIGFsaWduZWQgPSBhbGlnbihzaXplICUgdGFiV2lkdGgsIGFsaWduZWQpO1xuICAgIGFsaWduZWQgPSBhbGlnbihOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIGFsaWduZWQpO1xuICB9XG4gIHJldHVybiBhbGlnbmVkO1xufVxuZnVuY3Rpb24gbGFiZWwobGFiZWwyLCBjb250ZW50cykge1xuICBhc3NlcnREb2MoY29udGVudHMpO1xuICByZXR1cm4gbGFiZWwyID8geyB0eXBlOiBET0NfVFlQRV9MQUJFTCwgbGFiZWw6IGxhYmVsMiwgY29udGVudHMgfSA6IGNvbnRlbnRzO1xufVxuXG4vLyBzY3JpcHRzL2J1aWxkL3NoaW1zL3N0cmluZy1yZXBsYWNlLWFsbC5qc1xudmFyIHN0cmluZ1JlcGxhY2VBbGwgPSAoaXNPcHRpb25hbE9iamVjdCwgb3JpZ2luYWwsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSA9PiB7XG4gIGlmIChpc09wdGlvbmFsT2JqZWN0ICYmIChvcmlnaW5hbCA9PT0gdm9pZCAwIHx8IG9yaWdpbmFsID09PSBudWxsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3JpZ2luYWwucmVwbGFjZUFsbCkge1xuICAgIHJldHVybiBvcmlnaW5hbC5yZXBsYWNlQWxsKHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgfVxuICBpZiAocGF0dGVybi5nbG9iYWwpIHtcbiAgICByZXR1cm4gb3JpZ2luYWwucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbmFsLnNwbGl0KHBhdHRlcm4pLmpvaW4ocmVwbGFjZW1lbnQpO1xufTtcbnZhciBzdHJpbmdfcmVwbGFjZV9hbGxfZGVmYXVsdCA9IHN0cmluZ1JlcGxhY2VBbGw7XG5cbi8vIHNyYy9jb21tb24vZW5kLW9mLWxpbmUuanNcbmZ1bmN0aW9uIGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzKHZhbHVlKSB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwiY3JcIjpcbiAgICAgIHJldHVybiBcIlxcclwiO1xuICAgIGNhc2UgXCJjcmxmXCI6XG4gICAgICByZXR1cm4gXCJcXHJcXG5cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gIH1cbn1cblxuLy8gbm9kZV9tb2R1bGVzL2Vtb2ppLXJlZ2V4L2luZGV4Lm1qc1xudmFyIGVtb2ppX3JlZ2V4X2RlZmF1bHQgPSAoKSA9PiB7XG4gIHJldHVybiAvWyMqMC05XVxcdUZFMEY/XFx1MjBFM3xbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0VELVxcdTIzRUZcXHUyM0YxXFx1MjNGMlxcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQlxcdTI1RkNcXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyXFx1MjY5NC1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTdcXHUyNkFBXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM4XFx1MjZDRlxcdTI2RDFcXHUyNkU5XFx1MjZGMC1cXHUyNkY1XFx1MjZGN1xcdTI2RjhcXHUyNkZBXFx1MjcwMlxcdTI3MDhcXHUyNzA5XFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NTdcXHUyNzYzXFx1MjdBMVxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV1cXHVGRTBGP3xbXFx1MjYxRFxcdTI3MENcXHUyNzBEXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVGRTBGKT98W1xcdTI3MEFcXHUyNzBCXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNjkzXFx1MjZBMVxcdTI2QUJcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGRFxcdTI3MDVcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCNTBdfFxcdTI2RDNcXHVGRTBGPyg/OlxcdTIwMERcXHVEODNEXFx1RENBNSk/fFxcdTI2RjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RkUwRik/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdTI3NjRcXHVGRTBGPyg/OlxcdTIwMEQoPzpcXHVEODNEXFx1REQyNXxcXHVEODNFXFx1REU3OSkpP3xcXHVEODNDKD86W1xcdURDMDRcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REUwMlxcdURFMzdcXHVERjIxXFx1REYyNC1cXHVERjJDXFx1REYzNlxcdURGN0RcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUVcXHVERjlGXFx1REZDRFxcdURGQ0VcXHVERkQ0LVxcdURGREZcXHVERkY1XFx1REZGN11cXHVGRTBGP3xbXFx1REY4NVxcdURGQzJcXHVERkM3XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERkM0XFx1REZDQV0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REZDQlxcdURGQ0NdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUZFMEYpPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY0M1xcdURGNDUtXFx1REY0QVxcdURGNEMtXFx1REY3Q1xcdURGN0UtXFx1REY4NFxcdURGODYtXFx1REY5M1xcdURGQTAtXFx1REZDMVxcdURGQzVcXHVERkM2XFx1REZDOFxcdURGQzlcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY4LVxcdURGRkZdfFxcdURERTZcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdfFxcdURERTdcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl18XFx1RERFOFxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY3XFx1RERGQS1cXHVEREZGXXxcXHVEREU5XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXXxcXHVEREVBXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV18XFx1RERFQlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XXxcXHVEREVDXFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXXxcXHVEREVEXFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdfFxcdURERUVcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV18XFx1RERFRlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV18XFx1RERGMFxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdfFxcdURERjFcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV18XFx1RERGMlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl18XFx1RERGM1xcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXXxcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RERGNVxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXXxcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RERGN1xcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdfFxcdURERjhcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdfFxcdURERjlcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXXxcXHVEREZBXFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXXxcXHVEREZCXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXXxcXHVEREZDXFx1RDgzQ1tcXHVEREVCXFx1RERGOF18XFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdURERkVcXHVEODNDW1xcdURERUFcXHVEREY5XXxcXHVEREZGXFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdfFxcdURGNDQoPzpcXHUyMDBEXFx1RDgzRFxcdURGRUIpP3xcXHVERjRCKD86XFx1MjAwRFxcdUQ4M0RcXHVERkU5KT98XFx1REZDMyg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRCg/OltcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xcXHUyN0ExXFx1RkUwRj8pKT98XFx1REZGM1xcdUZFMEY/KD86XFx1MjAwRCg/OlxcdTI2QTdcXHVGRTBGP3xcXHVEODNDXFx1REYwOCkpP3xcXHVERkY0KD86XFx1MjAwRFxcdTI2MjBcXHVGRTBGP3xcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyXFx1REI0MCg/OlxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczKVxcdURCNDBcXHVEQzdGKT8pfFxcdUQ4M0QoPzpbXFx1REMzRlxcdURDRkRcXHVERDQ5XFx1REQ0QVxcdURENkZcXHVERDcwXFx1REQ3M1xcdURENzYtXFx1REQ3OVxcdUREODdcXHVERDhBLVxcdUREOERcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQVxcdURFQ0JcXHVERUNELVxcdURFQ0ZcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVGMFxcdURFRjNdXFx1RkUwRj98W1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDOEZcXHVEQzkxXFx1RENBQVxcdUREN0FcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0XFx1REVCNV0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQ3NFxcdUREOTBdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUZFMEYpP3xbXFx1REMwMC1cXHVEQzA3XFx1REMwOS1cXHVEQzE0XFx1REMxNi1cXHVEQzI1XFx1REMyNy1cXHVEQzNBXFx1REMzQy1cXHVEQzNFXFx1REM0MFxcdURDNDRcXHVEQzQ1XFx1REM1MS1cXHVEQzY1XFx1REM2QVxcdURDNzktXFx1REM3QlxcdURDN0QtXFx1REM4MFxcdURDODRcXHVEQzg4LVxcdURDOEVcXHVEQzkwXFx1REM5Mi1cXHVEQ0E5XFx1RENBQi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1RERBNFxcdURERkItXFx1REUyRFxcdURFMkYtXFx1REUzNFxcdURFMzctXFx1REU0MVxcdURFNDNcXHVERTQ0XFx1REU0OC1cXHVERTRBXFx1REU4MC1cXHVERUEyXFx1REVBNC1cXHVERUIzXFx1REVCNy1cXHVERUJGXFx1REVDMS1cXHVERUM1XFx1REVEMC1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVEQy1cXHVERURGXFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkNcXHVERkUwLVxcdURGRUJcXHVERkYwXXxcXHVEQzA4KD86XFx1MjAwRFxcdTJCMUIpP3xcXHVEQzE1KD86XFx1MjAwRFxcdUQ4M0VcXHVEREJBKT98XFx1REMyNig/OlxcdTIwMEQoPzpcXHUyQjFCfFxcdUQ4M0RcXHVERDI1KSk/fFxcdURDM0IoPzpcXHUyMDBEXFx1Mjc0NFxcdUZFMEY/KT98XFx1REM0MVxcdUZFMEY/KD86XFx1MjAwRFxcdUQ4M0RcXHVEREU4XFx1RkUwRj8pP3xcXHVEQzY4KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjh8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV1cXHUyMDBEXFx1RDgzRCg/OlxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXSkpfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUZcXHVEREJDXFx1RERCRF0oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98W1xcdUREQjAtXFx1RERCM118XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKSkpPykpP3xcXHVEQzY5KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1tcXHVEQzY4XFx1REM2OV18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT98XFx1REM2OVxcdTIwMERcXHVEODNEKD86XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pPykpfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXSkpfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUZcXHVEREJDXFx1RERCRF0oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98W1xcdUREQjAtXFx1RERCM118XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUZcXHVEREJDXFx1RERCRF0oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98W1xcdUREQjAtXFx1RERCM118XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkItXFx1REZGRV0pKSk/KSk/fFxcdURDNkYoPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1REQ3NSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVGRTBGKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1REUyRSg/OlxcdTIwMERcXHVEODNEXFx1RENBOCk/fFxcdURFMzUoPzpcXHUyMDBEXFx1RDgzRFxcdURDQUIpP3xcXHVERTM2KD86XFx1MjAwRFxcdUQ4M0NcXHVERjJCXFx1RkUwRj8pP3xcXHVERTQyKD86XFx1MjAwRFtcXHUyMTk0XFx1MjE5NV1cXHVGRTBGPyk/fFxcdURFQjYoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMEQoPzpbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98XFx1MjdBMVxcdUZFMEY/KSk/KXxcXHVEODNFKD86W1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVcXHVERUMzLVxcdURFQzVcXHVERUYwXFx1REVGMi1cXHVERUY4XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENEXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdUREREVcXHVERERGXSg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQwRFxcdUREMEVcXHVERDEwLVxcdUREMTdcXHVERDIwLVxcdUREMjVcXHVERDI3LVxcdUREMkZcXHVERDNBXFx1REQzRi1cXHVERDQ1XFx1REQ0Ny1cXHVERDc2XFx1REQ3OC1cXHVEREI0XFx1RERCN1xcdUREQkFcXHVEREJDLVxcdUREQ0NcXHVEREQwXFx1RERFMC1cXHVEREZGXFx1REU3MC1cXHVERTdDXFx1REU4MC1cXHVERTg5XFx1REU4Ri1cXHVERUMyXFx1REVDNlxcdURFQ0UtXFx1REVEQ1xcdURFREYtXFx1REVFOV18XFx1REQzQyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj98XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98XFx1RERDRSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRCg/OltcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xcXHUyN0ExXFx1RkUwRj8pKT98XFx1REREMSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1REREMVxcdTIwMERcXHVEODNFXFx1REREMig/OlxcdTIwMERcXHVEODNFXFx1REREMik/fFxcdURERDIoPzpcXHUyMDBEXFx1RDgzRVxcdURERDIpPykpfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkMtXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUZcXHVEREJDXFx1RERCRF0oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98W1xcdUREQjAtXFx1RERCM118XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRlxcdUREQkNcXHVEREJEXSg/OlxcdTIwMERcXHUyN0ExXFx1RkUwRj8pP3xbXFx1RERCMC1cXHVEREIzXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUZcXHVEREJDXFx1RERCRF0oPzpcXHUyMDBEXFx1MjdBMVxcdUZFMEY/KT98W1xcdUREQjAtXFx1RERCM118XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGXFx1RERCQ1xcdUREQkRdKD86XFx1MjAwRFxcdTI3QTFcXHVGRTBGPyk/fFtcXHVEREIwLVxcdUREQjNdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/KSk/fFxcdURFRjEoPzpcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSk/fFxcdURGRkMoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKT98XFx1REZGRCg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pP3xcXHVERkZFKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSk/fFxcdURGRkYoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkItXFx1REZGRV0pPykpPykvZztcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9nZXQtZWFzdC1hc2lhbi13aWR0aC9sb29rdXAuanNcbmZ1bmN0aW9uIGlzRnVsbFdpZHRoKHgpIHtcbiAgcmV0dXJuIHggPT09IDEyMjg4IHx8IHggPj0gNjUyODEgJiYgeCA8PSA2NTM3NiB8fCB4ID49IDY1NTA0ICYmIHggPD0gNjU1MTA7XG59XG5mdW5jdGlvbiBpc1dpZGUoeCkge1xuICByZXR1cm4geCA+PSA0MzUyICYmIHggPD0gNDQ0NyB8fCB4ID09PSA4OTg2IHx8IHggPT09IDg5ODcgfHwgeCA9PT0gOTAwMSB8fCB4ID09PSA5MDAyIHx8IHggPj0gOTE5MyAmJiB4IDw9IDkxOTYgfHwgeCA9PT0gOTIwMCB8fCB4ID09PSA5MjAzIHx8IHggPT09IDk3MjUgfHwgeCA9PT0gOTcyNiB8fCB4ID09PSA5NzQ4IHx8IHggPT09IDk3NDkgfHwgeCA+PSA5Nzc2ICYmIHggPD0gOTc4MyB8fCB4ID49IDk4MDAgJiYgeCA8PSA5ODExIHx8IHggPT09IDk4NTUgfHwgeCA+PSA5ODY2ICYmIHggPD0gOTg3MSB8fCB4ID09PSA5ODc1IHx8IHggPT09IDk4ODkgfHwgeCA9PT0gOTg5OCB8fCB4ID09PSA5ODk5IHx8IHggPT09IDk5MTcgfHwgeCA9PT0gOTkxOCB8fCB4ID09PSA5OTI0IHx8IHggPT09IDk5MjUgfHwgeCA9PT0gOTkzNCB8fCB4ID09PSA5OTQwIHx8IHggPT09IDk5NjIgfHwgeCA9PT0gOTk3MCB8fCB4ID09PSA5OTcxIHx8IHggPT09IDk5NzMgfHwgeCA9PT0gOTk3OCB8fCB4ID09PSA5OTgxIHx8IHggPT09IDk5ODkgfHwgeCA9PT0gOTk5NCB8fCB4ID09PSA5OTk1IHx8IHggPT09IDEwMDI0IHx8IHggPT09IDEwMDYwIHx8IHggPT09IDEwMDYyIHx8IHggPj0gMTAwNjcgJiYgeCA8PSAxMDA2OSB8fCB4ID09PSAxMDA3MSB8fCB4ID49IDEwMTMzICYmIHggPD0gMTAxMzUgfHwgeCA9PT0gMTAxNjAgfHwgeCA9PT0gMTAxNzUgfHwgeCA9PT0gMTEwMzUgfHwgeCA9PT0gMTEwMzYgfHwgeCA9PT0gMTEwODggfHwgeCA9PT0gMTEwOTMgfHwgeCA+PSAxMTkwNCAmJiB4IDw9IDExOTI5IHx8IHggPj0gMTE5MzEgJiYgeCA8PSAxMjAxOSB8fCB4ID49IDEyMDMyICYmIHggPD0gMTIyNDUgfHwgeCA+PSAxMjI3MiAmJiB4IDw9IDEyMjg3IHx8IHggPj0gMTIyODkgJiYgeCA8PSAxMjM1MCB8fCB4ID49IDEyMzUzICYmIHggPD0gMTI0MzggfHwgeCA+PSAxMjQ0MSAmJiB4IDw9IDEyNTQzIHx8IHggPj0gMTI1NDkgJiYgeCA8PSAxMjU5MSB8fCB4ID49IDEyNTkzICYmIHggPD0gMTI2ODYgfHwgeCA+PSAxMjY4OCAmJiB4IDw9IDEyNzczIHx8IHggPj0gMTI3ODMgJiYgeCA8PSAxMjgzMCB8fCB4ID49IDEyODMyICYmIHggPD0gMTI4NzEgfHwgeCA+PSAxMjg4MCAmJiB4IDw9IDQyMTI0IHx8IHggPj0gNDIxMjggJiYgeCA8PSA0MjE4MiB8fCB4ID49IDQzMzYwICYmIHggPD0gNDMzODggfHwgeCA+PSA0NDAzMiAmJiB4IDw9IDU1MjAzIHx8IHggPj0gNjM3NDQgJiYgeCA8PSA2NDI1NSB8fCB4ID49IDY1MDQwICYmIHggPD0gNjUwNDkgfHwgeCA+PSA2NTA3MiAmJiB4IDw9IDY1MTA2IHx8IHggPj0gNjUxMDggJiYgeCA8PSA2NTEyNiB8fCB4ID49IDY1MTI4ICYmIHggPD0gNjUxMzEgfHwgeCA+PSA5NDE3NiAmJiB4IDw9IDk0MTgwIHx8IHggPT09IDk0MTkyIHx8IHggPT09IDk0MTkzIHx8IHggPj0gOTQyMDggJiYgeCA8PSAxMDAzNDMgfHwgeCA+PSAxMDAzNTIgJiYgeCA8PSAxMDE1ODkgfHwgeCA+PSAxMDE2MzEgJiYgeCA8PSAxMDE2NDAgfHwgeCA+PSAxMTA1NzYgJiYgeCA8PSAxMTA1NzkgfHwgeCA+PSAxMTA1ODEgJiYgeCA8PSAxMTA1ODcgfHwgeCA9PT0gMTEwNTg5IHx8IHggPT09IDExMDU5MCB8fCB4ID49IDExMDU5MiAmJiB4IDw9IDExMDg4MiB8fCB4ID09PSAxMTA4OTggfHwgeCA+PSAxMTA5MjggJiYgeCA8PSAxMTA5MzAgfHwgeCA9PT0gMTEwOTMzIHx8IHggPj0gMTEwOTQ4ICYmIHggPD0gMTEwOTUxIHx8IHggPj0gMTEwOTYwICYmIHggPD0gMTExMzU1IHx8IHggPj0gMTE5NTUyICYmIHggPD0gMTE5NjM4IHx8IHggPj0gMTE5NjQ4ICYmIHggPD0gMTE5NjcwIHx8IHggPT09IDEyNjk4MCB8fCB4ID09PSAxMjcxODMgfHwgeCA9PT0gMTI3Mzc0IHx8IHggPj0gMTI3Mzc3ICYmIHggPD0gMTI3Mzg2IHx8IHggPj0gMTI3NDg4ICYmIHggPD0gMTI3NDkwIHx8IHggPj0gMTI3NTA0ICYmIHggPD0gMTI3NTQ3IHx8IHggPj0gMTI3NTUyICYmIHggPD0gMTI3NTYwIHx8IHggPT09IDEyNzU2OCB8fCB4ID09PSAxMjc1NjkgfHwgeCA+PSAxMjc1ODQgJiYgeCA8PSAxMjc1ODkgfHwgeCA+PSAxMjc3NDQgJiYgeCA8PSAxMjc3NzYgfHwgeCA+PSAxMjc3ODkgJiYgeCA8PSAxMjc3OTcgfHwgeCA+PSAxMjc3OTkgJiYgeCA8PSAxMjc4NjggfHwgeCA+PSAxMjc4NzAgJiYgeCA8PSAxMjc4OTEgfHwgeCA+PSAxMjc5MDQgJiYgeCA8PSAxMjc5NDYgfHwgeCA+PSAxMjc5NTEgJiYgeCA8PSAxMjc5NTUgfHwgeCA+PSAxMjc5NjggJiYgeCA8PSAxMjc5ODQgfHwgeCA9PT0gMTI3OTg4IHx8IHggPj0gMTI3OTkyICYmIHggPD0gMTI4MDYyIHx8IHggPT09IDEyODA2NCB8fCB4ID49IDEyODA2NiAmJiB4IDw9IDEyODI1MiB8fCB4ID49IDEyODI1NSAmJiB4IDw9IDEyODMxNyB8fCB4ID49IDEyODMzMSAmJiB4IDw9IDEyODMzNCB8fCB4ID49IDEyODMzNiAmJiB4IDw9IDEyODM1OSB8fCB4ID09PSAxMjgzNzggfHwgeCA9PT0gMTI4NDA1IHx8IHggPT09IDEyODQwNiB8fCB4ID09PSAxMjg0MjAgfHwgeCA+PSAxMjg1MDcgJiYgeCA8PSAxMjg1OTEgfHwgeCA+PSAxMjg2NDAgJiYgeCA8PSAxMjg3MDkgfHwgeCA9PT0gMTI4NzE2IHx8IHggPj0gMTI4NzIwICYmIHggPD0gMTI4NzIyIHx8IHggPj0gMTI4NzI1ICYmIHggPD0gMTI4NzI3IHx8IHggPj0gMTI4NzMyICYmIHggPD0gMTI4NzM1IHx8IHggPT09IDEyODc0NyB8fCB4ID09PSAxMjg3NDggfHwgeCA+PSAxMjg3NTYgJiYgeCA8PSAxMjg3NjQgfHwgeCA+PSAxMjg5OTIgJiYgeCA8PSAxMjkwMDMgfHwgeCA9PT0gMTI5MDA4IHx8IHggPj0gMTI5MjkyICYmIHggPD0gMTI5MzM4IHx8IHggPj0gMTI5MzQwICYmIHggPD0gMTI5MzQ5IHx8IHggPj0gMTI5MzUxICYmIHggPD0gMTI5NTM1IHx8IHggPj0gMTI5NjQ4ICYmIHggPD0gMTI5NjYwIHx8IHggPj0gMTI5NjY0ICYmIHggPD0gMTI5NjczIHx8IHggPj0gMTI5Njc5ICYmIHggPD0gMTI5NzM0IHx8IHggPj0gMTI5NzQyICYmIHggPD0gMTI5NzU2IHx8IHggPj0gMTI5NzU5ICYmIHggPD0gMTI5NzY5IHx8IHggPj0gMTI5Nzc2ICYmIHggPD0gMTI5Nzg0IHx8IHggPj0gMTMxMDcyICYmIHggPD0gMTk2NjA1IHx8IHggPj0gMTk2NjA4ICYmIHggPD0gMjYyMTQxO1xufVxuXG4vLyBub2RlX21vZHVsZXMvZ2V0LWVhc3QtYXNpYW4td2lkdGgvaW5kZXguanNcbnZhciBfaXNOYXJyb3dXaWR0aCA9IChjb2RlUG9pbnQpID0+ICEoaXNGdWxsV2lkdGgoY29kZVBvaW50KSB8fCBpc1dpZGUoY29kZVBvaW50KSk7XG5cbi8vIHNyYy91dGlscy9nZXQtc3RyaW5nLXdpZHRoLmpzXG52YXIgbm90QXNjaWlSZWdleCA9IC9bXlxceDIwLVxceDdGXS91O1xuZnVuY3Rpb24gZ2V0U3RyaW5nV2lkdGgodGV4dCkge1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIW5vdEFzY2lpUmVnZXgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgfVxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGVtb2ppX3JlZ2V4X2RlZmF1bHQoKSwgXCIgIFwiKTtcbiAgbGV0IHdpZHRoID0gMDtcbiAgZm9yIChjb25zdCBjaGFyYWN0ZXIgb2YgdGV4dCkge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKTtcbiAgICBpZiAoY29kZVBvaW50IDw9IDMxIHx8IGNvZGVQb2ludCA+PSAxMjcgJiYgY29kZVBvaW50IDw9IDE1OSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPj0gNzY4ICYmIGNvZGVQb2ludCA8PSA4NzkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3aWR0aCArPSBfaXNOYXJyb3dXaWR0aChjb2RlUG9pbnQpID8gMSA6IDI7XG4gIH1cbiAgcmV0dXJuIHdpZHRoO1xufVxudmFyIGdldF9zdHJpbmdfd2lkdGhfZGVmYXVsdCA9IGdldFN0cmluZ1dpZHRoO1xuXG4vLyBzcmMvZG9jdW1lbnQvcHJpbnRlci5qc1xudmFyIE1PREVfQlJFQUsgPSBTeW1ib2woXCJNT0RFX0JSRUFLXCIpO1xudmFyIE1PREVfRkxBVCA9IFN5bWJvbChcIk1PREVfRkxBVFwiKTtcbnZhciBDVVJTT1JfUExBQ0VIT0xERVIgPSBTeW1ib2woXCJjdXJzb3JcIik7XG52YXIgRE9DX0ZJTExfUFJJTlRFRF9MRU5HVEggPSBTeW1ib2woXCJET0NfRklMTF9QUklOVEVEX0xFTkdUSFwiKTtcbmZ1bmN0aW9uIHJvb3RJbmRlbnQoKSB7XG4gIHJldHVybiB7IHZhbHVlOiBcIlwiLCBsZW5ndGg6IDAsIHF1ZXVlOiBbXSB9O1xufVxuZnVuY3Rpb24gbWFrZUluZGVudChpbmQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdlbmVyYXRlSW5kKGluZCwgeyB0eXBlOiBcImluZGVudFwiIH0sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbWFrZUFsaWduKGluZGVudDIsIHdpZHRoT3JEb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHdpZHRoT3JEb2MgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgIHJldHVybiBpbmRlbnQyLnJvb3QgfHwgcm9vdEluZGVudCgpO1xuICB9XG4gIGlmICh3aWR0aE9yRG9jIDwgMCkge1xuICAgIHJldHVybiBnZW5lcmF0ZUluZChpbmRlbnQyLCB7IHR5cGU6IFwiZGVkZW50XCIgfSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKCF3aWR0aE9yRG9jKSB7XG4gICAgcmV0dXJuIGluZGVudDI7XG4gIH1cbiAgaWYgKHdpZHRoT3JEb2MudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICByZXR1cm4geyAuLi5pbmRlbnQyLCByb290OiBpbmRlbnQyIH07XG4gIH1cbiAgY29uc3QgYWxpZ25UeXBlID0gdHlwZW9mIHdpZHRoT3JEb2MgPT09IFwic3RyaW5nXCIgPyBcInN0cmluZ0FsaWduXCIgOiBcIm51bWJlckFsaWduXCI7XG4gIHJldHVybiBnZW5lcmF0ZUluZChpbmRlbnQyLCB7IHR5cGU6IGFsaWduVHlwZSwgbjogd2lkdGhPckRvYyB9LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW5kKGluZCwgbmV3UGFydCwgb3B0aW9ucykge1xuICBjb25zdCBxdWV1ZSA9IG5ld1BhcnQudHlwZSA9PT0gXCJkZWRlbnRcIiA/IGluZC5xdWV1ZS5zbGljZSgwLCAtMSkgOiBbLi4uaW5kLnF1ZXVlLCBuZXdQYXJ0XTtcbiAgbGV0IHZhbHVlID0gXCJcIjtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBsYXN0VGFicyA9IDA7XG4gIGxldCBsYXN0U3BhY2VzID0gMDtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHF1ZXVlKSB7XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbmRlbnRcIjpcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlVGFicykge1xuICAgICAgICAgIGFkZFRhYnMoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkU3BhY2VzKG9wdGlvbnMudGFiV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN0cmluZ0FsaWduXCI6XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHZhbHVlICs9IHBhcnQubjtcbiAgICAgICAgbGVuZ3RoICs9IHBhcnQubi5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm51bWJlckFsaWduXCI6XG4gICAgICAgIGxhc3RUYWJzICs9IDE7XG4gICAgICAgIGxhc3RTcGFjZXMgKz0gcGFydC5uO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlICcke3BhcnQudHlwZX0nYCk7XG4gICAgfVxuICB9XG4gIGZsdXNoU3BhY2VzKCk7XG4gIHJldHVybiB7IC4uLmluZCwgdmFsdWUsIGxlbmd0aCwgcXVldWUgfTtcbiAgZnVuY3Rpb24gYWRkVGFicyhjb3VudCkge1xuICAgIHZhbHVlICs9IFwiXHRcIi5yZXBlYXQoY291bnQpO1xuICAgIGxlbmd0aCArPSBvcHRpb25zLnRhYldpZHRoICogY291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gYWRkU3BhY2VzKGNvdW50KSB7XG4gICAgdmFsdWUgKz0gXCIgXCIucmVwZWF0KGNvdW50KTtcbiAgICBsZW5ndGggKz0gY291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlVGFicykge1xuICAgICAgZmx1c2hUYWJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoU3BhY2VzKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZsdXNoVGFicygpIHtcbiAgICBpZiAobGFzdFRhYnMgPiAwKSB7XG4gICAgICBhZGRUYWJzKGxhc3RUYWJzKTtcbiAgICB9XG4gICAgcmVzZXRMYXN0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hTcGFjZXMoKSB7XG4gICAgaWYgKGxhc3RTcGFjZXMgPiAwKSB7XG4gICAgICBhZGRTcGFjZXMobGFzdFNwYWNlcyk7XG4gICAgfVxuICAgIHJlc2V0TGFzdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0TGFzdCgpIHtcbiAgICBsYXN0VGFicyA9IDA7XG4gICAgbGFzdFNwYWNlcyA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaW0yKG91dCkge1xuICBsZXQgdHJpbUNvdW50ID0gMDtcbiAgbGV0IGN1cnNvckNvdW50ID0gMDtcbiAgbGV0IG91dEluZGV4ID0gb3V0Lmxlbmd0aDtcbiAgb3V0ZXI6IHdoaWxlIChvdXRJbmRleC0tKSB7XG4gICAgY29uc3QgbGFzdCA9IG91dFtvdXRJbmRleF07XG4gICAgaWYgKGxhc3QgPT09IENVUlNPUl9QTEFDRUhPTERFUikge1xuICAgICAgY3Vyc29yQ291bnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBpbiB0cmltOiAnJHt0eXBlb2YgbGFzdH0nYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGNoYXJJbmRleCA9IGxhc3QubGVuZ3RoIC0gMTsgY2hhckluZGV4ID49IDA7IGNoYXJJbmRleC0tKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGFzdFtjaGFySW5kZXhdO1xuICAgICAgaWYgKGNoYXIgPT09IFwiIFwiIHx8IGNoYXIgPT09IFwiXHRcIikge1xuICAgICAgICB0cmltQ291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtvdXRJbmRleF0gPSBsYXN0LnNsaWNlKDAsIGNoYXJJbmRleCArIDEpO1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRyaW1Db3VudCA+IDAgfHwgY3Vyc29yQ291bnQgPiAwKSB7XG4gICAgb3V0Lmxlbmd0aCA9IG91dEluZGV4ICsgMTtcbiAgICB3aGlsZSAoY3Vyc29yQ291bnQtLSA+IDApIHtcbiAgICAgIG91dC5wdXNoKENVUlNPUl9QTEFDRUhPTERFUik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmltQ291bnQ7XG59XG5mdW5jdGlvbiBmaXRzKG5leHQsIHJlc3RDb21tYW5kcywgd2lkdGgsIGhhc0xpbmVTdWZmaXgsIGdyb3VwTW9kZU1hcCwgbXVzdEJlRmxhdCkge1xuICBpZiAod2lkdGggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCByZXN0SWR4ID0gcmVzdENvbW1hbmRzLmxlbmd0aDtcbiAgY29uc3QgY21kcyA9IFtuZXh0XTtcbiAgY29uc3Qgb3V0ID0gW107XG4gIHdoaWxlICh3aWR0aCA+PSAwKSB7XG4gICAgaWYgKGNtZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocmVzdElkeCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtZHMucHVzaChyZXN0Q29tbWFuZHNbLS1yZXN0SWR4XSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeyBtb2RlLCBkb2MgfSA9IGNtZHMucG9wKCk7XG4gICAgY29uc3QgZG9jVHlwZSA9IGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYyk7XG4gICAgc3dpdGNoIChkb2NUeXBlKSB7XG4gICAgICBjYXNlIERPQ19UWVBFX1NUUklORzpcbiAgICAgICAgb3V0LnB1c2goZG9jKTtcbiAgICAgICAgd2lkdGggLT0gZ2V0X3N0cmluZ193aWR0aF9kZWZhdWx0KGRvYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET0NfVFlQRV9BUlJBWTpcbiAgICAgIGNhc2UgRE9DX1RZUEVfRklMTDoge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRvY1R5cGUgPT09IERPQ19UWVBFX0FSUkFZID8gZG9jIDogZG9jLnBhcnRzO1xuICAgICAgICBjb25zdCBlbmQgPSBkb2NbRE9DX0ZJTExfUFJJTlRFRF9MRU5HVEhdID8/IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgICAgY21kcy5wdXNoKHsgbW9kZSwgZG9jOiBwYXJ0c1tpXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgRE9DX1RZUEVfSU5ERU5UOlxuICAgICAgY2FzZSBET0NfVFlQRV9BTElHTjpcbiAgICAgIGNhc2UgRE9DX1RZUEVfSU5ERU5UX0lGX0JSRUFLOlxuICAgICAgY2FzZSBET0NfVFlQRV9MQUJFTDpcbiAgICAgICAgY21kcy5wdXNoKHsgbW9kZSwgZG9jOiBkb2MuY29udGVudHMgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET0NfVFlQRV9UUklNOlxuICAgICAgICB3aWR0aCArPSB0cmltMihvdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfR1JPVVA6IHtcbiAgICAgICAgaWYgKG11c3RCZUZsYXQgJiYgZG9jLmJyZWFrKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwTW9kZSA9IGRvYy5icmVhayA/IE1PREVfQlJFQUsgOiBtb2RlO1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGRvYy5leHBhbmRlZFN0YXRlcyAmJiBncm91cE1vZGUgPT09IE1PREVfQlJFQUsgPyBhdF9kZWZhdWx0KFxuICAgICAgICAgIC8qIGlzT3B0aW9uYWxPYmplY3QgKi9cbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBkb2MuZXhwYW5kZWRTdGF0ZXMsXG4gICAgICAgICAgLTFcbiAgICAgICAgKSA6IGRvYy5jb250ZW50cztcbiAgICAgICAgY21kcy5wdXNoKHsgbW9kZTogZ3JvdXBNb2RlLCBkb2M6IGNvbnRlbnRzIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgRE9DX1RZUEVfSUZfQlJFQUs6IHtcbiAgICAgICAgY29uc3QgZ3JvdXBNb2RlID0gZG9jLmdyb3VwSWQgPyBncm91cE1vZGVNYXBbZG9jLmdyb3VwSWRdIHx8IE1PREVfRkxBVCA6IG1vZGU7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gZ3JvdXBNb2RlID09PSBNT0RFX0JSRUFLID8gZG9jLmJyZWFrQ29udGVudHMgOiBkb2MuZmxhdENvbnRlbnRzO1xuICAgICAgICBpZiAoY29udGVudHMpIHtcbiAgICAgICAgICBjbWRzLnB1c2goeyBtb2RlLCBkb2M6IGNvbnRlbnRzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBET0NfVFlQRV9MSU5FOlxuICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9CUkVBSyB8fCBkb2MuaGFyZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jLnNvZnQpIHtcbiAgICAgICAgICBvdXQucHVzaChcIiBcIik7XG4gICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVg6XG4gICAgICAgIGhhc0xpbmVTdWZmaXggPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfTElORV9TVUZGSVhfQk9VTkRBUlk6XG4gICAgICAgIGlmIChoYXNMaW5lU3VmZml4KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcmludERvY1RvU3RyaW5nKGRvYywgb3B0aW9ucykge1xuICBjb25zdCBncm91cE1vZGVNYXAgPSB7fTtcbiAgY29uc3Qgd2lkdGggPSBvcHRpb25zLnByaW50V2lkdGg7XG4gIGNvbnN0IG5ld0xpbmUgPSBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFycyhvcHRpb25zLmVuZE9mTGluZSk7XG4gIGxldCBwb3MgPSAwO1xuICBjb25zdCBjbWRzID0gW3sgaW5kOiByb290SW5kZW50KCksIG1vZGU6IE1PREVfQlJFQUssIGRvYyB9XTtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGxldCBzaG91bGRSZW1lYXN1cmUgPSBmYWxzZTtcbiAgY29uc3QgbGluZVN1ZmZpeDIgPSBbXTtcbiAgbGV0IHByaW50ZWRDdXJzb3JDb3VudCA9IDA7XG4gIHByb3BhZ2F0ZUJyZWFrcyhkb2MpO1xuICB3aGlsZSAoY21kcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgeyBpbmQsIG1vZGUsIGRvYzogZG9jMiB9ID0gY21kcy5wb3AoKTtcbiAgICBzd2l0Y2ggKGdldF9kb2NfdHlwZV9kZWZhdWx0KGRvYzIpKSB7XG4gICAgICBjYXNlIERPQ19UWVBFX1NUUklORzoge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBuZXdMaW5lICE9PSBcIlxcblwiID8gc3RyaW5nX3JlcGxhY2VfYWxsX2RlZmF1bHQoXG4gICAgICAgICAgLyogaXNPcHRpb25hbE9iamVjdCAqL1xuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGRvYzIsXG4gICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICBuZXdMaW5lXG4gICAgICAgICkgOiBkb2MyO1xuICAgICAgICBvdXQucHVzaChmb3JtYXR0ZWQpO1xuICAgICAgICBpZiAoY21kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcG9zICs9IGdldF9zdHJpbmdfd2lkdGhfZGVmYXVsdChmb3JtYXR0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBET0NfVFlQRV9BUlJBWTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGRvYzIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjbWRzLnB1c2goeyBpbmQsIG1vZGUsIGRvYzogZG9jMltpXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfQ1VSU09SOlxuICAgICAgICBpZiAocHJpbnRlZEN1cnNvckNvdW50ID49IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBhcmUgdG9vIG1hbnkgJ2N1cnNvcicgaW4gZG9jLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaChDVVJTT1JfUExBQ0VIT0xERVIpO1xuICAgICAgICBwcmludGVkQ3Vyc29yQ291bnQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0lOREVOVDpcbiAgICAgICAgY21kcy5wdXNoKHsgaW5kOiBtYWtlSW5kZW50KGluZCwgb3B0aW9ucyksIG1vZGUsIGRvYzogZG9jMi5jb250ZW50cyB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0FMSUdOOlxuICAgICAgICBjbWRzLnB1c2goe1xuICAgICAgICAgIGluZDogbWFrZUFsaWduKGluZCwgZG9jMi5uLCBvcHRpb25zKSxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGRvYzogZG9jMi5jb250ZW50c1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX1RSSU06XG4gICAgICAgIHBvcyAtPSB0cmltMihvdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DX1RZUEVfR1JPVVA6XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgIGNhc2UgTU9ERV9GTEFUOlxuICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgY21kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmQsXG4gICAgICAgICAgICAgICAgbW9kZTogZG9jMi5icmVhayA/IE1PREVfQlJFQUsgOiBNT0RFX0ZMQVQsXG4gICAgICAgICAgICAgICAgZG9jOiBkb2MyLmNvbnRlbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgIGNhc2UgTU9ERV9CUkVBSzoge1xuICAgICAgICAgICAgc2hvdWxkUmVtZWFzdXJlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0geyBpbmQsIG1vZGU6IE1PREVfRkxBVCwgZG9jOiBkb2MyLmNvbnRlbnRzIH07XG4gICAgICAgICAgICBjb25zdCByZW0gPSB3aWR0aCAtIHBvcztcbiAgICAgICAgICAgIGNvbnN0IGhhc0xpbmVTdWZmaXggPSBsaW5lU3VmZml4Mi5sZW5ndGggPiAwO1xuICAgICAgICAgICAgaWYgKCFkb2MyLmJyZWFrICYmIGZpdHMobmV4dCwgY21kcywgcmVtLCBoYXNMaW5lU3VmZml4LCBncm91cE1vZGVNYXApKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChkb2MyLmV4cGFuZGVkU3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9zdEV4cGFuZGVkID0gYXRfZGVmYXVsdChcbiAgICAgICAgICAgICAgICAgIC8qIGlzT3B0aW9uYWxPYmplY3QgKi9cbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZG9jMi5leHBhbmRlZFN0YXRlcyxcbiAgICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jMi5icmVhaykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKHsgaW5kLCBtb2RlOiBNT0RFX0JSRUFLLCBkb2M6IG1vc3RFeHBhbmRlZCB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRvYzIuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IGRvYzIuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKHsgaW5kLCBtb2RlOiBNT0RFX0JSRUFLLCBkb2M6IG1vc3RFeHBhbmRlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGRvYzIuZXhwYW5kZWRTdGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgY21kID0geyBpbmQsIG1vZGU6IE1PREVfRkxBVCwgZG9jOiBzdGF0ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXRzKGNtZCwgY21kcywgcmVtLCBoYXNMaW5lU3VmZml4LCBncm91cE1vZGVNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goY21kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goeyBpbmQsIG1vZGU6IE1PREVfQlJFQUssIGRvYzogZG9jMi5jb250ZW50cyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb2MyLmlkKSB7XG4gICAgICAgICAgZ3JvdXBNb2RlTWFwW2RvYzIuaWRdID0gYXRfZGVmYXVsdChcbiAgICAgICAgICAgIC8qIGlzT3B0aW9uYWxPYmplY3QgKi9cbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgY21kcyxcbiAgICAgICAgICAgIC0xXG4gICAgICAgICAgKS5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRmlsbHMgZWFjaCBsaW5lIHdpdGggYXMgbXVjaCBjb2RlIGFzIHBvc3NpYmxlIGJlZm9yZSBtb3ZpbmcgdG8gYSBuZXdcbiAgICAgIC8vIGxpbmUgd2l0aCB0aGUgc2FtZSBpbmRlbnRhdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyBFeHBlY3RzIGRvYy5wYXJ0cyB0byBiZSBhbiBhcnJheSBvZiBhbHRlcm5hdGluZyBjb250ZW50IGFuZFxuICAgICAgLy8gd2hpdGVzcGFjZS4gVGhlIHdoaXRlc3BhY2UgY29udGFpbnMgdGhlIGxpbmVicmVha3MuXG4gICAgICAvL1xuICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAvLyAgIFtcIklcIiwgbGluZSwgXCJsb3ZlXCIsIGxpbmUsIFwibW9ua2V5c1wiXVxuICAgICAgLy8gb3JcbiAgICAgIC8vICAgW3sgdHlwZTogZ3JvdXAsIC4uLiB9LCBzb2Z0bGluZSwgeyB0eXBlOiBncm91cCwgLi4uIH1dXG4gICAgICAvL1xuICAgICAgLy8gSXQgdXNlcyB0aGlzIHBhcnRzIHN0cnVjdHVyZSB0byBoYW5kbGUgdGhyZWUgbWFpbiBsYXlvdXQgY2FzZXM6XG4gICAgICAvLyAqIFRoZSBmaXJzdCB0d28gY29udGVudCBpdGVtcyBmaXQgb24gdGhlIHNhbWUgbGluZSB3aXRob3V0XG4gICAgICAvLyAgIGJyZWFraW5nXG4gICAgICAvLyAgIC0+IG91dHB1dCB0aGUgZmlyc3QgY29udGVudCBpdGVtIGFuZCB0aGUgd2hpdGVzcGFjZSBcImZsYXRcIi5cbiAgICAgIC8vICogT25seSB0aGUgZmlyc3QgY29udGVudCBpdGVtIGZpdHMgb24gdGhlIGxpbmUgd2l0aG91dCBicmVha2luZ1xuICAgICAgLy8gICAtPiBvdXRwdXQgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBcImZsYXRcIiBhbmQgdGhlIHdoaXRlc3BhY2Ugd2l0aFxuICAgICAgLy8gICBcImJyZWFrXCIuXG4gICAgICAvLyAqIE5laXRoZXIgY29udGVudCBpdGVtIGZpdHMgb24gdGhlIGxpbmUgd2l0aG91dCBicmVha2luZ1xuICAgICAgLy8gICAtPiBvdXRwdXQgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBhbmQgdGhlIHdoaXRlc3BhY2Ugd2l0aCBcImJyZWFrXCIuXG4gICAgICBjYXNlIERPQ19UWVBFX0ZJTEw6IHtcbiAgICAgICAgY29uc3QgcmVtID0gd2lkdGggLSBwb3M7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvYzJbRE9DX0ZJTExfUFJJTlRFRF9MRU5HVEhdID8/IDA7XG4gICAgICAgIGNvbnN0IHsgcGFydHMgfSA9IGRvYzI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJ0c1tvZmZzZXQgKyAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IHBhcnRzW29mZnNldCArIDFdO1xuICAgICAgICBjb25zdCBjb250ZW50RmxhdENtZCA9IHsgaW5kLCBtb2RlOiBNT0RFX0ZMQVQsIGRvYzogY29udGVudCB9O1xuICAgICAgICBjb25zdCBjb250ZW50QnJlYWtDbWQgPSB7IGluZCwgbW9kZTogTU9ERV9CUkVBSywgZG9jOiBjb250ZW50IH07XG4gICAgICAgIGNvbnN0IGNvbnRlbnRGaXRzID0gZml0cyhcbiAgICAgICAgICBjb250ZW50RmxhdENtZCxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICByZW0sXG4gICAgICAgICAgbGluZVN1ZmZpeDIubGVuZ3RoID4gMCxcbiAgICAgICAgICBncm91cE1vZGVNYXAsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRGaXRzKSB7XG4gICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEZsYXRDbWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEJyZWFrQ21kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUZsYXRDbWQgPSB7IGluZCwgbW9kZTogTU9ERV9GTEFULCBkb2M6IHdoaXRlc3BhY2UgfTtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUJyZWFrQ21kID0geyBpbmQsIG1vZGU6IE1PREVfQlJFQUssIGRvYzogd2hpdGVzcGFjZSB9O1xuICAgICAgICBpZiAobGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRGaXRzKSB7XG4gICAgICAgICAgICBjbWRzLnB1c2god2hpdGVzcGFjZUZsYXRDbWQsIGNvbnRlbnRGbGF0Q21kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VCcmVha0NtZCwgY29udGVudEJyZWFrQ21kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vjb25kQ29udGVudCA9IHBhcnRzW29mZnNldCArIDJdO1xuICAgICAgICBjb25zdCByZW1haW5pbmdDbWQgPSB7XG4gICAgICAgICAgaW5kLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZG9jOiB7IC4uLmRvYzIsIFtET0NfRklMTF9QUklOVEVEX0xFTkdUSF06IG9mZnNldCArIDIgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaXJzdEFuZFNlY29uZENvbnRlbnRGbGF0Q21kID0ge1xuICAgICAgICAgIGluZCxcbiAgICAgICAgICBtb2RlOiBNT0RFX0ZMQVQsXG4gICAgICAgICAgZG9jOiBbY29udGVudCwgd2hpdGVzcGFjZSwgc2Vjb25kQ29udGVudF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlyc3RBbmRTZWNvbmRDb250ZW50Rml0cyA9IGZpdHMoXG4gICAgICAgICAgZmlyc3RBbmRTZWNvbmRDb250ZW50RmxhdENtZCxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICByZW0sXG4gICAgICAgICAgbGluZVN1ZmZpeDIubGVuZ3RoID4gMCxcbiAgICAgICAgICBncm91cE1vZGVNYXAsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBpZiAoZmlyc3RBbmRTZWNvbmRDb250ZW50Rml0cykge1xuICAgICAgICAgIGNtZHMucHVzaChyZW1haW5pbmdDbWQsIHdoaXRlc3BhY2VGbGF0Q21kLCBjb250ZW50RmxhdENtZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudEZpdHMpIHtcbiAgICAgICAgICBjbWRzLnB1c2gocmVtYWluaW5nQ21kLCB3aGl0ZXNwYWNlQnJlYWtDbWQsIGNvbnRlbnRGbGF0Q21kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbWRzLnB1c2gocmVtYWluaW5nQ21kLCB3aGl0ZXNwYWNlQnJlYWtDbWQsIGNvbnRlbnRCcmVha0NtZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIERPQ19UWVBFX0lGX0JSRUFLOlxuICAgICAgY2FzZSBET0NfVFlQRV9JTkRFTlRfSUZfQlJFQUs6IHtcbiAgICAgICAgY29uc3QgZ3JvdXBNb2RlID0gZG9jMi5ncm91cElkID8gZ3JvdXBNb2RlTWFwW2RvYzIuZ3JvdXBJZF0gOiBtb2RlO1xuICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0JSRUFLKSB7XG4gICAgICAgICAgY29uc3QgYnJlYWtDb250ZW50cyA9IGRvYzIudHlwZSA9PT0gRE9DX1RZUEVfSUZfQlJFQUsgPyBkb2MyLmJyZWFrQ29udGVudHMgOiBkb2MyLm5lZ2F0ZSA/IGRvYzIuY29udGVudHMgOiBpbmRlbnQoZG9jMi5jb250ZW50cyk7XG4gICAgICAgICAgaWYgKGJyZWFrQ29udGVudHMpIHtcbiAgICAgICAgICAgIGNtZHMucHVzaCh7IGluZCwgbW9kZSwgZG9jOiBicmVha0NvbnRlbnRzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0ZMQVQpIHtcbiAgICAgICAgICBjb25zdCBmbGF0Q29udGVudHMgPSBkb2MyLnR5cGUgPT09IERPQ19UWVBFX0lGX0JSRUFLID8gZG9jMi5mbGF0Q29udGVudHMgOiBkb2MyLm5lZ2F0ZSA/IGluZGVudChkb2MyLmNvbnRlbnRzKSA6IGRvYzIuY29udGVudHM7XG4gICAgICAgICAgaWYgKGZsYXRDb250ZW50cykge1xuICAgICAgICAgICAgY21kcy5wdXNoKHsgaW5kLCBtb2RlLCBkb2M6IGZsYXRDb250ZW50cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIERPQ19UWVBFX0xJTkVfU1VGRklYOlxuICAgICAgICBsaW5lU3VmZml4Mi5wdXNoKHsgaW5kLCBtb2RlLCBkb2M6IGRvYzIuY29udGVudHMgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET0NfVFlQRV9MSU5FX1NVRkZJWF9CT1VOREFSWTpcbiAgICAgICAgaWYgKGxpbmVTdWZmaXgyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjbWRzLnB1c2goeyBpbmQsIG1vZGUsIGRvYzogaGFyZGxpbmVXaXRob3V0QnJlYWtQYXJlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0xJTkU6XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgIGNhc2UgTU9ERV9GTEFUOlxuICAgICAgICAgICAgaWYgKCFkb2MyLmhhcmQpIHtcbiAgICAgICAgICAgICAgaWYgKCFkb2MyLnNvZnQpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG91bGRSZW1lYXN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgY2FzZSBNT0RFX0JSRUFLOlxuICAgICAgICAgICAgaWYgKGxpbmVTdWZmaXgyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY21kcy5wdXNoKHsgaW5kLCBtb2RlLCBkb2M6IGRvYzIgfSwgLi4ubGluZVN1ZmZpeDIucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgbGluZVN1ZmZpeDIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9jMi5saXRlcmFsKSB7XG4gICAgICAgICAgICAgIGlmIChpbmQucm9vdCkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5ld0xpbmUsIGluZC5yb290LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBwb3MgPSBpbmQucm9vdC5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3TGluZSk7XG4gICAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zIC09IHRyaW0yKG91dCk7XG4gICAgICAgICAgICAgIG91dC5wdXNoKG5ld0xpbmUgKyBpbmQudmFsdWUpO1xuICAgICAgICAgICAgICBwb3MgPSBpbmQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0xBQkVMOlxuICAgICAgICBjbWRzLnB1c2goeyBpbmQsIG1vZGUsIGRvYzogZG9jMi5jb250ZW50cyB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ19UWVBFX0JSRUFLX1BBUkVOVDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgaW52YWxpZF9kb2NfZXJyb3JfZGVmYXVsdChkb2MyKTtcbiAgICB9XG4gICAgaWYgKGNtZHMubGVuZ3RoID09PSAwICYmIGxpbmVTdWZmaXgyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNtZHMucHVzaCguLi5saW5lU3VmZml4Mi5yZXZlcnNlKCkpO1xuICAgICAgbGluZVN1ZmZpeDIubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY3Vyc29yUGxhY2Vob2xkZXJJbmRleCA9IG91dC5pbmRleE9mKENVUlNPUl9QTEFDRUhPTERFUik7XG4gIGlmIChjdXJzb3JQbGFjZWhvbGRlckluZGV4ICE9PSAtMSkge1xuICAgIGNvbnN0IG90aGVyQ3Vyc29yUGxhY2Vob2xkZXJJbmRleCA9IG91dC5pbmRleE9mKFxuICAgICAgQ1VSU09SX1BMQUNFSE9MREVSLFxuICAgICAgY3Vyc29yUGxhY2Vob2xkZXJJbmRleCArIDFcbiAgICApO1xuICAgIGlmIChvdGhlckN1cnNvclBsYWNlaG9sZGVySW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXR0ZWQ6IG91dC5maWx0ZXIoKGNoYXIpID0+IGNoYXIgIT09IENVUlNPUl9QTEFDRUhPTERFUikuam9pbihcIlwiKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlQ3Vyc29yID0gb3V0LnNsaWNlKDAsIGN1cnNvclBsYWNlaG9sZGVySW5kZXgpLmpvaW4oXCJcIik7XG4gICAgY29uc3QgYXJvdW5kQ3Vyc29yID0gb3V0LnNsaWNlKGN1cnNvclBsYWNlaG9sZGVySW5kZXggKyAxLCBvdGhlckN1cnNvclBsYWNlaG9sZGVySW5kZXgpLmpvaW4oXCJcIik7XG4gICAgY29uc3QgYWZ0ZXJDdXJzb3IgPSBvdXQuc2xpY2Uob3RoZXJDdXJzb3JQbGFjZWhvbGRlckluZGV4ICsgMSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0dGVkOiBiZWZvcmVDdXJzb3IgKyBhcm91bmRDdXJzb3IgKyBhZnRlckN1cnNvcixcbiAgICAgIGN1cnNvck5vZGVTdGFydDogYmVmb3JlQ3Vyc29yLmxlbmd0aCxcbiAgICAgIGN1cnNvck5vZGVUZXh0OiBhcm91bmRDdXJzb3JcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGZvcm1hdHRlZDogb3V0LmpvaW4oXCJcIikgfTtcbn1cblxuLy8gc3JjL2RvY3VtZW50L3B1YmxpYy5qc1xudmFyIGJ1aWxkZXJzID0ge1xuICBqb2luLFxuICBsaW5lLFxuICBzb2Z0bGluZSxcbiAgaGFyZGxpbmUsXG4gIGxpdGVyYWxsaW5lLFxuICBncm91cCxcbiAgY29uZGl0aW9uYWxHcm91cCxcbiAgZmlsbCxcbiAgbGluZVN1ZmZpeCxcbiAgbGluZVN1ZmZpeEJvdW5kYXJ5LFxuICBjdXJzb3IsXG4gIGJyZWFrUGFyZW50LFxuICBpZkJyZWFrLFxuICB0cmltLFxuICBpbmRlbnQsXG4gIGluZGVudElmQnJlYWssXG4gIGFsaWduLFxuICBhZGRBbGlnbm1lbnRUb0RvYyxcbiAgbWFya0FzUm9vdCxcbiAgZGVkZW50VG9Sb290LFxuICBkZWRlbnQsXG4gIGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50LFxuICBsaXRlcmFsbGluZVdpdGhvdXRCcmVha1BhcmVudCxcbiAgbGFiZWwsXG4gIC8vIFRPRE86IFJlbW92ZSB0aGlzIGluIHY0XG4gIGNvbmNhdDogKHBhcnRzKSA9PiBwYXJ0c1xufTtcbnZhciBwcmludGVyID0geyBwcmludERvY1RvU3RyaW5nIH07XG52YXIgdXRpbHMgPSB7XG4gIHdpbGxCcmVhayxcbiAgdHJhdmVyc2VEb2M6IHRyYXZlcnNlX2RvY19kZWZhdWx0LFxuICBmaW5kSW5Eb2MsXG4gIG1hcERvYyxcbiAgcmVtb3ZlTGluZXMsXG4gIHN0cmlwVHJhaWxpbmdIYXJkbGluZSxcbiAgcmVwbGFjZUVuZE9mTGluZSxcbiAgY2FuQnJlYWtcbn07XG5cbi8vIHdpdGgtZGVmYXVsdC1leHBvcnQ6c3JjL2RvY3VtZW50L3B1YmxpYy5qc1xudmFyIHB1YmxpY19kZWZhdWx0ID0gcHVibGljX2V4cG9ydHM7XG5leHBvcnQge1xuICBidWlsZGVycyxcbiAgcHVibGljX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgcHJpbnRlcixcbiAgdXRpbHNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/prettier/doc.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js":
/*!*********************************************************!*\
  !*** ./node_modules/regexp-to-ast/lib/regexp-to-ast.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {\n    // istanbul ignore next\n    if (true) {\n        // istanbul ignore next\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead  DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWdleHAtdG8tYXN0L2xpYi9yZWdleHAtdG8tYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLGlHQUFDO0FBQ0Q7QUFDQSxRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDM0IsTUFBTSxLQUFLLEVBS047QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xccmVnZXhwLXRvLWFzdFxcbGliXFxyZWdleHAtdG8tYXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICByb290LnJlZ2V4cFRvQXN0ID0gZmFjdG9yeSgpXG4gICAgfVxufSkoXG4gICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHNlbGZcbiAgICAgICAgOiB0aGlzLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZWZlcmVuY2VzXG4gICAgICAgIC8vIGh0dHBzOi8vaGFja2Vybm9vbi5jb20vdGhlLW1hZG5lc3Mtb2YtcGFyc2luZy1yZWFsLXdvcmxkLWphdmFzY3JpcHQtcmVnZXhwcy1kOWVlMzM2ZGY5ODNcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvaW5kZXguaHRtbCNwcm9kLVBhdHRlcm5cbiAgICAgICAgZnVuY3Rpb24gUmVnRXhwUGFyc2VyKCkge31cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZHg6IHRoaXMuaWR4LFxuICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgICAgIGdyb3VwSWR4OiB0aGlzLmdyb3VwSWR4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IG5ld1N0YXRlLmlkeFxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG5ld1N0YXRlLmlucHV0XG4gICAgICAgICAgICB0aGlzLmdyb3VwSWR4ID0gbmV3U3RhdGUuZ3JvdXBJZHhcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUucGF0dGVybiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaWR4ID0gMFxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0XG4gICAgICAgICAgICB0aGlzLmdyb3VwSWR4ID0gMFxuXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5kaXNqdW5jdGlvbigpXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKVxuXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJGbGFnc1wiLFxuICAgICAgICAgICAgICAgIGxvYzogeyBiZWdpbjogdGhpcy5pZHgsIGVuZDogaW5wdXQubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuaWNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0aWNreTogZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNSZWdFeHBGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcImdsb2JhbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwiaWdub3JlQ2FzZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwibXVsdGlMaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJ1bmljb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJzdGlja3lcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pZHggIT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVkdW5kYW50IGlucHV0OiBcIiArIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaWR4KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQYXR0ZXJuXCIsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKDApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmRpc2p1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWx0cyA9IFtdXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmlkeFxuXG4gICAgICAgICAgICBhbHRzLnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrQ2hhcigpID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ8XCIpXG4gICAgICAgICAgICAgICAgYWx0cy5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJEaXNqdW5jdGlvblwiLCB2YWx1ZTogYWx0cywgbG9jOiB0aGlzLmxvYyhiZWdpbikgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRlcm1zID0gW11cbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuaWR4XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzVGVybSgpKSB7XG4gICAgICAgICAgICAgICAgdGVybXMucHVzaCh0aGlzLnRlcm0oKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJBbHRlcm5hdGl2ZVwiLCB2YWx1ZTogdGVybXMsIGxvYzogdGhpcy5sb2MoYmVnaW4pIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUudGVybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3NlcnRpb24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VydGlvbigpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0b20oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5hc3NlcnRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuaWR4XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU3RhcnRBbmNob3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogdGhpcy5sb2MoYmVnaW4pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkVuZEFuY2hvclwiLCBsb2M6IHRoaXMubG9jKGJlZ2luKSB9XG4gICAgICAgICAgICAgICAgLy8gJ1xcYicgb3IgJ1xcQidcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiV29yZEJvdW5kYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogdGhpcy5sb2MoYmVnaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIk5vbldvcmRCb3VuZGFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKGJlZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgQXNzZXJ0aW9uIEVzY2FwZVwiKVxuICAgICAgICAgICAgICAgIC8vICcoPz0nIG9yICcoPyEnXG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIilcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIkxvb2thaGVhZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiTmVnYXRpdmVMb29rYWhlYWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyh0eXBlKVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNqdW5jdGlvbiA9IHRoaXMuZGlzanVuY3Rpb24oKVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIpXCIpXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGlzanVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKGJlZ2luKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5xdWFudGlmaWVyID0gZnVuY3Rpb24oaXNCYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5pZHhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdExlYXN0ID0gdGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogYXRMZWFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXRNb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEaWdpdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdCA9IHRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IGF0TW9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiBhdExlYXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBJbmZpbml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ9XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd2luZyBleGNlcHRpb25zIGZyb20gXCJBU1NFUlRfRVhJU1RTXCIgZHVyaW5nIGJhY2t0cmFja2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXVzZXMgc2V2ZXJlIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrdHJhY2tpbmcgPT09IHRydWUgJiYgcmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEFTU0VSVF9FWElTVFMocmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRocm93aW5nIGV4Y2VwdGlvbnMgZnJvbSBcIkFTU0VSVF9FWElTVFNcIiBkdXJpbmcgYmFja3RyYWNraW5nXG4gICAgICAgICAgICAvLyBjYXVzZXMgc2V2ZXJlIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uc1xuICAgICAgICAgICAgaWYgKGlzQmFja3RyYWNraW5nID09PSB0cnVlICYmIHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMocmFuZ2UpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDaGFyKDApID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpXG4gICAgICAgICAgICAgICAgcmFuZ2UuZ3JlZWR5ID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZ3JlZWR5ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYW5nZS50eXBlID0gXCJRdWFudGlmaWVyXCJcbiAgICAgICAgICAgIHJhbmdlLmxvYyA9IHRoaXMubG9jKGJlZ2luKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdG9tXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmlkeFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5kb3RBbGwoKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmF0b21Fc2NhcGUoKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmNoYXJhY3RlckNsYXNzKClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5ncm91cCgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdG9tID09PSB1bmRlZmluZWQgJiYgdGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLnBhdHRlcm5DaGFyYWN0ZXIoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBU1NFUlRfRVhJU1RTKGF0b20pXG5cbiAgICAgICAgICAgIGF0b20ubG9jID0gdGhpcy5sb2MoYmVnaW4pXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUXVhbnRpZmllcigpKSB7XG4gICAgICAgICAgICAgICAgYXRvbS5xdWFudGlmaWVyID0gdGhpcy5xdWFudGlmaWVyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF0b21cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuZG90QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiLlwiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlNldFwiLFxuICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFtjYyhcIlxcblwiKSwgY2MoXCJcXHJcIiksIGNjKFwiXFx1MjAyOFwiKSwgY2MoXCJcXHUyMDI5XCIpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5hdG9tRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiOVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsRXNjYXBlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlckNsYXNzRXNjYXBlKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVsQ2hhcmFjdGVyQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGV4RXNjYXBlU2VxdWVuY2VBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tKClcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5kZWNpbWFsRXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wb3NpdGl2ZUludGVnZXIoKVxuXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkdyb3VwQmFja1JlZmVyZW5jZVwiLCB2YWx1ZTogdmFsdWUgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldFxuICAgICAgICAgICAgdmFyIGNvbXBsZW1lbnQgPSBmYWxzZVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IGRpZ2l0c0NoYXJDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IGRpZ2l0c0NoYXJDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHdoaXRlc3BhY2VDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHdoaXRlc3BhY2VDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHdvcmRDaGFyQ29kZXNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgICAgICBzZXQgPSB3b3JkQ2hhckNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMoc2V0KVxuXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIlNldFwiLCB2YWx1ZTogc2V0LCBjb21wbGVtZW50OiBjb21wbGVtZW50IH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuY29udHJvbEVzY2FwZUF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGVDb2RlXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFxmXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFxyXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFx2XCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBU1NFUlRfRVhJU1RTKGVzY2FwZUNvZGUpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBlc2NhcGVDb2RlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuY29udHJvbExldHRlckVzY2FwZUF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJjXCIpXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gdGhpcy5wb3BDaGFyKClcbiAgICAgICAgICAgIGlmICgvW2EtekEtWl0vLnRlc3QobGV0dGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZXR0ZXJDb2RlID0gbGV0dGVyLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSAtIDY0XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogbGV0dGVyQ29kZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLm51bENoYXJhY3RlckF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50ICdbbG9va2FoZWFkIOKIiSBEZWNpbWFsRGlnaXRdJ1xuICAgICAgICAgICAgLy8gVE9ETzogZm9yIHRoZSBkZXByZWNhdGVkIG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIjBcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhcIlxcMFwiKSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmhleEVzY2FwZVNlcXVlbmNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcInhcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGV4RGlnaXRzKDIpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ1XCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhleERpZ2l0cyg0KVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pZGVudGl0eUVzY2FwZUF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBcIlNvdXJjZUNoYXJhY3RlciBidXQgbm90IFVuaWNvZGVJRENvbnRpbnVlXCJcbiAgICAgICAgICAgIC8vIC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzEvI1NwZWNpZmljX0NoYXJhY3Rlcl9BZGp1c3RtZW50c1xuICAgICAgICAgICAgdmFyIGVzY2FwZWRDaGFyID0gdGhpcy5wb3BDaGFyKClcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhlc2NhcGVkQ2hhcikgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jbGFzc1BhdHRlcm5DaGFyYWN0ZXJBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIilcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MobmV4dENoYXIpIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuY2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSBbXVxuICAgICAgICAgICAgdmFyIGNvbXBsZW1lbnQgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIltcIilcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDaGFyKDApID09PSBcIl5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJeXCIpXG4gICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNDbGFzc0F0b20oKSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5jbGFzc0F0b20oKVxuICAgICAgICAgICAgICAgIHZhciBpc0Zyb21TaW5nbGVDaGFyID0gZnJvbS50eXBlID09PSBcIkNoYXJhY3RlclwiXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvbVNpbmdsZUNoYXIgJiYgdGhpcy5pc1JhbmdlRGFzaCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCItXCIpXG4gICAgICAgICAgICAgICAgICAgIHZhciB0byA9IHRoaXMuY2xhc3NBdG9tKClcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzVG9TaW5nbGVDaGFyID0gdG8udHlwZSA9PT0gXCJDaGFyYWN0ZXJcIlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmFuZ2UgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGJvdGggc2lkZXMgYXJlIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RvU2luZ2xlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvLnZhbHVlIDwgZnJvbS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goeyBmcm9tOiBmcm9tLnZhbHVlLCB0bzogdG8udmFsdWUgfSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpdGVyYWwgZGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VG9TZXQoZnJvbS52YWx1ZSwgc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goY2MoXCItXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VG9TZXQodG8udmFsdWUsIHNldClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRvU2V0KGZyb20udmFsdWUsIHNldClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJdXCIpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiU2V0XCIsIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsIHZhbHVlOiBzZXQgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jbGFzc0F0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVEJEXCIpXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NFc2NhcGUoKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIlxcXFxcIilcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBhIGJhY2tzcGFjZS5cbiAgICAgICAgICAgICAgICAvLyAoTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggXFxiIHdvcmQgYm91bmRhcnkgb3V0c2lkZSBjaGFyYWN0ZXJDbGFzcylcbiAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiYlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MoXCJcXHUwMDA4XCIpIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyaW5nID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIihcIilcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI6XCIpXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmluZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cElkeCsrXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRpc2p1bmN0aW9uKClcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIpXCIpXG5cbiAgICAgICAgICAgIHZhciBncm91cEFzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICAgICAgICAgICAgY2FwdHVyaW5nOiBjYXB0dXJpbmcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYXB0dXJpbmcpIHtcbiAgICAgICAgICAgICAgICBncm91cEFzdC5pZHggPSB0aGlzLmdyb3VwSWR4XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBncm91cEFzdFxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wb3NpdGl2ZUludGVnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLnBvcENoYXIoKVxuXG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNhbid0IGV2ZXIgZ2V0IGhlcmUgZHVlIHRvIHByZXZpb3VzIGxvb2thaGVhZCBjaGVja3NcbiAgICAgICAgICAgIC8vIHN0aWxsIGltcGxlbWVudGluZyB0aGlzIGVycm9yIGNoZWNraW5nIGluIGNhc2UgdGhpcyBldmVyIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhdHRlcm5Ob1plcm8udGVzdChudW1iZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoZGVjaW1hbFBhdHRlcm4udGVzdCh0aGlzLnBlZWtDaGFyKDApKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCAxMClcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaW50ZWdlckluY2x1ZGluZ1plcm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXR0ZXJuLnRlc3QobnVtYmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhbiBpbnRlZ2VyXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1iZXIsIDEwKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIilcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MobmV4dENoYXIpIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzUmVnRXhwRmxhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc1JhbmdlRGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVla0NoYXIoKSA9PT0gXCItXCIgJiYgdGhpcy5pc0NsYXNzQXRvbSgxKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc0RpZ2l0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhdHRlcm4udGVzdCh0aGlzLnBlZWtDaGFyKDApKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc0NsYXNzQXRvbSA9IGZ1bmN0aW9uKGhvd011Y2gpIHtcbiAgICAgICAgICAgIGlmIChob3dNdWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3dNdWNoID0gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoaG93TXVjaCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc1Rlcm0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQXRvbSgpIHx8IHRoaXMuaXNBc3NlcnRpb24oKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc0F0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOiAvLyBhdG9tRXNjYXBlXG4gICAgICAgICAgICAgICAgY2FzZSBcIltcIjogLy8gY2hhcmFjdGVyQ2xhc3NcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpc0F0b20gbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGlzQXNzZXJ0aW9uIC0gZGlzYW1iaWd1YXRlXG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjogLy8gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNBc3NlcnRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAvLyAnXFxiJyBvciAnXFxCJ1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAnKD89JyBvciAnKD8hJ1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlZWtDaGFyKDEpID09PSBcIj9cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucGVla0NoYXIoMikgPT09IFwiPVwiIHx8IHRoaXMucGVla0NoYXIoMikgPT09IFwiIVwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzUXVhbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc2F2ZVN0YXRlKClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhbnRpZmllcih0cnVlKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVN0YXRlKHByZXZTdGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wYXJzZUhleERpZ2l0cyA9IGZ1bmN0aW9uKGhvd01hbnkpIHtcbiAgICAgICAgICAgIHZhciBoZXhTdHJpbmcgPSBcIlwiXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZXhDaGFyID0gdGhpcy5wb3BDaGFyKClcbiAgICAgICAgICAgICAgICBpZiAoaGV4RGlnaXRQYXR0ZXJuLnRlc3QoaGV4Q2hhcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgSGV4RGVjaW1hbCBkaWdpdHNcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGV4U3RyaW5nICs9IGhleENoYXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KGhleFN0cmluZywgMTYpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2hhckNvZGUgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wZWVrQ2hhciA9IGZ1bmN0aW9uKGhvd011Y2gpIHtcbiAgICAgICAgICAgIGlmIChob3dNdWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3dNdWNoID0gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRbdGhpcy5pZHggKyBob3dNdWNoXVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wb3BDaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSB0aGlzLnBlZWtDaGFyKDApXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKClcbiAgICAgICAgICAgIHJldHVybiBuZXh0Q2hhclxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lQ2hhciA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbnB1dFt0aGlzLmlkeF0gIT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZDogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInIGJ1dCBmb3VuZDogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRbdGhpcy5pZHhdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJyBhdCBvZmZzZXQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWR4XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pZHggPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlkeCsrXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uKGJlZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4geyBiZWdpbjogYmVnaW4sIGVuZDogdGhpcy5pZHggfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RzIGFuZCB1dGlsaXRpZXNcbiAgICAgICAgdmFyIGhleERpZ2l0UGF0dGVybiA9IC9bMC05YS1mQS1GXS9cbiAgICAgICAgdmFyIGRlY2ltYWxQYXR0ZXJuID0gL1swLTldL1xuICAgICAgICB2YXIgZGVjaW1hbFBhdHRlcm5Ob1plcm8gPSAvWzEtOV0vXG5cbiAgICAgICAgZnVuY3Rpb24gY2MoY2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXIuY2hhckNvZGVBdCgwKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0VG9TZXQoaXRlbSwgc2V0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZm9yRWFjaChmdW5jdGlvbihzdWJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKHN1Ykl0ZW0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0LnB1c2goaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZsYWcoZmxhZ09iaiwgZmxhZ0tleSkge1xuICAgICAgICAgICAgaWYgKGZsYWdPYmpbZmxhZ0tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcImR1cGxpY2F0ZSBmbGFnIFwiICsgZmxhZ0tleVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbGFnT2JqW2ZsYWdLZXldID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQVNTRVJUX0VYSVNUUyhvYmopIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZnVuY3Rpb24gQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlcbiAgICAgICAgdmFyIGRpZ2l0c0NoYXJDb2RlcyA9IFtdXG4gICAgICAgIGZvciAoaSA9IGNjKFwiMFwiKTsgaSA8PSBjYyhcIjlcIik7IGkrKykge1xuICAgICAgICAgICAgZGlnaXRzQ2hhckNvZGVzLnB1c2goaSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JkQ2hhckNvZGVzID0gW2NjKFwiX1wiKV0uY29uY2F0KGRpZ2l0c0NoYXJDb2RlcylcbiAgICAgICAgZm9yIChpID0gY2MoXCJhXCIpOyBpIDw9IGNjKFwielwiKTsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkQ2hhckNvZGVzLnB1c2goaSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IGNjKFwiQVwiKTsgaSA8PSBjYyhcIlpcIik7IGkrKykge1xuICAgICAgICAgICAgd29yZENoYXJDb2Rlcy5wdXNoKGkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAjY2hhcmFjdGVyLWNsYXNzZXNcbiAgICAgICAgdmFyIHdoaXRlc3BhY2VDb2RlcyA9IFtcbiAgICAgICAgICAgIGNjKFwiIFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFxmXCIpLFxuICAgICAgICAgICAgY2MoXCJcXG5cIiksXG4gICAgICAgICAgICBjYyhcIlxcclwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx0XCIpLFxuICAgICAgICAgICAgY2MoXCJcXHZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MDBhMFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MTY4MFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwMFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwMVwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwMlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwM1wiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwNFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwNVwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwNlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwN1wiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwOFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwOVwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAwYVwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAyOFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAyOVwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjAyZlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MjA1ZlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1MzAwMFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx1ZmVmZlwiKVxuICAgICAgICBdXG5cbiAgICAgICAgZnVuY3Rpb24gQmFzZVJlZ0V4cFZpc2l0b3IoKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoaWxkcmVuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2tleV1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbihzdWJDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoc3ViQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGbGFnc1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RmxhZ3Mobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRGlzanVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdERpc2p1bmN0aW9uKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFsdGVybmF0aXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbHRlcm5hdGl2ZShub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3RhcnRBbmNob3Iobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRW5kQW5jaG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRFbmRBbmNob3Iobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRXb3JkQm91bmRhcnkobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTm9uV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXROb25Xb3JkQm91bmRhcnkobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRMb29rYWhlYWQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTmVnYXRpdmVMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdE5lZ2F0aXZlTG9va2FoZWFkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkNoYXJhY3RlclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0Q2hhcmFjdGVyKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIlNldFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U2V0KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRHcm91cChub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHcm91cEJhY2tSZWZlcmVuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEdyb3VwQmFja1JlZmVyZW5jZShub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJRdWFudGlmaWVyXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRRdWFudGlmaWVyKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihub2RlKVxuICAgICAgICB9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGF0dGVybiA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RmxhZ3MgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpc2p1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgLy8gQXNzZXJ0aW9uXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YXJ0QW5jaG9yID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbmRBbmNob3IgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdvcmRCb3VuZGFyeSA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uV29yZEJvdW5kYXJ5ID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRMb29rYWhlYWQgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5lZ2F0aXZlTG9va2FoZWFkID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICAvLyBhdG9tc1xuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNldCA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdyb3VwQmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVhbnRpZmllciA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFJlZ0V4cFBhcnNlcjogUmVnRXhwUGFyc2VyLFxuICAgICAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3I6IEJhc2VSZWdFeHBWaXNpdG9yLFxuICAgICAgICAgICAgVkVSU0lPTjogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICB9XG4pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\n"));

/***/ })

}]);