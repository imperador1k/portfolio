"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_utils_imageDecoder_ts"],{

/***/ "(pages-dir-browser)/./components/apps/Photos/qoi.ts":
/*!***************************************!*\
  !*** ./components/apps/Photos/qoi.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeQoi: () => (/* binding */ decodeQoi)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* eslint-disable */ // @ts-nocheck\nfunction adler32(data) {\n    let s1 = 0;\n    let s2 = 0;\n    for (const datum of data){\n        s1 = (s1 + datum) % 65521;\n        s2 = (s2 + s1) % 65521;\n    }\n    return [\n        s2 >> 8,\n        s2 & 0xff,\n        s1 >> 8,\n        s1 & 0xff\n    ];\n}\nfunction crc32(data) {\n    const table = [];\n    let crc = 0;\n    for(let index = 0; index < 256; ++index){\n        crc = index;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        crc = crc & 1 ? 0xedb88320 ^ crc >>> 1 : crc >>> 1;\n        table[index] = crc;\n    }\n    crc = -1;\n    for (const datum of data){\n        crc = crc >>> 8 ^ table[(crc ^ datum) & 0xff];\n    }\n    crc ^= -1;\n    return [\n        crc >> 24 & 0xff,\n        crc >> 16 & 0xff,\n        crc >> 8 & 0xff,\n        crc & 0xff\n    ];\n}\nfunction encode_png(canvas, width, channels) {\n    const idat = [];\n    const zlib = [\n        0x78,\n        0x01\n    ];\n    const len = 1 + width * channels;\n    const nlen = len ^ 0xffff;\n    for(let line_begin = 0; canvas.length != line_begin; line_begin += width){\n        const line_end = line_begin + width;\n        zlib.push(line_end === canvas.length ? 0x01 : 0x00, len & 0xff, len >> 8 & 0xff, nlen & 0xff, nlen >> 8 & 0xff);\n        idat.push(0x01);\n        zlib.push(0x00);\n        for(let position = line_begin; line_end !== position; ++position){\n            const pixel = canvas[position];\n            idat.push(pixel >> 24 & 0xff);\n            zlib.push(pixel >> 24 & 0xff);\n            idat.push(pixel >> 16 & 0xff);\n            zlib.push(pixel >> 16 & 0xff);\n            idat.push(pixel >> 8 & 0xff);\n            zlib.push(pixel >> 8 & 0xff);\n            if (channels === 4) {\n                idat.push(pixel & 0xff);\n                zlib.push(pixel & 0xff);\n            }\n        }\n    }\n    const height = canvas.length / width;\n    return [\n        137,\n        80,\n        78,\n        71,\n        13,\n        10,\n        26,\n        10\n    ].concat(encode_png_chunk(\"IHDR\", [\n        width >> 24 & 0xff,\n        width >> 16 & 0xff,\n        width >> 8 & 0xff,\n        width & 0xff,\n        height >> 24 & 0xff,\n        height >> 16 & 0xff,\n        height >> 8 & 0xff,\n        height & 0xff,\n        8,\n        channels === 3 ? 2 : 6,\n        0,\n        0,\n        0\n    ]), encode_png_chunk(\"IDAT\", zlib.concat(adler32(idat))), encode_png_chunk(\"IEND\"));\n}\nfunction encode_png_chunk(tag, data = []) {\n    const { length } = data;\n    const content = [\n        tag.charCodeAt(0),\n        tag.charCodeAt(1),\n        tag.charCodeAt(2),\n        tag.charCodeAt(3)\n    ].concat(data);\n    return [\n        length >> 24 & 0xff,\n        length >> 16 & 0xff,\n        length >> 8 & 0xff,\n        length & 0xff\n    ].concat(content, crc32(content));\n}\nfunction transcode_qoi_to_png(data) {\n    if (data.length < 22 || data[0] !== 0x71 || data[1] !== 0x6f || data[2] !== 0x69 || data[3] !== 0x66) {\n        return;\n    }\n    const width = data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7];\n    const channels = data[12];\n    const colorspace = data[13];\n    if (channels !== 3 && channels !== 4 && colorspace !== 1) {\n        return;\n    }\n    const length = data.length - 8;\n    const canvas = [];\n    const map = Array.from({\n        length: 64\n    }).fill(0x00000000);\n    let pixel = 0x000000ff;\n    let position = 14;\n    while(position < length){\n        const byte = data[position];\n        const tag = byte >> 6;\n        if (byte === 0xff) {\n            // QOI_OP_RGBA\n            const r = data[position + 1];\n            const g = data[position + 2];\n            const b = data[position + 3];\n            const a = data[position + 4];\n            position += 5;\n            pixel = r << 24 | g << 16 | b << 8 | a;\n            map[(r * 3 + g * 5 + b * 7 + a * 11) % 64] = pixel;\n            canvas.push(pixel);\n        } else if (byte === 0xfe) {\n            // QOI_OP_RGB\n            const r = data[position + 1];\n            const g = data[position + 2];\n            const b = data[position + 3];\n            const a = pixel & 0xff;\n            position += 4;\n            pixel = r << 24 | g << 16 | b << 8 | a;\n            map[(r * 3 + g * 5 + b * 7 + a * 11) % 64] = pixel;\n            canvas.push(pixel);\n        } else if (tag === 0x00) {\n            // QOI_OP_INDEX\n            if (data[position] === 0x00 && data[position + 1] === 0x00 && data[position + 2] === 0x00 && data[position + 3] === 0x00 && data[position + 4] === 0x00 && data[position + 5] === 0x00 && data[position + 6] === 0x00 && data[position + 7] === 0x01) {\n                break;\n            }\n            position += 1;\n            pixel = map[byte];\n            canvas.push(pixel);\n        } else if (tag === 0x01) {\n            // QOI_OP_DIFF\n            const dr = (byte >> 4 & 0x03) - 2;\n            const dg = (byte >> 2 & 0x03) - 2;\n            const db = (byte & 0x03) - 2;\n            const r = (pixel >> 24 & 0xff) + dr & 0xff;\n            const g = (pixel >> 16 & 0xff) + dg & 0xff;\n            const b = (pixel >> 8 & 0xff) + db & 0xff;\n            const a = pixel & 0xff;\n            position += 1;\n            pixel = r << 24 | g << 16 | b << 8 | a;\n            map[(r * 3 + g * 5 + b * 7 + a * 11) % 64] = pixel;\n            canvas.push(pixel);\n        } else if (tag === 0x02) {\n            // QOI_OP_DIFF\n            const byte_2 = data[position + 1];\n            const dg = (byte & 0x3f) - 32 & 0xff;\n            const dr = (byte_2 >> 4 & 0x0f) - 8 + dg & 0xff;\n            const db = (byte_2 & 0x0f) - 8 + dg & 0xff;\n            const r = (pixel >> 24 & 0xff) + dr & 0xff;\n            const g = (pixel >> 16 & 0xff) + dg & 0xff;\n            const b = (pixel >> 8 & 0xff) + db & 0xff;\n            const a = pixel & 0xff;\n            position += 2;\n            pixel = r << 24 | g << 16 | b << 8 | a;\n            map[(r * 3 + g * 5 + b * 7 + a * 11) % 64] = pixel;\n            canvas.push(pixel);\n        } else {\n            // QOI_OP_RUN\n            for(let count = (byte & 0x3f) + 1; count > 0; --count){\n                canvas.push(pixel);\n            }\n            position += 1;\n        }\n    }\n    return encode_png(canvas, width, channels);\n}\nconst decodeQoi = (imgData)=>Buffer.from(new Uint8Array(transcode_qoi_to_png(new Uint8Array(imgData))));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9QaG90b3MvcW9pLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0JBQWtCLEdBQ2xCLGNBQWM7QUFFZCxTQUFTQSxRQUFRQyxJQUFJO0lBQ25CLElBQUlDLEtBQUs7SUFDVCxJQUFJQyxLQUFLO0lBQ1QsS0FBSyxNQUFNQyxTQUFTSCxLQUFNO1FBQ3hCQyxLQUFLLENBQUNBLEtBQUtFLEtBQUksSUFBSztRQUNwQkQsS0FBSyxDQUFDQSxLQUFLRCxFQUFDLElBQUs7SUFDbkI7SUFDQSxPQUFPO1FBQUNDLE1BQU07UUFBR0EsS0FBSztRQUFNRCxNQUFNO1FBQUdBLEtBQUs7S0FBSztBQUNqRDtBQUVBLFNBQVNHLE1BQU1KLElBQUk7SUFDakIsTUFBTUssUUFBUSxFQUFFO0lBQ2hCLElBQUlDLE1BQU07SUFDVixJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUSxLQUFLLEVBQUVBLE1BQU87UUFDeENELE1BQU1DO1FBQ05ELE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRBLE1BQU1BLE1BQU0sSUFBSSxhQUFjQSxRQUFRLElBQUtBLFFBQVE7UUFDbkRELEtBQUssQ0FBQ0UsTUFBTSxHQUFHRDtJQUNqQjtJQUVBQSxNQUFNLENBQUM7SUFDUCxLQUFLLE1BQU1ILFNBQVNILEtBQU07UUFDeEJN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LENBQUNFO1lBQ2Q7WUFDQUQsWUFBWTtRQUNkO0lBQ0Y7SUFDQSxPQUFPWixXQUFXQyxRQUFRQyxPQUFPQztBQUNuQztBQUVPLE1BQU1pQyxZQUFZLENBQUNDLFVBQ3hCQyxNQUFNQSxDQUFDZCxJQUFJLENBQUMsSUFBSWUsV0FBV25CLHFCQUFxQixJQUFJbUIsV0FBV0YsWUFBWSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxQaG90b3NcXHFvaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4vLyBAdHMtbm9jaGVja1xyXG5cclxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XHJcbiAgbGV0IHMxID0gMDtcclxuICBsZXQgczIgPSAwO1xyXG4gIGZvciAoY29uc3QgZGF0dW0gb2YgZGF0YSkge1xyXG4gICAgczEgPSAoczEgKyBkYXR1bSkgJSA2NTUyMTtcclxuICAgIHMyID0gKHMyICsgczEpICUgNjU1MjE7XHJcbiAgfVxyXG4gIHJldHVybiBbczIgPj4gOCwgczIgJiAweGZmLCBzMSA+PiA4LCBzMSAmIDB4ZmZdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmMzMihkYXRhKSB7XHJcbiAgY29uc3QgdGFibGUgPSBbXTtcclxuICBsZXQgY3JjID0gMDtcclxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMjU2OyArK2luZGV4KSB7XHJcbiAgICBjcmMgPSBpbmRleDtcclxuICAgIGNyYyA9IGNyYyAmIDEgPyAweGVkYjg4MzIwIF4gKGNyYyA+Pj4gMSkgOiBjcmMgPj4+IDE7XHJcbiAgICBjcmMgPSBjcmMgJiAxID8gMHhlZGI4ODMyMCBeIChjcmMgPj4+IDEpIDogY3JjID4+PiAxO1xyXG4gICAgY3JjID0gY3JjICYgMSA/IDB4ZWRiODgzMjAgXiAoY3JjID4+PiAxKSA6IGNyYyA+Pj4gMTtcclxuICAgIGNyYyA9IGNyYyAmIDEgPyAweGVkYjg4MzIwIF4gKGNyYyA+Pj4gMSkgOiBjcmMgPj4+IDE7XHJcbiAgICBjcmMgPSBjcmMgJiAxID8gMHhlZGI4ODMyMCBeIChjcmMgPj4+IDEpIDogY3JjID4+PiAxO1xyXG4gICAgY3JjID0gY3JjICYgMSA/IDB4ZWRiODgzMjAgXiAoY3JjID4+PiAxKSA6IGNyYyA+Pj4gMTtcclxuICAgIGNyYyA9IGNyYyAmIDEgPyAweGVkYjg4MzIwIF4gKGNyYyA+Pj4gMSkgOiBjcmMgPj4+IDE7XHJcbiAgICBjcmMgPSBjcmMgJiAxID8gMHhlZGI4ODMyMCBeIChjcmMgPj4+IDEpIDogY3JjID4+PiAxO1xyXG4gICAgdGFibGVbaW5kZXhdID0gY3JjO1xyXG4gIH1cclxuXHJcbiAgY3JjID0gLTE7XHJcbiAgZm9yIChjb25zdCBkYXR1bSBvZiBkYXRhKSB7XHJcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlWyhjcmMgXiBkYXR1bSkgJiAweGZmXTtcclxuICB9XHJcbiAgY3JjIF49IC0xO1xyXG5cclxuICByZXR1cm4gW1xyXG4gICAgKGNyYyA+PiAyNCkgJiAweGZmLFxyXG4gICAgKGNyYyA+PiAxNikgJiAweGZmLFxyXG4gICAgKGNyYyA+PiA4KSAmIDB4ZmYsXHJcbiAgICBjcmMgJiAweGZmLFxyXG4gIF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY29kZV9wbmcoY2FudmFzLCB3aWR0aCwgY2hhbm5lbHMpIHtcclxuICBjb25zdCBpZGF0ID0gW107XHJcbiAgY29uc3QgemxpYiA9IFsweDc4LCAweDAxXTtcclxuICBjb25zdCBsZW4gPSAxICsgd2lkdGggKiBjaGFubmVscztcclxuICBjb25zdCBubGVuID0gbGVuIF4gMHhmZmZmO1xyXG4gIGZvciAobGV0IGxpbmVfYmVnaW4gPSAwOyBjYW52YXMubGVuZ3RoICE9IGxpbmVfYmVnaW47IGxpbmVfYmVnaW4gKz0gd2lkdGgpIHtcclxuICAgIGNvbnN0IGxpbmVfZW5kID0gbGluZV9iZWdpbiArIHdpZHRoO1xyXG4gICAgemxpYi5wdXNoKFxyXG4gICAgICBsaW5lX2VuZCA9PT0gY2FudmFzLmxlbmd0aCA/IDB4MDEgOiAweDAwLFxyXG4gICAgICBsZW4gJiAweGZmLFxyXG4gICAgICAobGVuID4+IDgpICYgMHhmZixcclxuICAgICAgbmxlbiAmIDB4ZmYsXHJcbiAgICAgIChubGVuID4+IDgpICYgMHhmZlxyXG4gICAgKTtcclxuXHJcbiAgICBpZGF0LnB1c2goMHgwMSk7XHJcbiAgICB6bGliLnB1c2goMHgwMCk7XHJcbiAgICBmb3IgKGxldCBwb3NpdGlvbiA9IGxpbmVfYmVnaW47IGxpbmVfZW5kICE9PSBwb3NpdGlvbjsgKytwb3NpdGlvbikge1xyXG4gICAgICBjb25zdCBwaXhlbCA9IGNhbnZhc1twb3NpdGlvbl07XHJcbiAgICAgIGlkYXQucHVzaCgocGl4ZWwgPj4gMjQpICYgMHhmZik7XHJcbiAgICAgIHpsaWIucHVzaCgocGl4ZWwgPj4gMjQpICYgMHhmZik7XHJcbiAgICAgIGlkYXQucHVzaCgocGl4ZWwgPj4gMTYpICYgMHhmZik7XHJcbiAgICAgIHpsaWIucHVzaCgocGl4ZWwgPj4gMTYpICYgMHhmZik7XHJcbiAgICAgIGlkYXQucHVzaCgocGl4ZWwgPj4gOCkgJiAweGZmKTtcclxuICAgICAgemxpYi5wdXNoKChwaXhlbCA+PiA4KSAmIDB4ZmYpO1xyXG4gICAgICBpZiAoY2hhbm5lbHMgPT09IDQpIHtcclxuICAgICAgICBpZGF0LnB1c2gocGl4ZWwgJiAweGZmKTtcclxuICAgICAgICB6bGliLnB1c2gocGl4ZWwgJiAweGZmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmxlbmd0aCAvIHdpZHRoO1xyXG4gIHJldHVybiBbMTM3LCA4MCwgNzgsIDcxLCAxMywgMTAsIDI2LCAxMF0uY29uY2F0KFxyXG4gICAgZW5jb2RlX3BuZ19jaHVuayhcIklIRFJcIiwgW1xyXG4gICAgICAod2lkdGggPj4gMjQpICYgMHhmZixcclxuICAgICAgKHdpZHRoID4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4ZmYsXHJcbiAgICAgIHdpZHRoICYgMHhmZixcclxuICAgICAgKGhlaWdodCA+PiAyNCkgJiAweGZmLFxyXG4gICAgICAoaGVpZ2h0ID4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweGZmLFxyXG4gICAgICBoZWlnaHQgJiAweGZmLFxyXG4gICAgICA4LFxyXG4gICAgICBjaGFubmVscyA9PT0gMyA/IDIgOiA2LFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgXSksXHJcbiAgICBlbmNvZGVfcG5nX2NodW5rKFwiSURBVFwiLCB6bGliLmNvbmNhdChhZGxlcjMyKGlkYXQpKSksXHJcbiAgICBlbmNvZGVfcG5nX2NodW5rKFwiSUVORFwiKVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY29kZV9wbmdfY2h1bmsodGFnLCBkYXRhID0gW10pIHtcclxuICBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcclxuICBjb25zdCBjb250ZW50ID0gW1xyXG4gICAgdGFnLmNoYXJDb2RlQXQoMCksXHJcbiAgICB0YWcuY2hhckNvZGVBdCgxKSxcclxuICAgIHRhZy5jaGFyQ29kZUF0KDIpLFxyXG4gICAgdGFnLmNoYXJDb2RlQXQoMyksXHJcbiAgXS5jb25jYXQoZGF0YSk7XHJcbiAgcmV0dXJuIFtcclxuICAgIChsZW5ndGggPj4gMjQpICYgMHhmZixcclxuICAgIChsZW5ndGggPj4gMTYpICYgMHhmZixcclxuICAgIChsZW5ndGggPj4gOCkgJiAweGZmLFxyXG4gICAgbGVuZ3RoICYgMHhmZixcclxuICBdLmNvbmNhdChjb250ZW50LCBjcmMzMihjb250ZW50KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zY29kZV9xb2lfdG9fcG5nKGRhdGEpIHtcclxuICBpZiAoXHJcbiAgICBkYXRhLmxlbmd0aCA8IDIyIHx8XHJcbiAgICBkYXRhWzBdICE9PSAweDcxIHx8XHJcbiAgICBkYXRhWzFdICE9PSAweDZmIHx8XHJcbiAgICBkYXRhWzJdICE9PSAweDY5IHx8XHJcbiAgICBkYXRhWzNdICE9PSAweDY2XHJcbiAgKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHdpZHRoID0gKGRhdGFbNF0gPDwgMjQpIHwgKGRhdGFbNV0gPDwgMTYpIHwgKGRhdGFbNl0gPDwgOCkgfCBkYXRhWzddO1xyXG4gIGNvbnN0IGNoYW5uZWxzID0gZGF0YVsxMl07XHJcbiAgY29uc3QgY29sb3JzcGFjZSA9IGRhdGFbMTNdO1xyXG4gIGlmIChjaGFubmVscyAhPT0gMyAmJiBjaGFubmVscyAhPT0gNCAmJiBjb2xvcnNwYWNlICE9PSAxKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIDg7XHJcbiAgY29uc3QgY2FudmFzID0gW107XHJcbiAgY29uc3QgbWFwID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNjQgfSkuZmlsbCgweDAwMDAwMDAwKTtcclxuICBsZXQgcGl4ZWwgPSAweDAwMDAwMGZmO1xyXG4gIGxldCBwb3NpdGlvbiA9IDE0O1xyXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgY29uc3QgYnl0ZSA9IGRhdGFbcG9zaXRpb25dO1xyXG4gICAgY29uc3QgdGFnID0gYnl0ZSA+PiA2O1xyXG4gICAgaWYgKGJ5dGUgPT09IDB4ZmYpIHtcclxuICAgICAgLy8gUU9JX09QX1JHQkFcclxuICAgICAgY29uc3QgciA9IGRhdGFbcG9zaXRpb24gKyAxXTtcclxuICAgICAgY29uc3QgZyA9IGRhdGFbcG9zaXRpb24gKyAyXTtcclxuICAgICAgY29uc3QgYiA9IGRhdGFbcG9zaXRpb24gKyAzXTtcclxuICAgICAgY29uc3QgYSA9IGRhdGFbcG9zaXRpb24gKyA0XTtcclxuICAgICAgcG9zaXRpb24gKz0gNTtcclxuICAgICAgcGl4ZWwgPSAociA8PCAyNCkgfCAoZyA8PCAxNikgfCAoYiA8PCA4KSB8IGE7XHJcbiAgICAgIG1hcFsociAqIDMgKyBnICogNSArIGIgKiA3ICsgYSAqIDExKSAlIDY0XSA9IHBpeGVsO1xyXG4gICAgICBjYW52YXMucHVzaChwaXhlbCk7XHJcbiAgICB9IGVsc2UgaWYgKGJ5dGUgPT09IDB4ZmUpIHtcclxuICAgICAgLy8gUU9JX09QX1JHQlxyXG4gICAgICBjb25zdCByID0gZGF0YVtwb3NpdGlvbiArIDFdO1xyXG4gICAgICBjb25zdCBnID0gZGF0YVtwb3NpdGlvbiArIDJdO1xyXG4gICAgICBjb25zdCBiID0gZGF0YVtwb3NpdGlvbiArIDNdO1xyXG4gICAgICBjb25zdCBhID0gcGl4ZWwgJiAweGZmO1xyXG4gICAgICBwb3NpdGlvbiArPSA0O1xyXG4gICAgICBwaXhlbCA9IChyIDw8IDI0KSB8IChnIDw8IDE2KSB8IChiIDw8IDgpIHwgYTtcclxuICAgICAgbWFwWyhyICogMyArIGcgKiA1ICsgYiAqIDcgKyBhICogMTEpICUgNjRdID0gcGl4ZWw7XHJcbiAgICAgIGNhbnZhcy5wdXNoKHBpeGVsKTtcclxuICAgIH0gZWxzZSBpZiAodGFnID09PSAweDAwKSB7XHJcbiAgICAgIC8vIFFPSV9PUF9JTkRFWFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgZGF0YVtwb3NpdGlvbl0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgMV0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgMl0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgM10gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgNF0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgNV0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgNl0gPT09IDB4MDAgJiZcclxuICAgICAgICBkYXRhW3Bvc2l0aW9uICsgN10gPT09IDB4MDFcclxuICAgICAgKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcG9zaXRpb24gKz0gMTtcclxuICAgICAgcGl4ZWwgPSBtYXBbYnl0ZV07XHJcbiAgICAgIGNhbnZhcy5wdXNoKHBpeGVsKTtcclxuICAgIH0gZWxzZSBpZiAodGFnID09PSAweDAxKSB7XHJcbiAgICAgIC8vIFFPSV9PUF9ESUZGXHJcbiAgICAgIGNvbnN0IGRyID0gKChieXRlID4+IDQpICYgMHgwMykgLSAyO1xyXG4gICAgICBjb25zdCBkZyA9ICgoYnl0ZSA+PiAyKSAmIDB4MDMpIC0gMjtcclxuICAgICAgY29uc3QgZGIgPSAoYnl0ZSAmIDB4MDMpIC0gMjtcclxuICAgICAgY29uc3QgciA9ICgoKHBpeGVsID4+IDI0KSAmIDB4ZmYpICsgZHIpICYgMHhmZjtcclxuICAgICAgY29uc3QgZyA9ICgoKHBpeGVsID4+IDE2KSAmIDB4ZmYpICsgZGcpICYgMHhmZjtcclxuICAgICAgY29uc3QgYiA9ICgoKHBpeGVsID4+IDgpICYgMHhmZikgKyBkYikgJiAweGZmO1xyXG4gICAgICBjb25zdCBhID0gcGl4ZWwgJiAweGZmO1xyXG4gICAgICBwb3NpdGlvbiArPSAxO1xyXG4gICAgICBwaXhlbCA9IChyIDw8IDI0KSB8IChnIDw8IDE2KSB8IChiIDw8IDgpIHwgYTtcclxuICAgICAgbWFwWyhyICogMyArIGcgKiA1ICsgYiAqIDcgKyBhICogMTEpICUgNjRdID0gcGl4ZWw7XHJcbiAgICAgIGNhbnZhcy5wdXNoKHBpeGVsKTtcclxuICAgIH0gZWxzZSBpZiAodGFnID09PSAweDAyKSB7XHJcbiAgICAgIC8vIFFPSV9PUF9ESUZGXHJcbiAgICAgIGNvbnN0IGJ5dGVfMiA9IGRhdGFbcG9zaXRpb24gKyAxXTtcclxuICAgICAgY29uc3QgZGcgPSAoKGJ5dGUgJiAweDNmKSAtIDMyKSAmIDB4ZmY7XHJcbiAgICAgIGNvbnN0IGRyID0gKCgoYnl0ZV8yID4+IDQpICYgMHgwZikgLSA4ICsgZGcpICYgMHhmZjtcclxuICAgICAgY29uc3QgZGIgPSAoKGJ5dGVfMiAmIDB4MGYpIC0gOCArIGRnKSAmIDB4ZmY7XHJcbiAgICAgIGNvbnN0IHIgPSAoKChwaXhlbCA+PiAyNCkgJiAweGZmKSArIGRyKSAmIDB4ZmY7XHJcbiAgICAgIGNvbnN0IGcgPSAoKChwaXhlbCA+PiAxNikgJiAweGZmKSArIGRnKSAmIDB4ZmY7XHJcbiAgICAgIGNvbnN0IGIgPSAoKChwaXhlbCA+PiA4KSAmIDB4ZmYpICsgZGIpICYgMHhmZjtcclxuICAgICAgY29uc3QgYSA9IHBpeGVsICYgMHhmZjtcclxuICAgICAgcG9zaXRpb24gKz0gMjtcclxuICAgICAgcGl4ZWwgPSAociA8PCAyNCkgfCAoZyA8PCAxNikgfCAoYiA8PCA4KSB8IGE7XHJcbiAgICAgIG1hcFsociAqIDMgKyBnICogNSArIGIgKiA3ICsgYSAqIDExKSAlIDY0XSA9IHBpeGVsO1xyXG4gICAgICBjYW52YXMucHVzaChwaXhlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBRT0lfT1BfUlVOXHJcbiAgICAgIGZvciAobGV0IGNvdW50ID0gKGJ5dGUgJiAweDNmKSArIDE7IGNvdW50ID4gMDsgLS1jb3VudCkge1xyXG4gICAgICAgIGNhbnZhcy5wdXNoKHBpeGVsKTtcclxuICAgICAgfVxyXG4gICAgICBwb3NpdGlvbiArPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZW5jb2RlX3BuZyhjYW52YXMsIHdpZHRoLCBjaGFubmVscyk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBkZWNvZGVRb2kgPSAoaW1nRGF0YSkgPT5cclxuICBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheSh0cmFuc2NvZGVfcW9pX3RvX3BuZyhuZXcgVWludDhBcnJheShpbWdEYXRhKSkpKTtcclxuIl0sIm5hbWVzIjpbImFkbGVyMzIiLCJkYXRhIiwiczEiLCJzMiIsImRhdHVtIiwiY3JjMzIiLCJ0YWJsZSIsImNyYyIsImluZGV4IiwiZW5jb2RlX3BuZyIsImNhbnZhcyIsIndpZHRoIiwiY2hhbm5lbHMiLCJpZGF0IiwiemxpYiIsImxlbiIsIm5sZW4iLCJsaW5lX2JlZ2luIiwibGVuZ3RoIiwibGluZV9lbmQiLCJwdXNoIiwicG9zaXRpb24iLCJwaXhlbCIsImhlaWdodCIsImNvbmNhdCIsImVuY29kZV9wbmdfY2h1bmsiLCJ0YWciLCJjb250ZW50IiwiY2hhckNvZGVBdCIsInRyYW5zY29kZV9xb2lfdG9fcG5nIiwiY29sb3JzcGFjZSIsIm1hcCIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJieXRlIiwiciIsImciLCJiIiwiYSIsImRyIiwiZGciLCJkYiIsImJ5dGVfMiIsImNvdW50IiwiZGVjb2RlUW9pIiwiaW1nRGF0YSIsIkJ1ZmZlciIsIlVpbnQ4QXJyYXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Photos/qoi.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./utils/imageDecoder.ts":
/*!*******************************!*\
  !*** ./utils/imageDecoder.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cursorToCss: () => (/* binding */ cursorToCss),\n/* harmony export */   decodeImageToBuffer: () => (/* binding */ decodeImageToBuffer),\n/* harmony export */   getFirstAniImage: () => (/* binding */ getFirstAniImage)\n/* harmony export */ });\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var components_apps_Photos_qoi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! components/apps/Photos/qoi */ \"(pages-dir-browser)/./components/apps/Photos/qoi.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\nconst JIFFIES_IN_SECOND = 60;\nconst DEFAULT_JIFFY_RATE = 10;\nconst supportsImageType = async (type)=>{\n    const img = document.createElement(\"img\");\n    document.createElement(\"picture\").append(Object.assign(document.createElement(\"source\"), {\n        srcset: \"data:,x\",\n        type\n    }), img);\n    await new Promise((resolve)=>{\n        requestAnimationFrame(resolve);\n    });\n    return typeof img.currentSrc === \"string\" && img.currentSrc.length > 0;\n};\nconst decodeJxl = async (image)=>await supportsImageType(\"image/jxl\") ? image : new Promise((resolve)=>{\n        const worker = new Worker(\"System/JXL.js/jxl_dec.js\", {\n            name: \"JXL.js\"\n        });\n        worker.postMessage({\n            image,\n            jxlSrc: \"image.jxl\"\n        });\n        worker.addEventListener(\"message\", (message)=>{\n            resolve((0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.imgDataToBuffer)(message?.data?.imgData));\n            worker.terminate();\n        });\n    });\nconst decodeHeic = async (image)=>{\n    if (await supportsImageType(\"image/heic\")) return image;\n    return new Promise((resolve)=>{\n        const worker = new Worker(__webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"libheif\"), __webpack_require__.b)), {\n            name: \"libheif\"\n        });\n        worker.postMessage(image);\n        worker.addEventListener(\"message\", ({ data: imageData })=>{\n            resolve((0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.imgDataToBuffer)(imageData));\n            worker.terminate();\n        });\n    });\n};\nconst aniToGif = async (aniBuffer)=>{\n    const gif = await (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.getGifJs)();\n    const { parseAni } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_ani-cursor_dist_parser_js\", \"high\").then(__webpack_require__.bind(__webpack_require__, /*! ani-cursor/dist/parser */ \"(pages-dir-browser)/./node_modules/ani-cursor/dist/parser.js\"));\n    let images = [];\n    let metadata = {};\n    try {\n        ({ images, metadata } = parseAni(aniBuffer));\n    } catch  {\n        return aniBuffer;\n    }\n    await Promise.all(images.map((image)=>new Promise((resolve)=>{\n            const imageIcon = new Image();\n            const bufferUrl = (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.bufferToUrl)(Buffer.from(image));\n            gif.setOptions({\n                transparent: \"\"\n            });\n            imageIcon.addEventListener(\"load\", ()=>{\n                gif.addFrame(imageIcon, {\n                    delay: (metadata.iDispRate || DEFAULT_JIFFY_RATE) / JIFFIES_IN_SECOND * 1000\n                });\n                (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.cleanUpBufferUrl)(bufferUrl);\n                resolve();\n            }, utils_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_TIME_PASSIVE_EVENT);\n            imageIcon.src = bufferUrl;\n        })));\n    return new Promise((resolve)=>{\n        gif.on(\"finished\", (blob)=>{\n            (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.blobToBuffer)(blob).then(resolve);\n            gif.freeWorkers.forEach((worker)=>worker?.terminate());\n        }).render();\n    });\n};\nconst getFirstAniImage = async (imageBuffer)=>{\n    const { parseAni } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_ani-cursor_dist_parser_js\", \"high\").then(__webpack_require__.bind(__webpack_require__, /*! ani-cursor/dist/parser */ \"(pages-dir-browser)/./node_modules/ani-cursor/dist/parser.js\"));\n    let firstImage;\n    try {\n        ({ images: [firstImage] } = parseAni(imageBuffer));\n        return Buffer.from(firstImage);\n    } catch  {\n    // Can't parse ani\n    }\n    return undefined;\n};\nconst getGlobalCursorCSS = (cursorUrl)=>`*, *::before, *::after { cursor: url(${cursorUrl}), default !important; }`;\nconst aniToCss = async (imageBuffer, mimeType)=>{\n    const { parseAni } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_ani-cursor_dist_parser_js\", \"high\").then(__webpack_require__.bind(__webpack_require__, /*! ani-cursor/dist/parser */ \"(pages-dir-browser)/./node_modules/ani-cursor/dist/parser.js\"));\n    const { metadata, images } = parseAni(imageBuffer);\n    const toUrl = (image)=>(0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.bufferToUrl)(Buffer.from(image), mimeType);\n    if (images.length === 1) return getGlobalCursorCSS(toUrl(images[0]));\n    if (images.length > 1) {\n        const animationName = `cursor-ani-${Date.now()}`;\n        const keyframes = `\n      @keyframes ${animationName} {\n        ${images.map((image, i)=>`${(i / images.length * 100).toFixed(1)}% { cursor: url(${toUrl(image)}), default; }`).join(\"\")}\n        100% { cursor: url(${toUrl(images[0])}), default; }\n      }\n    `;\n        const duration = Math.ceil((metadata.iDispRate || DEFAULT_JIFFY_RATE) / JIFFIES_IN_SECOND * images.length * 1000);\n        return `${keyframes}* { animation: ${animationName} ${duration}ms infinite steps(1) !important; }`;\n    }\n    return \"\";\n};\nconst getLargestIcon = async (imageBuffer, maxSize)=>{\n    try {\n        const { default: icoData } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_decode-ico_index_js\", \"high\").then(__webpack_require__.t.bind(__webpack_require__, /*! decode-ico */ \"(pages-dir-browser)/./node_modules/decode-ico/index.js\", 23));\n        const [icon] = icoData(imageBuffer).filter(({ width })=>width <= maxSize).sort((a, b)=>b.width - a.width);\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\", {\n            desynchronized: true\n        });\n        canvas.width = icon.width;\n        canvas.height = icon.height;\n        context?.putImageData(icon, 0, 0);\n        return canvas.toDataURL();\n    } catch  {\n        return \"\";\n    }\n};\nconst cursorToCss = async (buffer, path)=>{\n    if ((0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.getExtension)(path) === \".ani\") {\n        const animatedCursorCss = await aniToCss(buffer, (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.getMimeType)(path));\n        if (animatedCursorCss) return animatedCursorCss;\n    }\n    const largestIcon = await getLargestIcon(buffer, 128);\n    return getGlobalCursorCSS(largestIcon || (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.bufferToUrl)(buffer, (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.getMimeType)(path)));\n};\nconst canLoadNative = async (extension, file)=>new Promise((resolve)=>{\n        const image = new Image();\n        image.addEventListener(\"load\", ()=>resolve(true), utils_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_TIME_PASSIVE_EVENT);\n        image.addEventListener(\"error\", ()=>resolve(false), utils_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_TIME_PASSIVE_EVENT);\n        image.src = (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.bufferToUrl)(file, (0,utils_functions__WEBPACK_IMPORTED_MODULE_2__.getMimeType)(\"\", extension));\n    });\nconst decodeImageToBuffer = async (extension, file)=>{\n    switch(extension){\n        case \".jxl\":\n            return decodeJxl(file);\n        case \".qoi\":\n            return (0,components_apps_Photos_qoi__WEBPACK_IMPORTED_MODULE_1__.decodeQoi)(file);\n        case \".ani\":\n            try {\n                return await aniToGif(file);\n            } catch  {\n                return getFirstAniImage(file);\n            }\n        case \".cur\":\n            return await canLoadNative(extension, file) ? file : getFirstAniImage(file);\n        default:\n            if (utils_constants__WEBPACK_IMPORTED_MODULE_0__.HEIF_IMAGE_FORMATS.has(extension)) return decodeHeic(file);\n            if (utils_constants__WEBPACK_IMPORTED_MODULE_0__.TIFF_IMAGE_FORMATS.has(extension)) {\n                return Buffer.from((await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_utif_UTIF_js\", \"high\").then(__webpack_require__.t.bind(__webpack_require__, /*! utif */ \"(pages-dir-browser)/./node_modules/utif/UTIF.js\", 23))).bufferToURI(file).replace(\"data:image/png;base64,\", \"\"), \"base64\");\n            }\n    }\n    return file;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2ltYWdlRGVjb2Rlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBSXlCO0FBQzhCO0FBUzlCO0FBSXpCLE1BQU1XLG9CQUFvQjtBQUMxQixNQUFNQyxxQkFBcUI7QUFFM0IsTUFBTUMsb0JBQW9CLE9BQU9DO0lBQy9CLE1BQU1DLE1BQU1DLFNBQVNDLGFBQWEsQ0FBQztJQUVuQ0QsU0FBU0MsYUFBYSxDQUFDLFdBQVdDLE1BQU0sQ0FDdENDLE9BQU9DLE1BQU0sQ0FBQ0osU0FBU0MsYUFBYSxDQUFDLFdBQVc7UUFDOUNJLFFBQVE7UUFDUlA7SUFDRixJQUNBQztJQUdGLE1BQU0sSUFBSU8sUUFBUSxDQUFDQztRQUNqQkMsc0JBQXNCRDtJQUN4QjtJQUVBLE9BQU8sT0FBT1IsSUFBSVUsVUFBVSxLQUFLLFlBQVlWLElBQUlVLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHO0FBQ3ZFO0FBRUEsTUFBTUMsWUFBWSxPQUFPQyxRQUN2QixNQUFPZixrQkFBa0IsZUFDckJlLFFBQ0EsSUFBSU4sUUFBUSxDQUFDQztRQUNYLE1BQU1NLFNBQVMsSUFBSUMsT0FBTyw0QkFBNEI7WUFDcERDLE1BQU07UUFDUjtRQUVBRixPQUFPRyxXQUFXLENBQUM7WUFBRUo7WUFBT0ssUUFBUTtRQUFZO1FBQ2hESixPQUFPSyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUNDO1lBQ2xDWixRQUFRYixnRUFBZUEsQ0FBQ3lCLFNBQVNDLE1BQU1DO1lBQ3ZDUixPQUFPUyxTQUFTO1FBQ2xCO0lBQ0Y7QUFFTixNQUFNQyxhQUFhLE9BQU9YO0lBQ3hCLElBQUksTUFBTWYsa0JBQWtCLGVBQWUsT0FBT2U7SUFFbEQsT0FBTyxJQUFJTixRQUFRLENBQUNDO1FBQ2xCLE1BQU1NLFNBQVMsSUFBSUMsT0FBTywyQkFBSVUsSUFBSSxtR0FBb0MsQ0FBQyxHQUFFO1lBQ3ZFVCxNQUFNO1FBQ1I7UUFFQUYsT0FBT0csV0FBVyxDQUFDSjtRQUNuQkMsT0FBT0ssZ0JBQWdCLENBQ3JCLFdBQ0EsQ0FBQyxFQUFFRSxNQUFNTSxTQUFTLEVBQXVCO1lBQ3ZDbkIsUUFBUWIsZ0VBQWVBLENBQUNnQztZQUN4QmIsT0FBT1MsU0FBUztRQUNsQjtJQUVKO0FBQ0Y7QUFFQSxNQUFNSyxXQUFXLE9BQU9DO0lBQ3RCLE1BQU1DLE1BQU0sTUFBTXJDLHlEQUFRQTtJQUMxQixNQUFNLEVBQUVzQyxRQUFRLEVBQUUsR0FBRyxNQUFNLDRQQUFnQztJQUMzRCxJQUFJQyxTQUF1QixFQUFFO0lBQzdCLElBQUlDLFdBQW1DLENBQUM7SUFFeEMsSUFBSTtRQUNELEdBQUVELE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdGLFNBQVNGLFVBQVM7SUFDNUMsRUFBRSxPQUFNO1FBQ04sT0FBT0E7SUFDVDtJQUVBLE1BQU10QixRQUFRMkIsR0FBRyxDQUNmRixPQUFPRyxHQUFHLENBQ1IsQ0FBQ3RCLFFBQ0MsSUFBSU4sUUFBYyxDQUFDQztZQUNqQixNQUFNNEIsWUFBWSxJQUFJQztZQUN0QixNQUFNQyxZQUFZaEQsNERBQVdBLENBQUNpRCxNQUFNQSxDQUFDQyxJQUFJLENBQUMzQjtZQUMxQ2lCLElBQUlXLFVBQVUsQ0FBQztnQkFBRUMsYUFBYTtZQUFHO1lBQ2pDTixVQUFVakIsZ0JBQWdCLENBQ3hCLFFBQ0E7Z0JBQ0VXLElBQUlhLFFBQVEsQ0FBQ1AsV0FBVztvQkFDdEJRLE9BQ0UsQ0FBRVgsU0FBU1ksU0FBUyxJQUFJaEQsa0JBQWlCLElBQ3ZDRCxvQkFDRjtnQkFDSjtnQkFDQUwsaUVBQWdCQSxDQUFDK0M7Z0JBQ2pCOUI7WUFDRixHQUNBckIsbUVBQXNCQTtZQUV4QmlELFVBQVVVLEdBQUcsR0FBR1I7UUFDbEI7SUFJTixPQUFPLElBQUkvQixRQUFRLENBQUNDO1FBQ2xCc0IsSUFDR2lCLEVBQUUsQ0FBQyxZQUFZLENBQUNDO1lBQ2YzRCw2REFBWUEsQ0FBQzJELE1BQU1DLElBQUksQ0FBQ3pDO1lBQ3hCc0IsSUFBSW9CLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDLENBQUNyQyxTQUFXQSxRQUFRUztRQUM5QyxHQUNDNkIsTUFBTTtJQUNYO0FBQ0Y7QUFFTyxNQUFNQyxtQkFBbUIsT0FDOUJDO0lBRUEsTUFBTSxFQUFFdkIsUUFBUSxFQUFFLEdBQUcsTUFBTSw0UEFBZ0M7SUFDM0QsSUFBSXdCO0lBRUosSUFBSTtRQUNELEdBQ0N2QixRQUFRLENBQUN1QixXQUFXLEVBQ3JCLEdBQUd4QixTQUFTdUIsWUFBVztRQUV4QixPQUFPZixNQUFNQSxDQUFDQyxJQUFJLENBQUNlO0lBQ3JCLEVBQUUsT0FBTTtJQUNOLGtCQUFrQjtJQUNwQjtJQUVBLE9BQU9DO0FBQ1QsRUFBRTtBQUVGLE1BQU1DLHFCQUFxQixDQUFDQyxZQUMxQixDQUFDLHFDQUFxQyxFQUFFQSxVQUFVLHdCQUF3QixDQUFDO0FBRTdFLE1BQU1DLFdBQVcsT0FDZkwsYUFDQU07SUFFQSxNQUFNLEVBQUU3QixRQUFRLEVBQUUsR0FBRyxNQUFNLDRQQUFnQztJQUMzRCxNQUFNLEVBQUVFLFFBQVEsRUFBRUQsTUFBTSxFQUFFLEdBQUdELFNBQVN1QjtJQUN0QyxNQUFNTyxRQUFRLENBQUNoRCxRQUNidkIsNERBQVdBLENBQUNpRCxNQUFNQSxDQUFDQyxJQUFJLENBQUMzQixRQUFRK0M7SUFFbEMsSUFBSTVCLE9BQU9yQixNQUFNLEtBQUssR0FBRyxPQUFPOEMsbUJBQW1CSSxNQUFNN0IsTUFBTSxDQUFDLEVBQUU7SUFFbEUsSUFBSUEsT0FBT3JCLE1BQU0sR0FBRyxHQUFHO1FBQ3JCLE1BQU1tRCxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUVDLEtBQUtDLEdBQUcsSUFBSTtRQUNoRCxNQUFNQyxZQUFZLENBQUM7aUJBQ04sRUFBRUgsY0FBYztRQUN6QixFQUFFOUIsT0FDQ0csR0FBRyxDQUNGLENBQUN0QixPQUFPcUQsSUFDTixHQUFHLENBQUMsSUFBS2xDLE9BQU9yQixNQUFNLEdBQUksR0FBRSxFQUFHd0QsT0FBTyxDQUFDLEdBQUcsZ0JBQWdCLEVBQUVOLE1BQU1oRCxPQUFPLGFBQWEsQ0FBQyxFQUUxRnVELElBQUksQ0FBQyxJQUFJOzJCQUNPLEVBQUVQLE1BQU03QixNQUFNLENBQUMsRUFBRSxFQUFFOztJQUUxQyxDQUFDO1FBQ0QsTUFBTXFDLFdBQVdDLEtBQUtDLElBQUksQ0FDeEIsQ0FBRXRDLFNBQVNZLFNBQVMsSUFBSWhELGtCQUFpQixJQUFLRCxvQkFDNUNvQyxPQUFPckIsTUFBTSxHQUNiO1FBR0osT0FBTyxHQUFHc0QsVUFBVSxlQUFlLEVBQUVILGNBQWMsQ0FBQyxFQUFFTyxTQUFTLGtDQUFrQyxDQUFDO0lBQ3BHO0lBRUEsT0FBTztBQUNUO0FBRUEsTUFBTUcsaUJBQWlCLE9BQ3JCbEIsYUFDQW1CO0lBRUEsSUFBSTtRQUNGLE1BQU0sRUFBRUMsU0FBU0MsT0FBTyxFQUFFLEdBQUcsTUFBTSwwT0FBb0I7UUFDdkQsTUFBTSxDQUFDQyxLQUFLLEdBQUdELFFBQVFyQixhQUNwQnVCLE1BQU0sQ0FBQyxDQUFDLEVBQUVDLEtBQUssRUFBRSxHQUFLQSxTQUFTTCxTQUMvQk0sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVILEtBQUssR0FBR0UsRUFBRUYsS0FBSztRQUNuQyxNQUFNSSxTQUFTakYsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDLE1BQU1pRixVQUFVRCxPQUFPRSxVQUFVLENBQUMsTUFBTTtZQUN0Q0MsZ0JBQWdCO1FBQ2xCO1FBRUFILE9BQU9KLEtBQUssR0FBR0YsS0FBS0UsS0FBSztRQUN6QkksT0FBT0ksTUFBTSxHQUFHVixLQUFLVSxNQUFNO1FBQzNCSCxTQUFTSSxhQUFhWCxNQUE4QixHQUFHO1FBRXZELE9BQU9NLE9BQU9NLFNBQVM7SUFDekIsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFTyxNQUFNQyxjQUFjLE9BQ3pCQyxRQUNBQztJQUVBLElBQUluRyw2REFBWUEsQ0FBQ21HLFVBQVUsUUFBUTtRQUNqQyxNQUFNQyxvQkFBb0IsTUFBTWpDLFNBQVMrQixRQUFRaEcsNERBQVdBLENBQUNpRztRQUU3RCxJQUFJQyxtQkFBbUIsT0FBT0E7SUFDaEM7SUFFQSxNQUFNQyxjQUFjLE1BQU1yQixlQUFla0IsUUFBUTtJQUVqRCxPQUFPakMsbUJBQ0xvQyxlQUFldkcsNERBQVdBLENBQUNvRyxRQUFRaEcsNERBQVdBLENBQUNpRztBQUVuRCxFQUFFO0FBRUYsTUFBTUcsZ0JBQWdCLE9BQ3BCQyxXQUNBQyxPQUVBLElBQUl6RixRQUFRLENBQUNDO1FBQ1gsTUFBTUssUUFBUSxJQUFJd0I7UUFFbEJ4QixNQUFNTSxnQkFBZ0IsQ0FBQyxRQUFRLElBQU1YLFFBQVEsT0FBT3JCLG1FQUFzQkE7UUFDMUUwQixNQUFNTSxnQkFBZ0IsQ0FDcEIsU0FDQSxJQUFNWCxRQUFRLFFBQ2RyQixtRUFBc0JBO1FBR3hCMEIsTUFBTWlDLEdBQUcsR0FBR3hELDREQUFXQSxDQUFDMEcsTUFBTXRHLDREQUFXQSxDQUFDLElBQUlxRztJQUNoRDtBQUVLLE1BQU1FLHNCQUFzQixPQUNqQ0YsV0FDQUM7SUFFQSxPQUFRRDtRQUNOLEtBQUs7WUFDSCxPQUFPbkYsVUFBVW9GO1FBQ25CLEtBQUs7WUFDSCxPQUFPNUcscUVBQVNBLENBQUM0RztRQUNuQixLQUFLO1lBQ0gsSUFBSTtnQkFDRixPQUFPLE1BQU1wRSxTQUFTb0U7WUFDeEIsRUFBRSxPQUFNO2dCQUNOLE9BQU8zQyxpQkFBaUIyQztZQUMxQjtRQUNGLEtBQUs7WUFDSCxPQUFPLE1BQU9GLGNBQWNDLFdBQVdDLFFBQ25DQSxPQUNBM0MsaUJBQWlCMkM7UUFDdkI7WUFDRSxJQUFJOUcsK0RBQWtCQSxDQUFDZ0gsR0FBRyxDQUFDSCxZQUFZLE9BQU92RSxXQUFXd0U7WUFDekQsSUFBSS9HLCtEQUFrQkEsQ0FBQ2lILEdBQUcsQ0FBQ0gsWUFBWTtnQkFDckMsT0FBT3hELE1BQU1BLENBQUNDLElBQUksQ0FDaEIsQ0FBQyxNQUFNLHNOQUFhLEVBQ2pCMkQsV0FBVyxDQUFDSCxNQUNaSSxPQUFPLENBQUMsMEJBQTBCLEtBQ3JDO1lBRUo7SUFDSjtJQUVBLE9BQU9KO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFx1dGlsc1xcaW1hZ2VEZWNvZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgVElGRl9JTUFHRV9GT1JNQVRTLFxyXG4gIEhFSUZfSU1BR0VfRk9STUFUUyxcclxuICBPTkVfVElNRV9QQVNTSVZFX0VWRU5ULFxyXG59IGZyb20gXCJ1dGlscy9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgZGVjb2RlUW9pIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9QaG90b3MvcW9pXCI7XHJcbmltcG9ydCB7XHJcbiAgYmxvYlRvQnVmZmVyLFxyXG4gIGJ1ZmZlclRvVXJsLFxyXG4gIGNsZWFuVXBCdWZmZXJVcmwsXHJcbiAgZ2V0RXh0ZW5zaW9uLFxyXG4gIGdldEdpZkpzLFxyXG4gIGdldE1pbWVUeXBlLFxyXG4gIGltZ0RhdGFUb0J1ZmZlcixcclxufSBmcm9tIFwidXRpbHMvZnVuY3Rpb25zXCI7XHJcblxyXG50eXBlIEp4bERlY29kZVJlc3BvbnNlID0geyBkYXRhOiB7IGltZ0RhdGE6IEltYWdlRGF0YSB9IH07XHJcblxyXG5jb25zdCBKSUZGSUVTX0lOX1NFQ09ORCA9IDYwO1xyXG5jb25zdCBERUZBVUxUX0pJRkZZX1JBVEUgPSAxMDtcclxuXHJcbmNvbnN0IHN1cHBvcnRzSW1hZ2VUeXBlID0gYXN5bmMgKHR5cGU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcblxyXG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwaWN0dXJlXCIpLmFwcGVuZChcclxuICAgIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKSwge1xyXG4gICAgICBzcmNzZXQ6IFwiZGF0YToseFwiLFxyXG4gICAgICB0eXBlLFxyXG4gICAgfSksXHJcbiAgICBpbWdcclxuICApO1xyXG5cclxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdHlwZW9mIGltZy5jdXJyZW50U3JjID09PSBcInN0cmluZ1wiICYmIGltZy5jdXJyZW50U3JjLmxlbmd0aCA+IDA7XHJcbn07XHJcblxyXG5jb25zdCBkZWNvZGVKeGwgPSBhc3luYyAoaW1hZ2U6IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiA9PlxyXG4gIChhd2FpdCBzdXBwb3J0c0ltYWdlVHlwZShcImltYWdlL2p4bFwiKSlcclxuICAgID8gaW1hZ2VcclxuICAgIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKFwiU3lzdGVtL0pYTC5qcy9qeGxfZGVjLmpzXCIsIHtcclxuICAgICAgICAgIG5hbWU6IFwiSlhMLmpzXCIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGltYWdlLCBqeGxTcmM6IFwiaW1hZ2UuanhsXCIgfSk7XHJcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChtZXNzYWdlOiBKeGxEZWNvZGVSZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZShpbWdEYXRhVG9CdWZmZXIobWVzc2FnZT8uZGF0YT8uaW1nRGF0YSkpO1xyXG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbmNvbnN0IGRlY29kZUhlaWMgPSBhc3luYyAoaW1hZ2U6IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiA9PiB7XHJcbiAgaWYgKGF3YWl0IHN1cHBvcnRzSW1hZ2VUeXBlKFwiaW1hZ2UvaGVpY1wiKSkgcmV0dXJuIGltYWdlO1xyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTChcInV0aWxzL2hlaWMud29ya2VyXCIsIGltcG9ydC5tZXRhLnVybCksIHtcclxuICAgICAgbmFtZTogXCJsaWJoZWlmXCIsXHJcbiAgICB9KTtcclxuXHJcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoaW1hZ2UpO1xyXG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFwibWVzc2FnZVwiLFxyXG4gICAgICAoeyBkYXRhOiBpbWFnZURhdGEgfTogeyBkYXRhOiBJbWFnZURhdGEgfSkgPT4ge1xyXG4gICAgICAgIHJlc29sdmUoaW1nRGF0YVRvQnVmZmVyKGltYWdlRGF0YSkpO1xyXG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9KTtcclxufTtcclxuXHJcbmNvbnN0IGFuaVRvR2lmID0gYXN5bmMgKGFuaUJ1ZmZlcjogQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+ID0+IHtcclxuICBjb25zdCBnaWYgPSBhd2FpdCBnZXRHaWZKcygpO1xyXG4gIGNvbnN0IHsgcGFyc2VBbmkgfSA9IGF3YWl0IGltcG9ydChcImFuaS1jdXJzb3IvZGlzdC9wYXJzZXJcIik7XHJcbiAgbGV0IGltYWdlczogVWludDhBcnJheVtdID0gW107XHJcbiAgbGV0IG1ldGFkYXRhOiB7IGlEaXNwUmF0ZT86IG51bWJlciB9ID0ge307XHJcblxyXG4gIHRyeSB7XHJcbiAgICAoeyBpbWFnZXMsIG1ldGFkYXRhIH0gPSBwYXJzZUFuaShhbmlCdWZmZXIpKTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBhbmlCdWZmZXI7XHJcbiAgfVxyXG5cclxuICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgIGltYWdlcy5tYXAoXHJcbiAgICAgIChpbWFnZSkgPT5cclxuICAgICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgaW1hZ2VJY29uID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICBjb25zdCBidWZmZXJVcmwgPSBidWZmZXJUb1VybChCdWZmZXIuZnJvbShpbWFnZSkpO1xyXG4gICAgICAgICAgZ2lmLnNldE9wdGlvbnMoeyB0cmFuc3BhcmVudDogXCJcIiB9KTtcclxuICAgICAgICAgIGltYWdlSWNvbi5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICBcImxvYWRcIixcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGdpZi5hZGRGcmFtZShpbWFnZUljb24sIHtcclxuICAgICAgICAgICAgICAgIGRlbGF5OlxyXG4gICAgICAgICAgICAgICAgICAoKG1ldGFkYXRhLmlEaXNwUmF0ZSB8fCBERUZBVUxUX0pJRkZZX1JBVEUpIC9cclxuICAgICAgICAgICAgICAgICAgICBKSUZGSUVTX0lOX1NFQ09ORCkgKlxyXG4gICAgICAgICAgICAgICAgICAxMDAwLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGNsZWFuVXBCdWZmZXJVcmwoYnVmZmVyVXJsKTtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE9ORV9USU1FX1BBU1NJVkVfRVZFTlRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpbWFnZUljb24uc3JjID0gYnVmZmVyVXJsO1xyXG4gICAgICAgIH0pXHJcbiAgICApXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICBnaWZcclxuICAgICAgLm9uKFwiZmluaXNoZWRcIiwgKGJsb2IpID0+IHtcclxuICAgICAgICBibG9iVG9CdWZmZXIoYmxvYikudGhlbihyZXNvbHZlKTtcclxuICAgICAgICBnaWYuZnJlZVdvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB3b3JrZXI/LnRlcm1pbmF0ZSgpKTtcclxuICAgICAgfSlcclxuICAgICAgLnJlbmRlcigpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZpcnN0QW5pSW1hZ2UgPSBhc3luYyAoXHJcbiAgaW1hZ2VCdWZmZXI6IEJ1ZmZlclxyXG4pOiBQcm9taXNlPEJ1ZmZlciB8IHVuZGVmaW5lZD4gPT4ge1xyXG4gIGNvbnN0IHsgcGFyc2VBbmkgfSA9IGF3YWl0IGltcG9ydChcImFuaS1jdXJzb3IvZGlzdC9wYXJzZXJcIik7XHJcbiAgbGV0IGZpcnN0SW1hZ2U6IFVpbnQ4QXJyYXk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAoe1xyXG4gICAgICBpbWFnZXM6IFtmaXJzdEltYWdlXSxcclxuICAgIH0gPSBwYXJzZUFuaShpbWFnZUJ1ZmZlcikpO1xyXG5cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShmaXJzdEltYWdlKTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIENhbid0IHBhcnNlIGFuaVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmNvbnN0IGdldEdsb2JhbEN1cnNvckNTUyA9IChjdXJzb3JVcmw6IHN0cmluZyk6IHN0cmluZyA9PlxyXG4gIGAqLCAqOjpiZWZvcmUsICo6OmFmdGVyIHsgY3Vyc29yOiB1cmwoJHtjdXJzb3JVcmx9KSwgZGVmYXVsdCAhaW1wb3J0YW50OyB9YDtcclxuXHJcbmNvbnN0IGFuaVRvQ3NzID0gYXN5bmMgKFxyXG4gIGltYWdlQnVmZmVyOiBCdWZmZXIsXHJcbiAgbWltZVR5cGU6IHN0cmluZ1xyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHsgcGFyc2VBbmkgfSA9IGF3YWl0IGltcG9ydChcImFuaS1jdXJzb3IvZGlzdC9wYXJzZXJcIik7XHJcbiAgY29uc3QgeyBtZXRhZGF0YSwgaW1hZ2VzIH0gPSBwYXJzZUFuaShpbWFnZUJ1ZmZlcik7XHJcbiAgY29uc3QgdG9VcmwgPSAoaW1hZ2U6IFVpbnQ4QXJyYXkpOiBzdHJpbmcgPT5cclxuICAgIGJ1ZmZlclRvVXJsKEJ1ZmZlci5mcm9tKGltYWdlKSwgbWltZVR5cGUpO1xyXG5cclxuICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGdldEdsb2JhbEN1cnNvckNTUyh0b1VybChpbWFnZXNbMF0pKTtcclxuXHJcbiAgaWYgKGltYWdlcy5sZW5ndGggPiAxKSB7XHJcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYGN1cnNvci1hbmktJHtEYXRlLm5vdygpfWA7XHJcbiAgICBjb25zdCBrZXlmcmFtZXMgPSBgXHJcbiAgICAgIEBrZXlmcmFtZXMgJHthbmltYXRpb25OYW1lfSB7XHJcbiAgICAgICAgJHtpbWFnZXNcclxuICAgICAgICAgIC5tYXAoXHJcbiAgICAgICAgICAgIChpbWFnZSwgaSkgPT5cclxuICAgICAgICAgICAgICBgJHsoKGkgLyBpbWFnZXMubGVuZ3RoKSAqIDEwMCkudG9GaXhlZCgxKX0lIHsgY3Vyc29yOiB1cmwoJHt0b1VybChpbWFnZSl9KSwgZGVmYXVsdDsgfWBcclxuICAgICAgICAgIClcclxuICAgICAgICAgIC5qb2luKFwiXCIpfVxyXG4gICAgICAgIDEwMCUgeyBjdXJzb3I6IHVybCgke3RvVXJsKGltYWdlc1swXSl9KSwgZGVmYXVsdDsgfVxyXG4gICAgICB9XHJcbiAgICBgO1xyXG4gICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLmNlaWwoXHJcbiAgICAgICgobWV0YWRhdGEuaURpc3BSYXRlIHx8IERFRkFVTFRfSklGRllfUkFURSkgLyBKSUZGSUVTX0lOX1NFQ09ORCkgKlxyXG4gICAgICAgIGltYWdlcy5sZW5ndGggKlxyXG4gICAgICAgIDEwMDBcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGAke2tleWZyYW1lc30qIHsgYW5pbWF0aW9uOiAke2FuaW1hdGlvbk5hbWV9ICR7ZHVyYXRpb259bXMgaW5maW5pdGUgc3RlcHMoMSkgIWltcG9ydGFudDsgfWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gXCJcIjtcclxufTtcclxuXHJcbmNvbnN0IGdldExhcmdlc3RJY29uID0gYXN5bmMgKFxyXG4gIGltYWdlQnVmZmVyOiBCdWZmZXIsXHJcbiAgbWF4U2l6ZTogbnVtYmVyXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGVmYXVsdDogaWNvRGF0YSB9ID0gYXdhaXQgaW1wb3J0KFwiZGVjb2RlLWljb1wiKTtcclxuICAgIGNvbnN0IFtpY29uXSA9IGljb0RhdGEoaW1hZ2VCdWZmZXIpXHJcbiAgICAgIC5maWx0ZXIoKHsgd2lkdGggfSkgPT4gd2lkdGggPD0gbWF4U2l6ZSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIud2lkdGggLSBhLndpZHRoKTtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XHJcbiAgICAgIGRlc3luY2hyb25pemVkOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gaWNvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBpY29uLmhlaWdodDtcclxuICAgIGNvbnRleHQ/LnB1dEltYWdlRGF0YShpY29uIGFzIHVua25vd24gYXMgSW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGN1cnNvclRvQ3NzID0gYXN5bmMgKFxyXG4gIGJ1ZmZlcjogQnVmZmVyLFxyXG4gIHBhdGg6IHN0cmluZ1xyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGlmIChnZXRFeHRlbnNpb24ocGF0aCkgPT09IFwiLmFuaVwiKSB7XHJcbiAgICBjb25zdCBhbmltYXRlZEN1cnNvckNzcyA9IGF3YWl0IGFuaVRvQ3NzKGJ1ZmZlciwgZ2V0TWltZVR5cGUocGF0aCkpO1xyXG5cclxuICAgIGlmIChhbmltYXRlZEN1cnNvckNzcykgcmV0dXJuIGFuaW1hdGVkQ3Vyc29yQ3NzO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbGFyZ2VzdEljb24gPSBhd2FpdCBnZXRMYXJnZXN0SWNvbihidWZmZXIsIDEyOCk7XHJcblxyXG4gIHJldHVybiBnZXRHbG9iYWxDdXJzb3JDU1MoXHJcbiAgICBsYXJnZXN0SWNvbiB8fCBidWZmZXJUb1VybChidWZmZXIsIGdldE1pbWVUeXBlKHBhdGgpKVxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBjYW5Mb2FkTmF0aXZlID0gYXN5bmMgKFxyXG4gIGV4dGVuc2lvbjogc3RyaW5nLFxyXG4gIGZpbGU6IEJ1ZmZlclxyXG4pOiBQcm9taXNlPGJvb2xlYW4+ID0+XHJcbiAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSwgT05FX1RJTUVfUEFTU0lWRV9FVkVOVCk7XHJcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICBcImVycm9yXCIsXHJcbiAgICAgICgpID0+IHJlc29sdmUoZmFsc2UpLFxyXG4gICAgICBPTkVfVElNRV9QQVNTSVZFX0VWRU5UXHJcbiAgICApO1xyXG5cclxuICAgIGltYWdlLnNyYyA9IGJ1ZmZlclRvVXJsKGZpbGUsIGdldE1pbWVUeXBlKFwiXCIsIGV4dGVuc2lvbikpO1xyXG4gIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlY29kZUltYWdlVG9CdWZmZXIgPSBhc3luYyAoXHJcbiAgZXh0ZW5zaW9uOiBzdHJpbmcsXHJcbiAgZmlsZTogQnVmZmVyXHJcbik6IFByb21pc2U8QnVmZmVyIHwgdW5kZWZpbmVkPiA9PiB7XHJcbiAgc3dpdGNoIChleHRlbnNpb24pIHtcclxuICAgIGNhc2UgXCIuanhsXCI6XHJcbiAgICAgIHJldHVybiBkZWNvZGVKeGwoZmlsZSk7XHJcbiAgICBjYXNlIFwiLnFvaVwiOlxyXG4gICAgICByZXR1cm4gZGVjb2RlUW9pKGZpbGUpO1xyXG4gICAgY2FzZSBcIi5hbmlcIjpcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgYW5pVG9HaWYoZmlsZSk7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIHJldHVybiBnZXRGaXJzdEFuaUltYWdlKGZpbGUpO1xyXG4gICAgICB9XHJcbiAgICBjYXNlIFwiLmN1clwiOlxyXG4gICAgICByZXR1cm4gKGF3YWl0IGNhbkxvYWROYXRpdmUoZXh0ZW5zaW9uLCBmaWxlKSlcclxuICAgICAgICA/IGZpbGVcclxuICAgICAgICA6IGdldEZpcnN0QW5pSW1hZ2UoZmlsZSk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAoSEVJRl9JTUFHRV9GT1JNQVRTLmhhcyhleHRlbnNpb24pKSByZXR1cm4gZGVjb2RlSGVpYyhmaWxlKTtcclxuICAgICAgaWYgKFRJRkZfSU1BR0VfRk9STUFUUy5oYXMoZXh0ZW5zaW9uKSkge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShcclxuICAgICAgICAgIChhd2FpdCBpbXBvcnQoXCJ1dGlmXCIpKVxyXG4gICAgICAgICAgICAuYnVmZmVyVG9VUkkoZmlsZSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIsIFwiXCIpLFxyXG4gICAgICAgICAgXCJiYXNlNjRcIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmaWxlO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiVElGRl9JTUFHRV9GT1JNQVRTIiwiSEVJRl9JTUFHRV9GT1JNQVRTIiwiT05FX1RJTUVfUEFTU0lWRV9FVkVOVCIsImRlY29kZVFvaSIsImJsb2JUb0J1ZmZlciIsImJ1ZmZlclRvVXJsIiwiY2xlYW5VcEJ1ZmZlclVybCIsImdldEV4dGVuc2lvbiIsImdldEdpZkpzIiwiZ2V0TWltZVR5cGUiLCJpbWdEYXRhVG9CdWZmZXIiLCJKSUZGSUVTX0lOX1NFQ09ORCIsIkRFRkFVTFRfSklGRllfUkFURSIsInN1cHBvcnRzSW1hZ2VUeXBlIiwidHlwZSIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsIk9iamVjdCIsImFzc2lnbiIsInNyY3NldCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY3VycmVudFNyYyIsImxlbmd0aCIsImRlY29kZUp4bCIsImltYWdlIiwid29ya2VyIiwiV29ya2VyIiwibmFtZSIsInBvc3RNZXNzYWdlIiwianhsU3JjIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1lc3NhZ2UiLCJkYXRhIiwiaW1nRGF0YSIsInRlcm1pbmF0ZSIsImRlY29kZUhlaWMiLCJVUkwiLCJ1cmwiLCJpbWFnZURhdGEiLCJhbmlUb0dpZiIsImFuaUJ1ZmZlciIsImdpZiIsInBhcnNlQW5pIiwiaW1hZ2VzIiwibWV0YWRhdGEiLCJhbGwiLCJtYXAiLCJpbWFnZUljb24iLCJJbWFnZSIsImJ1ZmZlclVybCIsIkJ1ZmZlciIsImZyb20iLCJzZXRPcHRpb25zIiwidHJhbnNwYXJlbnQiLCJhZGRGcmFtZSIsImRlbGF5IiwiaURpc3BSYXRlIiwic3JjIiwib24iLCJibG9iIiwidGhlbiIsImZyZWVXb3JrZXJzIiwiZm9yRWFjaCIsInJlbmRlciIsImdldEZpcnN0QW5pSW1hZ2UiLCJpbWFnZUJ1ZmZlciIsImZpcnN0SW1hZ2UiLCJ1bmRlZmluZWQiLCJnZXRHbG9iYWxDdXJzb3JDU1MiLCJjdXJzb3JVcmwiLCJhbmlUb0NzcyIsIm1pbWVUeXBlIiwidG9VcmwiLCJhbmltYXRpb25OYW1lIiwiRGF0ZSIsIm5vdyIsImtleWZyYW1lcyIsImkiLCJ0b0ZpeGVkIiwiam9pbiIsImR1cmF0aW9uIiwiTWF0aCIsImNlaWwiLCJnZXRMYXJnZXN0SWNvbiIsIm1heFNpemUiLCJkZWZhdWx0IiwiaWNvRGF0YSIsImljb24iLCJmaWx0ZXIiLCJ3aWR0aCIsInNvcnQiLCJhIiwiYiIsImNhbnZhcyIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwiZGVzeW5jaHJvbml6ZWQiLCJoZWlnaHQiLCJwdXRJbWFnZURhdGEiLCJ0b0RhdGFVUkwiLCJjdXJzb3JUb0NzcyIsImJ1ZmZlciIsInBhdGgiLCJhbmltYXRlZEN1cnNvckNzcyIsImxhcmdlc3RJY29uIiwiY2FuTG9hZE5hdGl2ZSIsImV4dGVuc2lvbiIsImZpbGUiLCJkZWNvZGVJbWFnZVRvQnVmZmVyIiwiaGFzIiwiYnVmZmVyVG9VUkkiLCJyZXBsYWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/imageDecoder.ts\n"));

/***/ })

}]);