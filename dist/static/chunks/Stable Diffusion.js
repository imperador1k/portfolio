/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "(pages-dir-browser)/./components/apps/StableDiffusion/sd.worker.ts":
/*!******************************************************!*\
  !*** ./components/apps/StableDiffusion/sd.worker.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var components_system_Desktop_Wallpapers_StableDiffusion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! components/system/Desktop/Wallpapers/StableDiffusion */ \"(pages-dir-browser)/./components/system/Desktop/Wallpapers/StableDiffusion/index.ts\");\n\nglobalThis.addEventListener(\"message\", ({ data })=>{\n    if (data === \"init\") {\n        globalThis.tvmjsGlobalEnv = globalThis.tvmjsGlobalEnv || {};\n        globalThis.tvmjsGlobalEnv.logger = (type, message)=>{\n            if (type || message) console.info(`${type}: ${message}`);\n            globalThis.postMessage({\n                message,\n                type\n            });\n        };\n        globalThis.importScripts(...components_system_Desktop_Wallpapers_StableDiffusion__WEBPACK_IMPORTED_MODULE_0__.libs);\n    } else if (!(data instanceof DOMRect)) {\n        const { canvas, config } = data;\n        (0,components_system_Desktop_Wallpapers_StableDiffusion__WEBPACK_IMPORTED_MODULE_0__.runStableDiffusion)(config, canvas, true).then(()=>globalThis.tvmjsGlobalEnv.logger(\"\", \"\"));\n    }\n}, {\n    passive: true\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9TdGFibGVEaWZmdXNpb24vc2Qud29ya2VyLnRzIiwibWFwcGluZ3MiOiI7O0FBSThEO0FBRzlERSxXQUFXQyxnQkFBZ0IsQ0FDekIsV0FDQSxDQUFDLEVBQUVDLElBQUksRUFBcUQ7SUFDMUQsSUFBSUEsU0FBUyxRQUFRO1FBQ25CRixXQUFXRyxjQUFjLEdBQUdILFdBQVdHLGNBQWMsSUFBSSxDQUFDO1FBQzFESCxXQUFXRyxjQUFjLENBQUNDLE1BQU0sR0FBRyxDQUFDQyxNQUFjQztZQUNoRCxJQUFJRCxRQUFRQyxTQUFTQyxRQUFRQyxJQUFJLENBQUMsR0FBR0gsS0FBSyxFQUFFLEVBQUVDLFNBQVM7WUFDdkROLFdBQVdTLFdBQVcsQ0FBQztnQkFBRUg7Z0JBQVNEO1lBQUs7UUFDekM7UUFFQUwsV0FBV1UsYUFBYSxJQUFJWixzRkFBSUE7SUFDbEMsT0FBTyxJQUFJLENBQUVJLENBQUFBLGdCQUFnQlMsT0FBTSxHQUFJO1FBQ3JDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR1g7UUFFM0JILHdHQUFrQkEsQ0FBQ2MsUUFBaUNELFFBQVEsTUFBTUUsSUFBSSxDQUNwRSxJQUFNZCxXQUFXRyxjQUFjLENBQUNDLE1BQU0sQ0FBQyxJQUFJO0lBRS9DO0FBQ0YsR0FDQTtJQUFFVyxTQUFTO0FBQUsiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcU3RhYmxlRGlmZnVzaW9uXFxzZC53b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBTdGFibGVEaWZmdXNpb25Db25maWcgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL1N0YWJsZURpZmZ1c2lvbi90eXBlc1wiO1xyXG5pbXBvcnQge1xyXG4gIGxpYnMsXHJcbiAgcnVuU3RhYmxlRGlmZnVzaW9uLFxyXG59IGZyb20gXCJjb21wb25lbnRzL3N5c3RlbS9EZXNrdG9wL1dhbGxwYXBlcnMvU3RhYmxlRGlmZnVzaW9uXCI7XHJcbmltcG9ydCB7IHR5cGUgT2Zmc2NyZWVuUmVuZGVyUHJvcHMgfSBmcm9tIFwiY29tcG9uZW50cy9zeXN0ZW0vRGVza3RvcC9XYWxscGFwZXJzL3R5cGVzXCI7XHJcblxyXG5nbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgXCJtZXNzYWdlXCIsXHJcbiAgKHsgZGF0YSB9OiB7IGRhdGE6IERPTVJlY3QgfCBPZmZzY3JlZW5SZW5kZXJQcm9wcyB8IHN0cmluZyB9KSA9PiB7XHJcbiAgICBpZiAoZGF0YSA9PT0gXCJpbml0XCIpIHtcclxuICAgICAgZ2xvYmFsVGhpcy50dm1qc0dsb2JhbEVudiA9IGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYgfHwge307XHJcbiAgICAgIGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYubG9nZ2VyID0gKHR5cGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGUgfHwgbWVzc2FnZSkgY29uc29sZS5pbmZvKGAke3R5cGV9OiAke21lc3NhZ2V9YCk7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7IG1lc3NhZ2UsIHR5cGUgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBnbG9iYWxUaGlzLmltcG9ydFNjcmlwdHMoLi4ubGlicyk7XHJcbiAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIERPTVJlY3QpKSB7XHJcbiAgICAgIGNvbnN0IHsgY2FudmFzLCBjb25maWcgfSA9IGRhdGEgYXMgT2Zmc2NyZWVuUmVuZGVyUHJvcHM7XHJcblxyXG4gICAgICBydW5TdGFibGVEaWZmdXNpb24oY29uZmlnIGFzIFN0YWJsZURpZmZ1c2lvbkNvbmZpZywgY2FudmFzLCB0cnVlKS50aGVuKFxyXG4gICAgICAgICgpID0+IGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYubG9nZ2VyKFwiXCIsIFwiXCIpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuICB7IHBhc3NpdmU6IHRydWUgfVxyXG4pO1xyXG4iXSwibmFtZXMiOlsibGlicyIsInJ1blN0YWJsZURpZmZ1c2lvbiIsImdsb2JhbFRoaXMiLCJhZGRFdmVudExpc3RlbmVyIiwiZGF0YSIsInR2bWpzR2xvYmFsRW52IiwibG9nZ2VyIiwidHlwZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiaW5mbyIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsIkRPTVJlY3QiLCJjYW52YXMiLCJjb25maWciLCJ0aGVuIiwicGFzc2l2ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/StableDiffusion/sd.worker.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/system/Desktop/Wallpapers/StableDiffusion/index.ts":
/*!***********************************************************************!*\
  !*** ./components/system/Desktop/Wallpapers/StableDiffusion/index.ts ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   libs: () => (/* binding */ libs),\n/* harmony export */   runStableDiffusion: () => (/* binding */ runStableDiffusion)\n/* harmony export */ });\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\nconst libs = [\n    \"/System/tvm/tvmjs_runtime.wasi.js\",\n    \"/System/tvm/tvmjs.bundle.js\",\n    \"/Program Files/StableDiffusion/tokenizers-wasm/tokenizers_wasm.js\",\n    \"/Program Files/StableDiffusion/stable_diffusion.js\"\n];\nconst runStableDiffusion = async (config, canvas, skipLibs = false, reUseCanvas = true)=>{\n    if (!skipLibs) {\n        window.tvmjsGlobalEnv = window.tvmjsGlobalEnv || {};\n        await (0,utils_functions__WEBPACK_IMPORTED_MODULE_0__.loadFiles)(libs);\n    }\n    globalThis.tvmjsGlobalEnv.getTokenizer = async ()=>{\n        if (!globalThis.tvmjsGlobalEnv.initialized) {\n            await globalThis.Tokenizer.init();\n        }\n        globalThis.tvmjsGlobalEnv.initialized = true;\n        return new globalThis.Tokenizer.TokenizerWasm(await (await fetch(\"/Program Files/StableDiffusion/tokenizers-wasm/tokenizer.json\")).text());\n    };\n    if (!reUseCanvas) {\n        globalThis.tvmjsGlobalEnv.canvas = undefined;\n    }\n    globalThis.tvmjsGlobalEnv.canvas = globalThis.tvmjsGlobalEnv.canvas || canvas;\n    const { prompts } = config;\n    globalThis.tvmjsGlobalEnv.prompts = prompts?.length ? prompts : [\n        [\n            \"A photo of an astronaut riding a elephant on jupiter\",\n            \"\"\n        ]\n    ];\n    await globalThis.tvmjsGlobalEnv.asyncOnGenerate();\n};\nconst StableDiffusion = (el, config = {})=>{\n    if (!el) return;\n    const canvas = document.createElement(\"canvas\");\n    canvas.height = window.innerHeight;\n    canvas.width = window.innerWidth;\n    el.append(canvas);\n    runStableDiffusion(config, canvas);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StableDiffusion);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvc3lzdGVtL0Rlc2t0b3AvV2FsbHBhcGVycy9TdGFibGVEaWZmdXNpb24vaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUU0QztBQUVyQyxNQUFNQyxPQUFPO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0NBQ0QsQ0FBQztBQUVLLE1BQU1DLHFCQUFxQixPQUNoQ0MsUUFDQUMsUUFDQUMsV0FBVyxLQUFLLEVBQ2hCQyxjQUFjLElBQUk7SUFFbEIsSUFBSSxDQUFDRCxVQUFVO1FBQ2JFLE9BQU9DLGNBQWMsR0FBR0QsT0FBT0MsY0FBYyxJQUFJLENBQUM7UUFFbEQsTUFBTVIsMERBQVNBLENBQUNDO0lBQ2xCO0lBRUFRLFdBQVdELGNBQWMsQ0FBQ0UsWUFBWSxHQUFHO1FBQ3ZDLElBQUksQ0FBQ0QsV0FBV0QsY0FBYyxDQUFDRyxXQUFXLEVBQUU7WUFDMUMsTUFBTUYsV0FBV0csU0FBUyxDQUFDQyxJQUFJO1FBQ2pDO1FBRUFKLFdBQVdELGNBQWMsQ0FBQ0csV0FBVyxHQUFHO1FBRXhDLE9BQU8sSUFBSUYsV0FBV0csU0FBUyxDQUFDRSxhQUFhLENBQzNDLE1BQU0sQ0FDSixNQUFNQyxNQUNKLGdFQUNGLEVBQ0FDLElBQUk7SUFFVjtJQUVBLElBQUksQ0FBQ1YsYUFBYTtRQUNoQkcsV0FBV0QsY0FBYyxDQUFDSixNQUFNLEdBQUdhO0lBQ3JDO0lBRUFSLFdBQVdELGNBQWMsQ0FBQ0osTUFBTSxHQUFHSyxXQUFXRCxjQUFjLENBQUNKLE1BQU0sSUFBSUE7SUFFdkUsTUFBTSxFQUFFYyxPQUFPLEVBQUUsR0FBR2Y7SUFFcEJNLFdBQVdELGNBQWMsQ0FBQ1UsT0FBTyxHQUFHQSxTQUFTQyxTQUN6Q0QsVUFDQTtRQUFDO1lBQUM7WUFBd0Q7U0FBRztLQUFDO0lBRWxFLE1BQU1ULFdBQVdELGNBQWMsQ0FBQ1ksZUFBZTtBQUNqRCxFQUFFO0FBRUYsTUFBTUMsa0JBQWtCLENBQ3RCQyxJQUNBbkIsU0FBMEIsQ0FBQyxDQUFvQjtJQUUvQyxJQUFJLENBQUNtQixJQUFJO0lBRVQsTUFBTWxCLFNBQVNtQixTQUFTQyxhQUFhLENBQUM7SUFFdENwQixPQUFPcUIsTUFBTSxHQUFHbEIsT0FBT21CLFdBQVc7SUFDbEN0QixPQUFPdUIsS0FBSyxHQUFHcEIsT0FBT3FCLFVBQVU7SUFFaENOLEdBQUdPLE1BQU0sQ0FBQ3pCO0lBRVZGLG1CQUFtQkMsUUFBaUNDO0FBQ3REO0FBRUEsaUVBQWVpQixlQUFlQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXGNvbXBvbmVudHNcXHN5c3RlbVxcRGVza3RvcFxcV2FsbHBhcGVyc1xcU3RhYmxlRGlmZnVzaW9uXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0eXBlIFN0YWJsZURpZmZ1c2lvbkNvbmZpZyB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvU3RhYmxlRGlmZnVzaW9uL3R5cGVzXCI7XHJcbmltcG9ydCB7IHR5cGUgV2FsbHBhcGVyQ29uZmlnIH0gZnJvbSBcImNvbXBvbmVudHMvc3lzdGVtL0Rlc2t0b3AvV2FsbHBhcGVycy90eXBlc1wiO1xyXG5pbXBvcnQgeyBsb2FkRmlsZXMgfSBmcm9tIFwidXRpbHMvZnVuY3Rpb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgbGlicyA9IFtcclxuICBcIi9TeXN0ZW0vdHZtL3R2bWpzX3J1bnRpbWUud2FzaS5qc1wiLFxyXG4gIFwiL1N5c3RlbS90dm0vdHZtanMuYnVuZGxlLmpzXCIsXHJcbiAgXCIvUHJvZ3JhbSBGaWxlcy9TdGFibGVEaWZmdXNpb24vdG9rZW5pemVycy13YXNtL3Rva2VuaXplcnNfd2FzbS5qc1wiLFxyXG4gIFwiL1Byb2dyYW0gRmlsZXMvU3RhYmxlRGlmZnVzaW9uL3N0YWJsZV9kaWZmdXNpb24uanNcIixcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBydW5TdGFibGVEaWZmdXNpb24gPSBhc3luYyAoXHJcbiAgY29uZmlnOiBTdGFibGVEaWZmdXNpb25Db25maWcsXHJcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyxcclxuICBza2lwTGlicyA9IGZhbHNlLFxyXG4gIHJlVXNlQ2FudmFzID0gdHJ1ZVxyXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICBpZiAoIXNraXBMaWJzKSB7XHJcbiAgICB3aW5kb3cudHZtanNHbG9iYWxFbnYgPSB3aW5kb3cudHZtanNHbG9iYWxFbnYgfHwge307XHJcblxyXG4gICAgYXdhaXQgbG9hZEZpbGVzKGxpYnMpO1xyXG4gIH1cclxuXHJcbiAgZ2xvYmFsVGhpcy50dm1qc0dsb2JhbEVudi5nZXRUb2tlbml6ZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIWdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgYXdhaXQgZ2xvYmFsVGhpcy5Ub2tlbml6ZXIuaW5pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5Ub2tlbml6ZXIuVG9rZW5pemVyV2FzbShcclxuICAgICAgYXdhaXQgKFxyXG4gICAgICAgIGF3YWl0IGZldGNoKFxyXG4gICAgICAgICAgXCIvUHJvZ3JhbSBGaWxlcy9TdGFibGVEaWZmdXNpb24vdG9rZW5pemVycy13YXNtL3Rva2VuaXplci5qc29uXCJcclxuICAgICAgICApXHJcbiAgICAgICkudGV4dCgpXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGlmICghcmVVc2VDYW52YXMpIHtcclxuICAgIGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYuY2FudmFzID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZ2xvYmFsVGhpcy50dm1qc0dsb2JhbEVudi5jYW52YXMgPSBnbG9iYWxUaGlzLnR2bWpzR2xvYmFsRW52LmNhbnZhcyB8fCBjYW52YXM7XHJcblxyXG4gIGNvbnN0IHsgcHJvbXB0cyB9ID0gY29uZmlnO1xyXG5cclxuICBnbG9iYWxUaGlzLnR2bWpzR2xvYmFsRW52LnByb21wdHMgPSBwcm9tcHRzPy5sZW5ndGhcclxuICAgID8gcHJvbXB0c1xyXG4gICAgOiBbW1wiQSBwaG90byBvZiBhbiBhc3Ryb25hdXQgcmlkaW5nIGEgZWxlcGhhbnQgb24ganVwaXRlclwiLCBcIlwiXV07XHJcblxyXG4gIGF3YWl0IGdsb2JhbFRoaXMudHZtanNHbG9iYWxFbnYuYXN5bmNPbkdlbmVyYXRlKCk7XHJcbn07XHJcblxyXG5jb25zdCBTdGFibGVEaWZmdXNpb24gPSAoXHJcbiAgZWw/OiBIVE1MRWxlbWVudCB8IG51bGwsXHJcbiAgY29uZmlnOiBXYWxscGFwZXJDb25maWcgPSB7fSBhcyBXYWxscGFwZXJDb25maWdcclxuKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFlbCkgcmV0dXJuO1xyXG5cclxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG5cclxuICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG5cclxuICBlbC5hcHBlbmQoY2FudmFzKTtcclxuXHJcbiAgcnVuU3RhYmxlRGlmZnVzaW9uKGNvbmZpZyBhcyBTdGFibGVEaWZmdXNpb25Db25maWcsIGNhbnZhcyk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdGFibGVEaWZmdXNpb247XHJcbiJdLCJuYW1lcyI6WyJsb2FkRmlsZXMiLCJsaWJzIiwicnVuU3RhYmxlRGlmZnVzaW9uIiwiY29uZmlnIiwiY2FudmFzIiwic2tpcExpYnMiLCJyZVVzZUNhbnZhcyIsIndpbmRvdyIsInR2bWpzR2xvYmFsRW52IiwiZ2xvYmFsVGhpcyIsImdldFRva2VuaXplciIsImluaXRpYWxpemVkIiwiVG9rZW5pemVyIiwiaW5pdCIsIlRva2VuaXplcldhc20iLCJmZXRjaCIsInRleHQiLCJ1bmRlZmluZWQiLCJwcm9tcHRzIiwibGVuZ3RoIiwiYXN5bmNPbkdlbmVyYXRlIiwiU3RhYmxlRGlmZnVzaW9uIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImFwcGVuZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/system/Desktop/Wallpapers/StableDiffusion/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcYmFzZTY0LWpzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(pages-dir-browser)/./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(pages-dir-browser)/./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxidWZmZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXGllZWU3NTRcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={114:function(e){function assertPath(e){if(typeof e!==\"string\"){throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(e))}}function normalizeStringPosix(e,r){var t=\"\";var i=0;var n=-1;var a=0;var f;for(var l=0;l<=e.length;++l){if(l<e.length)f=e.charCodeAt(l);else if(f===47)break;else f=47;if(f===47){if(n===l-1||a===1){}else if(n!==l-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var s=t.lastIndexOf(\"/\");if(s!==t.length-1){if(s===-1){t=\"\";i=0}else{t=t.slice(0,s);i=t.length-1-t.lastIndexOf(\"/\")}n=l;a=0;continue}}else if(t.length===2||t.length===1){t=\"\";i=0;n=l;a=0;continue}}if(r){if(t.length>0)t+=\"/..\";else t=\"..\";i=2}}else{if(t.length>0)t+=\"/\"+e.slice(n+1,l);else t=e.slice(n+1,l);i=l-n-1}n=l;a=0}else if(f===46&&a!==-1){++a}else{a=-1}}return t}function _format(e,r){var t=r.dir||r.root;var i=r.base||(r.name||\"\")+(r.ext||\"\");if(!t){return i}if(t===r.root){return t+i}return t+e+i}var r={resolve:function resolve(){var e=\"\";var r=false;var t;for(var i=arguments.length-1;i>=-1&&!r;i--){var n;if(i>=0)n=arguments[i];else{if(t===undefined)t=\"\";n=t}assertPath(n);if(n.length===0){continue}e=n+\"/\"+e;r=n.charCodeAt(0)===47}e=normalizeStringPosix(e,!r);if(r){if(e.length>0)return\"/\"+e;else return\"/\"}else if(e.length>0){return e}else{return\".\"}},normalize:function normalize(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0)===47;var t=e.charCodeAt(e.length-1)===47;e=normalizeStringPosix(e,!r);if(e.length===0&&!r)e=\".\";if(e.length>0&&t)e+=\"/\";if(r)return\"/\"+e;return e},isAbsolute:function isAbsolute(e){assertPath(e);return e.length>0&&e.charCodeAt(0)===47},join:function join(){if(arguments.length===0)return\".\";var e;for(var t=0;t<arguments.length;++t){var i=arguments[t];assertPath(i);if(i.length>0){if(e===undefined)e=i;else e+=\"/\"+i}}if(e===undefined)return\".\";return r.normalize(e)},relative:function relative(e,t){assertPath(e);assertPath(t);if(e===t)return\"\";e=r.resolve(e);t=r.resolve(t);if(e===t)return\"\";var i=1;for(;i<e.length;++i){if(e.charCodeAt(i)!==47)break}var n=e.length;var a=n-i;var f=1;for(;f<t.length;++f){if(t.charCodeAt(f)!==47)break}var l=t.length;var s=l-f;var o=a<s?a:s;var u=-1;var h=0;for(;h<=o;++h){if(h===o){if(s>o){if(t.charCodeAt(f+h)===47){return t.slice(f+h+1)}else if(h===0){return t.slice(f+h)}}else if(a>o){if(e.charCodeAt(i+h)===47){u=h}else if(h===0){u=0}}break}var c=e.charCodeAt(i+h);var v=t.charCodeAt(f+h);if(c!==v)break;else if(c===47)u=h}var g=\"\";for(h=i+u+1;h<=n;++h){if(h===n||e.charCodeAt(h)===47){if(g.length===0)g+=\"..\";else g+=\"/..\"}}if(g.length>0)return g+t.slice(f+u);else{f+=u;if(t.charCodeAt(f)===47)++f;return t.slice(f)}},_makeLong:function _makeLong(e){return e},dirname:function dirname(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0);var t=r===47;var i=-1;var n=true;for(var a=e.length-1;a>=1;--a){r=e.charCodeAt(a);if(r===47){if(!n){i=a;break}}else{n=false}}if(i===-1)return t?\"/\":\".\";if(t&&i===1)return\"//\";return e.slice(0,i)},basename:function basename(e,r){if(r!==undefined&&typeof r!==\"string\")throw new TypeError('\"ext\" argument must be a string');assertPath(e);var t=0;var i=-1;var n=true;var a;if(r!==undefined&&r.length>0&&r.length<=e.length){if(r.length===e.length&&r===e)return\"\";var f=r.length-1;var l=-1;for(a=e.length-1;a>=0;--a){var s=e.charCodeAt(a);if(s===47){if(!n){t=a+1;break}}else{if(l===-1){n=false;l=a+1}if(f>=0){if(s===r.charCodeAt(f)){if(--f===-1){i=a}}else{f=-1;i=l}}}}if(t===i)i=l;else if(i===-1)i=e.length;return e.slice(t,i)}else{for(a=e.length-1;a>=0;--a){if(e.charCodeAt(a)===47){if(!n){t=a+1;break}}else if(i===-1){n=false;i=a+1}}if(i===-1)return\"\";return e.slice(t,i)}},extname:function extname(e){assertPath(e);var r=-1;var t=0;var i=-1;var n=true;var a=0;for(var f=e.length-1;f>=0;--f){var l=e.charCodeAt(f);if(l===47){if(!n){t=f+1;break}continue}if(i===-1){n=false;i=f+1}if(l===46){if(r===-1)r=f;else if(a!==1)a=1}else if(r!==-1){a=-1}}if(r===-1||i===-1||a===0||a===1&&r===i-1&&r===t+1){return\"\"}return e.slice(r,i)},format:function format(e){if(e===null||typeof e!==\"object\"){throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof e)}return _format(\"/\",e)},parse:function parse(e){assertPath(e);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(e.length===0)return r;var t=e.charCodeAt(0);var i=t===47;var n;if(i){r.root=\"/\";n=1}else{n=0}var a=-1;var f=0;var l=-1;var s=true;var o=e.length-1;var u=0;for(;o>=n;--o){t=e.charCodeAt(o);if(t===47){if(!s){f=o+1;break}continue}if(l===-1){s=false;l=o+1}if(t===46){if(a===-1)a=o;else if(u!==1)u=1}else if(a!==-1){u=-1}}if(a===-1||l===-1||u===0||u===1&&a===l-1&&a===f+1){if(l!==-1){if(f===0&&i)r.base=r.name=e.slice(1,l);else r.base=r.name=e.slice(f,l)}}else{if(f===0&&i){r.name=e.slice(1,a);r.base=e.slice(1,l)}else{r.name=e.slice(f,a);r.base=e.slice(f,l)}r.ext=e.slice(a,l)}if(f>0)r.dir=e.slice(0,f-1);else if(i)r.dir=\"/\";return r},sep:\"/\",delimiter:\":\",win32:null,posix:null};r.posix=r;e.exports=r}};var r={};function __nccwpck_require__(t){var i=r[t];if(i!==undefined){return i.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(114);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsdUJBQXVCLHdCQUF3QiwyRUFBMkUsbUNBQW1DLFNBQVMsUUFBUSxTQUFTLFFBQVEsTUFBTSxZQUFZLFlBQVksS0FBSyxnQ0FBZ0MscUJBQXFCLFVBQVUsV0FBVyxvQkFBb0Isd0JBQXdCLG9GQUFvRixlQUFlLHlCQUF5QixtQkFBbUIsV0FBVyxLQUFLLElBQUksS0FBSyxlQUFlLGdDQUFnQyxJQUFJLElBQUksVUFBVSxvQ0FBb0MsS0FBSyxJQUFJLElBQUksSUFBSSxVQUFVLE1BQU0sdUJBQXVCLFlBQVksS0FBSyxLQUFLLG9DQUFvQyxzQkFBc0IsUUFBUSxJQUFJLElBQUksd0JBQXdCLElBQUksS0FBSyxNQUFNLFNBQVMsc0JBQXNCLG9CQUFvQix1Q0FBdUMsT0FBTyxTQUFTLGVBQWUsV0FBVyxhQUFhLE9BQU8sMkJBQTJCLFNBQVMsWUFBWSxNQUFNLDZCQUE2QixVQUFVLEtBQUssTUFBTSx1QkFBdUIsS0FBSyxzQkFBc0IsSUFBSSxjQUFjLGlCQUFpQixTQUFTLFVBQVUsdUJBQXVCLDZCQUE2QixNQUFNLDBCQUEwQixlQUFlLG9CQUFvQixTQUFTLEtBQUssV0FBVyxpQ0FBaUMsY0FBYywwQkFBMEIsMkJBQTJCLG9DQUFvQyw2QkFBNkIsMEJBQTBCLHdCQUF3QixpQkFBaUIsU0FBUyxtQ0FBbUMsY0FBYyx3Q0FBd0Msc0JBQXNCLGtDQUFrQyxNQUFNLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLGNBQWMsZUFBZSxxQkFBcUIsZUFBZSwyQkFBMkIsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsa0JBQWtCLGVBQWUsZUFBZSxrQkFBa0IsUUFBUSxLQUFLLFdBQVcsS0FBSyw4QkFBOEIsZUFBZSxVQUFVLFFBQVEsS0FBSyxXQUFXLEtBQUssOEJBQThCLGVBQWUsVUFBVSxjQUFjLFNBQVMsUUFBUSxLQUFLLEtBQUssS0FBSyxVQUFVLFFBQVEsMkJBQTJCLHNCQUFzQixlQUFlLHFCQUFxQixhQUFhLDJCQUEyQixJQUFJLGVBQWUsS0FBSyxNQUFNLHdCQUF3Qix3QkFBd0IsZUFBZSxtQkFBbUIsU0FBUyxZQUFZLEtBQUssS0FBSyxnQ0FBZ0Msd0JBQXdCLGVBQWUsb0NBQW9DLEtBQUssS0FBSyw0QkFBNEIsbUJBQW1CLGlDQUFpQyxTQUFTLDZCQUE2QixjQUFjLDBCQUEwQixzQkFBc0IsYUFBYSxTQUFTLFdBQVcscUJBQXFCLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLElBQUksT0FBTyxLQUFLLFNBQVMsMkJBQTJCLHVCQUF1QixvQkFBb0IsaUNBQWlDLDZGQUE2RixjQUFjLFFBQVEsU0FBUyxXQUFXLE1BQU0sa0RBQWtELHVDQUF1QyxpQkFBaUIsU0FBUyxpQkFBaUIsS0FBSyxLQUFLLHNCQUFzQixXQUFXLE9BQU8sTUFBTSxPQUFPLEtBQUssV0FBVyxRQUFRLE1BQU0sU0FBUyx3QkFBd0IsYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPLGFBQWEsMEJBQTBCLG9CQUFvQixLQUFLLGlCQUFpQixLQUFLLEtBQUsseUJBQXlCLE9BQU8sTUFBTSxPQUFPLGdCQUFnQixRQUFRLE9BQU8sbUJBQW1CLHFCQUFxQiw2QkFBNkIsY0FBYyxTQUFTLFFBQVEsU0FBUyxXQUFXLFFBQVEscUJBQXFCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFNBQVMsb0JBQW9CLDJCQUEyQixrQ0FBa0MsaUdBQWlHLHNCQUFzQix5QkFBeUIsY0FBYyxPQUFPLHVDQUF1Qyx5QkFBeUIsc0JBQXNCLGFBQWEsTUFBTSxNQUFNLFdBQVcsSUFBSSxLQUFLLElBQUksU0FBUyxRQUFRLFNBQVMsV0FBVyxpQkFBaUIsUUFBUSxLQUFLLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFdBQVcsdUNBQXVDLGlDQUFpQyxLQUFLLGFBQWEsb0JBQW9CLG9CQUFvQixLQUFLLG9CQUFvQixvQkFBb0IsbUJBQW1CLDRCQUE0QixvQkFBb0IsU0FBUyw4Q0FBOEMsVUFBVSxjQUFjLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccGF0aC1icm93c2VyaWZ5XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTE0OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./utils/constants.ts":
/*!****************************!*\
  !*** ./utils/constants.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_TITLE: () => (/* binding */ AI_TITLE),\n/* harmony export */   AI_WINDOW_ID: () => (/* binding */ AI_WINDOW_ID),\n/* harmony export */   AUDIO_FILE_EXTENSIONS: () => (/* binding */ AUDIO_FILE_EXTENSIONS),\n/* harmony export */   AUDIO_PLAYLIST_EXTENSIONS: () => (/* binding */ AUDIO_PLAYLIST_EXTENSIONS),\n/* harmony export */   BASE_2D_CONTEXT_OPTIONS: () => (/* binding */ BASE_2D_CONTEXT_OPTIONS),\n/* harmony export */   BASE_ZIP_CONFIG: () => (/* binding */ BASE_ZIP_CONFIG),\n/* harmony export */   CLIPBOARD_FILE_EXTENSIONS: () => (/* binding */ CLIPBOARD_FILE_EXTENSIONS),\n/* harmony export */   CLOCK_CANVAS_BASE_WIDTH: () => (/* binding */ CLOCK_CANVAS_BASE_WIDTH),\n/* harmony export */   COMPRESSED_FOLDER_ICON: () => (/* binding */ COMPRESSED_FOLDER_ICON),\n/* harmony export */   CURSOR_FILE_EXTENSIONS: () => (/* binding */ CURSOR_FILE_EXTENSIONS),\n/* harmony export */   DECODED_VIDEO_FILE_EXTENSIONS: () => (/* binding */ DECODED_VIDEO_FILE_EXTENSIONS),\n/* harmony export */   DEFAULT_ASCENDING: () => (/* binding */ DEFAULT_ASCENDING),\n/* harmony export */   DEFAULT_CLOCK_SOURCE: () => (/* binding */ DEFAULT_CLOCK_SOURCE),\n/* harmony export */   DEFAULT_INTERSECTION_OPTIONS: () => (/* binding */ DEFAULT_INTERSECTION_OPTIONS),\n/* harmony export */   DEFAULT_LOCALE: () => (/* binding */ DEFAULT_LOCALE),\n/* harmony export */   DEFAULT_MAPPED_NAME: () => (/* binding */ DEFAULT_MAPPED_NAME),\n/* harmony export */   DEFAULT_SCROLLBAR_WIDTH: () => (/* binding */ DEFAULT_SCROLLBAR_WIDTH),\n/* harmony export */   DEFAULT_TEXT_FILE_SAVE_PATH: () => (/* binding */ DEFAULT_TEXT_FILE_SAVE_PATH),\n/* harmony export */   DEFAULT_THEME: () => (/* binding */ DEFAULT_THEME),\n/* harmony export */   DEFAULT_WALLPAPER: () => (/* binding */ DEFAULT_WALLPAPER),\n/* harmony export */   DEFAULT_WALLPAPER_FIT: () => (/* binding */ DEFAULT_WALLPAPER_FIT),\n/* harmony export */   DEFAULT_WINDOW_SIZE: () => (/* binding */ DEFAULT_WINDOW_SIZE),\n/* harmony export */   DESKTOP_PATH: () => (/* binding */ DESKTOP_PATH),\n/* harmony export */   DISBALE_AUTO_INPUT_FEATURES: () => (/* binding */ DISBALE_AUTO_INPUT_FEATURES),\n/* harmony export */   DIV_BUTTON_PROPS: () => (/* binding */ DIV_BUTTON_PROPS),\n/* harmony export */   DYNAMIC_EXTENSION: () => (/* binding */ DYNAMIC_EXTENSION),\n/* harmony export */   DYNAMIC_PREFIX: () => (/* binding */ DYNAMIC_PREFIX),\n/* harmony export */   EDITABLE_IMAGE_FILE_EXTENSIONS: () => (/* binding */ EDITABLE_IMAGE_FILE_EXTENSIONS),\n/* harmony export */   FAVICON_BASE_PATH: () => (/* binding */ FAVICON_BASE_PATH),\n/* harmony export */   FOCUSABLE_ELEMENT: () => (/* binding */ FOCUSABLE_ELEMENT),\n/* harmony export */   FOLDER_BACK_ICON: () => (/* binding */ FOLDER_BACK_ICON),\n/* harmony export */   FOLDER_FRONT_ICON: () => (/* binding */ FOLDER_FRONT_ICON),\n/* harmony export */   FOLDER_ICON: () => (/* binding */ FOLDER_ICON),\n/* harmony export */   FS_HANDLES: () => (/* binding */ FS_HANDLES),\n/* harmony export */   HEIF_IMAGE_FORMATS: () => (/* binding */ HEIF_IMAGE_FORMATS),\n/* harmony export */   HIGH_PRIORITY_ELEMENT: () => (/* binding */ HIGH_PRIORITY_ELEMENT),\n/* harmony export */   HIGH_PRIORITY_REQUEST: () => (/* binding */ HIGH_PRIORITY_REQUEST),\n/* harmony export */   HOME: () => (/* binding */ HOME),\n/* harmony export */   ICON_CACHE: () => (/* binding */ ICON_CACHE),\n/* harmony export */   ICON_CACHE_EXTENSION: () => (/* binding */ ICON_CACHE_EXTENSION),\n/* harmony export */   ICON_GIF_FPS: () => (/* binding */ ICON_GIF_FPS),\n/* harmony export */   ICON_GIF_SECONDS: () => (/* binding */ ICON_GIF_SECONDS),\n/* harmony export */   ICON_PATH: () => (/* binding */ ICON_PATH),\n/* harmony export */   ICON_RES_MAP: () => (/* binding */ ICON_RES_MAP),\n/* harmony export */   IFRAME_CONFIG: () => (/* binding */ IFRAME_CONFIG),\n/* harmony export */   IMAGE_FILE_EXTENSIONS: () => (/* binding */ IMAGE_FILE_EXTENSIONS),\n/* harmony export */   INDEX_FILE: () => (/* binding */ INDEX_FILE),\n/* harmony export */   KEYPRESS_DEBOUNCE_MS: () => (/* binding */ KEYPRESS_DEBOUNCE_MS),\n/* harmony export */   LIST_VIEW_ANIMATION: () => (/* binding */ LIST_VIEW_ANIMATION),\n/* harmony export */   LONG_PRESS_DELAY_MS: () => (/* binding */ LONG_PRESS_DELAY_MS),\n/* harmony export */   MAX_ICON_SIZE: () => (/* binding */ MAX_ICON_SIZE),\n/* harmony export */   MAX_RES_ICON_OVERRIDE: () => (/* binding */ MAX_RES_ICON_OVERRIDE),\n/* harmony export */   MAX_THUMBNAIL_FILE_SIZE: () => (/* binding */ MAX_THUMBNAIL_FILE_SIZE),\n/* harmony export */   MAX_ZINDEX: () => (/* binding */ MAX_ZINDEX),\n/* harmony export */   MENU_SEPERATOR: () => (/* binding */ MENU_SEPERATOR),\n/* harmony export */   MILLISECONDS_IN_DAY: () => (/* binding */ MILLISECONDS_IN_DAY),\n/* harmony export */   MILLISECONDS_IN_HOUR: () => (/* binding */ MILLISECONDS_IN_HOUR),\n/* harmony export */   MILLISECONDS_IN_MINUTE: () => (/* binding */ MILLISECONDS_IN_MINUTE),\n/* harmony export */   MILLISECONDS_IN_SECOND: () => (/* binding */ MILLISECONDS_IN_SECOND),\n/* harmony export */   MOUNTABLE_EXTENSIONS: () => (/* binding */ MOUNTABLE_EXTENSIONS),\n/* harmony export */   MOUNTABLE_FS_TYPES: () => (/* binding */ MOUNTABLE_FS_TYPES),\n/* harmony export */   MOUNTED_FOLDER_ICON: () => (/* binding */ MOUNTED_FOLDER_ICON),\n/* harmony export */   MP3_MIME_TYPE: () => (/* binding */ MP3_MIME_TYPE),\n/* harmony export */   NATIVE_IMAGE_FORMATS: () => (/* binding */ NATIVE_IMAGE_FORMATS),\n/* harmony export */   NEW_FOLDER_ICON: () => (/* binding */ NEW_FOLDER_ICON),\n/* harmony export */   NON_BREAKING_HYPHEN: () => (/* binding */ NON_BREAKING_HYPHEN),\n/* harmony export */   ONE_DAY_IN_MILLISECONDS: () => (/* binding */ ONE_DAY_IN_MILLISECONDS),\n/* harmony export */   ONE_TIME_PASSIVE_EVENT: () => (/* binding */ ONE_TIME_PASSIVE_EVENT),\n/* harmony export */   PACKAGE_DATA: () => (/* binding */ PACKAGE_DATA),\n/* harmony export */   PEEK_MAX_WIDTH: () => (/* binding */ PEEK_MAX_WIDTH),\n/* harmony export */   PHOTO_ICON: () => (/* binding */ PHOTO_ICON),\n/* harmony export */   PICTURES_FOLDER: () => (/* binding */ PICTURES_FOLDER),\n/* harmony export */   PICUTRES_PATH: () => (/* binding */ PICUTRES_PATH),\n/* harmony export */   PREVENT_SCROLL: () => (/* binding */ PREVENT_SCROLL),\n/* harmony export */   PROCESS_DELIMITER: () => (/* binding */ PROCESS_DELIMITER),\n/* harmony export */   PROMPT_FILE: () => (/* binding */ PROMPT_FILE),\n/* harmony export */   ROOT_NAME: () => (/* binding */ ROOT_NAME),\n/* harmony export */   ROOT_SHORTCUT: () => (/* binding */ ROOT_SHORTCUT),\n/* harmony export */   SAVE_PATH: () => (/* binding */ SAVE_PATH),\n/* harmony export */   SAVE_TITLE_CHAR: () => (/* binding */ SAVE_TITLE_CHAR),\n/* harmony export */   SESSION_FILE: () => (/* binding */ SESSION_FILE),\n/* harmony export */   SHORTCUT_APPEND: () => (/* binding */ SHORTCUT_APPEND),\n/* harmony export */   SHORTCUT_EXTENSION: () => (/* binding */ SHORTCUT_EXTENSION),\n/* harmony export */   SHORTCUT_ICON: () => (/* binding */ SHORTCUT_ICON),\n/* harmony export */   SLIDESHOW_FILE: () => (/* binding */ SLIDESHOW_FILE),\n/* harmony export */   SLIDESHOW_TIMEOUT_IN_MILLISECONDS: () => (/* binding */ SLIDESHOW_TIMEOUT_IN_MILLISECONDS),\n/* harmony export */   SMALLEST_PNG_SIZE: () => (/* binding */ SMALLEST_PNG_SIZE),\n/* harmony export */   SPREADSHEET_FORMATS: () => (/* binding */ SPREADSHEET_FORMATS),\n/* harmony export */   START_MENU_PATH: () => (/* binding */ START_MENU_PATH),\n/* harmony export */   SUMMARIZABLE_FILE_EXTENSIONS: () => (/* binding */ SUMMARIZABLE_FILE_EXTENSIONS),\n/* harmony export */   SUPPORTED_ICON_PIXEL_RATIOS: () => (/* binding */ SUPPORTED_ICON_PIXEL_RATIOS),\n/* harmony export */   SUPPORTED_ICON_SIZES: () => (/* binding */ SUPPORTED_ICON_SIZES),\n/* harmony export */   SYSTEM_FILES: () => (/* binding */ SYSTEM_FILES),\n/* harmony export */   SYSTEM_PATH: () => (/* binding */ SYSTEM_PATH),\n/* harmony export */   SYSTEM_PATHS: () => (/* binding */ SYSTEM_PATHS),\n/* harmony export */   SYSTEM_SHORTCUT_DIRECTORIES: () => (/* binding */ SYSTEM_SHORTCUT_DIRECTORIES),\n/* harmony export */   TASKBAR_HEIGHT: () => (/* binding */ TASKBAR_HEIGHT),\n/* harmony export */   TEXT_EDITORS: () => (/* binding */ TEXT_EDITORS),\n/* harmony export */   THIN_SCROLLBAR_WIDTH: () => (/* binding */ THIN_SCROLLBAR_WIDTH),\n/* harmony export */   THIN_SCROLLBAR_WIDTH_NON_WEBKIT: () => (/* binding */ THIN_SCROLLBAR_WIDTH_NON_WEBKIT),\n/* harmony export */   TIFF_IMAGE_FORMATS: () => (/* binding */ TIFF_IMAGE_FORMATS),\n/* harmony export */   TIMESTAMP_DATE_FORMAT: () => (/* binding */ TIMESTAMP_DATE_FORMAT),\n/* harmony export */   TRANSITIONS_IN_MILLISECONDS: () => (/* binding */ TRANSITIONS_IN_MILLISECONDS),\n/* harmony export */   TRANSITIONS_IN_SECONDS: () => (/* binding */ TRANSITIONS_IN_SECONDS),\n/* harmony export */   UNKNOWN_ICON_PATH: () => (/* binding */ UNKNOWN_ICON_PATH),\n/* harmony export */   UNSUPPORTED_SLIDESHOW_EXTENSIONS: () => (/* binding */ UNSUPPORTED_SLIDESHOW_EXTENSIONS),\n/* harmony export */   USER_ICON_PATH: () => (/* binding */ USER_ICON_PATH),\n/* harmony export */   VIDEOS_FOLDER: () => (/* binding */ VIDEOS_FOLDER),\n/* harmony export */   VIDEO_FALLBACK_MIME_TYPE: () => (/* binding */ VIDEO_FALLBACK_MIME_TYPE),\n/* harmony export */   VIDEO_FILE_EXTENSIONS: () => (/* binding */ VIDEO_FILE_EXTENSIONS),\n/* harmony export */   YT_ICON_CACHE: () => (/* binding */ YT_ICON_CACHE),\n/* harmony export */   ZIP_EXTENSIONS: () => (/* binding */ ZIP_EXTENSIONS)\n/* harmony export */ });\nconst BASE_2D_CONTEXT_OPTIONS = {\n    alpha: false,\n    desynchronized: true\n};\nconst IFRAME_CONFIG = {\n    referrerPolicy: \"no-referrer\",\n    sandbox: \"allow-downloads allow-forms allow-modals allow-pointer-lock allow-popups allow-presentation allow-same-origin allow-scripts\"\n};\nconst DEFAULT_LOCALE = \"en\";\nconst DEFAULT_ASCENDING = true;\nconst DEFAULT_CLOCK_SOURCE = \"local\";\nconst DEFAULT_THEME = \"defaultTheme\";\nconst DEFAULT_WALLPAPER = \"VANTA\";\nconst DEFAULT_WALLPAPER_FIT = \"fill\";\nconst THIN_SCROLLBAR_WIDTH = 13;\nconst THIN_SCROLLBAR_WIDTH_NON_WEBKIT = 9;\nconst CLOCK_CANVAS_BASE_WIDTH = 68;\nconst SMALLEST_PNG_SIZE = 51;\nconst DEFAULT_WINDOW_SIZE = {\n    height: 510,\n    width: 640\n};\nconst DEFAULT_MAPPED_NAME = \"Share\";\nconst FOCUSABLE_ELEMENT = {\n    tabIndex: -1\n};\nconst DIV_BUTTON_PROPS = {\n    as: \"div\",\n    role: \"button\",\n    ...FOCUSABLE_ELEMENT\n};\nconst FS_HANDLES = \"FileSystemAccessHandles\";\nconst HOME = \"/Users/Public\";\nconst PICTURES_FOLDER = `${HOME}/Pictures`;\nconst VIDEOS_FOLDER = `${HOME}/Videos`;\nconst INDEX_FILE = \"/index.html\";\nconst PROMPT_FILE = \"prompts.json\";\nconst SLIDESHOW_FILE = \"slideshow.json\";\nconst SLIDESHOW_TIMEOUT_IN_MILLISECONDS = 15000;\nconst ICON_GIF_SECONDS = 2;\nconst ICON_GIF_FPS = 24;\nconst PEEK_MAX_WIDTH = 200;\nconst LIST_VIEW_ANIMATION = {\n    animate: {\n        opacity: 1\n    },\n    initial: {\n        opacity: 0\n    },\n    transition: {\n        duration: 0.15\n    }\n};\nconst HEIF_IMAGE_FORMATS = new Set([\n    \".heic\",\n    \".heics\",\n    \".heif\",\n    \".heifs\",\n    \".hif\",\n    \".avci\",\n    \".avcs\"\n]);\nconst TIFF_IMAGE_FORMATS = new Set([\n    \".cr2\",\n    \".dng\",\n    \".nef\",\n    \".tif\",\n    \".tiff\"\n]);\nconst CLIPBOARD_FILE_EXTENSIONS = new Set([\n    \".jpeg\",\n    \".jpg\",\n    \".png\"\n]);\nconst NATIVE_IMAGE_FORMATS = new Set([\n    \".apng\",\n    \".avif\",\n    \".bmp\",\n    \".gif\",\n    \".ico\",\n    \".jfif\",\n    \".jif\",\n    \".jpe\",\n    \".jpeg\",\n    \".jpg\",\n    \".pjp\",\n    \".pjpeg\",\n    \".png\",\n    \".svg\",\n    \".webp\",\n    \".xbm\"\n]);\nconst IMAGE_FILE_EXTENSIONS = new Set([\n    ...NATIVE_IMAGE_FORMATS,\n    ...HEIF_IMAGE_FORMATS,\n    ...TIFF_IMAGE_FORMATS,\n    \".ani\",\n    \".cur\",\n    \".jxl\",\n    \".qoi\"\n]);\nconst UNSUPPORTED_SLIDESHOW_EXTENSIONS = new Set([\n    ...HEIF_IMAGE_FORMATS,\n    ...TIFF_IMAGE_FORMATS,\n    \".jxl\",\n    \".qoi\",\n    \".svg\"\n]);\nconst TEXT_EDITORS = [\n    \"MonacoEditor\",\n    \"Vim\"\n];\nconst CURSOR_FILE_EXTENSIONS = new Set([\n    \".ani\",\n    \".cur\"\n]);\nconst SUMMARIZABLE_FILE_EXTENSIONS = new Set([\n    \".html\",\n    \".htm\",\n    \".whtml\",\n    \".md\",\n    \".txt\",\n    \".pdf\"\n]);\nconst EDITABLE_IMAGE_FILE_EXTENSIONS = new Set([\n    \".bmp\",\n    \".gif\",\n    \".ico\",\n    \".jfif\",\n    \".jpe\",\n    \".jpeg\",\n    \".jpg\",\n    \".png\",\n    \".tif\",\n    \".tiff\",\n    \".webp\"\n]);\nconst MENU_SEPERATOR = {\n    seperator: true\n};\nconst MILLISECONDS_IN_SECOND = 1000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_DAY = 86400000;\nconst ZIP_EXTENSIONS = new Set([\n    \".jsdos\",\n    \".pk3\",\n    \".wsz\",\n    \".zip\"\n]);\nconst MOUNTABLE_EXTENSIONS = new Set([\n    \".iso\",\n    ...ZIP_EXTENSIONS\n]);\nconst MOUNTABLE_FS_TYPES = new Set([\n    \"FileSystemAccess\",\n    \"HTTPRequest\"\n]);\nconst SPREADSHEET_FORMATS = [\n    \".csv\",\n    \".numbers\",\n    \".ods\",\n    \".xls\",\n    \".xlsx\"\n];\nconst MP3_MIME_TYPE = \"audio/mpeg\";\nconst VIDEO_FALLBACK_MIME_TYPE = \"video/mp4\";\nconst NON_BREAKING_HYPHEN = \"\\u2011\";\nconst ONE_TIME_PASSIVE_EVENT = {\n    once: true,\n    passive: true\n};\nconst PREVENT_SCROLL = {\n    preventScroll: true\n};\nconst PROCESS_DELIMITER = \"__\";\nconst SAVE_PATH = `${HOME}/Snapshots`;\nconst PICUTRES_PATH = `${HOME}/Pictures`;\nconst SHORTCUT_APPEND = \" - Shortcut\";\nconst SHORTCUT_EXTENSION = \".url\";\nconst SYSTEM_FILES = new Set([\n    \"desktop.ini\"\n]);\nconst SYSTEM_PATHS = new Set([\n    \"/.deletedFiles.log\"\n]);\nconst DESKTOP_PATH = `${HOME}/Desktop`;\nconst START_MENU_PATH = `${HOME}/Start Menu`;\nconst AI_TITLE = \"Talos\";\nconst AI_WINDOW_ID = \"ai-chat-window\";\nconst SYSTEM_SHORTCUT_DIRECTORIES = new Set([\n    DESKTOP_PATH\n]);\nconst TRANSITIONS_IN_MILLISECONDS = {\n    DOUBLE_CLICK: 500,\n    LONG_PRESS: 500,\n    MOUSE_IN_OUT: 300,\n    TASKBAR_ITEM: 400,\n    WINDOW: 250\n};\nconst TRANSITIONS_IN_SECONDS = {\n    TASKBAR_ITEM: TRANSITIONS_IN_MILLISECONDS.TASKBAR_ITEM / MILLISECONDS_IN_SECOND,\n    WINDOW: TRANSITIONS_IN_MILLISECONDS.WINDOW / MILLISECONDS_IN_SECOND\n};\nconst KEYPRESS_DEBOUNCE_MS = 150;\nconst LONG_PRESS_DELAY_MS = 750;\nconst ONE_DAY_IN_MILLISECONDS = 86400000;\nconst DEFAULT_INTERSECTION_OPTIONS = {\n    rootMargin: \"3px\",\n    threshold: 0\n};\nconst AUDIO_FILE_EXTENSIONS = new Set([\n    \".aac\",\n    \".flac\",\n    \".m4a\",\n    \".oga\",\n    \".wav\"\n]);\nconst AUDIO_PLAYLIST_EXTENSIONS = new Set([\n    \".asx\",\n    \".m3u\",\n    \".pls\"\n]);\nconst DECODED_VIDEO_FILE_EXTENSIONS = new Set([\n    \".avi\",\n    \".divx\"\n]);\nconst VIDEO_FILE_EXTENSIONS = new Set([\n    \".3gp\",\n    \".f4v\",\n    \".m4v\",\n    \".mkv\",\n    \".mov\",\n    \".mp4\",\n    \".ogg\",\n    \".ogm\",\n    \".ogv\",\n    \".webm\"\n]);\nconst DYNAMIC_PREFIX = [\n    \"nostr:\"\n];\nconst DYNAMIC_EXTENSION = new Set([\n    ...AUDIO_FILE_EXTENSIONS,\n    ...AUDIO_PLAYLIST_EXTENSIONS,\n    ...IMAGE_FILE_EXTENSIONS,\n    ...TIFF_IMAGE_FORMATS,\n    ...VIDEO_FILE_EXTENSIONS,\n    \".ani\",\n    \".exe\",\n    \".mp3\",\n    \".sav\",\n    \".whtml\"\n]);\nconst SAVE_TITLE_CHAR = \"\\u25CF\";\nconst ROOT_NAME = \"My PC\";\nconst SYSTEM_PATH = \"/System\";\nconst ROOT_SHORTCUT = `${ROOT_NAME}.url`;\nconst ICON_PATH = `${SYSTEM_PATH}/Icons`;\nconst PHOTO_ICON = `${ICON_PATH}/photo.webp`;\nconst USER_ICON_PATH = `${HOME}/Icons`;\nconst ICON_CACHE = `${USER_ICON_PATH}/Cache`;\nconst YT_ICON_CACHE = `${ICON_CACHE}/YouTube`;\nconst ICON_CACHE_EXTENSION = \".cache\";\nconst SESSION_FILE = \"/session.json\";\nconst SHORTCUT_ICON = `${ICON_PATH}/shortcut.webp`;\nconst FAVICON_BASE_PATH = `/favicon.ico?v=${Date.now()}`;\nconst FOLDER_ICON = `${ICON_PATH}/folder.webp`;\nconst FOLDER_BACK_ICON = `${ICON_PATH}/folder_back.webp`;\nconst FOLDER_FRONT_ICON = `${ICON_PATH}/folder_front.webp`;\nconst COMPRESSED_FOLDER_ICON = `${ICON_PATH}/compressed.webp`;\nconst MOUNTED_FOLDER_ICON = `${ICON_PATH}/mounted.webp`;\nconst NEW_FOLDER_ICON = `${ICON_PATH}/new_folder.webp`;\nconst UNKNOWN_ICON_PATH = `${ICON_PATH}/unknown.webp`;\nconst TIMESTAMP_DATE_FORMAT = {\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    hour12: false,\n    minute: \"2-digit\",\n    month: \"2-digit\",\n    second: \"2-digit\",\n    year: \"numeric\"\n};\nconst ICON_RES_MAP = {\n    64: 96\n};\nconst MAX_RES_ICON_OVERRIDE = {\n    desktop: [\n        16,\n        32\n    ],\n    document: [\n        16,\n        32\n    ],\n    folder: [\n        16,\n        16\n    ],\n    mounted: [\n        16,\n        16\n    ],\n    music: [\n        16,\n        32\n    ],\n    pc: [\n        16,\n        16\n    ],\n    pictures: [\n        16,\n        32\n    ],\n    user: [\n        16,\n        16\n    ],\n    videos: [\n        16,\n        32\n    ]\n};\nconst SUPPORTED_ICON_PIXEL_RATIOS = [\n    3,\n    2,\n    1\n];\nconst SUPPORTED_ICON_SIZES = [\n    16,\n    32,\n    48,\n    96,\n    144\n];\nconst MAX_ICON_SIZE = 144;\nconst MAX_THUMBNAIL_FILE_SIZE = 1048576; // 1 MB\nconst DEFAULT_TEXT_FILE_SAVE_PATH = `${DESKTOP_PATH}/Untitled.txt`;\nconst DEFAULT_SCROLLBAR_WIDTH = 17;\nconst TASKBAR_HEIGHT = 30;\nconst PACKAGE_DATA = {\n    alias: \"Miguel Portfolio\",\n    author: {\n        email: \"dustinbrett@gmail.com\",\n        name: \"Dustin Brett\",\n        npub: \"npub10uc7hg6wdxhhd7ee8x9c5lr9d0ux7272rv2m0mc03ds54q7quxjss02r3p\",\n        url: \"https://dustinbrett.com\"\n    },\n    description: \"Desktop environment in the browser\",\n    license: \"MIT\",\n    version: \"2.0.0\"\n};\nconst BASE_ZIP_CONFIG = {\n    consume: true,\n    level: 0,\n    mem: 8\n};\nconst HIGH_PRIORITY_REQUEST = {\n    priority: \"high\"\n};\nconst HIGH_PRIORITY_ELEMENT = {\n    fetchPriority: \"high\"\n};\nconst DISBALE_AUTO_INPUT_FEATURES = {\n    autoCapitalize: \"off\",\n    autoComplete: \"off\",\n    autoCorrect: \"off\",\n    spellCheck: false\n};\nconst MAX_ZINDEX = 2147483647;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS08sTUFBTUEsMEJBQTREO0lBQ3ZFQyxPQUFPO0lBQ1BDLGdCQUFnQjtBQUNsQixFQUFFO0FBRUssTUFBTUMsZ0JBQWdCO0lBQzNCQyxnQkFBZ0I7SUFDaEJDLFNBQ0U7QUFDSixFQUFFO0FBRUssTUFBTUMsaUJBQWlCLEtBQUs7QUFFNUIsTUFBTUMsb0JBQW9CLEtBQUs7QUFFL0IsTUFBTUMsdUJBQW9DLFFBQVE7QUFFbEQsTUFBTUMsZ0JBQTJCLGVBQWU7QUFFaEQsTUFBTUMsb0JBQW9CLFFBQVE7QUFFbEMsTUFBTUMsd0JBQXNDLE9BQU87QUFFbkQsTUFBTUMsdUJBQXVCLEdBQUc7QUFFaEMsTUFBTUMsa0NBQWtDLEVBQUU7QUFFMUMsTUFBTUMsMEJBQTBCLEdBQUc7QUFFbkMsTUFBTUMsb0JBQW9CLEdBQUc7QUFFN0IsTUFBTUMsc0JBQTRCO0lBQ3ZDQyxRQUFRO0lBQ1JDLE9BQU87QUFDVCxFQUFFO0FBRUssTUFBTUMsc0JBQXNCLFFBQVE7QUFFcEMsTUFBTUMsb0JBQW9CO0lBQUVDLFVBQVUsQ0FBQztBQUFFLEVBQUU7QUFFM0MsTUFBTUMsbUJBQW1CO0lBQzlCQyxJQUFJO0lBQ0pDLE1BQU07SUFDTixHQUFHSixpQkFBaUI7QUFDdEIsRUFBRTtBQUVLLE1BQU1LLGFBQWEsMEJBQTBCO0FBRTdDLE1BQU1DLE9BQU8sZ0JBQWdCO0FBRTdCLE1BQU1DLGtCQUFrQixHQUFHRCxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBRTNDLE1BQU1FLGdCQUFnQixHQUFHRixLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBRXZDLE1BQU1HLGFBQWEsY0FBYztBQUVqQyxNQUFNQyxj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XFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFx1dGlsc1xcY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgQXN5bmNaaXBPcHRpb25zIH0gZnJvbSBcImZmbGF0ZVwiO1xyXG5pbXBvcnQgeyB0eXBlIFNpemUgfSBmcm9tIFwiY29tcG9uZW50cy9zeXN0ZW0vV2luZG93L1JuZFdpbmRvdy91c2VSZXNpemFibGVcIjtcclxuaW1wb3J0IHsgdHlwZSBDbG9ja1NvdXJjZSwgdHlwZSBXYWxscGFwZXJGaXQgfSBmcm9tIFwiY29udGV4dHMvc2Vzc2lvbi90eXBlc1wiO1xyXG5pbXBvcnQgeyB0eXBlIFRoZW1lTmFtZSB9IGZyb20gXCJzdHlsZXMvdGhlbWVzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQkFTRV8yRF9DT05URVhUX09QVElPTlM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFNldHRpbmdzID0ge1xyXG4gIGFscGhhOiBmYWxzZSxcclxuICBkZXN5bmNocm9uaXplZDogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBJRlJBTUVfQ09ORklHID0ge1xyXG4gIHJlZmVycmVyUG9saWN5OiBcIm5vLXJlZmVycmVyXCIgYXMgUmVhY3QuSFRNTEF0dHJpYnV0ZVJlZmVycmVyUG9saWN5LFxyXG4gIHNhbmRib3g6XHJcbiAgICBcImFsbG93LWRvd25sb2FkcyBhbGxvdy1mb3JtcyBhbGxvdy1tb2RhbHMgYWxsb3ctcG9pbnRlci1sb2NrIGFsbG93LXBvcHVwcyBhbGxvdy1wcmVzZW50YXRpb24gYWxsb3ctc2FtZS1vcmlnaW4gYWxsb3ctc2NyaXB0c1wiLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9DQUxFID0gXCJlblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVNDRU5ESU5HID0gdHJ1ZTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NMT0NLX1NPVVJDRTogQ2xvY2tTb3VyY2UgPSBcImxvY2FsXCI7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9USEVNRTogVGhlbWVOYW1lID0gXCJkZWZhdWx0VGhlbWVcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dBTExQQVBFUiA9IFwiVkFOVEFcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dBTExQQVBFUl9GSVQ6IFdhbGxwYXBlckZpdCA9IFwiZmlsbFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRISU5fU0NST0xMQkFSX1dJRFRIID0gMTM7XHJcblxyXG5leHBvcnQgY29uc3QgVEhJTl9TQ1JPTExCQVJfV0lEVEhfTk9OX1dFQktJVCA9IDk7XHJcblxyXG5leHBvcnQgY29uc3QgQ0xPQ0tfQ0FOVkFTX0JBU0VfV0lEVEggPSA2ODtcclxuXHJcbmV4cG9ydCBjb25zdCBTTUFMTEVTVF9QTkdfU0laRSA9IDUxO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfV0lORE9XX1NJWkU6IFNpemUgPSB7XHJcbiAgaGVpZ2h0OiA1MTAsXHJcbiAgd2lkdGg6IDY0MCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX01BUFBFRF9OQU1FID0gXCJTaGFyZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UID0geyB0YWJJbmRleDogLTEgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBESVZfQlVUVE9OX1BST1BTID0ge1xyXG4gIGFzOiBcImRpdlwiLFxyXG4gIHJvbGU6IFwiYnV0dG9uXCIsXHJcbiAgLi4uRk9DVVNBQkxFX0VMRU1FTlQsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgRlNfSEFORExFUyA9IFwiRmlsZVN5c3RlbUFjY2Vzc0hhbmRsZXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBIT01FID0gXCIvVXNlcnMvUHVibGljXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUElDVFVSRVNfRk9MREVSID0gYCR7SE9NRX0vUGljdHVyZXNgO1xyXG5cclxuZXhwb3J0IGNvbnN0IFZJREVPU19GT0xERVIgPSBgJHtIT01FfS9WaWRlb3NgO1xyXG5cclxuZXhwb3J0IGNvbnN0IElOREVYX0ZJTEUgPSBcIi9pbmRleC5odG1sXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUFJPTVBUX0ZJTEUgPSBcInByb21wdHMuanNvblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNMSURFU0hPV19GSUxFID0gXCJzbGlkZXNob3cuanNvblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNMSURFU0hPV19USU1FT1VUX0lOX01JTExJU0VDT05EUyA9IDE1MDAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IElDT05fR0lGX1NFQ09ORFMgPSAyO1xyXG5cclxuZXhwb3J0IGNvbnN0IElDT05fR0lGX0ZQUyA9IDI0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBFRUtfTUFYX1dJRFRIID0gMjAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IExJU1RfVklFV19BTklNQVRJT04gPSB7XHJcbiAgYW5pbWF0ZTogeyBvcGFjaXR5OiAxIH0sXHJcbiAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXHJcbiAgdHJhbnNpdGlvbjogeyBkdXJhdGlvbjogMC4xNSB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEhFSUZfSU1BR0VfRk9STUFUUyA9IG5ldyBTZXQoW1xyXG4gIFwiLmhlaWNcIixcclxuICBcIi5oZWljc1wiLFxyXG4gIFwiLmhlaWZcIixcclxuICBcIi5oZWlmc1wiLFxyXG4gIFwiLmhpZlwiLFxyXG4gIFwiLmF2Y2lcIixcclxuICBcIi5hdmNzXCIsXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRJRkZfSU1BR0VfRk9STUFUUyA9IG5ldyBTZXQoW1xyXG4gIFwiLmNyMlwiLFxyXG4gIFwiLmRuZ1wiLFxyXG4gIFwiLm5lZlwiLFxyXG4gIFwiLnRpZlwiLFxyXG4gIFwiLnRpZmZcIixcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgQ0xJUEJPQVJEX0ZJTEVfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1wiLmpwZWdcIiwgXCIuanBnXCIsIFwiLnBuZ1wiXSk7XHJcblxyXG5leHBvcnQgY29uc3QgTkFUSVZFX0lNQUdFX0ZPUk1BVFMgPSBuZXcgU2V0KFtcclxuICBcIi5hcG5nXCIsXHJcbiAgXCIuYXZpZlwiLFxyXG4gIFwiLmJtcFwiLFxyXG4gIFwiLmdpZlwiLFxyXG4gIFwiLmljb1wiLFxyXG4gIFwiLmpmaWZcIixcclxuICBcIi5qaWZcIixcclxuICBcIi5qcGVcIixcclxuICBcIi5qcGVnXCIsXHJcbiAgXCIuanBnXCIsXHJcbiAgXCIucGpwXCIsXHJcbiAgXCIucGpwZWdcIixcclxuICBcIi5wbmdcIixcclxuICBcIi5zdmdcIixcclxuICBcIi53ZWJwXCIsXHJcbiAgXCIueGJtXCIsXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IElNQUdFX0ZJTEVfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1xyXG4gIC4uLk5BVElWRV9JTUFHRV9GT1JNQVRTLFxyXG4gIC4uLkhFSUZfSU1BR0VfRk9STUFUUyxcclxuICAuLi5USUZGX0lNQUdFX0ZPUk1BVFMsXHJcbiAgXCIuYW5pXCIsXHJcbiAgXCIuY3VyXCIsXHJcbiAgXCIuanhsXCIsXHJcbiAgXCIucW9pXCIsXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1NMSURFU0hPV19FWFRFTlNJT05TID0gbmV3IFNldChbXHJcbiAgLi4uSEVJRl9JTUFHRV9GT1JNQVRTLFxyXG4gIC4uLlRJRkZfSU1BR0VfRk9STUFUUyxcclxuICBcIi5qeGxcIixcclxuICBcIi5xb2lcIixcclxuICBcIi5zdmdcIixcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgVEVYVF9FRElUT1JTID0gW1wiTW9uYWNvRWRpdG9yXCIsIFwiVmltXCJdO1xyXG5cclxuZXhwb3J0IGNvbnN0IENVUlNPUl9GSUxFX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcIi5hbmlcIiwgXCIuY3VyXCJdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBTVU1NQVJJWkFCTEVfRklMRV9FWFRFTlNJT05TID0gbmV3IFNldChbXHJcbiAgXCIuaHRtbFwiLFxyXG4gIFwiLmh0bVwiLFxyXG4gIFwiLndodG1sXCIsXHJcbiAgXCIubWRcIixcclxuICBcIi50eHRcIixcclxuICBcIi5wZGZcIixcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgRURJVEFCTEVfSU1BR0VfRklMRV9FWFRFTlNJT05TID0gbmV3IFNldChbXHJcbiAgXCIuYm1wXCIsXHJcbiAgXCIuZ2lmXCIsXHJcbiAgXCIuaWNvXCIsXHJcbiAgXCIuamZpZlwiLFxyXG4gIFwiLmpwZVwiLFxyXG4gIFwiLmpwZWdcIixcclxuICBcIi5qcGdcIixcclxuICBcIi5wbmdcIixcclxuICBcIi50aWZcIixcclxuICBcIi50aWZmXCIsXHJcbiAgXCIud2VicFwiLFxyXG5dKTtcclxuXHJcbmV4cG9ydCBjb25zdCBNRU5VX1NFUEVSQVRPUiA9IHsgc2VwZXJhdG9yOiB0cnVlIH07XHJcblxyXG5leHBvcnQgY29uc3QgTUlMTElTRUNPTkRTX0lOX1NFQ09ORCA9IDEwMDA7XHJcblxyXG5leHBvcnQgY29uc3QgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMDtcclxuXHJcbmV4cG9ydCBjb25zdCBNSUxMSVNFQ09ORFNfSU5fREFZID0gODY0MDAwMDA7XHJcblxyXG5leHBvcnQgY29uc3QgWklQX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcIi5qc2Rvc1wiLCBcIi5wazNcIiwgXCIud3N6XCIsIFwiLnppcFwiXSk7XHJcblxyXG5leHBvcnQgY29uc3QgTU9VTlRBQkxFX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcIi5pc29cIiwgLi4uWklQX0VYVEVOU0lPTlNdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBNT1VOVEFCTEVfRlNfVFlQRVMgPSBuZXcgU2V0KFtcIkZpbGVTeXN0ZW1BY2Nlc3NcIiwgXCJIVFRQUmVxdWVzdFwiXSk7XHJcblxyXG5leHBvcnQgY29uc3QgU1BSRUFEU0hFRVRfRk9STUFUUyA9IFtcclxuICBcIi5jc3ZcIixcclxuICBcIi5udW1iZXJzXCIsXHJcbiAgXCIub2RzXCIsXHJcbiAgXCIueGxzXCIsXHJcbiAgXCIueGxzeFwiLFxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1QM19NSU1FX1RZUEUgPSBcImF1ZGlvL21wZWdcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBWSURFT19GQUxMQkFDS19NSU1FX1RZUEUgPSBcInZpZGVvL21wNFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5PTl9CUkVBS0lOR19IWVBIRU4gPSBcIlxcdTIwMTFcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBPTkVfVElNRV9QQVNTSVZFX0VWRU5UID0ge1xyXG4gIG9uY2U6IHRydWUsXHJcbiAgcGFzc2l2ZTogdHJ1ZSxcclxufSBhcyBBZGRFdmVudExpc3RlbmVyT3B0aW9ucztcclxuXHJcbmV4cG9ydCBjb25zdCBQUkVWRU5UX1NDUk9MTCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBST0NFU1NfREVMSU1JVEVSID0gXCJfX1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNBVkVfUEFUSCA9IGAke0hPTUV9L1NuYXBzaG90c2A7XHJcblxyXG5leHBvcnQgY29uc3QgUElDVVRSRVNfUEFUSCA9IGAke0hPTUV9L1BpY3R1cmVzYDtcclxuXHJcbmV4cG9ydCBjb25zdCBTSE9SVENVVF9BUFBFTkQgPSBcIiAtIFNob3J0Y3V0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgU0hPUlRDVVRfRVhURU5TSU9OID0gXCIudXJsXCI7XHJcblxyXG5leHBvcnQgY29uc3QgU1lTVEVNX0ZJTEVTID0gbmV3IFNldChbXCJkZXNrdG9wLmluaVwiXSk7XHJcblxyXG5leHBvcnQgY29uc3QgU1lTVEVNX1BBVEhTID0gbmV3IFNldChbXCIvLmRlbGV0ZWRGaWxlcy5sb2dcIl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFU0tUT1BfUEFUSCA9IGAke0hPTUV9L0Rlc2t0b3BgO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNUQVJUX01FTlVfUEFUSCA9IGAke0hPTUV9L1N0YXJ0IE1lbnVgO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFJX1RJVExFID0gXCJUYWxvc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFJX1dJTkRPV19JRCA9IFwiYWktY2hhdC13aW5kb3dcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBTWVNURU1fU0hPUlRDVVRfRElSRUNUT1JJRVMgPSBuZXcgU2V0KFtERVNLVE9QX1BBVEhdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OU19JTl9NSUxMSVNFQ09ORFMgPSB7XHJcbiAgRE9VQkxFX0NMSUNLOiA1MDAsXHJcbiAgTE9OR19QUkVTUzogNTAwLFxyXG4gIE1PVVNFX0lOX09VVDogMzAwLFxyXG4gIFRBU0tCQVJfSVRFTTogNDAwLFxyXG4gIFdJTkRPVzogMjUwLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05TX0lOX1NFQ09ORFMgPSB7XHJcbiAgVEFTS0JBUl9JVEVNOlxyXG4gICAgVFJBTlNJVElPTlNfSU5fTUlMTElTRUNPTkRTLlRBU0tCQVJfSVRFTSAvIE1JTExJU0VDT05EU19JTl9TRUNPTkQsXHJcbiAgV0lORE9XOiBUUkFOU0lUSU9OU19JTl9NSUxMSVNFQ09ORFMuV0lORE9XIC8gTUlMTElTRUNPTkRTX0lOX1NFQ09ORCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBLRVlQUkVTU19ERUJPVU5DRV9NUyA9IDE1MDtcclxuXHJcbmV4cG9ydCBjb25zdCBMT05HX1BSRVNTX0RFTEFZX01TID0gNzUwO1xyXG5cclxuZXhwb3J0IGNvbnN0IE9ORV9EQVlfSU5fTUlMTElTRUNPTkRTID0gODY0MDAwMDA7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9JTlRFUlNFQ1RJT05fT1BUSU9OUzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0ge1xyXG4gIHJvb3RNYXJnaW46IFwiM3B4XCIsXHJcbiAgdGhyZXNob2xkOiAwLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFVRElPX0ZJTEVfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1xyXG4gIFwiLmFhY1wiLFxyXG4gIFwiLmZsYWNcIixcclxuICBcIi5tNGFcIixcclxuICBcIi5vZ2FcIixcclxuICBcIi53YXZcIixcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgQVVESU9fUExBWUxJU1RfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1wiLmFzeFwiLCBcIi5tM3VcIiwgXCIucGxzXCJdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUNPREVEX1ZJREVPX0ZJTEVfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1wiLmF2aVwiLCBcIi5kaXZ4XCJdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBWSURFT19GSUxFX0VYVEVOU0lPTlMgPSBuZXcgU2V0KFtcclxuICBcIi4zZ3BcIixcclxuICBcIi5mNHZcIixcclxuICBcIi5tNHZcIixcclxuICBcIi5ta3ZcIixcclxuICBcIi5tb3ZcIixcclxuICBcIi5tcDRcIixcclxuICBcIi5vZ2dcIixcclxuICBcIi5vZ21cIixcclxuICBcIi5vZ3ZcIixcclxuICBcIi53ZWJtXCIsXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IERZTkFNSUNfUFJFRklYID0gW1wibm9zdHI6XCJdO1xyXG5cclxuZXhwb3J0IGNvbnN0IERZTkFNSUNfRVhURU5TSU9OID0gbmV3IFNldChbXHJcbiAgLi4uQVVESU9fRklMRV9FWFRFTlNJT05TLFxyXG4gIC4uLkFVRElPX1BMQVlMSVNUX0VYVEVOU0lPTlMsXHJcbiAgLi4uSU1BR0VfRklMRV9FWFRFTlNJT05TLFxyXG4gIC4uLlRJRkZfSU1BR0VfRk9STUFUUyxcclxuICAuLi5WSURFT19GSUxFX0VYVEVOU0lPTlMsXHJcbiAgXCIuYW5pXCIsXHJcbiAgXCIuZXhlXCIsXHJcbiAgXCIubXAzXCIsXHJcbiAgXCIuc2F2XCIsXHJcbiAgXCIud2h0bWxcIixcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgU0FWRV9USVRMRV9DSEFSID0gXCJcXHUyNUNGXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUk9PVF9OQU1FID0gXCJNeSBQQ1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNZU1RFTV9QQVRIID0gXCIvU3lzdGVtXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUk9PVF9TSE9SVENVVCA9IGAke1JPT1RfTkFNRX0udXJsYDtcclxuXHJcbmV4cG9ydCBjb25zdCBJQ09OX1BBVEggPSBgJHtTWVNURU1fUEFUSH0vSWNvbnNgO1xyXG5cclxuZXhwb3J0IGNvbnN0IFBIT1RPX0lDT04gPSBgJHtJQ09OX1BBVEh9L3Bob3RvLndlYnBgO1xyXG5cclxuZXhwb3J0IGNvbnN0IFVTRVJfSUNPTl9QQVRIID0gYCR7SE9NRX0vSWNvbnNgO1xyXG5cclxuZXhwb3J0IGNvbnN0IElDT05fQ0FDSEUgPSBgJHtVU0VSX0lDT05fUEFUSH0vQ2FjaGVgO1xyXG5cclxuZXhwb3J0IGNvbnN0IFlUX0lDT05fQ0FDSEUgPSBgJHtJQ09OX0NBQ0hFfS9Zb3VUdWJlYDtcclxuXHJcbmV4cG9ydCBjb25zdCBJQ09OX0NBQ0hFX0VYVEVOU0lPTiA9IFwiLmNhY2hlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgU0VTU0lPTl9GSUxFID0gXCIvc2Vzc2lvbi5qc29uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgU0hPUlRDVVRfSUNPTiA9IGAke0lDT05fUEFUSH0vc2hvcnRjdXQud2VicGA7XHJcblxyXG5leHBvcnQgY29uc3QgRkFWSUNPTl9CQVNFX1BBVEggPSBgL2Zhdmljb24uaWNvP3Y9JHsgIERhdGUubm93KCl9YDtcclxuXHJcbmV4cG9ydCBjb25zdCBGT0xERVJfSUNPTiA9IGAke0lDT05fUEFUSH0vZm9sZGVyLndlYnBgO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZPTERFUl9CQUNLX0lDT04gPSBgJHtJQ09OX1BBVEh9L2ZvbGRlcl9iYWNrLndlYnBgO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZPTERFUl9GUk9OVF9JQ09OID0gYCR7SUNPTl9QQVRIfS9mb2xkZXJfZnJvbnQud2VicGA7XHJcblxyXG5leHBvcnQgY29uc3QgQ09NUFJFU1NFRF9GT0xERVJfSUNPTiA9IGAke0lDT05fUEFUSH0vY29tcHJlc3NlZC53ZWJwYDtcclxuXHJcbmV4cG9ydCBjb25zdCBNT1VOVEVEX0ZPTERFUl9JQ09OID0gYCR7SUNPTl9QQVRIfS9tb3VudGVkLndlYnBgO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5FV19GT0xERVJfSUNPTiA9IGAke0lDT05fUEFUSH0vbmV3X2ZvbGRlci53ZWJwYDtcclxuXHJcbmV4cG9ydCBjb25zdCBVTktOT1dOX0lDT05fUEFUSCA9IGAke0lDT05fUEFUSH0vdW5rbm93bi53ZWJwYDtcclxuXHJcbmV4cG9ydCBjb25zdCBUSU1FU1RBTVBfREFURV9GT1JNQVQ6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zID0ge1xyXG4gIGRheTogXCIyLWRpZ2l0XCIsXHJcbiAgaG91cjogXCIyLWRpZ2l0XCIsXHJcbiAgaG91cjEyOiBmYWxzZSxcclxuICBtaW51dGU6IFwiMi1kaWdpdFwiLFxyXG4gIG1vbnRoOiBcIjItZGlnaXRcIixcclxuICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxyXG4gIHllYXI6IFwibnVtZXJpY1wiLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IElDT05fUkVTX01BUDogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcclxuICA2NDogOTYsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgTUFYX1JFU19JQ09OX09WRVJSSURFOiBSZWNvcmQ8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiA9IHtcclxuICBkZXNrdG9wOiBbMTYsIDMyXSxcclxuICBkb2N1bWVudDogWzE2LCAzMl0sXHJcbiAgZm9sZGVyOiBbMTYsIDE2XSxcclxuICBtb3VudGVkOiBbMTYsIDE2XSxcclxuICBtdXNpYzogWzE2LCAzMl0sXHJcbiAgcGM6IFsxNiwgMTZdLFxyXG4gIHBpY3R1cmVzOiBbMTYsIDMyXSxcclxuICB1c2VyOiBbMTYsIDE2XSxcclxuICB2aWRlb3M6IFsxNiwgMzJdLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9JQ09OX1BJWEVMX1JBVElPUyA9IFszLCAyLCAxXTtcclxuXHJcbmV4cG9ydCBjb25zdCBTVVBQT1JURURfSUNPTl9TSVpFUyA9IFsxNiwgMzIsIDQ4LCA5NiwgMTQ0XTtcclxuXHJcbmV4cG9ydCBjb25zdCBNQVhfSUNPTl9TSVpFID0gMTQ0O1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9USFVNQk5BSUxfRklMRV9TSVpFID0gMTA0ODU3NjsgLy8gMSBNQlxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVYVF9GSUxFX1NBVkVfUEFUSCA9IGAke0RFU0tUT1BfUEFUSH0vVW50aXRsZWQudHh0YDtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NDUk9MTEJBUl9XSURUSCA9IDE3O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRBU0tCQVJfSEVJR0hUID0gMzA7XHJcblxyXG5leHBvcnQgY29uc3QgUEFDS0FHRV9EQVRBID0ge1xyXG4gIGFsaWFzOiBcIk1pZ3VlbCBQb3J0Zm9saW9cIixcclxuICBhdXRob3I6IHtcclxuICAgIGVtYWlsOiBcImR1c3RpbmJyZXR0QGdtYWlsLmNvbVwiLFxyXG4gICAgbmFtZTogXCJEdXN0aW4gQnJldHRcIixcclxuICAgIG5wdWI6IFwibnB1YjEwdWM3aGc2d2R4aGhkN2VlOHg5YzVscjlkMHV4NzI3MnJ2Mm0wbWMwM2RzNTRxN3F1eGpzczAycjNwXCIsXHJcbiAgICB1cmw6IFwiaHR0cHM6Ly9kdXN0aW5icmV0dC5jb21cIixcclxuICB9LFxyXG4gIGRlc2NyaXB0aW9uOiBcIkRlc2t0b3AgZW52aXJvbm1lbnQgaW4gdGhlIGJyb3dzZXJcIixcclxuICBsaWNlbnNlOiBcIk1JVFwiLFxyXG4gIHZlcnNpb246IFwiMi4wLjBcIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBCQVNFX1pJUF9DT05GSUc6IEFzeW5jWmlwT3B0aW9ucyA9IHtcclxuICBjb25zdW1lOiB0cnVlLFxyXG4gIGxldmVsOiAwLFxyXG4gIG1lbTogOCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBISUdIX1BSSU9SSVRZX1JFUVVFU1QgPSB7IHByaW9yaXR5OiBcImhpZ2hcIiB9IGFzIFJlcXVlc3RJbml0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEhJR0hfUFJJT1JJVFlfRUxFTUVOVCA9IHtcclxuICBmZXRjaFByaW9yaXR5OiBcImhpZ2hcIixcclxufSBhcyBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MRWxlbWVudD47XHJcblxyXG5leHBvcnQgY29uc3QgRElTQkFMRV9BVVRPX0lOUFVUX0ZFQVRVUkVTID0ge1xyXG4gIGF1dG9DYXBpdGFsaXplOiBcIm9mZlwiLFxyXG4gIGF1dG9Db21wbGV0ZTogXCJvZmZcIixcclxuICBhdXRvQ29ycmVjdDogXCJvZmZcIixcclxuICBzcGVsbENoZWNrOiBmYWxzZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBNQVhfWklOREVYID0gMjE0NzQ4MzY0NztcclxuIl0sIm5hbWVzIjpbIkJBU0VfMkRfQ09OVEVYVF9PUFRJT05TIiwiYWxwaGEiLCJkZXN5bmNocm9uaXplZCIsIklGUkFNRV9DT05GSUciLCJyZWZlcnJlclBvbGljeSIsInNhbmRib3giLCJERUZBVUxUX0xPQ0FMRSIsIkRFRkFVTFRfQVNDRU5ESU5HIiwiREVGQVVMVF9DTE9DS19TT1VSQ0UiLCJERUZBVUxUX1RIRU1FIiwiREVGQVVMVF9XQUxMUEFQRVIiLCJERUZBVUxUX1dBTExQQVBFUl9GSVQiLCJUSElOX1NDUk9MTEJBUl9XSURUSCIsIlRISU5fU0NST0xMQkFSX1dJRFRIX05PTl9XRUJLSVQiLCJDTE9DS19DQU5WQVNfQkFTRV9XSURUSCIsIlNNQUxMRVNUX1BOR19TSVpFIiwiREVGQVVMVF9XSU5ET1dfU0laRSIsImhlaWdodCIsIndpZHRoIiwiREVGQVVMVF9NQVBQRURfTkFNRSIsIkZPQ1VTQUJMRV9FTEVNRU5UIiwidGFiSW5kZXgiLCJESVZfQlVUVE9OX1BST1BTIiwiYXMiLCJyb2xlIiwiRlNfSEFORExFUyIsIkhPTUUiLCJQSUNUVVJFU19GT0xERVIiLCJWSURFT1NfRk9MREVSIiwiSU5ERVhfRklMRSIsIlBST01QVF9GSUxFIiwiU0xJREVTSE9XX0ZJTEUiLCJTTElERVNIT1dfVElNRU9VVF9JTl9NSUxMSVNFQ09ORFMiLCJJQ09OX0dJRl9TRUNPTkRTIiwiSUNPTl9HSUZfRlBTIiwiUEVFS19NQVhfV0lEVEgiLCJMSVNUX1ZJRVdfQU5JTUFUSU9OIiwiYW5pbWF0ZSIsIm9wYWNpdHkiLCJpbml0aWFsIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiSEVJRl9JTUFHRV9GT1JNQVRTIiwiU2V0IiwiVElGRl9JTUFHRV9GT1JNQVRTIiwiQ0xJUEJPQVJEX0ZJTEVfRVhURU5TSU9OUyIsIk5BVElWRV9JTUFHRV9GT1JNQVRTIiwiSU1BR0VfRklMRV9FWFRFTlNJT05TIiwiVU5TVVBQT1JURURfU0xJREVTSE9XX0VYVEVOU0lPTlMiLCJURVhUX0VESVRPUlMiLCJDVVJTT1JfRklMRV9FWFRFTlNJT05TIiwiU1VNTUFSSVpBQkxFX0ZJTEVfRVhURU5TSU9OUyIsIkVESVRBQkxFX0lNQUdFX0ZJTEVfRVhURU5TSU9OUyIsIk1FTlVfU0VQRVJBVE9SIiwic2VwZXJhdG9yIiwiTUlMTElTRUNPTkRTX0lOX1NFQ09ORCIsIk1JTExJU0VDT05EU19JTl9NSU5VVEUiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiIsIk1JTExJU0VDT05EU19JTl9EQVkiLCJaSVBfRVhURU5TSU9OUyIsIk1PVU5UQUJMRV9FWFRFTlNJT05TIiwiTU9VTlRBQkxFX0ZTX1RZUEVTIiwiU1BSRUFEU0hFRVRfRk9STUFUUyIsIk1QM19NSU1FX1RZUEUiLCJWSURFT19GQUxMQkFDS19NSU1FX1RZUEUiLCJOT05fQlJFQUtJTkdfSFlQSEVOIiwiT05FX1RJTUVfUEFTU0lWRV9FVkVOVCIsIm9uY2UiLCJwYXNzaXZlIiwiUFJFVkVOVF9TQ1JPTEwiLCJwcmV2ZW50U2Nyb2xsIiwiUFJPQ0VTU19ERUxJTUlURVIiLCJTQVZFX1BBVEgiLCJQSUNVVFJFU19QQVRIIiwiU0hPUlRDVVRfQVBQRU5EIiwiU0hPUlRDVVRfRVhURU5TSU9OIiwiU1lTVEVNX0ZJTEVTIiwiU1lTVEVNX1BBVEhTIiwiREVTS1RPUF9QQVRIIiwiU1RBUlRfTUVOVV9QQVRIIiwiQUlfVElUTEUiLCJBSV9XSU5ET1dfSUQiLCJTWVNURU1fU0hPUlRDVVRfRElSRUNUT1JJRVMiLCJUUkFOU0lUSU9OU19JTl9NSUxMSVNFQ09ORFMiLCJET1VCTEVfQ0xJQ0siLCJMT05HX1BSRVNTIiwiTU9VU0VfSU5fT1VUIiwiVEFTS0JBUl9JVEVNIiwiV0lORE9XIiwiVFJBTlNJVElPTlNfSU5fU0VDT05EUyIsIktFWVBSRVNTX0RFQk9VTkNFX01TIiwiTE9OR19QUkVTU19ERUxBWV9NUyIsIk9ORV9EQVlfSU5fTUlMTElTRUNPTkRTIiwiREVGQVVMVF9JTlRFUlNFQ1RJT05fT1BUSU9OUyIsInJvb3RNYXJnaW4iLCJ0aHJlc2hvbGQiLCJBVURJT19GSUxFX0VYVEVOU0lPTlMiLCJBVURJT19QTEFZTElTVF9FWFRFTlNJT05TIiwiREVDT0RFRF9WSURFT19GSUxFX0VYVEVOU0lPTlMiLCJWSURFT19GSUxFX0VYVEVOU0lPTlMiLCJEWU5BTUlDX1BSRUZJWCIsIkRZTkFNSUNfRVhURU5TSU9OIiwiU0FWRV9USVRMRV9DSEFSIiwiUk9PVF9OQU1FIiwiU1lTVEVNX1BBVEgiLCJST09UX1NIT1JUQ1VUIiwiSUNPTl9QQVRIIiwiUEhPVE9fSUNPTiIsIlVTRVJfSUNPTl9QQVRIIiwiSUNPTl9DQUNIRSIsIllUX0lDT05fQ0FDSEUiLCJJQ09OX0NBQ0hFX0VYVEVOU0lPTiIsIlNFU1NJT05fRklMRSIsIlNIT1JUQ1VUX0lDT04iLCJGQVZJQ09OX0JBU0VfUEFUSCIsIkRhdGUiLCJub3ciLCJGT0xERVJfSUNPTiIsIkZPTERFUl9CQUNLX0lDT04iLCJGT0xERVJfRlJPTlRfSUNPTiIsIkNPTVBSRVNTRURfRk9MREVSX0lDT04iLCJNT1VOVEVEX0ZPTERFUl9JQ09OIiwiTkVXX0ZPTERFUl9JQ09OIiwiVU5LTk9XTl9JQ09OX1BBVEgiLCJUSU1FU1RBTVBfREFURV9GT1JNQVQiLCJkYXkiLCJob3VyIiwiaG91cjEyIiwibWludXRlIiwibW9udGgiLCJzZWNvbmQiLCJ5ZWFyIiwiSUNPTl9SRVNfTUFQIiwiTUFYX1JFU19JQ09OX09WRVJSSURFIiwiZGVza3RvcCIsImRvY3VtZW50IiwiZm9sZGVyIiwibW91bnRlZCIsIm11c2ljIiwicGMiLCJwaWN0dXJlcyIsInVzZXIiLCJ2aWRlb3MiLCJTVVBQT1JURURfSUNPTl9QSVhFTF9SQVRJT1MiLCJTVVBQT1JURURfSUNPTl9TSVpFUyIsIk1BWF9JQ09OX1NJWkUiLCJNQVhfVEhVTUJOQUlMX0ZJTEVfU0laRSIsIkRFRkFVTFRfVEVYVF9GSUxFX1NBVkVfUEFUSCIsIkRFRkFVTFRfU0NST0xMQkFSX1dJRFRIIiwiVEFTS0JBUl9IRUlHSFQiLCJQQUNLQUdFX0RBVEEiLCJhbGlhcyIsImF1dGhvciIsImVtYWlsIiwibmFtZSIsIm5wdWIiLCJ1cmwiLCJkZXNjcmlwdGlvbiIsImxpY2Vuc2UiLCJ2ZXJzaW9uIiwiQkFTRV9aSVBfQ09ORklHIiwiY29uc3VtZSIsImxldmVsIiwibWVtIiwiSElHSF9QUklPUklUWV9SRVFVRVNUIiwicHJpb3JpdHkiLCJISUdIX1BSSU9SSVRZX0VMRU1FTlQiLCJmZXRjaFByaW9yaXR5IiwiRElTQkFMRV9BVVRPX0lOUFVUX0ZFQVRVUkVTIiwiYXV0b0NhcGl0YWxpemUiLCJhdXRvQ29tcGxldGUiLCJhdXRvQ29ycmVjdCIsInNwZWxsQ2hlY2siLCJNQVhfWklOREVYIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/constants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./utils/functions.ts":
/*!****************************!*\
  !*** ./utils/functions.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GOOGLE_SEARCH_QUERY: () => (/* binding */ GOOGLE_SEARCH_QUERY),\n/* harmony export */   LOCAL_HOST: () => (/* binding */ LOCAL_HOST),\n/* harmony export */   blobToBase64: () => (/* binding */ blobToBase64),\n/* harmony export */   blobToBuffer: () => (/* binding */ blobToBuffer),\n/* harmony export */   bufferToBlob: () => (/* binding */ bufferToBlob),\n/* harmony export */   bufferToUrl: () => (/* binding */ bufferToUrl),\n/* harmony export */   calcInitialPosition: () => (/* binding */ calcInitialPosition),\n/* harmony export */   canvasToBuffer: () => (/* binding */ canvasToBuffer),\n/* harmony export */   cleanUpBufferUrl: () => (/* binding */ cleanUpBufferUrl),\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   createFallbackSrcSet: () => (/* binding */ createFallbackSrcSet),\n/* harmony export */   createOffscreenCanvas: () => (/* binding */ createOffscreenCanvas),\n/* harmony export */   displayVersion: () => (/* binding */ displayVersion),\n/* harmony export */   fetchBlob: () => (/* binding */ fetchBlob),\n/* harmony export */   generatePrettyTimestamp: () => (/* binding */ generatePrettyTimestamp),\n/* harmony export */   getDpi: () => (/* binding */ getDpi),\n/* harmony export */   getExtension: () => (/* binding */ getExtension),\n/* harmony export */   getFormattedSize: () => (/* binding */ getFormattedSize),\n/* harmony export */   getGifJs: () => (/* binding */ getGifJs),\n/* harmony export */   getHtmlToImage: () => (/* binding */ getHtmlToImage),\n/* harmony export */   getIteratedNames: () => (/* binding */ getIteratedNames),\n/* harmony export */   getMimeType: () => (/* binding */ getMimeType),\n/* harmony export */   getSearchParam: () => (/* binding */ getSearchParam),\n/* harmony export */   getTZOffsetISOString: () => (/* binding */ getTZOffsetISOString),\n/* harmony export */   getUrlOrSearch: () => (/* binding */ getUrlOrSearch),\n/* harmony export */   getWindowViewport: () => (/* binding */ getWindowViewport),\n/* harmony export */   getYouTubeUrlId: () => (/* binding */ getYouTubeUrlId),\n/* harmony export */   haltEvent: () => (/* binding */ haltEvent),\n/* harmony export */   hasFinePointer: () => (/* binding */ hasFinePointer),\n/* harmony export */   imageSrc: () => (/* binding */ imageSrc),\n/* harmony export */   imageSrcs: () => (/* binding */ imageSrcs),\n/* harmony export */   imgDataToBuffer: () => (/* binding */ imgDataToBuffer),\n/* harmony export */   isBeforeBg: () => (/* binding */ isBeforeBg),\n/* harmony export */   isCanvasDrawn: () => (/* binding */ isCanvasDrawn),\n/* harmony export */   isDev: () => (/* binding */ isDev),\n/* harmony export */   isDynamicIcon: () => (/* binding */ isDynamicIcon),\n/* harmony export */   isFileSystemMappingSupported: () => (/* binding */ isFileSystemMappingSupported),\n/* harmony export */   isFirefox: () => (/* binding */ isFirefox),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isYouTubeUrl: () => (/* binding */ isYouTubeUrl),\n/* harmony export */   jsonFetch: () => (/* binding */ jsonFetch),\n/* harmony export */   label: () => (/* binding */ label),\n/* harmony export */   loadFiles: () => (/* binding */ loadFiles),\n/* harmony export */   maybeRequestIdleCallback: () => (/* binding */ maybeRequestIdleCallback),\n/* harmony export */   notFound: () => (/* binding */ notFound),\n/* harmony export */   parseBgPosition: () => (/* binding */ parseBgPosition),\n/* harmony export */   preloadImage: () => (/* binding */ preloadImage),\n/* harmony export */   preloadLibs: () => (/* binding */ preloadLibs),\n/* harmony export */   pxToNum: () => (/* binding */ pxToNum),\n/* harmony export */   resizeImage: () => (/* binding */ resizeImage),\n/* harmony export */   saveUnpositionedDesktopIcons: () => (/* binding */ saveUnpositionedDesktopIcons),\n/* harmony export */   sendMouseClick: () => (/* binding */ sendMouseClick),\n/* harmony export */   shouldCaptureDragImage: () => (/* binding */ shouldCaptureDragImage),\n/* harmony export */   supportsWebp: () => (/* binding */ supportsWebp),\n/* harmony export */   toSorted: () => (/* binding */ toSorted),\n/* harmony export */   toggleShowDesktop: () => (/* binding */ toggleShowDesktop),\n/* harmony export */   trimCanvasToTopLeft: () => (/* binding */ trimCanvasToTopLeft),\n/* harmony export */   updateIconPositions: () => (/* binding */ updateIconPositions),\n/* harmony export */   updateIconPositionsIfEmpty: () => (/* binding */ updateIconPositionsIfEmpty),\n/* harmony export */   viewHeight: () => (/* binding */ viewHeight),\n/* harmony export */   viewWidth: () => (/* binding */ viewWidth)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nconst bufferToBlob = (buffer, type)=>new Blob([\n        buffer\n    ], type ? {\n        type\n    } : undefined);\nconst bufferToUrl = (buffer, mimeType)=>mimeType === \"image/svg+xml\" ? `data:${mimeType};base64,${window.btoa(buffer.toString())}` : URL.createObjectURL(bufferToBlob(buffer, mimeType));\nconst RESIZE_IMAGE_TIMEOUT_SECONDS = 60;\nconst resizeImage = async (blob, maxDimension)=>new Promise((resolve)=>{\n        const worker = new Worker(__webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"Resize Image Worker\"), __webpack_require__.b)), {\n            name: \"Resize Image Worker\"\n        });\n        const timeoutHandle = setTimeout(()=>{\n            resolve(blob);\n            worker.terminate();\n        }, RESIZE_IMAGE_TIMEOUT_SECONDS * utils_constants__WEBPACK_IMPORTED_MODULE_1__.MILLISECONDS_IN_SECOND);\n        const canvas = document.createElement(\"canvas\").transferControlToOffscreen();\n        worker.addEventListener(\"message\", ({ data })=>{\n            clearTimeout(timeoutHandle);\n            resolve(data instanceof Blob ? data : blob);\n            worker.terminate();\n        });\n        worker.postMessage({\n            blob,\n            canvas,\n            maxDimension\n        }, [\n            canvas\n        ]);\n    });\nlet dpi;\nconst getDpi = ()=>{\n    if (typeof dpi === \"number\") return dpi;\n    dpi = Math.min(Math.ceil(window.devicePixelRatio), 3);\n    return dpi;\n};\nconst getExtension = (url)=>{\n    let ext = (0,path__WEBPACK_IMPORTED_MODULE_0__.extname)(url);\n    if (!ext) {\n        const baseName = (0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(url);\n        if (baseName.startsWith(\".\")) ext = baseName;\n    }\n    return ext.toLowerCase();\n};\nconst sendMouseClick = (target, count = 1)=>{\n    if (count === 0) return;\n    target.dispatchEvent(new MouseEvent(\"click\", {\n        bubbles: true\n    }));\n    sendMouseClick(target, count - 1);\n};\nlet visibleWindows = [];\nconst toggleShowDesktop = (processes, stackOrder, minimize)=>{\n    const restoreWindows = stackOrder.length > 0 && !stackOrder.some((pid)=>!processes[pid]?.minimized);\n    const allWindows = restoreWindows ? [\n        ...stackOrder\n    ].reverse() : stackOrder;\n    if (!restoreWindows) visibleWindows = [];\n    else if (visibleWindows.length === 0) visibleWindows = allWindows;\n    allWindows.forEach((pid)=>{\n        if (restoreWindows) {\n            if (visibleWindows.includes(pid)) minimize(pid);\n        } else if (!processes[pid]?.minimized) {\n            visibleWindows.push(pid);\n            minimize(pid);\n        }\n    });\n    if (restoreWindows) {\n        requestAnimationFrame(()=>processes[stackOrder[0]]?.componentWindow?.focus(utils_constants__WEBPACK_IMPORTED_MODULE_1__.PREVENT_SCROLL));\n    }\n};\nconst imageSrc = (imagePath, size, ratio, extension)=>{\n    const imageName = (0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(imagePath, extension);\n    const [expectedSize, maxIconSize] = utils_constants__WEBPACK_IMPORTED_MODULE_1__.MAX_RES_ICON_OVERRIDE[imageName] || [];\n    const ratioSize = size * ratio;\n    const imageSize = Math.min(utils_constants__WEBPACK_IMPORTED_MODULE_1__.MAX_ICON_SIZE, expectedSize === size ? Math.min(maxIconSize, ratioSize) : ratioSize);\n    return `${(0,path__WEBPACK_IMPORTED_MODULE_0__.join)((0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(imagePath), `${utils_constants__WEBPACK_IMPORTED_MODULE_1__.ICON_RES_MAP[imageSize] || imageSize}x${utils_constants__WEBPACK_IMPORTED_MODULE_1__.ICON_RES_MAP[imageSize] || imageSize}`, `${imageName}${extension}`).replace(/\\\\/g, \"/\")}${ratio > 1 ? ` ${ratio}x` : \"\"}`;\n};\nconst imageSrcs = (imagePath, size, extension, failedUrls = [])=>{\n    const srcs = [\n        imageSrc(imagePath, size, 1, extension),\n        imageSrc(imagePath, size, 2, extension),\n        imageSrc(imagePath, size, 3, extension)\n    ].filter((url)=>failedUrls.length === 0 || failedUrls.includes(url.split(\" \")[0])).join(\", \");\n    return failedUrls?.includes(srcs) ? \"\" : srcs;\n};\nconst createFallbackSrcSet = (src, failedUrls)=>{\n    const srcExt = getExtension(src);\n    const failedSizes = new Set(new Set(failedUrls.map((failedUrl)=>{\n        const fileName = (0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(src, srcExt);\n        return Number(failedUrl.replace(`${utils_constants__WEBPACK_IMPORTED_MODULE_1__.ICON_PATH}/`, \"\").replace(`${utils_constants__WEBPACK_IMPORTED_MODULE_1__.USER_ICON_PATH}/`, \"\").replace(`/${fileName}.png`, \"\").replace(`/${fileName}.webp`, \"\").split(\"x\")[0]);\n    })));\n    const possibleSizes = utils_constants__WEBPACK_IMPORTED_MODULE_1__.SUPPORTED_ICON_SIZES.filter((size)=>!failedSizes.has(size));\n    return possibleSizes.map((size)=>imageSrc(src, size, 1, srcExt)).reverse().join(\", \");\n};\nconst blobToBase64 = (blob)=>new Promise((resolve)=>{\n        const fileReader = new FileReader();\n        fileReader.readAsDataURL(blob);\n        fileReader.onloadend = ()=>resolve(fileReader.result);\n    });\nconst blobToBuffer = async (blob)=>blob ? Buffer.from(await blob.arrayBuffer()) : Buffer.from(\"\");\nconst fetchBlob = async (url)=>(await fetch(url)).blob();\nconst canvasToBuffer = (canvas)=>Buffer.from(canvas?.toDataURL(\"image/png\").replace(\"data:image/png;base64,\", \"\") || \"\", \"base64\");\nconst imgDataToBuffer = (imageData)=>{\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = imageData.width;\n    canvas.height = imageData.height;\n    canvas.getContext(\"2d\")?.putImageData(imageData, 0, 0);\n    return canvasToBuffer(canvas);\n};\nconst cleanUpBufferUrl = (url)=>URL.revokeObjectURL(url);\nconst rowBlank = (imageData, width, y)=>{\n    for(let x = 0; x < width; ++x){\n        if (imageData.data[y * width * 4 + x * 4 + 3] !== 0) return false;\n    }\n    return true;\n};\nconst columnBlank = (imageData, width, x, top, bottom)=>{\n    for(let y = top; y < bottom; ++y){\n        if (imageData.data[y * width * 4 + x * 4 + 3] !== 0) return false;\n    }\n    return true;\n};\nconst trimCanvasToTopLeft = (canvas)=>{\n    const ctx = canvas.getContext(\"2d\", {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: true\n    });\n    if (!ctx) return canvas;\n    const { height, ownerDocument, width } = canvas;\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const { height: bottom, width: right } = imageData;\n    let top = 0;\n    let left = 0;\n    while(top < bottom && rowBlank(imageData, width, top))++top;\n    while(left < right && columnBlank(imageData, width, left, top, bottom)){\n        ++left;\n    }\n    const trimmed = ctx.getImageData(left, top, right - left, bottom - top);\n    const copy = ownerDocument.createElement(\"canvas\");\n    const copyCtx = copy.getContext(\"2d\");\n    if (!copyCtx) return canvas;\n    copy.width = trimmed.width;\n    copy.height = trimmed.height;\n    copyCtx.putImageData(trimmed, 0, 0);\n    return copy;\n};\nconst loadScript = (src, defer, force, asModule, contentWindow = window)=>new Promise((resolve, reject)=>{\n        const loadedScripts = [\n            ...contentWindow.document.scripts\n        ];\n        const currentScript = loadedScripts.find((loadedScript)=>loadedScript.src.endsWith(src));\n        if (currentScript) {\n            if (!force) {\n                resolve(new Event(\"Already loaded.\"));\n                return;\n            }\n            currentScript.remove();\n        }\n        const script = contentWindow.document.createElement(\"script\");\n        script.async = false;\n        if (defer) script.defer = true;\n        if (asModule) script.type = \"module\";\n        script.fetchPriority = \"high\";\n        script.src = src;\n        script.addEventListener(\"error\", reject, utils_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_TIME_PASSIVE_EVENT);\n        script.addEventListener(\"load\", resolve, utils_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_TIME_PASSIVE_EVENT);\n        contentWindow.document.head.append(script);\n    });\nconst loadStyle = (href, contentWindow = window)=>new Promise((resolve, reject)=>{\n        const loadedStyles = [\n            ...contentWindow.document.querySelectorAll(\"link[rel=stylesheet]\")\n        ];\n        if (loadedStyles.some((loadedStyle)=>loadedStyle.href.endsWith(href))) {\n            resolve(new Event(\"Already loaded.\"));\n            return;\n        }\n        const link = contentWindow.document.createElement(\"link\");\n        link.rel = \"stylesheet\";\n        link.fetchPriority = \"high\";\n        link.href = href;\n        link.addEventListener(\"error\", reject, utils_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_TIME_PASSIVE_EVENT);\n        link.addEventListener(\"load\", resolve, utils_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_TIME_PASSIVE_EVENT);\n        contentWindow.document.head.append(link);\n    });\nconst loadFiles = async (files, defer, force, asModule, contentWindow)=>!files || files.length === 0 ? Promise.resolve() : files.reduce(async (_promise, file)=>{\n        await (getExtension(file) === \".css\" ? loadStyle(encodeURI(file), contentWindow) : loadScript(encodeURI(file), defer, force, asModule, contentWindow));\n    }, Promise.resolve());\nconst getHtmlToImage = async ()=>{\n    await loadFiles([\n        \"/System/html-to-image/html-to-image.js\"\n    ]);\n    const { htmlToImage } = window;\n    return htmlToImage;\n};\nconst pxToNum = (value = 0)=>typeof value === \"number\" ? value : Number.parseFloat(value);\nconst viewHeight = ()=>window.innerHeight;\nconst viewWidth = ()=>window.innerWidth;\nconst getWindowViewport = ()=>({\n        x: viewWidth(),\n        y: viewHeight() - utils_constants__WEBPACK_IMPORTED_MODULE_1__.TASKBAR_HEIGHT\n    });\nconst calcInitialPosition = ({ offsetHeight }, { right = 0, left = 0, top = 0, bottom = 0 } = {}, { width = 0, height = 0 } = {})=>{\n    const [vh, vw] = [\n        viewHeight(),\n        viewWidth()\n    ];\n    return {\n        x: pxToNum(width) >= vw ? 0 : left || vw - right,\n        y: pxToNum(height) + utils_constants__WEBPACK_IMPORTED_MODULE_1__.TASKBAR_HEIGHT >= vh ? 0 : top || vh - bottom - offsetHeight\n    };\n};\nconst GRID_TEMPLATE_ROWS = \"grid-template-rows\";\nconst calcGridDropPosition = (gridElement, { x = 0, y = 0 })=>{\n    if (!gridElement) return Object.create(null);\n    const gridComputedStyle = window.getComputedStyle(gridElement);\n    const gridTemplateRows = gridComputedStyle.getPropertyValue(GRID_TEMPLATE_ROWS).split(\" \");\n    const gridTemplateColumns = gridComputedStyle.getPropertyValue(\"grid-template-columns\").split(\" \");\n    const gridRowHeight = pxToNum(gridTemplateRows[0]);\n    const gridColumnWidth = pxToNum(gridTemplateColumns[0]);\n    const gridColumnGap = pxToNum(gridComputedStyle.getPropertyValue(\"grid-column-gap\"));\n    const gridRowGap = pxToNum(gridComputedStyle.getPropertyValue(\"grid-row-gap\"));\n    const paddingTop = pxToNum(gridComputedStyle.getPropertyValue(\"padding-top\"));\n    return {\n        gridColumnStart: Math.min(Math.ceil(x / (gridColumnWidth + gridColumnGap)), gridTemplateColumns.length),\n        gridRowStart: Math.min(Math.ceil((y - paddingTop) / (gridRowHeight + gridRowGap)), gridTemplateRows.length)\n    };\n};\nconst saveUnpositionedDesktopIcons = (setIconPositions)=>{\n    const desktopIconGrid = document.querySelector(\"main > ol\");\n    if (desktopIconGrid instanceof HTMLOListElement) {\n        const unPositionedIcons = [\n            ...desktopIconGrid.querySelectorAll(\"li\")\n        ].filter(({ style: { gridRowStart, gridColumnStart } })=>!gridRowStart || !gridColumnStart);\n        if (unPositionedIcons.length > 0) {\n            const { columnGap, gridTemplateColumns, gridTemplateRows, paddingTop, rowGap } = window.getComputedStyle(desktopIconGrid);\n            const [entryWidth] = gridTemplateColumns.split(\" \");\n            const [entryHeight] = gridTemplateRows.split(\" \");\n            const height = pxToNum(entryHeight) + pxToNum(rowGap);\n            const width = pxToNum(entryWidth) + pxToNum(columnGap);\n            const rowTopPadding = pxToNum(paddingTop);\n            const newIconPositions = Object.fromEntries(unPositionedIcons.map((icon)=>{\n                const { top, left } = icon.getBoundingClientRect() || {};\n                const button = icon.querySelector(\"button\");\n                let name = button?.getAttribute(\"aria-label\") || button?.textContent;\n                if (button?.querySelector(\"img[src*=shortcut]\")) {\n                    name = `${name}${utils_constants__WEBPACK_IMPORTED_MODULE_1__.SHORTCUT_EXTENSION}`;\n                }\n                return [\n                    name ? (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(utils_constants__WEBPACK_IMPORTED_MODULE_1__.DESKTOP_PATH, name) : \"\",\n                    {\n                        gridColumnStart: Math.round(left / width) + 1,\n                        gridRowStart: Math.round((top - rowTopPadding) / height) + 1\n                    }\n                ];\n            }));\n            setIconPositions((currentIconPositions)=>({\n                    ...currentIconPositions,\n                    ...newIconPositions\n                }));\n        }\n    }\n};\nconst updateIconPositionsIfEmpty = (url, gridElement, iconPositions, sortOrders)=>{\n    if (!gridElement) return iconPositions;\n    const [fileOrder = []] = sortOrders[url] || [];\n    const newIconPositions = {};\n    const gridComputedStyle = window.getComputedStyle(gridElement);\n    const gridTemplateRowCount = gridComputedStyle.getPropertyValue(GRID_TEMPLATE_ROWS).split(\" \").length;\n    fileOrder.forEach((entry, index)=>{\n        const entryUrl = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(url, entry);\n        if (!iconPositions[entryUrl]) {\n            let gridEntry;\n            try {\n                gridEntry = [\n                    ...gridElement.children\n                ].find((element)=>element.querySelector(`button[aria-label=\"${CSS.escape(entry.replace(utils_constants__WEBPACK_IMPORTED_MODULE_1__.SHORTCUT_EXTENSION, \"\"))}\"]`));\n            } catch  {\n            // Ignore error getting element\n            }\n            if (gridEntry instanceof HTMLElement) {\n                const { x, y, height, width } = gridEntry.getBoundingClientRect();\n                newIconPositions[entryUrl] = calcGridDropPosition(gridElement, {\n                    x: x + width / 2,\n                    y: y + height / 2\n                });\n            } else {\n                const position = index + 1;\n                const gridColumnStart = Math.ceil(position / gridTemplateRowCount);\n                const gridRowStart = position - gridTemplateRowCount * (gridColumnStart - 1);\n                newIconPositions[entryUrl] = {\n                    gridColumnStart,\n                    gridRowStart\n                };\n            }\n        }\n    });\n    return Object.keys(newIconPositions).length > 0 ? {\n        ...newIconPositions,\n        ...iconPositions\n    } : iconPositions;\n};\nconst calcGridPositionOffset = (url, targetUrl, currentIconPositions, gridDropPosition, [, ...draggedEntries], gridElement)=>{\n    if (currentIconPositions[url] && currentIconPositions[targetUrl]) {\n        return {\n            gridColumnStart: currentIconPositions[url].gridColumnStart + (gridDropPosition.gridColumnStart - currentIconPositions[targetUrl].gridColumnStart),\n            gridRowStart: currentIconPositions[url].gridRowStart + (gridDropPosition.gridRowStart - currentIconPositions[targetUrl].gridRowStart)\n        };\n    }\n    const gridComputedStyle = window.getComputedStyle(gridElement);\n    const gridTemplateRowCount = gridComputedStyle.getPropertyValue(GRID_TEMPLATE_ROWS).split(\" \").length;\n    const { gridColumnStart: targetGridColumnStart, gridRowStart: targetGridRowStart } = gridDropPosition;\n    const gridRowStart = targetGridRowStart + draggedEntries.indexOf((0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(url)) + 1;\n    return gridRowStart > gridTemplateRowCount ? {\n        gridColumnStart: targetGridColumnStart + Math.ceil(gridRowStart / gridTemplateRowCount) - 1,\n        gridRowStart: gridRowStart % gridTemplateRowCount || gridTemplateRowCount\n    } : {\n        gridColumnStart: targetGridColumnStart,\n        gridRowStart\n    };\n};\nconst getIteratedNames = (fileEntries, directory, iconPositions, exists)=>Promise.all(fileEntries.map(async (fileEntry)=>{\n        let entryIteration = `${directory}/${fileEntry}`;\n        if (!iconPositions[entryIteration] || !await exists(entryIteration)) {\n            return fileEntry;\n        }\n        let iteration = 0;\n        do {\n            iteration += 1;\n            entryIteration = `${directory}/${(0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(fileEntry, (0,path__WEBPACK_IMPORTED_MODULE_0__.extname)(fileEntry))} (${iteration})${(0,path__WEBPACK_IMPORTED_MODULE_0__.extname)(fileEntry)}`;\n        }while (iconPositions[entryIteration] && // eslint-disable-next-line no-await-in-loop\n        await exists(entryIteration));\n        return (0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(entryIteration);\n    }));\nconst updateIconPositions = (directory, gridElement, iconPositions, sortOrders, dragPosition, draggedEntries, setIconPositions, exists)=>{\n    if (!gridElement || draggedEntries.length === 0) return;\n    const updatedIconPositions = updateIconPositionsIfEmpty(directory, gridElement, iconPositions, sortOrders);\n    const gridDropPosition = calcGridDropPosition(gridElement, dragPosition);\n    const conflictingIcon = Object.entries(updatedIconPositions).find(([, { gridColumnStart, gridRowStart }])=>gridColumnStart === gridDropPosition.gridColumnStart && gridRowStart === gridDropPosition.gridRowStart);\n    const processIconMove = ()=>{\n        const targetFile = draggedEntries.find((entry)=>entry.startsWith(document.activeElement?.textContent || \"\")) || draggedEntries[0];\n        const targetUrl = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(directory, targetFile);\n        const adjustDraggedEntries = [\n            targetFile,\n            ...draggedEntries.filter((entry)=>entry !== targetFile)\n        ];\n        const adjustIconPositions = Object.fromEntries(adjustDraggedEntries.map((entryFile)=>{\n            const url = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(directory, entryFile);\n            return [\n                url,\n                url === targetUrl ? gridDropPosition : calcGridPositionOffset(url, targetUrl, updatedIconPositions, gridDropPosition, adjustDraggedEntries, gridElement)\n            ];\n        }).filter(([, { gridColumnStart, gridRowStart }])=>gridColumnStart >= 1 && gridRowStart >= 1));\n        const newIconPositions = Object.fromEntries(Object.entries(adjustIconPositions).filter(([entryFile, { gridColumnStart, gridRowStart }])=>!Object.entries({\n                ...updatedIconPositions,\n                ...adjustIconPositions\n            }).some(([compareEntryFile, { gridColumnStart: compareGridColumnStart, gridRowStart: compareGridRowStart }])=>entryFile !== compareEntryFile && gridColumnStart === compareGridColumnStart && gridRowStart === compareGridRowStart)));\n        setIconPositions({\n            ...updatedIconPositions,\n            ...newIconPositions\n        });\n    };\n    if (conflictingIcon) {\n        const [conflictingIconPath] = conflictingIcon;\n        exists(conflictingIconPath).then((pathExists)=>{\n            if (!pathExists) {\n                delete updatedIconPositions[conflictingIconPath];\n                processIconMove();\n            }\n        });\n    } else {\n        processIconMove();\n    }\n};\nconst isCanvasDrawn = (canvas)=>{\n    if (!(canvas instanceof HTMLCanvasElement)) return false;\n    if (canvas.width === 0 || canvas.height === 0) return false;\n    const { data: pixels = [] } = canvas.getContext(\"2d\", {\n        willReadFrequently: true\n    })?.getImageData(0, 0, canvas.width, canvas.height) || {};\n    if (pixels.length === 0) return false;\n    const bwPixels = {\n        0: 0,\n        255: 0\n    };\n    for (const pixel of pixels){\n        if (pixel !== 0 && pixel !== 255) return true;\n        bwPixels[pixel] += 1;\n    }\n    const isBlankCanvas = bwPixels[0] === pixels.length || bwPixels[255] === pixels.length || bwPixels[255] + bwPixels[0] === pixels.length && bwPixels[0] / 3 === bwPixels[255];\n    return !isBlankCanvas;\n};\nconst bytesInKB = 1024;\nconst bytesInMB = 1022976; // 1024 * 999\nconst bytesInGB = 1047527424; // 1024 * 1024 * 999\nconst bytesInTB = 1072668082176; // 1024 * 1024 * 1024 * 999\nconst formatNumber = (number, roundUpNumber = false)=>{\n    const formattedNumber = new Intl.NumberFormat(\"en-US\", roundUpNumber ? undefined : {\n        maximumSignificantDigits: number < 1 ? 2 : 4,\n        minimumSignificantDigits: number < 1 ? 2 : 3\n    }).format(roundUpNumber ? Math.ceil(number) : Number(number.toFixed(4).slice(0, -2)));\n    if (roundUpNumber) return formattedNumber;\n    const [integer, decimal] = formattedNumber.split(\".\");\n    if (integer.length === 3) return integer;\n    if (integer.length === 2 && decimal.length === 2) {\n        return `${integer}.${decimal[0]}`;\n    }\n    return formattedNumber;\n};\nconst getFormattedSize = (size = 0, asKB = false)=>{\n    if (asKB) {\n        if (size === 0) return \"0 KB\";\n        if (size <= bytesInKB) return \"1 KB\";\n        return `${formatNumber(size / bytesInKB, true)} KB`;\n    }\n    if (size === 1) return \"1 byte\";\n    if (size < bytesInKB) return `${size} bytes`;\n    if (size < bytesInMB) return `${formatNumber(size / bytesInKB)} KB`;\n    if (size < bytesInGB) {\n        return `${formatNumber(size / bytesInKB / bytesInKB)} MB`;\n    }\n    if (size < bytesInTB) {\n        return `${formatNumber(size / bytesInKB / bytesInKB / bytesInKB)} GB`;\n    }\n    return `${size} bytes`;\n};\nlet timezoneOffset;\nconst getTZOffsetISOString = (timestamp)=>{\n    let time = timestamp;\n    // eslint-disable-next-line no-undef-init\n    let date = undefined;\n    if (!time) {\n        date = new Date();\n        time = date.getTime();\n    }\n    if (typeof timezoneOffset !== \"number\") {\n        timezoneOffset = (date || new Date()).getTimezoneOffset() * 60000;\n    }\n    return new Date(time - timezoneOffset).toISOString();\n};\nconst LOCAL_HOST = new Set([\n    \"127.0.0.1\",\n    \"localhost\"\n]);\nconst GOOGLE_SEARCH_QUERY = \"https://www.google.com/search?igu=1&q=\";\nconst getUrlOrSearch = async (input)=>{\n    const isIpfs = input.startsWith(\"ipfs://\");\n    const hasHttpSchema = input.startsWith(\"http://\") || input.startsWith(\"https://\");\n    const hasTld = input.endsWith(\".com\") || input.endsWith(\".ca\") || input.endsWith(\".net\") || input.endsWith(\".org\");\n    const isLocalHost = LOCAL_HOST.has(input);\n    try {\n        const url = new URL(!isLocalHost && (hasHttpSchema || !hasTld || isIpfs) ? input : `https://${input}`);\n        if (isIpfs) {\n            const { getIpfsGatewayUrl } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_utils_ipfs_ts\", \"high\").then(__webpack_require__.bind(__webpack_require__, /*! utils/ipfs */ \"(pages-dir-browser)/./utils/ipfs.ts\"));\n            return new URL(await getIpfsGatewayUrl(url.href));\n        }\n        return url;\n    } catch  {\n        return new URL(`${GOOGLE_SEARCH_QUERY}${input}`);\n    }\n};\nlet IS_FIREFOX;\nconst isFirefox = ()=>{\n    if (false) {}\n    if (IS_FIREFOX ?? false) return IS_FIREFOX;\n    IS_FIREFOX = /firefox/i.test(window.navigator.userAgent);\n    return IS_FIREFOX;\n};\nlet IS_SAFARI;\nconst isSafari = ()=>{\n    if (false) {}\n    if (IS_SAFARI ?? false) return IS_SAFARI;\n    IS_SAFARI = /^(?:(?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n    return IS_SAFARI;\n};\nconst haltEvent = (event)=>{\n    try {\n        if (event?.cancelable) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    } catch  {\n    // Ignore failured to halt event\n    }\n};\nconst createOffscreenCanvas = (containerElement, devicePixelRatio = 1, customSize = Object.create(null))=>{\n    const canvas = document.createElement(\"canvas\");\n    const height = Number(customSize?.height) || containerElement.offsetHeight;\n    const width = Number(customSize?.width) || containerElement.offsetWidth;\n    canvas.style.height = `${height}px`;\n    canvas.style.width = `${width}px`;\n    canvas.height = Math.floor(height * devicePixelRatio);\n    canvas.width = Math.floor(width * devicePixelRatio);\n    containerElement.append(canvas);\n    return canvas.transferControlToOffscreen();\n};\nconst getSearchParam = (param)=>new URLSearchParams(window.location.search).get(param) || \"\";\nconst clsx = (classes)=>Object.entries(classes).filter(([, isActive])=>isActive).map(([className])=>className).join(\" \");\nconst label = (value)=>({\n        \"aria-label\": value,\n        title: value\n    });\nconst isYouTubeUrl = (url)=>(url.includes(\"youtube.com/\") || url.includes(\"youtu.be/\")) && !url.includes(\"youtube.com/@\") && !url.includes(\"/channel/\") && !url.includes(\"/c/\");\nconst getYouTubeUrlId = (url)=>{\n    try {\n        const { pathname, searchParams } = new URL(url);\n        return searchParams.get(\"v\") || pathname.split(\"/\").pop() || \"\";\n    } catch  {\n    // URL parsing failed\n    }\n    return \"\";\n};\nconst getMimeType = (url, ext)=>{\n    switch(ext ? ext.toLowerCase() : getExtension(url)){\n        case \".ani\":\n        case \".cur\":\n        case \".ico\":\n            return \"image/vnd.microsoft.icon\";\n        case \".flac\":\n            return \"audio/x-flac\";\n        case \".cache\":\n        case \".jpg\":\n        case \".jpeg\":\n            return \"image/jpeg\";\n        case \".gif\":\n            return \"image/gif\";\n        case \".json\":\n            return \"application/json\";\n        case \".html\":\n        case \".htm\":\n        case \".whtml\":\n            return \"text/html\";\n        case \".m3u\":\n        case \".m3u8\":\n            return \"application/x-mpegURL\";\n        case \".m4a\":\n            return \"audio/m4a\";\n        case \".m4v\":\n        case \".mkv\":\n        case \".mov\":\n        case \".mp4\":\n            return \"video/mp4\";\n        case \".mp3\":\n            return \"audio/mpeg\";\n        case \".oga\":\n            return \"audio/ogg\";\n        case \".ogg\":\n        case \".ogm\":\n        case \".ogv\":\n            return \"video/ogg\";\n        case \".pdf\":\n            return \"application/pdf\";\n        case \".png\":\n            return \"image/png\";\n        case \".svg\":\n            return \"image/svg+xml\";\n        case \".md\":\n        case \".txt\":\n            return \"text/plain\";\n        case \".wav\":\n            return \"audio/wav\";\n        case \".webm\":\n            return \"video/webm\";\n        case \".webp\":\n            return \"image/webp\";\n        case \".xml\":\n            return \"application/xml\";\n        case \".jsdos\":\n        case \".pk3\":\n        case \".wsz\":\n        case \".zip\":\n            return \"application/zip\";\n        default:\n            return \"\";\n    }\n};\nconst isDynamicIcon = (icon)=>typeof icon === \"string\" && (icon.startsWith(utils_constants__WEBPACK_IMPORTED_MODULE_1__.ICON_PATH) || icon.startsWith(utils_constants__WEBPACK_IMPORTED_MODULE_1__.USER_ICON_PATH) && !icon.startsWith(utils_constants__WEBPACK_IMPORTED_MODULE_1__.ICON_CACHE));\nconst getPreloadedLinks = ()=>[\n        ...document.querySelectorAll(\"link[rel=preload]\")\n    ];\nlet HAS_MODULE_PRELOAD_SUPPORT = false;\nconst supportsModulePreload = ()=>{\n    if (HAS_MODULE_PRELOAD_SUPPORT) return true;\n    try {\n        const { relList } = document.createElement(\"link\");\n        HAS_MODULE_PRELOAD_SUPPORT = relList ? relList.supports(\"modulepreload\") : false;\n    } catch  {\n    // Ignore failure to check for modulepreload support\n    }\n    return HAS_MODULE_PRELOAD_SUPPORT;\n};\nlet HAS_WEBP_SUPPORT = false;\nconst supportsWebp = ()=>{\n    if (HAS_WEBP_SUPPORT) return true;\n    try {\n        HAS_WEBP_SUPPORT = document.createElement(\"canvas\").toDataURL(\"image/webp\").startsWith(\"data:image/webp\");\n    } catch  {\n    // Ignore failure to check for WebP support\n    }\n    return HAS_WEBP_SUPPORT;\n};\nconst supportsImageSrcSet = ()=>Object.prototype.hasOwnProperty.call(HTMLLinkElement.prototype, \"imageSrcset\");\nconst preloadImage = (image, id, fetchPriority = \"high\")=>{\n    const extension = getExtension(image);\n    const link = document.createElement(\"link\");\n    link.as = \"image\";\n    if (id) link.id = id;\n    link.fetchPriority = fetchPriority;\n    link.rel = \"preload\";\n    link.type = getMimeType(extension);\n    if (isDynamicIcon(image)) {\n        if (supportsImageSrcSet()) {\n            link.imageSrcset = imageSrcs(image, 48, extension);\n        } else {\n            const [href] = imageSrc(image, 48, getDpi(), extension).split(\" \");\n            link.href = href;\n        }\n    } else {\n        link.href = image;\n    }\n    const preloadedLinks = getPreloadedLinks();\n    if (!preloadedLinks.some((preloadedLink)=>link.imageSrcset && preloadedLink?.imageSrcset?.endsWith(link.imageSrcset) || link.href && preloadedLink?.href?.endsWith(link.href))) {\n        document.head.append(link);\n    }\n};\nconst preloadLibs = (libs = [])=>{\n    const scripts = [\n        ...document.scripts\n    ];\n    const preloadedLinks = getPreloadedLinks();\n    // eslint-disable-next-line unicorn/no-array-callback-reference\n    libs.map(encodeURI).forEach((lib)=>{\n        if (scripts.some((script)=>script.src.endsWith(lib)) || preloadedLinks.some((preloadedLink)=>preloadedLink.href.endsWith(lib))) {\n            return;\n        }\n        const link = document.createElement(\"link\");\n        link.fetchPriority = \"high\";\n        link.rel = \"preload\";\n        link.href = lib;\n        switch(getExtension(lib)){\n            case \".css\":\n                link.as = \"style\";\n                break;\n            case \".htm\":\n            case \".html\":\n                link.rel = \"prerender\";\n                break;\n            case \".js\":\n                if (supportsModulePreload()) {\n                    link.rel = \"modulepreload\";\n                }\n                break;\n            case \".json\":\n            case \".wasm\":\n                link.as = \"fetch\";\n                link.crossOrigin = \"anonymous\";\n                break;\n            default:\n                link.as = \"script\";\n                break;\n        }\n        document.head.append(link);\n    });\n};\nconst getGifJs = async ()=>{\n    const { default: GIFInstance } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_node_modules_gif_js_dist_gif_js\", \"high\").then(__webpack_require__.t.bind(__webpack_require__, /*! gif.js */ \"(pages-dir-browser)/./node_modules/gif.js/dist/gif.js\", 23));\n    return new GIFInstance({\n        quality: 10,\n        workerScript: \"System/gif.js/gif.worker.js\",\n        workers: Math.max(Math.floor(navigator.hardwareConcurrency / 4), 1)\n    });\n};\nconst jsonFetch = async (url, options)=>{\n    const response = await fetch(url, {\n        ...utils_constants__WEBPACK_IMPORTED_MODULE_1__.HIGH_PRIORITY_REQUEST,\n        ...options\n    });\n    const json = await response.json();\n    return json || {};\n};\nconst generatePrettyTimestamp = ()=>new Intl.DateTimeFormat(utils_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCALE, utils_constants__WEBPACK_IMPORTED_MODULE_1__.TIMESTAMP_DATE_FORMAT).format(new Date()).replace(/[/:]/g, \"-\").replace(\",\", \"\");\nconst isFileSystemMappingSupported = ()=>typeof FileSystemHandle === \"function\" && \"showDirectoryPicker\" in window;\nconst hasFinePointer = ()=>window.matchMedia(\"(pointer: fine)\").matches;\nconst isBeforeBg = ()=>document.documentElement.style.getPropertyValue(\"--before-background-opacity\") === \"1\";\nconst parseBgPosition = (position)=>{\n    if (typeof position === \"string\") {\n        const positionNum = Number.parseFloat(position);\n        if (!Number.isNaN(positionNum) && positionNum >= 0 && positionNum <= 100) {\n            return `${positionNum}%`;\n        }\n    }\n    return \"center\";\n};\nconst toSorted = (array, compareFn)=>[\n        ...array\n    ].sort(compareFn);\nconst notFound = (resource)=>// eslint-disable-next-line no-alert\n    alert(`Can't find '${resource}'. Check the spelling and try again.`);\nconst shouldCaptureDragImage = (entryCount, isDesktop = false)=>entryCount > 1 || !isDesktop && entryCount === 1 && isSafari();\nconst maybeRequestIdleCallback = (callback)=>{\n    if (\"requestIdleCallback\" in window && typeof window.requestIdleCallback === \"function\") {\n        requestIdleCallback(callback);\n    } else {\n        setTimeout(callback, 0);\n    }\n};\nconst displayVersion = ()=>{\n    const { __NEXT_DATA__: { buildId } = {} } = window;\n    return `${utils_constants__WEBPACK_IMPORTED_MODULE_1__.PACKAGE_DATA.version}${buildId ? `-${buildId}` : \"\"}`;\n};\nconst isDev = ()=>\"__nextDevClientId\" in window;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2Z1bmN0aW9ucy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQTZCL0I7QUFFbEIsTUFBTXFCLGVBQWUsQ0FBQ0MsUUFBZ0JDLE9BQzNDLElBQUlDLEtBQUs7UUFBQ0Y7S0FBbUIsRUFBRUMsT0FBTztRQUFFQTtJQUFLLElBQUlFLFdBQVc7QUFFdkQsTUFBTUMsY0FBYyxDQUFDSixRQUFnQkssV0FDMUNBLGFBQWEsa0JBQ1QsQ0FBQyxLQUFLLEVBQUVBLFNBQVMsUUFBUSxFQUFFQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9RLFFBQVEsS0FBSyxHQUMzREMsSUFBSUMsZUFBZSxDQUFDWCxhQUFhQyxRQUFRSyxXQUFXO0FBRTFELE1BQU1NLCtCQUErQjtBQUU5QixNQUFNQyxjQUFjLE9BQ3pCQyxNQUNBQyxlQUVBLElBQUlDLFFBQVEsQ0FBQ0M7UUFDWCxNQUFNQyxTQUFTLElBQUlDLE9BQ2pCLDJCQUFJVCxJQUFJLCtHQUEyQyxDQUFDLEdBQ3BEO1lBQUVXLE1BQU07UUFBc0I7UUFFaEMsTUFBTUMsZ0JBQWdCQyxXQUFXO1lBQy9CTixRQUFRSDtZQUNSSSxPQUFPTSxTQUFTO1FBQ2xCLEdBQUdaLCtCQUErQnJCLG1FQUFzQkE7UUFDeEQsTUFBTWtDLFNBQVNDLFNBQ1pDLGFBQWEsQ0FBQyxVQUNkQywwQkFBMEI7UUFFN0JWLE9BQU9XLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxFQUFFQyxJQUFJLEVBQWtCO1lBQzFEQyxhQUFhVDtZQUNiTCxRQUFRYSxnQkFBZ0IzQixPQUFPMkIsT0FBT2hCO1lBQ3RDSSxPQUFPTSxTQUFTO1FBQ2xCO1FBQ0FOLE9BQU9jLFdBQVcsQ0FBQztZQUFFbEI7WUFBTVc7WUFBUVY7UUFBYSxHQUFHO1lBQUNVO1NBQU87SUFDN0QsR0FBRztBQUVMLElBQUlRO0FBRUcsTUFBTUMs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LGVBQWUsS0FBS0EsZUFBZSxLQUFLO1lBQ3hFLE9BQU8sR0FBR0EsWUFBWSxDQUFDLENBQUM7UUFDMUI7SUFDRjtJQUVBLE9BQU87QUFDVCxFQUFFO0FBRUssTUFBTUUsV0FBVyxDQUN0QkMsT0FDQUMsWUFDUTtXQUFJRDtLQUFNLENBQUNFLElBQUksQ0FBQ0QsV0FBVztBQUU5QixNQUFNRSxXQUFXLENBQUNDLFdBQ3ZCLG9DQUFvQztJQUNwQ0MsTUFBTSxDQUFDLFlBQVksRUFBRUQsU0FBUyxvQ0FBb0MsQ0FBQyxFQUFFO0FBRWhFLE1BQU1FLHlCQUF5QixDQUNwQ0MsWUFDQUMsWUFBWSxLQUFLLEdBQ0xELGFBQWEsS0FBTSxDQUFDQyxhQUFhRCxlQUFlLEtBQUtyRixXQUFZO0FBRXhFLE1BQU11RiwyQkFBMkIsQ0FDdENDO0lBRUEsSUFDRSx5QkFBeUI3WSxVQUN6QixPQUFPQSxPQUFPOFksbUJBQW1CLEtBQUssWUFDdEM7UUFDQUEsb0JBQW9CRDtJQUN0QixPQUFPO1FBQ0w3WCxXQUFXNlgsVUFBVTtJQUN2QjtBQUNGLEVBQUU7QUFFSyxNQUFNRSxpQkFBaUI7SUFDNUIsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUdqWjtJQUU1QyxPQUFPLEdBQUdkLHlEQUFZQSxDQUFDZ2EsT0FBTyxHQUFHRCxVQUFVLENBQUMsQ0FBQyxFQUFFQSxTQUFTLEdBQUcsSUFBSTtBQUNqRSxFQUFFO0FBRUssTUFBTUUsUUFBUSxJQUFlLHVCQUF1Qm5aLE9BQU8iLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcdXRpbHNcXGZ1bmN0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSwgam9pbiB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7IHR5cGUgUG9zaXRpb24gfSBmcm9tIFwiZXJ1ZGFcIjtcclxuaW1wb3J0IHR5cGUgSHRtbFRvSW1hZ2UgZnJvbSBcImh0bWwtdG8taW1hZ2VcIjtcclxuaW1wb3J0IHsgdHlwZSBEcmFnUG9zaXRpb24gfSBmcm9tIFwiY29tcG9uZW50cy9zeXN0ZW0vRmlsZXMvRmlsZU1hbmFnZXIvdXNlRHJhZ2dhYmxlRW50cmllc1wiO1xyXG5pbXBvcnQgeyB0eXBlIFNpemUgfSBmcm9tIFwiY29tcG9uZW50cy9zeXN0ZW0vV2luZG93L1JuZFdpbmRvdy91c2VSZXNpemFibGVcIjtcclxuaW1wb3J0IHsgdHlwZSBQcm9jZXNzZXMsIHR5cGUgUmVsYXRpdmVQb3NpdGlvbiB9IGZyb20gXCJjb250ZXh0cy9wcm9jZXNzL3R5cGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgdHlwZSBJY29uUG9zaXRpb24sXHJcbiAgdHlwZSBJY29uUG9zaXRpb25zLFxyXG4gIHR5cGUgU29ydE9yZGVycyxcclxufSBmcm9tIFwiY29udGV4dHMvc2Vzc2lvbi90eXBlc1wiO1xyXG5pbXBvcnQge1xyXG4gIERFRkFVTFRfTE9DQUxFLFxyXG4gIERFU0tUT1BfUEFUSCxcclxuICBISUdIX1BSSU9SSVRZX1JFUVVFU1QsXHJcbiAgSUNPTl9DQUNIRSxcclxuICBJQ09OX1BBVEgsXHJcbiAgSUNPTl9SRVNfTUFQLFxyXG4gIE1BWF9JQ09OX1NJWkUsXHJcbiAgTUFYX1JFU19JQ09OX09WRVJSSURFLFxyXG4gIE1JTExJU0VDT05EU19JTl9TRUNPTkQsXHJcbiAgT05FX1RJTUVfUEFTU0lWRV9FVkVOVCxcclxuICBQQUNLQUdFX0RBVEEsXHJcbiAgUFJFVkVOVF9TQ1JPTEwsXHJcbiAgU0hPUlRDVVRfRVhURU5TSU9OLFxyXG4gIFNVUFBPUlRFRF9JQ09OX1NJWkVTLFxyXG4gIFRBU0tCQVJfSEVJR0hULFxyXG4gIFRJTUVTVEFNUF9EQVRFX0ZPUk1BVCxcclxuICBVU0VSX0lDT05fUEFUSCxcclxufSBmcm9tIFwidXRpbHMvY29uc3RhbnRzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgYnVmZmVyVG9CbG9iID0gKGJ1ZmZlcjogQnVmZmVyLCB0eXBlPzogc3RyaW5nKTogQmxvYiA9PlxyXG4gIG5ldyBCbG9iKFtidWZmZXIgYXMgQmxvYlBhcnRdLCB0eXBlID8geyB0eXBlIH0gOiB1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVXJsID0gKGJ1ZmZlcjogQnVmZmVyLCBtaW1lVHlwZT86IHN0cmluZyk6IHN0cmluZyA9PlxyXG4gIG1pbWVUeXBlID09PSBcImltYWdlL3N2Zyt4bWxcIlxyXG4gICAgPyBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHt3aW5kb3cuYnRvYShidWZmZXIudG9TdHJpbmcoKSl9YFxyXG4gICAgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJ1ZmZlclRvQmxvYihidWZmZXIsIG1pbWVUeXBlKSk7XHJcblxyXG5jb25zdCBSRVNJWkVfSU1BR0VfVElNRU9VVF9TRUNPTkRTID0gNjA7XHJcblxyXG5leHBvcnQgY29uc3QgcmVzaXplSW1hZ2UgPSBhc3luYyAoXHJcbiAgYmxvYjogQmxvYixcclxuICBtYXhEaW1lbnNpb246IG51bWJlclxyXG4pOiBQcm9taXNlPEJsb2I+ID0+XHJcbiAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoXHJcbiAgICAgIG5ldyBVUkwoXCJ1dGlscy9yZXNpemVJbWFnZS53b3JrZXJcIiwgaW1wb3J0Lm1ldGEudXJsKSxcclxuICAgICAgeyBuYW1lOiBcIlJlc2l6ZSBJbWFnZSBXb3JrZXJcIiB9XHJcbiAgICApO1xyXG4gICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICByZXNvbHZlKGJsb2IpO1xyXG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICB9LCBSRVNJWkVfSU1BR0VfVElNRU9VVF9TRUNPTkRTICogTUlMTElTRUNPTkRTX0lOX1NFQ09ORCk7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudFxyXG4gICAgICAuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxyXG4gICAgICAudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4oKTtcclxuXHJcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YSB9OiB7IGRhdGE6IEJsb2IgfSkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XHJcbiAgICAgIHJlc29sdmUoZGF0YSBpbnN0YW5jZW9mIEJsb2IgPyBkYXRhIDogYmxvYik7XHJcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgIH0pO1xyXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgYmxvYiwgY2FudmFzLCBtYXhEaW1lbnNpb24gfSwgW2NhbnZhc10pO1xyXG4gIH0pO1xyXG5cclxubGV0IGRwaTogbnVtYmVyO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldERwaSA9ICgpOiBudW1iZXIgPT4ge1xyXG4gIGlmICh0eXBlb2YgZHBpID09PSBcIm51bWJlclwiKSByZXR1cm4gZHBpO1xyXG5cclxuICBkcGkgPSBNYXRoLm1pbihNYXRoLmNlaWwod2luZG93LmRldmljZVBpeGVsUmF0aW8pLCAzKTtcclxuXHJcbiAgcmV0dXJuIGRwaTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFeHRlbnNpb24gPSAodXJsOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gIGxldCBleHQgPSBleHRuYW1lKHVybCk7XHJcblxyXG4gIGlmICghZXh0KSB7XHJcbiAgICBjb25zdCBiYXNlTmFtZSA9IGJhc2VuYW1lKHVybCk7XHJcblxyXG4gICAgaWYgKGJhc2VOYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSBleHQgPSBiYXNlTmFtZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBleHQudG9Mb3dlckNhc2UoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZW5kTW91c2VDbGljayA9ICh0YXJnZXQ6IEhUTUxFbGVtZW50LCBjb3VudCA9IDEpOiB2b2lkID0+IHtcclxuICBpZiAoY291bnQgPT09IDApIHJldHVybjtcclxuXHJcbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG5cclxuICBzZW5kTW91c2VDbGljayh0YXJnZXQsIGNvdW50IC0gMSk7XHJcbn07XHJcblxyXG5sZXQgdmlzaWJsZVdpbmRvd3M6IHN0cmluZ1tdID0gW107XHJcblxyXG5leHBvcnQgY29uc3QgdG9nZ2xlU2hvd0Rlc2t0b3AgPSAoXHJcbiAgcHJvY2Vzc2VzOiBQcm9jZXNzZXMsXHJcbiAgc3RhY2tPcmRlcjogc3RyaW5nW10sXHJcbiAgbWluaW1pemU6IChpZDogc3RyaW5nKSA9PiB2b2lkXHJcbik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHJlc3RvcmVXaW5kb3dzID1cclxuICAgIHN0YWNrT3JkZXIubGVuZ3RoID4gMCAmJlxyXG4gICAgIXN0YWNrT3JkZXIuc29tZSgocGlkKSA9PiAhcHJvY2Vzc2VzW3BpZF0/Lm1pbmltaXplZCk7XHJcbiAgY29uc3QgYWxsV2luZG93cyA9IHJlc3RvcmVXaW5kb3dzID8gWy4uLnN0YWNrT3JkZXJdLnJldmVyc2UoKSA6IHN0YWNrT3JkZXI7XHJcblxyXG4gIGlmICghcmVzdG9yZVdpbmRvd3MpIHZpc2libGVXaW5kb3dzID0gW107XHJcbiAgZWxzZSBpZiAodmlzaWJsZVdpbmRvd3MubGVuZ3RoID09PSAwKSB2aXNpYmxlV2luZG93cyA9IGFsbFdpbmRvd3M7XHJcblxyXG4gIGFsbFdpbmRvd3MuZm9yRWFjaCgocGlkKSA9PiB7XHJcbiAgICBpZiAocmVzdG9yZVdpbmRvd3MpIHtcclxuICAgICAgaWYgKHZpc2libGVXaW5kb3dzLmluY2x1ZGVzKHBpZCkpIG1pbmltaXplKHBpZCk7XHJcbiAgICB9IGVsc2UgaWYgKCFwcm9jZXNzZXNbcGlkXT8ubWluaW1pemVkKSB7XHJcbiAgICAgIHZpc2libGVXaW5kb3dzLnB1c2gocGlkKTtcclxuICAgICAgbWluaW1pemUocGlkKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKHJlc3RvcmVXaW5kb3dzKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cclxuICAgICAgcHJvY2Vzc2VzW3N0YWNrT3JkZXJbMF1dPy5jb21wb25lbnRXaW5kb3c/LmZvY3VzKFBSRVZFTlRfU0NST0xMKVxyXG4gICAgKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW1hZ2VTcmMgPSAoXHJcbiAgaW1hZ2VQYXRoOiBzdHJpbmcsXHJcbiAgc2l6ZTogbnVtYmVyLFxyXG4gIHJhdGlvOiBudW1iZXIsXHJcbiAgZXh0ZW5zaW9uOiBzdHJpbmdcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBpbWFnZU5hbWUgPSBiYXNlbmFtZShpbWFnZVBhdGgsIGV4dGVuc2lvbik7XHJcbiAgY29uc3QgW2V4cGVjdGVkU2l6ZSwgbWF4SWNvblNpemVdID0gTUFYX1JFU19JQ09OX09WRVJSSURFW2ltYWdlTmFtZV0gfHwgW107XHJcbiAgY29uc3QgcmF0aW9TaXplID0gc2l6ZSAqIHJhdGlvO1xyXG4gIGNvbnN0IGltYWdlU2l6ZSA9IE1hdGgubWluKFxyXG4gICAgTUFYX0lDT05fU0laRSxcclxuICAgIGV4cGVjdGVkU2l6ZSA9PT0gc2l6ZSA/IE1hdGgubWluKG1heEljb25TaXplLCByYXRpb1NpemUpIDogcmF0aW9TaXplXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIGAke2pvaW4oXHJcbiAgICBkaXJuYW1lKGltYWdlUGF0aCksXHJcbiAgICBgJHtJQ09OX1JFU19NQVBbaW1hZ2VTaXplXSB8fCBpbWFnZVNpemV9eCR7XHJcbiAgICAgIElDT05fUkVTX01BUFtpbWFnZVNpemVdIHx8IGltYWdlU2l6ZVxyXG4gICAgfWAsXHJcbiAgICBgJHtpbWFnZU5hbWV9JHtleHRlbnNpb259YFxyXG4gICkucmVwbGFjZSgvXFxcXC9nLCBcIi9cIil9JHtyYXRpbyA+IDEgPyBgICR7cmF0aW99eGAgOiBcIlwifWA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW1hZ2VTcmNzID0gKFxyXG4gIGltYWdlUGF0aDogc3RyaW5nLFxyXG4gIHNpemU6IG51bWJlcixcclxuICBleHRlbnNpb246IHN0cmluZyxcclxuICBmYWlsZWRVcmxzID0gW10gYXMgc3RyaW5nW11cclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBzcmNzID0gW1xyXG4gICAgaW1hZ2VTcmMoaW1hZ2VQYXRoLCBzaXplLCAxLCBleHRlbnNpb24pLFxyXG4gICAgaW1hZ2VTcmMoaW1hZ2VQYXRoLCBzaXplLCAyLCBleHRlbnNpb24pLFxyXG4gICAgaW1hZ2VTcmMoaW1hZ2VQYXRoLCBzaXplLCAzLCBleHRlbnNpb24pLFxyXG4gIF1cclxuICAgIC5maWx0ZXIoXHJcbiAgICAgICh1cmwpID0+IGZhaWxlZFVybHMubGVuZ3RoID09PSAwIHx8IGZhaWxlZFVybHMuaW5jbHVkZXModXJsLnNwbGl0KFwiIFwiKVswXSlcclxuICAgIClcclxuICAgIC5qb2luKFwiLCBcIik7XHJcblxyXG4gIHJldHVybiBmYWlsZWRVcmxzPy5pbmNsdWRlcyhzcmNzKSA/IFwiXCIgOiBzcmNzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZhbGxiYWNrU3JjU2V0ID0gKFxyXG4gIHNyYzogc3RyaW5nLFxyXG4gIGZhaWxlZFVybHM6IHN0cmluZ1tdXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3Qgc3JjRXh0ID0gZ2V0RXh0ZW5zaW9uKHNyYyk7XHJcbiAgY29uc3QgZmFpbGVkU2l6ZXMgPSBuZXcgU2V0KFxyXG4gICAgbmV3IFNldChcclxuICAgICAgZmFpbGVkVXJscy5tYXAoKGZhaWxlZFVybCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYmFzZW5hbWUoc3JjLCBzcmNFeHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gTnVtYmVyKFxyXG4gICAgICAgICAgZmFpbGVkVXJsXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKGAke0lDT05fUEFUSH0vYCwgXCJcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoYCR7VVNFUl9JQ09OX1BBVEh9L2AsIFwiXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKGAvJHtmaWxlTmFtZX0ucG5nYCwgXCJcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoYC8ke2ZpbGVOYW1lfS53ZWJwYCwgXCJcIilcclxuICAgICAgICAgICAgLnNwbGl0KFwieFwiKVswXVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pXHJcbiAgICApXHJcbiAgKTtcclxuICBjb25zdCBwb3NzaWJsZVNpemVzID0gU1VQUE9SVEVEX0lDT05fU0laRVMuZmlsdGVyKFxyXG4gICAgKHNpemUpID0+ICFmYWlsZWRTaXplcy5oYXMoc2l6ZSlcclxuICApO1xyXG5cclxuICByZXR1cm4gcG9zc2libGVTaXplc1xyXG4gICAgLm1hcCgoc2l6ZSkgPT4gaW1hZ2VTcmMoc3JjLCBzaXplLCAxLCBzcmNFeHQpKVxyXG4gICAgLnJldmVyc2UoKVxyXG4gICAgLmpvaW4oXCIsIFwiKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBibG9iVG9CYXNlNjQgPSAoYmxvYjogQmxvYik6IFByb21pc2U8c3RyaW5nPiA9PlxyXG4gIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XHJcbiAgICBmaWxlUmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUoZmlsZVJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKTtcclxuICB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBibG9iVG9CdWZmZXIgPSBhc3luYyAoYmxvYj86IEJsb2IgfCBudWxsKTogUHJvbWlzZTxCdWZmZXI+ID0+XHJcbiAgYmxvYiA/IEJ1ZmZlci5mcm9tKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSkgOiBCdWZmZXIuZnJvbShcIlwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaEJsb2IgPSBhc3luYyAodXJsOiBzdHJpbmcpOiBQcm9taXNlPEJsb2I+ID0+XHJcbiAgKGF3YWl0IGZldGNoKHVybCkpLmJsb2IoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBjYW52YXNUb0J1ZmZlciA9IChjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCk6IEJ1ZmZlciA9PlxyXG4gIEJ1ZmZlci5mcm9tKFxyXG4gICAgY2FudmFzPy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIikucmVwbGFjZShcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiwgXCJcIikgfHwgXCJcIixcclxuICAgIFwiYmFzZTY0XCJcclxuICApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGltZ0RhdGFUb0J1ZmZlciA9IChpbWFnZURhdGE6IEltYWdlRGF0YSk6IEJ1ZmZlciA9PiB7XHJcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuXHJcbiAgY2FudmFzLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xyXG4gIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik/LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG5cclxuICByZXR1cm4gY2FudmFzVG9CdWZmZXIoY2FudmFzKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhblVwQnVmZmVyVXJsID0gKHVybDogc3RyaW5nKTogdm9pZCA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcblxyXG5jb25zdCByb3dCbGFuayA9IChpbWFnZURhdGE6IEltYWdlRGF0YSwgd2lkdGg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiA9PiB7XHJcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XHJcbiAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbeSAqIHdpZHRoICogNCArIHggKiA0ICsgM10gIT09IDApIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5jb25zdCBjb2x1bW5CbGFuayA9IChcclxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcclxuICB3aWR0aDogbnVtYmVyLFxyXG4gIHg6IG51bWJlcixcclxuICB0b3A6IG51bWJlcixcclxuICBib3R0b206IG51bWJlclxyXG4pOiBib29sZWFuID0+IHtcclxuICBmb3IgKGxldCB5ID0gdG9wOyB5IDwgYm90dG9tOyArK3kpIHtcclxuICAgIGlmIChpbWFnZURhdGEuZGF0YVt5ICogd2lkdGggKiA0ICsgeCAqIDQgKyAzXSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0cmltQ2FudmFzVG9Ub3BMZWZ0ID0gKFxyXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcclxuKTogSFRNTENhbnZhc0VsZW1lbnQgPT4ge1xyXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xyXG4gICAgYWxwaGE6IHRydWUsXHJcbiAgICBkZXN5bmNocm9uaXplZDogdHJ1ZSxcclxuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcclxuICB9KTtcclxuXHJcbiAgaWYgKCFjdHgpIHJldHVybiBjYW52YXM7XHJcblxyXG4gIGNvbnN0IHsgaGVpZ2h0LCBvd25lckRvY3VtZW50LCB3aWR0aCB9ID0gY2FudmFzO1xyXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgY29uc3QgeyBoZWlnaHQ6IGJvdHRvbSwgd2lkdGg6IHJpZ2h0IH0gPSBpbWFnZURhdGE7XHJcblxyXG4gIGxldCB0b3AgPSAwO1xyXG4gIGxldCBsZWZ0ID0gMDtcclxuXHJcbiAgd2hpbGUgKHRvcCA8IGJvdHRvbSAmJiByb3dCbGFuayhpbWFnZURhdGEsIHdpZHRoLCB0b3ApKSArK3RvcDtcclxuICB3aGlsZSAobGVmdCA8IHJpZ2h0ICYmIGNvbHVtbkJsYW5rKGltYWdlRGF0YSwgd2lkdGgsIGxlZnQsIHRvcCwgYm90dG9tKSkge1xyXG4gICAgKytsZWZ0O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJpbW1lZCA9IGN0eC5nZXRJbWFnZURhdGEobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XHJcbiAgY29uc3QgY29weSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICBjb25zdCBjb3B5Q3R4ID0gY29weS5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gIGlmICghY29weUN0eCkgcmV0dXJuIGNhbnZhcztcclxuXHJcbiAgY29weS53aWR0aCA9IHRyaW1tZWQud2lkdGg7XHJcbiAgY29weS5oZWlnaHQgPSB0cmltbWVkLmhlaWdodDtcclxuICBjb3B5Q3R4LnB1dEltYWdlRGF0YSh0cmltbWVkLCAwLCAwKTtcclxuXHJcbiAgcmV0dXJuIGNvcHk7XHJcbn07XHJcblxyXG5jb25zdCBsb2FkU2NyaXB0ID0gKFxyXG4gIHNyYzogc3RyaW5nLFxyXG4gIGRlZmVyPzogYm9vbGVhbixcclxuICBmb3JjZT86IGJvb2xlYW4sXHJcbiAgYXNNb2R1bGU/OiBib29sZWFuLFxyXG4gIGNvbnRlbnRXaW5kb3cgPSB3aW5kb3cgYXMgV2luZG93XHJcbik6IFByb21pc2U8RXZlbnQ+ID0+XHJcbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgbG9hZGVkU2NyaXB0cyA9IFsuLi5jb250ZW50V2luZG93LmRvY3VtZW50LnNjcmlwdHNdO1xyXG4gICAgY29uc3QgY3VycmVudFNjcmlwdCA9IGxvYWRlZFNjcmlwdHMuZmluZCgobG9hZGVkU2NyaXB0KSA9PlxyXG4gICAgICBsb2FkZWRTY3JpcHQuc3JjLmVuZHNXaXRoKHNyYylcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcclxuICAgICAgaWYgKCFmb3JjZSkge1xyXG4gICAgICAgIHJlc29sdmUobmV3IEV2ZW50KFwiQWxyZWFkeSBsb2FkZWQuXCIpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1cnJlbnRTY3JpcHQucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2NyaXB0ID0gY29udGVudFdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG5cclxuICAgIHNjcmlwdC5hc3luYyA9IGZhbHNlO1xyXG4gICAgaWYgKGRlZmVyKSBzY3JpcHQuZGVmZXIgPSB0cnVlO1xyXG4gICAgaWYgKGFzTW9kdWxlKSBzY3JpcHQudHlwZSA9IFwibW9kdWxlXCI7XHJcbiAgICBzY3JpcHQuZmV0Y2hQcmlvcml0eSA9IFwiaGlnaFwiO1xyXG4gICAgc2NyaXB0LnNyYyA9IHNyYztcclxuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0LCBPTkVfVElNRV9QQVNTSVZFX0VWRU5UKTtcclxuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZXNvbHZlLCBPTkVfVElNRV9QQVNTSVZFX0VWRU5UKTtcclxuXHJcbiAgICBjb250ZW50V2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdCk7XHJcbiAgfSk7XHJcblxyXG5jb25zdCBsb2FkU3R5bGUgPSAoXHJcbiAgaHJlZjogc3RyaW5nLFxyXG4gIGNvbnRlbnRXaW5kb3cgPSB3aW5kb3cgYXMgV2luZG93XHJcbik6IFByb21pc2U8RXZlbnQ+ID0+XHJcbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgbG9hZGVkU3R5bGVzID0gW1xyXG4gICAgICAuLi5jb250ZW50V2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1zdHlsZXNoZWV0XVwiKSxcclxuICAgIF0gYXMgSFRNTExpbmtFbGVtZW50W107XHJcblxyXG4gICAgaWYgKGxvYWRlZFN0eWxlcy5zb21lKChsb2FkZWRTdHlsZSkgPT4gbG9hZGVkU3R5bGUuaHJlZi5lbmRzV2l0aChocmVmKSkpIHtcclxuICAgICAgcmVzb2x2ZShuZXcgRXZlbnQoXCJBbHJlYWR5IGxvYWRlZC5cIikpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGluayA9IGNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblxyXG4gICAgbGluay5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuICAgIGxpbmsuZmV0Y2hQcmlvcml0eSA9IFwiaGlnaFwiO1xyXG4gICAgbGluay5ocmVmID0gaHJlZjtcclxuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCwgT05FX1RJTUVfUEFTU0lWRV9FVkVOVCk7XHJcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc29sdmUsIE9ORV9USU1FX1BBU1NJVkVfRVZFTlQpO1xyXG5cclxuICAgIGNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuaGVhZC5hcHBlbmQobGluayk7XHJcbiAgfSk7XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzID0gYXN5bmMgKFxyXG4gIGZpbGVzPzogc3RyaW5nW10sXHJcbiAgZGVmZXI/OiBib29sZWFuLFxyXG4gIGZvcmNlPzogYm9vbGVhbixcclxuICBhc01vZHVsZT86IGJvb2xlYW4sXHJcbiAgY29udGVudFdpbmRvdz86IFdpbmRvd1xyXG4pOiBQcm9taXNlPHZvaWQ+ID0+XHJcbiAgIWZpbGVzIHx8IGZpbGVzLmxlbmd0aCA9PT0gMFxyXG4gICAgPyBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgOiBmaWxlcy5yZWR1Y2UoYXN5bmMgKF9wcm9taXNlLCBmaWxlKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgKGdldEV4dGVuc2lvbihmaWxlKSA9PT0gXCIuY3NzXCJcclxuICAgICAgICAgID8gbG9hZFN0eWxlKGVuY29kZVVSSShmaWxlKSwgY29udGVudFdpbmRvdylcclxuICAgICAgICAgIDogbG9hZFNjcmlwdChlbmNvZGVVUkkoZmlsZSksIGRlZmVyLCBmb3JjZSwgYXNNb2R1bGUsIGNvbnRlbnRXaW5kb3cpKTtcclxuICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEh0bWxUb0ltYWdlID0gYXN5bmMgKCk6IFByb21pc2U8XHJcbiAgdHlwZW9mIEh0bWxUb0ltYWdlIHwgdW5kZWZpbmVkXHJcbj4gPT4ge1xyXG4gIGF3YWl0IGxvYWRGaWxlcyhbXCIvU3lzdGVtL2h0bWwtdG8taW1hZ2UvaHRtbC10by1pbWFnZS5qc1wiXSk7XHJcblxyXG4gIGNvbnN0IHsgaHRtbFRvSW1hZ2UgfSA9IHdpbmRvdyBhcyB1bmtub3duIGFzIFdpbmRvdyAmIHtcclxuICAgIGh0bWxUb0ltYWdlOiB0eXBlb2YgSHRtbFRvSW1hZ2U7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGh0bWxUb0ltYWdlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHB4VG9OdW0gPSAodmFsdWU6IG51bWJlciB8IHN0cmluZyA9IDApOiBudW1iZXIgPT5cclxuICB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2aWV3SGVpZ2h0ID0gKCk6IG51bWJlciA9PiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG5leHBvcnQgY29uc3Qgdmlld1dpZHRoID0gKCk6IG51bWJlciA9PiB3aW5kb3cuaW5uZXJXaWR0aDtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRXaW5kb3dWaWV3cG9ydCA9ICgpOiBQb3NpdGlvbiA9PiAoe1xyXG4gIHg6IHZpZXdXaWR0aCgpLFxyXG4gIHk6IHZpZXdIZWlnaHQoKSAtIFRBU0tCQVJfSEVJR0hULFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBjYWxjSW5pdGlhbFBvc2l0aW9uID0gKFxyXG4gIHsgb2Zmc2V0SGVpZ2h0IH06IEhUTUxFbGVtZW50LFxyXG4gIHsgcmlnaHQgPSAwLCBsZWZ0ID0gMCwgdG9wID0gMCwgYm90dG9tID0gMCB9ID0ge30gYXMgUmVsYXRpdmVQb3NpdGlvbixcclxuICB7IHdpZHRoID0gMCwgaGVpZ2h0ID0gMCB9ID0ge30gYXMgU2l6ZVxyXG4pOiBQb3NpdGlvbiA9PiB7XHJcbiAgY29uc3QgW3ZoLCB2d10gPSBbdmlld0hlaWdodCgpLCB2aWV3V2lkdGgoKV07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBweFRvTnVtKHdpZHRoKSA+PSB2dyA/IDAgOiBsZWZ0IHx8IHZ3IC0gcmlnaHQsXHJcbiAgICB5OlxyXG4gICAgICBweFRvTnVtKGhlaWdodCkgKyBUQVNLQkFSX0hFSUdIVCA+PSB2aFxyXG4gICAgICAgID8gMFxyXG4gICAgICAgIDogdG9wIHx8IHZoIC0gYm90dG9tIC0gb2Zmc2V0SGVpZ2h0LFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBHUklEX1RFTVBMQVRFX1JPV1MgPSBcImdyaWQtdGVtcGxhdGUtcm93c1wiO1xyXG5cclxuY29uc3QgY2FsY0dyaWREcm9wUG9zaXRpb24gPSAoXHJcbiAgZ3JpZEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbCxcclxuICB7IHggPSAwLCB5ID0gMCB9OiBEcmFnUG9zaXRpb25cclxuKTogSWNvblBvc2l0aW9uID0+IHtcclxuICBpZiAoIWdyaWRFbGVtZW50KSByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKSBhcyBJY29uUG9zaXRpb247XHJcblxyXG4gIGNvbnN0IGdyaWRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZ3JpZEVsZW1lbnQpO1xyXG4gIGNvbnN0IGdyaWRUZW1wbGF0ZVJvd3MgPSBncmlkQ29tcHV0ZWRTdHlsZVxyXG4gICAgLmdldFByb3BlcnR5VmFsdWUoR1JJRF9URU1QTEFURV9ST1dTKVxyXG4gICAgLnNwbGl0KFwiIFwiKTtcclxuICBjb25zdCBncmlkVGVtcGxhdGVDb2x1bW5zID0gZ3JpZENvbXB1dGVkU3R5bGVcclxuICAgIC5nZXRQcm9wZXJ0eVZhbHVlKFwiZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXCIpXHJcbiAgICAuc3BsaXQoXCIgXCIpO1xyXG4gIGNvbnN0IGdyaWRSb3dIZWlnaHQgPSBweFRvTnVtKGdyaWRUZW1wbGF0ZVJvd3NbMF0pO1xyXG4gIGNvbnN0IGdyaWRDb2x1bW5XaWR0aCA9IHB4VG9OdW0oZ3JpZFRlbXBsYXRlQ29sdW1uc1swXSk7XHJcbiAgY29uc3QgZ3JpZENvbHVtbkdhcCA9IHB4VG9OdW0oXHJcbiAgICBncmlkQ29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZ3JpZC1jb2x1bW4tZ2FwXCIpXHJcbiAgKTtcclxuICBjb25zdCBncmlkUm93R2FwID0gcHhUb051bShcclxuICAgIGdyaWRDb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJncmlkLXJvdy1nYXBcIilcclxuICApO1xyXG4gIGNvbnN0IHBhZGRpbmdUb3AgPSBweFRvTnVtKGdyaWRDb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLXRvcFwiKSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBncmlkQ29sdW1uU3RhcnQ6IE1hdGgubWluKFxyXG4gICAgICBNYXRoLmNlaWwoeCAvIChncmlkQ29sdW1uV2lkdGggKyBncmlkQ29sdW1uR2FwKSksXHJcbiAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnMubGVuZ3RoXHJcbiAgICApLFxyXG4gICAgZ3JpZFJvd1N0YXJ0OiBNYXRoLm1pbihcclxuICAgICAgTWF0aC5jZWlsKCh5IC0gcGFkZGluZ1RvcCkgLyAoZ3JpZFJvd0hlaWdodCArIGdyaWRSb3dHYXApKSxcclxuICAgICAgZ3JpZFRlbXBsYXRlUm93cy5sZW5ndGhcclxuICAgICksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlVW5wb3NpdGlvbmVkRGVza3RvcEljb25zID0gKFxyXG4gIHNldEljb25Qb3NpdGlvbnM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPEljb25Qb3NpdGlvbnM+PlxyXG4pOiB2b2lkID0+IHtcclxuICBjb25zdCBkZXNrdG9wSWNvbkdyaWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxPTGlzdEVsZW1lbnQ+KFwibWFpbiA+IG9sXCIpO1xyXG5cclxuICBpZiAoZGVza3RvcEljb25HcmlkIGluc3RhbmNlb2YgSFRNTE9MaXN0RWxlbWVudCkge1xyXG4gICAgY29uc3QgdW5Qb3NpdGlvbmVkSWNvbnMgPSBbXHJcbiAgICAgIC4uLmRlc2t0b3BJY29uR3JpZC5xdWVyeVNlbGVjdG9yQWxsKFwibGlcIiksXHJcbiAgICBdLmZpbHRlcihcclxuICAgICAgKHsgc3R5bGU6IHsgZ3JpZFJvd1N0YXJ0LCBncmlkQ29sdW1uU3RhcnQgfSB9KSA9PlxyXG4gICAgICAgICFncmlkUm93U3RhcnQgfHwgIWdyaWRDb2x1bW5TdGFydFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodW5Qb3NpdGlvbmVkSWNvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgY29sdW1uR2FwLFxyXG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnMsXHJcbiAgICAgICAgZ3JpZFRlbXBsYXRlUm93cyxcclxuICAgICAgICBwYWRkaW5nVG9wLFxyXG4gICAgICAgIHJvd0dhcCxcclxuICAgICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRlc2t0b3BJY29uR3JpZCk7XHJcbiAgICAgIGNvbnN0IFtlbnRyeVdpZHRoXSA9IGdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoXCIgXCIpO1xyXG4gICAgICBjb25zdCBbZW50cnlIZWlnaHRdID0gZ3JpZFRlbXBsYXRlUm93cy5zcGxpdChcIiBcIik7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IHB4VG9OdW0oZW50cnlIZWlnaHQpICsgcHhUb051bShyb3dHYXApO1xyXG4gICAgICBjb25zdCB3aWR0aCA9IHB4VG9OdW0oZW50cnlXaWR0aCkgKyBweFRvTnVtKGNvbHVtbkdhcCk7XHJcbiAgICAgIGNvbnN0IHJvd1RvcFBhZGRpbmcgPSBweFRvTnVtKHBhZGRpbmdUb3ApO1xyXG4gICAgICBjb25zdCBuZXdJY29uUG9zaXRpb25zID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG4gICAgICAgIHVuUG9zaXRpb25lZEljb25zLm1hcCgoaWNvbikgPT4ge1xyXG4gICAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwge307XHJcbiAgICAgICAgICBjb25zdCBidXR0b24gPSBpY29uLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICAgICAgICBsZXQgbmFtZSA9IGJ1dHRvbj8uZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSB8fCBidXR0b24/LnRleHRDb250ZW50O1xyXG5cclxuICAgICAgICAgIGlmIChidXR0b24/LnF1ZXJ5U2VsZWN0b3IoXCJpbWdbc3JjKj1zaG9ydGN1dF1cIikpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGAke25hbWV9JHtTSE9SVENVVF9FWFRFTlNJT059YDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuYW1lID8gam9pbihERVNLVE9QX1BBVEgsIG5hbWUpIDogXCJcIixcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGdyaWRDb2x1bW5TdGFydDogTWF0aC5yb3VuZChsZWZ0IC8gd2lkdGgpICsgMSxcclxuICAgICAgICAgICAgICBncmlkUm93U3RhcnQ6IE1hdGgucm91bmQoKHRvcCAtIHJvd1RvcFBhZGRpbmcpIC8gaGVpZ2h0KSArIDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBzZXRJY29uUG9zaXRpb25zKChjdXJyZW50SWNvblBvc2l0aW9ucykgPT4gKHtcclxuICAgICAgICAuLi5jdXJyZW50SWNvblBvc2l0aW9ucyxcclxuICAgICAgICAuLi5uZXdJY29uUG9zaXRpb25zLFxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUljb25Qb3NpdGlvbnNJZkVtcHR5ID0gKFxyXG4gIHVybDogc3RyaW5nLFxyXG4gIGdyaWRFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwsXHJcbiAgaWNvblBvc2l0aW9uczogSWNvblBvc2l0aW9ucyxcclxuICBzb3J0T3JkZXJzOiBTb3J0T3JkZXJzXHJcbik6IEljb25Qb3NpdGlvbnMgPT4ge1xyXG4gIGlmICghZ3JpZEVsZW1lbnQpIHJldHVybiBpY29uUG9zaXRpb25zO1xyXG5cclxuICBjb25zdCBbZmlsZU9yZGVyID0gW11dID0gc29ydE9yZGVyc1t1cmxdIHx8IFtdO1xyXG4gIGNvbnN0IG5ld0ljb25Qb3NpdGlvbnM6IEljb25Qb3NpdGlvbnMgPSB7fTtcclxuICBjb25zdCBncmlkQ29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdyaWRFbGVtZW50KTtcclxuICBjb25zdCBncmlkVGVtcGxhdGVSb3dDb3VudCA9IGdyaWRDb21wdXRlZFN0eWxlXHJcbiAgICAuZ2V0UHJvcGVydHlWYWx1ZShHUklEX1RFTVBMQVRFX1JPV1MpXHJcbiAgICAuc3BsaXQoXCIgXCIpLmxlbmd0aDtcclxuXHJcbiAgZmlsZU9yZGVyLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgZW50cnlVcmwgPSBqb2luKHVybCwgZW50cnkpO1xyXG5cclxuICAgIGlmICghaWNvblBvc2l0aW9uc1tlbnRyeVVybF0pIHtcclxuICAgICAgbGV0IGdyaWRFbnRyeTogRWxlbWVudCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZ3JpZEVudHJ5ID0gWy4uLmdyaWRFbGVtZW50LmNoaWxkcmVuXS5maW5kKChlbGVtZW50KSA9PlxyXG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICAgICAgICBgYnV0dG9uW2FyaWEtbGFiZWw9XCIke0NTUy5lc2NhcGUoZW50cnkucmVwbGFjZShTSE9SVENVVF9FWFRFTlNJT04sIFwiXCIpKX1cIl1gXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgLy8gSWdub3JlIGVycm9yIGdldHRpbmcgZWxlbWVudFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZ3JpZEVudHJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIGhlaWdodCwgd2lkdGggfSA9IGdyaWRFbnRyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgbmV3SWNvblBvc2l0aW9uc1tlbnRyeVVybF0gPSBjYWxjR3JpZERyb3BQb3NpdGlvbihncmlkRWxlbWVudCwge1xyXG4gICAgICAgICAgeDogeCArIHdpZHRoIC8gMixcclxuICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggKyAxO1xyXG4gICAgICAgIGNvbnN0IGdyaWRDb2x1bW5TdGFydCA9IE1hdGguY2VpbChwb3NpdGlvbiAvIGdyaWRUZW1wbGF0ZVJvd0NvdW50KTtcclxuICAgICAgICBjb25zdCBncmlkUm93U3RhcnQgPVxyXG4gICAgICAgICAgcG9zaXRpb24gLSBncmlkVGVtcGxhdGVSb3dDb3VudCAqIChncmlkQ29sdW1uU3RhcnQgLSAxKTtcclxuXHJcbiAgICAgICAgbmV3SWNvblBvc2l0aW9uc1tlbnRyeVVybF0gPSB7IGdyaWRDb2x1bW5TdGFydCwgZ3JpZFJvd1N0YXJ0IH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG5ld0ljb25Qb3NpdGlvbnMpLmxlbmd0aCA+IDBcclxuICAgID8geyAuLi5uZXdJY29uUG9zaXRpb25zLCAuLi5pY29uUG9zaXRpb25zIH1cclxuICAgIDogaWNvblBvc2l0aW9ucztcclxufTtcclxuXHJcbmNvbnN0IGNhbGNHcmlkUG9zaXRpb25PZmZzZXQgPSAoXHJcbiAgdXJsOiBzdHJpbmcsXHJcbiAgdGFyZ2V0VXJsOiBzdHJpbmcsXHJcbiAgY3VycmVudEljb25Qb3NpdGlvbnM6IEljb25Qb3NpdGlvbnMsXHJcbiAgZ3JpZERyb3BQb3NpdGlvbjogSWNvblBvc2l0aW9uLFxyXG4gIFssIC4uLmRyYWdnZWRFbnRyaWVzXTogc3RyaW5nW10sXHJcbiAgZ3JpZEVsZW1lbnQ6IEhUTUxFbGVtZW50XHJcbik6IEljb25Qb3NpdGlvbiA9PiB7XHJcbiAgaWYgKGN1cnJlbnRJY29uUG9zaXRpb25zW3VybF0gJiYgY3VycmVudEljb25Qb3NpdGlvbnNbdGFyZ2V0VXJsXSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ3JpZENvbHVtblN0YXJ0OlxyXG4gICAgICAgIGN1cnJlbnRJY29uUG9zaXRpb25zW3VybF0uZ3JpZENvbHVtblN0YXJ0ICtcclxuICAgICAgICAoZ3JpZERyb3BQb3NpdGlvbi5ncmlkQ29sdW1uU3RhcnQgLVxyXG4gICAgICAgICAgY3VycmVudEljb25Qb3NpdGlvbnNbdGFyZ2V0VXJsXS5ncmlkQ29sdW1uU3RhcnQpLFxyXG4gICAgICBncmlkUm93U3RhcnQ6XHJcbiAgICAgICAgY3VycmVudEljb25Qb3NpdGlvbnNbdXJsXS5ncmlkUm93U3RhcnQgK1xyXG4gICAgICAgIChncmlkRHJvcFBvc2l0aW9uLmdyaWRSb3dTdGFydCAtXHJcbiAgICAgICAgICBjdXJyZW50SWNvblBvc2l0aW9uc1t0YXJnZXRVcmxdLmdyaWRSb3dTdGFydCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZ3JpZENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShncmlkRWxlbWVudCk7XHJcbiAgY29uc3QgZ3JpZFRlbXBsYXRlUm93Q291bnQgPSBncmlkQ29tcHV0ZWRTdHlsZVxyXG4gICAgLmdldFByb3BlcnR5VmFsdWUoR1JJRF9URU1QTEFURV9ST1dTKVxyXG4gICAgLnNwbGl0KFwiIFwiKS5sZW5ndGg7XHJcbiAgY29uc3Qge1xyXG4gICAgZ3JpZENvbHVtblN0YXJ0OiB0YXJnZXRHcmlkQ29sdW1uU3RhcnQsXHJcbiAgICBncmlkUm93U3RhcnQ6IHRhcmdldEdyaWRSb3dTdGFydCxcclxuICB9ID0gZ3JpZERyb3BQb3NpdGlvbjtcclxuICBjb25zdCBncmlkUm93U3RhcnQgPVxyXG4gICAgdGFyZ2V0R3JpZFJvd1N0YXJ0ICsgZHJhZ2dlZEVudHJpZXMuaW5kZXhPZihiYXNlbmFtZSh1cmwpKSArIDE7XHJcblxyXG4gIHJldHVybiBncmlkUm93U3RhcnQgPiBncmlkVGVtcGxhdGVSb3dDb3VudFxyXG4gICAgPyB7XHJcbiAgICAgICAgZ3JpZENvbHVtblN0YXJ0OlxyXG4gICAgICAgICAgdGFyZ2V0R3JpZENvbHVtblN0YXJ0ICtcclxuICAgICAgICAgIE1hdGguY2VpbChncmlkUm93U3RhcnQgLyBncmlkVGVtcGxhdGVSb3dDb3VudCkgLVxyXG4gICAgICAgICAgMSxcclxuICAgICAgICBncmlkUm93U3RhcnQ6XHJcbiAgICAgICAgICBncmlkUm93U3RhcnQgJSBncmlkVGVtcGxhdGVSb3dDb3VudCB8fCBncmlkVGVtcGxhdGVSb3dDb3VudCxcclxuICAgICAgfVxyXG4gICAgOiB7XHJcbiAgICAgICAgZ3JpZENvbHVtblN0YXJ0OiB0YXJnZXRHcmlkQ29sdW1uU3RhcnQsXHJcbiAgICAgICAgZ3JpZFJvd1N0YXJ0LFxyXG4gICAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEl0ZXJhdGVkTmFtZXMgPSAoXHJcbiAgZmlsZUVudHJpZXM6IHN0cmluZ1tdLFxyXG4gIGRpcmVjdG9yeTogc3RyaW5nLFxyXG4gIGljb25Qb3NpdGlvbnM6IEljb25Qb3NpdGlvbnMsXHJcbiAgZXhpc3RzOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XHJcbik6IFByb21pc2U8c3RyaW5nW10+ID0+XHJcbiAgUHJvbWlzZS5hbGwoXHJcbiAgICBmaWxlRW50cmllcy5tYXAoYXN5bmMgKGZpbGVFbnRyeSkgPT4ge1xyXG4gICAgICBsZXQgZW50cnlJdGVyYXRpb24gPSBgJHtkaXJlY3Rvcnl9LyR7ZmlsZUVudHJ5fWA7XHJcblxyXG4gICAgICBpZiAoIWljb25Qb3NpdGlvbnNbZW50cnlJdGVyYXRpb25dIHx8ICEoYXdhaXQgZXhpc3RzKGVudHJ5SXRlcmF0aW9uKSkpIHtcclxuICAgICAgICByZXR1cm4gZmlsZUVudHJ5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgaXRlcmF0aW9uID0gMDtcclxuXHJcbiAgICAgIGRvIHtcclxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcclxuICAgICAgICBlbnRyeUl0ZXJhdGlvbiA9IGAke2RpcmVjdG9yeX0vJHtiYXNlbmFtZShcclxuICAgICAgICAgIGZpbGVFbnRyeSxcclxuICAgICAgICAgIGV4dG5hbWUoZmlsZUVudHJ5KVxyXG4gICAgICAgICl9ICgke2l0ZXJhdGlvbn0pJHtleHRuYW1lKGZpbGVFbnRyeSl9YDtcclxuICAgICAgfSB3aGlsZSAoXHJcbiAgICAgICAgaWNvblBvc2l0aW9uc1tlbnRyeUl0ZXJhdGlvbl0gJiZcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgICAgIChhd2FpdCBleGlzdHMoZW50cnlJdGVyYXRpb24pKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGJhc2VuYW1lKGVudHJ5SXRlcmF0aW9uKTtcclxuICAgIH0pXHJcbiAgKTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVJY29uUG9zaXRpb25zID0gKFxyXG4gIGRpcmVjdG9yeTogc3RyaW5nLFxyXG4gIGdyaWRFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwsXHJcbiAgaWNvblBvc2l0aW9uczogSWNvblBvc2l0aW9ucyxcclxuICBzb3J0T3JkZXJzOiBTb3J0T3JkZXJzLFxyXG4gIGRyYWdQb3NpdGlvbjogRHJhZ1Bvc2l0aW9uLFxyXG4gIGRyYWdnZWRFbnRyaWVzOiBzdHJpbmdbXSxcclxuICBzZXRJY29uUG9zaXRpb25zOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxJY29uUG9zaXRpb25zPj4sXHJcbiAgZXhpc3RzOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XHJcbik6IHZvaWQgPT4ge1xyXG4gIGlmICghZ3JpZEVsZW1lbnQgfHwgZHJhZ2dlZEVudHJpZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gIGNvbnN0IHVwZGF0ZWRJY29uUG9zaXRpb25zID0gdXBkYXRlSWNvblBvc2l0aW9uc0lmRW1wdHkoXHJcbiAgICBkaXJlY3RvcnksXHJcbiAgICBncmlkRWxlbWVudCxcclxuICAgIGljb25Qb3NpdGlvbnMsXHJcbiAgICBzb3J0T3JkZXJzXHJcbiAgKTtcclxuICBjb25zdCBncmlkRHJvcFBvc2l0aW9uID0gY2FsY0dyaWREcm9wUG9zaXRpb24oZ3JpZEVsZW1lbnQsIGRyYWdQb3NpdGlvbik7XHJcbiAgY29uc3QgY29uZmxpY3RpbmdJY29uID0gT2JqZWN0LmVudHJpZXModXBkYXRlZEljb25Qb3NpdGlvbnMpLmZpbmQoXHJcbiAgICAoWywgeyBncmlkQ29sdW1uU3RhcnQsIGdyaWRSb3dTdGFydCB9XSkgPT5cclxuICAgICAgZ3JpZENvbHVtblN0YXJ0ID09PSBncmlkRHJvcFBvc2l0aW9uLmdyaWRDb2x1bW5TdGFydCAmJlxyXG4gICAgICBncmlkUm93U3RhcnQgPT09IGdyaWREcm9wUG9zaXRpb24uZ3JpZFJvd1N0YXJ0XHJcbiAgKTtcclxuICBjb25zdCBwcm9jZXNzSWNvbk1vdmUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRGaWxlID1cclxuICAgICAgZHJhZ2dlZEVudHJpZXMuZmluZCgoZW50cnkpID0+XHJcbiAgICAgICAgZW50cnkuc3RhcnRzV2l0aChkb2N1bWVudC5hY3RpdmVFbGVtZW50Py50ZXh0Q29udGVudCB8fCBcIlwiKVxyXG4gICAgICApIHx8IGRyYWdnZWRFbnRyaWVzWzBdO1xyXG4gICAgY29uc3QgdGFyZ2V0VXJsID0gam9pbihkaXJlY3RvcnksIHRhcmdldEZpbGUpO1xyXG4gICAgY29uc3QgYWRqdXN0RHJhZ2dlZEVudHJpZXMgPSBbXHJcbiAgICAgIHRhcmdldEZpbGUsXHJcbiAgICAgIC4uLmRyYWdnZWRFbnRyaWVzLmZpbHRlcigoZW50cnkpID0+IGVudHJ5ICE9PSB0YXJnZXRGaWxlKSxcclxuICAgIF07XHJcbiAgICBjb25zdCBhZGp1c3RJY29uUG9zaXRpb25zID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG4gICAgICBhZGp1c3REcmFnZ2VkRW50cmllc1xyXG4gICAgICAgIC5tYXA8W3N0cmluZywgSWNvblBvc2l0aW9uXT4oKGVudHJ5RmlsZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdXJsID0gam9pbihkaXJlY3RvcnksIGVudHJ5RmlsZSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICB1cmwgPT09IHRhcmdldFVybFxyXG4gICAgICAgICAgICAgID8gZ3JpZERyb3BQb3NpdGlvblxyXG4gICAgICAgICAgICAgIDogY2FsY0dyaWRQb3NpdGlvbk9mZnNldChcclxuICAgICAgICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICAgICAgICB0YXJnZXRVcmwsXHJcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRJY29uUG9zaXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICBncmlkRHJvcFBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICBhZGp1c3REcmFnZ2VkRW50cmllcyxcclxuICAgICAgICAgICAgICAgICAgZ3JpZEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmZpbHRlcihcclxuICAgICAgICAgIChbLCB7IGdyaWRDb2x1bW5TdGFydCwgZ3JpZFJvd1N0YXJ0IH1dKSA9PlxyXG4gICAgICAgICAgICBncmlkQ29sdW1uU3RhcnQgPj0gMSAmJiBncmlkUm93U3RhcnQgPj0gMVxyXG4gICAgICAgIClcclxuICAgICk7XHJcbiAgICBjb25zdCBuZXdJY29uUG9zaXRpb25zID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG4gICAgICBPYmplY3QuZW50cmllcyhhZGp1c3RJY29uUG9zaXRpb25zKS5maWx0ZXIoXHJcbiAgICAgICAgKFtlbnRyeUZpbGUsIHsgZ3JpZENvbHVtblN0YXJ0LCBncmlkUm93U3RhcnQgfV0pID0+XHJcbiAgICAgICAgICAhT2JqZWN0LmVudHJpZXMoe1xyXG4gICAgICAgICAgICAuLi51cGRhdGVkSWNvblBvc2l0aW9ucyxcclxuICAgICAgICAgICAgLi4uYWRqdXN0SWNvblBvc2l0aW9ucyxcclxuICAgICAgICAgIH0pLnNvbWUoXHJcbiAgICAgICAgICAgIChbXHJcbiAgICAgICAgICAgICAgY29tcGFyZUVudHJ5RmlsZSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBncmlkQ29sdW1uU3RhcnQ6IGNvbXBhcmVHcmlkQ29sdW1uU3RhcnQsXHJcbiAgICAgICAgICAgICAgICBncmlkUm93U3RhcnQ6IGNvbXBhcmVHcmlkUm93U3RhcnQsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSkgPT5cclxuICAgICAgICAgICAgICBlbnRyeUZpbGUgIT09IGNvbXBhcmVFbnRyeUZpbGUgJiZcclxuICAgICAgICAgICAgICBncmlkQ29sdW1uU3RhcnQgPT09IGNvbXBhcmVHcmlkQ29sdW1uU3RhcnQgJiZcclxuICAgICAgICAgICAgICBncmlkUm93U3RhcnQgPT09IGNvbXBhcmVHcmlkUm93U3RhcnRcclxuICAgICAgICAgIClcclxuICAgICAgKVxyXG4gICAgKTtcclxuXHJcbiAgICBzZXRJY29uUG9zaXRpb25zKHsgLi4udXBkYXRlZEljb25Qb3NpdGlvbnMsIC4uLm5ld0ljb25Qb3NpdGlvbnMgfSk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKGNvbmZsaWN0aW5nSWNvbikge1xyXG4gICAgY29uc3QgW2NvbmZsaWN0aW5nSWNvblBhdGhdID0gY29uZmxpY3RpbmdJY29uO1xyXG5cclxuICAgIGV4aXN0cyhjb25mbGljdGluZ0ljb25QYXRoKS50aGVuKChwYXRoRXhpc3RzKSA9PiB7XHJcbiAgICAgIGlmICghcGF0aEV4aXN0cykge1xyXG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkSWNvblBvc2l0aW9uc1tjb25mbGljdGluZ0ljb25QYXRoXTtcclxuICAgICAgICBwcm9jZXNzSWNvbk1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHByb2Nlc3NJY29uTW92ZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0NhbnZhc0RyYXduID0gKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCk6IGJvb2xlYW4gPT4ge1xyXG4gIGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBjb25zdCB7IGRhdGE6IHBpeGVscyA9IFtdIH0gPVxyXG4gICAgY2FudmFzXHJcbiAgICAgIC5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWUgfSlcclxuICAgICAgPy5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSB8fCB7fTtcclxuXHJcbiAgaWYgKHBpeGVscy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgY29uc3QgYndQaXhlbHM6IFJlY29yZDxudW1iZXIsIG51bWJlcj4gPSB7IDA6IDAsIDI1NTogMCB9O1xyXG5cclxuICBmb3IgKGNvbnN0IHBpeGVsIG9mIHBpeGVscykge1xyXG4gICAgaWYgKHBpeGVsICE9PSAwICYmIHBpeGVsICE9PSAyNTUpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGJ3UGl4ZWxzW3BpeGVsXSArPSAxO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaXNCbGFua0NhbnZhcyA9XHJcbiAgICBid1BpeGVsc1swXSA9PT0gcGl4ZWxzLmxlbmd0aCB8fFxyXG4gICAgYndQaXhlbHNbMjU1XSA9PT0gcGl4ZWxzLmxlbmd0aCB8fFxyXG4gICAgKGJ3UGl4ZWxzWzI1NV0gKyBid1BpeGVsc1swXSA9PT0gcGl4ZWxzLmxlbmd0aCAmJlxyXG4gICAgICBid1BpeGVsc1swXSAvIDMgPT09IGJ3UGl4ZWxzWzI1NV0pO1xyXG5cclxuICByZXR1cm4gIWlzQmxhbmtDYW52YXM7XHJcbn07XHJcblxyXG5jb25zdCBieXRlc0luS0IgPSAxMDI0O1xyXG5jb25zdCBieXRlc0luTUIgPSAxMDIyOTc2OyAvLyAxMDI0ICogOTk5XHJcbmNvbnN0IGJ5dGVzSW5HQiA9IDEwNDc1Mjc0MjQ7IC8vIDEwMjQgKiAxMDI0ICogOTk5XHJcbmNvbnN0IGJ5dGVzSW5UQiA9IDEwNzI2NjgwODIxNzY7IC8vIDEwMjQgKiAxMDI0ICogMTAyNCAqIDk5OVxyXG5cclxuY29uc3QgZm9ybWF0TnVtYmVyID0gKG51bWJlcjogbnVtYmVyLCByb3VuZFVwTnVtYmVyID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGZvcm1hdHRlZE51bWJlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcclxuICAgIFwiZW4tVVNcIixcclxuICAgIHJvdW5kVXBOdW1iZXJcclxuICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgOiB7XHJcbiAgICAgICAgICBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHM6IG51bWJlciA8IDEgPyAyIDogNCxcclxuICAgICAgICAgIG1pbmltdW1TaWduaWZpY2FudERpZ2l0czogbnVtYmVyIDwgMSA/IDIgOiAzLFxyXG4gICAgICAgIH1cclxuICApLmZvcm1hdChcclxuICAgIHJvdW5kVXBOdW1iZXIgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE51bWJlcihudW1iZXIudG9GaXhlZCg0KS5zbGljZSgwLCAtMikpXHJcbiAgKTtcclxuXHJcbiAgaWYgKHJvdW5kVXBOdW1iZXIpIHJldHVybiBmb3JtYXR0ZWROdW1iZXI7XHJcblxyXG4gIGNvbnN0IFtpbnRlZ2VyLCBkZWNpbWFsXSA9IGZvcm1hdHRlZE51bWJlci5zcGxpdChcIi5cIik7XHJcblxyXG4gIGlmIChpbnRlZ2VyLmxlbmd0aCA9PT0gMykgcmV0dXJuIGludGVnZXI7XHJcbiAgaWYgKGludGVnZXIubGVuZ3RoID09PSAyICYmIGRlY2ltYWwubGVuZ3RoID09PSAyKSB7XHJcbiAgICByZXR1cm4gYCR7aW50ZWdlcn0uJHtkZWNpbWFsWzBdfWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZvcm1hdHRlZFNpemUgPSAoc2l6ZSA9IDAsIGFzS0IgPSBmYWxzZSk6IHN0cmluZyA9PiB7XHJcbiAgaWYgKGFzS0IpIHtcclxuICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gXCIwIEtCXCI7XHJcbiAgICBpZiAoc2l6ZSA8PSBieXRlc0luS0IpIHJldHVybiBcIjEgS0JcIjtcclxuXHJcbiAgICByZXR1cm4gYCR7Zm9ybWF0TnVtYmVyKHNpemUgLyBieXRlc0luS0IsIHRydWUpfSBLQmA7XHJcbiAgfVxyXG5cclxuICBpZiAoc2l6ZSA9PT0gMSkgcmV0dXJuIFwiMSBieXRlXCI7XHJcbiAgaWYgKHNpemUgPCBieXRlc0luS0IpIHJldHVybiBgJHtzaXplfSBieXRlc2A7XHJcbiAgaWYgKHNpemUgPCBieXRlc0luTUIpIHJldHVybiBgJHtmb3JtYXROdW1iZXIoc2l6ZSAvIGJ5dGVzSW5LQil9IEtCYDtcclxuICBpZiAoc2l6ZSA8IGJ5dGVzSW5HQikge1xyXG4gICAgcmV0dXJuIGAke2Zvcm1hdE51bWJlcihzaXplIC8gYnl0ZXNJbktCIC8gYnl0ZXNJbktCKX0gTUJgO1xyXG4gIH1cclxuICBpZiAoc2l6ZSA8IGJ5dGVzSW5UQikge1xyXG4gICAgcmV0dXJuIGAke2Zvcm1hdE51bWJlcihzaXplIC8gYnl0ZXNJbktCIC8gYnl0ZXNJbktCIC8gYnl0ZXNJbktCKX0gR0JgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGAke3NpemV9IGJ5dGVzYDtcclxufTtcclxuXHJcbmxldCB0aW1lem9uZU9mZnNldDogbnVtYmVyO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRaT2Zmc2V0SVNPU3RyaW5nID0gKHRpbWVzdGFtcD86IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IHRpbWUgPSB0aW1lc3RhbXA7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmLWluaXRcclxuICBsZXQgZGF0ZTogRGF0ZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgaWYgKCF0aW1lKSB7XHJcbiAgICBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgIHRpbWUgPSBkYXRlLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdGltZXpvbmVPZmZzZXQgIT09IFwibnVtYmVyXCIpIHtcclxuICAgIHRpbWV6b25lT2Zmc2V0ID0gKGRhdGUgfHwgbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWUgLSB0aW1lem9uZU9mZnNldCkudG9JU09TdHJpbmcoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBMT0NBTF9IT1NUID0gbmV3IFNldChbXCIxMjcuMC4wLjFcIiwgXCJsb2NhbGhvc3RcIl0pO1xyXG5leHBvcnQgY29uc3QgR09PR0xFX1NFQVJDSF9RVUVSWSA9IFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/aWd1PTEmcT1cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRVcmxPclNlYXJjaCA9IGFzeW5jIChpbnB1dDogc3RyaW5nKTogUHJvbWlzZTxVUkw+ID0+IHtcclxuICBjb25zdCBpc0lwZnMgPSBpbnB1dC5zdGFydHNXaXRoKFwiaXBmczovL1wiKTtcclxuICBjb25zdCBoYXNIdHRwU2NoZW1hID1cclxuICAgIGlucHV0LnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKTtcclxuICBjb25zdCBoYXNUbGQgPVxyXG4gICAgaW5wdXQuZW5kc1dpdGgoXCIuY29tXCIpIHx8XHJcbiAgICBpbnB1dC5lbmRzV2l0aChcIi5jYVwiKSB8fFxyXG4gICAgaW5wdXQuZW5kc1dpdGgoXCIubmV0XCIpIHx8XHJcbiAgICBpbnB1dC5lbmRzV2l0aChcIi5vcmdcIik7XHJcbiAgY29uc3QgaXNMb2NhbEhvc3QgPSBMT0NBTF9IT1NULmhhcyhpbnB1dCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxyXG4gICAgICAhaXNMb2NhbEhvc3QgJiYgKGhhc0h0dHBTY2hlbWEgfHwgIWhhc1RsZCB8fCBpc0lwZnMpXHJcbiAgICAgICAgPyBpbnB1dFxyXG4gICAgICAgIDogYGh0dHBzOi8vJHtpbnB1dH1gXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChpc0lwZnMpIHtcclxuICAgICAgY29uc3QgeyBnZXRJcGZzR2F0ZXdheVVybCB9ID0gYXdhaXQgaW1wb3J0KFwidXRpbHMvaXBmc1wiKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgVVJMKGF3YWl0IGdldElwZnNHYXRld2F5VXJsKHVybC5ocmVmKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVybDtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBuZXcgVVJMKGAke0dPT0dMRV9TRUFSQ0hfUVVFUll9JHtpbnB1dH1gKTtcclxuICB9XHJcbn07XHJcblxyXG5sZXQgSVNfRklSRUZPWDogYm9vbGVhbjtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcclxuICBpZiAoSVNfRklSRUZPWCA/PyBmYWxzZSkgcmV0dXJuIElTX0ZJUkVGT1g7XHJcblxyXG4gIElTX0ZJUkVGT1ggPSAvZmlyZWZveC9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuICByZXR1cm4gSVNfRklSRUZPWDtcclxufTtcclxuXHJcbmxldCBJU19TQUZBUkk6IGJvb2xlYW47XHJcblxyXG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcclxuICBpZiAoSVNfU0FGQVJJID8/IGZhbHNlKSByZXR1cm4gSVNfU0FGQVJJO1xyXG5cclxuICBJU19TQUZBUkkgPSAvXig/Oig/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoXHJcbiAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxyXG4gICk7XHJcblxyXG4gIHJldHVybiBJU19TQUZBUkk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGFsdEV2ZW50ID0gKFxyXG4gIGV2ZW50OlxyXG4gICAgfCBFdmVudFxyXG4gICAgfCBSZWFjdC5EcmFnRXZlbnRcclxuICAgIHwgUmVhY3QuRm9jdXNFdmVudFxyXG4gICAgfCBSZWFjdC5LZXlib2FyZEV2ZW50XHJcbiAgICB8IFJlYWN0Lk1vdXNlRXZlbnRcclxuKTogdm9pZCA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmIChldmVudD8uY2FuY2VsYWJsZSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICB9IGNhdGNoIHtcclxuICAgIC8vIElnbm9yZSBmYWlsdXJlZCB0byBoYWx0IGV2ZW50XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9mZnNjcmVlbkNhbnZhcyA9IChcclxuICBjb250YWluZXJFbGVtZW50OiBIVE1MRWxlbWVudCxcclxuICBkZXZpY2VQaXhlbFJhdGlvID0gMSxcclxuICBjdXN0b21TaXplOiBTaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKSBhcyBTaXplXHJcbik6IE9mZnNjcmVlbkNhbnZhcyA9PiB7XHJcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICBjb25zdCBoZWlnaHQgPSBOdW1iZXIoY3VzdG9tU2l6ZT8uaGVpZ2h0KSB8fCBjb250YWluZXJFbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICBjb25zdCB3aWR0aCA9IE51bWJlcihjdXN0b21TaXplPy53aWR0aCkgfHwgY29udGFpbmVyRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XHJcbiAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xyXG5cclxuICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvKTtcclxuICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbyk7XHJcblxyXG4gIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XHJcblxyXG4gIHJldHVybiBjYW52YXMudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4oKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTZWFyY2hQYXJhbSA9IChwYXJhbTogc3RyaW5nKTogc3RyaW5nID0+XHJcbiAgbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQocGFyYW0pIHx8IFwiXCI7XHJcblxyXG5leHBvcnQgY29uc3QgY2xzeCA9IChjbGFzc2VzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPik6IHN0cmluZyA9PlxyXG4gIE9iamVjdC5lbnRyaWVzKGNsYXNzZXMpXHJcbiAgICAuZmlsdGVyKChbLCBpc0FjdGl2ZV0pID0+IGlzQWN0aXZlKVxyXG4gICAgLm1hcCgoW2NsYXNzTmFtZV0pID0+IGNsYXNzTmFtZSlcclxuICAgIC5qb2luKFwiIFwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBsYWJlbCA9ICh2YWx1ZTogc3RyaW5nKTogUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTEVsZW1lbnQ+ID0+ICh7XHJcbiAgXCJhcmlhLWxhYmVsXCI6IHZhbHVlLFxyXG4gIHRpdGxlOiB2YWx1ZSxcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgaXNZb3VUdWJlVXJsID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PlxyXG4gICh1cmwuaW5jbHVkZXMoXCJ5b3V0dWJlLmNvbS9cIikgfHwgdXJsLmluY2x1ZGVzKFwieW91dHUuYmUvXCIpKSAmJlxyXG4gICF1cmwuaW5jbHVkZXMoXCJ5b3V0dWJlLmNvbS9AXCIpICYmXHJcbiAgIXVybC5pbmNsdWRlcyhcIi9jaGFubmVsL1wiKSAmJlxyXG4gICF1cmwuaW5jbHVkZXMoXCIvYy9cIik7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0WW91VHViZVVybElkID0gKHVybDogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHVybCk7XHJcblxyXG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcy5nZXQoXCJ2XCIpIHx8IHBhdGhuYW1lLnNwbGl0KFwiL1wiKS5wb3AoKSB8fCBcIlwiO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgLy8gVVJMIHBhcnNpbmcgZmFpbGVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gXCJcIjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRNaW1lVHlwZSA9ICh1cmw6IHN0cmluZywgZXh0Pzogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICBzd2l0Y2ggKGV4dCA/IGV4dC50b0xvd2VyQ2FzZSgpIDogZ2V0RXh0ZW5zaW9uKHVybCkpIHtcclxuICAgIGNhc2UgXCIuYW5pXCI6XHJcbiAgICBjYXNlIFwiLmN1clwiOlxyXG4gICAgY2FzZSBcIi5pY29cIjpcclxuICAgICAgcmV0dXJuIFwiaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uXCI7XHJcbiAgICBjYXNlIFwiLmZsYWNcIjpcclxuICAgICAgcmV0dXJuIFwiYXVkaW8veC1mbGFjXCI7XHJcbiAgICBjYXNlIFwiLmNhY2hlXCI6XHJcbiAgICBjYXNlIFwiLmpwZ1wiOlxyXG4gICAgY2FzZSBcIi5qcGVnXCI6XHJcbiAgICAgIHJldHVybiBcImltYWdlL2pwZWdcIjtcclxuICAgIGNhc2UgXCIuZ2lmXCI6XHJcbiAgICAgIHJldHVybiBcImltYWdlL2dpZlwiO1xyXG4gICAgY2FzZSBcIi5qc29uXCI6XHJcbiAgICAgIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIjtcclxuICAgIGNhc2UgXCIuaHRtbFwiOlxyXG4gICAgY2FzZSBcIi5odG1cIjpcclxuICAgIGNhc2UgXCIud2h0bWxcIjpcclxuICAgICAgcmV0dXJuIFwidGV4dC9odG1sXCI7XHJcbiAgICBjYXNlIFwiLm0zdVwiOlxyXG4gICAgY2FzZSBcIi5tM3U4XCI6XHJcbiAgICAgIHJldHVybiBcImFwcGxpY2F0aW9uL3gtbXBlZ1VSTFwiO1xyXG4gICAgY2FzZSBcIi5tNGFcIjpcclxuICAgICAgcmV0dXJuIFwiYXVkaW8vbTRhXCI7XHJcbiAgICBjYXNlIFwiLm00dlwiOlxyXG4gICAgY2FzZSBcIi5ta3ZcIjpcclxuICAgIGNhc2UgXCIubW92XCI6XHJcbiAgICBjYXNlIFwiLm1wNFwiOlxyXG4gICAgICByZXR1cm4gXCJ2aWRlby9tcDRcIjtcclxuICAgIGNhc2UgXCIubXAzXCI6XHJcbiAgICAgIHJldHVybiBcImF1ZGlvL21wZWdcIjtcclxuICAgIGNhc2UgXCIub2dhXCI6XHJcbiAgICAgIHJldHVybiBcImF1ZGlvL29nZ1wiO1xyXG4gICAgY2FzZSBcIi5vZ2dcIjpcclxuICAgIGNhc2UgXCIub2dtXCI6XHJcbiAgICBjYXNlIFwiLm9ndlwiOlxyXG4gICAgICByZXR1cm4gXCJ2aWRlby9vZ2dcIjtcclxuICAgIGNhc2UgXCIucGRmXCI6XHJcbiAgICAgIHJldHVybiBcImFwcGxpY2F0aW9uL3BkZlwiO1xyXG4gICAgY2FzZSBcIi5wbmdcIjpcclxuICAgICAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XHJcbiAgICBjYXNlIFwiLnN2Z1wiOlxyXG4gICAgICByZXR1cm4gXCJpbWFnZS9zdmcreG1sXCI7XHJcbiAgICBjYXNlIFwiLm1kXCI6XHJcbiAgICBjYXNlIFwiLnR4dFwiOlxyXG4gICAgICByZXR1cm4gXCJ0ZXh0L3BsYWluXCI7XHJcbiAgICBjYXNlIFwiLndhdlwiOlxyXG4gICAgICByZXR1cm4gXCJhdWRpby93YXZcIjtcclxuICAgIGNhc2UgXCIud2VibVwiOlxyXG4gICAgICByZXR1cm4gXCJ2aWRlby93ZWJtXCI7XHJcbiAgICBjYXNlIFwiLndlYnBcIjpcclxuICAgICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xyXG4gICAgY2FzZSBcIi54bWxcIjpcclxuICAgICAgcmV0dXJuIFwiYXBwbGljYXRpb24veG1sXCI7XHJcbiAgICBjYXNlIFwiLmpzZG9zXCI6XHJcbiAgICBjYXNlIFwiLnBrM1wiOlxyXG4gICAgY2FzZSBcIi53c3pcIjpcclxuICAgIGNhc2UgXCIuemlwXCI6XHJcbiAgICAgIHJldHVybiBcImFwcGxpY2F0aW9uL3ppcFwiO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzRHluYW1pY0ljb24gPSAoaWNvbj86IHN0cmluZyk6IGJvb2xlYW4gPT5cclxuICB0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gIChpY29uLnN0YXJ0c1dpdGgoSUNPTl9QQVRIKSB8fFxyXG4gICAgKGljb24uc3RhcnRzV2l0aChVU0VSX0lDT05fUEFUSCkgJiYgIWljb24uc3RhcnRzV2l0aChJQ09OX0NBQ0hFKSkpO1xyXG5cclxuY29uc3QgZ2V0UHJlbG9hZGVkTGlua3MgPSAoKTogSFRNTExpbmtFbGVtZW50W10gPT4gW1xyXG4gIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTExpbmtFbGVtZW50PihcImxpbmtbcmVsPXByZWxvYWRdXCIpLFxyXG5dO1xyXG5cclxubGV0IEhBU19NT0RVTEVfUFJFTE9BRF9TVVBQT1JUID0gZmFsc2U7XHJcblxyXG5jb25zdCBzdXBwb3J0c01vZHVsZVByZWxvYWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKEhBU19NT0RVTEVfUFJFTE9BRF9TVVBQT1JUKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgcmVsTGlzdCB9ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblxyXG4gICAgSEFTX01PRFVMRV9QUkVMT0FEX1NVUFBPUlQgPSByZWxMaXN0XHJcbiAgICAgID8gcmVsTGlzdC5zdXBwb3J0cyhcIm1vZHVsZXByZWxvYWRcIilcclxuICAgICAgOiBmYWxzZTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIElnbm9yZSBmYWlsdXJlIHRvIGNoZWNrIGZvciBtb2R1bGVwcmVsb2FkIHN1cHBvcnRcclxuICB9XHJcblxyXG4gIHJldHVybiBIQVNfTU9EVUxFX1BSRUxPQURfU1VQUE9SVDtcclxufTtcclxuXHJcbmxldCBIQVNfV0VCUF9TVVBQT1JUID0gZmFsc2U7XHJcblxyXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNXZWJwID0gKCk6IGJvb2xlYW4gPT4ge1xyXG4gIGlmIChIQVNfV0VCUF9TVVBQT1JUKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIEhBU19XRUJQX1NVUFBPUlQgPSBkb2N1bWVudFxyXG4gICAgICAuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxyXG4gICAgICAudG9EYXRhVVJMKFwiaW1hZ2Uvd2VicFwiKVxyXG4gICAgICAuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2Uvd2VicFwiKTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIElnbm9yZSBmYWlsdXJlIHRvIGNoZWNrIGZvciBXZWJQIHN1cHBvcnRcclxuICB9XHJcblxyXG4gIHJldHVybiBIQVNfV0VCUF9TVVBQT1JUO1xyXG59O1xyXG5cclxuY29uc3Qgc3VwcG9ydHNJbWFnZVNyY1NldCA9ICgpOiBib29sZWFuID0+XHJcbiAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxyXG4gICAgSFRNTExpbmtFbGVtZW50LnByb3RvdHlwZSxcclxuICAgIFwiaW1hZ2VTcmNzZXRcIlxyXG4gICk7XHJcblxyXG5leHBvcnQgY29uc3QgcHJlbG9hZEltYWdlID0gKFxyXG4gIGltYWdlOiBzdHJpbmcsXHJcbiAgaWQ/OiBzdHJpbmcsXHJcbiAgZmV0Y2hQcmlvcml0eTogXCJhdXRvXCIgfCBcImhpZ2hcIiB8IFwibG93XCIgPSBcImhpZ2hcIlxyXG4pOiB2b2lkID0+IHtcclxuICBjb25zdCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24oaW1hZ2UpO1xyXG4gIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHJcbiAgbGluay5hcyA9IFwiaW1hZ2VcIjtcclxuICBpZiAoaWQpIGxpbmsuaWQgPSBpZDtcclxuICBsaW5rLmZldGNoUHJpb3JpdHkgPSBmZXRjaFByaW9yaXR5O1xyXG4gIGxpbmsucmVsID0gXCJwcmVsb2FkXCI7XHJcbiAgbGluay50eXBlID0gZ2V0TWltZVR5cGUoZXh0ZW5zaW9uKTtcclxuXHJcbiAgaWYgKGlzRHluYW1pY0ljb24oaW1hZ2UpKSB7XHJcbiAgICBpZiAoc3VwcG9ydHNJbWFnZVNyY1NldCgpKSB7XHJcbiAgICAgIGxpbmsuaW1hZ2VTcmNzZXQgPSBpbWFnZVNyY3MoaW1hZ2UsIDQ4LCBleHRlbnNpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgW2hyZWZdID0gaW1hZ2VTcmMoaW1hZ2UsIDQ4LCBnZXREcGkoKSwgZXh0ZW5zaW9uKS5zcGxpdChcIiBcIik7XHJcblxyXG4gICAgICBsaW5rLmhyZWYgPSBocmVmO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBsaW5rLmhyZWYgPSBpbWFnZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHByZWxvYWRlZExpbmtzID0gZ2V0UHJlbG9hZGVkTGlua3MoKTtcclxuXHJcbiAgaWYgKFxyXG4gICAgIXByZWxvYWRlZExpbmtzLnNvbWUoXHJcbiAgICAgIChwcmVsb2FkZWRMaW5rKSA9PlxyXG4gICAgICAgIChsaW5rLmltYWdlU3Jjc2V0ICYmXHJcbiAgICAgICAgICBwcmVsb2FkZWRMaW5rPy5pbWFnZVNyY3NldD8uZW5kc1dpdGgobGluay5pbWFnZVNyY3NldCkpIHx8XHJcbiAgICAgICAgKGxpbmsuaHJlZiAmJiBwcmVsb2FkZWRMaW5rPy5ocmVmPy5lbmRzV2l0aChsaW5rLmhyZWYpKVxyXG4gICAgKVxyXG4gICkge1xyXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQobGluayk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHByZWxvYWRMaWJzID0gKGxpYnM6IHN0cmluZ1tdID0gW10pOiB2b2lkID0+IHtcclxuICBjb25zdCBzY3JpcHRzID0gWy4uLmRvY3VtZW50LnNjcmlwdHNdO1xyXG4gIGNvbnN0IHByZWxvYWRlZExpbmtzID0gZ2V0UHJlbG9hZGVkTGlua3MoKTtcclxuXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tYXJyYXktY2FsbGJhY2stcmVmZXJlbmNlXHJcbiAgbGlicy5tYXAoZW5jb2RlVVJJKS5mb3JFYWNoKChsaWIpID0+IHtcclxuICAgIGlmIChcclxuICAgICAgc2NyaXB0cy5zb21lKChzY3JpcHQpID0+IHNjcmlwdC5zcmMuZW5kc1dpdGgobGliKSkgfHxcclxuICAgICAgcHJlbG9hZGVkTGlua3Muc29tZSgocHJlbG9hZGVkTGluaykgPT4gcHJlbG9hZGVkTGluay5ocmVmLmVuZHNXaXRoKGxpYikpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHJcbiAgICBsaW5rLmZldGNoUHJpb3JpdHkgPSBcImhpZ2hcIjtcclxuICAgIGxpbmsucmVsID0gXCJwcmVsb2FkXCI7XHJcbiAgICBsaW5rLmhyZWYgPSBsaWI7XHJcblxyXG4gICAgc3dpdGNoIChnZXRFeHRlbnNpb24obGliKSkge1xyXG4gICAgICBjYXNlIFwiLmNzc1wiOlxyXG4gICAgICAgIGxpbmsuYXMgPSBcInN0eWxlXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCIuaHRtXCI6XHJcbiAgICAgIGNhc2UgXCIuaHRtbFwiOlxyXG4gICAgICAgIGxpbmsucmVsID0gXCJwcmVyZW5kZXJcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIi5qc1wiOlxyXG4gICAgICAgIGlmIChzdXBwb3J0c01vZHVsZVByZWxvYWQoKSkge1xyXG4gICAgICAgICAgbGluay5yZWwgPSBcIm1vZHVsZXByZWxvYWRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCIuanNvblwiOlxyXG4gICAgICBjYXNlIFwiLndhc21cIjpcclxuICAgICAgICBsaW5rLmFzID0gXCJmZXRjaFwiO1xyXG4gICAgICAgIGxpbmsuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGxpbmsuYXMgPSBcInNjcmlwdFwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kKGxpbmspO1xyXG4gIH0pO1xyXG59O1xyXG5cclxudHlwZSBHSUZXaXRoV29ya2VycyA9IEdJRiAmIHsgZnJlZVdvcmtlcnM6IFdvcmtlcltdIH07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0R2lmSnMgPSBhc3luYyAoKTogUHJvbWlzZTxHSUZXaXRoV29ya2Vycz4gPT4ge1xyXG4gIGNvbnN0IHsgZGVmYXVsdDogR0lGSW5zdGFuY2UgfSA9IGF3YWl0IGltcG9ydChcImdpZi5qc1wiKTtcclxuXHJcbiAgcmV0dXJuIG5ldyBHSUZJbnN0YW5jZSh7XHJcbiAgICBxdWFsaXR5OiAxMCxcclxuICAgIHdvcmtlclNjcmlwdDogXCJTeXN0ZW0vZ2lmLmpzL2dpZi53b3JrZXIuanNcIixcclxuICAgIHdvcmtlcnM6IE1hdGgubWF4KE1hdGguZmxvb3IobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgLyA0KSwgMSksXHJcbiAgfSkgYXMgR0lGV2l0aFdvcmtlcnM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QganNvbkZldGNoID0gYXN5bmMgKFxyXG4gIHVybDogc3RyaW5nLFxyXG4gIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdFxyXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9PiB7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHsgLi4uSElHSF9QUklPUklUWV9SRVFVRVNULCAuLi5vcHRpb25zIH0pO1xyXG4gIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHJcbiAgcmV0dXJuIGpzb24gfHwge307XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVQcmV0dHlUaW1lc3RhbXAgPSAoKTogc3RyaW5nID0+XHJcbiAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoREVGQVVMVF9MT0NBTEUsIFRJTUVTVEFNUF9EQVRFX0ZPUk1BVClcclxuICAgIC5mb3JtYXQobmV3IERhdGUoKSlcclxuICAgIC5yZXBsYWNlKC9bLzpdL2csIFwiLVwiKVxyXG4gICAgLnJlcGxhY2UoXCIsXCIsIFwiXCIpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzRmlsZVN5c3RlbU1hcHBpbmdTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PlxyXG4gIHR5cGVvZiBGaWxlU3lzdGVtSGFuZGxlID09PSBcImZ1bmN0aW9uXCIgJiYgXCJzaG93RGlyZWN0b3J5UGlja2VyXCIgaW4gd2luZG93O1xyXG5cclxuZXhwb3J0IGNvbnN0IGhhc0ZpbmVQb2ludGVyID0gKCk6IGJvb2xlYW4gPT5cclxuICB3aW5kb3cubWF0Y2hNZWRpYShcIihwb2ludGVyOiBmaW5lKVwiKS5tYXRjaGVzO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzQmVmb3JlQmcgPSAoKTogYm9vbGVhbiA9PlxyXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFxyXG4gICAgXCItLWJlZm9yZS1iYWNrZ3JvdW5kLW9wYWNpdHlcIlxyXG4gICkgPT09IFwiMVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQmdQb3NpdGlvbiA9IChwb3NpdGlvbj86IHN0cmluZyk6IGAke251bWJlcn0lYCB8IFwiY2VudGVyXCIgPT4ge1xyXG4gIGlmICh0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9uTnVtID0gTnVtYmVyLnBhcnNlRmxvYXQocG9zaXRpb24pO1xyXG5cclxuICAgIGlmICghTnVtYmVyLmlzTmFOKHBvc2l0aW9uTnVtKSAmJiBwb3NpdGlvbk51bSA+PSAwICYmIHBvc2l0aW9uTnVtIDw9IDEwMCkge1xyXG4gICAgICByZXR1cm4gYCR7cG9zaXRpb25OdW19JWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gXCJjZW50ZXJcIjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0b1NvcnRlZCA9IDxUPihcclxuICBhcnJheTogVFtdLFxyXG4gIGNvbXBhcmVGbj86IChhOiBULCBiOiBUKSA9PiBudW1iZXJcclxuKTogVFtdID0+IFsuLi5hcnJheV0uc29ydChjb21wYXJlRm4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IG5vdEZvdW5kID0gKHJlc291cmNlOiBzdHJpbmcpOiB2b2lkID0+XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFsZXJ0XHJcbiAgYWxlcnQoYENhbid0IGZpbmQgJyR7cmVzb3VyY2V9Jy4gQ2hlY2sgdGhlIHNwZWxsaW5nIGFuZCB0cnkgYWdhaW4uYCk7XHJcblxyXG5leHBvcnQgY29uc3Qgc2hvdWxkQ2FwdHVyZURyYWdJbWFnZSA9IChcclxuICBlbnRyeUNvdW50OiBudW1iZXIsXHJcbiAgaXNEZXNrdG9wID0gZmFsc2VcclxuKTogYm9vbGVhbiA9PiBlbnRyeUNvdW50ID4gMSB8fCAoIWlzRGVza3RvcCAmJiBlbnRyeUNvdW50ID09PSAxICYmIGlzU2FmYXJpKCkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1heWJlUmVxdWVzdElkbGVDYWxsYmFjayA9IChcclxuICBjYWxsYmFjazogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cclxuKTogdm9pZCA9PiB7XHJcbiAgaWYgKFxyXG4gICAgXCJyZXF1ZXN0SWRsZUNhbGxiYWNrXCIgaW4gd2luZG93ICYmXHJcbiAgICB0eXBlb2Ygd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIlxyXG4gICkge1xyXG4gICAgcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkaXNwbGF5VmVyc2lvbiA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IHsgX19ORVhUX0RBVEFfXzogeyBidWlsZElkIH0gPSB7fSB9ID0gd2luZG93O1xyXG5cclxuICByZXR1cm4gYCR7UEFDS0FHRV9EQVRBLnZlcnNpb259JHtidWlsZElkID8gYC0ke2J1aWxkSWR9YCA6IFwiXCJ9YDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0RldiA9ICgpOiBib29sZWFuID0+IFwiX19uZXh0RGV2Q2xpZW50SWRcIiBpbiB3aW5kb3c7XHJcbiJdLCJuYW1lcyI6WyJiYXNlbmFtZSIsImRpcm5hbWUiLCJleHRuYW1lIiwiam9pbiIsIkRFRkFVTFRfTE9DQUxFIiwiREVTS1RPUF9QQVRIIiwiSElHSF9QUklPUklUWV9SRVFVRVNUIiwiSUNPTl9DQUNIRSIsIklDT05fUEFUSCIsIklDT05fUkVTX01BUCIsIk1BWF9JQ09OX1NJWkUiLCJNQVhfUkVTX0lDT05fT1ZFUlJJREUiLCJNSUxMSVNFQ09ORFNfSU5fU0VDT05EIiwiT05FX1RJTUVfUEFTU0lWRV9FVkVOVCIsIlBBQ0tBR0VfREFUQSIsIlBSRVZFTlRfU0NST0xMIiwiU0hPUlRDVVRfRVhURU5TSU9OIiwiU1VQUE9SVEVEX0lDT05fU0laRVMiLCJUQVNLQkFSX0hFSUdIVCIsIlRJTUVTVEFNUF9EQVRFX0ZPUk1BVCIsIlVTRVJfSUNPTl9QQVRIIiwiYnVmZmVyVG9CbG9iIiwiYnVmZmVyIiwidHlwZSIsIkJsb2IiLCJ1bmRlZmluZWQiLCJidWZmZXJUb1VybCIsIm1pbWVUeXBlIiwid2luZG93IiwiYnRvYSIsInRvU3RyaW5nIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiUkVTSVpFX0lNQUdFX1RJTUVPVVRfU0VDT05EUyIsInJlc2l6ZUltYWdlIiwiYmxvYiIsIm1heERpbWVuc2lvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwid29ya2VyIiwiV29ya2VyIiwidXJsIiwibmFtZSIsInRpbWVvdXRIYW5kbGUiLCJzZXRUaW1lb3V0IiwidGVybWluYXRlIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4iLCJhZGRFdmVudExpc3RlbmVyIiwiZGF0YSIsImNsZWFyVGltZW91dCIsInBvc3RNZXNzYWdlIiwiZHBpIiwiZ2V0RHBpIiwiTWF0aCIsIm1pbiIsImNlaWwiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0IiwiYmFzZU5hbWUiLCJzdGFydHNXaXRoIiwidG9Mb3dlckNhc2UiLCJzZW5kTW91c2VDbGljayIsInRhcmdldCIsImNvdW50IiwiZGlzcGF0Y2hFdmVudCIsIk1vdXNlRXZlbnQiLCJidWJibGVzIiwidmlzaWJsZVdpbmRvd3MiLCJ0b2dnbGVTaG93RGVza3RvcCIsInByb2Nlc3NlcyIsInN0YWNrT3JkZXIiLCJtaW5pbWl6ZSIsInJlc3RvcmVXaW5kb3dzIiwibGVuZ3RoIiwic29tZSIsInBpZCIsIm1pbmltaXplZCIsImFsbFdpbmRvd3MiLCJyZXZlcnNlIiwiZm9yRWFjaCIsImluY2x1ZGVzIiwicHVzaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNvbXBvbmVudFdpbmRvdyIsImZvY3VzIiwiaW1hZ2VTcmMiLCJpbWFnZVBhdGgiLCJzaXplIiwicmF0aW8iLCJleHRlbnNpb24iLCJpbWFnZU5hbWUiLCJleHBlY3RlZFNpemUiLCJtYXhJY29uU2l6ZSIsInJhdGlvU2l6ZSIsImltYWdlU2l6ZSIsInJlcGxhY2UiLCJpbWFnZVNyY3MiLCJmYWlsZWRVcmxzIiwic3JjcyIsImZpbHRlciIsInNwbGl0IiwiY3JlYXRlRmFsbGJhY2tTcmNTZXQiLCJzcmMiLCJzcmNFeHQiLCJmYWlsZWRTaXplcyIsIlNldCIsIm1hcCIsImZhaWxlZFVybCIsImZpbGVOYW1lIiwiTnVtYmVyIiwicG9zc2libGVTaXplcyIsImhhcyIsImJsb2JUb0Jhc2U2NCIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsImJsb2JUb0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJhcnJheUJ1ZmZlciIsImZldGNoQmxvYiIsImZldGNoIiwiY2FudmFzVG9CdWZmZXIiLCJ0b0RhdGFVUkwiLCJpbWdEYXRhVG9CdWZmZXIiLCJpbWFnZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsImdldENvbnRleHQiLCJwdXRJbWFnZURhdGEiLCJjbGVhblVwQnVmZmVyVXJsIiwicmV2b2tlT2JqZWN0VVJMIiwicm93QmxhbmsiLCJ5IiwieCIsImNvbHVtbkJsYW5rIiwidG9wIiwiYm90dG9tIiwidHJpbUNhbnZhc1RvVG9wTGVmdCIsImN0eCIsImFscGhhIiwiZGVzeW5jaHJvbml6ZWQiLCJ3aWxsUmVhZEZyZXF1ZW50bHkiLCJvd25lckRvY3VtZW50IiwiZ2V0SW1hZ2VEYXRhIiwicmlnaHQiLCJsZWZ0IiwidHJpbW1lZCIsImNvcHkiLCJjb3B5Q3R4IiwibG9hZFNjcmlwdCIsImRlZmVyIiwiZm9yY2UiLCJhc01vZHVsZSIsImNvbnRlbnRXaW5kb3ciLCJyZWplY3QiLCJsb2FkZWRTY3JpcHRzIiwic2NyaXB0cyIsImN1cnJlbnRTY3JpcHQiLCJmaW5kIiwibG9hZGVkU2NyaXB0IiwiZW5kc1dpdGgiLCJFdmVudCIsInJlbW92ZSIsInNjcmlwdCIsImFzeW5jIiwiZmV0Y2hQcmlvcml0eSIsImhlYWQiLCJhcHBlbmQiLCJsb2FkU3R5bGUiLCJocmVmIiwibG9hZGVkU3R5bGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImxvYWRlZFN0eWxlIiwibGluayIsInJlbCIsImxvYWRGaWxlcyIsImZpbGVzIiwicmVkdWNlIiwiX3Byb21pc2UiLCJmaWxlIiwiZW5jb2RlVVJJIiwiZ2V0SHRtbFRvSW1hZ2UiLCJodG1sVG9JbWFnZSIsInB4VG9OdW0iLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJ2aWV3SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJ2aWV3V2lkdGgiLCJpbm5lcldpZHRoIiwiZ2V0V2luZG93Vmlld3BvcnQiLCJjYWxjSW5pdGlhbFBvc2l0aW9uIiwib2Zmc2V0SGVpZ2h0IiwidmgiLCJ2dyIsIkdSSURfVEVNUExBVEVfUk9XUyIsImNhbGNHcmlkRHJvcFBvc2l0aW9uIiwiZ3JpZEVsZW1lbnQiLCJPYmplY3QiLCJjcmVhdGUiLCJncmlkQ29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJncmlkVGVtcGxhdGVSb3dzIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkUm93SGVpZ2h0IiwiZ3JpZENvbHVtbldpZHRoIiwiZ3JpZENvbHVtbkdhcCIsImdyaWRSb3dHYXAiLCJwYWRkaW5nVG9wIiwiZ3JpZENvbHVtblN0YXJ0IiwiZ3JpZFJvd1N0YXJ0Iiwic2F2ZVVucG9zaXRpb25lZERlc2t0b3BJY29ucyIsInNldEljb25Qb3NpdGlvbnMiLCJkZXNrdG9wSWNvbkdyaWQiLCJxdWVyeVNlbGVjdG9yIiwiSFRNTE9MaXN0RWxlbWVudCIsInVuUG9zaXRpb25lZEljb25zIiwic3R5bGUiLCJjb2x1bW5HYXAiLCJyb3dHYXAiLCJlbnRyeVdpZHRoIiwiZW50cnlIZWlnaHQiLCJyb3dUb3BQYWRkaW5nIiwibmV3SWNvblBvc2l0aW9ucyIsImZyb21FbnRyaWVzIiwiaWNvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJ1dHRvbiIsImdldEF0dHJpYnV0ZSIsInRleHRDb250ZW50Iiwicm91bmQiLCJjdXJyZW50SWNvblBvc2l0aW9ucyIsInVwZGF0ZUljb25Qb3NpdGlvbnNJZkVtcHR5IiwiaWNvblBvc2l0aW9ucyIsInNvcnRPcmRlcnMiLCJmaWxlT3JkZXIiLCJncmlkVGVtcGxhdGVSb3dDb3VudCIsImVudHJ5IiwiaW5kZXgiLCJlbnRyeVVybCIsImdyaWRFbnRyeSIsImNoaWxkcmVuIiwiZWxlbWVudCIsIkNTUyIsImVzY2FwZSIsIkhUTUxFbGVtZW50IiwicG9zaXRpb24iLCJrZXlzIiwiY2FsY0dyaWRQb3NpdGlvbk9mZnNldCIsInRhcmdldFVybCIsImdyaWREcm9wUG9zaXRpb24iLCJkcmFnZ2VkRW50cmllcyIsInRhcmdldEdyaWRDb2x1bW5TdGFydCIsInRhcmdldEdyaWRSb3dTdGFydCIsImluZGV4T2YiLCJnZXRJdGVyYXRlZE5hbWVzIiwiZmlsZUVudHJpZXMiLCJkaXJlY3RvcnkiLCJleGlzdHMiLCJhbGwiLCJmaWxlRW50cnkiLCJlbnRyeUl0ZXJhdGlvbiIsIml0ZXJhdGlvbiIsInVwZGF0ZUljb25Qb3NpdGlvbnMiLCJkcmFnUG9zaXRpb24iLCJ1cGRhdGVkSWNvblBvc2l0aW9ucyIsImNvbmZsaWN0aW5nSWNvbiIsImVudHJpZXMiLCJwcm9jZXNzSWNvbk1vdmUiLCJ0YXJnZXRGaWxlIiwiYWN0aXZlRWxlbWVudCIsImFkanVzdERyYWdnZWRFbnRyaWVzIiwiYWRqdXN0SWNvblBvc2l0aW9ucyIsImVudHJ5RmlsZSIsImNvbXBhcmVFbnRyeUZpbGUiLCJjb21wYXJlR3JpZENvbHVtblN0YXJ0IiwiY29tcGFyZUdyaWRSb3dTdGFydCIsImNvbmZsaWN0aW5nSWNvblBhdGgiLCJ0aGVuIiwicGF0aEV4aXN0cyIsImlzQ2FudmFzRHJhd24iLCJIVE1MQ2FudmFzRWxlbWVudCIsInBpeGVscyIsImJ3UGl4ZWxzIiwicGl4ZWwiLCJpc0JsYW5rQ2FudmFzIiwiYnl0ZXNJbktCIiwiYnl0ZXNJbk1CIiwiYnl0ZXNJbkdCIiwiYnl0ZXNJblRCIiwiZm9ybWF0TnVtYmVyIiwibnVtYmVyIiwicm91bmRVcE51bWJlciIsImZvcm1hdHRlZE51bWJlciIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMiLCJtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMiLCJmb3JtYXQiLCJ0b0ZpeGVkIiwic2xpY2UiLCJpbnRlZ2VyIiwiZGVjaW1hbCIsImdldEZvcm1hdHRlZFNpemUiLCJhc0tCIiwidGltZXpvbmVPZmZzZXQiLCJnZXRUWk9mZnNldElTT1N0cmluZyIsInRpbWVzdGFtcCIsInRpbWUiLCJkYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInRvSVNPU3RyaW5nIiwiTE9DQUxfSE9TVCIsIkdPT0dMRV9TRUFSQ0hfUVVFUlkiLCJnZXRVcmxPclNlYXJjaCIsImlucHV0IiwiaXNJcGZzIiwiaGFzSHR0cFNjaGVtYSIsImhhc1RsZCIsImlzTG9jYWxIb3N0IiwiZ2V0SXBmc0dhdGV3YXlVcmwiLCJJU19GSVJFRk9YIiwiaXNGaXJlZm94IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIklTX1NBRkFSSSIsImlzU2FmYXJpIiwiaGFsdEV2ZW50IiwiZXZlbnQiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjcmVhdGVPZmZzY3JlZW5DYW52YXMiLCJjb250YWluZXJFbGVtZW50IiwiY3VzdG9tU2l6ZSIsIm9mZnNldFdpZHRoIiwiZmxvb3IiLCJnZXRTZWFyY2hQYXJhbSIsInBhcmFtIiwiVVJMU2VhcmNoUGFyYW1zIiwibG9jYXRpb24iLCJzZWFyY2giLCJnZXQiLCJjbHN4IiwiY2xhc3NlcyIsImlzQWN0aXZlIiwiY2xhc3NOYW1lIiwibGFiZWwiLCJ0aXRsZSIsImlzWW91VHViZVVybCIsImdldFlvdVR1YmVVcmxJZCIsInBhdGhuYW1lIiwic2VhcmNoUGFyYW1zIiwicG9wIiwiZ2V0TWltZVR5cGUiLCJpc0R5bmFtaWNJY29uIiwiZ2V0UHJlbG9hZGVkTGlua3MiLCJIQVNfTU9EVUxFX1BSRUxPQURfU1VQUE9SVCIsInN1cHBvcnRzTW9kdWxlUHJlbG9hZCIsInJlbExpc3QiLCJzdXBwb3J0cyIsIkhBU19XRUJQX1NVUFBPUlQiLCJzdXBwb3J0c1dlYnAiLCJzdXBwb3J0c0ltYWdlU3JjU2V0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiSFRNTExpbmtFbGVtZW50IiwicHJlbG9hZEltYWdlIiwiaW1hZ2UiLCJpZCIsImFzIiwiaW1hZ2VTcmNzZXQiLCJwcmVsb2FkZWRMaW5rcyIsInByZWxvYWRlZExpbmsiLCJwcmVsb2FkTGlicyIsImxpYnMiLCJsaWIiLCJjcm9zc09yaWdpbiIsImdldEdpZkpzIiwiZGVmYXVsdCIsIkdJRkluc3RhbmNlIiwicXVhbGl0eSIsIndvcmtlclNjcmlwdCIsIndvcmtlcnMiLCJtYXgiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwianNvbkZldGNoIiwib3B0aW9ucyIsInJlc3BvbnNlIiwianNvbiIsImdlbmVyYXRlUHJldHR5VGltZXN0YW1wIiwiRGF0ZVRpbWVGb3JtYXQiLCJpc0ZpbGVTeXN0ZW1NYXBwaW5nU3VwcG9ydGVkIiwiRmlsZVN5c3RlbUhhbmRsZSIsImhhc0ZpbmVQb2ludGVyIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJpc0JlZm9yZUJnIiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VCZ1Bvc2l0aW9uIiwicG9zaXRpb25OdW0iLCJpc05hTiIsInRvU29ydGVkIiwiYXJyYXkiLCJjb21wYXJlRm4iLCJzb3J0Iiwibm90Rm91bmQiLCJyZXNvdXJjZSIsImFsZXJ0Iiwic2hvdWxkQ2FwdHVyZURyYWdJbWFnZSIsImVudHJ5Q291bnQiLCJpc0Rlc2t0b3AiLCJtYXliZVJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJkaXNwbGF5VmVyc2lvbiIsIl9fTkVYVF9EQVRBX18iLCJidWlsZElkIiwidmVyc2lvbiIsImlzRGV2Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/functions.ts\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId, fetchPriority) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises, fetchPriority);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/chunks/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("static/webpack/" + __webpack_require__.h() + ".e0d63f45eb8b53a4.hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("8948337a68f46a6c")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script),
/******/ 					createScriptURL: (url) => (url)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	(() => {
/******/ 		__webpack_require__.tu = (url) => (__webpack_require__.tt().createScriptURL(url));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"Stable Diffusion": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.u(chunkId)));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = (_, moreModules, runtime) => {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(pages-dir-browser)/./components/apps/StableDiffusion/sd.worker.ts");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;