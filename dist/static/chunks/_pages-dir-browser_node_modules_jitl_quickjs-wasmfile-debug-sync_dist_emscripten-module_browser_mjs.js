"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_jitl_quickjs-wasmfile-debug-sync_dist_emscripten-module_browser_mjs"],{

/***/ "(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.browser.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.browser.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\nvar QuickJSRaw = (() => {\n  var _scriptName = \"file:///C:/Users/User/Documents/Sites/Sites/em%20desenvolvimento/Portfolio2/node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.browser.mjs\";\n  \n  return (\nfunction(moduleArg = {}) {\n  var moduleRtn;\n\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = moduleArg;\n\n// Set up the promise that indicates the Module is initialized\nvar readyPromiseResolve, readyPromiseReject;\nvar readyPromise = new Promise((resolve, reject) => {\n  readyPromiseResolve = resolve;\n  readyPromiseReject = reject;\n});\n[\"_QTS_Throw\",\"_QTS_NewError\",\"_QTS_RuntimeSetMemoryLimit\",\"_QTS_RuntimeComputeMemoryUsage\",\"_QTS_RuntimeDumpMemoryUsage\",\"_QTS_RecoverableLeakCheck\",\"_QTS_BuildIsSanitizeLeak\",\"_QTS_RuntimeSetMaxStackSize\",\"_QTS_GetUndefined\",\"_QTS_GetNull\",\"_QTS_GetFalse\",\"_QTS_GetTrue\",\"_QTS_NewRuntime\",\"_QTS_FreeRuntime\",\"_QTS_NewContext\",\"_QTS_FreeContext\",\"_QTS_FreeValuePointer\",\"_QTS_FreeValuePointerRuntime\",\"_QTS_FreeVoidPointer\",\"_QTS_FreeCString\",\"_QTS_DupValuePointer\",\"_QTS_NewObject\",\"_QTS_NewObjectProto\",\"_QTS_NewArray\",\"_QTS_NewArrayBuffer\",\"_QTS_NewFloat64\",\"_QTS_GetFloat64\",\"_QTS_NewString\",\"_QTS_GetString\",\"_QTS_GetArrayBuffer\",\"_QTS_GetArrayBufferLength\",\"_QTS_NewSymbol\",\"_QTS_GetSymbolDescriptionOrKey\",\"_QTS_IsGlobalSymbol\",\"_QTS_IsJobPending\",\"_QTS_ExecutePendingJob\",\"_QTS_GetProp\",\"_QTS_GetPropNumber\",\"_QTS_SetProp\",\"_QTS_DefineProp\",\"_QTS_GetOwnPropertyNames\",\"_QTS_Call\",\"_QTS_ResolveException\",\"_QTS_Dump\",\"_QTS_Eval\",\"_QTS_GetModuleNamespace\",\"_QTS_Typeof\",\"_QTS_GetLength\",\"_QTS_IsEqual\",\"_QTS_GetGlobalObject\",\"_QTS_NewPromiseCapability\",\"_QTS_PromiseState\",\"_QTS_PromiseResult\",\"_QTS_TestStringArg\",\"_QTS_GetDebugLogEnabled\",\"_QTS_SetDebugLogEnabled\",\"_QTS_BuildIsDebug\",\"_QTS_BuildIsAsyncify\",\"_QTS_NewFunction\",\"_QTS_ArgvGetJSValueConstPointer\",\"_QTS_RuntimeEnableInterruptHandler\",\"_QTS_RuntimeDisableInterruptHandler\",\"_QTS_RuntimeEnableModuleLoader\",\"_QTS_RuntimeDisableModuleLoader\",\"_QTS_bjson_encode\",\"_QTS_bjson_decode\",\"_malloc\",\"_free\",\"_qts_host_call_function\",\"_qts_host_interrupt_handler\",\"_qts_host_load_module_source\",\"_qts_host_normalize_module\",\"___indirect_function_table\",\"onRuntimeInitialized\"].forEach((prop) => {\n  if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\n    Object.defineProperty(readyPromise, prop, {\n      get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n      set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n    });\n  }\n});\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n}\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-extension.js\n/* eslint-disable no-undef */\n// quickjs-emscripten code injected into emscripten-module.js\n// We use this to expose and patch up issues with Emscripten's source map handling...\nfunction quickjsEmscriptenInit(debugLog) {\n  const log = debugLog || function () {}\n  // Everything goes in a function so we can defer running until other variables\n  // are initialized in case they change.\n  const extension = { log }\n  for (const init of quickjsEmscriptenInit.inits) {\n    init(extension)\n  }\n  Module[\"quickJSEmscriptenExtensions\"] = extension\n  return extension\n}\nquickjsEmscriptenInit.inits = []\nModule[\"quickjsEmscriptenInit\"] = quickjsEmscriptenInit\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-extension.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-sourceMapJson.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  if (typeof receiveSourceMapJSON !== \"undefined\") {\n    extension[\"receiveSourceMapJSON\"] = (data) => {\n      if (typeof wasmSourceMap === \"undefined\") {\n        extension.log(\"receiveSourceMapJSON: received\", data)\n        return receiveSourceMapJSON(data)\n      } else {\n        extension.log(\"receiveSourceMapJSON: already have data:\", wasmSourceMap, \"ignoring\", data)\n      }\n    }\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-sourceMapJson.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmOffsetConverter.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  if (typeof WasmOffsetConverter !== \"undefined\") {\n    extension[\"WasmOffsetConverter\"] = WasmOffsetConverter\n    // Expose function to receive WasmOffsetConverter, set to wasmOffsetConverter local variable\n    // if it exists\n    try {\n      // Check if wasmOffsetConverter variable exists. If it isn't defined, this\n      // will throw and we'll skip the rest of the branch.\n      extension[\"existingWasmOffsetConverter\"] = wasmOffsetConverter\n      extension[\"receiveWasmOffsetConverter\"] = function (wasmBinary, wasmModule) {\n        if (!wasmOffsetConverter) {\n          extension.log(\"wasmOffsetConverter set\")\n          wasmOffsetConverter = new WasmOffsetConverter(wasmBinary, wasmModule)\n        } else {\n          extension.log(\"wasmOffsetConverter already set, ignored\")\n        }\n      }\n    } catch (error) {\n      // Nothing.\n      extension[\"receiveWasmOffsetConverter\"] = function () {\n        extension.log(\"wasmOffsetConverter variable not defined, this is a no-op\")\n      }\n    }\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmOffsetConverter.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmMemory.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  extension[\"getWasmMemory\"] = function () {\n    return wasmMemory\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmMemory.js\n\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_SHELL) {\n\n  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptName) {\n    scriptDirectory = _scriptName;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n  // they are removed because they could contain a slash.\n  if (scriptDirectory.startsWith('blob:')) {\n    scriptDirectory = '';\n  } else {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);\n  }\n\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  {\n// include: web_or_worker_shell_read.js\nif (ENVIRONMENT_IS_WORKER) {\n    readBinary = (url) => {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.responseType = 'arraybuffer';\n      xhr.send(null);\n      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n    };\n  }\n\n  readAsync = (url) => {\n    assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\n    return fetch(url, { credentials: 'same-origin' })\n      .then((response) => {\n        if (response.ok) {\n          return response.arrayBuffer();\n        }\n        return Promise.reject(new Error(response.status + ' : ' + response.url));\n      })\n  };\n// end include: web_or_worker_shell_read.js\n  }\n} else\n{\n  throw new Error('environment detection error');\n}\n\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.error.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used.\nmoduleOverrides = null;\ncheckIncomingModuleAPI();\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\n\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\nlegacyModuleProp('asm', 'wasmExports');\nlegacyModuleProp('readAsync', 'readAsync');\nlegacyModuleProp('readBinary', 'readBinary');\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\nassert(!ENVIRONMENT_IS_NODE, 'node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.');\n\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n\n// end include: shell.js\n\n// include: preamble.js\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\n\nif (typeof WebAssembly != 'object') {\n  err('no native wasm support detected');\n}\n\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\n\n// Memory management\n\nvar HEAP,\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\n// include: runtime_shared.js\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n}\n// end include: runtime_shared.js\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\n\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\n       'JS engine does not provide full typed array support');\n\n// In non-standalone/normal mode, we create the memory here.\n// include: runtime_init_memory.js\n// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');\n\n    assert(INITIAL_MEMORY >= 5242880, 'INITIAL_MEMORY should be larger than STACK_SIZE, was ' + INITIAL_MEMORY + '! (STACK_SIZE=' + 5242880 + ')');\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_MEMORY / 65536,\n      // In theory we should not need to emit the maximum if we want \"unlimited\"\n      // or 4GB of memory, but VMs error on that atm, see\n      // https://github.com/emscripten-core/emscripten/issues/14130\n      // And in the pthreads case we definitely need to emit a maximum. So\n      // always emit one.\n      'maximum': 2147483648 / 65536,\n    });\n  }\n\n  updateMemoryViews();\n\n// end include: runtime_init_memory.js\n\n// include: runtime_stack_check.js\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end();\n  assert((max & 3) == 0);\n  // If the stack ends at address zero we write our cookies 4 bytes into the\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n  // monitor writes to address zero.\n  if (max == 0) {\n    max += 4;\n  }\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[((max)>>2)] = 0x02135467;\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[((0)>>2)] = 1668509029;\n}\n\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end();\n  // See writeStackCookie().\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = HEAPU32[((max)>>2)];\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n  }\n}\n// end include: runtime_stack_check.js\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\n\nvar runtimeExited = false;\n\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n\n  checkStackCookie();\n\n  \nif (!Module['noFSInit'] && !FS.initialized)\n  FS.init();\nFS.ignorePermissions = false;\n\nTTY.init();\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction exitRuntime() {\n  assert(!runtimeExited);\n  checkStackCookie();\n  ___funcs_on_exit(); // Native atexit() functions\n  callRuntimeCallbacks(__ATEXIT__);\n  FS.quit();\nTTY.shutdown();\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(() => {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err(`dependency: ${dep}`);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  Module['onAbort']?.(what);\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  readyPromiseReject(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// include: URIUtils.js\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n/**\n * Indicates whether filename is a base64 data URI.\n * @noinline\n */\nvar isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */\nvar isFileURI = (filename) => filename.startsWith('file://');\n// end include: URIUtils.js\nfunction createExportWrapper(name, nargs) {\n  return (...args) => {\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n    assert(!runtimeExited, `native function \\`${name}\\` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)`);\n    var f = wasmExports[name];\n    assert(f, `exported native function \\`${name}\\` not found`);\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\n    return f(...args);\n  };\n}\n\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\nfunction findWasmBinary() {\n  if (Module['locateFile']) {\n    var f = 'emscripten-module.wasm';\n    if (!isDataURI(f)) {\n      return locateFile(f);\n    }\n    return f;\n  }\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n  return /* asset import */ new __webpack_require__.U(__webpack_require__(/*! emscripten-module.wasm */ \"(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.wasm\")).href;\n}\n\nvar wasmBinaryFile;\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw 'both async and sync fetching of the wasm failed';\n}\n\nfunction getBinaryPromise(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary\n      ) {\n    // Fetch the binary using readAsync\n    return readAsync(binaryFile).then(\n      (response) => new Uint8Array(/** @type{!ArrayBuffer} */(response)),\n      // Fall back to getBinarySync if readAsync fails\n      () => getBinarySync(binaryFile)\n    );\n  }\n\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return Promise.resolve().then(() => getBinarySync(binaryFile));\n}\n\nvar wasmSourceMap;\n// include: source_map_support.js\n/**\n * @constructor\n */\nfunction WasmSourceMap(sourceMap) {\n  this.version = sourceMap.version;\n  this.sources = sourceMap.sources;\n  this.names = sourceMap.names;\n\n  this.mapping = {};\n  this.offsets = [];\n\n  var vlqMap = {};\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach((c, i) => vlqMap[c] = i);\n\n  // based on https://github.com/Rich-Harris/vlq/blob/master/src/vlq.ts\n  function decodeVLQ(string) {\n    var result = [];\n    var shift = 0;\n    var value = 0;\n\n    for (var i = 0; i < string.length; ++i) {\n      var integer = vlqMap[string[i]];\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + string[i] + ')');\n      }\n\n      value += (integer & 31) << shift;\n\n      if (integer & 32) {\n        shift += 5;\n      } else {\n        var negate = value & 1;\n        value >>= 1;\n        result.push(negate ? -value : value);\n        value = shift = 0;\n      }\n    }\n    return result;\n  }\n\n  var offset = 0, src = 0, line = 1, col = 1, name = 0;\n  sourceMap.mappings.split(',').forEach(function (segment, index) {\n    if (!segment) return;\n    var data = decodeVLQ(segment);\n    var info = {};\n\n    offset += data[0];\n    if (data.length >= 2) info.source = src += data[1];\n    if (data.length >= 3) info.line = line += data[2];\n    if (data.length >= 4) info.column = col += data[3];\n    if (data.length >= 5) info.name = name += data[4];\n    this.mapping[offset] = info;\n    this.offsets.push(offset);\n  }, this);\n  this.offsets.sort((a, b) => a - b);\n}\n\nWasmSourceMap.prototype.lookup = function (offset) {\n  var normalized = this.normalizeOffset(offset);\n  if (!wasmOffsetConverter.isSameFunc(offset, normalized)) {\n    return null;\n  }\n  var info = this.mapping[normalized];\n  if (!info) {\n    return null;\n  }\n  return {\n    file: this.sources[info.source],\n    line: info.line,\n    column: info.column,\n    name: this.names[info.name],\n  };\n}\n\nWasmSourceMap.prototype.normalizeOffset = function (offset) {\n  var lo = 0;\n  var hi = this.offsets.length;\n  var mid;\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2);\n    if (this.offsets[mid] > offset) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return this.offsets[lo - 1];\n}\n\nvar wasmSourceMapFile = 'emscripten-module.wasm.map';\nif (!isDataURI(wasmSourceMapFile)) {\n  wasmSourceMapFile = locateFile(wasmSourceMapFile);\n}\n\nfunction getSourceMap() {\n  var buf = readBinary(wasmSourceMapFile);\n  return JSON.parse(UTF8ArrayToString(buf, 0, buf.length));\n}\n\nfunction getSourceMapPromise() {\n  if ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch == 'function') {\n    return fetch(wasmSourceMapFile, { credentials: 'same-origin' })\n      .then((response) => response.json())\n      .catch(getSourceMap);\n  }\n  return Promise.resolve(getSourceMap());\n}\n// end include: source_map_support.js\n\nvar wasmOffsetConverter;\n// include: wasm_offset_converter.js\n/** @constructor */\nfunction WasmOffsetConverter(wasmBytes, wasmModule) {\n  // This class parses a WASM binary file, and constructs a mapping from\n  // function indices to the start of their code in the binary file, as well\n  // as parsing the name section to allow conversion of offsets to function names.\n  //\n  // The main purpose of this module is to enable the conversion of function\n  // index and offset from start of function to an offset into the WASM binary.\n  // This is needed to look up the WASM source map as well as generate\n  // consistent program counter representations given v8's non-standard\n  // WASM stack trace format.\n  //\n  // v8 bug: https://crbug.com/v8/9172\n  //\n  // This code is also used to check if the candidate source map offset is\n  // actually part of the same function as the offset we are looking for,\n  // as well as providing the function names for a given offset.\n\n  // current byte offset into the WASM binary, as we parse it\n  // the first section starts at offset 8.\n  var offset = 8;\n\n  // the index of the next function we see in the binary\n  var funcidx = 0;\n\n  // map from function index to byte offset in WASM binary\n  this.offset_map = {};\n  this.func_starts = [];\n\n  // map from function index to names in WASM binary\n  this.name_map = {};\n\n  // number of imported functions this module has\n  this.import_functions = 0;\n\n  // the buffer unsignedLEB128 will read from.\n  var buffer = wasmBytes;\n\n  function unsignedLEB128() {\n    // consumes an unsigned LEB128 integer starting at `offset`.\n    // changes `offset` to immediately after the integer\n    var result = 0;\n    var shift = 0;\n    do {\n      var byte = buffer[offset++];\n      result += (byte & 0x7F) << shift;\n      shift += 7;\n    } while (byte & 0x80);\n    return result;\n  }\n\n  function skipLimits() {\n    var flags = unsignedLEB128();\n    unsignedLEB128(); // initial size\n    var hasMax = (flags & 1) != 0;\n    if (hasMax) {\n      unsignedLEB128();\n    }\n  }\n\n  binary_parse:\n  while (offset < buffer.length) {\n    var start = offset;\n    var type = buffer[offset++];\n    var end = unsignedLEB128() + offset;\n    switch (type) {\n      case 2: // import section\n        // we need to find all function imports and increment funcidx for each one\n        // since functions defined in the module are numbered after all imports\n        var count = unsignedLEB128();\n\n        while (count-- > 0) {\n          // skip module\n          offset = unsignedLEB128() + offset;\n          // skip name\n          offset = unsignedLEB128() + offset;\n\n          var kind = buffer[offset++];\n          switch (kind) {\n            case 0: // function import\n              ++funcidx;\n              unsignedLEB128(); // skip function type\n              break;\n            case 1: // table import\n              unsignedLEB128(); // skip elem type\n              skipLimits();\n              break;\n            case 2: // memory import\n              skipLimits();\n              break;\n            case 3: // global import\n              offset += 2; // skip type id byte and mutability byte\n              break;\n            case 4: // tag import\n              ++offset; // skip attribute\n              unsignedLEB128(); // skip tag type\n              break;\n            default: throw 'bad import kind: ' + kind;\n          }\n        }\n        this.import_functions = funcidx;\n        break;\n      case 10: // code section\n        var count = unsignedLEB128();\n        while (count-- > 0) {\n          var size = unsignedLEB128();\n          this.offset_map[funcidx++] = offset;\n          this.func_starts.push(offset);\n          offset += size;\n        }\n        break binary_parse;\n    }\n    offset = end;\n  }\n\n  var sections = WebAssembly.Module.customSections(wasmModule, \"name\");\n  var nameSection = sections.length ? sections[0] : undefined;\n  if (nameSection) {\n    buffer = new Uint8Array(nameSection);\n    offset = 0;\n    while (offset < buffer.length) {\n      var subsection_type = buffer[offset++];\n      var len = unsignedLEB128(); // byte count\n      if (subsection_type != 1) {\n        // Skip the whole sub-section if it's not a function name sub-section.\n        offset += len;\n        continue;\n      }\n      var count = unsignedLEB128();\n      while (count-- > 0) {\n        var index = unsignedLEB128();\n        var length = unsignedLEB128();\n        this.name_map[index] = UTF8ArrayToString(buffer, offset, length);\n        offset += length;\n      }\n    }\n  }\n}\n\nWasmOffsetConverter.prototype.convert = function (funcidx, offset) {\n  return this.offset_map[funcidx] + offset;\n}\n\nWasmOffsetConverter.prototype.getIndex = function (offset) {\n  var lo = 0;\n  var hi = this.func_starts.length;\n  var mid;\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2);\n    if (this.func_starts[mid] > offset) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo + this.import_functions - 1;\n}\n\nWasmOffsetConverter.prototype.isSameFunc = function (offset1, offset2) {\n  return this.getIndex(offset1) == this.getIndex(offset2);\n}\n\nWasmOffsetConverter.prototype.getName = function (offset) {\n  var index = this.getIndex(offset);\n  return this.name_map[index] || ('wasm-function[' + index + ']');\n}\n// end include: wasm_offset_converter.js\n\nfunction receiveSourceMapJSON(sourceMap) {\n  wasmSourceMap = new WasmSourceMap(sourceMap);\n  removeRunDependency('source-map');\n}\n\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\n  var savedBinary;\n  return getBinaryPromise(binaryFile).then((binary) => {\n    savedBinary = binary;\n    return WebAssembly.instantiate(binary, imports);\n  }).then((instance) => {\n    // wasmOffsetConverter needs to be assigned before calling the receiver\n    // (receiveInstantiationResult).  See comments below in instantiateAsync.\n    wasmOffsetConverter = new WasmOffsetConverter(savedBinary, instance.module);\n    return instance;\n  }).then(receiver, (reason) => {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n\n    // Warn on some common problems.\n    if (isFileURI(wasmBinaryFile)) {\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n    }\n    abort(reason);\n  });\n}\n\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\n  if (!binary &&\n      typeof WebAssembly.instantiateStreaming == 'function' &&\n      !isDataURI(binaryFile) &&\n      typeof fetch == 'function') {\n    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\n      // Suppress closure warning here since the upstream definition for\n      // instantiateStreaming only allows Promise<Repsponse> rather than\n      // an actual Response.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n      /** @suppress {checkTypes} */\n      var result = WebAssembly.instantiateStreaming(response, imports);\n\n      // We need the wasm binary for the offset converter. Clone the response\n      // in order to get its arrayBuffer (cloning should be more efficient\n      // than doing another entire request).\n      // (We must clone the response now in order to use it later, as if we\n      // try to clone it asynchronously lower down then we will get a\n      // \"response was already consumed\" error.)\n      var clonedResponsePromise = response.clone().arrayBuffer();\n\n      return result.then(\n        function(instantiationResult) {\n          // When using the offset converter, we must interpose here. First,\n          // the instantiation result must arrive (if it fails, the error\n          // handling later down will handle it). Once it arrives, we can\n          // initialize the offset converter. And only then is it valid to\n          // call receiveInstantiationResult, as that function will use the\n          // offset converter (in the case of pthreads, it will create the\n          // pthreads and send them the offsets along with the wasm instance).\n\n          clonedResponsePromise.then((arrayBufferResult) => {\n              wasmOffsetConverter = new WasmOffsetConverter(new Uint8Array(arrayBufferResult), instantiationResult.module);\n              callback(instantiationResult);\n            },\n            (reason) => err(`failed to initialize offset-converter: ${reason}`)\n          );\n        },\n        function(reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          err(`wasm streaming compile failed: ${reason}`);\n          err('falling back to ArrayBuffer instantiation');\n          return instantiateArrayBuffer(binaryFile, imports, callback);\n        });\n    });\n  }\n  return instantiateArrayBuffer(binaryFile, imports, callback);\n}\n\nfunction getWasmImports() {\n  // prepare imports\n  return {\n    'env': wasmImports,\n    'wasi_snapshot_preview1': wasmImports,\n  }\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  var info = getWasmImports();\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n\n    \n\n    addOnInit(wasmExports['__wasm_call_ctors']);\n\n    removeRunDependency('wasm-instantiate');\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency('wasm-instantiate');\n\n  addRunDependency('source-map');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\n    receiveInstance(result['instance']);\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module['instantiateWasm']) {\n    try {\n      return Module['instantiateWasm'](info, receiveInstance);\n    } catch(e) {\n      err(`Module.instantiateWasm callback failed with error: ${e}`);\n        // If instantiation fails, reject the module ready promise.\n        readyPromiseReject(e);\n    }\n  }\n\n  if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();\n\n  // If instantiation fails, reject the module ready promise.\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n  getSourceMapPromise().then(receiveSourceMapJSON);\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// include: runtime_debug.js\n// Endianness check\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n})();\n\nfunction legacyModuleProp(prop, newName, incoming=true) {\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      get() {\n        let extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\n        abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n\n      }\n    });\n  }\n}\n\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' ||\n         name === 'FS_createDataFile' ||\n         name === 'FS_createPreloadedFile' ||\n         name === 'FS_unlink' ||\n         name === 'addRunDependency' ||\n         // The old FS has some functionality that WasmFS lacks.\n         name === 'FS_createLazyFile' ||\n         name === 'FS_createDevice' ||\n         name === 'removeRunDependency';\n}\n\nfunction missingGlobal(sym, msg) {\n  if (typeof globalThis != 'undefined') {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get() {\n        warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n        return undefined;\n      }\n    });\n  }\n}\n\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\nmissingGlobal('asm', 'Please use wasmExports instead');\n\nfunction missingLibrarySymbol(sym) {\n  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get() {\n        // Can't `abort()` here because it would break code that does runtime\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n        var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n        // library.js, which means $name for a JS name with no prefix, or name\n        // for a JS name like _name.\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith('_')) {\n          librarySymbol = '$' + sym;\n        }\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        warnOnce(msg);\n        return undefined;\n      }\n    });\n  }\n  // Any symbol that is not included from the JS library is also (by definition)\n  // not exported on the Module object.\n  unexportedRuntimeSymbol(sym);\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get() {\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      }\n    });\n  }\n}\n\n// Used by XXXXX_DEBUG settings to output debug messages.\nfunction dbg(...args) {\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n  // logging to show up as warnings.\n  console.warn(...args);\n}\n// end include: runtime_debug.js\n// === Body ===\n\nfunction qts_host_call_function(ctx,this_ptr,argc,argv,magic_func_id) { const asyncify = undefined; return Module['callbacks']['callFunction'](asyncify, ctx, this_ptr, argc, argv, magic_func_id); }\nfunction qts_host_interrupt_handler(rt) { const asyncify = undefined; return Module['callbacks']['shouldInterrupt'](asyncify, rt); }\nfunction qts_host_load_module_source(rt,ctx,module_name) { const asyncify = undefined; const moduleNameString = UTF8ToString(module_name); return Module['callbacks']['loadModuleSource'](asyncify, rt, ctx, moduleNameString); }\nfunction qts_host_normalize_module(rt,ctx,module_base_name,module_name) { const asyncify = undefined; const moduleBaseNameString = UTF8ToString(module_base_name); const moduleNameString = UTF8ToString(module_name); return Module['callbacks']['normalizeModule'](asyncify, rt, ctx, moduleBaseNameString, moduleNameString); }\n\n// end include: preamble.js\n\n\n  /** @constructor */\n  function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n  \n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  \n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n  \n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        }\n      }\n      return str;\n    };\n\n  var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': return HEAP8[ptr];\n      case 'i8': return HEAP8[ptr];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      case '*': return HEAPU32[((ptr)>>2)];\n      default: abort(`invalid type for getValue: ${type}`);\n    }\n  }\n\n  var noExitRuntime = Module['noExitRuntime'] || false;\n\n  var ptrToString = (ptr) => {\n      assert(typeof ptr === 'number');\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return '0x' + ptr.toString(16).padStart(8, '0');\n    };\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': HEAP8[ptr] = value; break;\n      case 'i8': HEAP8[ptr] = value; break;\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\n      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\n      default: abort(`invalid type for setValue: ${type}`);\n    }\n  }\n\n  var stackRestore = (val) => __emscripten_stack_restore(val);\n\n  var stackSave = () => _emscripten_stack_get_current();\n\n  var warnOnce = (text) => {\n      warnOnce.shown ||= {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n  \n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n  var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n  var ___assert_fail = (condition, filename, line, func) => {\n      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n    };\n\n  var PATH = {\n  isAbs:(path) => path.charAt(0) === '/',\n  splitPath:(filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n  normalizeArray:(parts, allowAboveRoot) => {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n  normalize:(path) => {\n        var isAbsolute = PATH.isAbs(path),\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n  dirname:(path) => {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n  basename:(path) => {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },\n  join:(...paths) => PATH.normalize(paths.join('/')),\n  join2:(l, r) => PATH.normalize(l + '/' + r),\n  };\n  \n  var initRandomFill = () => {\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n        // for modern web browsers\n        return (view) => crypto.getRandomValues(view);\n      } else\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n      abort('no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };');\n    };\n  var randomFill = (view) => {\n      // Lazily init on the first invocation.\n      return (randomFill = initRandomFill())(view);\n    };\n  \n  \n  \n  var PATH_FS = {\n  resolve:(...args) => {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = (i >= 0) ? args[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n      },\n  relative:(from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      },\n  };\n  \n  \n  \n  var FS_stdin_getChar_buffer = [];\n  \n  var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7F) {\n          len++;\n        } else if (c <= 0x7FF) {\n          len += 2;\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\n          len += 4; ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n  \n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0))\n        return 0;\n  \n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n        }\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xC0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xE0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n          heap[outIdx++] = 0xF0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n  /** @type {function(string, boolean=, number=)} */\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n  }\n  var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != 'undefined' &&\n          typeof window.prompt == 'function') {\n          // Browser.\n          result = window.prompt('Input: ');  // returns null on cancel\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else\n        {}\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n  var TTY = {\n  ttys:[],\n  init() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process.stdin.setEncoding('utf8');\n        // }\n      },\n  shutdown() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process.stdin.pause();\n        // }\n      },\n  register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n  stream_ops:{\n  open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n  close(stream) {\n          // flush any pending line data\n          stream.tty.ops.fsync(stream.tty);\n        },\n  fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n  read(stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset+i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n  write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        },\n  },\n  default_tty_ops:{\n  get_char(tty) {\n          return FS_stdin_getChar();\n        },\n  put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },\n  fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        },\n  ioctl_tcgets(tty) {\n          // typical setting\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\n              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            ]\n          };\n        },\n  ioctl_tcsets(tty, optional_actions, data) {\n          // currently just ignore\n          return 0;\n        },\n  ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        },\n  },\n  default_tty1_ops:{\n  put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n  fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        },\n  },\n  };\n  \n  \n  var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n      return address;\n    };\n  \n  var alignMemory = (size, alignment) => {\n      assert(alignment, \"alignment argument is required\");\n      return Math.ceil(size / alignment) * alignment;\n    };\n  var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (!ptr) return 0;\n      return zeroMemory(ptr, size);\n    };\n  var MEMFS = {\n  ops_table:null,\n  mount(mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },\n  createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table ||= {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        };\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null; \n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n  getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },\n  expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n      },\n  resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n        }\n      },\n  node_ops:{\n  getattr(node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n  setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n  lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n  mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n  rename(old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now()\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n  unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n  rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n  readdir(node) {\n          var entries = ['.', '..'];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n  symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n  readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        },\n  },\n  stream_ops:{\n  read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n  write(stream, buffer, offset, length, position, canOwn) {\n          // The data buffer should be a typed array view\n          assert(!(buffer instanceof ArrayBuffer));\n          // If the buffer is located in main memory (HEAP), and if\n          // memory can grow, we can't hold on to references of the\n          // memory buffer, as they may get invalidated. That means we\n          // need to do copy its contents.\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n  \n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n  \n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n            if (canOwn) {\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n  \n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position+length);\n          if (node.contents.subarray && buffer.subarray) {\n            // Use typed array write which is available.\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n  llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n  allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n  mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            // We can't emulate MAP_SHARED when the file is not backed by the\n            // buffer we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              // Try to avoid unnecessary slices.\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(contents, position, position + length);\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n  msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        },\n  },\n  };\n  \n  /** @param {boolean=} noRunDep */\n  var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\n      readAsync(url).then(\n        (arrayBuffer) => {\n          assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file \"${url}\" failed.`;\n          }\n        }\n      );\n      if (dep) addRunDependency(dep);\n    };\n  \n  \n  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n  \n  var preloadPlugins = Module['preloadPlugins'] || [];\n  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      // Ensure plugins are ready.\n      if (typeof Browser != 'undefined') Browser.init();\n  \n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin['canHandle'](fullname)) {\n          plugin['handle'](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n      // TODO we should allow people to just pass in a complete filename instead\n      // of parent and name being that we just join them anyways\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\n      function processData(byteArray) {\n        function finish(byteArray) {\n          preFinish?.();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n          }\n          onload?.();\n          removeRunDependency(dep);\n        }\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n          onerror?.();\n          removeRunDependency(dep);\n        })) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == 'string') {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n  \n  var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        'r': 0,\n        'r+': 2,\n        'w': 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        'a': 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2,\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n  \n  var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n  \n  \n  \n  \n  \n  \n  var strError = (errno) => {\n      return UTF8ToString(_strerror(errno));\n    };\n  \n  var ERRNO_CODES = {\n      'EPERM': 63,\n      'ENOENT': 44,\n      'ESRCH': 71,\n      'EINTR': 27,\n      'EIO': 29,\n      'ENXIO': 60,\n      'E2BIG': 1,\n      'ENOEXEC': 45,\n      'EBADF': 8,\n      'ECHILD': 12,\n      'EAGAIN': 6,\n      'EWOULDBLOCK': 6,\n      'ENOMEM': 48,\n      'EACCES': 2,\n      'EFAULT': 21,\n      'ENOTBLK': 105,\n      'EBUSY': 10,\n      'EEXIST': 20,\n      'EXDEV': 75,\n      'ENODEV': 43,\n      'ENOTDIR': 54,\n      'EISDIR': 31,\n      'EINVAL': 28,\n      'ENFILE': 41,\n      'EMFILE': 33,\n      'ENOTTY': 59,\n      'ETXTBSY': 74,\n      'EFBIG': 22,\n      'ENOSPC': 51,\n      'ESPIPE': 70,\n      'EROFS': 69,\n      'EMLINK': 34,\n      'EPIPE': 64,\n      'EDOM': 18,\n      'ERANGE': 68,\n      'ENOMSG': 49,\n      'EIDRM': 24,\n      'ECHRNG': 106,\n      'EL2NSYNC': 156,\n      'EL3HLT': 107,\n      'EL3RST': 108,\n      'ELNRNG': 109,\n      'EUNATCH': 110,\n      'ENOCSI': 111,\n      'EL2HLT': 112,\n      'EDEADLK': 16,\n      'ENOLCK': 46,\n      'EBADE': 113,\n      'EBADR': 114,\n      'EXFULL': 115,\n      'ENOANO': 104,\n      'EBADRQC': 103,\n      'EBADSLT': 102,\n      'EDEADLOCK': 16,\n      'EBFONT': 101,\n      'ENOSTR': 100,\n      'ENODATA': 116,\n      'ETIME': 117,\n      'ENOSR': 118,\n      'ENONET': 119,\n      'ENOPKG': 120,\n      'EREMOTE': 121,\n      'ENOLINK': 47,\n      'EADV': 122,\n      'ESRMNT': 123,\n      'ECOMM': 124,\n      'EPROTO': 65,\n      'EMULTIHOP': 36,\n      'EDOTDOT': 125,\n      'EBADMSG': 9,\n      'ENOTUNIQ': 126,\n      'EBADFD': 127,\n      'EREMCHG': 128,\n      'ELIBACC': 129,\n      'ELIBBAD': 130,\n      'ELIBSCN': 131,\n      'ELIBMAX': 132,\n      'ELIBEXEC': 133,\n      'ENOSYS': 52,\n      'ENOTEMPTY': 55,\n      'ENAMETOOLONG': 37,\n      'ELOOP': 32,\n      'EOPNOTSUPP': 138,\n      'EPFNOSUPPORT': 139,\n      'ECONNRESET': 15,\n      'ENOBUFS': 42,\n      'EAFNOSUPPORT': 5,\n      'EPROTOTYPE': 67,\n      'ENOTSOCK': 57,\n      'ENOPROTOOPT': 50,\n      'ESHUTDOWN': 140,\n      'ECONNREFUSED': 14,\n      'EADDRINUSE': 3,\n      'ECONNABORTED': 13,\n      'ENETUNREACH': 40,\n      'ENETDOWN': 38,\n      'ETIMEDOUT': 73,\n      'EHOSTDOWN': 142,\n      'EHOSTUNREACH': 23,\n      'EINPROGRESS': 26,\n      'EALREADY': 7,\n      'EDESTADDRREQ': 17,\n      'EMSGSIZE': 35,\n      'EPROTONOSUPPORT': 66,\n      'ESOCKTNOSUPPORT': 137,\n      'EADDRNOTAVAIL': 4,\n      'ENETRESET': 39,\n      'EISCONN': 30,\n      'ENOTCONN': 53,\n      'ETOOMANYREFS': 141,\n      'EUSERS': 136,\n      'EDQUOT': 19,\n      'ESTALE': 72,\n      'ENOTSUP': 138,\n      'ENOMEDIUM': 148,\n      'EILSEQ': 25,\n      'EOVERFLOW': 61,\n      'ECANCELED': 11,\n      'ENOTRECOVERABLE': 56,\n      'EOWNERDEAD': 62,\n      'ESTRPIPE': 135,\n    };\n  var FS = {\n  root:null,\n  mounts:[],\n  devices:{\n  },\n  streams:[],\n  nextInode:1,\n  nameTable:null,\n  currentPath:\"/\",\n  initialized:false,\n  ignorePermissions:true,\n  ErrnoError:class extends Error {\n        // We set the `name` property to be able to identify `FS.ErrnoError`\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n        // - when using PROXYFS, an error can come from an underlying FS\n        // as different FS objects have their own FS.ErrnoError each,\n        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n        // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n        constructor(errno) {\n          super(runtimeInitialized ? strError(errno) : '');\n          // TODO(sbc): Use the inline member declaration syntax once we\n          // support it in acorn and closure.\n          this.name = 'ErrnoError';\n          this.errno = errno;\n          for (var key in ERRNO_CODES) {\n            if (ERRNO_CODES[key] === errno) {\n              this.code = key;\n              break;\n            }\n          }\n        }\n      },\n  genericErrors:{\n  },\n  filesystems:null,\n  syncFSRequests:0,\n  FSStream:class {\n        constructor() {\n          // TODO(https://github.com/emscripten-core/emscripten/issues/21414):\n          // Use inline field declarations.\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return (this.flags & 1024);\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n  FSNode:class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;  // root node sets parent to itself\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n  lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n  \n        if (!path) return { path: '', node: null };\n  \n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts)\n  \n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\n          throw new FS.ErrnoError(32);\n        }\n  \n        // split the absolute path\n        var parts = path.split('/').filter((p) => !!p);\n  \n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n  \n        for (var i = 0; i < parts.length; i++) {\n          var islast = (i === parts.length-1);\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n  \n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n  \n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n  \n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n  \n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n              current = lookup.node;\n  \n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n  \n        return { path: current_path, node: current };\n      },\n  getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n  hashName(parentid, name) {\n        var hash = 0;\n  \n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },\n  hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n  hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n  lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },\n  createNode(parent, name, mode, rdev) {\n        assert(typeof parent == 'object')\n        var node = new FS.FSNode(parent, name, mode, rdev);\n  \n        FS.hashAddNode(node);\n  \n        return node;\n      },\n  destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n  isRoot(node) {\n        return node === node.parent;\n      },\n  isMountpoint(node) {\n        return !!node.mounted;\n      },\n  isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n  isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n  isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n  isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n  isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n  isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n  isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n  flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if ((flag & 512)) {\n          perms += 'w';\n        }\n        return perms;\n      },\n  nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n  mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n  mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, 'wx');\n      },\n  mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n  mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n  MAX_OPEN_FDS:4096,\n  nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n  getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n  getStream:(fd) => FS.streams[fd],\n  createStream(stream, fd = -1) {\n        assert(fd >= -1);\n  \n        // clone it, so we can return an instance of FSStream\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n  closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n  dupStream(origStream, fd = -1) {\n        var stream = FS.createStream(origStream, fd);\n        stream.stream_ops?.dup?.(stream);\n        return stream;\n      },\n  chrdev_stream_ops:{\n  open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          stream.stream_ops.open?.(stream);\n        },\n  llseek() {\n          throw new FS.ErrnoError(70);\n        },\n  },\n  major:(dev) => ((dev) >> 8),\n  minor:(dev) => ((dev) & 0xff),\n  makedev:(ma, mi) => ((ma) << 8 | (mi)),\n  registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n  getDevice:(dev) => FS.devices[dev],\n  getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n  \n        while (check.length) {\n          var m = check.pop();\n  \n          mounts.push(m);\n  \n          check.push(...m.mounts);\n        }\n  \n        return mounts;\n      },\n  syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n  \n        FS.syncFSRequests++;\n  \n        if (FS.syncFSRequests > 1) {\n          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\n        }\n  \n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n  \n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n  \n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        };\n  \n        // sync all mounts\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n  mount(type, opts, mountpoint) {\n        if (typeof type == 'string') {\n          // The filesystem was not included, and instead we have an error\n          // message stored in the variable.\n          throw type;\n        }\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n  \n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n          mountpoint = lookup.path;  // use the absolute path\n          node = lookup.node;\n  \n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n  \n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n  \n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: []\n        };\n  \n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n  \n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n  \n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n  \n        return mountRoot;\n      },\n  unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n  \n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n  \n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n  \n          while (current) {\n            var next = current.name_next;\n  \n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n  \n            current = next;\n          }\n        });\n  \n        // no longer a mountpoint\n        node.mounted = null;\n  \n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n  lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n  mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n  create(path, mode) {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n  mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n  mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch(e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n  mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n  symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n  rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n  \n        // let the errors from non existent directories percolate up\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n  \n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        errCode = new_node ?\n          FS.mayDelete(new_dir, new_name, isdir) :\n          FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(10);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          // update old node (we do this here to avoid each backend \n          // needing to)\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n      },\n  rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n  readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n  unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n  readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n  stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n  lstat(path) {\n        return FS.stat(path, true);\n      },\n  chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now()\n        });\n      },\n  lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n  fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n  chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },\n  lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n  fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n  truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n  ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n  utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n  open(path, flags, mode) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if ((flags & 64)) {\n          mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if ((flags & 64)) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // do truncation if necessary\n        if ((flags & 512) && !created) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512 | 131072);\n  \n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),  // we want the absolute path to the node\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n  close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n  isClosed(stream) {\n        return stream.fd === null;\n      },\n  llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n  read(stream, buffer, offset, length, position) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n  write(stream, buffer, offset, length, position, canOwn) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n  allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n  mmap(stream, length, position, prot, flags) {\n        // User requests writing to file (prot & PROT_WRITE != 0).\n        // Checking if we have permissions to write to the file unless\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\n        // as all modifications will be visible only in the memory of\n        // the current process.\n        if ((prot & 2) !== 0\n            && (flags & 2) === 0\n            && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n  msync(stream, buffer, offset, length, mmapFlags) {\n        assert(offset >= 0);\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n  ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n  readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n  writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n  cwd:() => FS.currentPath,\n  chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n  createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n  createDefaultDevices() {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using err() rather than out()\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        // use a buffer to avoid overhead of individual crypto calls per byte\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n  createSpecialDirectories() {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n        // name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount() {\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\n            node.node_ops = {\n              lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStreamChecked(fd);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: () => stream.path },\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },\n  createStandardStreams(input, output, error) {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n  \n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (input) {\n          FS.createDevice('/dev', 'stdin', input);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (output) {\n          FS.createDevice('/dev', 'stdout', null, output);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (error) {\n          FS.createDevice('/dev', 'stderr', null, error);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n  \n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n      },\n  staticInit() {\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n  \n        FS.nameTable = new Array(4096);\n  \n        FS.mount(MEMFS, {}, '/');\n  \n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n  \n        FS.filesystems = {\n          'MEMFS': MEMFS,\n        };\n      },\n  init(input, output, error) {\n        assert(!FS.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\n        FS.initialized = true;\n  \n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        input ??= Module['stdin'];\n        output ??= Module['stdout'];\n        error ??= Module['stderr'];\n  \n        FS.createStandardStreams(input, output, error);\n      },\n  quit() {\n        FS.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        _fflush(0);\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n  findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n  analyzePath(path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n          parentExists: false, parentPath: null, parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        };\n        return ret;\n      },\n  createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },\n  createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n  createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n  createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            // flush any pending line data\n            if (output?.buffer?.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset+i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n  forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else { // Command-line.\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n  createLazyFile(parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array).\n        // Actual getting is abstracted away for eventual reuse.\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = []; // Loaded chunks. Index is the chunk number\n          }\n          get(idx) {\n            if (idx > this.length-1 || idx < 0) {\n              return undefined;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = (idx / this.chunkSize)|0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            // Find length\n            var xhr = new XMLHttpRequest();\n            xhr.open('HEAD', url, false);\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n            var header;\n            var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n            var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n  \n            var chunkSize = 1024*1024; // Chunk size in bytes\n  \n            if (!hasByteServing) chunkSize = datalength;\n  \n            // Function to get a range from the remote URL.\n            var doXHR = (from, to) => {\n              if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n              if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n  \n              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', url, false);\n              if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n  \n              // Some hints to the browser that we want binary data.\n              xhr.responseType = 'arraybuffer';\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\n              }\n  \n              xhr.send(null);\n              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n              if (xhr.response !== undefined) {\n                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\n              }\n              return intArrayFromString(xhr.responseText || '', true);\n            };\n            var lazyArray = this;\n            lazyArray.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum+1) * chunkSize - 1; // including this byte\n              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\n              return lazyArray.chunks[chunkNum];\n            });\n  \n            if (usesGzip || !datalength) {\n              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n            }\n  \n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n  \n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n  \n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() { return this.contents.length; }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        // use a custom read function\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position)\n        };\n        // use a custom mmap function\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n  absolutePath() {\n        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\n      },\n  createFolder() {\n        abort('FS.createFolder has been removed; use FS.mkdir instead');\n      },\n  createLink() {\n        abort('FS.createLink has been removed; use FS.symlink instead');\n      },\n  joinPath() {\n        abort('FS.joinPath has been removed; use PATH.join instead');\n      },\n  mmapAlloc() {\n        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\n      },\n  standardizePath() {\n        abort('FS.standardizePath has been removed; use PATH.normalize instead');\n      },\n  };\n  \n  var SYSCALLS = {\n  DEFAULT_POLLMASK:5,\n  calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);;\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n  doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[((buf)>>2)] = stat.dev;\n        HEAP32[(((buf)+(4))>>2)] = stat.mode;\n        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;\n        HEAP32[(((buf)+(12))>>2)] = stat.uid;\n        HEAP32[(((buf)+(16))>>2)] = stat.gid;\n        HEAP32[(((buf)+(20))>>2)] = stat.rdev;\n        (tempI64 = [stat.size>>>0,(tempDouble = stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(24))>>2)] = tempI64[0],HEAP32[(((buf)+(28))>>2)] = tempI64[1]);\n        HEAP32[(((buf)+(32))>>2)] = 4096;\n        HEAP32[(((buf)+(36))>>2)] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble = Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000;\n        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble = Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000;\n        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble = Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000;\n        (tempI64 = [stat.ino>>>0,(tempDouble = stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);\n        return 0;\n      },\n  doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n  getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n  varargs:undefined,\n  getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n  };\n  function ___syscall_dup(fd) {\n  try {\n  \n      var old = SYSCALLS.getStreamFromFD(fd);\n      return FS.dupStream(old).fd;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  function ___syscall_mkdirat(dirfd, path, mode) {\n  try {\n  \n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      // remove a trailing slash, if one - /a/b/ has basename of '', but\n      // we want to create b in the context of this function\n      path = PATH.normalize(path);\n      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);\n      FS.mkdir(path, mode, 0);\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  function syscallGetVarargI() {\n      assert(SYSCALLS.varargs != undefined);\n      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\n      var ret = HEAP32[((+SYSCALLS.varargs)>>2)];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n  \n  function ___syscall_openat(dirfd, path, flags, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n  \n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      var mode = varargs ? syscallGetVarargI() : 0;\n      return FS.open(path, flags, mode).fd;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  function ___syscall_stat64(path, buf) {\n  try {\n  \n      path = SYSCALLS.getStr(path);\n      return SYSCALLS.doStat(FS.stat, path, buf);\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  var __abort_js = () => {\n      abort('native code called abort()');\n    };\n\n  var nowIsMonotonic = 1;\n  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;\n\n  var getExecutableName = () => {\n      return thisProgram || './this.program';\n    };\n  \n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n  var __emscripten_get_progname = (str, len) => {\n      stringToUTF8(getExecutableName(), str, len);\n    };\n\n  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n\n  \n  \n  /** @suppress{checkTypes} */\n  var withBuiltinMalloc = (func) => {\n      var prev_malloc = typeof _malloc != 'undefined' ? _malloc : undefined;\n      var prev_memalign = typeof _memalign != 'undefined' ? _memalign : undefined;\n      var prev_free = typeof _free != 'undefined' ? _free : undefined;\n      _malloc = _emscripten_builtin_malloc;\n      _memalign = _emscripten_builtin_memalign;\n      _free = _emscripten_builtin_free;\n      try {\n        return func();\n      } finally {\n        _malloc = prev_malloc;\n        _memalign = prev_memalign;\n        _free = prev_free;\n      }\n    };\n  \n  \n  \n  var stringToNewUTF8 = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = _malloc(size);\n      if (ret) stringToUTF8(str, ret, size);\n      return ret;\n    };\n  \n  \n  var __emscripten_sanitizer_get_option = (name) => {\n      return withBuiltinMalloc(() => stringToNewUTF8(Module[UTF8ToString(name)] || \"\"));\n    };\n\n  var __emscripten_sanitizer_use_colors = () => {\n      var setting = Module['printWithColors'];\n      if (setting !== undefined) {\n        return setting;\n      }\n      return ENVIRONMENT_IS_NODE && process.stderr.isTTY;\n    };\n\n  var isLeapYear = (year) => year%4 === 0 && (year%100 !== 0 || year%400 === 0);\n  \n  var MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];\n  \n  var MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];\n  var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = (leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE);\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1\n  \n      return yday;\n    };\n  \n  var convertI32PairToI53Checked = (lo, hi) => {\n      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32\n      assert(hi === (hi|0));                    // hi should be a i32\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n  function __localtime_js(time_low, time_high,tmPtr) {\n    var time = convertI32PairToI53Checked(time_low, time_high);\n  \n    \n      var date = new Date(time*1000);\n      HEAP32[((tmPtr)>>2)] = date.getSeconds();\n      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();\n      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();\n      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();\n      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();\n      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;\n      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();\n  \n      var yday = ydayFromDate(date)|0;\n      HEAP32[(((tmPtr)+(28))>>2)] = yday;\n      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);\n  \n      // Attention: DST is in December in South, and some regions don't have DST at all.\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;\n      HEAP32[(((tmPtr)+(32))>>2)] = dst;\n    ;\n  }\n\n  \n  \n  \n  \n  \n  function __mmap_js(len,prot,flags,fd,offset_low, offset_high,allocated,addr) {\n    var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  \n    \n  try {\n  \n      if (isNaN(offset)) return 61;\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var res = FS.mmap(stream, len, offset, prot, flags);\n      var ptr = res.ptr;\n      HEAP32[((allocated)>>2)] = res.allocated;\n      HEAPU32[((addr)>>2)] = ptr;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  ;\n  }\n\n  \n  function __munmap_js(addr,len,prot,flags,fd,offset_low, offset_high) {\n    var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  \n    \n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      if (prot & 2) {\n        SYSCALLS.doMsync(addr, stream, len, flags, offset);\n      }\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  ;\n  }\n\n  \n  var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      // TODO: Use (malleable) environment variables instead of system settings.\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n  \n      // Local standard timezone offset. Local standard time is not adjusted for\n      // daylight savings.  This code uses the fact that getTimezoneOffset returns\n      // a greater value during Standard Time versus Daylight Saving Time (DST).\n      // Thus it determines the expected output during Standard Time, and it\n      // compares whether the output of the given date the same (Standard) or less\n      // (DST).\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n  \n      // timezone is specified as seconds west of UTC (\"The external variable\n      // `timezone` shall be set to the difference, in seconds, between\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\n      // as returned by stdTimezoneOffset.\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;\n  \n      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);\n  \n      var extractZone = (timezoneOffset) => {\n        // Why inverse sign?\n        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n        var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\n  \n        var absOffset = Math.abs(timezoneOffset)\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\n        var minutes = String(absOffset % 60).padStart(2, \"0\");\n  \n        return `UTC${sign}${hours}${minutes}`;\n      }\n  \n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      assert(winterName);\n      assert(summerName);\n      assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`);\n      assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`);\n      if (summerOffset < winterOffset) {\n        // Northern hemisphere\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n\n  var _emscripten_date_now = () => Date.now();\n\n  var getHeapMax = () =>\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      2147483648;\n  var _emscripten_get_heap_max = () => getHeapMax();\n\n  var _emscripten_get_now;\n      // Modern environment where performance.now() is supported:\n      // N.B. a shorter form \"_emscripten_get_now = performance.now;\" is\n      // unfortunately not allowed even in current browsers (e.g. FF Nightly 75).\n      _emscripten_get_now = () => performance.now();\n  ;\n\n  var UNWIND_CACHE = {\n  };\n  \n  /** @returns {number} */\n  var convertFrameToPC = (frame) => {\n      assert(wasmOffsetConverter);\n      var match;\n  \n      if (match = /\\bwasm-function\\[\\d+\\]:(0x[0-9a-f]+)/.exec(frame)) {\n        // some engines give the binary offset directly, so we use that as return address\n        return +match[1];\n      } else if (match = /\\bwasm-function\\[(\\d+)\\]:(\\d+)/.exec(frame)) {\n        // other engines only give function index and offset in the function,\n        // so we try using the offset converter. If that doesn't work,\n        // we pack index and offset into a \"return address\"\n        return wasmOffsetConverter.convert(+match[1], +match[2]);\n      } else if (match = /:(\\d+):\\d+(?:\\)|$)/.exec(frame)) {\n        // If we are in js, we can use the js line number as the \"return address\".\n        // This should work for wasm2js.  We tag the high bit to distinguish this\n        // from wasm addresses.\n        return 0x80000000 | +match[1];\n      }\n      // return 0 if we can't find any\n      return 0;\n    };\n  var convertPCtoSourceLocation = (pc) => {\n      if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;\n  \n      var match;\n      var source;\n      if (wasmSourceMap) {\n        source = wasmSourceMap.lookup(pc);\n      }\n  \n      if (!source) {\n        var frame = UNWIND_CACHE[pc];\n        if (!frame) return null;\n        // Example: at callMain (a.out.js:6335:22)\n        if (match = /\\((.*):(\\d+):(\\d+)\\)$/.exec(frame)) {\n          source = {file: match[1], line: match[2], column: match[3]};\n        // Example: main@a.out.js:1337:42\n        } else if (match = /@(.*):(\\d+):(\\d+)/.exec(frame)) {\n          source = {file: match[1], line: match[2], column: match[3]};\n        }\n      }\n      UNWIND_CACHE.last_get_source_pc = pc;\n      UNWIND_CACHE.last_source = source;\n      return source;\n    };\n  var _emscripten_pc_get_column = (pc) => {\n      var result = convertPCtoSourceLocation(pc);\n      return result ? result.column || 0 : 0;\n    };\n\n  \n  \n  \n  var _emscripten_pc_get_file = (pc) => withBuiltinMalloc(() => {\n      var result = convertPCtoSourceLocation(pc);\n      if (!result) return 0;\n  \n      if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);\n      _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);\n      return _emscripten_pc_get_file.ret;\n    });\n\n  \n  \n  \n  var _emscripten_pc_get_function = (pc) => withBuiltinMalloc(() => {\n      var name;\n      if (pc & 0x80000000) {\n        // If this is a JavaScript function, try looking it up in the unwind cache.\n        var frame = UNWIND_CACHE[pc];\n        if (!frame) return 0;\n  \n        var match;\n        if (match = /^\\s+at (.*) \\(.*\\)$/.exec(frame)) {\n          name = match[1];\n        } else if (match = /^(.+?)@/.exec(frame)) {\n          name = match[1];\n        } else {\n          return 0;\n        }\n      } else {\n        name = wasmOffsetConverter.getName(pc);\n      }\n      if (_emscripten_pc_get_function.ret) _free(_emscripten_pc_get_function.ret);\n      _emscripten_pc_get_function.ret = stringToNewUTF8(name);\n      return _emscripten_pc_get_function.ret;\n    });\n\n  var _emscripten_pc_get_line = (pc) => {\n      var result = convertPCtoSourceLocation(pc);\n      return result ? result.line : 0;\n    };\n\n  \n  \n  var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\n        updateMemoryViews();\n        return 1 /*success*/;\n      } catch(e) {\n        err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    };\n  var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      // With multithreaded builds, races can happen (another thread might increase the size\n      // in between), so return a failure, and let the caller retry.\n      assert(requestedSize > oldSize);\n  \n      // Memory resize rules:\n      // 1.  Always increase heap size to at least the requested size, rounded up\n      //     to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n      //     geometrically: increase the heap size according to\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n      //     linearly: increase the heap size by at least\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4.  If we were unable to allocate as much memory, it may be due to\n      //     over-eager decision to excessively reserve due to (3) above.\n      //     Hence if an allocation fails, cut down on the amount of excess\n      //     growth, in an attempt to succeed to perform a smaller allocation.\n  \n      // A limit is set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\n        return false;\n      }\n  \n      // Loop through potential heap size increases. If we attempt a too eager\n      // reservation that fails, cut down on the attempted size and reserve a\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n  \n        var replacement = growMemory(newSize);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n      return false;\n    };\n\n  \n  \n  \n  var saveInUnwindCache = (callstack) => {\n      callstack.forEach((frame) => {\n        var pc = convertFrameToPC(frame);\n        if (pc) {\n          UNWIND_CACHE[pc] = frame;\n        }\n      });\n    };\n  \n  function jsStackTrace() {\n      return new Error().stack.toString();\n    }\n  function _emscripten_stack_snapshot() {\n      var callstack = jsStackTrace().split('\\n');\n      if (callstack[0] == 'Error') {\n        callstack.shift();\n      }\n      saveInUnwindCache(callstack);\n  \n      // Caches the stack snapshot so that emscripten_stack_unwind_buffer() can\n      // unwind from this spot.\n      UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);\n      UNWIND_CACHE.last_stack = callstack;\n      return UNWIND_CACHE.last_addr;\n    }\n\n  \n  \n  \n  var _emscripten_stack_unwind_buffer = (addr, buffer, count) => {\n      var stack;\n      if (UNWIND_CACHE.last_addr == addr) {\n        stack = UNWIND_CACHE.last_stack;\n      } else {\n        stack = jsStackTrace().split('\\n');\n        if (stack[0] == 'Error') {\n          stack.shift();\n        }\n        saveInUnwindCache(stack);\n      }\n  \n      var offset = 3;\n      while (stack[offset] && convertFrameToPC(stack[offset]) != addr) {\n        ++offset;\n      }\n  \n      for (var i = 0; i < count && stack[i+offset]; ++i) {\n        HEAP32[(((buffer)+(i*4))>>2)] = convertFrameToPC(stack[i + offset]);\n      }\n      return i;\n    };\n\n  function _fd_close(fd) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  /** @param {number=} offset */\n  var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n  \n  function _fd_read(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doReadv(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  \n  function _fd_seek(fd,offset_low, offset_high,whence,newOffset) {\n    var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  \n    \n  try {\n  \n      if (isNaN(offset)) return 61;\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.llseek(stream, offset, whence);\n      (tempI64 = [stream.position>>>0,(tempDouble = stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  ;\n  }\n\n  /** @param {number=} offset */\n  var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          // No more space to write.\n          break;\n        }\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n  \n  function _fd_write(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doWritev(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  \n  var runtimeKeepaliveCounter = 0;\n  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\n  var _proc_exit = (code) => {\n      EXITSTATUS = code;\n      if (!keepRuntimeAlive()) {\n        Module['onExit']?.(code);\n        ABORT = true;\n      }\n      quit_(code, new ExitStatus(code));\n    };\n\n  var getCFunc = (ident) => {\n      var func = Module['_' + ident]; // closure exported function\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    };\n  \n  \n  var writeArrayToMemory = (array, buffer) => {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n      HEAP8.set(array, buffer);\n    };\n  \n  \n  \n  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n  var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n  \n  \n  \n  \n  \n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n  var ccall = (ident, returnType, argTypes, args, opts) => {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) { // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        'array': (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n  \n      function convertReturnValue(ret) {\n        if (returnType === 'string') {\n          \n          return UTF8ToString(ret);\n        }\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n  \n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func(...cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n  \n      ret = onDone(ret);\n      return ret;\n    };\n  \n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n  var cwrap = (ident, returnType, argTypes, opts) => {\n      return (...args) => ccall(ident, returnType, argTypes, args, opts);\n    };\n\n\n\n\n  FS.createPreloadedFile = FS_createPreloadedFile;\n  FS.staticInit();\n  // Set module methods based on EXPORTED_RUNTIME_METHODS\n  ;\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\nvar wasmImports = {\n  /** @export */\n  __assert_fail: ___assert_fail,\n  /** @export */\n  __syscall_dup: ___syscall_dup,\n  /** @export */\n  __syscall_mkdirat: ___syscall_mkdirat,\n  /** @export */\n  __syscall_openat: ___syscall_openat,\n  /** @export */\n  __syscall_stat64: ___syscall_stat64,\n  /** @export */\n  _abort_js: __abort_js,\n  /** @export */\n  _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n  /** @export */\n  _emscripten_get_progname: __emscripten_get_progname,\n  /** @export */\n  _emscripten_memcpy_js: __emscripten_memcpy_js,\n  /** @export */\n  _emscripten_sanitizer_get_option: __emscripten_sanitizer_get_option,\n  /** @export */\n  _emscripten_sanitizer_use_colors: __emscripten_sanitizer_use_colors,\n  /** @export */\n  _localtime_js: __localtime_js,\n  /** @export */\n  _mmap_js: __mmap_js,\n  /** @export */\n  _munmap_js: __munmap_js,\n  /** @export */\n  _tzset_js: __tzset_js,\n  /** @export */\n  emscripten_date_now: _emscripten_date_now,\n  /** @export */\n  emscripten_get_heap_max: _emscripten_get_heap_max,\n  /** @export */\n  emscripten_get_now: _emscripten_get_now,\n  /** @export */\n  emscripten_pc_get_column: _emscripten_pc_get_column,\n  /** @export */\n  emscripten_pc_get_file: _emscripten_pc_get_file,\n  /** @export */\n  emscripten_pc_get_function: _emscripten_pc_get_function,\n  /** @export */\n  emscripten_pc_get_line: _emscripten_pc_get_line,\n  /** @export */\n  emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */\n  emscripten_stack_snapshot: _emscripten_stack_snapshot,\n  /** @export */\n  emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,\n  /** @export */\n  fd_close: _fd_close,\n  /** @export */\n  fd_read: _fd_read,\n  /** @export */\n  fd_seek: _fd_seek,\n  /** @export */\n  fd_write: _fd_write,\n  /** @export */\n  memory: wasmMemory,\n  /** @export */\n  proc_exit: _proc_exit,\n  /** @export */\n  qts_host_call_function,\n  /** @export */\n  qts_host_interrupt_handler,\n  /** @export */\n  qts_host_load_module_source,\n  /** @export */\n  qts_host_normalize_module\n};\nvar wasmExports = createWasm();\nvar ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);\nvar _malloc = Module['_malloc'] = createExportWrapper('malloc', 1);\nvar _QTS_Throw = Module['_QTS_Throw'] = createExportWrapper('QTS_Throw', 2);\nvar _QTS_NewError = Module['_QTS_NewError'] = createExportWrapper('QTS_NewError', 1);\nvar _QTS_RuntimeSetMemoryLimit = Module['_QTS_RuntimeSetMemoryLimit'] = createExportWrapper('QTS_RuntimeSetMemoryLimit', 2);\nvar _QTS_RuntimeComputeMemoryUsage = Module['_QTS_RuntimeComputeMemoryUsage'] = createExportWrapper('QTS_RuntimeComputeMemoryUsage', 2);\nvar _QTS_RuntimeDumpMemoryUsage = Module['_QTS_RuntimeDumpMemoryUsage'] = createExportWrapper('QTS_RuntimeDumpMemoryUsage', 1);\nvar _QTS_RecoverableLeakCheck = Module['_QTS_RecoverableLeakCheck'] = createExportWrapper('QTS_RecoverableLeakCheck', 0);\nvar _QTS_BuildIsSanitizeLeak = Module['_QTS_BuildIsSanitizeLeak'] = createExportWrapper('QTS_BuildIsSanitizeLeak', 0);\nvar _QTS_RuntimeSetMaxStackSize = Module['_QTS_RuntimeSetMaxStackSize'] = createExportWrapper('QTS_RuntimeSetMaxStackSize', 2);\nvar _QTS_GetUndefined = Module['_QTS_GetUndefined'] = createExportWrapper('QTS_GetUndefined', 0);\nvar _QTS_GetNull = Module['_QTS_GetNull'] = createExportWrapper('QTS_GetNull', 0);\nvar _QTS_GetFalse = Module['_QTS_GetFalse'] = createExportWrapper('QTS_GetFalse', 0);\nvar _QTS_GetTrue = Module['_QTS_GetTrue'] = createExportWrapper('QTS_GetTrue', 0);\nvar _QTS_NewRuntime = Module['_QTS_NewRuntime'] = createExportWrapper('QTS_NewRuntime', 0);\nvar _QTS_FreeRuntime = Module['_QTS_FreeRuntime'] = createExportWrapper('QTS_FreeRuntime', 1);\nvar _free = Module['_free'] = createExportWrapper('free', 1);\nvar _QTS_NewContext = Module['_QTS_NewContext'] = createExportWrapper('QTS_NewContext', 2);\nvar _QTS_FreeContext = Module['_QTS_FreeContext'] = createExportWrapper('QTS_FreeContext', 1);\nvar _QTS_FreeValuePointer = Module['_QTS_FreeValuePointer'] = createExportWrapper('QTS_FreeValuePointer', 2);\nvar _QTS_FreeValuePointerRuntime = Module['_QTS_FreeValuePointerRuntime'] = createExportWrapper('QTS_FreeValuePointerRuntime', 2);\nvar _QTS_FreeVoidPointer = Module['_QTS_FreeVoidPointer'] = createExportWrapper('QTS_FreeVoidPointer', 2);\nvar _QTS_FreeCString = Module['_QTS_FreeCString'] = createExportWrapper('QTS_FreeCString', 2);\nvar _QTS_DupValuePointer = Module['_QTS_DupValuePointer'] = createExportWrapper('QTS_DupValuePointer', 2);\nvar _QTS_NewObject = Module['_QTS_NewObject'] = createExportWrapper('QTS_NewObject', 1);\nvar _QTS_NewObjectProto = Module['_QTS_NewObjectProto'] = createExportWrapper('QTS_NewObjectProto', 2);\nvar _QTS_NewArray = Module['_QTS_NewArray'] = createExportWrapper('QTS_NewArray', 1);\nvar _QTS_NewArrayBuffer = Module['_QTS_NewArrayBuffer'] = createExportWrapper('QTS_NewArrayBuffer', 3);\nvar _QTS_NewFloat64 = Module['_QTS_NewFloat64'] = createExportWrapper('QTS_NewFloat64', 2);\nvar _QTS_GetFloat64 = Module['_QTS_GetFloat64'] = createExportWrapper('QTS_GetFloat64', 2);\nvar _QTS_NewString = Module['_QTS_NewString'] = createExportWrapper('QTS_NewString', 2);\nvar _QTS_GetString = Module['_QTS_GetString'] = createExportWrapper('QTS_GetString', 2);\nvar _QTS_GetArrayBuffer = Module['_QTS_GetArrayBuffer'] = createExportWrapper('QTS_GetArrayBuffer', 2);\nvar _QTS_GetArrayBufferLength = Module['_QTS_GetArrayBufferLength'] = createExportWrapper('QTS_GetArrayBufferLength', 2);\nvar _QTS_NewSymbol = Module['_QTS_NewSymbol'] = createExportWrapper('QTS_NewSymbol', 3);\nvar _QTS_GetSymbolDescriptionOrKey = Module['_QTS_GetSymbolDescriptionOrKey'] = createExportWrapper('QTS_GetSymbolDescriptionOrKey', 2);\nvar _QTS_IsGlobalSymbol = Module['_QTS_IsGlobalSymbol'] = createExportWrapper('QTS_IsGlobalSymbol', 2);\nvar _QTS_IsJobPending = Module['_QTS_IsJobPending'] = createExportWrapper('QTS_IsJobPending', 1);\nvar _QTS_ExecutePendingJob = Module['_QTS_ExecutePendingJob'] = createExportWrapper('QTS_ExecutePendingJob', 3);\nvar _QTS_GetProp = Module['_QTS_GetProp'] = createExportWrapper('QTS_GetProp', 3);\nvar _QTS_GetPropNumber = Module['_QTS_GetPropNumber'] = createExportWrapper('QTS_GetPropNumber', 3);\nvar _QTS_SetProp = Module['_QTS_SetProp'] = createExportWrapper('QTS_SetProp', 4);\nvar _QTS_DefineProp = Module['_QTS_DefineProp'] = createExportWrapper('QTS_DefineProp', 9);\nvar _QTS_GetOwnPropertyNames = Module['_QTS_GetOwnPropertyNames'] = createExportWrapper('QTS_GetOwnPropertyNames', 5);\nvar _QTS_Call = Module['_QTS_Call'] = createExportWrapper('QTS_Call', 5);\nvar _QTS_ResolveException = Module['_QTS_ResolveException'] = createExportWrapper('QTS_ResolveException', 2);\nvar _QTS_Dump = Module['_QTS_Dump'] = createExportWrapper('QTS_Dump', 2);\nvar _QTS_Eval = Module['_QTS_Eval'] = createExportWrapper('QTS_Eval', 6);\nvar _QTS_GetModuleNamespace = Module['_QTS_GetModuleNamespace'] = createExportWrapper('QTS_GetModuleNamespace', 2);\nvar _QTS_Typeof = Module['_QTS_Typeof'] = createExportWrapper('QTS_Typeof', 2);\nvar _QTS_GetLength = Module['_QTS_GetLength'] = createExportWrapper('QTS_GetLength', 3);\nvar _QTS_IsEqual = Module['_QTS_IsEqual'] = createExportWrapper('QTS_IsEqual', 4);\nvar _QTS_GetGlobalObject = Module['_QTS_GetGlobalObject'] = createExportWrapper('QTS_GetGlobalObject', 1);\nvar _QTS_NewPromiseCapability = Module['_QTS_NewPromiseCapability'] = createExportWrapper('QTS_NewPromiseCapability', 2);\nvar _QTS_PromiseState = Module['_QTS_PromiseState'] = createExportWrapper('QTS_PromiseState', 2);\nvar _QTS_PromiseResult = Module['_QTS_PromiseResult'] = createExportWrapper('QTS_PromiseResult', 2);\nvar _QTS_TestStringArg = Module['_QTS_TestStringArg'] = createExportWrapper('QTS_TestStringArg', 1);\nvar _QTS_GetDebugLogEnabled = Module['_QTS_GetDebugLogEnabled'] = createExportWrapper('QTS_GetDebugLogEnabled', 1);\nvar _QTS_SetDebugLogEnabled = Module['_QTS_SetDebugLogEnabled'] = createExportWrapper('QTS_SetDebugLogEnabled', 2);\nvar _QTS_BuildIsDebug = Module['_QTS_BuildIsDebug'] = createExportWrapper('QTS_BuildIsDebug', 0);\nvar _QTS_BuildIsAsyncify = Module['_QTS_BuildIsAsyncify'] = createExportWrapper('QTS_BuildIsAsyncify', 0);\nvar _QTS_NewFunction = Module['_QTS_NewFunction'] = createExportWrapper('QTS_NewFunction', 3);\nvar _QTS_ArgvGetJSValueConstPointer = Module['_QTS_ArgvGetJSValueConstPointer'] = createExportWrapper('QTS_ArgvGetJSValueConstPointer', 2);\nvar _QTS_RuntimeEnableInterruptHandler = Module['_QTS_RuntimeEnableInterruptHandler'] = createExportWrapper('QTS_RuntimeEnableInterruptHandler', 1);\nvar _QTS_RuntimeDisableInterruptHandler = Module['_QTS_RuntimeDisableInterruptHandler'] = createExportWrapper('QTS_RuntimeDisableInterruptHandler', 1);\nvar _QTS_RuntimeEnableModuleLoader = Module['_QTS_RuntimeEnableModuleLoader'] = createExportWrapper('QTS_RuntimeEnableModuleLoader', 2);\nvar _QTS_RuntimeDisableModuleLoader = Module['_QTS_RuntimeDisableModuleLoader'] = createExportWrapper('QTS_RuntimeDisableModuleLoader', 1);\nvar _QTS_bjson_encode = Module['_QTS_bjson_encode'] = createExportWrapper('QTS_bjson_encode', 2);\nvar _QTS_bjson_decode = Module['_QTS_bjson_decode'] = createExportWrapper('QTS_bjson_decode', 2);\nvar _fflush = createExportWrapper('fflush', 1);\nvar _strerror = createExportWrapper('strerror', 1);\nvar _emscripten_builtin_malloc = createExportWrapper('emscripten_builtin_malloc', 1);\nvar ___funcs_on_exit = createExportWrapper('__funcs_on_exit', 0);\nvar _emscripten_builtin_free = createExportWrapper('emscripten_builtin_free', 1);\nvar _emscripten_builtin_memalign = createExportWrapper('emscripten_builtin_memalign', 2);\nvar _memalign = createExportWrapper('memalign', 2);\nvar __emscripten_tempret_set = createExportWrapper('_emscripten_tempret_set', 1);\nvar _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\nvar _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();\nvar _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();\nvar _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\nvar __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\nvar __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\nvar _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\nvar dynCall_jijiiii = Module['dynCall_jijiiii'] = createExportWrapper('dynCall_jijiiii', 8);\nvar dynCall_jijiii = Module['dynCall_jijiii'] = createExportWrapper('dynCall_jijiii', 7);\nvar dynCall_jijjiii = Module['dynCall_jijjiii'] = createExportWrapper('dynCall_jijjiii', 9);\nvar dynCall_jij = Module['dynCall_jij'] = createExportWrapper('dynCall_jij', 4);\nvar dynCall_jiiiii = Module['dynCall_jiiiii'] = createExportWrapper('dynCall_jiiiii', 6);\nvar dynCall_iiiij = Module['dynCall_iiiij'] = createExportWrapper('dynCall_iiiij', 6);\nvar dynCall_iiiijj = Module['dynCall_iiiijj'] = createExportWrapper('dynCall_iiiijj', 8);\nvar dynCall_jiij = Module['dynCall_jiij'] = createExportWrapper('dynCall_jiij', 5);\nvar dynCall_jijii = Module['dynCall_jijii'] = createExportWrapper('dynCall_jijii', 6);\nvar dynCall_jijiiiii = Module['dynCall_jijiiiii'] = createExportWrapper('dynCall_jijiiiii', 9);\nvar dynCall_iiijj = Module['dynCall_iiijj'] = createExportWrapper('dynCall_iiijj', 7);\nvar dynCall_jijj = Module['dynCall_jijj'] = createExportWrapper('dynCall_jijj', 6);\nvar dynCall_jiii = Module['dynCall_jiii'] = createExportWrapper('dynCall_jiii', 4);\nvar dynCall_jii = Module['dynCall_jii'] = createExportWrapper('dynCall_jii', 3);\nvar dynCall_vij = Module['dynCall_vij'] = createExportWrapper('dynCall_vij', 4);\nvar dynCall_viji = Module['dynCall_viji'] = createExportWrapper('dynCall_viji', 5);\nvar dynCall_iijijjji = Module['dynCall_iijijjji'] = createExportWrapper('dynCall_iijijjji', 12);\nvar dynCall_iiiji = Module['dynCall_iiiji'] = createExportWrapper('dynCall_iiiji', 6);\nvar dynCall_iiji = Module['dynCall_iiji'] = createExportWrapper('dynCall_iiji', 5);\nvar dynCall_jijij = Module['dynCall_jijij'] = createExportWrapper('dynCall_jijij', 7);\nvar dynCall_iijijji = Module['dynCall_iijijji'] = createExportWrapper('dynCall_iijijji', 10);\nvar dynCall_jiiii = Module['dynCall_jiiii'] = createExportWrapper('dynCall_jiiii', 5);\nvar dynCall_jiji = Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji', 5);\nvar dynCall_jijji = Module['dynCall_jijji'] = createExportWrapper('dynCall_jijji', 7);\n\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\n\nModule['cwrap'] = cwrap;\nModule['UTF8ToString'] = UTF8ToString;\nModule['stringToUTF8'] = stringToUTF8;\nModule['lengthBytesUTF8'] = lengthBytesUTF8;\nvar missingLibrarySymbols = [\n  'writeI53ToI64',\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'readI53FromI64',\n  'readI53FromU64',\n  'convertI32PairToI53',\n  'convertU32PairToI53',\n  'getTempRet0',\n  'setTempRet0',\n  'exitJS',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'emscriptenLog',\n  'readEmAsmArgs',\n  'jstoi_q',\n  'listenOnce',\n  'autoResumeAudioContext',\n  'dynCallLegacy',\n  'getDynCaller',\n  'dynCall',\n  'handleException',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'callUserCallback',\n  'maybeExit',\n  'asmjsMangle',\n  'HandleAllocator',\n  'getNativeTypeSize',\n  'STACK_SIZE',\n  'STACK_ALIGN',\n  'POINTER_SIZE',\n  'ASSERTIONS',\n  'uleb128Encode',\n  'sigToWasmTypes',\n  'generateFuncType',\n  'convertJsFunctionToWasm',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'getFunctionAddress',\n  'addFunction',\n  'removeFunction',\n  'reallyNegative',\n  'unSign',\n  'strLen',\n  'reSign',\n  'formatString',\n  'intArrayToString',\n  'AsciiToString',\n  'stringToAscii',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'registerKeyEventCallback',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerMouseEventCallback',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'battery',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'getCallstack',\n  'getEnvStrings',\n  'checkWasiClock',\n  'wasiRightsToMuslOFlags',\n  'wasiOFlagsToMuslOFlags',\n  'createDyncallWrapper',\n  'safeSetTimeout',\n  'setImmediateWrapped',\n  'clearImmediateWrapped',\n  'polyfillSetImmediate',\n  'getPromise',\n  'makePromise',\n  'idsToPromises',\n  'makePromiseCallback',\n  'Browser_asyncPrepareDataCounter',\n  'setMainLoop',\n  'arraySum',\n  'addDays',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'FS_unlink',\n  'FS_mkdirTree',\n  '_setNetworkCallback',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n  'writeStringToMemory',\n  'writeAsciiToMemory',\n  'setErrNo',\n  'stackTrace',\n];\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\n\nvar unexportedSymbols = [\n  'run',\n  'addOnPreRun',\n  'addOnInit',\n  'addOnPreMain',\n  'addOnExit',\n  'addOnPostRun',\n  'addRunDependency',\n  'removeRunDependency',\n  'out',\n  'err',\n  'callMain',\n  'abort',\n  'wasmMemory',\n  'wasmExports',\n  'WasmOffsetConverter',\n  'WasmSourceMap',\n  'writeStackCookie',\n  'checkStackCookie',\n  'convertI32PairToI53Checked',\n  'stackSave',\n  'stackRestore',\n  'stackAlloc',\n  'ptrToString',\n  'zeroMemory',\n  'getHeapMax',\n  'growMemory',\n  'ENV',\n  'ERRNO_CODES',\n  'strError',\n  'DNS',\n  'Protocols',\n  'Sockets',\n  'initRandomFill',\n  'randomFill',\n  'timers',\n  'warnOnce',\n  'withBuiltinMalloc',\n  'readEmAsmArgsArray',\n  'jstoi_s',\n  'getExecutableName',\n  'keepRuntimeAlive',\n  'asyncLoad',\n  'alignMemory',\n  'mmapAlloc',\n  'wasmTable',\n  'noExitRuntime',\n  'getCFunc',\n  'ccall',\n  'freeTableIndexes',\n  'functionsInTableMap',\n  'setValue',\n  'getValue',\n  'PATH',\n  'PATH_FS',\n  'UTF8Decoder',\n  'UTF8ArrayToString',\n  'stringToUTF8Array',\n  'intArrayFromString',\n  'UTF16Decoder',\n  'stringToNewUTF8',\n  'stringToUTF8OnStack',\n  'writeArrayToMemory',\n  'JSEvents',\n  'specialHTMLTargets',\n  'findCanvasEventTarget',\n  'currentFullscreenStrategy',\n  'restoreOldWindowedStyle',\n  'jsStackTrace',\n  'UNWIND_CACHE',\n  'convertPCtoSourceLocation',\n  'ExitStatus',\n  'doReadv',\n  'doWritev',\n  'promiseMap',\n  'Browser',\n  'getPreloadedImageData__data',\n  'wget',\n  'MONTH_DAYS_REGULAR',\n  'MONTH_DAYS_LEAP',\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\n  'MONTH_DAYS_LEAP_CUMULATIVE',\n  'isLeapYear',\n  'ydayFromDate',\n  'SYSCALLS',\n  'preloadPlugins',\n  'FS_createPreloadedFile',\n  'FS_modeStringToFlags',\n  'FS_getMode',\n  'FS_stdin_getChar_buffer',\n  'FS_stdin_getChar',\n  'FS_createPath',\n  'FS_createDevice',\n  'FS_readFile',\n  'FS',\n  'FS_createDataFile',\n  'FS_createLazyFile',\n  'MEMFS',\n  'TTY',\n  'PIPEFS',\n  'SOCKFS',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'print',\n  'printErr',\n];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n\n\nvar calledRun;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\n\nfunction run() {\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n    stackCheckInit();\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    readyPromiseResolve(Module);\n    Module['onRuntimeInitialized']?.();\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nrun();\n\n// end include: postamble.js\n\n// include: postamble_modularize.js\n// In MODULARIZE mode we wrap the generated code in a factory function\n// and return either the Module itself, or a promise of the module.\n//\n// We assign to the `moduleRtn` global here and configure closure to see\n// this as and extern so it won't get minified.\n\nmoduleRtn = readyPromise;\n\n// Assertion for attempting to access module properties on the incoming\n// moduleArg.  In the past we used this object as the prototype of the module\n// and assigned properties to it, but now we return a distinct object.  This\n// keeps the instance private until it is ready (i.e the promise has been\n// resolved).\nfor (const prop of Object.keys(Module)) {\n  if (!(prop in moduleArg)) {\n    Object.defineProperty(moduleArg, prop, {\n      configurable: true,\n      get() {\n        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`)\n      }\n    });\n  }\n}\n// end include: postamble_modularize.js\n\n\n\n  return moduleRtn;\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuickJSRaw);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aaml0bC9xdWlja2pzLXdhc21maWxlLWRlYnVnLXN5bmMvZGlzdC9lbXNjcmlwdGVuLW1vZHVsZS5icm93c2VyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTtBQUNBLG9CQUFvQiwrSkFBZTtBQUNuQztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sdUJBQXVCLE9BQU8sZ0NBQWdDLE9BQU87QUFDN0c7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUssOERBQThEO0FBQ2hIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpRUFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAaml0bFxccXVpY2tqcy13YXNtZmlsZS1kZWJ1Zy1zeW5jXFxkaXN0XFxlbXNjcmlwdGVuLW1vZHVsZS5icm93c2VyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBRdWlja0pTUmF3ID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHROYW1lID0gaW1wb3J0Lm1ldGEudXJsO1xuICBcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKG1vZHVsZUFyZyA9IHt9KSB7XG4gIHZhciBtb2R1bGVSdG47XG5cbi8vIGluY2x1ZGU6IHNoZWxsLmpzXG4vLyBUaGUgTW9kdWxlIG9iamVjdDogT3VyIGludGVyZmFjZSB0byB0aGUgb3V0c2lkZSB3b3JsZC4gV2UgaW1wb3J0XG4vLyBhbmQgZXhwb3J0IHZhbHVlcyBvbiBpdC4gVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyBNb2R1bGUgY2FuIGJlIHVzZWQ6XG4vLyAxLiBOb3QgZGVmaW5lZC4gV2UgY3JlYXRlIGl0IGhlcmVcbi8vIDIuIEEgZnVuY3Rpb24gcGFyYW1ldGVyLCBmdW5jdGlvbihtb2R1bGVBcmcpID0+IFByb21pc2U8TW9kdWxlPlxuLy8gMy4gcHJlLXJ1biBhcHBlbmRlZCBpdCwgdmFyIE1vZHVsZSA9IHt9OyAuLmdlbmVyYXRlZCBjb2RlLi5cbi8vIDQuIEV4dGVybmFsIHNjcmlwdCB0YWcgZGVmaW5lcyB2YXIgTW9kdWxlLlxuLy8gV2UgbmVlZCB0byBjaGVjayBpZiBNb2R1bGUgYWxyZWFkeSBleGlzdHMgKGUuZy4gY2FzZSAzIGFib3ZlKS5cbi8vIFN1YnN0aXR1dGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIGNvZGUgb24gbGF0ZXIgc3RhZ2Ugb2YgdGhlIGJ1aWxkLFxuLy8gdGhpcyB3YXkgQ2xvc3VyZSBDb21waWxlciB3aWxsIG5vdCBtYW5nbGUgaXQgKGUuZy4gY2FzZSA0LiBhYm92ZSkuXG4vLyBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8gcnVuIGNsb3N1cmUsIGFuZCBhbHNvIHRvIHVzZSBNb2R1bGVcbi8vIGFmdGVyIHRoZSBnZW5lcmF0ZWQgY29kZSwgeW91IHdpbGwgbmVlZCB0byBkZWZpbmUgICB2YXIgTW9kdWxlID0ge307XG4vLyBiZWZvcmUgdGhlIGNvZGUuIFRoZW4gdGhhdCBvYmplY3Qgd2lsbCBiZSB1c2VkIGluIHRoZSBjb2RlLCBhbmQgeW91XG4vLyBjYW4gY29udGludWUgdG8gdXNlIE1vZHVsZSBhZnRlcndhcmRzIGFzIHdlbGwuXG52YXIgTW9kdWxlID0gbW9kdWxlQXJnO1xuXG4vLyBTZXQgdXAgdGhlIHByb21pc2UgdGhhdCBpbmRpY2F0ZXMgdGhlIE1vZHVsZSBpcyBpbml0aWFsaXplZFxudmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcbnZhciByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG59KTtcbltcIl9RVFNfVGhyb3dcIixcIl9RVFNfTmV3RXJyb3JcIixcIl9RVFNfUnVudGltZVNldE1lbW9yeUxpbWl0XCIsXCJfUVRTX1J1bnRpbWVDb21wdXRlTWVtb3J5VXNhZ2VcIixcIl9RVFNfUnVudGltZUR1bXBNZW1vcnlVc2FnZVwiLFwiX1FUU19SZWNvdmVyYWJsZUxlYWtDaGVja1wiLFwiX1FUU19CdWlsZElzU2FuaXRpemVMZWFrXCIsXCJfUVRTX1J1bnRpbWVTZXRNYXhTdGFja1NpemVcIixcIl9RVFNfR2V0VW5kZWZpbmVkXCIsXCJfUVRTX0dldE51bGxcIixcIl9RVFNfR2V0RmFsc2VcIixcIl9RVFNfR2V0VHJ1ZVwiLFwiX1FUU19OZXdSdW50aW1lXCIsXCJfUVRTX0ZyZWVSdW50aW1lXCIsXCJfUVRTX05ld0NvbnRleHRcIixcIl9RVFNfRnJlZUNvbnRleHRcIixcIl9RVFNfRnJlZVZhbHVlUG9pbnRlclwiLFwiX1FUU19GcmVlVmFsdWVQb2ludGVyUnVudGltZVwiLFwiX1FUU19GcmVlVm9pZFBvaW50ZXJcIixcIl9RVFNfRnJlZUNTdHJpbmdcIixcIl9RVFNfRHVwVmFsdWVQb2ludGVyXCIsXCJfUVRTX05ld09iamVjdFwiLFwiX1FUU19OZXdPYmplY3RQcm90b1wiLFwiX1FUU19OZXdBcnJheVwiLFwiX1FUU19OZXdBcnJheUJ1ZmZlclwiLFwiX1FUU19OZXdGbG9hdDY0XCIsXCJfUVRTX0dldEZsb2F0NjRcIixcIl9RVFNfTmV3U3RyaW5nXCIsXCJfUVRTX0dldFN0cmluZ1wiLFwiX1FUU19HZXRBcnJheUJ1ZmZlclwiLFwiX1FUU19HZXRBcnJheUJ1ZmZlckxlbmd0aFwiLFwiX1FUU19OZXdTeW1ib2xcIixcIl9RVFNfR2V0U3ltYm9sRGVzY3JpcHRpb25PcktleVwiLFwiX1FUU19Jc0dsb2JhbFN5bWJvbFwiLFwiX1FUU19Jc0pvYlBlbmRpbmdcIixcIl9RVFNfRXhlY3V0ZVBlbmRpbmdKb2JcIixcIl9RVFNfR2V0UHJvcFwiLFwiX1FUU19HZXRQcm9wTnVtYmVyXCIsXCJfUVRTX1NldFByb3BcIixcIl9RVFNfRGVmaW5lUHJvcFwiLFwiX1FUU19HZXRPd25Qcm9wZXJ0eU5hbWVzXCIsXCJfUVRTX0NhbGxcIixcIl9RVFNfUmVzb2x2ZUV4Y2VwdGlvblwiLFwiX1FUU19EdW1wXCIsXCJfUVRTX0V2YWxcIixcIl9RVFNfR2V0TW9kdWxlTmFtZXNwYWNlXCIsXCJfUVRTX1R5cGVvZlwiLFwiX1FUU19HZXRMZW5ndGhcIixcIl9RVFNfSXNFcXVhbFwiLFwiX1FUU19HZXRHbG9iYWxPYmplY3RcIixcIl9RVFNfTmV3UHJvbWlzZUNhcGFiaWxpdHlcIixcIl9RVFNfUHJvbWlzZVN0YXRlXCIsXCJfUVRTX1Byb21pc2VSZXN1bHRcIixcIl9RVFNfVGVzdFN0cmluZ0FyZ1wiLFwiX1FUU19HZXREZWJ1Z0xvZ0VuYWJsZWRcIixcIl9RVFNfU2V0RGVidWdMb2dFbmFibGVkXCIsXCJfUVRTX0J1aWxkSXNEZWJ1Z1wiLFwiX1FUU19CdWlsZElzQXN5bmNpZnlcIixcIl9RVFNfTmV3RnVuY3Rpb25cIixcIl9RVFNfQXJndkdldEpTVmFsdWVDb25zdFBvaW50ZXJcIixcIl9RVFNfUnVudGltZUVuYWJsZUludGVycnVwdEhhbmRsZXJcIixcIl9RVFNfUnVudGltZURpc2FibGVJbnRlcnJ1cHRIYW5kbGVyXCIsXCJfUVRTX1J1bnRpbWVFbmFibGVNb2R1bGVMb2FkZXJcIixcIl9RVFNfUnVudGltZURpc2FibGVNb2R1bGVMb2FkZXJcIixcIl9RVFNfYmpzb25fZW5jb2RlXCIsXCJfUVRTX2Jqc29uX2RlY29kZVwiLFwiX21hbGxvY1wiLFwiX2ZyZWVcIixcIl9xdHNfaG9zdF9jYWxsX2Z1bmN0aW9uXCIsXCJfcXRzX2hvc3RfaW50ZXJydXB0X2hhbmRsZXJcIixcIl9xdHNfaG9zdF9sb2FkX21vZHVsZV9zb3VyY2VcIixcIl9xdHNfaG9zdF9ub3JtYWxpemVfbW9kdWxlXCIsXCJfX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZVwiLFwib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0uZm9yRWFjaCgocHJvcCkgPT4ge1xuICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVhZHlQcm9taXNlLCBwcm9wKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWFkeVByb21pc2UsIHByb3AsIHtcbiAgICAgIGdldDogKCkgPT4gYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyAnICsgcHJvcCArICcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSxcbiAgICAgIHNldDogKCkgPT4gYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyAnICsgcHJvcCArICcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSxcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIERldGVybWluZSB0aGUgcnVudGltZSBlbnZpcm9ubWVudCB3ZSBhcmUgaW4uIFlvdSBjYW4gY3VzdG9taXplIHRoaXMgYnlcbi8vIHNldHRpbmcgdGhlIEVOVklST05NRU5UIHNldHRpbmcgYXQgY29tcGlsZSB0aW1lIChzZWUgc2V0dGluZ3MuanMpLlxuXG4vLyBBdHRlbXB0IHRvIGF1dG8tZGV0ZWN0IHRoZSBlbnZpcm9ubWVudFxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCc7XG52YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJztcbi8vIE4uYi4gRWxlY3Ryb24uanMgZW52aXJvbm1lbnQgaXMgc2ltdWx0YW5lb3VzbHkgYSBOT0RFLWVudmlyb25tZW50LCBidXRcbi8vIGFsc28gYSB3ZWIgZW52aXJvbm1lbnQuXG52YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT0gJ3N0cmluZyc7XG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbmlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNb2R1bGUuRU5WSVJPTk1FTlQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVG8gZm9yY2UgdGhlIGVudmlyb25tZW50LCB1c2UgdGhlIEVOVklST05NRU5UIGNvbXBpbGUtdGltZSBvcHRpb24gKGZvciBleGFtcGxlLCAtc0VOVklST05NRU5UPXdlYiBvciAtc0VOVklST05NRU5UPW5vZGUpJyk7XG59XG5cbi8vIC0tcHJlLWpzZXMgYXJlIGVtaXR0ZWQgYWZ0ZXIgdGhlIE1vZHVsZSBpbnRlZ3JhdGlvbiBjb2RlLCBzbyB0aGF0IHRoZXkgY2FuXG4vLyByZWZlciB0byBNb2R1bGUgKGlmIHRoZXkgY2hvb3NlOyB0aGV5IGNhbiBhbHNvIGRlZmluZSBNb2R1bGUpXG4vLyBpbmNsdWRlOiAvVXNlcnMvaml0bC9zcmMvcXVpY2tqcy1lbXNjcmlwdGVuL3RlbXBsYXRlcy9wcmUtZXh0ZW5zaW9uLmpzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuLy8gcXVpY2tqcy1lbXNjcmlwdGVuIGNvZGUgaW5qZWN0ZWQgaW50byBlbXNjcmlwdGVuLW1vZHVsZS5qc1xuLy8gV2UgdXNlIHRoaXMgdG8gZXhwb3NlIGFuZCBwYXRjaCB1cCBpc3N1ZXMgd2l0aCBFbXNjcmlwdGVuJ3Mgc291cmNlIG1hcCBoYW5kbGluZy4uLlxuZnVuY3Rpb24gcXVpY2tqc0Vtc2NyaXB0ZW5Jbml0KGRlYnVnTG9nKSB7XG4gIGNvbnN0IGxvZyA9IGRlYnVnTG9nIHx8IGZ1bmN0aW9uICgpIHt9XG4gIC8vIEV2ZXJ5dGhpbmcgZ29lcyBpbiBhIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZWZlciBydW5uaW5nIHVudGlsIG90aGVyIHZhcmlhYmxlc1xuICAvLyBhcmUgaW5pdGlhbGl6ZWQgaW4gY2FzZSB0aGV5IGNoYW5nZS5cbiAgY29uc3QgZXh0ZW5zaW9uID0geyBsb2cgfVxuICBmb3IgKGNvbnN0IGluaXQgb2YgcXVpY2tqc0Vtc2NyaXB0ZW5Jbml0LmluaXRzKSB7XG4gICAgaW5pdChleHRlbnNpb24pXG4gIH1cbiAgTW9kdWxlW1wicXVpY2tKU0Vtc2NyaXB0ZW5FeHRlbnNpb25zXCJdID0gZXh0ZW5zaW9uXG4gIHJldHVybiBleHRlbnNpb25cbn1cbnF1aWNranNFbXNjcmlwdGVuSW5pdC5pbml0cyA9IFtdXG5Nb2R1bGVbXCJxdWlja2pzRW1zY3JpcHRlbkluaXRcIl0gPSBxdWlja2pzRW1zY3JpcHRlbkluaXRcbi8vIGVuZCBpbmNsdWRlOiAvVXNlcnMvaml0bC9zcmMvcXVpY2tqcy1lbXNjcmlwdGVuL3RlbXBsYXRlcy9wcmUtZXh0ZW5zaW9uLmpzXG4vLyBpbmNsdWRlOiAvVXNlcnMvaml0bC9zcmMvcXVpY2tqcy1lbXNjcmlwdGVuL3RlbXBsYXRlcy9wcmUtc291cmNlTWFwSnNvbi5qc1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbnF1aWNranNFbXNjcmlwdGVuSW5pdC5pbml0cy5wdXNoKChleHRlbnNpb24pID0+IHtcbiAgaWYgKHR5cGVvZiByZWNlaXZlU291cmNlTWFwSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4dGVuc2lvbltcInJlY2VpdmVTb3VyY2VNYXBKU09OXCJdID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2FzbVNvdXJjZU1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBleHRlbnNpb24ubG9nKFwicmVjZWl2ZVNvdXJjZU1hcEpTT046IHJlY2VpdmVkXCIsIGRhdGEpXG4gICAgICAgIHJldHVybiByZWNlaXZlU291cmNlTWFwSlNPTihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW5zaW9uLmxvZyhcInJlY2VpdmVTb3VyY2VNYXBKU09OOiBhbHJlYWR5IGhhdmUgZGF0YTpcIiwgd2FzbVNvdXJjZU1hcCwgXCJpZ25vcmluZ1wiLCBkYXRhKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbi8vIGVuZCBpbmNsdWRlOiAvVXNlcnMvaml0bC9zcmMvcXVpY2tqcy1lbXNjcmlwdGVuL3RlbXBsYXRlcy9wcmUtc291cmNlTWFwSnNvbi5qc1xuLy8gaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLXdhc21PZmZzZXRDb252ZXJ0ZXIuanNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5xdWlja2pzRW1zY3JpcHRlbkluaXQuaW5pdHMucHVzaCgoZXh0ZW5zaW9uKSA9PiB7XG4gIGlmICh0eXBlb2YgV2FzbU9mZnNldENvbnZlcnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4dGVuc2lvbltcIldhc21PZmZzZXRDb252ZXJ0ZXJcIl0gPSBXYXNtT2Zmc2V0Q29udmVydGVyXG4gICAgLy8gRXhwb3NlIGZ1bmN0aW9uIHRvIHJlY2VpdmUgV2FzbU9mZnNldENvbnZlcnRlciwgc2V0IHRvIHdhc21PZmZzZXRDb252ZXJ0ZXIgbG9jYWwgdmFyaWFibGVcbiAgICAvLyBpZiBpdCBleGlzdHNcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2FzbU9mZnNldENvbnZlcnRlciB2YXJpYWJsZSBleGlzdHMuIElmIGl0IGlzbid0IGRlZmluZWQsIHRoaXNcbiAgICAgIC8vIHdpbGwgdGhyb3cgYW5kIHdlJ2xsIHNraXAgdGhlIHJlc3Qgb2YgdGhlIGJyYW5jaC5cbiAgICAgIGV4dGVuc2lvbltcImV4aXN0aW5nV2FzbU9mZnNldENvbnZlcnRlclwiXSA9IHdhc21PZmZzZXRDb252ZXJ0ZXJcbiAgICAgIGV4dGVuc2lvbltcInJlY2VpdmVXYXNtT2Zmc2V0Q29udmVydGVyXCJdID0gZnVuY3Rpb24gKHdhc21CaW5hcnksIHdhc21Nb2R1bGUpIHtcbiAgICAgICAgaWYgKCF3YXNtT2Zmc2V0Q29udmVydGVyKSB7XG4gICAgICAgICAgZXh0ZW5zaW9uLmxvZyhcIndhc21PZmZzZXRDb252ZXJ0ZXIgc2V0XCIpXG4gICAgICAgICAgd2FzbU9mZnNldENvbnZlcnRlciA9IG5ldyBXYXNtT2Zmc2V0Q29udmVydGVyKHdhc21CaW5hcnksIHdhc21Nb2R1bGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uLmxvZyhcIndhc21PZmZzZXRDb252ZXJ0ZXIgYWxyZWFkeSBzZXQsIGlnbm9yZWRcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBOb3RoaW5nLlxuICAgICAgZXh0ZW5zaW9uW1wicmVjZWl2ZVdhc21PZmZzZXRDb252ZXJ0ZXJcIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4dGVuc2lvbi5sb2coXCJ3YXNtT2Zmc2V0Q29udmVydGVyIHZhcmlhYmxlIG5vdCBkZWZpbmVkLCB0aGlzIGlzIGEgbm8tb3BcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG4vLyBlbmQgaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLXdhc21PZmZzZXRDb252ZXJ0ZXIuanNcbi8vIGluY2x1ZGU6IC9Vc2Vycy9qaXRsL3NyYy9xdWlja2pzLWVtc2NyaXB0ZW4vdGVtcGxhdGVzL3ByZS13YXNtTWVtb3J5LmpzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xucXVpY2tqc0Vtc2NyaXB0ZW5Jbml0LmluaXRzLnB1c2goKGV4dGVuc2lvbikgPT4ge1xuICBleHRlbnNpb25bXCJnZXRXYXNtTWVtb3J5XCJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3YXNtTWVtb3J5XG4gIH1cbn0pXG4vLyBlbmQgaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLXdhc21NZW1vcnkuanNcblxuXG4vLyBTb21ldGltZXMgYW4gZXhpc3RpbmcgTW9kdWxlIG9iamVjdCBleGlzdHMgd2l0aCBwcm9wZXJ0aWVzXG4vLyBtZWFudCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbW9kdWxlIGZ1bmN0aW9uYWxpdHkuIEhlcmVcbi8vIHdlIGNvbGxlY3QgdGhvc2UgcHJvcGVydGllcyBhbmQgcmVhcHBseSBfYWZ0ZXJfIHdlIGNvbmZpZ3VyZVxuLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBkZWZhdWx0cyB0byBhdm9pZCBoYXZpbmcgdG8gYmUgc29cbi8vIGRlZmVuc2l2ZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG52YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxudmFyIGFyZ3VtZW50c18gPSBbXTtcbnZhciB0aGlzUHJvZ3JhbSA9ICcuL3RoaXMucHJvZ3JhbSc7XG52YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gIHRocm93IHRvVGhyb3c7XG59O1xuXG4vLyBgL2Agc2hvdWxkIGJlIHByZXNlbnQgYXQgdGhlIGVuZCBpZiBgc2NyaXB0RGlyZWN0b3J5YCBpcyBub3QgZW1wdHlcbnZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcbmZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICBpZiAoTW9kdWxlWydsb2NhdGVGaWxlJ10pIHtcbiAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgfVxuICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbn1cblxuLy8gSG9va3MgdGhhdCBhcmUgaW1wbGVtZW50ZWQgZGlmZmVyZW50bHkgaW4gZGlmZmVyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnRzLlxudmFyIHJlYWRBc3luYywgcmVhZEJpbmFyeTtcblxuaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XG5cbiAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ25vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pJyk7XG5cbn0gZWxzZVxuXG4vLyBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyBOb2RlLmpzIHdvcmtlcnMgd2hlbiByZWxldmFudCAocHRocmVhZHMgaXMgZW5hYmxlZCkuXG4vLyBOb2RlLmpzIHdvcmtlcnMgYXJlIGRldGVjdGVkIGFzIGEgY29tYmluYXRpb24gb2YgRU5WSVJPTk1FTlRfSVNfV09SS0VSIGFuZFxuLy8gRU5WSVJPTk1FTlRfSVNfTk9ERS5cbmlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHsgLy8gQ2hlY2sgd29ya2VyLCBub3Qgd2ViLCBzaW5jZSB3aW5kb3cgY291bGQgYmUgcG9seWZpbGxlZFxuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkgeyAvLyB3ZWJcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgfVxuICAvLyBXaGVuIE1PRFVMQVJJWkUsIHRoaXMgSlMgbWF5IGJlIGV4ZWN1dGVkIGxhdGVyLCBhZnRlciBkb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gIC8vIGlzIGdvbmUsIHNvIHdlIHNhdmVkIGl0LCBhbmQgd2UgdXNlIGl0IGhlcmUgaW5zdGVhZCBvZiBhbnkgb3RoZXIgaW5mby5cbiAgaWYgKF9zY3JpcHROYW1lKSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdE5hbWU7XG4gIH1cbiAgLy8gYmxvYiB1cmxzIGxvb2sgbGlrZSBibG9iOmh0dHA6Ly9zaXRlLmNvbS9ldGMvZXRjIGFuZCB3ZSBjYW5ub3QgaW5mZXIgYW55dGhpbmcgZnJvbSB0aGVtLlxuICAvLyBvdGhlcndpc2UsIHNsaWNlIG9mZiB0aGUgZmluYWwgcGFydCBvZiB0aGUgdXJsIHRvIGZpbmQgdGhlIHNjcmlwdCBkaXJlY3RvcnkuXG4gIC8vIGlmIHNjcmlwdERpcmVjdG9yeSBkb2VzIG5vdCBjb250YWluIGEgc2xhc2gsIGxhc3RJbmRleE9mIHdpbGwgcmV0dXJuIC0xLFxuICAvLyBhbmQgc2NyaXB0RGlyZWN0b3J5IHdpbGwgY29ycmVjdGx5IGJlIHJlcGxhY2VkIHdpdGggYW4gZW1wdHkgc3RyaW5nLlxuICAvLyBJZiBzY3JpcHREaXJlY3RvcnkgY29udGFpbnMgYSBxdWVyeSAoc3RhcnRpbmcgd2l0aCA/KSBvciBhIGZyYWdtZW50IChzdGFydGluZyB3aXRoICMpLFxuICAvLyB0aGV5IGFyZSByZW1vdmVkIGJlY2F1c2UgdGhleSBjb3VsZCBjb250YWluIGEgc2xhc2guXG4gIGlmIChzY3JpcHREaXJlY3Rvcnkuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sICcnKS5sYXN0SW5kZXhPZignLycpKzEpO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nKSkgdGhyb3cgbmV3IEVycm9yKCdub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KScpO1xuXG4gIHtcbi8vIGluY2x1ZGU6IHdlYl9vcl93b3JrZXJfc2hlbGxfcmVhZC5qc1xuaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgIHJlYWRCaW5hcnkgPSAodXJsKSA9PiB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXshQXJyYXlCdWZmZXJ9ICovKHhoci5yZXNwb25zZSkpO1xuICAgIH07XG4gIH1cblxuICByZWFkQXN5bmMgPSAodXJsKSA9PiB7XG4gICAgYXNzZXJ0KCFpc0ZpbGVVUkkodXJsKSwgXCJyZWFkQXN5bmMgZG9lcyBub3Qgd29yayB3aXRoIGZpbGU6Ly8gVVJMc1wiKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyAnIDogJyArIHJlc3BvbnNlLnVybCkpO1xuICAgICAgfSlcbiAgfTtcbi8vIGVuZCBpbmNsdWRlOiB3ZWJfb3Jfd29ya2VyX3NoZWxsX3JlYWQuanNcbiAgfVxufSBlbHNlXG57XG4gIHRocm93IG5ldyBFcnJvcignZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGVycm9yJyk7XG59XG5cbnZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbnZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuXG4vLyBNZXJnZSBiYWNrIGluIHRoZSBvdmVycmlkZXNcbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuLy8gRnJlZSB0aGUgb2JqZWN0IGhpZXJhcmNoeSBjb250YWluZWQgaW4gdGhlIG92ZXJyaWRlcywgdGhpcyBsZXRzIHRoZSBHQ1xuLy8gcmVjbGFpbSBkYXRhIHVzZWQuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuY2hlY2tJbmNvbWluZ01vZHVsZUFQSSgpO1xuXG4vLyBFbWl0IGNvZGUgdG8gaGFuZGxlIGV4cGVjdGVkIHZhbHVlcyBvbiB0aGUgTW9kdWxlIG9iamVjdC4gVGhpcyBhcHBsaWVzIE1vZHVsZS54XG4vLyB0byB0aGUgcHJvcGVyIGxvY2FsIHguIFRoaXMgaGFzIHR3byBiZW5lZml0czogZmlyc3QsIHdlIG9ubHkgZW1pdCBpdCBpZiBpdCBpc1xuLy8gZXhwZWN0ZWQgdG8gYXJyaXZlLCBhbmQgc2Vjb25kLCBieSB1c2luZyBhIGxvY2FsIGV2ZXJ5d2hlcmUgZWxzZSB0aGF0IGNhbiBiZVxuLy8gbWluaWZpZWQuXG5cbmlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtsZWdhY3lNb2R1bGVQcm9wKCdhcmd1bWVudHMnLCAnYXJndW1lbnRzXycpO1xuXG5pZiAoTW9kdWxlWyd0aGlzUHJvZ3JhbSddKSB0aGlzUHJvZ3JhbSA9IE1vZHVsZVsndGhpc1Byb2dyYW0nXTtsZWdhY3lNb2R1bGVQcm9wKCd0aGlzUHJvZ3JhbScsICd0aGlzUHJvZ3JhbScpO1xuXG4vLyBwZXJmb3JtIGFzc2VydGlvbnMgaW4gc2hlbGwuanMgYWZ0ZXIgd2Ugc2V0IHVwIG91dCgpIGFuZCBlcnIoKSwgYXMgb3RoZXJ3aXNlIGlmIGFuIGFzc2VydGlvbiBmYWlscyBpdCBjYW5ub3QgcHJpbnQgdGhlIG1lc3NhZ2Vcbi8vIEFzc2VydGlvbnMgb24gcmVtb3ZlZCBpbmNvbWluZyBNb2R1bGUgSlMgQVBJcy5cbmFzc2VydCh0eXBlb2YgTW9kdWxlWydtZW1vcnlJbml0aWFsaXplclByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydwdGhyZWFkTWFpblByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnB0aHJlYWRNYWluUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydjZEluaXRpYWxpemVyUHJlZml4VVJMJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuY2RJbml0aWFsaXplclByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnZmlsZVBhY2thZ2VQcmVmaXhVUkwnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5maWxlUGFja2FnZVByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncmVhZCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnJlYWQgb3B0aW9uIHdhcyByZW1vdmVkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncmVhZEFzeW5jJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucmVhZEFzeW5jIG9wdGlvbiB3YXMgcmVtb3ZlZCAobW9kaWZ5IHJlYWRBc3luYyBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydyZWFkQmluYXJ5J10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucmVhZEJpbmFyeSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQmluYXJ5IGluIEpTKScpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3NldFdpbmRvd1RpdGxlJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuc2V0V2luZG93VGl0bGUgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgZW1zY3JpcHRlbl9zZXRfd2luZG93X3RpdGxlIGluIEpTKScpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ1RPVEFMX01FTU9SWSddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLlRPVEFMX01FTU9SWSBoYXMgYmVlbiByZW5hbWVkIE1vZHVsZS5JTklUSUFMX01FTU9SWScpO1xubGVnYWN5TW9kdWxlUHJvcCgnYXNtJywgJ3dhc21FeHBvcnRzJyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdyZWFkQXN5bmMnLCAncmVhZEFzeW5jJyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdyZWFkQmluYXJ5JywgJ3JlYWRCaW5hcnknKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ3NldFdpbmRvd1RpdGxlJywgJ3NldFdpbmRvd1RpdGxlJyk7XG52YXIgSURCRlMgPSAnSURCRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWxpZGJmcy5qcyc7XG52YXIgUFJPWFlGUyA9ICdQUk9YWUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1scHJveHlmcy5qcyc7XG52YXIgV09SS0VSRlMgPSAnV09SS0VSRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWx3b3JrZXJmcy5qcyc7XG52YXIgRkVUQ0hGUyA9ICdGRVRDSEZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sZmV0Y2hmcy5qcyc7XG52YXIgSUNBU0VGUyA9ICdJQ0FTRUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1saWNhc2Vmcy5qcyc7XG52YXIgSlNGSUxFRlMgPSAnSlNGSUxFRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWxqc2ZpbGVmcy5qcyc7XG52YXIgT1BGUyA9ICdPUEZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sb3Bmcy5qcyc7XG5cbnZhciBOT0RFRlMgPSAnTk9ERUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sbm9kZWZzLmpzJztcblxuYXNzZXJ0KCFFTlZJUk9OTUVOVF9JU19OT0RFLCAnbm9kZSBlbnZpcm9ubWVudCBkZXRlY3RlZCBidXQgbm90IGVuYWJsZWQgYXQgYnVpbGQgdGltZS4gIEFkZCBgbm9kZWAgdG8gYC1zRU5WSVJPTk1FTlRgIHRvIGVuYWJsZS4nKTtcblxuYXNzZXJ0KCFFTlZJUk9OTUVOVF9JU19TSEVMTCwgJ3NoZWxsIGVudmlyb25tZW50IGRldGVjdGVkIGJ1dCBub3QgZW5hYmxlZCBhdCBidWlsZCB0aW1lLiAgQWRkIGBzaGVsbGAgdG8gYC1zRU5WSVJPTk1FTlRgIHRvIGVuYWJsZS4nKTtcblxuLy8gZW5kIGluY2x1ZGU6IHNoZWxsLmpzXG5cbi8vIGluY2x1ZGU6IHByZWFtYmxlLmpzXG4vLyA9PT0gUHJlYW1ibGUgbGlicmFyeSBzdHVmZiA9PT1cblxuLy8gRG9jdW1lbnRhdGlvbiBmb3IgdGhlIHB1YmxpYyBBUElzIGRlZmluZWQgaW4gdGhpcyBmaWxlIG11c3QgYmUgdXBkYXRlZCBpbjpcbi8vICAgIHNpdGUvc291cmNlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5yc3Rcbi8vIEEgcHJlYnVpbHQgbG9jYWwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQ6XG4vLyAgICBzaXRlL2J1aWxkL3RleHQvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLnR4dFxuLy8gWW91IGNhbiBhbHNvIGJ1aWxkIGRvY3MgbG9jYWxseSBhcyBIVE1MIG9yIG90aGVyIGZvcm1hdHMgaW4gc2l0ZS9cbi8vIEFuIG9ubGluZSBIVE1MIHZlcnNpb24gKHdoaWNoIG1heSBiZSBvZiBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIEVtc2NyaXB0ZW4pXG4vLyAgICBpcyB1cCBhdCBodHRwOi8va3JpcGtlbi5naXRodWIuaW8vZW1zY3JpcHRlbi1zaXRlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5odG1sXG5cbnZhciB3YXNtQmluYXJ5ID0gTW9kdWxlWyd3YXNtQmluYXJ5J107bGVnYWN5TW9kdWxlUHJvcCgnd2FzbUJpbmFyeScsICd3YXNtQmluYXJ5Jyk7XG5cbmlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT0gJ29iamVjdCcpIHtcbiAgZXJyKCdubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkJyk7XG59XG5cbi8vIFdhc20gZ2xvYmFsc1xuXG52YXIgd2FzbU1lbW9yeTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSdW50aW1lIGVzc2VudGlhbHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB3aGV0aGVyIHdlIGFyZSBxdWl0dGluZyB0aGUgYXBwbGljYXRpb24uIG5vIGNvZGUgc2hvdWxkIHJ1biBhZnRlciB0aGlzLlxuLy8gc2V0IGluIGV4aXQoKSBhbmQgYWJvcnQoKVxudmFyIEFCT1JUID0gZmFsc2U7XG5cbi8vIHNldCBieSBleGl0KCkgYW5kIGFib3J0KCkuICBQYXNzZWQgdG8gJ29uRXhpdCcgaGFuZGxlci5cbi8vIE5PVEU6IFRoaXMgaXMgYWxzbyB1c2VkIGFzIHRoZSBwcm9jZXNzIHJldHVybiBjb2RlIGNvZGUgaW4gc2hlbGwgZW52aXJvbm1lbnRzXG4vLyBidXQgb25seSB3aGVuIG5vRXhpdFJ1bnRpbWUgaXMgZmFsc2UuXG52YXIgRVhJVFNUQVRVUztcblxuLy8gSW4gU1RSSUNUIG1vZGUsIHdlIG9ubHkgZGVmaW5lIGFzc2VydCgpIHdoZW4gQVNTRVJUSU9OUyBpcyBzZXQuICBpLmUuIHdlXG4vLyBkb24ndCBkZWZpbmUgaXQgYXQgYWxsIGluIHJlbGVhc2UgbW9kZXMuICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZlxuLy8gTUlOSU1BTF9SVU5USU1FLlxuLy8gVE9ETyhzYmMpOiBNYWtlIHRoaXMgdGhlIGRlZmF1bHQgZXZlbiB3aXRob3V0IFNUUklDVCBlbmFibGVkLlxuLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZCcgKyAodGV4dCA/ICc6ICcgKyB0ZXh0IDogJycpKTtcbiAgfVxufVxuXG4vLyBXZSB1c2VkIHRvIGluY2x1ZGUgbWFsbG9jL2ZyZWUgYnkgZGVmYXVsdCBpbiB0aGUgcGFzdC4gU2hvdyBhIGhlbHBmdWwgZXJyb3IgaW5cbi8vIGJ1aWxkcyB3aXRoIGFzc2VydGlvbnMuXG5cbi8vIE1lbW9yeSBtYW5hZ2VtZW50XG5cbnZhciBIRUFQLFxuLyoqIEB0eXBlIHshSW50OEFycmF5fSAqL1xuICBIRUFQOCxcbi8qKiBAdHlwZSB7IVVpbnQ4QXJyYXl9ICovXG4gIEhFQVBVOCxcbi8qKiBAdHlwZSB7IUludDE2QXJyYXl9ICovXG4gIEhFQVAxNixcbi8qKiBAdHlwZSB7IVVpbnQxNkFycmF5fSAqL1xuICBIRUFQVTE2LFxuLyoqIEB0eXBlIHshSW50MzJBcnJheX0gKi9cbiAgSEVBUDMyLFxuLyoqIEB0eXBlIHshVWludDMyQXJyYXl9ICovXG4gIEhFQVBVMzIsXG4vKiogQHR5cGUgeyFGbG9hdDMyQXJyYXl9ICovXG4gIEhFQVBGMzIsXG4vKiogQHR5cGUgeyFGbG9hdDY0QXJyYXl9ICovXG4gIEhFQVBGNjQ7XG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfc2hhcmVkLmpzXG5mdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpIHtcbiAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQRjMyJ10gPSBIRUFQRjMyID0gbmV3IEZsb2F0MzJBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbn1cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX3NoYXJlZC5qc1xuYXNzZXJ0KCFNb2R1bGVbJ1NUQUNLX1NJWkUnXSwgJ1NUQUNLX1NJWkUgY2FuIG5vIGxvbmdlciBiZSBzZXQgYXQgcnVudGltZS4gIFVzZSAtc1NUQUNLX1NJWkUgYXQgbGluayB0aW1lJylcblxuYXNzZXJ0KHR5cGVvZiBJbnQzMkFycmF5ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEludDMyQXJyYXkucHJvdG90eXBlLnN1YmFycmF5ICE9IHVuZGVmaW5lZCAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT0gdW5kZWZpbmVkLFxuICAgICAgICdKUyBlbmdpbmUgZG9lcyBub3QgcHJvdmlkZSBmdWxsIHR5cGVkIGFycmF5IHN1cHBvcnQnKTtcblxuLy8gSW4gbm9uLXN0YW5kYWxvbmUvbm9ybWFsIG1vZGUsIHdlIGNyZWF0ZSB0aGUgbWVtb3J5IGhlcmUuXG4vLyBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG4vLyBDcmVhdGUgdGhlIHdhc20gbWVtb3J5LiAoTm90ZTogdGhpcyBvbmx5IGFwcGxpZXMgaWYgSU1QT1JURURfTUVNT1JZIGlzIGRlZmluZWQpXG5cbi8vIGNoZWNrIGZvciBmdWxsIGVuZ2luZSBzdXBwb3J0ICh1c2Ugc3RyaW5nICdzdWJhcnJheScgdG8gYXZvaWQgY2xvc3VyZSBjb21waWxlciBjb25mdXNpb24pXG5cbiAgaWYgKE1vZHVsZVsnd2FzbU1lbW9yeSddKSB7XG4gICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xuICB9IGVsc2VcbiAge1xuICAgIHZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtsZWdhY3lNb2R1bGVQcm9wKCdJTklUSUFMX01FTU9SWScsICdJTklUSUFMX01FTU9SWScpO1xuXG4gICAgYXNzZXJ0KElOSVRJQUxfTUVNT1JZID49IDUyNDI4ODAsICdJTklUSUFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gU1RBQ0tfU0laRSwgd2FzICcgKyBJTklUSUFMX01FTU9SWSArICchIChTVEFDS19TSVpFPScgKyA1MjQyODgwICsgJyknKTtcbiAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAnaW5pdGlhbCc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG4gICAgICAvLyBJbiB0aGVvcnkgd2Ugc2hvdWxkIG5vdCBuZWVkIHRvIGVtaXQgdGhlIG1heGltdW0gaWYgd2Ugd2FudCBcInVubGltaXRlZFwiXG4gICAgICAvLyBvciA0R0Igb2YgbWVtb3J5LCBidXQgVk1zIGVycm9yIG9uIHRoYXQgYXRtLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9pc3N1ZXMvMTQxMzBcbiAgICAgIC8vIEFuZCBpbiB0aGUgcHRocmVhZHMgY2FzZSB3ZSBkZWZpbml0ZWx5IG5lZWQgdG8gZW1pdCBhIG1heGltdW0uIFNvXG4gICAgICAvLyBhbHdheXMgZW1pdCBvbmUuXG4gICAgICAnbWF4aW11bSc6IDIxNDc0ODM2NDggLyA2NTUzNixcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfc3RhY2tfY2hlY2suanNcbi8vIEluaXRpYWxpemVzIHRoZSBzdGFjayBjb29raWUuIENhbGxlZCBhdCB0aGUgc3RhcnR1cCBvZiBtYWluIGFuZCBhdCB0aGUgc3RhcnR1cCBvZiBlYWNoIHRocmVhZCBpbiBwdGhyZWFkcyBtb2RlLlxuZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcbiAgdmFyIG1heCA9IF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQoKTtcbiAgYXNzZXJ0KChtYXggJiAzKSA9PSAwKTtcbiAgLy8gSWYgdGhlIHN0YWNrIGVuZHMgYXQgYWRkcmVzcyB6ZXJvIHdlIHdyaXRlIG91ciBjb29raWVzIDQgYnl0ZXMgaW50byB0aGVcbiAgLy8gc3RhY2suICBUaGlzIHByZXZlbnRzIGludGVyZmVyZW5jZSB3aXRoIFNBRkVfSEVBUCBhbmQgQVNBTiB3aGljaCBhbHNvXG4gIC8vIG1vbml0b3Igd3JpdGVzIHRvIGFkZHJlc3MgemVyby5cbiAgaWYgKG1heCA9PSAwKSB7XG4gICAgbWF4ICs9IDQ7XG4gIH1cbiAgLy8gVGhlIHN0YWNrIGdyb3cgZG93bndhcmRzIHRvd2FyZHMgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZC5cbiAgLy8gV2Ugd3JpdGUgY29va2llcyB0byB0aGUgZmluYWwgdHdvIHdvcmRzIGluIHRoZSBzdGFjayBhbmQgZGV0ZWN0IGlmIHRoZXkgYXJlXG4gIC8vIGV2ZXIgb3ZlcndyaXR0ZW4uXG4gIEhFQVBVMzJbKChtYXgpPj4yKV0gPSAweDAyMTM1NDY3O1xuICBIRUFQVTMyWygoKG1heCkrKDQpKT4+MildID0gMHg4OUJBQ0RGRTtcbiAgLy8gQWxzbyB0ZXN0IHRoZSBnbG9iYWwgYWRkcmVzcyAwIGZvciBpbnRlZ3JpdHkuXG4gIEhFQVBVMzJbKCgwKT4+MildID0gMTY2ODUwOTAyOTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGFja0Nvb2tpZSgpIHtcbiAgaWYgKEFCT1JUKSByZXR1cm47XG4gIHZhciBtYXggPSBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kKCk7XG4gIC8vIFNlZSB3cml0ZVN0YWNrQ29va2llKCkuXG4gIGlmIChtYXggPT0gMCkge1xuICAgIG1heCArPSA0O1xuICB9XG4gIHZhciBjb29raWUxID0gSEVBUFUzMlsoKG1heCk+PjIpXTtcbiAgdmFyIGNvb2tpZTIgPSBIRUFQVTMyWygoKG1heCkrKDQpKT4+MildO1xuICBpZiAoY29va2llMSAhPSAweDAyMTM1NDY3IHx8IGNvb2tpZTIgIT0gMHg4OUJBQ0RGRSkge1xuICAgIGFib3J0KGBTdGFjayBvdmVyZmxvdyEgU3RhY2sgY29va2llIGhhcyBiZWVuIG92ZXJ3cml0dGVuIGF0ICR7cHRyVG9TdHJpbmcobWF4KX0sIGV4cGVjdGVkIGhleCBkd29yZHMgMHg4OUJBQ0RGRSBhbmQgMHgyMTM1NDY3LCBidXQgcmVjZWl2ZWQgJHtwdHJUb1N0cmluZyhjb29raWUyKX0gJHtwdHJUb1N0cmluZyhjb29raWUxKX1gKTtcbiAgfVxuICAvLyBBbHNvIHRlc3QgdGhlIGdsb2JhbCBhZGRyZXNzIDAgZm9yIGludGVncml0eS5cbiAgaWYgKEhFQVBVMzJbKCgwKT4+MildICE9IDB4NjM3MzZkNjUgLyogJ2Vtc2MnICovKSB7XG4gICAgYWJvcnQoJ1J1bnRpbWUgZXJyb3I6IFRoZSBhcHBsaWNhdGlvbiBoYXMgY29ycnVwdGVkIGl0cyBoZWFwIG1lbW9yeSBhcmVhIChhZGRyZXNzIHplcm8pIScpO1xuICB9XG59XG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zdGFja19jaGVjay5qc1xudmFyIF9fQVRQUkVSVU5fXyAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBiZWZvcmUgdGhlIHJ1bnRpbWUgaXMgaW5pdGlhbGl6ZWRcbnZhciBfX0FUSU5JVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHN0YXJ0dXBcbnZhciBfX0FURVhJVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHNodXRkb3duXG52YXIgX19BVFBPU1RSVU5fXyA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGFmdGVyIHRoZSBtYWluKCkgaXMgY2FsbGVkXG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxudmFyIHJ1bnRpbWVFeGl0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuICBpZiAoTW9kdWxlWydwcmVSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTtcbn1cblxuZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gIGFzc2VydCghcnVudGltZUluaXRpYWxpemVkKTtcbiAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICBjaGVja1N0YWNrQ29va2llKCk7XG5cbiAgXG5pZiAoIU1vZHVsZVsnbm9GU0luaXQnXSAmJiAhRlMuaW5pdGlhbGl6ZWQpXG4gIEZTLmluaXQoKTtcbkZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG5cblRUWS5pbml0KCk7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG5mdW5jdGlvbiBleGl0UnVudGltZSgpIHtcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkKTtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuICBfX19mdW5jc19vbl9leGl0KCk7IC8vIE5hdGl2ZSBhdGV4aXQoKSBmdW5jdGlvbnNcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVEVYSVRfXyk7XG4gIEZTLnF1aXQoKTtcblRUWS5zaHV0ZG93bigpO1xuICBydW50aW1lRXhpdGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7XG4gIF9fQVRFWElUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG4vLyBpbmNsdWRlOiBydW50aW1lX21hdGguanNcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvaW11bFxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Zyb3VuZFxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmNcblxuYXNzZXJ0KE1hdGguaW11bCwgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGguaW11bCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGguZnJvdW5kLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5mcm91bmQoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGwnKTtcbmFzc2VydChNYXRoLmNsejMyLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5jbHozMigpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGgudHJ1bmMsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLnRydW5jKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9tYXRoLmpzXG4vLyBBIGNvdW50ZXIgb2YgZGVwZW5kZW5jaWVzIGZvciBjYWxsaW5nIHJ1bigpLiBJZiB3ZSBuZWVkIHRvXG4vLyBkbyBhc3luY2hyb25vdXMgd29yayBiZWZvcmUgcnVubmluZywgaW5jcmVtZW50IHRoaXMgYW5kXG4vLyBkZWNyZW1lbnQgaXQuIEluY3JlbWVudGluZyBtdXN0IGhhcHBlbiBpbiBhIHBsYWNlIGxpa2Vcbi8vIE1vZHVsZS5wcmVSdW4gKHVzZWQgYnkgZW1jYyB0byBhZGQgZmlsZSBwcmVsb2FkaW5nKS5cbi8vIE5vdGUgdGhhdCB5b3UgY2FuIGFkZCBkZXBlbmRlbmNpZXMgaW4gcHJlUnVuLCBldmVuIHRob3VnaFxuLy8gaXQgaGFwcGVucyByaWdodCBiZWZvcmUgcnVuIC0gcnVuIHdpbGwgYmUgcG9zdHBvbmVkIHVudGlsXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGFyZSBtZXQuXG52YXIgcnVuRGVwZW5kZW5jaWVzID0gMDtcbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG52YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsgLy8gb3ZlcnJpZGRlbiB0byB0YWtlIGRpZmZlcmVudCBhY3Rpb25zIHdoZW4gYWxsIHJ1biBkZXBlbmRlbmNpZXMgYXJlIGZ1bGZpbGxlZFxudmFyIHJ1bkRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHZhciBvcmlnID0gaWQ7XG4gIHdoaWxlICgxKSB7XG4gICAgaWYgKCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBvcmlnICsgTWF0aC5yYW5kb20oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcysrO1xuXG4gIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddPy4ocnVuRGVwZW5kZW5jaWVzKTtcblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xuICAgIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xuICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciA9PT0gbnVsbCAmJiB0eXBlb2Ygc2V0SW50ZXJ2YWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGRlcGVuZGVuY2llcyBldmVyeSBmZXcgc2Vjb25kc1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChBQk9SVCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICBpZiAoIXNob3duKSB7XG4gICAgICAgICAgICBzaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnIoJ3N0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczonKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyKGBkZXBlbmRlbmN5OiAke2RlcH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd24pIHtcbiAgICAgICAgICBlcnIoJyhlbmQgb2YgbGlzdCknKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IGFkZGVkIHdpdGhvdXQgSUQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddPy4ocnVuRGVwZW5kZW5jaWVzKTtcblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gIH0gZWxzZSB7XG4gICAgZXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSByZW1vdmVkIHdpdGhvdXQgSUQnKTtcbiAgfVxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgIH1cbiAgfVxufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd8bnVtYmVyPX0gd2hhdCAqL1xuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuICBNb2R1bGVbJ29uQWJvcnQnXT8uKHdoYXQpO1xuXG4gIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgLy8gVE9ETyhzYmMpOiBTaG91bGQgd2UgcmVtb3ZlIHByaW50aW5nIGFuZCBsZWF2ZSBpdCB1cCB0byB3aG9ldmVyXG4gIC8vIGNhdGNoZXMgdGhlIGV4Y2VwdGlvbj9cbiAgZXJyKHdoYXQpO1xuXG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG5cbiAgLy8gVXNlIGEgd2FzbSBydW50aW1lIGVycm9yLCBiZWNhdXNlIGEgSlMgZXJyb3IgbWlnaHQgYmUgc2VlbiBhcyBhIGZvcmVpZ25cbiAgLy8gZXhjZXB0aW9uLCB3aGljaCBtZWFucyB3ZSdkIHJ1biBkZXN0cnVjdG9ycyBvbiBpdC4gV2UgbmVlZCB0aGUgZXJyb3IgdG9cbiAgLy8gc2ltcGx5IG1ha2UgdGhlIHByb2dyYW0gc3RvcC5cbiAgLy8gRklYTUUgVGhpcyBhcHByb2FjaCBkb2VzIG5vdCB3b3JrIGluIFdhc20gRUggYmVjYXVzZSBpdCBjdXJyZW50bHkgZG9lcyBub3QgYXNzdW1lXG4gIC8vIGFsbCBSdW50aW1lRXJyb3JzIGFyZSBmcm9tIHRyYXBzOyBpdCBkZWNpZGVzIHdoZXRoZXIgYSBSdW50aW1lRXJyb3IgaXMgZnJvbVxuICAvLyBhIHRyYXAgb3Igbm90IGJhc2VkIG9uIGEgaGlkZGVuIGZpZWxkIHdpdGhpbiB0aGUgb2JqZWN0LiBTbyBhdCB0aGUgbW9tZW50XG4gIC8vIHdlIGRvbid0IGhhdmUgYSB3YXkgb2YgdGhyb3dpbmcgYSB3YXNtIHRyYXAgZnJvbSBKUy4gVE9ETyBNYWtlIGEgSlMgQVBJIHRoYXRcbiAgLy8gYWxsb3dzIHRoaXMgaW4gdGhlIHdhc20gc3BlYy5cblxuICAvLyBTdXBwcmVzcyBjbG9zdXJlIGNvbXBpbGVyIHdhcm5pbmcgaGVyZS4gQ2xvc3VyZSBjb21waWxlcidzIGJ1aWx0aW4gZXh0ZXJuXG4gIC8vIGRlZmluaXRpb24gZm9yIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvciBjbGFpbXMgaXQgdGFrZXMgbm8gYXJndW1lbnRzIGV2ZW5cbiAgLy8gdGhvdWdoIGl0IGNhbi5cbiAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvcHVsbC8zOTEzKTogUmVtb3ZlIGlmL3doZW4gdXBzdHJlYW0gY2xvc3VyZSBnZXRzIGZpeGVkLlxuICAvKiogQHN1cHByZXNzIHtjaGVja1R5cGVzfSAqL1xuICB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG5cbiAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICAvLyBUaHJvdyB0aGUgZXJyb3Igd2hldGhlciBvciBub3QgTU9EVUxBUklaRSBpcyBzZXQgYmVjYXVzZSBhYm9ydCBpcyB1c2VkXG4gIC8vIGluIGNvZGUgcGF0aHMgYXBhcnQgZnJvbSBpbnN0YW50aWF0aW9uIHdoZXJlIGFuIGV4Y2VwdGlvbiBpcyBleHBlY3RlZFxuICAvLyB0byBiZSB0aHJvd24gd2hlbiBhYm9ydCBpcyBjYWxsZWQuXG4gIHRocm93IGU7XG59XG5cbi8vIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG4vLyBlbmQgaW5jbHVkZTogbWVtb3J5cHJvZmlsZXIuanNcbi8vIGluY2x1ZGU6IFVSSVV0aWxzLmpzXG4vLyBQcmVmaXggb2YgZGF0YSBVUklzIGVtaXR0ZWQgYnkgU0lOR0xFX0ZJTEUgYW5kIHJlbGF0ZWQgb3B0aW9ucy5cbnZhciBkYXRhVVJJUHJlZml4ID0gJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwnO1xuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxuICogQG5vaW5saW5lXG4gKi9cbnZhciBpc0RhdGFVUkkgPSAoZmlsZW5hbWUpID0+IGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7XG5cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgZmlsZW5hbWUgaXMgZGVsaXZlcmVkIHZpYSBmaWxlIHByb3RvY29sIChhcyBvcHBvc2VkIHRvIGh0dHAvaHR0cHMpXG4gKiBAbm9pbmxpbmVcbiAqL1xudmFyIGlzRmlsZVVSSSA9IChmaWxlbmFtZSkgPT4gZmlsZW5hbWUuc3RhcnRzV2l0aCgnZmlsZTovLycpO1xuLy8gZW5kIGluY2x1ZGU6IFVSSVV0aWxzLmpzXG5mdW5jdGlvbiBjcmVhdGVFeHBvcnRXcmFwcGVyKG5hbWUsIG5hcmdzKSB7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsIGBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBjYWxsZWQgYmVmb3JlIHJ1bnRpbWUgaW5pdGlhbGl6YXRpb25gKTtcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsIGBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBjYWxsZWQgYWZ0ZXIgcnVudGltZSBleGl0ICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKWApO1xuICAgIHZhciBmID0gd2FzbUV4cG9ydHNbbmFtZV07XG4gICAgYXNzZXJ0KGYsIGBleHBvcnRlZCBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBub3QgZm91bmRgKTtcbiAgICAvLyBPbmx5IGFzc2VydCBmb3IgdG9vIG1hbnkgYXJndW1lbnRzLiBUb28gZmV3IGNhbiBiZSB2YWxpZCBzaW5jZSB0aGUgbWlzc2luZyBhcmd1bWVudHMgd2lsbCBiZSB6ZXJvIGZpbGxlZC5cbiAgICBhc3NlcnQoYXJncy5sZW5ndGggPD0gbmFyZ3MsIGBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBjYWxsZWQgd2l0aCAke2FyZ3MubGVuZ3RofSBhcmdzIGJ1dCBleHBlY3RzICR7bmFyZ3N9YCk7XG4gICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gIH07XG59XG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfZXhjZXB0aW9ucy5qc1xuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZXhjZXB0aW9ucy5qc1xuZnVuY3Rpb24gZmluZFdhc21CaW5hcnkoKSB7XG4gIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgIHZhciBmID0gJ2Vtc2NyaXB0ZW4tbW9kdWxlLndhc20nO1xuICAgIGlmICghaXNEYXRhVVJJKGYpKSB7XG4gICAgICByZXR1cm4gbG9jYXRlRmlsZShmKTtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgLy8gVXNlIGJ1bmRsZXItZnJpZW5kbHkgYG5ldyBVUkwoLi4uLCBpbXBvcnQubWV0YS51cmwpYCBwYXR0ZXJuOyB3b3JrcyBpbiBicm93c2VycyB0b28uXG4gIHJldHVybiBuZXcgVVJMKCdlbXNjcmlwdGVuLW1vZHVsZS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG5cbmZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZmlsZSkge1xuICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICB9XG4gIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH1cbiAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgdGhlIGJpbmFyeSB5ZXQsIGxvYWQgaXQgYXN5bmNocm9ub3VzbHkgdXNpbmcgcmVhZEFzeW5jLlxuICBpZiAoIXdhc21CaW5hcnlcbiAgICAgICkge1xuICAgIC8vIEZldGNoIHRoZSBiaW5hcnkgdXNpbmcgcmVhZEFzeW5jXG4gICAgcmV0dXJuIHJlYWRBc3luYyhiaW5hcnlGaWxlKS50aGVuKFxuICAgICAgKHJlc3BvbnNlKSA9PiBuZXcgVWludDhBcnJheSgvKiogQHR5cGV7IUFycmF5QnVmZmVyfSAqLyhyZXNwb25zZSkpLFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGdldEJpbmFyeVN5bmMgaWYgcmVhZEFzeW5jIGZhaWxzXG4gICAgICAoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpXG4gICAgKTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZ2V0QmluYXJ5U3luYyBzaG91bGQgYmUgYWJsZSB0byBnZXQgaXQgc3luY2hyb25vdXNseVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKTtcbn1cblxudmFyIHdhc21Tb3VyY2VNYXA7XG4vLyBpbmNsdWRlOiBzb3VyY2VfbWFwX3N1cHBvcnQuanNcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdhc21Tb3VyY2VNYXAoc291cmNlTWFwKSB7XG4gIHRoaXMudmVyc2lvbiA9IHNvdXJjZU1hcC52ZXJzaW9uO1xuICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VNYXAuc291cmNlcztcbiAgdGhpcy5uYW1lcyA9IHNvdXJjZU1hcC5uYW1lcztcblxuICB0aGlzLm1hcHBpbmcgPSB7fTtcbiAgdGhpcy5vZmZzZXRzID0gW107XG5cbiAgdmFyIHZscU1hcCA9IHt9O1xuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB2bHFNYXBbY10gPSBpKTtcblxuICAvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUmljaC1IYXJyaXMvdmxxL2Jsb2IvbWFzdGVyL3NyYy92bHEudHNcbiAgZnVuY3Rpb24gZGVjb2RlVkxRKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciB2YWx1ZSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGludGVnZXIgPSB2bHFNYXBbc3RyaW5nW2ldXTtcbiAgICAgIGlmIChpbnRlZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciAoJyArIHN0cmluZ1tpXSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlICs9IChpbnRlZ2VyICYgMzEpIDw8IHNoaWZ0O1xuXG4gICAgICBpZiAoaW50ZWdlciAmIDMyKSB7XG4gICAgICAgIHNoaWZ0ICs9IDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVnYXRlID0gdmFsdWUgJiAxO1xuICAgICAgICB2YWx1ZSA+Pj0gMTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmVnYXRlID8gLXZhbHVlIDogdmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSAwLCBzcmMgPSAwLCBsaW5lID0gMSwgY29sID0gMSwgbmFtZSA9IDA7XG4gIHNvdXJjZU1hcC5tYXBwaW5ncy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgaWYgKCFzZWdtZW50KSByZXR1cm47XG4gICAgdmFyIGRhdGEgPSBkZWNvZGVWTFEoc2VnbWVudCk7XG4gICAgdmFyIGluZm8gPSB7fTtcblxuICAgIG9mZnNldCArPSBkYXRhWzBdO1xuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAyKSBpbmZvLnNvdXJjZSA9IHNyYyArPSBkYXRhWzFdO1xuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAzKSBpbmZvLmxpbmUgPSBsaW5lICs9IGRhdGFbMl07XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDQpIGluZm8uY29sdW1uID0gY29sICs9IGRhdGFbM107XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDUpIGluZm8ubmFtZSA9IG5hbWUgKz0gZGF0YVs0XTtcbiAgICB0aGlzLm1hcHBpbmdbb2Zmc2V0XSA9IGluZm87XG4gICAgdGhpcy5vZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgfSwgdGhpcyk7XG4gIHRoaXMub2Zmc2V0cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG59XG5cbldhc21Tb3VyY2VNYXAucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICBpZiAoIXdhc21PZmZzZXRDb252ZXJ0ZXIuaXNTYW1lRnVuYyhvZmZzZXQsIG5vcm1hbGl6ZWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGluZm8gPSB0aGlzLm1hcHBpbmdbbm9ybWFsaXplZF07XG4gIGlmICghaW5mbykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogdGhpcy5zb3VyY2VzW2luZm8uc291cmNlXSxcbiAgICBsaW5lOiBpbmZvLmxpbmUsXG4gICAgY29sdW1uOiBpbmZvLmNvbHVtbixcbiAgICBuYW1lOiB0aGlzLm5hbWVzW2luZm8ubmFtZV0sXG4gIH07XG59XG5cbldhc21Tb3VyY2VNYXAucHJvdG90eXBlLm5vcm1hbGl6ZU9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgdmFyIGxvID0gMDtcbiAgdmFyIGhpID0gdGhpcy5vZmZzZXRzLmxlbmd0aDtcbiAgdmFyIG1pZDtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIG1pZCA9IE1hdGguZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgaWYgKHRoaXMub2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5vZmZzZXRzW2xvIC0gMV07XG59XG5cbnZhciB3YXNtU291cmNlTWFwRmlsZSA9ICdlbXNjcmlwdGVuLW1vZHVsZS53YXNtLm1hcCc7XG5pZiAoIWlzRGF0YVVSSSh3YXNtU291cmNlTWFwRmlsZSkpIHtcbiAgd2FzbVNvdXJjZU1hcEZpbGUgPSBsb2NhdGVGaWxlKHdhc21Tb3VyY2VNYXBGaWxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlTWFwKCkge1xuICB2YXIgYnVmID0gcmVhZEJpbmFyeSh3YXNtU291cmNlTWFwRmlsZSk7XG4gIHJldHVybiBKU09OLnBhcnNlKFVURjhBcnJheVRvU3RyaW5nKGJ1ZiwgMCwgYnVmLmxlbmd0aCkpO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VNYXBQcm9taXNlKCkge1xuICBpZiAoKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpICYmIHR5cGVvZiBmZXRjaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZldGNoKHdhc21Tb3VyY2VNYXBGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC5jYXRjaChnZXRTb3VyY2VNYXApO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2V0U291cmNlTWFwKCkpO1xufVxuLy8gZW5kIGluY2x1ZGU6IHNvdXJjZV9tYXBfc3VwcG9ydC5qc1xuXG52YXIgd2FzbU9mZnNldENvbnZlcnRlcjtcbi8vIGluY2x1ZGU6IHdhc21fb2Zmc2V0X2NvbnZlcnRlci5qc1xuLyoqIEBjb25zdHJ1Y3RvciAqL1xuZnVuY3Rpb24gV2FzbU9mZnNldENvbnZlcnRlcih3YXNtQnl0ZXMsIHdhc21Nb2R1bGUpIHtcbiAgLy8gVGhpcyBjbGFzcyBwYXJzZXMgYSBXQVNNIGJpbmFyeSBmaWxlLCBhbmQgY29uc3RydWN0cyBhIG1hcHBpbmcgZnJvbVxuICAvLyBmdW5jdGlvbiBpbmRpY2VzIHRvIHRoZSBzdGFydCBvZiB0aGVpciBjb2RlIGluIHRoZSBiaW5hcnkgZmlsZSwgYXMgd2VsbFxuICAvLyBhcyBwYXJzaW5nIHRoZSBuYW1lIHNlY3Rpb24gdG8gYWxsb3cgY29udmVyc2lvbiBvZiBvZmZzZXRzIHRvIGZ1bmN0aW9uIG5hbWVzLlxuICAvL1xuICAvLyBUaGUgbWFpbiBwdXJwb3NlIG9mIHRoaXMgbW9kdWxlIGlzIHRvIGVuYWJsZSB0aGUgY29udmVyc2lvbiBvZiBmdW5jdGlvblxuICAvLyBpbmRleCBhbmQgb2Zmc2V0IGZyb20gc3RhcnQgb2YgZnVuY3Rpb24gdG8gYW4gb2Zmc2V0IGludG8gdGhlIFdBU00gYmluYXJ5LlxuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBsb29rIHVwIHRoZSBXQVNNIHNvdXJjZSBtYXAgYXMgd2VsbCBhcyBnZW5lcmF0ZVxuICAvLyBjb25zaXN0ZW50IHByb2dyYW0gY291bnRlciByZXByZXNlbnRhdGlvbnMgZ2l2ZW4gdjgncyBub24tc3RhbmRhcmRcbiAgLy8gV0FTTSBzdGFjayB0cmFjZSBmb3JtYXQuXG4gIC8vXG4gIC8vIHY4IGJ1ZzogaHR0cHM6Ly9jcmJ1Zy5jb20vdjgvOTE3MlxuICAvL1xuICAvLyBUaGlzIGNvZGUgaXMgYWxzbyB1c2VkIHRvIGNoZWNrIGlmIHRoZSBjYW5kaWRhdGUgc291cmNlIG1hcCBvZmZzZXQgaXNcbiAgLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgc2FtZSBmdW5jdGlvbiBhcyB0aGUgb2Zmc2V0IHdlIGFyZSBsb29raW5nIGZvcixcbiAgLy8gYXMgd2VsbCBhcyBwcm92aWRpbmcgdGhlIGZ1bmN0aW9uIG5hbWVzIGZvciBhIGdpdmVuIG9mZnNldC5cblxuICAvLyBjdXJyZW50IGJ5dGUgb2Zmc2V0IGludG8gdGhlIFdBU00gYmluYXJ5LCBhcyB3ZSBwYXJzZSBpdFxuICAvLyB0aGUgZmlyc3Qgc2VjdGlvbiBzdGFydHMgYXQgb2Zmc2V0IDguXG4gIHZhciBvZmZzZXQgPSA4O1xuXG4gIC8vIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBmdW5jdGlvbiB3ZSBzZWUgaW4gdGhlIGJpbmFyeVxuICB2YXIgZnVuY2lkeCA9IDA7XG5cbiAgLy8gbWFwIGZyb20gZnVuY3Rpb24gaW5kZXggdG8gYnl0ZSBvZmZzZXQgaW4gV0FTTSBiaW5hcnlcbiAgdGhpcy5vZmZzZXRfbWFwID0ge307XG4gIHRoaXMuZnVuY19zdGFydHMgPSBbXTtcblxuICAvLyBtYXAgZnJvbSBmdW5jdGlvbiBpbmRleCB0byBuYW1lcyBpbiBXQVNNIGJpbmFyeVxuICB0aGlzLm5hbWVfbWFwID0ge307XG5cbiAgLy8gbnVtYmVyIG9mIGltcG9ydGVkIGZ1bmN0aW9ucyB0aGlzIG1vZHVsZSBoYXNcbiAgdGhpcy5pbXBvcnRfZnVuY3Rpb25zID0gMDtcblxuICAvLyB0aGUgYnVmZmVyIHVuc2lnbmVkTEVCMTI4IHdpbGwgcmVhZCBmcm9tLlxuICB2YXIgYnVmZmVyID0gd2FzbUJ5dGVzO1xuXG4gIGZ1bmN0aW9uIHVuc2lnbmVkTEVCMTI4KCkge1xuICAgIC8vIGNvbnN1bWVzIGFuIHVuc2lnbmVkIExFQjEyOCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IGBvZmZzZXRgLlxuICAgIC8vIGNoYW5nZXMgYG9mZnNldGAgdG8gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGludGVnZXJcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIGRvIHtcbiAgICAgIHZhciBieXRlID0gYnVmZmVyW29mZnNldCsrXTtcbiAgICAgIHJlc3VsdCArPSAoYnl0ZSAmIDB4N0YpIDw8IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gNztcbiAgICB9IHdoaWxlIChieXRlICYgMHg4MCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBMaW1pdHMoKSB7XG4gICAgdmFyIGZsYWdzID0gdW5zaWduZWRMRUIxMjgoKTtcbiAgICB1bnNpZ25lZExFQjEyOCgpOyAvLyBpbml0aWFsIHNpemVcbiAgICB2YXIgaGFzTWF4ID0gKGZsYWdzICYgMSkgIT0gMDtcbiAgICBpZiAoaGFzTWF4KSB7XG4gICAgICB1bnNpZ25lZExFQjEyOCgpO1xuICAgIH1cbiAgfVxuXG4gIGJpbmFyeV9wYXJzZTpcbiAgd2hpbGUgKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgdmFyIHR5cGUgPSBidWZmZXJbb2Zmc2V0KytdO1xuICAgIHZhciBlbmQgPSB1bnNpZ25lZExFQjEyOCgpICsgb2Zmc2V0O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAyOiAvLyBpbXBvcnQgc2VjdGlvblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpbmQgYWxsIGZ1bmN0aW9uIGltcG9ydHMgYW5kIGluY3JlbWVudCBmdW5jaWR4IGZvciBlYWNoIG9uZVxuICAgICAgICAvLyBzaW5jZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGUgbW9kdWxlIGFyZSBudW1iZXJlZCBhZnRlciBhbGwgaW1wb3J0c1xuICAgICAgICB2YXIgY291bnQgPSB1bnNpZ25lZExFQjEyOCgpO1xuXG4gICAgICAgIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgICAgICAgIC8vIHNraXAgbW9kdWxlXG4gICAgICAgICAgb2Zmc2V0ID0gdW5zaWduZWRMRUIxMjgoKSArIG9mZnNldDtcbiAgICAgICAgICAvLyBza2lwIG5hbWVcbiAgICAgICAgICBvZmZzZXQgPSB1bnNpZ25lZExFQjEyOCgpICsgb2Zmc2V0O1xuXG4gICAgICAgICAgdmFyIGtpbmQgPSBidWZmZXJbb2Zmc2V0KytdO1xuICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyBmdW5jdGlvbiBpbXBvcnRcbiAgICAgICAgICAgICAgKytmdW5jaWR4O1xuICAgICAgICAgICAgICB1bnNpZ25lZExFQjEyOCgpOyAvLyBza2lwIGZ1bmN0aW9uIHR5cGVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHRhYmxlIGltcG9ydFxuICAgICAgICAgICAgICB1bnNpZ25lZExFQjEyOCgpOyAvLyBza2lwIGVsZW0gdHlwZVxuICAgICAgICAgICAgICBza2lwTGltaXRzKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiAvLyBtZW1vcnkgaW1wb3J0XG4gICAgICAgICAgICAgIHNraXBMaW1pdHMoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6IC8vIGdsb2JhbCBpbXBvcnRcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7IC8vIHNraXAgdHlwZSBpZCBieXRlIGFuZCBtdXRhYmlsaXR5IGJ5dGVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHRhZyBpbXBvcnRcbiAgICAgICAgICAgICAgKytvZmZzZXQ7IC8vIHNraXAgYXR0cmlidXRlXG4gICAgICAgICAgICAgIHVuc2lnbmVkTEVCMTI4KCk7IC8vIHNraXAgdGFnIHR5cGVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyAnYmFkIGltcG9ydCBraW5kOiAnICsga2luZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXBvcnRfZnVuY3Rpb25zID0gZnVuY2lkeDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwOiAvLyBjb2RlIHNlY3Rpb25cbiAgICAgICAgdmFyIGNvdW50ID0gdW5zaWduZWRMRUIxMjgoKTtcbiAgICAgICAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSB1bnNpZ25lZExFQjEyOCgpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0X21hcFtmdW5jaWR4KytdID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuZnVuY19zdGFydHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrIGJpbmFyeV9wYXJzZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25zID0gV2ViQXNzZW1ibHkuTW9kdWxlLmN1c3RvbVNlY3Rpb25zKHdhc21Nb2R1bGUsIFwibmFtZVwiKTtcbiAgdmFyIG5hbWVTZWN0aW9uID0gc2VjdGlvbnMubGVuZ3RoID8gc2VjdGlvbnNbMF0gOiB1bmRlZmluZWQ7XG4gIGlmIChuYW1lU2VjdGlvbikge1xuICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5hbWVTZWN0aW9uKTtcbiAgICBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YXIgc3Vic2VjdGlvbl90eXBlID0gYnVmZmVyW29mZnNldCsrXTtcbiAgICAgIHZhciBsZW4gPSB1bnNpZ25lZExFQjEyOCgpOyAvLyBieXRlIGNvdW50XG4gICAgICBpZiAoc3Vic2VjdGlvbl90eXBlICE9IDEpIHtcbiAgICAgICAgLy8gU2tpcCB0aGUgd2hvbGUgc3ViLXNlY3Rpb24gaWYgaXQncyBub3QgYSBmdW5jdGlvbiBuYW1lIHN1Yi1zZWN0aW9uLlxuICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudCA9IHVuc2lnbmVkTEVCMTI4KCk7XG4gICAgICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdW5zaWduZWRMRUIxMjgoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHVuc2lnbmVkTEVCMTI4KCk7XG4gICAgICAgIHRoaXMubmFtZV9tYXBbaW5kZXhdID0gVVRGOEFycmF5VG9TdHJpbmcoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbldhc21PZmZzZXRDb252ZXJ0ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoZnVuY2lkeCwgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLm9mZnNldF9tYXBbZnVuY2lkeF0gKyBvZmZzZXQ7XG59XG5cbldhc21PZmZzZXRDb252ZXJ0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICB2YXIgbG8gPSAwO1xuICB2YXIgaGkgPSB0aGlzLmZ1bmNfc3RhcnRzLmxlbmd0aDtcbiAgdmFyIG1pZDtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIG1pZCA9IE1hdGguZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgaWYgKHRoaXMuZnVuY19zdGFydHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvICsgdGhpcy5pbXBvcnRfZnVuY3Rpb25zIC0gMTtcbn1cblxuV2FzbU9mZnNldENvbnZlcnRlci5wcm90b3R5cGUuaXNTYW1lRnVuYyA9IGZ1bmN0aW9uIChvZmZzZXQxLCBvZmZzZXQyKSB7XG4gIHJldHVybiB0aGlzLmdldEluZGV4KG9mZnNldDEpID09IHRoaXMuZ2V0SW5kZXgob2Zmc2V0Mik7XG59XG5cbldhc21PZmZzZXRDb252ZXJ0ZXIucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgob2Zmc2V0KTtcbiAgcmV0dXJuIHRoaXMubmFtZV9tYXBbaW5kZXhdIHx8ICgnd2FzbS1mdW5jdGlvblsnICsgaW5kZXggKyAnXScpO1xufVxuLy8gZW5kIGluY2x1ZGU6IHdhc21fb2Zmc2V0X2NvbnZlcnRlci5qc1xuXG5mdW5jdGlvbiByZWNlaXZlU291cmNlTWFwSlNPTihzb3VyY2VNYXApIHtcbiAgd2FzbVNvdXJjZU1hcCA9IG5ldyBXYXNtU291cmNlTWFwKHNvdXJjZU1hcCk7XG4gIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ3NvdXJjZS1tYXAnKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCByZWNlaXZlcikge1xuICB2YXIgc2F2ZWRCaW5hcnk7XG4gIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oKGJpbmFyeSkgPT4ge1xuICAgIHNhdmVkQmluYXJ5ID0gYmluYXJ5O1xuICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGltcG9ydHMpO1xuICB9KS50aGVuKChpbnN0YW5jZSkgPT4ge1xuICAgIC8vIHdhc21PZmZzZXRDb252ZXJ0ZXIgbmVlZHMgdG8gYmUgYXNzaWduZWQgYmVmb3JlIGNhbGxpbmcgdGhlIHJlY2VpdmVyXG4gICAgLy8gKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS4gIFNlZSBjb21tZW50cyBiZWxvdyBpbiBpbnN0YW50aWF0ZUFzeW5jLlxuICAgIHdhc21PZmZzZXRDb252ZXJ0ZXIgPSBuZXcgV2FzbU9mZnNldENvbnZlcnRlcihzYXZlZEJpbmFyeSwgaW5zdGFuY2UubW9kdWxlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0pLnRoZW4ocmVjZWl2ZXIsIChyZWFzb24pID0+IHtcbiAgICBlcnIoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7cmVhc29ufWApO1xuXG4gICAgLy8gV2FybiBvbiBzb21lIGNvbW1vbiBwcm9ibGVtcy5cbiAgICBpZiAoaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICAgICAgZXJyKGB3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoJHt3YXNtQmluYXJ5RmlsZX0pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbW9zdCBicm93c2Vycy4gU2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9nZXR0aW5nX3N0YXJ0ZWQvRkFRLmh0bWwjaG93LWRvLWktcnVuLWEtbG9jYWwtd2Vic2VydmVyLWZvci10ZXN0aW5nLXdoeS1kb2VzLW15LXByb2dyYW0tc3RhbGwtaW4tZG93bmxvYWRpbmctb3ItcHJlcGFyaW5nYCk7XG4gICAgfVxuICAgIGFib3J0KHJlYXNvbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFiaW5hcnkgJiZcbiAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAhaXNEYXRhVVJJKGJpbmFyeUZpbGUpICYmXG4gICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmZXRjaChiaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBTdXBwcmVzcyBjbG9zdXJlIHdhcm5pbmcgaGVyZSBzaW5jZSB0aGUgdXBzdHJlYW0gZGVmaW5pdGlvbiBmb3JcbiAgICAgIC8vIGluc3RhbnRpYXRlU3RyZWFtaW5nIG9ubHkgYWxsb3dzIFByb21pc2U8UmVwc3BvbnNlPiByYXRoZXIgdGhhblxuICAgICAgLy8gYW4gYWN0dWFsIFJlc3BvbnNlLlxuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvcHVsbC8zOTEzKTogUmVtb3ZlIGlmL3doZW4gdXBzdHJlYW0gY2xvc3VyZSBpcyBmaXhlZC5cbiAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGltcG9ydHMpO1xuXG4gICAgICAvLyBXZSBuZWVkIHRoZSB3YXNtIGJpbmFyeSBmb3IgdGhlIG9mZnNldCBjb252ZXJ0ZXIuIENsb25lIHRoZSByZXNwb25zZVxuICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IGl0cyBhcnJheUJ1ZmZlciAoY2xvbmluZyBzaG91bGQgYmUgbW9yZSBlZmZpY2llbnRcbiAgICAgIC8vIHRoYW4gZG9pbmcgYW5vdGhlciBlbnRpcmUgcmVxdWVzdCkuXG4gICAgICAvLyAoV2UgbXVzdCBjbG9uZSB0aGUgcmVzcG9uc2Ugbm93IGluIG9yZGVyIHRvIHVzZSBpdCBsYXRlciwgYXMgaWYgd2VcbiAgICAgIC8vIHRyeSB0byBjbG9uZSBpdCBhc3luY2hyb25vdXNseSBsb3dlciBkb3duIHRoZW4gd2Ugd2lsbCBnZXQgYVxuICAgICAgLy8gXCJyZXNwb25zZSB3YXMgYWxyZWFkeSBjb25zdW1lZFwiIGVycm9yLilcbiAgICAgIHZhciBjbG9uZWRSZXNwb25zZVByb21pc2UgPSByZXNwb25zZS5jbG9uZSgpLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQudGhlbihcbiAgICAgICAgZnVuY3Rpb24oaW5zdGFudGlhdGlvblJlc3VsdCkge1xuICAgICAgICAgIC8vIFdoZW4gdXNpbmcgdGhlIG9mZnNldCBjb252ZXJ0ZXIsIHdlIG11c3QgaW50ZXJwb3NlIGhlcmUuIEZpcnN0LFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW50aWF0aW9uIHJlc3VsdCBtdXN0IGFycml2ZSAoaWYgaXQgZmFpbHMsIHRoZSBlcnJvclxuICAgICAgICAgIC8vIGhhbmRsaW5nIGxhdGVyIGRvd24gd2lsbCBoYW5kbGUgaXQpLiBPbmNlIGl0IGFycml2ZXMsIHdlIGNhblxuICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIG9mZnNldCBjb252ZXJ0ZXIuIEFuZCBvbmx5IHRoZW4gaXMgaXQgdmFsaWQgdG9cbiAgICAgICAgICAvLyBjYWxsIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LCBhcyB0aGF0IGZ1bmN0aW9uIHdpbGwgdXNlIHRoZVxuICAgICAgICAgIC8vIG9mZnNldCBjb252ZXJ0ZXIgKGluIHRoZSBjYXNlIG9mIHB0aHJlYWRzLCBpdCB3aWxsIGNyZWF0ZSB0aGVcbiAgICAgICAgICAvLyBwdGhyZWFkcyBhbmQgc2VuZCB0aGVtIHRoZSBvZmZzZXRzIGFsb25nIHdpdGggdGhlIHdhc20gaW5zdGFuY2UpLlxuXG4gICAgICAgICAgY2xvbmVkUmVzcG9uc2VQcm9taXNlLnRoZW4oKGFycmF5QnVmZmVyUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIHdhc21PZmZzZXRDb252ZXJ0ZXIgPSBuZXcgV2FzbU9mZnNldENvbnZlcnRlcihuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlclJlc3VsdCksIGluc3RhbnRpYXRpb25SZXN1bHQubW9kdWxlKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soaW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKHJlYXNvbikgPT4gZXJyKGBmYWlsZWQgdG8gaW5pdGlhbGl6ZSBvZmZzZXQtY29udmVydGVyOiAke3JlYXNvbn1gKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgbW9zdCBjb21tb24gZmFpbHVyZSBjYXVzZSB0byBiZSBhIGJhZCBNSU1FIHR5cGUgZm9yIHRoZSBiaW5hcnksXG4gICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSBmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbiBzaG91bGQgd29yay5cbiAgICAgICAgICBlcnIoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke3JlYXNvbn1gKTtcbiAgICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFdhc21JbXBvcnRzKCkge1xuICAvLyBwcmVwYXJlIGltcG9ydHNcbiAgcmV0dXJuIHtcbiAgICAnZW52Jzogd2FzbUltcG9ydHMsXG4gICAgJ3dhc2lfc25hcHNob3RfcHJldmlldzEnOiB3YXNtSW1wb3J0cyxcbiAgfVxufVxuXG4vLyBDcmVhdGUgdGhlIHdhc20gaW5zdGFuY2UuXG4vLyBSZWNlaXZlcyB0aGUgd2FzbSBpbXBvcnRzLCByZXR1cm5zIHRoZSBleHBvcnRzLlxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgdmFyIGluZm8gPSBnZXRXYXNtSW1wb3J0cygpO1xuICAvLyBMb2FkIHRoZSB3YXNtIG1vZHVsZSBhbmQgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHVzaW5nIG5hdGl2ZSBzdXBwb3J0IGluIHRoZSBKUyBlbmdpbmUuXG4gIC8vIGhhbmRsZSBhIGdlbmVyYXRlZCB3YXNtIGluc3RhbmNlLCByZWNlaXZpbmcgaXRzIGV4cG9ydHMgYW5kXG4gIC8vIHBlcmZvcm1pbmcgb3RoZXIgbmVjZXNzYXJ5IHNldHVwXG4gIC8qKiBAcGFyYW0ge1dlYkFzc2VtYmx5Lk1vZHVsZT19IG1vZHVsZSovXG4gIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbUV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuXG4gICAgXG5cbiAgICBhZGRPbkluaXQod2FzbUV4cG9ydHNbJ19fd2FzbV9jYWxsX2N0b3JzJ10pO1xuXG4gICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuICAgIHJldHVybiB3YXNtRXhwb3J0cztcbiAgfVxuICAvLyB3YWl0IGZvciB0aGUgcHRocmVhZCBwb29sIChpZiBhbnkpXG4gIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICBhZGRSdW5EZXBlbmRlbmN5KCdzb3VyY2UtbWFwJyk7XG5cbiAgLy8gUHJlZmVyIHN0cmVhbWluZyBpbnN0YW50aWF0aW9uIGlmIGF2YWlsYWJsZS5cbiAgLy8gQXN5bmMgY29tcGlsYXRpb24gY2FuIGJlIGNvbmZ1c2luZyB3aGVuIGFuIGVycm9yIG9uIHRoZSBwYWdlIG92ZXJ3cml0ZXMgTW9kdWxlXG4gIC8vIChmb3IgZXhhbXBsZSwgaWYgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIHdyb25nLCBhbmQgdGhlIG9uZSBkZWZpbmluZyBNb2R1bGUgaXNcbiAgLy8gbGF0ZXIpLCBzbyB3ZSBzYXZlIE1vZHVsZSBhbmQgY2hlY2sgaXQgbGF0ZXIuXG4gIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyAncmVzdWx0JyBpcyBhIFJlc3VsdE9iamVjdCBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXG4gICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcbiAgICBhc3NlcnQoTW9kdWxlID09PSB0cnVlTW9kdWxlLCAndGhlIE1vZHVsZSBvYmplY3Qgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBkdXJpbmcgYXN5bmMgY29tcGlsYXRpb24gLSBwZXJoYXBzIHRoZSBvcmRlciBvZiBIVE1MIGVsZW1lbnRzIGlzIHdyb25nPycpO1xuICAgIHRydWVNb2R1bGUgPSBudWxsO1xuICAgIC8vIFRPRE86IER1ZSB0byBDbG9zdXJlIHJlZ3Jlc3Npb24gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMTkzLCB0aGUgYWJvdmUgbGluZSBubyBsb25nZXIgb3B0aW1pemVzIG91dCBkb3duIHRvIHRoZSBmb2xsb3dpbmcgbGluZS5cbiAgICAvLyBXaGVuIHRoZSByZWdyZXNzaW9uIGlzIGZpeGVkLCBjYW4gcmVzdG9yZSB0aGUgYWJvdmUgUFRIUkVBRFMtZW5hYmxlZCBwYXRoLlxuICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICB9XG5cbiAgLy8gVXNlciBzaGVsbCBwYWdlcyBjYW4gd3JpdGUgdGhlaXIgb3duIE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gPSBmdW5jdGlvbihpbXBvcnRzLCBzdWNjZXNzQ2FsbGJhY2spIGNhbGxiYWNrXG4gIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0b1xuICAvLyBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWwgdG8gYW55IG90aGVyIGFzeW5jIHN0YXJ0dXAgYWN0aW9ucyB0aGV5IGFyZVxuICAvLyBwZXJmb3JtaW5nLlxuICAvLyBBbHNvIHB0aHJlYWRzIGFuZCB3YXNtIHdvcmtlcnMgaW5pdGlhbGl6ZSB0aGUgd2FzbSBpbnN0YW5jZSB0aHJvdWdoIHRoaXNcbiAgLy8gcGF0aC5cbiAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfWApO1xuICAgICAgICAvLyBJZiBpbnN0YW50aWF0aW9uIGZhaWxzLCByZWplY3QgdGhlIG1vZHVsZSByZWFkeSBwcm9taXNlLlxuICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF3YXNtQmluYXJ5RmlsZSkgd2FzbUJpbmFyeUZpbGUgPSBmaW5kV2FzbUJpbmFyeSgpO1xuXG4gIC8vIElmIGluc3RhbnRpYXRpb24gZmFpbHMsIHJlamVjdCB0aGUgbW9kdWxlIHJlYWR5IHByb21pc2UuXG4gIGluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSwgd2FzbUJpbmFyeUZpbGUsIGluZm8sIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICBnZXRTb3VyY2VNYXBQcm9taXNlKCkudGhlbihyZWNlaXZlU291cmNlTWFwSlNPTik7XG4gIHJldHVybiB7fTsgLy8gbm8gZXhwb3J0cyB5ZXQ7IHdlJ2xsIGZpbGwgdGhlbSBpbiBsYXRlclxufVxuXG4vLyBHbG9iYWxzIHVzZWQgYnkgSlMgaTY0IGNvbnZlcnNpb25zIChzZWUgbWFrZVNldFZhbHVlKVxudmFyIHRlbXBEb3VibGU7XG52YXIgdGVtcEk2NDtcblxuLy8gaW5jbHVkZTogcnVudGltZV9kZWJ1Zy5qc1xuLy8gRW5kaWFubmVzcyBjaGVja1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgaDE2ID0gbmV3IEludDE2QXJyYXkoMSk7XG4gIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gIGgxNlswXSA9IDB4NjM3MztcbiAgaWYgKGg4WzBdICE9PSAweDczIHx8IGg4WzFdICE9PSAweDYzKSB0aHJvdyAnUnVudGltZSBlcnJvcjogZXhwZWN0ZWQgdGhlIHN5c3RlbSB0byBiZSBsaXR0bGUtZW5kaWFuISAoUnVuIHdpdGggLXNTVVBQT1JUX0JJR19FTkRJQU4gdG8gYnlwYXNzKSc7XG59KSgpO1xuXG5mdW5jdGlvbiBsZWdhY3lNb2R1bGVQcm9wKHByb3AsIG5ld05hbWUsIGluY29taW5nPXRydWUpIHtcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgcHJvcCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBwcm9wLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxldCBleHRyYSA9IGluY29taW5nID8gJyAodGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIHByb3ZpZGVkIG9uIE1vZHVsZSwgYnV0IGFmdGVyIHN0YXJ0dXAgdGhlIHZhbHVlIGlzIG9ubHkgbG9va2VkIGZvciBvbiBhIGxvY2FsIHZhcmlhYmxlIG9mIHRoYXQgbmFtZSknIDogJyc7XG4gICAgICAgIGFib3J0KGBcXGBNb2R1bGUuJHtwcm9wfVxcYCBoYXMgYmVlbiByZXBsYWNlZCBieSBcXGAke25ld05hbWV9XFxgYCArIGV4dHJhKTtcblxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICAgIGFib3J0KGBcXGBNb2R1bGUuJHtwcm9wfVxcYCB3YXMgc3VwcGxpZWQgYnV0IFxcYCR7cHJvcH1cXGAgbm90IGluY2x1ZGVkIGluIElOQ09NSU5HX01PRFVMRV9KU19BUElgKTtcbiAgfVxufVxuXG4vLyBmb3JjaW5nIHRoZSBmaWxlc3lzdGVtIGV4cG9ydHMgYSBmZXcgdGhpbmdzIGJ5IGRlZmF1bHRcbmZ1bmN0aW9uIGlzRXhwb3J0ZWRCeUZvcmNlRmlsZXN5c3RlbShuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnRlNfY3JlYXRlUGF0aCcgfHxcbiAgICAgICAgIG5hbWUgPT09ICdGU19jcmVhdGVEYXRhRmlsZScgfHxcbiAgICAgICAgIG5hbWUgPT09ICdGU19jcmVhdGVQcmVsb2FkZWRGaWxlJyB8fFxuICAgICAgICAgbmFtZSA9PT0gJ0ZTX3VubGluaycgfHxcbiAgICAgICAgIG5hbWUgPT09ICdhZGRSdW5EZXBlbmRlbmN5JyB8fFxuICAgICAgICAgLy8gVGhlIG9sZCBGUyBoYXMgc29tZSBmdW5jdGlvbmFsaXR5IHRoYXQgV2FzbUZTIGxhY2tzLlxuICAgICAgICAgbmFtZSA9PT0gJ0ZTX2NyZWF0ZUxhenlGaWxlJyB8fFxuICAgICAgICAgbmFtZSA9PT0gJ0ZTX2NyZWF0ZURldmljZScgfHxcbiAgICAgICAgIG5hbWUgPT09ICdyZW1vdmVSdW5EZXBlbmRlbmN5Jztcbn1cblxuZnVuY3Rpb24gbWlzc2luZ0dsb2JhbChzeW0sIG1zZykge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm5PbmNlKGBcXGAke3N5bX1cXGAgaXMgbm90IGxvbmdlciBkZWZpbmVkIGJ5IGVtc2NyaXB0ZW4uICR7bXNnfWApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1pc3NpbmdHbG9iYWwoJ2J1ZmZlcicsICdQbGVhc2UgdXNlIEhFQVA4LmJ1ZmZlciBvciB3YXNtTWVtb3J5LmJ1ZmZlcicpO1xubWlzc2luZ0dsb2JhbCgnYXNtJywgJ1BsZWFzZSB1c2Ugd2FzbUV4cG9ydHMgaW5zdGVhZCcpO1xuXG5mdW5jdGlvbiBtaXNzaW5nTGlicmFyeVN5bWJvbChzeW0pIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9ICd1bmRlZmluZWQnICYmICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbFRoaXMsIHN5bSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIC8vIENhbid0IGBhYm9ydCgpYCBoZXJlIGJlY2F1c2UgaXQgd291bGQgYnJlYWsgY29kZSB0aGF0IGRvZXMgcnVudGltZVxuICAgICAgICAvLyBjaGVja3MuICBlLmcuIGBpZiAodHlwZW9mIFNETCA9PT0gJ3VuZGVmaW5lZCcpYC5cbiAgICAgICAgdmFyIG1zZyA9IGBcXGAke3N5bX1cXGAgaXMgYSBsaWJyYXJ5IHN5bWJvbCBhbmQgbm90IGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGFkZCBpdCB0byB5b3VyIGxpYnJhcnkuanMgX19kZXBzIG9yIHRvIERFRkFVTFRfTElCUkFSWV9GVU5DU19UT19JTkNMVURFIG9uIHRoZSBjb21tYW5kIGxpbmVgO1xuICAgICAgICAvLyBERUZBVUxUX0xJQlJBUllfRlVOQ1NfVE9fSU5DTFVERSByZXF1aXJlcyB0aGUgbmFtZSBhcyBpdCBhcHBlYXJzIGluXG4gICAgICAgIC8vIGxpYnJhcnkuanMsIHdoaWNoIG1lYW5zICRuYW1lIGZvciBhIEpTIG5hbWUgd2l0aCBubyBwcmVmaXgsIG9yIG5hbWVcbiAgICAgICAgLy8gZm9yIGEgSlMgbmFtZSBsaWtlIF9uYW1lLlxuICAgICAgICB2YXIgbGlicmFyeVN5bWJvbCA9IHN5bTtcbiAgICAgICAgaWYgKCFsaWJyYXJ5U3ltYm9sLnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgIGxpYnJhcnlTeW1ib2wgPSAnJCcgKyBzeW07XG4gICAgICAgIH1cbiAgICAgICAgbXNnICs9IGAgKGUuZy4gLXNERUZBVUxUX0xJQlJBUllfRlVOQ1NfVE9fSU5DTFVERT0nJHtsaWJyYXJ5U3ltYm9sfScpYDtcbiAgICAgICAgaWYgKGlzRXhwb3J0ZWRCeUZvcmNlRmlsZXN5c3RlbShzeW0pKSB7XG4gICAgICAgICAgbXNnICs9ICcuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91JztcbiAgICAgICAgfVxuICAgICAgICB3YXJuT25jZShtc2cpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIEFueSBzeW1ib2wgdGhhdCBpcyBub3QgaW5jbHVkZWQgZnJvbSB0aGUgSlMgbGlicmFyeSBpcyBhbHNvIChieSBkZWZpbml0aW9uKVxuICAvLyBub3QgZXhwb3J0ZWQgb24gdGhlIE1vZHVsZSBvYmplY3QuXG4gIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSk7XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSkge1xuICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBzeW0pKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgc3ltLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHZhciBtc2cgPSBgJyR7c3ltfScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBFbXNjcmlwdGVuIEZBUSlgO1xuICAgICAgICBpZiAoaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKHN5bSkpIHtcbiAgICAgICAgICBtc2cgKz0gJy4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zRk9SQ0VfRklMRVNZU1RFTSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3UnO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0KG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gVXNlZCBieSBYWFhYWF9ERUJVRyBzZXR0aW5ncyB0byBvdXRwdXQgZGVidWcgbWVzc2FnZXMuXG5mdW5jdGlvbiBkYmcoLi4uYXJncykge1xuICAvLyBUT0RPKHNiYyk6IE1ha2UgdGhpcyBjb25maWd1cmFibGUgc29tZWhvdy4gIEl0cyBub3QgYWx3YXlzIGNvbnZlbmllbnQgZm9yXG4gIC8vIGxvZ2dpbmcgdG8gc2hvdyB1cCBhcyB3YXJuaW5ncy5cbiAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xufVxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZGVidWcuanNcbi8vID09PSBCb2R5ID09PVxuXG5mdW5jdGlvbiBxdHNfaG9zdF9jYWxsX2Z1bmN0aW9uKGN0eCx0aGlzX3B0cixhcmdjLGFyZ3YsbWFnaWNfZnVuY19pZCkgeyBjb25zdCBhc3luY2lmeSA9IHVuZGVmaW5lZDsgcmV0dXJuIE1vZHVsZVsnY2FsbGJhY2tzJ11bJ2NhbGxGdW5jdGlvbiddKGFzeW5jaWZ5LCBjdHgsIHRoaXNfcHRyLCBhcmdjLCBhcmd2LCBtYWdpY19mdW5jX2lkKTsgfVxuZnVuY3Rpb24gcXRzX2hvc3RfaW50ZXJydXB0X2hhbmRsZXIocnQpIHsgY29uc3QgYXN5bmNpZnkgPSB1bmRlZmluZWQ7IHJldHVybiBNb2R1bGVbJ2NhbGxiYWNrcyddWydzaG91bGRJbnRlcnJ1cHQnXShhc3luY2lmeSwgcnQpOyB9XG5mdW5jdGlvbiBxdHNfaG9zdF9sb2FkX21vZHVsZV9zb3VyY2UocnQsY3R4LG1vZHVsZV9uYW1lKSB7IGNvbnN0IGFzeW5jaWZ5ID0gdW5kZWZpbmVkOyBjb25zdCBtb2R1bGVOYW1lU3RyaW5nID0gVVRGOFRvU3RyaW5nKG1vZHVsZV9uYW1lKTsgcmV0dXJuIE1vZHVsZVsnY2FsbGJhY2tzJ11bJ2xvYWRNb2R1bGVTb3VyY2UnXShhc3luY2lmeSwgcnQsIGN0eCwgbW9kdWxlTmFtZVN0cmluZyk7IH1cbmZ1bmN0aW9uIHF0c19ob3N0X25vcm1hbGl6ZV9tb2R1bGUocnQsY3R4LG1vZHVsZV9iYXNlX25hbWUsbW9kdWxlX25hbWUpIHsgY29uc3QgYXN5bmNpZnkgPSB1bmRlZmluZWQ7IGNvbnN0IG1vZHVsZUJhc2VOYW1lU3RyaW5nID0gVVRGOFRvU3RyaW5nKG1vZHVsZV9iYXNlX25hbWUpOyBjb25zdCBtb2R1bGVOYW1lU3RyaW5nID0gVVRGOFRvU3RyaW5nKG1vZHVsZV9uYW1lKTsgcmV0dXJuIE1vZHVsZVsnY2FsbGJhY2tzJ11bJ25vcm1hbGl6ZU1vZHVsZSddKGFzeW5jaWZ5LCBydCwgY3R4LCBtb2R1bGVCYXNlTmFtZVN0cmluZywgbW9kdWxlTmFtZVN0cmluZyk7IH1cblxuLy8gZW5kIGluY2x1ZGU6IHByZWFtYmxlLmpzXG5cblxuICAvKiogQGNvbnN0cnVjdG9yICovXG4gIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICB0aGlzLm5hbWUgPSAnRXhpdFN0YXR1cyc7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBgUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3N0YXR1c30pYDtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cblxuICB2YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbiAgXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludGVyICdpZHgnIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGdpdmVuXG4gICAgICogYXJyYXkgdGhhdCBjb250YWlucyB1aW50OCB2YWx1ZXMsIHJldHVybnMgYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGFcbiAgICAgKiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4gICAgICogaGVhcE9yQXJyYXkgaXMgZWl0aGVyIGEgcmVndWxhciBhcnJheSwgb3IgYSBKYXZhU2NyaXB0IHR5cGVkIGFycmF5IHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4Qnl0ZXNUb1JlYWRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gIHZhciBVVEY4QXJyYXlUb1N0cmluZyA9IChoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkgPT4ge1xuICAgICAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICAgICAgdmFyIGVuZFB0ciA9IGlkeDtcbiAgICAgIC8vIFRleHREZWNvZGVyIG5lZWRzIHRvIGtub3cgdGhlIGJ5dGUgbGVuZ3RoIGluIGFkdmFuY2UsIGl0IGRvZXNuJ3Qgc3RvcCBvblxuICAgICAgLy8gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi4gIEFsc28sIHVzZSB0aGUgbGVuZ3RoIGluZm8gdG8gYXZvaWQgcnVubmluZyB0aW55XG4gICAgICAvLyBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxuICAgICAgLy8gKEFzIGEgdGlueSBjb2RlIHNhdmUgdHJpY2ssIGNvbXBhcmUgZW5kUHRyIGFnYWluc3QgZW5kSWR4IHVzaW5nIGEgbmVnYXRpb24sXG4gICAgICAvLyBzbyB0aGF0IHVuZGVmaW5lZCBtZWFucyBJbmZpbml0eSlcbiAgICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuICBcbiAgICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgLy8gSWYgYnVpbGRpbmcgd2l0aCBUZXh0RGVjb2Rlciwgd2UgaGF2ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSBzdHJpbmcgbGVuZ3RoXG4gICAgICAvLyBhYm92ZSwgc28gdGVzdCBsb29wIGVuZCBjb25kaXRpb24gYWdhaW5zdCB0aGF0XG4gICAgICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICAgICAgIC8vIEZvciBVVEY4IGJ5dGUgc3RydWN0dXJlLCBzZWU6XG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjI5XG4gICAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgICAgaWYgKCEodTAgJiAweDgwKSkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgICAgaWYgKCh1MCAmIDB4RjApID09IDB4RTApIHtcbiAgICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCh1MCAmIDB4RjgpICE9IDB4RjApIHdhcm5PbmNlKCdJbnZhbGlkIFVURi04IGxlYWRpbmcgYnl0ZSAnICsgcHRyVG9TdHJpbmcodTApICsgJyBlbmNvdW50ZXJlZCB3aGVuIGRlc2VyaWFsaXppbmcgYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkgdG8gYSBKUyBzdHJpbmchJyk7XG4gICAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IChoZWFwT3JBcnJheVtpZHgrK10gJiA2Myk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICB2YXIgY2FsbFJ1bnRpbWVDYWxsYmFja3MgPSAoY2FsbGJhY2tzKSA9PiB7XG4gICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gUGFzcyB0aGUgbW9kdWxlIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShwdHIsIHR5cGUgPSAnaTgnKSB7XG4gICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2kxJzogcmV0dXJuIEhFQVA4W3B0cl07XG4gICAgICBjYXNlICdpOCc6IHJldHVybiBIRUFQOFtwdHJdO1xuICAgICAgY2FzZSAnaTE2JzogcmV0dXJuIEhFQVAxNlsoKHB0cik+PjEpXTtcbiAgICAgIGNhc2UgJ2kzMic6IHJldHVybiBIRUFQMzJbKChwdHIpPj4yKV07XG4gICAgICBjYXNlICdpNjQnOiBhYm9ydCgndG8gZG8gZ2V0VmFsdWUoaTY0KSB1c2UgV0FTTV9CSUdJTlQnKTtcbiAgICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIEhFQVBGMzJbKChwdHIpPj4yKV07XG4gICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gSEVBUEY2NFsoKHB0cik+PjMpXTtcbiAgICAgIGNhc2UgJyonOiByZXR1cm4gSEVBUFUzMlsoKHB0cik+PjIpXTtcbiAgICAgIGRlZmF1bHQ6IGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCBmYWxzZTtcblxuICB2YXIgcHRyVG9TdHJpbmcgPSAocHRyKSA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIHB0ciA9PT0gJ251bWJlcicpO1xuICAgICAgLy8gV2l0aCBDQU5fQUREUkVTU18yR0Igb3IgTUVNT1JZNjQsIHBvaW50ZXJzIGFyZSBhbHJlYWR5IHVuc2lnbmVkLlxuICAgICAgcHRyID4+Pj0gMDtcbiAgICAgIHJldHVybiAnMHgnICsgcHRyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCAnMCcpO1xuICAgIH07XG5cbiAgXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHB0clxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICovXG4gIGZ1bmN0aW9uIHNldFZhbHVlKHB0ciwgdmFsdWUsIHR5cGUgPSAnaTgnKSB7XG4gICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2kxJzogSEVBUDhbcHRyXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2k4JzogSEVBUDhbcHRyXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2kxNic6IEhFQVAxNlsoKHB0cik+PjEpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2kzMic6IEhFQVAzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2k2NCc6IGFib3J0KCd0byBkbyBzZXRWYWx1ZShpNjQpIHVzZSBXQVNNX0JJR0lOVCcpO1xuICAgICAgY2FzZSAnZmxvYXQnOiBIRUFQRjMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAnZG91YmxlJzogSEVBUEY2NFsoKHB0cik+PjMpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJyonOiBIRUFQVTMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYWJvcnQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhY2tSZXN0b3JlID0gKHZhbCkgPT4gX19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUodmFsKTtcblxuICB2YXIgc3RhY2tTYXZlID0gKCkgPT4gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQoKTtcblxuICB2YXIgd2Fybk9uY2UgPSAodGV4dCkgPT4ge1xuICAgICAgd2Fybk9uY2Uuc2hvd24gfHw9IHt9O1xuICAgICAgaWYgKCF3YXJuT25jZS5zaG93blt0ZXh0XSkge1xuICAgICAgICB3YXJuT25jZS5zaG93blt0ZXh0XSA9IDE7XG4gICAgICAgIGVycih0ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIFxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZVxuICAgICAqIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJucyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHRyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtYXhCeXRlc1RvUmVhZCAtIEFuIG9wdGlvbmFsIGxlbmd0aCB0aGF0IHNwZWNpZmllcyB0aGVcbiAgICAgKiAgIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIFlvdSBjYW4gb21pdCB0aGlzIHBhcmFtZXRlciB0byBzY2FuIHRoZVxuICAgICAqICAgc3RyaW5nIHVudGlsIHRoZSBmaXJzdCAwIGJ5dGUuIElmIG1heEJ5dGVzVG9SZWFkIGlzIHBhc3NlZCwgYW5kIHRoZSBzdHJpbmdcbiAgICAgKiAgIGF0IFtwdHIsIHB0cittYXhCeXRlc1RvUmVhZHJbIGNvbnRhaW5zIGEgbnVsbCBieXRlIGluIHRoZSBtaWRkbGUsIHRoZW4gdGhlXG4gICAgICogICBzdHJpbmcgd2lsbCBjdXQgc2hvcnQgYXQgdGhhdCBieXRlIGluZGV4IChpLmUuIG1heEJ5dGVzVG9SZWFkIHdpbGwgbm90XG4gICAgICogICBwcm9kdWNlIGEgc3RyaW5nIG9mIGV4YWN0IGxlbmd0aCBbcHRyLCBwdHIrbWF4Qnl0ZXNUb1JlYWRbKSBOLkIuIG1peGluZ1xuICAgICAqICAgZnJlcXVlbnQgdXNlcyBvZiBVVEY4VG9TdHJpbmcoKSB3aXRoIGFuZCB3aXRob3V0IG1heEJ5dGVzVG9SZWFkIG1heSB0aHJvd1xuICAgICAqICAgSlMgSklUIG9wdGltaXphdGlvbnMgb2ZmLCBzbyBpdCBpcyB3b3J0aCB0byBjb25zaWRlciBjb25zaXN0ZW50bHkgdXNpbmcgb25lXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICB2YXIgVVRGOFRvU3RyaW5nID0gKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpID0+IHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcHRyID09ICdudW1iZXInLCBgVVRGOFRvU3RyaW5nIGV4cGVjdHMgYSBudW1iZXIgKGdvdCAke3R5cGVvZiBwdHJ9KWApO1xuICAgICAgcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiAnJztcbiAgICB9O1xuICB2YXIgX19fYXNzZXJ0X2ZhaWwgPSAoY29uZGl0aW9uLCBmaWxlbmFtZSwgbGluZSwgZnVuYykgPT4ge1xuICAgICAgYWJvcnQoYEFzc2VydGlvbiBmYWlsZWQ6ICR7VVRGOFRvU3RyaW5nKGNvbmRpdGlvbil9LCBhdDogYCArIFtmaWxlbmFtZSA/IFVURjhUb1N0cmluZyhmaWxlbmFtZSkgOiAndW5rbm93biBmaWxlbmFtZScsIGxpbmUsIGZ1bmMgPyBVVEY4VG9TdHJpbmcoZnVuYykgOiAndW5rbm93biBmdW5jdGlvbiddKTtcbiAgICB9O1xuXG4gIHZhciBQQVRIID0ge1xuICBpc0FiczoocGF0aCkgPT4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyxcbiAgc3BsaXRQYXRoOihmaWxlbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICAgICAgfSxcbiAgbm9ybWFsaXplQXJyYXk6KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgICAgICB2YXIgdXAgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBmb3IgKDsgdXA7IHVwLS0pIHtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH0sXG4gIG5vcm1hbGl6ZToocGF0aCkgPT4ge1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCksXG4gICAgICAgICAgICB0cmFpbGluZ1NsYXNoID0gcGF0aC5zdWJzdHIoLTEpID09PSAnLyc7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuICAgICAgICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICBwYXRoID0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xuICAgICAgfSxcbiAgZGlybmFtZToocGF0aCkgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgICAgICAgZGlyID0gcmVzdWx0WzFdO1xuICAgICAgICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgICAgICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgKyBkaXI7XG4gICAgICB9LFxuICBiYXNlbmFtZToocGF0aCkgPT4ge1xuICAgICAgICAvLyBFTVNDUklQVEVOIHJldHVybiAnLycnIGZvciAnLycsIG5vdCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKGxhc3RTbGFzaCsxKTtcbiAgICAgIH0sXG4gIGpvaW46KC4uLnBhdGhzKSA9PiBQQVRILm5vcm1hbGl6ZShwYXRocy5qb2luKCcvJykpLFxuICBqb2luMjoobCwgcikgPT4gUEFUSC5ub3JtYWxpemUobCArICcvJyArIHIpLFxuICB9O1xuICBcbiAgdmFyIGluaXRSYW5kb21GaWxsID0gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBmb3IgbW9kZXJuIHdlYiBicm93c2Vyc1xuICAgICAgICByZXR1cm4gKHZpZXcpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldyk7XG4gICAgICB9IGVsc2VcbiAgICAgIC8vIHdlIGNvdWxkbid0IGZpbmQgYSBwcm9wZXIgaW1wbGVtZW50YXRpb24sIGFzIE1hdGgucmFuZG9tKCkgaXMgbm90IHN1aXRhYmxlIGZvciAvZGV2L3JhbmRvbSwgc2VlIGVtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3B1bGwvNzA5NlxuICAgICAgYWJvcnQoJ25vIGNyeXB0b2dyYXBoaWMgc3VwcG9ydCBmb3VuZCBmb3IgcmFuZG9tRGV2aWNlLiBjb25zaWRlciBwb2x5ZmlsbGluZyBpdCBpZiB5b3Ugd2FudCB0byB1c2Ugc29tZXRoaW5nIGluc2VjdXJlIGxpa2UgTWF0aC5yYW5kb20oKSwgZS5nLiBwdXQgdGhpcyBpbiBhIC0tcHJlLWpzOiB2YXIgY3J5cHRvID0geyBnZXRSYW5kb21WYWx1ZXM6IChhcnJheSkgPT4geyBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBhcnJheVtpXSA9IChNYXRoLnJhbmRvbSgpKjI1Nil8MCB9IH07Jyk7XG4gICAgfTtcbiAgdmFyIHJhbmRvbUZpbGwgPSAodmlldykgPT4ge1xuICAgICAgLy8gTGF6aWx5IGluaXQgb24gdGhlIGZpcnN0IGludm9jYXRpb24uXG4gICAgICByZXR1cm4gKHJhbmRvbUZpbGwgPSBpbml0UmFuZG9tRmlsbCgpKSh2aWV3KTtcbiAgICB9O1xuICBcbiAgXG4gIFxuICB2YXIgUEFUSF9GUyA9IHtcbiAgcmVzb2x2ZTooLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJnc1tpXSA6IEZTLmN3ZCgpO1xuICAgICAgICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIGFuIGludmFsaWQgcG9ydGlvbiBpbnZhbGlkYXRlcyB0aGUgd2hvbGUgdGhpbmdcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xuICAgICAgfSxcbiAgcmVsYXRpdmU6KGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGZyb20gPSBQQVRIX0ZTLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICAgICAgICB0byA9IFBBVEhfRlMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuICAgICAgICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG4gICAgICB9LFxuICB9O1xuICBcbiAgXG4gIFxuICB2YXIgRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIgPSBbXTtcbiAgXG4gIHZhciBsZW5ndGhCeXRlc1VURjggPSAoc3RyKSA9PiB7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGVcbiAgICAgICAgLy8gdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZVxuICAgICAgICAvLyBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcbiAgICAgICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPD0gMHg3RkYpIHtcbiAgICAgICAgICBsZW4gKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikge1xuICAgICAgICAgIGxlbiArPSA0OyArK2k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuICs9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfTtcbiAgXG4gIHZhciBzdHJpbmdUb1VURjhBcnJheSA9IChzdHIsIGhlYXAsIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycsIGBzdHJpbmdUb1VURjhBcnJheSBleHBlY3RzIGEgc3RyaW5nIChnb3QgJHt0eXBlb2Ygc3RyfSlgKTtcbiAgICAgIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsXG4gICAgICAvLyB1bmRlZmluZWQgYW5kIGZhbHNlIGVhY2ggZG9uJ3Qgd3JpdGUgb3V0IGFueSBieXRlcy5cbiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKVxuICAgICAgICByZXR1cm4gMDtcbiAgXG4gICAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gICAgICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsgLy8gLTEgZm9yIHN0cmluZyBudWxsIHRlcm1pbmF0b3IuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlXG4gICAgICAgIC8vIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGVcbiAgICAgICAgLy8gVVRGMTYtPlVURjMyLT5VVEY4LlxuICAgICAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xuICAgICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dFxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgICAgICBpZiAodSA+PSAweEQ4MDAgJiYgdSA8PSAweERGRkYpIHtcbiAgICAgICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8ICh1MSAmIDB4M0ZGKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gdTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4QzAgfCAodSA+PiA2KTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEUwIHwgKHUgPj4gMTIpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGlmICh1ID4gMHgxMEZGRkYpIHdhcm5PbmNlKCdJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCAnICsgcHRyVG9TdHJpbmcodSkgKyAnIGVuY291bnRlcmVkIHdoZW4gc2VyaWFsaXppbmcgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkhIChWYWxpZCB1bmljb2RlIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbiByYW5nZSAwLTB4MTBGRkZGKS4nKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4RjAgfCAodSA+PiAxOCk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBidWZmZXIuXG4gICAgICBoZWFwW291dElkeF0gPSAwO1xuICAgICAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xuICAgIH07XG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nLCBib29sZWFuPSwgbnVtYmVyPSl9ICovXG4gIGZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gICAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTtcbiAgICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XG4gICAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcbiAgICByZXR1cm4gdThhcnJheTtcbiAgfVxuICB2YXIgRlNfc3RkaW5fZ2V0Q2hhciA9ICgpID0+IHtcbiAgICAgIGlmICghRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBCcm93c2VyLlxuICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoJ0lucHV0OiAnKTsgIC8vIHJldHVybnMgbnVsbCBvbiBjYW5jZWxcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAge31cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlciA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZTX3N0ZGluX2dldENoYXJfYnVmZmVyLnNoaWZ0KCk7XG4gICAgfTtcbiAgdmFyIFRUWSA9IHtcbiAgdHR5czpbXSxcbiAgaW5pdCgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3B1bGwvMTU1NVxuICAgICAgICAvLyBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgICAvLyAgIC8vIGN1cnJlbnRseSwgRlMuaW5pdCBkb2VzIG5vdCBkaXN0aW5ndWlzaCBpZiBwcm9jZXNzLnN0ZGluIGlzIGEgZmlsZSBvciBUVFlcbiAgICAgICAgLy8gICAvLyBkZXZpY2UsIGl0IGFsd2F5cyBhc3N1bWVzIGl0J3MgYSBUVFkgZGV2aWNlLiBiZWNhdXNlIG9mIHRoaXMsIHdlJ3JlIGZvcmNpbmdcbiAgICAgICAgLy8gICAvLyBwcm9jZXNzLnN0ZGluIHRvIFVURjggZW5jb2RpbmcgdG8gYXQgbGVhc3QgbWFrZSBzdGRpbiByZWFkaW5nIGNvbXBhdGlibGVcbiAgICAgICAgLy8gICAvLyB3aXRoIHRleHQgZmlsZXMgdW50aWwgRlMuaW5pdCBjYW4gYmUgcmVmYWN0b3JlZC5cbiAgICAgICAgLy8gICBwcm9jZXNzLnN0ZGluLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0sXG4gIHNodXRkb3duKCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vcHVsbC8xNTU1XG4gICAgICAgIC8vIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgIC8vICAgLy8gaW5vbGVuOiBhbnkgaWRlYSBhcyB0byB3aHkgbm9kZSAtZSAncHJvY2Vzcy5zdGRpbi5yZWFkKCknIHdvdWxkbid0IGV4aXQgaW1tZWRpYXRlbHkgKHdpdGggcHJvY2Vzcy5zdGRpbiBiZWluZyBhIHR0eSk/XG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBiZWNhdXNlIG5vdyBpdCdzIHJlYWRpbmcgZnJvbSB0aGUgc3RyZWFtLCB5b3UndmUgZXhwcmVzc2VkIGludGVyZXN0IGluIGl0LCBzbyB0aGF0IHJlYWQoKSBraWNrcyBvZmYgYSBfcmVhZCgpIHdoaWNoIGNyZWF0ZXMgYSBSZWFkUmVxIG9wZXJhdGlvblxuICAgICAgICAvLyAgIC8vIGlub2xlbjogSSB0aG91Z2h0IHJlYWQoKSBpbiB0aGF0IGNhc2Ugd2FzIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uIHRoYXQganVzdCBncmFiYmVkIHNvbWUgYW1vdW50IG9mIGJ1ZmZlcmVkIGRhdGEgaWYgaXQgZXhpc3RzP1xuICAgICAgICAvLyAgIC8vIGlzYWFjczogaXQgaXMuIGJ1dCBpdCBhbHNvIHRyaWdnZXJzIGEgX3JlYWQoKSBjYWxsLCB3aGljaCBjYWxscyByZWFkU3RhcnQoKSBvbiB0aGUgaGFuZGxlXG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBkbyBwcm9jZXNzLnN0ZGluLnBhdXNlKCkgYW5kIGknZCB0aGluayBpdCdkIHByb2JhYmx5IGNsb3NlIHRoZSBwZW5kaW5nIGNhbGxcbiAgICAgICAgLy8gICBwcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0sXG4gIHJlZ2lzdGVyKGRldiwgb3BzKSB7XG4gICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTtcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCBUVFkuc3RyZWFtX29wcyk7XG4gICAgICB9LFxuICBzdHJlYW1fb3BzOntcbiAgb3BlbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgdHR5ID0gVFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07XG4gICAgICAgICAgaWYgKCF0dHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLnR0eSA9IHR0eTtcbiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgY2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgICAgLy8gZmx1c2ggYW55IHBlbmRpbmcgbGluZSBkYXRhXG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gIGZzeW5jKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpO1xuICAgICAgICB9LFxuICByZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICB9LFxuICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSwgYnVmZmVyW29mZnNldCtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSxcbiAgfSxcbiAgZGVmYXVsdF90dHlfb3BzOntcbiAgZ2V0X2NoYXIodHR5KSB7XG4gICAgICAgICAgcmV0dXJuIEZTX3N0ZGluX2dldENoYXIoKTtcbiAgICAgICAgfSxcbiAgcHV0X2NoYXIodHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7IC8vIHZhbCA9PSAwIHdvdWxkIGN1dCB0ZXh0IG91dHB1dCBvZmYgaW4gdGhlIG1pZGRsZS5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIGZzeW5jKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIGlvY3RsX3RjZ2V0cyh0dHkpIHtcbiAgICAgICAgICAvLyB0eXBpY2FsIHNldHRpbmdcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY19pZmxhZzogMjU4NTYsXG4gICAgICAgICAgICBjX29mbGFnOiA1LFxuICAgICAgICAgICAgY19jZmxhZzogMTkxLFxuICAgICAgICAgICAgY19sZmxhZzogMzUzODcsXG4gICAgICAgICAgICBjX2NjOiBbXG4gICAgICAgICAgICAgIDB4MDMsIDB4MWMsIDB4N2YsIDB4MTUsIDB4MDQsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MTEsIDB4MTMsIDB4MWEsIDB4MDAsXG4gICAgICAgICAgICAgIDB4MTIsIDB4MGYsIDB4MTcsIDB4MTYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgaW9jdGxfdGNzZXRzKHR0eSwgb3B0aW9uYWxfYWN0aW9ucywgZGF0YSkge1xuICAgICAgICAgIC8vIGN1cnJlbnRseSBqdXN0IGlnbm9yZVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICBpb2N0bF90aW9jZ3dpbnN6KHR0eSkge1xuICAgICAgICAgIHJldHVybiBbMjQsIDgwXTtcbiAgICAgICAgfSxcbiAgfSxcbiAgZGVmYXVsdF90dHkxX29wczp7XG4gIHB1dF9jaGFyKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgZnN5bmModHR5KSB7XG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgfSxcbiAgfTtcbiAgXG4gIFxuICB2YXIgemVyb01lbW9yeSA9IChhZGRyZXNzLCBzaXplKSA9PiB7XG4gICAgICBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9O1xuICBcbiAgdmFyIGFsaWduTWVtb3J5ID0gKHNpemUsIGFsaWdubWVudCkgPT4ge1xuICAgICAgYXNzZXJ0KGFsaWdubWVudCwgXCJhbGlnbm1lbnQgYXJndW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50O1xuICAgIH07XG4gIHZhciBtbWFwQWxsb2MgPSAoc2l6ZSkgPT4ge1xuICAgICAgc2l6ZSA9IGFsaWduTWVtb3J5KHNpemUsIDY1NTM2KTtcbiAgICAgIHZhciBwdHIgPSBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduKDY1NTM2LCBzaXplKTtcbiAgICAgIGlmICghcHRyKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB6ZXJvTWVtb3J5KHB0ciwgc2l6ZSk7XG4gICAgfTtcbiAgdmFyIE1FTUZTID0ge1xuICBvcHNfdGFibGU6bnVsbCxcbiAgbW91bnQobW91bnQpIHtcbiAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAvKiAwNzc3ICovLCAwKTtcbiAgICAgIH0sXG4gIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIC8vIG5vIHN1cHBvcnRlZFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBNRU1GUy5vcHNfdGFibGUgfHw9IHtcbiAgICAgICAgICBkaXI6IHtcbiAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsXG4gICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgcmVuYW1lOiBNRU1GUy5ub2RlX29wcy5yZW5hbWUsXG4gICAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLFxuICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgIHJlYWRkaXI6IE1FTUZTLm5vZGVfb3BzLnJlYWRkaXIsXG4gICAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2Vla1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWssXG4gICAgICAgICAgICAgIHJlYWQ6IE1FTUZTLnN0cmVhbV9vcHMucmVhZCxcbiAgICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsXG4gICAgICAgICAgICAgIGFsbG9jYXRlOiBNRU1GUy5zdHJlYW1fb3BzLmFsbG9jYXRlLFxuICAgICAgICAgICAgICBtbWFwOiBNRU1GUy5zdHJlYW1fb3BzLm1tYXAsXG4gICAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW5rOiB7XG4gICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgIHJlYWRsaW5rOiBNRU1GUy5ub2RlX29wcy5yZWFkbGlua1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmVhbToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNocmRldjoge1xuICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiBGUy5jaHJkZXZfc3RyZWFtX29wc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7IC8vIFRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgaW4gdGhlIHR5cGVkIGFycmF5LCBhcyBvcHBvc2VkIHRvIGNvbnRlbnRzLmxlbmd0aCB3aGljaCBnaXZlcyB0aGUgd2hvbGUgY2FwYWNpdHkuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgYnl0ZSBkYXRhIG9mIHRoZSBmaWxlIGlzIHBvcHVsYXRlZCwgdGhpcyB3aWxsIHBvaW50IHRvIGVpdGhlciBhIHR5cGVkIGFycmF5LCBvciBhIG5vcm1hbCBKUyBhcnJheS4gVHlwZWQgYXJyYXlzIGFyZSBwcmVmZXJyZWRcbiAgICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UsIGFuZCB1c2VkIGJ5IGRlZmF1bHQuIEhvd2V2ZXIsIHR5cGVkIGFycmF5cyBhcmUgbm90IHJlc2l6YWJsZSBsaWtlIG5vcm1hbCBKUyBhcnJheXMgYXJlLCBzbyB0aGVyZSBpcyBhIHNtYWxsIGRpc2sgc2l6ZVxuICAgICAgICAgIC8vIHBlbmFsdHkgaW52b2x2ZWQgZm9yIGFwcGVuZGluZyBmaWxlIHdyaXRlcyB0aGF0IGNvbnRpbnVvdXNseSBncm93IGEgZmlsZSBzaW1pbGFyIHRvIHN0ZDo6dmVjdG9yIGNhcGFjaXR5IHZzIHVzZWQgLXNjaGVtZS5cbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsgXG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5zdHJlYW07XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5zdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyBhZGQgdGhlIG5ldyBub2RlIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IG5vZGUudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKTsgLy8gTWFrZSBzdXJlIHRvIG5vdCByZXR1cm4gZXhjZXNzIHVudXNlZCBieXRlcy5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xuICAgICAgfSxcbiAgZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgbmV3Q2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIHByZXZDYXBhY2l0eSA9IG5vZGUuY29udGVudHMgPyBub2RlLmNvbnRlbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgPj0gbmV3Q2FwYWNpdHkpIHJldHVybjsgLy8gTm8gbmVlZCB0byBleHBhbmQsIHRoZSBzdG9yYWdlIHdhcyBhbHJlYWR5IGxhcmdlIGVub3VnaC5cbiAgICAgICAgLy8gRG9uJ3QgZXhwYW5kIHN0cmljdGx5IHRvIHRoZSBnaXZlbiByZXF1ZXN0ZWQgbGltaXQgaWYgaXQncyBvbmx5IGEgdmVyeSBzbWFsbCBpbmNyZWFzZSwgYnV0IGluc3RlYWQgZ2VvbWV0cmljYWxseSBncm93IGNhcGFjaXR5LlxuICAgICAgICAvLyBGb3Igc21hbGwgZmlsZXNpemVzICg8MU1CKSwgcGVyZm9ybSBzaXplKjIgZ2VvbWV0cmljIGluY3JlYXNlLCBidXQgZm9yIGxhcmdlIHNpemVzLCBkbyBhIG11Y2ggbW9yZSBjb25zZXJ2YXRpdmUgc2l6ZSoxLjEyNSBpbmNyZWFzZSB0b1xuICAgICAgICAvLyBhdm9pZCBvdmVyc2hvb3RpbmcgdGhlIGFsbG9jYXRpb24gY2FwIGJ5IGEgdmVyeSBsYXJnZSBtYXJnaW4uXG4gICAgICAgIHZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVggPSAxMDI0ICogMTAyNDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgKHByZXZDYXBhY2l0eSAqIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyLjAgOiAxLjEyNSkpID4+PiAwKTtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpOyAvLyBBdCBtaW5pbXVtIGFsbG9jYXRlIDI1NmIgZm9yIGVhY2ggZmlsZSB3aGVuIGV4cGFuZGluZy5cbiAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTsgLy8gQWxsb2NhdGUgbmV3IHN0b3JhZ2UuXG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA+IDApIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKSwgMCk7IC8vIENvcHkgb2xkIGRhdGEgb3ZlciB0byB0aGUgbmV3IHN0b3JhZ2UuXG4gICAgICB9LFxuICByZXNpemVGaWxlU3RvcmFnZShub2RlLCBuZXdTaXplKSB7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XG4gICAgICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsgLy8gRnVsbHkgZGVjb21taXQgd2hlbiByZXF1ZXN0aW5nIGEgcmVzaXplIHRvIHplcm8uXG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld1NpemUpOyAvLyBBbGxvY2F0ZSBuZXcgc3RvcmFnZS5cbiAgICAgICAgICBpZiAob2xkQ29udGVudHMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIE1hdGgubWluKG5ld1NpemUsIG5vZGUudXNlZEJ5dGVzKSkpOyAvLyBDb3B5IG9sZCBkYXRhIG92ZXIgdG8gdGhlIG5ldyBzdG9yYWdlLlxuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IG5ld1NpemU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIG5vZGVfb3BzOntcbiAgZ2V0YXR0cihub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgICAvLyBkZXZpY2UgbnVtYmVycyByZXVzZSBpbm9kZSBudW1iZXJzLlxuICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcbiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7XG4gICAgICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xuICAgICAgICAgIGF0dHIuZ2lkID0gMDtcbiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgLy8gTk9URTogSW4gb3VyIGltcGxlbWVudGF0aW9uLCBzdF9ibG9ja3MgPSBNYXRoLmNlaWwoc3Rfc2l6ZS9zdF9ibGtzaXplKSxcbiAgICAgICAgICAvLyAgICAgICBidXQgdGhpcyBpcyBub3QgcmVxdWlyZWQgYnkgdGhlIHN0YW5kYXJkLlxuICAgICAgICAgIGF0dHIuYmxrc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgYXR0ci5ibG9ja3MgPSBNYXRoLmNlaWwoYXR0ci5zaXplIC8gYXR0ci5ibGtzaXplKTtcbiAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfSxcbiAgc2V0YXR0cihub2RlLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKGF0dHIubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIGF0dHIuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBsb29rdXAocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1s0NF07XG4gICAgICAgIH0sXG4gIG1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7XG4gICAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgICB9LFxuICByZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XG4gICAgICAgICAgLy8gaWYgd2UncmUgb3ZlcndyaXRpbmcgYSBkaXJlY3RvcnkgYXQgbmV3X25hbWUsIG1ha2Ugc3VyZSBpdCdzIGVtcHR5LlxuICAgICAgICAgIGlmIChGUy5pc0RpcihvbGRfbm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdfbm9kZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5ld19ub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRvIHRoZSBpbnRlcm5hbCByZXdpcmluZ1xuICAgICAgICAgIGRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICAgICAgICBvbGRfbm9kZS5uYW1lID0gbmV3X25hbWU7XG4gICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTtcbiAgICAgICAgICBuZXdfZGlyLnRpbWVzdGFtcCA9IG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXA7XG4gICAgICAgIH0sXG4gIHVubGluayhwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB9LFxuICBybWRpcihwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgcmVhZGRpcihub2RlKSB7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbJy4nLCAnLi4nXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMobm9kZS5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgc3ltbGluayhwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgLyogMDc3NyAqLyB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICByZWFkbGluayhub2RlKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5saW5rO1xuICAgICAgICB9LFxuICB9LFxuICBzdHJlYW1fb3BzOntcbiAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMgLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBhc3NlcnQoc2l6ZSA+PSAwKTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDggJiYgY29udGVudHMuc3ViYXJyYXkpIHsgLy8gbm9uLXRyaXZpYWwsIGFuZCB0eXBlZCBhcnJheVxuICAgICAgICAgICAgYnVmZmVyLnNldChjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKSwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9LFxuICB3cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgICAgICAvLyBUaGUgZGF0YSBidWZmZXIgc2hvdWxkIGJlIGEgdHlwZWQgYXJyYXkgdmlld1xuICAgICAgICAgIGFzc2VydCghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSk7XG4gICAgICAgICAgLy8gSWYgdGhlIGJ1ZmZlciBpcyBsb2NhdGVkIGluIG1haW4gbWVtb3J5IChIRUFQKSwgYW5kIGlmXG4gICAgICAgICAgLy8gbWVtb3J5IGNhbiBncm93LCB3ZSBjYW4ndCBob2xkIG9uIHRvIHJlZmVyZW5jZXMgb2YgdGhlXG4gICAgICAgICAgLy8gbWVtb3J5IGJ1ZmZlciwgYXMgdGhleSBtYXkgZ2V0IGludmFsaWRhdGVkLiBUaGF0IG1lYW5zIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkbyBjb3B5IGl0cyBjb250ZW50cy5cbiAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlciA9PT0gSEVBUDguYnVmZmVyKSB7XG4gICAgICAgICAgICBjYW5Pd24gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbS5ub2RlO1xuICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHsgLy8gVGhpcyB3cml0ZSBpcyBmcm9tIGEgdHlwZWQgYXJyYXkgdG8gYSB0eXBlZCBhcnJheT9cbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KHBvc2l0aW9uID09PSAwLCAnY2FuT3duIG11c3QgaW1wbHkgbm8gd2VpcmQgcG9zaXRpb24gaW5zaWRlIHRoZSBmaWxlJyk7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS51c2VkQnl0ZXMgPT09IDAgJiYgcG9zaXRpb24gPT09IDApIHsgLy8gSWYgdGhpcyBpcyBhIHNpbXBsZSBmaXJzdCB3cml0ZSB0byBhbiBlbXB0eSBmaWxlLCBkbyBhIGZhc3Qgc2V0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gY2FyZSBhYm91dCBvbGQgZGF0YS5cbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiArIGxlbmd0aCA8PSBub2RlLnVzZWRCeXRlcykgeyAvLyBXcml0aW5nIHRvIGFuIGFscmVhZHkgYWxsb2NhdGVkIGFuZCB1c2VkIHN1YnJhbmdlIG9mIHRoZSBmaWxlP1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBBcHBlbmRpbmcgdG8gYW4gZXhpc3RpbmcgZmlsZSBhbmQgd2UgbmVlZCB0byByZWFsbG9jYXRlLCBvciBzb3VyY2UgZGF0YSBkaWQgbm90IGNvbWUgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbitsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgLy8gVXNlIHR5cGVkIGFycmF5IHdyaXRlIHdoaWNoIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsgLy8gT3IgZmFsbCBiYWNrIHRvIG1hbnVhbCB3cml0ZSBpZiBub3QuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LFxuICBsbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9mZnNldDtcbiAgICAgICAgICBpZiAod2hlbmNlID09PSAxKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmICh3aGVuY2UgPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcywgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgbW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHB0cjtcbiAgICAgICAgICB2YXIgYWxsb2NhdGVkO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIC8vIE9ubHkgbWFrZSBhIG5ldyBjb3B5IHdoZW4gTUFQX1BSSVZBVEUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgY29udGVudHMgJiYgY29udGVudHMuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGVtdWxhdGUgTUFQX1NIQVJFRCB3aGVuIHRoZSBmaWxlIGlzIG5vdCBiYWNrZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyBidWZmZXIgd2UncmUgbWFwcGluZyB0byAoZS5nLiB0aGUgSEVBUCBidWZmZXIpLlxuICAgICAgICAgICAgYWxsb2NhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBwdHIgPSBjb250ZW50cy5ieXRlT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMpIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIGF2b2lkIHVubmVjZXNzYXJ5IHNsaWNlcy5cbiAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCB8fCBwb3NpdGlvbiArIGxlbmd0aCA8IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0ciwgYWxsb2NhdGVkIH07XG4gICAgICAgIH0sXG4gIG1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICAvLyBzaG91bGQgd2UgY2hlY2sgaWYgYnl0ZXNXcml0dGVuIGFuZCBsZW5ndGggYXJlIHRoZSBzYW1lP1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICB9LFxuICB9O1xuICBcbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IG5vUnVuRGVwICovXG4gIHZhciBhc3luY0xvYWQgPSAodXJsLCBvbmxvYWQsIG9uZXJyb3IsIG5vUnVuRGVwKSA9PiB7XG4gICAgICB2YXIgZGVwID0gIW5vUnVuRGVwID8gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShgYWwgJHt1cmx9YCkgOiAnJztcbiAgICAgIHJlYWRBc3luYyh1cmwpLnRoZW4oXG4gICAgICAgIChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICAgIGFzc2VydChhcnJheUJ1ZmZlciwgYExvYWRpbmcgZGF0YSBmaWxlIFwiJHt1cmx9XCIgZmFpbGVkIChubyBhcnJheUJ1ZmZlcikuYCk7XG4gICAgICAgICAgb25sb2FkKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICAgICAgaWYgKGRlcCkgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgYExvYWRpbmcgZGF0YSBmaWxlIFwiJHt1cmx9XCIgZmFpbGVkLmA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGRlcCkgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgIH07XG4gIFxuICBcbiAgdmFyIEZTX2NyZWF0ZURhdGFGaWxlID0gKHBhcmVudCwgbmFtZSwgZmlsZURhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pID0+IHtcbiAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCwgbmFtZSwgZmlsZURhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgIH07XG4gIFxuICB2YXIgcHJlbG9hZFBsdWdpbnMgPSBNb2R1bGVbJ3ByZWxvYWRQbHVnaW5zJ10gfHwgW107XG4gIHZhciBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luID0gKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgb25lcnJvcikgPT4ge1xuICAgICAgLy8gRW5zdXJlIHBsdWdpbnMgYXJlIHJlYWR5LlxuICAgICAgaWYgKHR5cGVvZiBCcm93c2VyICE9ICd1bmRlZmluZWQnKSBCcm93c2VyLmluaXQoKTtcbiAgXG4gICAgICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgcHJlbG9hZFBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgIGlmIChoYW5kbGVkKSByZXR1cm47XG4gICAgICAgIGlmIChwbHVnaW5bJ2NhbkhhbmRsZSddKGZ1bGxuYW1lKSkge1xuICAgICAgICAgIHBsdWdpblsnaGFuZGxlJ10oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCBvbmVycm9yKTtcbiAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9O1xuICB2YXIgRlNfY3JlYXRlUHJlbG9hZGVkRmlsZSA9IChwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUsIG9ubG9hZCwgb25lcnJvciwgZG9udENyZWF0ZUZpbGUsIGNhbk93biwgcHJlRmluaXNoKSA9PiB7XG4gICAgICAvLyBUT0RPIHdlIHNob3VsZCBhbGxvdyBwZW9wbGUgdG8ganVzdCBwYXNzIGluIGEgY29tcGxldGUgZmlsZW5hbWUgaW5zdGVhZFxuICAgICAgLy8gb2YgcGFyZW50IGFuZCBuYW1lIGJlaW5nIHRoYXQgd2UganVzdCBqb2luIHRoZW0gYW55d2F5c1xuICAgICAgdmFyIGZ1bGxuYW1lID0gbmFtZSA/IFBBVEhfRlMucmVzb2x2ZShQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkpIDogcGFyZW50O1xuICAgICAgdmFyIGRlcCA9IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koYGNwICR7ZnVsbG5hbWV9YCk7IC8vIG1pZ2h0IGhhdmUgc2V2ZXJhbCBhY3RpdmUgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIGZ1bGxuYW1lXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHtcbiAgICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xuICAgICAgICAgIHByZUZpbmlzaD8uKCk7XG4gICAgICAgICAgaWYgKCFkb250Q3JlYXRlRmlsZSkge1xuICAgICAgICAgICAgRlNfY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBieXRlQXJyYXksIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbmxvYWQ/LigpO1xuICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlNfaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbihieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsICgpID0+IHtcbiAgICAgICAgICBvbmVycm9yPy4oKTtcbiAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXN5bmNMb2FkKHVybCwgcHJvY2Vzc0RhdGEsIG9uZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0RhdGEodXJsKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgdmFyIEZTX21vZGVTdHJpbmdUb0ZsYWdzID0gKHN0cikgPT4ge1xuICAgICAgdmFyIGZsYWdNb2RlcyA9IHtcbiAgICAgICAgJ3InOiAwLFxuICAgICAgICAncisnOiAyLFxuICAgICAgICAndyc6IDUxMiB8IDY0IHwgMSxcbiAgICAgICAgJ3crJzogNTEyIHwgNjQgfCAyLFxuICAgICAgICAnYSc6IDEwMjQgfCA2NCB8IDEsXG4gICAgICAgICdhKyc6IDEwMjQgfCA2NCB8IDIsXG4gICAgICB9O1xuICAgICAgdmFyIGZsYWdzID0gZmxhZ01vZGVzW3N0cl07XG4gICAgICBpZiAodHlwZW9mIGZsYWdzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJHtzdHJ9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfTtcbiAgXG4gIHZhciBGU19nZXRNb2RlID0gKGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICB2YXIgbW9kZSA9IDA7XG4gICAgICBpZiAoY2FuUmVhZCkgbW9kZSB8PSAyOTIgfCA3MztcbiAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9O1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICB2YXIgc3RyRXJyb3IgPSAoZXJybm8pID0+IHtcbiAgICAgIHJldHVybiBVVEY4VG9TdHJpbmcoX3N0cmVycm9yKGVycm5vKSk7XG4gICAgfTtcbiAgXG4gIHZhciBFUlJOT19DT0RFUyA9IHtcbiAgICAgICdFUEVSTSc6IDYzLFxuICAgICAgJ0VOT0VOVCc6IDQ0LFxuICAgICAgJ0VTUkNIJzogNzEsXG4gICAgICAnRUlOVFInOiAyNyxcbiAgICAgICdFSU8nOiAyOSxcbiAgICAgICdFTlhJTyc6IDYwLFxuICAgICAgJ0UyQklHJzogMSxcbiAgICAgICdFTk9FWEVDJzogNDUsXG4gICAgICAnRUJBREYnOiA4LFxuICAgICAgJ0VDSElMRCc6IDEyLFxuICAgICAgJ0VBR0FJTic6IDYsXG4gICAgICAnRVdPVUxEQkxPQ0snOiA2LFxuICAgICAgJ0VOT01FTSc6IDQ4LFxuICAgICAgJ0VBQ0NFUyc6IDIsXG4gICAgICAnRUZBVUxUJzogMjEsXG4gICAgICAnRU5PVEJMSyc6IDEwNSxcbiAgICAgICdFQlVTWSc6IDEwLFxuICAgICAgJ0VFWElTVCc6IDIwLFxuICAgICAgJ0VYREVWJzogNzUsXG4gICAgICAnRU5PREVWJzogNDMsXG4gICAgICAnRU5PVERJUic6IDU0LFxuICAgICAgJ0VJU0RJUic6IDMxLFxuICAgICAgJ0VJTlZBTCc6IDI4LFxuICAgICAgJ0VORklMRSc6IDQxLFxuICAgICAgJ0VNRklMRSc6IDMzLFxuICAgICAgJ0VOT1RUWSc6IDU5LFxuICAgICAgJ0VUWFRCU1knOiA3NCxcbiAgICAgICdFRkJJRyc6IDIyLFxuICAgICAgJ0VOT1NQQyc6IDUxLFxuICAgICAgJ0VTUElQRSc6IDcwLFxuICAgICAgJ0VST0ZTJzogNjksXG4gICAgICAnRU1MSU5LJzogMzQsXG4gICAgICAnRVBJUEUnOiA2NCxcbiAgICAgICdFRE9NJzogMTgsXG4gICAgICAnRVJBTkdFJzogNjgsXG4gICAgICAnRU5PTVNHJzogNDksXG4gICAgICAnRUlEUk0nOiAyNCxcbiAgICAgICdFQ0hSTkcnOiAxMDYsXG4gICAgICAnRUwyTlNZTkMnOiAxNTYsXG4gICAgICAnRUwzSExUJzogMTA3LFxuICAgICAgJ0VMM1JTVCc6IDEwOCxcbiAgICAgICdFTE5STkcnOiAxMDksXG4gICAgICAnRVVOQVRDSCc6IDExMCxcbiAgICAgICdFTk9DU0knOiAxMTEsXG4gICAgICAnRUwySExUJzogMTEyLFxuICAgICAgJ0VERUFETEsnOiAxNixcbiAgICAgICdFTk9MQ0snOiA0NixcbiAgICAgICdFQkFERSc6IDExMyxcbiAgICAgICdFQkFEUic6IDExNCxcbiAgICAgICdFWEZVTEwnOiAxMTUsXG4gICAgICAnRU5PQU5PJzogMTA0LFxuICAgICAgJ0VCQURSUUMnOiAxMDMsXG4gICAgICAnRUJBRFNMVCc6IDEwMixcbiAgICAgICdFREVBRExPQ0snOiAxNixcbiAgICAgICdFQkZPTlQnOiAxMDEsXG4gICAgICAnRU5PU1RSJzogMTAwLFxuICAgICAgJ0VOT0RBVEEnOiAxMTYsXG4gICAgICAnRVRJTUUnOiAxMTcsXG4gICAgICAnRU5PU1InOiAxMTgsXG4gICAgICAnRU5PTkVUJzogMTE5LFxuICAgICAgJ0VOT1BLRyc6IDEyMCxcbiAgICAgICdFUkVNT1RFJzogMTIxLFxuICAgICAgJ0VOT0xJTksnOiA0NyxcbiAgICAgICdFQURWJzogMTIyLFxuICAgICAgJ0VTUk1OVCc6IDEyMyxcbiAgICAgICdFQ09NTSc6IDEyNCxcbiAgICAgICdFUFJPVE8nOiA2NSxcbiAgICAgICdFTVVMVElIT1AnOiAzNixcbiAgICAgICdFRE9URE9UJzogMTI1LFxuICAgICAgJ0VCQURNU0cnOiA5LFxuICAgICAgJ0VOT1RVTklRJzogMTI2LFxuICAgICAgJ0VCQURGRCc6IDEyNyxcbiAgICAgICdFUkVNQ0hHJzogMTI4LFxuICAgICAgJ0VMSUJBQ0MnOiAxMjksXG4gICAgICAnRUxJQkJBRCc6IDEzMCxcbiAgICAgICdFTElCU0NOJzogMTMxLFxuICAgICAgJ0VMSUJNQVgnOiAxMzIsXG4gICAgICAnRUxJQkVYRUMnOiAxMzMsXG4gICAgICAnRU5PU1lTJzogNTIsXG4gICAgICAnRU5PVEVNUFRZJzogNTUsXG4gICAgICAnRU5BTUVUT09MT05HJzogMzcsXG4gICAgICAnRUxPT1AnOiAzMixcbiAgICAgICdFT1BOT1RTVVBQJzogMTM4LFxuICAgICAgJ0VQRk5PU1VQUE9SVCc6IDEzOSxcbiAgICAgICdFQ09OTlJFU0VUJzogMTUsXG4gICAgICAnRU5PQlVGUyc6IDQyLFxuICAgICAgJ0VBRk5PU1VQUE9SVCc6IDUsXG4gICAgICAnRVBST1RPVFlQRSc6IDY3LFxuICAgICAgJ0VOT1RTT0NLJzogNTcsXG4gICAgICAnRU5PUFJPVE9PUFQnOiA1MCxcbiAgICAgICdFU0hVVERPV04nOiAxNDAsXG4gICAgICAnRUNPTk5SRUZVU0VEJzogMTQsXG4gICAgICAnRUFERFJJTlVTRSc6IDMsXG4gICAgICAnRUNPTk5BQk9SVEVEJzogMTMsXG4gICAgICAnRU5FVFVOUkVBQ0gnOiA0MCxcbiAgICAgICdFTkVURE9XTic6IDM4LFxuICAgICAgJ0VUSU1FRE9VVCc6IDczLFxuICAgICAgJ0VIT1NURE9XTic6IDE0MixcbiAgICAgICdFSE9TVFVOUkVBQ0gnOiAyMyxcbiAgICAgICdFSU5QUk9HUkVTUyc6IDI2LFxuICAgICAgJ0VBTFJFQURZJzogNyxcbiAgICAgICdFREVTVEFERFJSRVEnOiAxNyxcbiAgICAgICdFTVNHU0laRSc6IDM1LFxuICAgICAgJ0VQUk9UT05PU1VQUE9SVCc6IDY2LFxuICAgICAgJ0VTT0NLVE5PU1VQUE9SVCc6IDEzNyxcbiAgICAgICdFQUREUk5PVEFWQUlMJzogNCxcbiAgICAgICdFTkVUUkVTRVQnOiAzOSxcbiAgICAgICdFSVNDT05OJzogMzAsXG4gICAgICAnRU5PVENPTk4nOiA1MyxcbiAgICAgICdFVE9PTUFOWVJFRlMnOiAxNDEsXG4gICAgICAnRVVTRVJTJzogMTM2LFxuICAgICAgJ0VEUVVPVCc6IDE5LFxuICAgICAgJ0VTVEFMRSc6IDcyLFxuICAgICAgJ0VOT1RTVVAnOiAxMzgsXG4gICAgICAnRU5PTUVESVVNJzogMTQ4LFxuICAgICAgJ0VJTFNFUSc6IDI1LFxuICAgICAgJ0VPVkVSRkxPVyc6IDYxLFxuICAgICAgJ0VDQU5DRUxFRCc6IDExLFxuICAgICAgJ0VOT1RSRUNPVkVSQUJMRSc6IDU2LFxuICAgICAgJ0VPV05FUkRFQUQnOiA2MixcbiAgICAgICdFU1RSUElQRSc6IDEzNSxcbiAgICB9O1xuICB2YXIgRlMgPSB7XG4gIHJvb3Q6bnVsbCxcbiAgbW91bnRzOltdLFxuICBkZXZpY2VzOntcbiAgfSxcbiAgc3RyZWFtczpbXSxcbiAgbmV4dElub2RlOjEsXG4gIG5hbWVUYWJsZTpudWxsLFxuICBjdXJyZW50UGF0aDpcIi9cIixcbiAgaW5pdGlhbGl6ZWQ6ZmFsc2UsXG4gIGlnbm9yZVBlcm1pc3Npb25zOnRydWUsXG4gIEVycm5vRXJyb3I6Y2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIC8vIFdlIHNldCB0aGUgYG5hbWVgIHByb3BlcnR5IHRvIGJlIGFibGUgdG8gaWRlbnRpZnkgYEZTLkVycm5vRXJyb3JgXG4gICAgICAgIC8vIC0gdGhlIGBuYW1lYCBpcyBhIHN0YW5kYXJkIEVDTUEtMjYyIHByb3BlcnR5IG9mIGVycm9yIG9iamVjdHMuIEtpbmQgb2YgZ29vZCB0byBoYXZlIGl0IGFueXdheS5cbiAgICAgICAgLy8gLSB3aGVuIHVzaW5nIFBST1hZRlMsIGFuIGVycm9yIGNhbiBjb21lIGZyb20gYW4gdW5kZXJseWluZyBGU1xuICAgICAgICAvLyBhcyBkaWZmZXJlbnQgRlMgb2JqZWN0cyBoYXZlIHRoZWlyIG93biBGUy5FcnJub0Vycm9yIGVhY2gsXG4gICAgICAgIC8vIHRoZSB0ZXN0IGBlcnIgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yYCB3b24ndCBkZXRlY3QgYW4gZXJyb3IgY29taW5nIGZyb20gYW5vdGhlciBmaWxlc3lzdGVtLCBjYXVzaW5nIGJ1Z3MuXG4gICAgICAgIC8vIHdlJ2xsIHVzZSB0aGUgcmVsaWFibGUgdGVzdCBgZXJyLm5hbWUgPT0gXCJFcnJub0Vycm9yXCJgIGluc3RlYWRcbiAgICAgICAgY29uc3RydWN0b3IoZXJybm8pIHtcbiAgICAgICAgICBzdXBlcihydW50aW1lSW5pdGlhbGl6ZWQgPyBzdHJFcnJvcihlcnJubykgOiAnJyk7XG4gICAgICAgICAgLy8gVE9ETyhzYmMpOiBVc2UgdGhlIGlubGluZSBtZW1iZXIgZGVjbGFyYXRpb24gc3ludGF4IG9uY2Ugd2VcbiAgICAgICAgICAvLyBzdXBwb3J0IGl0IGluIGFjb3JuIGFuZCBjbG9zdXJlLlxuICAgICAgICAgIHRoaXMubmFtZSA9ICdFcnJub0Vycm9yJztcbiAgICAgICAgICB0aGlzLmVycm5vID0gZXJybm87XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIEVSUk5PX0NPREVTKSB7XG4gICAgICAgICAgICBpZiAoRVJSTk9fQ09ERVNba2V5XSA9PT0gZXJybm8pIHtcbiAgICAgICAgICAgICAgdGhpcy5jb2RlID0ga2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIGdlbmVyaWNFcnJvcnM6e1xuICB9LFxuICBmaWxlc3lzdGVtczpudWxsLFxuICBzeW5jRlNSZXF1ZXN0czowLFxuICBGU1N0cmVhbTpjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8yMTQxNCk6XG4gICAgICAgICAgLy8gVXNlIGlubGluZSBmaWVsZCBkZWNsYXJhdGlvbnMuXG4gICAgICAgICAgdGhpcy5zaGFyZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgb2JqZWN0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IG9iamVjdCh2YWwpIHtcbiAgICAgICAgICB0aGlzLm5vZGUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzUmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNXcml0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNBcHBlbmQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGZsYWdzKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYXJlZC5mbGFncztcbiAgICAgICAgfVxuICAgICAgICBzZXQgZmxhZ3ModmFsKSB7XG4gICAgICAgICAgdGhpcy5zaGFyZWQuZmxhZ3MgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYXJlZC5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBzZXQgcG9zaXRpb24odmFsKSB7XG4gICAgICAgICAgdGhpcy5zaGFyZWQucG9zaXRpb24gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIEZTTm9kZTpjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikge1xuICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzOyAgLy8gcm9vdCBub2RlIHNldHMgcGFyZW50IHRvIGl0c2VsZlxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICAgICAgICAgIHRoaXMubW91bnRlZCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pZCA9IEZTLm5leHRJbm9kZSsrO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLm5vZGVfb3BzID0ge307XG4gICAgICAgICAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gICAgICAgICAgdGhpcy5yZGV2ID0gcmRldjtcbiAgICAgICAgICB0aGlzLnJlYWRNb2RlID0gMjkyIHwgNzM7XG4gICAgICAgICAgdGhpcy53cml0ZU1vZGUgPSAxNDY7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB0aGlzLnJlYWRNb2RlKSA9PT0gdGhpcy5yZWFkTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgcmVhZCh2YWwpIHtcbiAgICAgICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gdGhpcy5yZWFkTW9kZSA6IHRoaXMubW9kZSAmPSB+dGhpcy5yZWFkTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgd3JpdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB0aGlzLndyaXRlTW9kZSkgPT09IHRoaXMud3JpdGVNb2RlO1xuICAgICAgICB9XG4gICAgICAgIHNldCB3cml0ZSh2YWwpIHtcbiAgICAgICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gdGhpcy53cml0ZU1vZGUgOiB0aGlzLm1vZGUgJj0gfnRoaXMud3JpdGVNb2RlO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc0ZvbGRlcigpIHtcbiAgICAgICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNEZXZpY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIGxvb2t1cFBhdGgocGF0aCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHBhdGggPSBQQVRIX0ZTLnJlc29sdmUocGF0aCk7XG4gIFxuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiB7IHBhdGg6ICcnLCBub2RlOiBudWxsIH07XG4gIFxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgZm9sbG93X21vdW50OiB0cnVlLFxuICAgICAgICAgIHJlY3Vyc2VfY291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpXG4gIFxuICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkgeyAgLy8gbWF4IHJlY3Vyc2l2ZSBsb29rdXAgb2YgOFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gc3BsaXQgdGhlIGFic29sdXRlIHBhdGhcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKTtcbiAgXG4gICAgICAgIC8vIHN0YXJ0IGF0IHRoZSByb290XG4gICAgICAgIHZhciBjdXJyZW50ID0gRlMucm9vdDtcbiAgICAgICAgdmFyIGN1cnJlbnRfcGF0aCA9ICcvJztcbiAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gKGkgPT09IHBhcnRzLmxlbmd0aC0xKTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBzdG9wIHJlc29sdmluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcbiAgXG4gICAgICAgICAgLy8ganVtcCB0byB0aGUgbW91bnQncyByb290IG5vZGUgaWYgdGhpcyBpcyBhIG1vdW50cG9pbnRcbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tb3VudGVkLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBieSBkZWZhdWx0LCBsb29rdXBQYXRoIHdpbGwgbm90IGZvbGxvdyBhIHN5bWxpbmsgaWYgaXQgaXMgdGhlIGZpbmFsIHBhdGggY29tcG9uZW50LlxuICAgICAgICAgIC8vIHNldHRpbmcgb3B0cy5mb2xsb3cgPSB0cnVlIHdpbGwgb3ZlcnJpZGUgdGhpcyBiZWhhdmlvci5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG4gIFxuICAgICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChjdXJyZW50X3BhdGgsIHsgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSB9KTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkgeyAgLy8gbGltaXQgbWF4IGNvbnNlY3V0aXZlIHN5bWxpbmtzIHRvIDQwIChTWU1MT09QX01BWCkuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgICAgIH0sXG4gIGdldFBhdGgobm9kZSkge1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBtb3VudFttb3VudC5sZW5ndGgtMV0gIT09ICcvJyA/IGAke21vdW50fS8ke3BhdGh9YCA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBgJHtub2RlLm5hbWV9LyR7cGF0aH1gIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgaGFzaE5hbWUocGFyZW50aWQsIG5hbWUpIHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gICAgICB9LFxuICBoYXNoQWRkTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlO1xuICAgICAgfSxcbiAgaGFzaFJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XG4gICAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5hbWVfbmV4dCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIGxvb2t1cE5vZGUocGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShwYXJlbnQuaWQsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHtcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LmlkID09PSBwYXJlbnQuaWQgJiYgbm9kZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBmYWlsZWQgdG8gZmluZCBpdCBpbiB0aGUgY2FjaGUsIGNhbGwgaW50byB0aGUgVkZTXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gIGNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGFyZW50ID09ICdvYmplY3QnKVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBGUy5GU05vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KTtcbiAgXG4gICAgICAgIEZTLmhhc2hBZGROb2RlKG5vZGUpO1xuICBcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICBkZXN0cm95Tm9kZShub2RlKSB7XG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgaXNSb290KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IG5vZGUucGFyZW50O1xuICAgICAgfSxcbiAgaXNNb3VudHBvaW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5tb3VudGVkO1xuICAgICAgfSxcbiAgaXNGaWxlKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2ODtcbiAgICAgIH0sXG4gIGlzRGlyKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAxNjM4NDtcbiAgICAgIH0sXG4gIGlzTGluayhtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjA7XG4gICAgICB9LFxuICBpc0NocmRldihtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MjtcbiAgICAgIH0sXG4gIGlzQmxrZGV2KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAyNDU3NjtcbiAgICAgIH0sXG4gIGlzRklGTyhtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjtcbiAgICAgIH0sXG4gIGlzU29ja2V0KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MjtcbiAgICAgIH0sXG4gIGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWcpIHtcbiAgICAgICAgdmFyIHBlcm1zID0gWydyJywgJ3cnLCAncncnXVtmbGFnICYgM107XG4gICAgICAgIGlmICgoZmxhZyAmIDUxMikpIHtcbiAgICAgICAgICBwZXJtcyArPSAndyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcm1zO1xuICAgICAgfSxcbiAgbm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSB7XG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiAwIGlmIGFueSB1c2VyLCBncm91cCBvciBvd25lciBiaXRzIGFyZSBzZXQuXG4gICAgICAgIGlmIChwZXJtcy5pbmNsdWRlcygncicpICYmICEobm9kZS5tb2RlICYgMjkyKSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluY2x1ZGVzKCd3JykgJiYgIShub2RlLm1vZGUgJiAxNDYpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3gnKSAmJiAhKG5vZGUubW9kZSAmIDczKSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgbWF5TG9va3VwKGRpcikge1xuICAgICAgICBpZiAoIUZTLmlzRGlyKGRpci5tb2RlKSkgcmV0dXJuIDU0O1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgaWYgKCFkaXIubm9kZV9vcHMubG9va3VwKSByZXR1cm4gMjtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICBtYXlDcmVhdGUoZGlyLCBuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgfSxcbiAgbWF5RGVsZXRlKGRpciwgbmFtZSwgaXNkaXIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzZGlyKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkgfHwgRlMuZ2V0UGF0aChub2RlKSA9PT0gRlMuY3dkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICBtYXlPcGVuKG5vZGUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHJldHVybiA0NDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGlmIChGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykgIT09ICdyJyB8fCAvLyBvcGVuaW5nIGZvciB3cml0ZVxuICAgICAgICAgICAgICAoZmxhZ3MgJiA1MTIpKSB7IC8vIFRPRE86IGNoZWNrIGZvciBPX1NFQVJDSD8gKD09IHNlYXJjaCBmb3IgZGlyIG9ubHkpXG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpKTtcbiAgICAgIH0sXG4gIE1BWF9PUEVOX0ZEUzo0MDk2LFxuICBuZXh0ZmQoKSB7XG4gICAgICAgIGZvciAodmFyIGZkID0gMDsgZmQgPD0gRlMuTUFYX09QRU5fRkRTOyBmZCsrKSB7XG4gICAgICAgICAgaWYgKCFGUy5zdHJlYW1zW2ZkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMyk7XG4gICAgICB9LFxuICBnZXRTdHJlYW1DaGVja2VkKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICBnZXRTdHJlYW06KGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxcbiAgY3JlYXRlU3RyZWFtKHN0cmVhbSwgZmQgPSAtMSkge1xuICAgICAgICBhc3NlcnQoZmQgPj0gLTEpO1xuICBcbiAgICAgICAgLy8gY2xvbmUgaXQsIHNvIHdlIGNhbiByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRlNTdHJlYW1cbiAgICAgICAgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihuZXcgRlMuRlNTdHJlYW0oKSwgc3RyZWFtKTtcbiAgICAgICAgaWYgKGZkID09IC0xKSB7XG4gICAgICAgICAgZmQgPSBGUy5uZXh0ZmQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICBjbG9zZVN0cmVhbShmZCkge1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gICAgICB9LFxuICBkdXBTdHJlYW0ob3JpZ1N0cmVhbSwgZmQgPSAtMSkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKG9yaWdTdHJlYW0sIGZkKTtcbiAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHM/LmR1cD8uKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICBjaHJkZXZfc3RyZWFtX29wczp7XG4gIG9wZW4oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtcbiAgICAgICAgICAvLyBvdmVycmlkZSBub2RlJ3Mgc3RyZWFtIG9wcyB3aXRoIHRoZSBkZXZpY2Unc1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzID0gZGV2aWNlLnN0cmVhbV9vcHM7XG4gICAgICAgICAgLy8gZm9yd2FyZCB0aGUgb3BlbiBjYWxsXG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3Blbj8uKHN0cmVhbSk7XG4gICAgICAgIH0sXG4gIGxsc2VlaygpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH0sXG4gIH0sXG4gIG1ham9yOihkZXYpID0+ICgoZGV2KSA+PiA4KSxcbiAgbWlub3I6KGRldikgPT4gKChkZXYpICYgMHhmZiksXG4gIG1ha2VkZXY6KG1hLCBtaSkgPT4gKChtYSkgPDwgOCB8IChtaSkpLFxuICByZWdpc3RlckRldmljZShkZXYsIG9wcykge1xuICAgICAgICBGUy5kZXZpY2VzW2Rldl0gPSB7IHN0cmVhbV9vcHM6IG9wcyB9O1xuICAgICAgfSxcbiAgZ2V0RGV2aWNlOihkZXYpID0+IEZTLmRldmljZXNbZGV2XSxcbiAgZ2V0TW91bnRzKG1vdW50KSB7XG4gICAgICAgIHZhciBtb3VudHMgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrID0gW21vdW50XTtcbiAgXG4gICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuICBcbiAgICAgICAgICBtb3VudHMucHVzaChtKTtcbiAgXG4gICAgICAgICAgY2hlY2sucHVzaCguLi5tLm1vdW50cyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBtb3VudHM7XG4gICAgICB9LFxuICBzeW5jZnMocG9wdWxhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wdWxhdGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrID0gcG9wdWxhdGU7XG4gICAgICAgICAgcG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMrKztcbiAgXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgICAgICBlcnIoYHdhcm5pbmc6ICR7RlMuc3luY0ZTUmVxdWVzdHN9IEZTLnN5bmNmcyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlLCBwcm9iYWJseSBqdXN0IGRvaW5nIGV4dHJhIHdvcmtgKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gIFxuICAgICAgICBmdW5jdGlvbiBkb0NhbGxiYWNrKGVyckNvZGUpIHtcbiAgICAgICAgICBhc3NlcnQoRlMuc3luY0ZTUmVxdWVzdHMgPiAwKTtcbiAgICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cy0tO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnJDb2RlKSB7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7XG4gICAgICAgICAgICAgIGRvbmUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBkb0NhbGxiYWNrKGVyckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytjb21wbGV0ZWQgPj0gbW91bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9DYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gIFxuICAgICAgICAvLyBzeW5jIGFsbCBtb3VudHNcbiAgICAgICAgbW91bnRzLmZvckVhY2goKG1vdW50KSA9PiB7XG4gICAgICAgICAgaWYgKCFtb3VudC50eXBlLnN5bmNmcykge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50LnR5cGUuc3luY2ZzKG1vdW50LCBwb3B1bGF0ZSwgZG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgbW91bnQodHlwZSwgb3B0cywgbW91bnRwb2ludCkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBUaGUgZmlsZXN5c3RlbSB3YXMgbm90IGluY2x1ZGVkLCBhbmQgaW5zdGVhZCB3ZSBoYXZlIGFuIGVycm9yXG4gICAgICAgICAgLy8gbWVzc2FnZSBzdG9yZWQgaW4gdGhlIHZhcmlhYmxlLlxuICAgICAgICAgIHRocm93IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSAnLyc7XG4gICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDtcbiAgICAgICAgdmFyIG5vZGU7XG4gIFxuICAgICAgICBpZiAocm9vdCAmJiBGUy5yb290KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9IGVsc2UgaWYgKCFyb290ICYmICFwc2V1ZG8pIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG4gIFxuICAgICAgICAgIG1vdW50cG9pbnQgPSBsb29rdXAucGF0aDsgIC8vIHVzZSB0aGUgYWJzb2x1dGUgcGF0aFxuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgbW91bnQgPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIG1vdW50cG9pbnQsXG4gICAgICAgICAgbW91bnRzOiBbXVxuICAgICAgICB9O1xuICBcbiAgICAgICAgLy8gY3JlYXRlIGEgcm9vdCBub2RlIGZvciB0aGUgZnNcbiAgICAgICAgdmFyIG1vdW50Um9vdCA9IHR5cGUubW91bnQobW91bnQpO1xuICAgICAgICBtb3VudFJvb3QubW91bnQgPSBtb3VudDtcbiAgICAgICAgbW91bnQucm9vdCA9IG1vdW50Um9vdDtcbiAgXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgLy8gc2V0IGFzIGEgbW91bnRwb2ludFxuICAgICAgICAgIG5vZGUubW91bnRlZCA9IG1vdW50O1xuICBcbiAgICAgICAgICAvLyBhZGQgdGhlIG5ldyBtb3VudCB0byB0aGUgY3VycmVudCBtb3VudCdzIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKG5vZGUubW91bnQpIHtcbiAgICAgICAgICAgIG5vZGUubW91bnQubW91bnRzLnB1c2gobW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG1vdW50Um9vdDtcbiAgICAgIH0sXG4gIHVubW91bnQobW91bnRwb2ludCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG4gIFxuICAgICAgICBpZiAoIUZTLmlzTW91bnRwb2ludChsb29rdXAubm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIG5vZGVzIGZvciB0aGlzIG1vdW50LCBhbmQgYWxsIGl0cyBjaGlsZCBtb3VudHNcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkO1xuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcbiAgXG4gICAgICAgIE9iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaCgoaGFzaCkgPT4ge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICBcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgXG4gICAgICAgICAgICBpZiAobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKSB7XG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gIFxuICAgICAgICAvLyBubyBsb25nZXIgYSBtb3VudHBvaW50XG4gICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG4gIFxuICAgICAgICAvLyByZW1vdmUgdGhpcyBtb3VudCBmcm9tIHRoZSBjaGlsZCBtb3VudHNcbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSk7XG4gICAgICAgIG5vZGUubW91bnQubW91bnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfSxcbiAgbG9va3VwKHBhcmVudCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxcbiAgbWtub2QocGF0aCwgbW9kZSwgZGV2KSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09ICcuJyB8fCBuYW1lID09PSAnLi4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMubWtub2QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5ta25vZChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICB9LFxuICBjcmVhdGUocGF0aCwgbW9kZSkge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDQzOCAvKiAwNjY2ICovO1xuICAgICAgICBtb2RlICY9IDQwOTU7XG4gICAgICAgIG1vZGUgfD0gMzI3Njg7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sXG4gIG1rZGlyKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA1MTEgLyogMDc3NyAqLztcbiAgICAgICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgICAgIG1vZGUgfD0gMTYzODQ7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sXG4gIG1rZGlyVHJlZShwYXRoLCBtb2RlKSB7XG4gICAgICAgIHZhciBkaXJzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWRpcnNbaV0pIGNvbnRpbnVlO1xuICAgICAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoZCwgbW9kZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBpZiAoZS5lcnJubyAhPSAyMCkgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIG1rZGV2KHBhdGgsIG1vZGUsIGRldikge1xuICAgICAgICBpZiAodHlwZW9mIGRldiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRldiA9IG1vZGU7XG4gICAgICAgICAgbW9kZSA9IDQzOCAvKiAwNjY2ICovO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgfD0gODE5MjtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIGRldik7XG4gICAgICB9LFxuICBzeW1saW5rKG9sZHBhdGgsIG5ld3BhdGgpIHtcbiAgICAgICAgaWYgKCFQQVRIX0ZTLnJlc29sdmUob2xkcGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3cGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld3BhdGgpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5ld25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCk7XG4gICAgICB9LFxuICByZW5hbWUob2xkX3BhdGgsIG5ld19wYXRoKSB7XG4gICAgICAgIHZhciBvbGRfZGlybmFtZSA9IFBBVEguZGlybmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfZGlybmFtZSA9IFBBVEguZGlybmFtZShuZXdfcGF0aCk7XG4gICAgICAgIHZhciBvbGRfbmFtZSA9IFBBVEguYmFzZW5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld19wYXRoKTtcbiAgICAgICAgLy8gcGFyZW50cyBtdXN0IGV4aXN0XG4gICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7XG4gIFxuICAgICAgICAvLyBsZXQgdGhlIGVycm9ycyBmcm9tIG5vbiBleGlzdGVudCBkaXJlY3RvcmllcyBwZXJjb2xhdGUgdXBcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChvbGRfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG5ld19kaXIgPSBsb29rdXAubm9kZTtcbiAgXG4gICAgICAgIGlmICghb2xkX2RpciB8fCAhbmV3X2RpcikgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICAvLyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHNhbWUgbW91bnRcbiAgICAgICAgaWYgKG9sZF9kaXIubW91bnQgIT09IG5ld19kaXIubW91bnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3NSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc291cmNlIG11c3QgZXhpc3RcbiAgICAgICAgdmFyIG9sZF9ub2RlID0gRlMubG9va3VwTm9kZShvbGRfZGlyLCBvbGRfbmFtZSk7XG4gICAgICAgIC8vIG9sZCBwYXRoIHNob3VsZCBub3QgYmUgYW4gYW5jZXN0b3Igb2YgdGhlIG5ldyBwYXRoXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsIG5ld19kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5ldyBwYXRoIHNob3VsZCBub3QgYmUgYW4gYW5jZXN0b3Igb2YgdGhlIG9sZCBwYXRoXG4gICAgICAgIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShuZXdfcGF0aCwgb2xkX2Rpcm5hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIGlmIHRoZSBuZXcgcGF0aCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIG5vdCBmYXRhbFxuICAgICAgICB9XG4gICAgICAgIC8vIGVhcmx5IG91dCBpZiBub3RoaW5nIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgICBpZiAob2xkX25vZGUgPT09IG5ld19ub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlJ2xsIG5lZWQgdG8gZGVsZXRlIHRoZSBvbGQgZW50cnlcbiAgICAgICAgdmFyIGlzZGlyID0gRlMuaXNEaXIob2xkX25vZGUubW9kZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKG9sZF9kaXIsIG9sZF9uYW1lLCBpc2Rpcik7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZCBkZWxldGUgcGVybWlzc2lvbnMgaWYgd2UnbGwgYmUgb3ZlcndyaXRpbmcuXG4gICAgICAgIC8vIG5lZWQgY3JlYXRlIHBlcm1pc3Npb25zIGlmIG5ldyBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gICAgICAgIGVyckNvZGUgPSBuZXdfbm9kZSA/XG4gICAgICAgICAgRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcikgOlxuICAgICAgICAgIEZTLm1heUNyZWF0ZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fCAobmV3X25vZGUgJiYgRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIGdvaW5nIHRvIGNoYW5nZSB0aGUgcGFyZW50LCBjaGVjayB3cml0ZSBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAobmV3X2RpciAhPT0gb2xkX2Rpcikge1xuICAgICAgICAgIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBsb29rdXAgaGFzaFxuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7XG4gICAgICAgIC8vIGRvIHRoZSB1bmRlcmx5aW5nIGZzIHJlbmFtZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgICAgLy8gdXBkYXRlIG9sZCBub2RlICh3ZSBkbyB0aGlzIGhlcmUgdG8gYXZvaWQgZWFjaCBiYWNrZW5kIFxuICAgICAgICAgIC8vIG5lZWRpbmcgdG8pXG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gYWRkIHRoZSBub2RlIGJhY2sgdG8gdGhlIGhhc2ggKGluIGNhc2Ugbm9kZV9vcHMucmVuYW1lXG4gICAgICAgICAgLy8gY2hhbmdlZCBpdHMgbmFtZSlcbiAgICAgICAgICBGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIHJtZGlyKHBhdGgpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ybWRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsIG5hbWUpO1xuICAgICAgICBGUy5kZXN0cm95Tm9kZShub2RlKTtcbiAgICAgIH0sXG4gIHJlYWRkaXIocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKTtcbiAgICAgIH0sXG4gIHVubGluayhwYXRoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIC8vIEFjY29yZGluZyB0byBQT1NJWCwgd2Ugc2hvdWxkIG1hcCBFSVNESVIgdG8gRVBFUk0sIGJ1dFxuICAgICAgICAgIC8vIHdlIGluc3RlYWQgZG8gd2hhdCBMaW51eCBkb2VzIChhbmQgd2UgbXVzdCwgYXMgd2UgdXNlXG4gICAgICAgICAgLy8gdGhlIG11c2wgbGludXggbGliYykuXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMudW5saW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpO1xuICAgICAgICBGUy5kZXN0cm95Tm9kZShub2RlKTtcbiAgICAgIH0sXG4gIHJlYWRsaW5rKHBhdGgpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCk7XG4gICAgICAgIHZhciBsaW5rID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBVEhfRlMucmVzb2x2ZShGUy5nZXRQYXRoKGxpbmsucGFyZW50KSwgbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSk7XG4gICAgICB9LFxuICBzdGF0KHBhdGgsIGRvbnRGb2xsb3cpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMuZ2V0YXR0cihub2RlKTtcbiAgICAgIH0sXG4gIGxzdGF0KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSk7XG4gICAgICB9LFxuICBjaG1vZChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgbGNobW9kKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSwgdHJ1ZSk7XG4gICAgICB9LFxuICBmY2htb2QoZmQsIG1vZGUpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7XG4gICAgICB9LFxuICBjaG93bihwYXRoLCB1aWQsIGdpZCwgZG9udEZvbGxvdykge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgdWlkIC8gZ2lkIGZvciBub3dcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICBsY2hvd24ocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpO1xuICAgICAgfSxcbiAgZmNob3duKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XG4gICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7XG4gICAgICB9LFxuICB0cnVuY2F0ZShwYXRoLCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsICd3Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBzaXplOiBsZW4sXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgZnRydW5jYXRlKGZkLCBsZW4pIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLnRydW5jYXRlKHN0cmVhbS5ub2RlLCBsZW4pO1xuICAgICAgfSxcbiAgdXRpbWUocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5tYXgoYXRpbWUsIG10aW1lKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gIG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgPSB0eXBlb2YgZmxhZ3MgPT0gJ3N0cmluZycgPyBGU19tb2RlU3RyaW5nVG9GbGFncyhmbGFncykgOiBmbGFncztcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PSAndW5kZWZpbmVkJyA/IDQzOCAvKiAwNjY2ICovIDogbW9kZTtcbiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHtcbiAgICAgICAgICAgICAgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmhhcHMgd2UgbmVlZCB0byBjcmVhdGUgdGhlIG5vZGVcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAvLyBpZiBPX0NSRUFUIGFuZCBPX0VYQ0wgYXJlIHNldCwgZXJyb3Igb3V0IGlmIHRoZSBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMTI4KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vZGUgZG9lc24ndCBleGlzdCwgdHJ5IHRvIGNyZWF0ZSBpdFxuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW4ndCB0cnVuY2F0ZSBhIGRldmljZVxuICAgICAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGZsYWdzICY9IH41MTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYXNrZWQgb25seSBmb3IgYSBkaXJlY3RvcnksIHRoZW4gdGhpcyBtdXN0IGJlIG9uZVxuICAgICAgICBpZiAoKGZsYWdzICYgNjU1MzYpICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHBlcm1pc3Npb25zLCBpZiB0aGlzIGlzIG5vdCBhIGZpbGUgd2UganVzdCBjcmVhdGVkIG5vdyAoaXQgaXMgb2sgdG9cbiAgICAgICAgLy8gY3JlYXRlIGFuZCB3cml0ZSB0byBhIGZpbGUgd2l0aCByZWFkLW9ubHkgcGVybWlzc2lvbnM7IGl0IGlzIHJlYWQtb25seVxuICAgICAgICAvLyBmb3IgbGF0ZXIgdXNlKVxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gdHJ1bmNhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKChmbGFncyAmIDUxMikgJiYgIWNyZWF0ZWQpIHtcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlc2UsIGRvbid0IHBhc3MgZG93biB0byB0aGUgdW5kZXJseWluZyB2ZnNcbiAgICAgICAgZmxhZ3MgJj0gfigxMjggfCA1MTIgfCAxMzEwNzIpO1xuICBcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0cmVhbSB3aXRoIHRoZSBmaWxlc3lzdGVtXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcGF0aDogRlMuZ2V0UGF0aChub2RlKSwgIC8vIHdlIHdhbnQgdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIG5vZGVcbiAgICAgICAgICBmbGFncyxcbiAgICAgICAgICBzZWVrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsXG4gICAgICAgICAgLy8gdXNlZCBieSB0aGUgZmlsZSBmYW1pbHkgbGliYyBjYWxscyAoZm9wZW4sIGZ3cml0ZSwgZmVycm9yLCBldGMuKVxuICAgICAgICAgIHVuZ290dGVuOiBbXSxcbiAgICAgICAgICBlcnJvcjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNhbGwgdGhlIG5ldyBzdHJlYW0ncyBvcGVuIGZ1bmN0aW9uXG4gICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ2xvZ1JlYWRGaWxlcyddICYmICEoZmxhZ3MgJiAxKSkge1xuICAgICAgICAgIGlmICghRlMucmVhZEZpbGVzKSBGUy5yZWFkRmlsZXMgPSB7fTtcbiAgICAgICAgICBpZiAoIShwYXRoIGluIEZTLnJlYWRGaWxlcykpIHtcbiAgICAgICAgICAgIEZTLnJlYWRGaWxlc1twYXRoXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICBjbG9zZShzdHJlYW0pIHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmdldGRlbnRzKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyAvLyBmcmVlIHJlYWRkaXIgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2UpIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5mZCA9IG51bGw7XG4gICAgICB9LFxuICBpc0Nsb3NlZChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5mZCA9PT0gbnVsbDtcbiAgICAgIH0sXG4gIGxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0sXG4gIHJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBhc3NlcnQob2Zmc2V0ID49IDApO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMucmVhZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNSZWFkO1xuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgfSxcbiAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgIGFzc2VydChvZmZzZXQgPj0gMCk7XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLnNlZWthYmxlICYmIHN0cmVhbS5mbGFncyAmIDEwMjQpIHtcbiAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBlbmQgYmVmb3JlIHdyaXRpbmcgaW4gYXBwZW5kIG1vZGVcbiAgICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCAwLCAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNXcml0dGVuID0gc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNXcml0dGVuO1xuICAgICAgICByZXR1cm4gYnl0ZXNXcml0dGVuO1xuICAgICAgfSxcbiAgYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSAmJiAhRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICB9LFxuICBtbWFwKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpIHtcbiAgICAgICAgLy8gVXNlciByZXF1ZXN0cyB3cml0aW5nIHRvIGZpbGUgKHByb3QgJiBQUk9UX1dSSVRFICE9IDApLlxuICAgICAgICAvLyBDaGVja2luZyBpZiB3ZSBoYXZlIHBlcm1pc3Npb25zIHRvIHdyaXRlIHRvIHRoZSBmaWxlIHVubGVzc1xuICAgICAgICAvLyBNQVBfUFJJVkFURSBmbGFnIGlzIHNldC4gQWNjb3JkaW5nIHRvIFBPU0lYIHNwZWMgaXQgaXMgcG9zc2libGVcbiAgICAgICAgLy8gdG8gd3JpdGUgdG8gZmlsZSBvcGVuZWQgaW4gcmVhZC1vbmx5IG1vZGUgd2l0aCBNQVBfUFJJVkFURSBmbGFnLFxuICAgICAgICAvLyBhcyBhbGwgbW9kaWZpY2F0aW9ucyB3aWxsIGJlIHZpc2libGUgb25seSBpbiB0aGUgbWVtb3J5IG9mXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gICAgICAgIGlmICgocHJvdCAmIDIpICE9PSAwXG4gICAgICAgICAgICAmJiAoZmxhZ3MgJiAyKSA9PT0gMFxuICAgICAgICAgICAgJiYgKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcbiAgICAgIH0sXG4gIG1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgIGFzc2VydChvZmZzZXQgPj0gMCk7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpO1xuICAgICAgfSxcbiAgaW9jdGwoc3RyZWFtLCBjbWQsIGFyZykge1xuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKTtcbiAgICAgIH0sXG4gIHJlYWRGaWxlKHBhdGgsIG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAwO1xuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJHtvcHRzLmVuY29kaW5nfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgcmV0ID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICB3cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSsxKTtcbiAgICAgICAgICB2YXIgYWN0dWFsTnVtQnl0ZXMgPSBzdHJpbmdUb1VURjhBcnJheShkYXRhLCBidWYsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgsIHVuZGVmaW5lZCwgb3B0cy5jYW5Pd24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0sXG4gIGN3ZDooKSA9PiBGUy5jdXJyZW50UGF0aCxcbiAgY2hkaXIocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGxvb2t1cC5ub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY3VycmVudFBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgIH0sXG4gIGNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpIHtcbiAgICAgICAgRlMubWtkaXIoJy90bXAnKTtcbiAgICAgICAgRlMubWtkaXIoJy9ob21lJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZS93ZWJfdXNlcicpO1xuICAgICAgfSxcbiAgY3JlYXRlRGVmYXVsdERldmljZXMoKSB7XG4gICAgICAgIC8vIGNyZWF0ZSAvZGV2XG4gICAgICAgIEZTLm1rZGlyKCcvZGV2Jyk7XG4gICAgICAgIC8vIHNldHVwIC9kZXYvbnVsbFxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsIDMpLCB7XG4gICAgICAgICAgcmVhZDogKCkgPT4gMCxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiBsZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBGUy5ta2RldignL2Rldi9udWxsJywgRlMubWFrZWRldigxLCAzKSk7XG4gICAgICAgIC8vIHNldHVwIC9kZXYvdHR5IGFuZCAvZGV2L3R0eTFcbiAgICAgICAgLy8gc3RkZXJyIG5lZWRzIHRvIHByaW50IG91dHB1dCB1c2luZyBlcnIoKSByYXRoZXIgdGhhbiBvdXQoKVxuICAgICAgICAvLyBzbyB3ZSByZWdpc3RlciBhIHNlY29uZCB0dHkganVzdCBmb3IgaXQuXG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDUsIDApLCBUVFkuZGVmYXVsdF90dHlfb3BzKTtcbiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNiwgMCksIFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5JywgRlMubWFrZWRldig1LCAwKSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eTEnLCBGUy5tYWtlZGV2KDYsIDApKTtcbiAgICAgICAgLy8gc2V0dXAgL2Rldi9bdV1yYW5kb21cbiAgICAgICAgLy8gdXNlIGEgYnVmZmVyIHRvIGF2b2lkIG92ZXJoZWFkIG9mIGluZGl2aWR1YWwgY3J5cHRvIGNhbGxzIHBlciBieXRlXG4gICAgICAgIHZhciByYW5kb21CdWZmZXIgPSBuZXcgVWludDhBcnJheSgxMDI0KSwgcmFuZG9tTGVmdCA9IDA7XG4gICAgICAgIHZhciByYW5kb21CeXRlID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChyYW5kb21MZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICByYW5kb21MZWZ0ID0gcmFuZG9tRmlsbChyYW5kb21CdWZmZXIpLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5kb21CdWZmZXJbLS1yYW5kb21MZWZ0XTtcbiAgICAgICAgfTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3JhbmRvbScsIHJhbmRvbUJ5dGUpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAndXJhbmRvbScsIHJhbmRvbUJ5dGUpO1xuICAgICAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gZW11bGF0ZSB0aGUgYWN0dWFsIHNobSBkZXZpY2UsXG4gICAgICAgIC8vIGp1c3QgY3JlYXRlIHRoZSB0bXAgZGlycyB0aGF0IHJlc2lkZSBpbiBpdCBjb21tb25seVxuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0nKTtcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htL3RtcCcpO1xuICAgICAgfSxcbiAgY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCkge1xuICAgICAgICAvLyBjcmVhdGUgL3Byb2Mvc2VsZi9mZCB3aGljaCBhbGxvd3MgL3Byb2Mvc2VsZi9mZC82ID0+IHJlYWRsaW5rIGdpdmVzIHRoZVxuICAgICAgICAvLyBuYW1lIG9mIHRoZSBzdHJlYW0gZm9yIGZkIDYgKHNlZSB0ZXN0X3VuaXN0ZF90dHluYW1lKVxuICAgICAgICBGUy5ta2RpcignL3Byb2MnKTtcbiAgICAgICAgdmFyIHByb2Nfc2VsZiA9IEZTLm1rZGlyKCcvcHJvYy9zZWxmJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYy9zZWxmL2ZkJyk7XG4gICAgICAgIEZTLm1vdW50KHtcbiAgICAgICAgICBtb3VudCgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsICdmZCcsIDE2Mzg0IHwgNTExIC8qIDA3NzcgKi8sIDczKTtcbiAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICAgIGxvb2t1cChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmQgPSArbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgICAgbm9kZV9vcHM6IHsgcmVhZGxpbms6ICgpID0+IHN0cmVhbS5wYXRoIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcmV0OyAvLyBtYWtlIGl0IGxvb2sgbGlrZSBhIHNpbXBsZSByb290IG5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7fSwgJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgIH0sXG4gIGNyZWF0ZVN0YW5kYXJkU3RyZWFtcyhpbnB1dCwgb3V0cHV0LCBlcnJvcikge1xuICAgICAgICAvLyBUT0RPIGRlcHJlY2F0ZSB0aGUgb2xkIGZ1bmN0aW9uYWxpdHkgb2YgYSBzaW5nbGVcbiAgICAgICAgLy8gaW5wdXQgLyBvdXRwdXQgY2FsbGJhY2sgYW5kIHRoYXQgdXRpbGl6ZXMgRlMuY3JlYXRlRGV2aWNlXG4gICAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlcXVpcmUgYSB1bmlxdWUgc2V0IG9mIHN0cmVhbSBvcHNcbiAgXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIHdlIHN5bWxpbmsgdGhlIHN0YW5kYXJkIHN0cmVhbXMgdG8gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgdHR5IGRldmljZXMuIGhvd2V2ZXIsIGlmIHRoZSBzdGFuZGFyZCBzdHJlYW1zXG4gICAgICAgIC8vIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiB3ZSBjcmVhdGUgYSB1bmlxdWUgZGV2aWNlIGZvclxuICAgICAgICAvLyB0aGVtIGluc3RlYWQuXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRpbicsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZGluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3Rkb3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eTEnLCAnL2Rldi9zdGRlcnInKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gb3BlbiBkZWZhdWx0IHN0cmVhbXMgZm9yIHRoZSBzdGRpbiwgc3Rkb3V0IGFuZCBzdGRlcnIgZGV2aWNlc1xuICAgICAgICB2YXIgc3RkaW4gPSBGUy5vcGVuKCcvZGV2L3N0ZGluJywgMCk7XG4gICAgICAgIHZhciBzdGRvdXQgPSBGUy5vcGVuKCcvZGV2L3N0ZG91dCcsIDEpO1xuICAgICAgICB2YXIgc3RkZXJyID0gRlMub3BlbignL2Rldi9zdGRlcnInLCAxKTtcbiAgICAgICAgYXNzZXJ0KHN0ZGluLmZkID09PSAwLCBgaW52YWxpZCBoYW5kbGUgZm9yIHN0ZGluICgke3N0ZGluLmZkfSlgKTtcbiAgICAgICAgYXNzZXJ0KHN0ZG91dC5mZCA9PT0gMSwgYGludmFsaWQgaGFuZGxlIGZvciBzdGRvdXQgKCR7c3Rkb3V0LmZkfSlgKTtcbiAgICAgICAgYXNzZXJ0KHN0ZGVyci5mZCA9PT0gMiwgYGludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCR7c3RkZXJyLmZkfSlgKTtcbiAgICAgIH0sXG4gIHN0YXRpY0luaXQoKSB7XG4gICAgICAgIC8vIFNvbWUgZXJyb3JzIG1heSBoYXBwZW4gcXVpdGUgYSBiaXQsIHRvIGF2b2lkIG92ZXJoZWFkIHdlIHJldXNlIHRoZW0gKGFuZCBzdWZmZXIgYSBsYWNrIG9mIHN0YWNrIGluZm8pXG4gICAgICAgIFs0NF0uZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0gPSBuZXcgRlMuRXJybm9FcnJvcihjb2RlKTtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgICAgICB9KTtcbiAgXG4gICAgICAgIEZTLm5hbWVUYWJsZSA9IG5ldyBBcnJheSg0MDk2KTtcbiAgXG4gICAgICAgIEZTLm1vdW50KE1FTUZTLCB7fSwgJy8nKTtcbiAgXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO1xuICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcbiAgXG4gICAgICAgIEZTLmZpbGVzeXN0ZW1zID0ge1xuICAgICAgICAgICdNRU1GUyc6IE1FTUZTLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgaW5pdChpbnB1dCwgb3V0cHV0LCBlcnJvcikge1xuICAgICAgICBhc3NlcnQoIUZTLmluaXRpYWxpemVkLCAnRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKScpO1xuICAgICAgICBGUy5pbml0aWFsaXplZCA9IHRydWU7XG4gIFxuICAgICAgICAvLyBBbGxvdyBNb2R1bGUuc3RkaW4gZXRjLiB0byBwcm92aWRlIGRlZmF1bHRzLCBpZiBub25lIGV4cGxpY2l0bHkgcGFzc2VkIHRvIHVzIGhlcmVcbiAgICAgICAgaW5wdXQgPz89IE1vZHVsZVsnc3RkaW4nXTtcbiAgICAgICAgb3V0cHV0ID8/PSBNb2R1bGVbJ3N0ZG91dCddO1xuICAgICAgICBlcnJvciA/Pz0gTW9kdWxlWydzdGRlcnInXTtcbiAgXG4gICAgICAgIEZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcyhpbnB1dCwgb3V0cHV0LCBlcnJvcik7XG4gICAgICB9LFxuICBxdWl0KCkge1xuICAgICAgICBGUy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvLyBmb3JjZS1mbHVzaCBhbGwgc3RyZWFtcywgc28gd2UgZ2V0IG11c2wgc3RkIHN0cmVhbXMgcHJpbnRlZCBvdXRcbiAgICAgICAgX2ZmbHVzaCgwKTtcbiAgICAgICAgLy8gY2xvc2UgYWxsIG9mIG91ciBzdHJlYW1zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRlMuc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5zdHJlYW1zW2ldO1xuICAgICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgZmluZE9iamVjdChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKCFyZXQuZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgICB9LFxuICBhbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XG4gICAgICAgIC8vIG9wZXJhdGUgZnJvbSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIHN5bWxpbmsncyB0YXJnZXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLCBleGlzdHM6IGZhbHNlLCBlcnJvcjogMCwgbmFtZTogbnVsbCwgcGF0aDogbnVsbCwgb2JqZWN0OiBudWxsLFxuICAgICAgICAgIHBhcmVudEV4aXN0czogZmFsc2UsIHBhcmVudFBhdGg6IG51bGwsIHBhcmVudE9iamVjdDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7XG4gICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgY3JlYXRlUGF0aChwYXJlbnQsIHBhdGgsIGNhblJlYWQsIGNhbldyaXRlKSB7XG4gICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCk7XG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBQQVRILmpvaW4yKHBhcmVudCwgcGFydCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGN1cnJlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBFRVhJU1RcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH0sXG4gIGNyZWF0ZUZpbGUocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7XG4gICAgICAgIHZhciBtb2RlID0gRlNfZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHJldHVybiBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICB9LFxuICBjcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pIHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgICBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIocGFyZW50LCBuYW1lKSA6IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IEZTX2dldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjYW4gd3JpdGUgdG8gdGhlIGZpbGVcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlIHwgMTQ2KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMub3Blbihub2RlLCA1NzcpO1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDAsIGNhbk93bik7XG4gICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgY3JlYXRlRGV2aWNlKHBhcmVudCwgbmFtZSwgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7XG4gICAgICAgIHZhciBtb2RlID0gRlNfZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XG4gICAgICAgIGlmICghRlMuY3JlYXRlRGV2aWNlLm1ham9yKSBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPSA2NDtcbiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApO1xuICAgICAgICAvLyBDcmVhdGUgYSBmYWtlIGRldmljZSB0aGF0IGEgc2V0IG9mIHN0cmVhbSBvcHMgdG8gZW11bGF0ZVxuICAgICAgICAvLyB0aGUgb2xkIGJlaGF2aW9yLlxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIHtcbiAgICAgICAgICBvcGVuKHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZShzdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGFueSBwZW5kaW5nIGxpbmUgZGF0YVxuICAgICAgICAgICAgaWYgKG91dHB1dD8uYnVmZmVyPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb3V0cHV0KDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MgLyogaWdub3JlZCAqLykge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGJ1ZmZlcltvZmZzZXQraV0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gIGZvcmNlTG9hZEZpbGUob2JqKSB7XG4gICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cykgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC5cIik7XG4gICAgICAgIH0gZWxzZSB7IC8vIENvbW1hbmQtbGluZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gcmVhZEJpbmFyeShvYmoudXJsKTtcbiAgICAgICAgICAgIG9iai51c2VkQnl0ZXMgPSBvYmouY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIGNyZWF0ZUxhenlGaWxlKHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSkge1xuICAgICAgICAvLyBMYXp5IGNodW5rZWQgVWludDhBcnJheSAoaW1wbGVtZW50cyBnZXQgYW5kIGxlbmd0aCBmcm9tIFVpbnQ4QXJyYXkpLlxuICAgICAgICAvLyBBY3R1YWwgZ2V0dGluZyBpcyBhYnN0cmFjdGVkIGF3YXkgZm9yIGV2ZW50dWFsIHJldXNlLlxuICAgICAgICBjbGFzcyBMYXp5VWludDhBcnJheSB7XG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNodW5rcyA9IFtdOyAvLyBMb2FkZWQgY2h1bmtzLiBJbmRleCBpcyB0aGUgY2h1bmsgbnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGdldChpZHgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPiB0aGlzLmxlbmd0aC0xIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaHVua09mZnNldCA9IGlkeCAlIHRoaXMuY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGNodW5rTnVtID0gKGlkeCAvIHRoaXMuY2h1bmtTaXplKXwwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGVMZW5ndGgoKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGxlbmd0aFxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKCEoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiICsgdXJsICsgXCIuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgIHZhciBkYXRhbGVuZ3RoID0gTnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtbGVuZ3RoXCIpKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkgJiYgaGVhZGVyID09PSBcImJ5dGVzXCI7XG4gICAgICAgICAgICB2YXIgdXNlc0d6aXAgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSkgJiYgaGVhZGVyID09PSBcImd6aXBcIjtcbiAgXG4gICAgICAgICAgICB2YXIgY2h1bmtTaXplID0gMTAyNCoxMDI0OyAvLyBDaHVuayBzaXplIGluIGJ5dGVzXG4gIFxuICAgICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcbiAgXG4gICAgICAgICAgICAvLyBGdW5jdGlvbiB0byBnZXQgYSByYW5nZSBmcm9tIHRoZSByZW1vdGUgVVJMLlxuICAgICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmcm9tID4gdG8pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiICsgZnJvbSArIFwiLCBcIiArIHRvICsgXCIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCFcIik7XG4gICAgICAgICAgICAgIGlmICh0byA+IGRhdGFsZW5ndGgtMSkgdGhyb3cgbmV3IEVycm9yKFwib25seSBcIiArIGRhdGFsZW5ndGggKyBcIiBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhXCIpO1xuICBcbiAgICAgICAgICAgICAgLy8gVE9ETzogVXNlIG1velJlc3BvbnNlQXJyYXlCdWZmZXIsIHJlc3BvbnNlU3RyZWFtLCBldGMuIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChkYXRhbGVuZ3RoICE9PSBjaHVua1NpemUpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIGZyb20gKyBcIi1cIiArIHRvKTtcbiAgXG4gICAgICAgICAgICAgIC8vIFNvbWUgaGludHMgdG8gdGhlIGJyb3dzZXIgdGhhdCB3ZSB3YW50IGJpbmFyeSBkYXRhLlxuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgaWYgKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgIGlmICghKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgvKiogQHR5cGV7QXJyYXk8bnVtYmVyPn0gKi8oeGhyLnJlc3BvbnNlIHx8IFtdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0IHx8ICcnLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpcztcbiAgICAgICAgICAgIGxhenlBcnJheS5zZXREYXRhR2V0dGVyKChjaHVua051bSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBjaHVua051bSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSsxKSAqIGNodW5rU2l6ZSAtIDE7IC8vIGluY2x1ZGluZyB0aGlzIGJ5dGVcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBkYXRhbGVuZ3RoLTEpOyAvLyBpZiBkYXRhbGVuZ3RoLTEgaXMgc2VsZWN0ZWQsIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2tcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID0gZG9YSFIoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdkb1hIUiBmYWlsZWQhJyk7XG4gICAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcbiAgICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICAgIGlmICh1c2VzR3ppcCB8fCAhZGF0YWxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgc2VydmVyIHVzZXMgZ3ppcCBvciBkb2Vzbid0IHN1cHBseSB0aGUgbGVuZ3RoLCB3ZSBoYXZlIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBmaWxlIHRvIGdldCB0aGUgKHVuY29tcHJlc3NlZCkgbGVuZ3RoXG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxOyAvLyB0aGlzIHdpbGwgZm9yY2UgZ2V0dGVyKDApL2RvWEhSIGRvIGRvd25sb2FkIHRoZSB3aG9sZSBmaWxlXG4gICAgICAgICAgICAgIGRhdGFsZW5ndGggPSB0aGlzLmdldHRlcigwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICAgIG91dChcIkxhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGhLbm93biA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0IGNodW5rU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIGNvbnRlbnRzOiBsYXp5QXJyYXkgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCB1cmw6IHVybCB9O1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZUZpbGUocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSB0b3RhbCBoYWNrLCBidXQgSSB3YW50IHRvIGdldCB0aGlzIGxhenkgZmlsZSBjb2RlIG91dCBvZiB0aGVcbiAgICAgICAgLy8gY29yZSBvZiBNRU1GUy4gSWYgd2Ugd2FudCB0byBrZWVwIHRoaXMgbGF6eSBmaWxlIGNvbmNlcHQgSSBmZWVsIGl0IHNob3VsZFxuICAgICAgICAvLyBiZSBpdHMgb3duIHRoaW4gTEFaWUZTIHByb3h5aW5nIGNhbGxzIHRvIE1FTUZTLlxuICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBmdW5jdGlvbiB0aGF0IGRlZmVycyBxdWVyeWluZyB0aGUgZmlsZSBzaXplIHVudGlsIGl0IGlzIGFza2VkIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLCB7XG4gICAgICAgICAgdXNlZEJ5dGVzOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBvdmVycmlkZSBlYWNoIHN0cmVhbSBvcCB3aXRoIG9uZSB0aGF0IHRyaWVzIHRvIGZvcmNlIGxvYWQgdGhlIGxhenkgZmlsZSBmaXJzdFxuICAgICAgICB2YXIgc3RyZWFtX29wcyA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgdmFyIGZuID0gbm9kZS5zdHJlYW1fb3BzW2tleV07XG4gICAgICAgICAgc3RyZWFtX29wc1trZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4oLi4uYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gY29udGVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihjb250ZW50cy5sZW5ndGggLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBhc3NlcnQoc2l6ZSA+PSAwKTtcbiAgICAgICAgICBpZiAoY29udGVudHMuc2xpY2UpIHsgLy8gbm9ybWFsIGFycmF5XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgeyAvLyBMYXp5VWludDhBcnJheSBmcm9tIHN5bmMgYmluYXJ5IFhIUlxuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIGEgY3VzdG9tIHJlYWQgZnVuY3Rpb25cbiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rcyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgYSBjdXN0b20gbW1hcCBmdW5jdGlvblxuICAgICAgICBzdHJlYW1fb3BzLm1tYXAgPSAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgdmFyIHB0ciA9IG1tYXBBbGxvYyhsZW5ndGgpO1xuICAgICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXRlQ2h1bmtzKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHsgcHRyLCBhbGxvY2F0ZWQ6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gc3RyZWFtX29wcztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICBhYnNvbHV0ZVBhdGgoKSB7XG4gICAgICAgIGFib3J0KCdGUy5hYnNvbHV0ZVBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEhfRlMucmVzb2x2ZSBpbnN0ZWFkJyk7XG4gICAgICB9LFxuICBjcmVhdGVGb2xkZXIoKSB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVGb2xkZXIgaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIEZTLm1rZGlyIGluc3RlYWQnKTtcbiAgICAgIH0sXG4gIGNyZWF0ZUxpbmsoKSB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVMaW5rIGhhcyBiZWVuIHJlbW92ZWQ7IHVzZSBGUy5zeW1saW5rIGluc3RlYWQnKTtcbiAgICAgIH0sXG4gIGpvaW5QYXRoKCkge1xuICAgICAgICBhYm9ydCgnRlMuam9pblBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEguam9pbiBpbnN0ZWFkJyk7XG4gICAgICB9LFxuICBtbWFwQWxsb2MoKSB7XG4gICAgICAgIGFib3J0KCdGUy5tbWFwQWxsb2MgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiBtbWFwQWxsb2MnKTtcbiAgICAgIH0sXG4gIHN0YW5kYXJkaXplUGF0aCgpIHtcbiAgICAgICAgYWJvcnQoJ0ZTLnN0YW5kYXJkaXplUGF0aCBoYXMgYmVlbiByZW1vdmVkOyB1c2UgUEFUSC5ub3JtYWxpemUgaW5zdGVhZCcpO1xuICAgICAgfSxcbiAgfTtcbiAgXG4gIHZhciBTWVNDQUxMUyA9IHtcbiAgREVGQVVMVF9QT0xMTUFTSzo1LFxuICBjYWxjdWxhdGVBdChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSkge1xuICAgICAgICBpZiAoUEFUSC5pc0FicyhwYXRoKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbGF0aXZlIHBhdGhcbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChkaXJmZCk7XG4gICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBVEguam9pbjIoZGlyLCBwYXRoKTtcbiAgICAgIH0sXG4gIGRvU3RhdChmdW5jLCBwYXRoLCBidWYpIHtcbiAgICAgICAgdmFyIHN0YXQgPSBmdW5jKHBhdGgpO1xuICAgICAgICBIRUFQMzJbKChidWYpPj4yKV0gPSBzdGF0LmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDQpKT4+MildID0gc3RhdC5tb2RlO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDgpKT4+MildID0gc3RhdC5ubGluaztcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDEyKSk+PjIpXSA9IHN0YXQudWlkO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMTYpKT4+MildID0gc3RhdC5naWQ7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyMCkpPj4yKV0gPSBzdGF0LnJkZXY7XG4gICAgICAgICh0ZW1wSTY0ID0gW3N0YXQuc2l6ZT4+PjAsKHRlbXBEb3VibGUgPSBzdGF0LnNpemUsKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSwgSEVBUDMyWygoKGJ1ZikrKDI0KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDI4KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMzIpKT4+MildID0gNDA5NjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDM2KSk+PjIpXSA9IHN0YXQuYmxvY2tzO1xuICAgICAgICB2YXIgYXRpbWUgPSBzdGF0LmF0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIG10aW1lID0gc3RhdC5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xuICAgICAgICAodGVtcEk2NCA9IFtNYXRoLmZsb29yKGF0aW1lIC8gMTAwMCk+Pj4wLCh0ZW1wRG91YmxlID0gTWF0aC5mbG9vcihhdGltZSAvIDEwMDApLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sIEhFQVAzMlsoKChidWYpKyg0MCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKyg0NCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoKChidWYpKyg0OCkpPj4yKV0gPSAoYXRpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW01hdGguZmxvb3IobXRpbWUgLyAxMDAwKT4+PjAsKHRlbXBEb3VibGUgPSBNYXRoLmZsb29yKG10aW1lIC8gMTAwMCksKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSwgSEVBUDMyWygoKGJ1ZikrKDU2KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDYwKSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDY0KSk+PjIpXSA9IChtdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbTWF0aC5mbG9vcihjdGltZSAvIDEwMDApPj4+MCwodGVtcERvdWJsZSA9IE1hdGguZmxvb3IoY3RpbWUgLyAxMDAwKSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLCBIRUFQMzJbKCgoYnVmKSsoNzIpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoNzYpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKCgoYnVmKSsoODApKT4+MildID0gKGN0aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtzdGF0Lmlubz4+PjAsKHRlbXBEb3VibGUgPSBzdGF0LmlubywoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLCBIRUFQMzJbKCgoYnVmKSsoODgpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoOTIpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgZG9Nc3luYyhhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MsIG9mZnNldCkge1xuICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgLy8gTUFQX1BSSVZBVEUgY2FsbHMgbmVlZCBub3QgdG8gYmUgc3luY2VkIGJhY2sgdG8gdW5kZXJseWluZyBmc1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBIRUFQVTguc2xpY2UoYWRkciwgYWRkciArIGxlbik7XG4gICAgICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICAgICAgfSxcbiAgZ2V0U3RyZWFtRnJvbUZEKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gIHZhcmFyZ3M6dW5kZWZpbmVkLFxuICBnZXRTdHIocHRyKSB7XG4gICAgICAgIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gIH07XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZHVwKGZkKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIG9sZCA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICByZXR1cm4gRlMuZHVwU3RyZWFtKG9sZCkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX21rZGlyYXQoZGlyZmQsIHBhdGgsIG1vZGUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIC8vIHJlbW92ZSBhIHRyYWlsaW5nIHNsYXNoLCBpZiBvbmUgLSAvYS9iLyBoYXMgYmFzZW5hbWUgb2YgJycsIGJ1dFxuICAgICAgLy8gd2Ugd2FudCB0byBjcmVhdGUgYiBpbiB0aGUgY29udGV4dCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aC0xXSA9PT0gJy8nKSBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGgtMSk7XG4gICAgICBGUy5ta2RpcihwYXRoLCBtb2RlLCAwKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3lzY2FsbEdldFZhcmFyZ0koKSB7XG4gICAgICBhc3NlcnQoU1lTQ0FMTFMudmFyYXJncyAhPSB1bmRlZmluZWQpO1xuICAgICAgLy8gdGhlIGArYCBwcmVwZW5kZWQgaGVyZSBpcyBuZWNlc3NhcnkgdG8gY29udmluY2UgdGhlIEpTQ29tcGlsZXIgdGhhdCB2YXJhcmdzIGlzIGluZGVlZCBhIG51bWJlci5cbiAgICAgIHZhciByZXQgPSBIRUFQMzJbKCgrU1lTQ0FMTFMudmFyYXJncyk+PjIpXTtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9vcGVuYXQoZGlyZmQsIHBhdGgsIGZsYWdzLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgdmFyIG1vZGUgPSB2YXJhcmdzID8gc3lzY2FsbEdldFZhcmFyZ0koKSA6IDA7XG4gICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBwYXRoLCBidWYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgdmFyIF9fYWJvcnRfanMgPSAoKSA9PiB7XG4gICAgICBhYm9ydCgnbmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KCknKTtcbiAgICB9O1xuXG4gIHZhciBub3dJc01vbm90b25pYyA9IDE7XG4gIHZhciBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMgPSAoKSA9PiBub3dJc01vbm90b25pYztcblxuICB2YXIgZ2V0RXhlY3V0YWJsZU5hbWUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgICB9O1xuICBcbiAgdmFyIHN0cmluZ1RvVVRGOCA9IChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIG1heEJ5dGVzVG9Xcml0ZSA9PSAnbnVtYmVyJywgJ3N0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcbiAgICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xuICAgIH07XG4gIHZhciBfX2Vtc2NyaXB0ZW5fZ2V0X3Byb2duYW1lID0gKHN0ciwgbGVuKSA9PiB7XG4gICAgICBzdHJpbmdUb1VURjgoZ2V0RXhlY3V0YWJsZU5hbWUoKSwgc3RyLCBsZW4pO1xuICAgIH07XG5cbiAgdmFyIF9fZW1zY3JpcHRlbl9tZW1jcHlfanMgPSAoZGVzdCwgc3JjLCBudW0pID0+IEhFQVBVOC5jb3B5V2l0aGluKGRlc3QsIHNyYywgc3JjICsgbnVtKTtcblxuICBcbiAgXG4gIC8qKiBAc3VwcHJlc3N7Y2hlY2tUeXBlc30gKi9cbiAgdmFyIHdpdGhCdWlsdGluTWFsbG9jID0gKGZ1bmMpID0+IHtcbiAgICAgIHZhciBwcmV2X21hbGxvYyA9IHR5cGVvZiBfbWFsbG9jICE9ICd1bmRlZmluZWQnID8gX21hbGxvYyA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcmV2X21lbWFsaWduID0gdHlwZW9mIF9tZW1hbGlnbiAhPSAndW5kZWZpbmVkJyA/IF9tZW1hbGlnbiA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcmV2X2ZyZWUgPSB0eXBlb2YgX2ZyZWUgIT0gJ3VuZGVmaW5lZCcgPyBfZnJlZSA6IHVuZGVmaW5lZDtcbiAgICAgIF9tYWxsb2MgPSBfZW1zY3JpcHRlbl9idWlsdGluX21hbGxvYztcbiAgICAgIF9tZW1hbGlnbiA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ247XG4gICAgICBfZnJlZSA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fZnJlZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfbWFsbG9jID0gcHJldl9tYWxsb2M7XG4gICAgICAgIF9tZW1hbGlnbiA9IHByZXZfbWVtYWxpZ247XG4gICAgICAgIF9mcmVlID0gcHJldl9mcmVlO1xuICAgICAgfVxuICAgIH07XG4gIFxuICBcbiAgXG4gIHZhciBzdHJpbmdUb05ld1VURjggPSAoc3RyKSA9PiB7XG4gICAgICB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcbiAgICAgIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuICAgICAgaWYgKHJldCkgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBzaXplKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgXG4gIFxuICB2YXIgX19lbXNjcmlwdGVuX3Nhbml0aXplcl9nZXRfb3B0aW9uID0gKG5hbWUpID0+IHtcbiAgICAgIHJldHVybiB3aXRoQnVpbHRpbk1hbGxvYygoKSA9PiBzdHJpbmdUb05ld1VURjgoTW9kdWxlW1VURjhUb1N0cmluZyhuYW1lKV0gfHwgXCJcIikpO1xuICAgIH07XG5cbiAgdmFyIF9fZW1zY3JpcHRlbl9zYW5pdGl6ZXJfdXNlX2NvbG9ycyA9ICgpID0+IHtcbiAgICAgIHZhciBzZXR0aW5nID0gTW9kdWxlWydwcmludFdpdGhDb2xvcnMnXTtcbiAgICAgIGlmIChzZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWTtcbiAgICB9O1xuXG4gIHZhciBpc0xlYXBZZWFyID0gKHllYXIpID0+IHllYXIlNCA9PT0gMCAmJiAoeWVhciUxMDAgIT09IDAgfHwgeWVhciU0MDAgPT09IDApO1xuICBcbiAgdmFyIE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFID0gWzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV07XG4gIFxuICB2YXIgTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUgPSBbMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtcbiAgdmFyIHlkYXlGcm9tRGF0ZSA9IChkYXRlKSA9PiB7XG4gICAgICB2YXIgbGVhcCA9IGlzTGVhcFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgIHZhciBtb250aERheXNDdW11bGF0aXZlID0gKGxlYXAgPyBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA6IE1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFKTtcbiAgICAgIHZhciB5ZGF5ID0gbW9udGhEYXlzQ3VtdWxhdGl2ZVtkYXRlLmdldE1vbnRoKCldICsgZGF0ZS5nZXREYXRlKCkgLSAxOyAvLyAtMSBzaW5jZSBpdCdzIGRheXMgc2luY2UgSmFuIDFcbiAgXG4gICAgICByZXR1cm4geWRheTtcbiAgICB9O1xuICBcbiAgdmFyIGNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkID0gKGxvLCBoaSkgPT4ge1xuICAgICAgYXNzZXJ0KGxvID09IChsbyA+Pj4gMCkgfHwgbG8gPT0gKGxvfDApKTsgLy8gbG8gc2hvdWxkIGVpdGhlciBiZSBhIGkzMiBvciBhIHUzMlxuICAgICAgYXNzZXJ0KGhpID09PSAoaGl8MCkpOyAgICAgICAgICAgICAgICAgICAgLy8gaGkgc2hvdWxkIGJlIGEgaTMyXG4gICAgICByZXR1cm4gKChoaSArIDB4MjAwMDAwKSA+Pj4gMCA8IDB4NDAwMDAxIC0gISFsbykgPyAobG8gPj4+IDApICsgaGkgKiA0Mjk0OTY3Mjk2IDogTmFOO1xuICAgIH07XG4gIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWVfbG93LCB0aW1lX2hpZ2gsdG1QdHIpIHtcbiAgICB2YXIgdGltZSA9IGNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkKHRpbWVfbG93LCB0aW1lX2hpZ2gpO1xuICBcbiAgICBcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodGltZSoxMDAwKTtcbiAgICAgIEhFQVAzMlsoKHRtUHRyKT4+MildID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg0KSk+PjIpXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0gPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxMikpPj4yKV0gPSBkYXRlLmdldERhdGUoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDE2KSk+PjIpXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDIwKSk+PjIpXSA9IGRhdGUuZ2V0RnVsbFllYXIoKS0xOTAwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjQpKT4+MildID0gZGF0ZS5nZXREYXkoKTtcbiAgXG4gICAgICB2YXIgeWRheSA9IHlkYXlGcm9tRGF0ZShkYXRlKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDM2KSk+PjIpXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApO1xuICBcbiAgICAgIC8vIEF0dGVudGlvbjogRFNUIGlzIGluIERlY2VtYmVyIGluIFNvdXRoLCBhbmQgc29tZSByZWdpb25zIGRvbid0IGhhdmUgRFNUIGF0IGFsbC5cbiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgZHN0ID0gKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSl8MDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDMyKSk+PjIpXSA9IGRzdDtcbiAgICA7XG4gIH1cblxuICBcbiAgXG4gIFxuICBcbiAgXG4gIGZ1bmN0aW9uIF9fbW1hcF9qcyhsZW4scHJvdCxmbGFncyxmZCxvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCxhbGxvY2F0ZWQsYWRkcikge1xuICAgIHZhciBvZmZzZXQgPSBjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCk7XG4gIFxuICAgIFxuICB0cnkge1xuICBcbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHZhciByZXMgPSBGUy5tbWFwKHN0cmVhbSwgbGVuLCBvZmZzZXQsIHByb3QsIGZsYWdzKTtcbiAgICAgIHZhciBwdHIgPSByZXMucHRyO1xuICAgICAgSEVBUDMyWygoYWxsb2NhdGVkKT4+MildID0gcmVzLmFsbG9jYXRlZDtcbiAgICAgIEhFQVBVMzJbKChhZGRyKT4+MildID0gcHRyO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIDtcbiAgfVxuXG4gIFxuICBmdW5jdGlvbiBfX211bm1hcF9qcyhhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZnNldF9sb3csIG9mZnNldF9oaWdoKSB7XG4gICAgdmFyIG9mZnNldCA9IGNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkKG9mZnNldF9sb3csIG9mZnNldF9oaWdoKTtcbiAgXG4gICAgXG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBpZiAocHJvdCAmIDIpIHtcbiAgICAgICAgU1lTQ0FMTFMuZG9Nc3luYyhhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIDtcbiAgfVxuXG4gIFxuICB2YXIgX190enNldF9qcyA9ICh0aW1lem9uZSwgZGF5bGlnaHQsIHN0ZF9uYW1lLCBkc3RfbmFtZSkgPT4ge1xuICAgICAgLy8gVE9ETzogVXNlIChtYWxsZWFibGUpIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbnN0ZWFkIG9mIHN5c3RlbSBzZXR0aW5ncy5cbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBcbiAgICAgIC8vIExvY2FsIHN0YW5kYXJkIHRpbWV6b25lIG9mZnNldC4gTG9jYWwgc3RhbmRhcmQgdGltZSBpcyBub3QgYWRqdXN0ZWQgZm9yXG4gICAgICAvLyBkYXlsaWdodCBzYXZpbmdzLiAgVGhpcyBjb2RlIHVzZXMgdGhlIGZhY3QgdGhhdCBnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zXG4gICAgICAvLyBhIGdyZWF0ZXIgdmFsdWUgZHVyaW5nIFN0YW5kYXJkIFRpbWUgdmVyc3VzIERheWxpZ2h0IFNhdmluZyBUaW1lIChEU1QpLlxuICAgICAgLy8gVGh1cyBpdCBkZXRlcm1pbmVzIHRoZSBleHBlY3RlZCBvdXRwdXQgZHVyaW5nIFN0YW5kYXJkIFRpbWUsIGFuZCBpdFxuICAgICAgLy8gY29tcGFyZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBkYXRlIHRoZSBzYW1lIChTdGFuZGFyZCkgb3IgbGVzc1xuICAgICAgLy8gKERTVCkuXG4gICAgICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgLy8gdGltZXpvbmUgaXMgc3BlY2lmaWVkIGFzIHNlY29uZHMgd2VzdCBvZiBVVEMgKFwiVGhlIGV4dGVybmFsIHZhcmlhYmxlXG4gICAgICAvLyBgdGltZXpvbmVgIHNoYWxsIGJlIHNldCB0byB0aGUgZGlmZmVyZW5jZSwgaW4gc2Vjb25kcywgYmV0d2VlblxuICAgICAgLy8gQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUgKFVUQykgYW5kIGxvY2FsIHN0YW5kYXJkIHRpbWUuXCIpLCB0aGUgc2FtZVxuICAgICAgLy8gYXMgcmV0dXJuZWQgYnkgc3RkVGltZXpvbmVPZmZzZXQuXG4gICAgICAvLyBTZWUgaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvdHpzZXQuaHRtbFxuICAgICAgSEVBUFUzMlsoKHRpbWV6b25lKT4+MildID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcbiAgXG4gICAgICBIRUFQMzJbKChkYXlsaWdodCk+PjIpXSA9IE51bWJlcih3aW50ZXJPZmZzZXQgIT0gc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICB2YXIgZXh0cmFjdFpvbmUgPSAodGltZXpvbmVPZmZzZXQpID0+IHtcbiAgICAgICAgLy8gV2h5IGludmVyc2Ugc2lnbj9cbiAgICAgICAgLy8gUmVhZCBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0VGltZXpvbmVPZmZzZXRcbiAgICAgICAgdmFyIHNpZ24gPSB0aW1lem9uZU9mZnNldCA+PSAwID8gXCItXCIgOiBcIitcIjtcbiAgXG4gICAgICAgIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyh0aW1lem9uZU9mZnNldClcbiAgICAgICAgdmFyIGhvdXJzID0gU3RyaW5nKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICAgIHZhciBtaW51dGVzID0gU3RyaW5nKGFic09mZnNldCAlIDYwKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gIFxuICAgICAgICByZXR1cm4gYFVUQyR7c2lnbn0ke2hvdXJzfSR7bWludXRlc31gO1xuICAgICAgfVxuICBcbiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyT2Zmc2V0KTtcbiAgICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyT2Zmc2V0KTtcbiAgICAgIGFzc2VydCh3aW50ZXJOYW1lKTtcbiAgICAgIGFzc2VydChzdW1tZXJOYW1lKTtcbiAgICAgIGFzc2VydChsZW5ndGhCeXRlc1VURjgod2ludGVyTmFtZSkgPD0gMTYsIGB0aW1lem9uZSBuYW1lIHRydW5jYXRlZCB0byBmaXQgaW4gVFpOQU1FX01BWCAoJHt3aW50ZXJOYW1lfSlgKTtcbiAgICAgIGFzc2VydChsZW5ndGhCeXRlc1VURjgoc3VtbWVyTmFtZSkgPD0gMTYsIGB0aW1lem9uZSBuYW1lIHRydW5jYXRlZCB0byBmaXQgaW4gVFpOQU1FX01BWCAoJHtzdW1tZXJOYW1lfSlgKTtcbiAgICAgIGlmIChzdW1tZXJPZmZzZXQgPCB3aW50ZXJPZmZzZXQpIHtcbiAgICAgICAgLy8gTm9ydGhlcm4gaGVtaXNwaGVyZVxuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgc3RkX25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIGRzdF9uYW1lLCAxNyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgZHN0X25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIHN0ZF9uYW1lLCAxNyk7XG4gICAgICB9XG4gICAgfTtcblxuICB2YXIgX2Vtc2NyaXB0ZW5fZGF0ZV9ub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xuXG4gIHZhciBnZXRIZWFwTWF4ID0gKCkgPT5cbiAgICAgIC8vIFN0YXkgb25lIFdhc20gcGFnZSBzaG9ydCBvZiA0R0I6IHdoaWxlIGUuZy4gQ2hyb21lIGlzIGFibGUgdG8gYWxsb2NhdGVcbiAgICAgIC8vIGZ1bGwgNEdCIFdhc20gbWVtb3JpZXMsIHRoZSBzaXplIHdpbGwgd3JhcCBiYWNrIHRvIDAgYnl0ZXMgaW4gV2FzbSBzaWRlXG4gICAgICAvLyBmb3IgYW55IGNvZGUgdGhhdCBkZWFscyB3aXRoIGhlYXAgc2l6ZXMsIHdoaWNoIHdvdWxkIHJlcXVpcmUgc3BlY2lhbFxuICAgICAgLy8gY2FzaW5nIGFsbCBoZWFwIHNpemUgcmVsYXRlZCBjb2RlIHRvIHRyZWF0IDAgc3BlY2lhbGx5LlxuICAgICAgMjE0NzQ4MzY0ODtcbiAgdmFyIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCA9ICgpID0+IGdldEhlYXBNYXgoKTtcblxuICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztcbiAgICAgIC8vIE1vZGVybiBlbnZpcm9ubWVudCB3aGVyZSBwZXJmb3JtYW5jZS5ub3coKSBpcyBzdXBwb3J0ZWQ6XG4gICAgICAvLyBOLkIuIGEgc2hvcnRlciBmb3JtIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vdyA9IHBlcmZvcm1hbmNlLm5vdztcIiBpc1xuICAgICAgLy8gdW5mb3J0dW5hdGVseSBub3QgYWxsb3dlZCBldmVuIGluIGN1cnJlbnQgYnJvd3NlcnMgKGUuZy4gRkYgTmlnaHRseSA3NSkuXG4gICAgICBfZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIDtcblxuICB2YXIgVU5XSU5EX0NBQ0hFID0ge1xuICB9O1xuICBcbiAgLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXG4gIHZhciBjb252ZXJ0RnJhbWVUb1BDID0gKGZyYW1lKSA9PiB7XG4gICAgICBhc3NlcnQod2FzbU9mZnNldENvbnZlcnRlcik7XG4gICAgICB2YXIgbWF0Y2g7XG4gIFxuICAgICAgaWYgKG1hdGNoID0gL1xcYndhc20tZnVuY3Rpb25cXFtcXGQrXFxdOigweFswLTlhLWZdKykvLmV4ZWMoZnJhbWUpKSB7XG4gICAgICAgIC8vIHNvbWUgZW5naW5lcyBnaXZlIHRoZSBiaW5hcnkgb2Zmc2V0IGRpcmVjdGx5LCBzbyB3ZSB1c2UgdGhhdCBhcyByZXR1cm4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gK21hdGNoWzFdO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IC9cXGJ3YXNtLWZ1bmN0aW9uXFxbKFxcZCspXFxdOihcXGQrKS8uZXhlYyhmcmFtZSkpIHtcbiAgICAgICAgLy8gb3RoZXIgZW5naW5lcyBvbmx5IGdpdmUgZnVuY3Rpb24gaW5kZXggYW5kIG9mZnNldCBpbiB0aGUgZnVuY3Rpb24sXG4gICAgICAgIC8vIHNvIHdlIHRyeSB1c2luZyB0aGUgb2Zmc2V0IGNvbnZlcnRlci4gSWYgdGhhdCBkb2Vzbid0IHdvcmssXG4gICAgICAgIC8vIHdlIHBhY2sgaW5kZXggYW5kIG9mZnNldCBpbnRvIGEgXCJyZXR1cm4gYWRkcmVzc1wiXG4gICAgICAgIHJldHVybiB3YXNtT2Zmc2V0Q29udmVydGVyLmNvbnZlcnQoK21hdGNoWzFdLCArbWF0Y2hbMl0pO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IC86KFxcZCspOlxcZCsoPzpcXCl8JCkvLmV4ZWMoZnJhbWUpKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBpbiBqcywgd2UgY2FuIHVzZSB0aGUganMgbGluZSBudW1iZXIgYXMgdGhlIFwicmV0dXJuIGFkZHJlc3NcIi5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgd29yayBmb3Igd2FzbTJqcy4gIFdlIHRhZyB0aGUgaGlnaCBiaXQgdG8gZGlzdGluZ3Vpc2ggdGhpc1xuICAgICAgICAvLyBmcm9tIHdhc20gYWRkcmVzc2VzLlxuICAgICAgICByZXR1cm4gMHg4MDAwMDAwMCB8ICttYXRjaFsxXTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiAwIGlmIHdlIGNhbid0IGZpbmQgYW55XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICB2YXIgY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvbiA9IChwYykgPT4ge1xuICAgICAgaWYgKFVOV0lORF9DQUNIRS5sYXN0X2dldF9zb3VyY2VfcGMgPT0gcGMpIHJldHVybiBVTldJTkRfQ0FDSEUubGFzdF9zb3VyY2U7XG4gIFxuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIHNvdXJjZTtcbiAgICAgIGlmICh3YXNtU291cmNlTWFwKSB7XG4gICAgICAgIHNvdXJjZSA9IHdhc21Tb3VyY2VNYXAubG9va3VwKHBjKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICB2YXIgZnJhbWUgPSBVTldJTkRfQ0FDSEVbcGNdO1xuICAgICAgICBpZiAoIWZyYW1lKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRXhhbXBsZTogYXQgY2FsbE1haW4gKGEub3V0LmpzOjYzMzU6MjIpXG4gICAgICAgIGlmIChtYXRjaCA9IC9cXCgoLiopOihcXGQrKTooXFxkKylcXCkkLy5leGVjKGZyYW1lKSkge1xuICAgICAgICAgIHNvdXJjZSA9IHtmaWxlOiBtYXRjaFsxXSwgbGluZTogbWF0Y2hbMl0sIGNvbHVtbjogbWF0Y2hbM119O1xuICAgICAgICAvLyBFeGFtcGxlOiBtYWluQGEub3V0LmpzOjEzMzc6NDJcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IC9AKC4qKTooXFxkKyk6KFxcZCspLy5leGVjKGZyYW1lKSkge1xuICAgICAgICAgIHNvdXJjZSA9IHtmaWxlOiBtYXRjaFsxXSwgbGluZTogbWF0Y2hbMl0sIGNvbHVtbjogbWF0Y2hbM119O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBVTldJTkRfQ0FDSEUubGFzdF9nZXRfc291cmNlX3BjID0gcGM7XG4gICAgICBVTldJTkRfQ0FDSEUubGFzdF9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG4gIHZhciBfZW1zY3JpcHRlbl9wY19nZXRfY29sdW1uID0gKHBjKSA9PiB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvbihwYyk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0LmNvbHVtbiB8fCAwIDogMDtcbiAgICB9O1xuXG4gIFxuICBcbiAgXG4gIHZhciBfZW1zY3JpcHRlbl9wY19nZXRfZmlsZSA9IChwYykgPT4gd2l0aEJ1aWx0aW5NYWxsb2MoKCkgPT4ge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnZlcnRQQ3RvU291cmNlTG9jYXRpb24ocGMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiAwO1xuICBcbiAgICAgIGlmIChfZW1zY3JpcHRlbl9wY19nZXRfZmlsZS5yZXQpIF9mcmVlKF9lbXNjcmlwdGVuX3BjX2dldF9maWxlLnJldCk7XG4gICAgICBfZW1zY3JpcHRlbl9wY19nZXRfZmlsZS5yZXQgPSBzdHJpbmdUb05ld1VURjgocmVzdWx0LmZpbGUpO1xuICAgICAgcmV0dXJuIF9lbXNjcmlwdGVuX3BjX2dldF9maWxlLnJldDtcbiAgICB9KTtcblxuICBcbiAgXG4gIFxuICB2YXIgX2Vtc2NyaXB0ZW5fcGNfZ2V0X2Z1bmN0aW9uID0gKHBjKSA9PiB3aXRoQnVpbHRpbk1hbGxvYygoKSA9PiB7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIGlmIChwYyAmIDB4ODAwMDAwMDApIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIEphdmFTY3JpcHQgZnVuY3Rpb24sIHRyeSBsb29raW5nIGl0IHVwIGluIHRoZSB1bndpbmQgY2FjaGUuXG4gICAgICAgIHZhciBmcmFtZSA9IFVOV0lORF9DQUNIRVtwY107XG4gICAgICAgIGlmICghZnJhbWUpIHJldHVybiAwO1xuICBcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAobWF0Y2ggPSAvXlxccythdCAoLiopIFxcKC4qXFwpJC8uZXhlYyhmcmFtZSkpIHtcbiAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSAvXiguKz8pQC8uZXhlYyhmcmFtZSkpIHtcbiAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSB3YXNtT2Zmc2V0Q29udmVydGVyLmdldE5hbWUocGMpO1xuICAgICAgfVxuICAgICAgaWYgKF9lbXNjcmlwdGVuX3BjX2dldF9mdW5jdGlvbi5yZXQpIF9mcmVlKF9lbXNjcmlwdGVuX3BjX2dldF9mdW5jdGlvbi5yZXQpO1xuICAgICAgX2Vtc2NyaXB0ZW5fcGNfZ2V0X2Z1bmN0aW9uLnJldCA9IHN0cmluZ1RvTmV3VVRGOChuYW1lKTtcbiAgICAgIHJldHVybiBfZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24ucmV0O1xuICAgIH0pO1xuXG4gIHZhciBfZW1zY3JpcHRlbl9wY19nZXRfbGluZSA9IChwYykgPT4ge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnZlcnRQQ3RvU291cmNlTG9jYXRpb24ocGMpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5saW5lIDogMDtcbiAgICB9O1xuXG4gIFxuICBcbiAgdmFyIGdyb3dNZW1vcnkgPSAoc2l6ZSkgPT4ge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHZhciBwYWdlcyA9IChzaXplIC0gYi5ieXRlTGVuZ3RoICsgNjU1MzUpIC8gNjU1MzY7XG4gICAgICB0cnkge1xuICAgICAgICAvLyByb3VuZCBzaXplIGdyb3cgcmVxdWVzdCB1cCB0byB3YXNtIHBhZ2Ugc2l6ZSAoZml4ZWQgNjRLQiBwZXIgc3BlYylcbiAgICAgICAgd2FzbU1lbW9yeS5ncm93KHBhZ2VzKTsgLy8gLmdyb3coKSB0YWtlcyBhIGRlbHRhIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzaXplXG4gICAgICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gICAgICAgIHJldHVybiAxIC8qc3VjY2VzcyovO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGVycihgZ3Jvd01lbW9yeTogQXR0ZW1wdGVkIHRvIGdyb3cgaGVhcCBmcm9tICR7Yi5ieXRlTGVuZ3RofSBieXRlcyB0byAke3NpemV9IGJ5dGVzLCBidXQgZ290IGVycm9yOiAke2V9YCk7XG4gICAgICB9XG4gICAgICAvLyBpbXBsaWNpdCAwIHJldHVybiB0byBzYXZlIGNvZGUgc2l6ZSAoY2FsbGVyIHdpbGwgY2FzdCBcInVuZGVmaW5lZFwiIGludG8gMFxuICAgICAgLy8gYW55aG93KVxuICAgIH07XG4gIHZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCA9IChyZXF1ZXN0ZWRTaXplKSA9PiB7XG4gICAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gICAgICAvLyBXaXRoIENBTl9BRERSRVNTXzJHQiBvciBNRU1PUlk2NCwgcG9pbnRlcnMgYXJlIGFscmVhZHkgdW5zaWduZWQuXG4gICAgICByZXF1ZXN0ZWRTaXplID4+Pj0gMDtcbiAgICAgIC8vIFdpdGggbXVsdGl0aHJlYWRlZCBidWlsZHMsIHJhY2VzIGNhbiBoYXBwZW4gKGFub3RoZXIgdGhyZWFkIG1pZ2h0IGluY3JlYXNlIHRoZSBzaXplXG4gICAgICAvLyBpbiBiZXR3ZWVuKSwgc28gcmV0dXJuIGEgZmFpbHVyZSwgYW5kIGxldCB0aGUgY2FsbGVyIHJldHJ5LlxuICAgICAgYXNzZXJ0KHJlcXVlc3RlZFNpemUgPiBvbGRTaXplKTtcbiAgXG4gICAgICAvLyBNZW1vcnkgcmVzaXplIHJ1bGVzOlxuICAgICAgLy8gMS4gIEFsd2F5cyBpbmNyZWFzZSBoZWFwIHNpemUgdG8gYXQgbGVhc3QgdGhlIHJlcXVlc3RlZCBzaXplLCByb3VuZGVkIHVwXG4gICAgICAvLyAgICAgdG8gbmV4dCBwYWdlIG11bHRpcGxlLlxuICAgICAgLy8gMmEuIElmIE1FTU9SWV9HUk9XVEhfTElORUFSX1NURVAgPT0gLTEsIGV4Y2Vzc2l2ZWx5IHJlc2l6ZSB0aGUgaGVhcFxuICAgICAgLy8gICAgIGdlb21ldHJpY2FsbHk6IGluY3JlYXNlIHRoZSBoZWFwIHNpemUgYWNjb3JkaW5nIHRvXG4gICAgICAvLyAgICAgTUVNT1JZX0dST1dUSF9HRU9NRVRSSUNfU1RFUCBmYWN0b3IgKGRlZmF1bHQgKzIwJSksIEF0IG1vc3RcbiAgICAgIC8vICAgICBvdmVycmVzZXJ2ZSBieSBNRU1PUllfR1JPV1RIX0dFT01FVFJJQ19DQVAgYnl0ZXMgKGRlZmF1bHQgOTZNQikuXG4gICAgICAvLyAyYi4gSWYgTUVNT1JZX0dST1dUSF9MSU5FQVJfU1RFUCAhPSAtMSwgZXhjZXNzaXZlbHkgcmVzaXplIHRoZSBoZWFwXG4gICAgICAvLyAgICAgbGluZWFybHk6IGluY3JlYXNlIHRoZSBoZWFwIHNpemUgYnkgYXQgbGVhc3RcbiAgICAgIC8vICAgICBNRU1PUllfR1JPV1RIX0xJTkVBUl9TVEVQIGJ5dGVzLlxuICAgICAgLy8gMy4gIE1heCBzaXplIGZvciB0aGUgaGVhcCBpcyBjYXBwZWQgYXQgMjA0OE1CLVdBU01fUEFHRV9TSVpFLCBvciBieVxuICAgICAgLy8gICAgIE1BWElNVU1fTUVNT1JZLCBvciBieSBBU0FOIGxpbWl0LCBkZXBlbmRpbmcgb24gd2hpY2ggaXMgc21hbGxlc3RcbiAgICAgIC8vIDQuICBJZiB3ZSB3ZXJlIHVuYWJsZSB0byBhbGxvY2F0ZSBhcyBtdWNoIG1lbW9yeSwgaXQgbWF5IGJlIGR1ZSB0b1xuICAgICAgLy8gICAgIG92ZXItZWFnZXIgZGVjaXNpb24gdG8gZXhjZXNzaXZlbHkgcmVzZXJ2ZSBkdWUgdG8gKDMpIGFib3ZlLlxuICAgICAgLy8gICAgIEhlbmNlIGlmIGFuIGFsbG9jYXRpb24gZmFpbHMsIGN1dCBkb3duIG9uIHRoZSBhbW91bnQgb2YgZXhjZXNzXG4gICAgICAvLyAgICAgZ3Jvd3RoLCBpbiBhbiBhdHRlbXB0IHRvIHN1Y2NlZWQgdG8gcGVyZm9ybSBhIHNtYWxsZXIgYWxsb2NhdGlvbi5cbiAgXG4gICAgICAvLyBBIGxpbWl0IGlzIHNldCBmb3IgaG93IG11Y2ggd2UgY2FuIGdyb3cuIFdlIHNob3VsZCBub3QgZXhjZWVkIHRoYXRcbiAgICAgIC8vICh0aGUgd2FzbSBiaW5hcnkgc3BlY2lmaWVzIGl0LCBzbyBpZiB3ZSB0cmllZCwgd2UnZCBmYWlsIGFueWhvdykuXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIGVycihgQ2Fubm90IGVubGFyZ2UgbWVtb3J5LCByZXF1ZXN0ZWQgJHtyZXF1ZXN0ZWRTaXplfSBieXRlcywgYnV0IHRoZSBsaW1pdCBpcyAke21heEhlYXBTaXplfSBieXRlcyFgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICBcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwb3RlbnRpYWwgaGVhcCBzaXplIGluY3JlYXNlcy4gSWYgd2UgYXR0ZW1wdCBhIHRvbyBlYWdlclxuICAgICAgLy8gcmVzZXJ2YXRpb24gdGhhdCBmYWlscywgY3V0IGRvd24gb24gdGhlIGF0dGVtcHRlZCBzaXplIGFuZCByZXNlcnZlIGFcbiAgICAgIC8vIHNtYWxsZXIgYnVtcCBpbnN0ZWFkLiAobWF4IDMgdGltZXMsIGNob3NlbiBzb21ld2hhdCBhcmJpdHJhcmlseSlcbiAgICAgIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICAgICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTsgLy8gZW5zdXJlIGdlb21ldHJpYyBncm93dGhcbiAgICAgICAgLy8gYnV0IGxpbWl0IG92ZXJyZXNlcnZpbmcgKGRlZmF1bHQgdG8gY2FwcGluZyBhdCArOTZNQiBvdmVyZ3Jvd3RoIGF0IG1vc3QpXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUsIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYgKTtcbiAgXG4gICAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4obWF4SGVhcFNpemUsIGFsaWduTWVtb3J5KE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpKTtcbiAgXG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IGdyb3dNZW1vcnkobmV3U2l6ZSk7XG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyKGBGYWlsZWQgdG8gZ3JvdyB0aGUgaGVhcCBmcm9tICR7b2xkU2l6ZX0gYnl0ZXMgdG8gJHtuZXdTaXplfSBieXRlcywgbm90IGVub3VnaCBtZW1vcnkhYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICBcbiAgXG4gIFxuICB2YXIgc2F2ZUluVW53aW5kQ2FjaGUgPSAoY2FsbHN0YWNrKSA9PiB7XG4gICAgICBjYWxsc3RhY2suZm9yRWFjaCgoZnJhbWUpID0+IHtcbiAgICAgICAgdmFyIHBjID0gY29udmVydEZyYW1lVG9QQyhmcmFtZSk7XG4gICAgICAgIGlmIChwYykge1xuICAgICAgICAgIFVOV0lORF9DQUNIRVtwY10gPSBmcmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgXG4gIGZ1bmN0aW9uIGpzU3RhY2tUcmFjZSgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoKS5zdGFjay50b1N0cmluZygpO1xuICAgIH1cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc3RhY2tfc25hcHNob3QoKSB7XG4gICAgICB2YXIgY2FsbHN0YWNrID0ganNTdGFja1RyYWNlKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgaWYgKGNhbGxzdGFja1swXSA9PSAnRXJyb3InKSB7XG4gICAgICAgIGNhbGxzdGFjay5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgc2F2ZUluVW53aW5kQ2FjaGUoY2FsbHN0YWNrKTtcbiAgXG4gICAgICAvLyBDYWNoZXMgdGhlIHN0YWNrIHNuYXBzaG90IHNvIHRoYXQgZW1zY3JpcHRlbl9zdGFja191bndpbmRfYnVmZmVyKCkgY2FuXG4gICAgICAvLyB1bndpbmQgZnJvbSB0aGlzIHNwb3QuXG4gICAgICBVTldJTkRfQ0FDSEUubGFzdF9hZGRyID0gY29udmVydEZyYW1lVG9QQyhjYWxsc3RhY2tbM10pO1xuICAgICAgVU5XSU5EX0NBQ0hFLmxhc3Rfc3RhY2sgPSBjYWxsc3RhY2s7XG4gICAgICByZXR1cm4gVU5XSU5EX0NBQ0hFLmxhc3RfYWRkcjtcbiAgICB9XG5cbiAgXG4gIFxuICBcbiAgdmFyIF9lbXNjcmlwdGVuX3N0YWNrX3Vud2luZF9idWZmZXIgPSAoYWRkciwgYnVmZmVyLCBjb3VudCkgPT4ge1xuICAgICAgdmFyIHN0YWNrO1xuICAgICAgaWYgKFVOV0lORF9DQUNIRS5sYXN0X2FkZHIgPT0gYWRkcikge1xuICAgICAgICBzdGFjayA9IFVOV0lORF9DQUNIRS5sYXN0X3N0YWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sgPSBqc1N0YWNrVHJhY2UoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGlmIChzdGFja1swXSA9PSAnRXJyb3InKSB7XG4gICAgICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzYXZlSW5VbndpbmRDYWNoZShzdGFjayk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIG9mZnNldCA9IDM7XG4gICAgICB3aGlsZSAoc3RhY2tbb2Zmc2V0XSAmJiBjb252ZXJ0RnJhbWVUb1BDKHN0YWNrW29mZnNldF0pICE9IGFkZHIpIHtcbiAgICAgICAgKytvZmZzZXQ7XG4gICAgICB9XG4gIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAmJiBzdGFja1tpK29mZnNldF07ICsraSkge1xuICAgICAgICBIRUFQMzJbKCgoYnVmZmVyKSsoaSo0KSk+PjIpXSA9IGNvbnZlcnRGcmFtZVRvUEMoc3RhY2tbaSArIG9mZnNldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0ICovXG4gIHZhciBkb1JlYWR2ID0gKHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkgPT4ge1xuICAgICAgdmFyIHJldCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgIHZhciBwdHIgPSBIRUFQVTMyWygoaW92KT4+MildO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoKChpb3YpKyg0KSk+PjIpXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMucmVhZChzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7IC8vIG5vdGhpbmcgbW9yZSB0byByZWFkXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGN1cnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgXG4gIGZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIG51bSA9IGRvUmVhZHYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICBIRUFQVTMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgZnVuY3Rpb24gX2ZkX3NlZWsoZmQsb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCkge1xuICAgIHZhciBvZmZzZXQgPSBjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCk7XG4gIFxuICAgIFxuICB0cnkge1xuICBcbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIEZTLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICh0ZW1wSTY0ID0gW3N0cmVhbS5wb3NpdGlvbj4+PjAsKHRlbXBEb3VibGUgPSBzdHJlYW0ucG9zaXRpb24sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSwgSEVBUDMyWygobmV3T2Zmc2V0KT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgobmV3T2Zmc2V0KSsoNCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMCkgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgLy8gcmVzZXQgcmVhZGRpciBzdGF0ZVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0ICovXG4gIHZhciBkb1dyaXRldiA9IChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpID0+IHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMlsoKGlvdik+PjIpXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKCgoaW92KSsoNCkpPj4yKV07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmIChjdXJyIDwgbGVuKSB7XG4gICAgICAgICAgLy8gTm8gbW9yZSBzcGFjZSB0byB3cml0ZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIFxuICBmdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgbnVtID0gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICBIRUFQVTMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgdmFyIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID0gMDtcbiAgdmFyIGtlZXBSdW50aW1lQWxpdmUgPSAoKSA9PiBub0V4aXRSdW50aW1lIHx8IHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID4gMDtcbiAgdmFyIF9wcm9jX2V4aXQgPSAoY29kZSkgPT4ge1xuICAgICAgRVhJVFNUQVRVUyA9IGNvZGU7XG4gICAgICBpZiAoIWtlZXBSdW50aW1lQWxpdmUoKSkge1xuICAgICAgICBNb2R1bGVbJ29uRXhpdCddPy4oY29kZSk7XG4gICAgICAgIEFCT1JUID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHF1aXRfKGNvZGUsIG5ldyBFeGl0U3RhdHVzKGNvZGUpKTtcbiAgICB9O1xuXG4gIHZhciBnZXRDRnVuYyA9IChpZGVudCkgPT4ge1xuICAgICAgdmFyIGZ1bmMgPSBNb2R1bGVbJ18nICsgaWRlbnRdOyAvLyBjbG9zdXJlIGV4cG9ydGVkIGZ1bmN0aW9uXG4gICAgICBhc3NlcnQoZnVuYywgJ0Nhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gJyArIGlkZW50ICsgJywgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkJyk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuICBcbiAgXG4gIHZhciB3cml0ZUFycmF5VG9NZW1vcnkgPSAoYXJyYXksIGJ1ZmZlcikgPT4ge1xuICAgICAgYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCAnd3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KScpXG4gICAgICBIRUFQOC5zZXQoYXJyYXksIGJ1ZmZlcik7XG4gICAgfTtcbiAgXG4gIFxuICBcbiAgdmFyIHN0YWNrQWxsb2MgPSAoc3opID0+IF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyhzeik7XG4gIHZhciBzdHJpbmdUb1VURjhPblN0YWNrID0gKHN0cikgPT4ge1xuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gICAgICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcbiAgICAgIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgc2l6ZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsPX0gcmV0dXJuVHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBhcmdUeXBlc1xuICAgICAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5PX0gYXJnc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0c1xuICAgICAqL1xuICB2YXIgY2NhbGwgPSAoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmdzLCBvcHRzKSA9PiB7XG4gICAgICAvLyBGb3IgZmFzdCBsb29rdXAgb2YgY29udmVyc2lvbiBmdW5jdGlvbnNcbiAgICAgIHZhciB0b0MgPSB7XG4gICAgICAgICdzdHJpbmcnOiAoc3RyKSA9PiB7XG4gICAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHsgLy8gbnVsbCBzdHJpbmdcbiAgICAgICAgICAgIC8vIGF0IG1vc3QgNCBieXRlcyBwZXIgVVRGLTggY29kZSBwb2ludCwgKzEgZm9yIHRoZSB0cmFpbGluZyAnXFwwJ1xuICAgICAgICAgICAgcmV0ID0gc3RyaW5nVG9VVEY4T25TdGFjayhzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnYXJyYXknOiAoYXJyKSA9PiB7XG4gICAgICAgICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XG4gICAgICAgICAgd3JpdGVBcnJheVRvTWVtb3J5KGFyciwgcmV0KTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9O1xuICBcbiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpIHtcbiAgICAgICAgaWYgKHJldHVyblR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIFVURjhUb1N0cmluZyhyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXR1cm5UeXBlID09PSAnYm9vbGVhbicpIHJldHVybiBCb29sZWFuKHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XG4gICAgICB2YXIgY0FyZ3MgPSBbXTtcbiAgICAgIHZhciBzdGFjayA9IDA7XG4gICAgICBhc3NlcnQocmV0dXJuVHlwZSAhPT0gJ2FycmF5JywgJ1JldHVybiB0eXBlIHNob3VsZCBub3QgYmUgXCJhcnJheVwiLicpO1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XG4gICAgICAgICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICAgICAgaWYgKHN0YWNrID09PSAwKSBzdGFjayA9IHN0YWNrU2F2ZSgpO1xuICAgICAgICAgICAgY0FyZ3NbaV0gPSBjb252ZXJ0ZXIoYXJnc1tpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNBcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZXQgPSBmdW5jKC4uLmNBcmdzKTtcbiAgICAgIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcbiAgICAgICAgaWYgKHN0YWNrICE9PSAwKSBzdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgICAgICByZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0ID0gb25Eb25lKHJldCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcmV0dXJuVHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBhcmdUeXBlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0c1xuICAgICAqL1xuICB2YXIgY3dyYXAgPSAoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJncywgb3B0cyk7XG4gICAgfTtcblxuXG5cblxuICBGUy5jcmVhdGVQcmVsb2FkZWRGaWxlID0gRlNfY3JlYXRlUHJlbG9hZGVkRmlsZTtcbiAgRlMuc3RhdGljSW5pdCgpO1xuICAvLyBTZXQgbW9kdWxlIG1ldGhvZHMgYmFzZWQgb24gRVhQT1JURURfUlVOVElNRV9NRVRIT0RTXG4gIDtcbmZ1bmN0aW9uIGNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKSB7XG4gIGlnbm9yZWRNb2R1bGVQcm9wKCdmZXRjaFNldHRpbmdzJyk7XG59XG52YXIgd2FzbUltcG9ydHMgPSB7XG4gIC8qKiBAZXhwb3J0ICovXG4gIF9fYXNzZXJ0X2ZhaWw6IF9fX2Fzc2VydF9mYWlsLFxuICAvKiogQGV4cG9ydCAqL1xuICBfX3N5c2NhbGxfZHVwOiBfX19zeXNjYWxsX2R1cCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX19zeXNjYWxsX21rZGlyYXQ6IF9fX3N5c2NhbGxfbWtkaXJhdCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX19zeXNjYWxsX29wZW5hdDogX19fc3lzY2FsbF9vcGVuYXQsXG4gIC8qKiBAZXhwb3J0ICovXG4gIF9fc3lzY2FsbF9zdGF0NjQ6IF9fX3N5c2NhbGxfc3RhdDY0LFxuICAvKiogQGV4cG9ydCAqL1xuICBfYWJvcnRfanM6IF9fYWJvcnRfanMsXG4gIC8qKiBAZXhwb3J0ICovXG4gIF9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljOiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXG4gIC8qKiBAZXhwb3J0ICovXG4gIF9lbXNjcmlwdGVuX2dldF9wcm9nbmFtZTogX19lbXNjcmlwdGVuX2dldF9wcm9nbmFtZSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzOiBfX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzLFxuICAvKiogQGV4cG9ydCAqL1xuICBfZW1zY3JpcHRlbl9zYW5pdGl6ZXJfZ2V0X29wdGlvbjogX19lbXNjcmlwdGVuX3Nhbml0aXplcl9nZXRfb3B0aW9uLFxuICAvKiogQGV4cG9ydCAqL1xuICBfZW1zY3JpcHRlbl9zYW5pdGl6ZXJfdXNlX2NvbG9yczogX19lbXNjcmlwdGVuX3Nhbml0aXplcl91c2VfY29sb3JzLFxuICAvKiogQGV4cG9ydCAqL1xuICBfbG9jYWx0aW1lX2pzOiBfX2xvY2FsdGltZV9qcyxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX21tYXBfanM6IF9fbW1hcF9qcyxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX211bm1hcF9qczogX19tdW5tYXBfanMsXG4gIC8qKiBAZXhwb3J0ICovXG4gIF90enNldF9qczogX190enNldF9qcyxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gIC8qKiBAZXhwb3J0ICovXG4gIGVtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4OiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gIC8qKiBAZXhwb3J0ICovXG4gIGVtc2NyaXB0ZW5fZ2V0X25vdzogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZW1zY3JpcHRlbl9wY19nZXRfY29sdW1uOiBfZW1zY3JpcHRlbl9wY19nZXRfY29sdW1uLFxuICAvKiogQGV4cG9ydCAqL1xuICBlbXNjcmlwdGVuX3BjX2dldF9maWxlOiBfZW1zY3JpcHRlbl9wY19nZXRfZmlsZSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb246IF9lbXNjcmlwdGVuX3BjX2dldF9mdW5jdGlvbixcbiAgLyoqIEBleHBvcnQgKi9cbiAgZW1zY3JpcHRlbl9wY19nZXRfbGluZTogX2Vtc2NyaXB0ZW5fcGNfZ2V0X2xpbmUsXG4gIC8qKiBAZXhwb3J0ICovXG4gIGVtc2NyaXB0ZW5fcmVzaXplX2hlYXA6IF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFxuICAvKiogQGV4cG9ydCAqL1xuICBlbXNjcmlwdGVuX3N0YWNrX3NuYXBzaG90OiBfZW1zY3JpcHRlbl9zdGFja19zbmFwc2hvdCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZW1zY3JpcHRlbl9zdGFja191bndpbmRfYnVmZmVyOiBfZW1zY3JpcHRlbl9zdGFja191bndpbmRfYnVmZmVyLFxuICAvKiogQGV4cG9ydCAqL1xuICBmZF9jbG9zZTogX2ZkX2Nsb3NlLFxuICAvKiogQGV4cG9ydCAqL1xuICBmZF9yZWFkOiBfZmRfcmVhZCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZmRfc2VlazogX2ZkX3NlZWssXG4gIC8qKiBAZXhwb3J0ICovXG4gIGZkX3dyaXRlOiBfZmRfd3JpdGUsXG4gIC8qKiBAZXhwb3J0ICovXG4gIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgcHJvY19leGl0OiBfcHJvY19leGl0LFxuICAvKiogQGV4cG9ydCAqL1xuICBxdHNfaG9zdF9jYWxsX2Z1bmN0aW9uLFxuICAvKiogQGV4cG9ydCAqL1xuICBxdHNfaG9zdF9pbnRlcnJ1cHRfaGFuZGxlcixcbiAgLyoqIEBleHBvcnQgKi9cbiAgcXRzX2hvc3RfbG9hZF9tb2R1bGVfc291cmNlLFxuICAvKiogQGV4cG9ydCAqL1xuICBxdHNfaG9zdF9ub3JtYWxpemVfbW9kdWxlXG59O1xudmFyIHdhc21FeHBvcnRzID0gY3JlYXRlV2FzbSgpO1xudmFyIF9fX3dhc21fY2FsbF9jdG9ycyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ19fd2FzbV9jYWxsX2N0b3JzJywgMCk7XG52YXIgX21hbGxvYyA9IE1vZHVsZVsnX21hbGxvYyddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignbWFsbG9jJywgMSk7XG52YXIgX1FUU19UaHJvdyA9IE1vZHVsZVsnX1FUU19UaHJvdyddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1Rocm93JywgMik7XG52YXIgX1FUU19OZXdFcnJvciA9IE1vZHVsZVsnX1FUU19OZXdFcnJvciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0Vycm9yJywgMSk7XG52YXIgX1FUU19SdW50aW1lU2V0TWVtb3J5TGltaXQgPSBNb2R1bGVbJ19RVFNfUnVudGltZVNldE1lbW9yeUxpbWl0J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUnVudGltZVNldE1lbW9yeUxpbWl0JywgMik7XG52YXIgX1FUU19SdW50aW1lQ29tcHV0ZU1lbW9yeVVzYWdlID0gTW9kdWxlWydfUVRTX1J1bnRpbWVDb21wdXRlTWVtb3J5VXNhZ2UnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lQ29tcHV0ZU1lbW9yeVVzYWdlJywgMik7XG52YXIgX1FUU19SdW50aW1lRHVtcE1lbW9yeVVzYWdlID0gTW9kdWxlWydfUVRTX1J1bnRpbWVEdW1wTWVtb3J5VXNhZ2UnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lRHVtcE1lbW9yeVVzYWdlJywgMSk7XG52YXIgX1FUU19SZWNvdmVyYWJsZUxlYWtDaGVjayA9IE1vZHVsZVsnX1FUU19SZWNvdmVyYWJsZUxlYWtDaGVjayddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1JlY292ZXJhYmxlTGVha0NoZWNrJywgMCk7XG52YXIgX1FUU19CdWlsZElzU2FuaXRpemVMZWFrID0gTW9kdWxlWydfUVRTX0J1aWxkSXNTYW5pdGl6ZUxlYWsnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19CdWlsZElzU2FuaXRpemVMZWFrJywgMCk7XG52YXIgX1FUU19SdW50aW1lU2V0TWF4U3RhY2tTaXplID0gTW9kdWxlWydfUVRTX1J1bnRpbWVTZXRNYXhTdGFja1NpemUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lU2V0TWF4U3RhY2tTaXplJywgMik7XG52YXIgX1FUU19HZXRVbmRlZmluZWQgPSBNb2R1bGVbJ19RVFNfR2V0VW5kZWZpbmVkJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0VW5kZWZpbmVkJywgMCk7XG52YXIgX1FUU19HZXROdWxsID0gTW9kdWxlWydfUVRTX0dldE51bGwnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXROdWxsJywgMCk7XG52YXIgX1FUU19HZXRGYWxzZSA9IE1vZHVsZVsnX1FUU19HZXRGYWxzZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldEZhbHNlJywgMCk7XG52YXIgX1FUU19HZXRUcnVlID0gTW9kdWxlWydfUVRTX0dldFRydWUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRUcnVlJywgMCk7XG52YXIgX1FUU19OZXdSdW50aW1lID0gTW9kdWxlWydfUVRTX05ld1J1bnRpbWUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdSdW50aW1lJywgMCk7XG52YXIgX1FUU19GcmVlUnVudGltZSA9IE1vZHVsZVsnX1FUU19GcmVlUnVudGltZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0ZyZWVSdW50aW1lJywgMSk7XG52YXIgX2ZyZWUgPSBNb2R1bGVbJ19mcmVlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdmcmVlJywgMSk7XG52YXIgX1FUU19OZXdDb250ZXh0ID0gTW9kdWxlWydfUVRTX05ld0NvbnRleHQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdDb250ZXh0JywgMik7XG52YXIgX1FUU19GcmVlQ29udGV4dCA9IE1vZHVsZVsnX1FUU19GcmVlQ29udGV4dCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0ZyZWVDb250ZXh0JywgMSk7XG52YXIgX1FUU19GcmVlVmFsdWVQb2ludGVyID0gTW9kdWxlWydfUVRTX0ZyZWVWYWx1ZVBvaW50ZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19GcmVlVmFsdWVQb2ludGVyJywgMik7XG52YXIgX1FUU19GcmVlVmFsdWVQb2ludGVyUnVudGltZSA9IE1vZHVsZVsnX1FUU19GcmVlVmFsdWVQb2ludGVyUnVudGltZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0ZyZWVWYWx1ZVBvaW50ZXJSdW50aW1lJywgMik7XG52YXIgX1FUU19GcmVlVm9pZFBvaW50ZXIgPSBNb2R1bGVbJ19RVFNfRnJlZVZvaWRQb2ludGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRnJlZVZvaWRQb2ludGVyJywgMik7XG52YXIgX1FUU19GcmVlQ1N0cmluZyA9IE1vZHVsZVsnX1FUU19GcmVlQ1N0cmluZyddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0ZyZWVDU3RyaW5nJywgMik7XG52YXIgX1FUU19EdXBWYWx1ZVBvaW50ZXIgPSBNb2R1bGVbJ19RVFNfRHVwVmFsdWVQb2ludGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRHVwVmFsdWVQb2ludGVyJywgMik7XG52YXIgX1FUU19OZXdPYmplY3QgPSBNb2R1bGVbJ19RVFNfTmV3T2JqZWN0J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3T2JqZWN0JywgMSk7XG52YXIgX1FUU19OZXdPYmplY3RQcm90byA9IE1vZHVsZVsnX1FUU19OZXdPYmplY3RQcm90byddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld09iamVjdFByb3RvJywgMik7XG52YXIgX1FUU19OZXdBcnJheSA9IE1vZHVsZVsnX1FUU19OZXdBcnJheSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0FycmF5JywgMSk7XG52YXIgX1FUU19OZXdBcnJheUJ1ZmZlciA9IE1vZHVsZVsnX1FUU19OZXdBcnJheUJ1ZmZlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0FycmF5QnVmZmVyJywgMyk7XG52YXIgX1FUU19OZXdGbG9hdDY0ID0gTW9kdWxlWydfUVRTX05ld0Zsb2F0NjQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdGbG9hdDY0JywgMik7XG52YXIgX1FUU19HZXRGbG9hdDY0ID0gTW9kdWxlWydfUVRTX0dldEZsb2F0NjQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRGbG9hdDY0JywgMik7XG52YXIgX1FUU19OZXdTdHJpbmcgPSBNb2R1bGVbJ19RVFNfTmV3U3RyaW5nJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3U3RyaW5nJywgMik7XG52YXIgX1FUU19HZXRTdHJpbmcgPSBNb2R1bGVbJ19RVFNfR2V0U3RyaW5nJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0U3RyaW5nJywgMik7XG52YXIgX1FUU19HZXRBcnJheUJ1ZmZlciA9IE1vZHVsZVsnX1FUU19HZXRBcnJheUJ1ZmZlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldEFycmF5QnVmZmVyJywgMik7XG52YXIgX1FUU19HZXRBcnJheUJ1ZmZlckxlbmd0aCA9IE1vZHVsZVsnX1FUU19HZXRBcnJheUJ1ZmZlckxlbmd0aCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldEFycmF5QnVmZmVyTGVuZ3RoJywgMik7XG52YXIgX1FUU19OZXdTeW1ib2wgPSBNb2R1bGVbJ19RVFNfTmV3U3ltYm9sJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3U3ltYm9sJywgMyk7XG52YXIgX1FUU19HZXRTeW1ib2xEZXNjcmlwdGlvbk9yS2V5ID0gTW9kdWxlWydfUVRTX0dldFN5bWJvbERlc2NyaXB0aW9uT3JLZXknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRTeW1ib2xEZXNjcmlwdGlvbk9yS2V5JywgMik7XG52YXIgX1FUU19Jc0dsb2JhbFN5bWJvbCA9IE1vZHVsZVsnX1FUU19Jc0dsb2JhbFN5bWJvbCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0lzR2xvYmFsU3ltYm9sJywgMik7XG52YXIgX1FUU19Jc0pvYlBlbmRpbmcgPSBNb2R1bGVbJ19RVFNfSXNKb2JQZW5kaW5nJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfSXNKb2JQZW5kaW5nJywgMSk7XG52YXIgX1FUU19FeGVjdXRlUGVuZGluZ0pvYiA9IE1vZHVsZVsnX1FUU19FeGVjdXRlUGVuZGluZ0pvYiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0V4ZWN1dGVQZW5kaW5nSm9iJywgMyk7XG52YXIgX1FUU19HZXRQcm9wID0gTW9kdWxlWydfUVRTX0dldFByb3AnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRQcm9wJywgMyk7XG52YXIgX1FUU19HZXRQcm9wTnVtYmVyID0gTW9kdWxlWydfUVRTX0dldFByb3BOdW1iZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRQcm9wTnVtYmVyJywgMyk7XG52YXIgX1FUU19TZXRQcm9wID0gTW9kdWxlWydfUVRTX1NldFByb3AnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19TZXRQcm9wJywgNCk7XG52YXIgX1FUU19EZWZpbmVQcm9wID0gTW9kdWxlWydfUVRTX0RlZmluZVByb3AnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19EZWZpbmVQcm9wJywgOSk7XG52YXIgX1FUU19HZXRPd25Qcm9wZXJ0eU5hbWVzID0gTW9kdWxlWydfUVRTX0dldE93blByb3BlcnR5TmFtZXMnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRPd25Qcm9wZXJ0eU5hbWVzJywgNSk7XG52YXIgX1FUU19DYWxsID0gTW9kdWxlWydfUVRTX0NhbGwnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19DYWxsJywgNSk7XG52YXIgX1FUU19SZXNvbHZlRXhjZXB0aW9uID0gTW9kdWxlWydfUVRTX1Jlc29sdmVFeGNlcHRpb24nXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SZXNvbHZlRXhjZXB0aW9uJywgMik7XG52YXIgX1FUU19EdW1wID0gTW9kdWxlWydfUVRTX0R1bXAnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19EdW1wJywgMik7XG52YXIgX1FUU19FdmFsID0gTW9kdWxlWydfUVRTX0V2YWwnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19FdmFsJywgNik7XG52YXIgX1FUU19HZXRNb2R1bGVOYW1lc3BhY2UgPSBNb2R1bGVbJ19RVFNfR2V0TW9kdWxlTmFtZXNwYWNlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0TW9kdWxlTmFtZXNwYWNlJywgMik7XG52YXIgX1FUU19UeXBlb2YgPSBNb2R1bGVbJ19RVFNfVHlwZW9mJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfVHlwZW9mJywgMik7XG52YXIgX1FUU19HZXRMZW5ndGggPSBNb2R1bGVbJ19RVFNfR2V0TGVuZ3RoJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0TGVuZ3RoJywgMyk7XG52YXIgX1FUU19Jc0VxdWFsID0gTW9kdWxlWydfUVRTX0lzRXF1YWwnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19Jc0VxdWFsJywgNCk7XG52YXIgX1FUU19HZXRHbG9iYWxPYmplY3QgPSBNb2R1bGVbJ19RVFNfR2V0R2xvYmFsT2JqZWN0J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0R2xvYmFsT2JqZWN0JywgMSk7XG52YXIgX1FUU19OZXdQcm9taXNlQ2FwYWJpbGl0eSA9IE1vZHVsZVsnX1FUU19OZXdQcm9taXNlQ2FwYWJpbGl0eSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld1Byb21pc2VDYXBhYmlsaXR5JywgMik7XG52YXIgX1FUU19Qcm9taXNlU3RhdGUgPSBNb2R1bGVbJ19RVFNfUHJvbWlzZVN0YXRlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUHJvbWlzZVN0YXRlJywgMik7XG52YXIgX1FUU19Qcm9taXNlUmVzdWx0ID0gTW9kdWxlWydfUVRTX1Byb21pc2VSZXN1bHQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19Qcm9taXNlUmVzdWx0JywgMik7XG52YXIgX1FUU19UZXN0U3RyaW5nQXJnID0gTW9kdWxlWydfUVRTX1Rlc3RTdHJpbmdBcmcnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19UZXN0U3RyaW5nQXJnJywgMSk7XG52YXIgX1FUU19HZXREZWJ1Z0xvZ0VuYWJsZWQgPSBNb2R1bGVbJ19RVFNfR2V0RGVidWdMb2dFbmFibGVkJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0RGVidWdMb2dFbmFibGVkJywgMSk7XG52YXIgX1FUU19TZXREZWJ1Z0xvZ0VuYWJsZWQgPSBNb2R1bGVbJ19RVFNfU2V0RGVidWdMb2dFbmFibGVkJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfU2V0RGVidWdMb2dFbmFibGVkJywgMik7XG52YXIgX1FUU19CdWlsZElzRGVidWcgPSBNb2R1bGVbJ19RVFNfQnVpbGRJc0RlYnVnJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfQnVpbGRJc0RlYnVnJywgMCk7XG52YXIgX1FUU19CdWlsZElzQXN5bmNpZnkgPSBNb2R1bGVbJ19RVFNfQnVpbGRJc0FzeW5jaWZ5J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfQnVpbGRJc0FzeW5jaWZ5JywgMCk7XG52YXIgX1FUU19OZXdGdW5jdGlvbiA9IE1vZHVsZVsnX1FUU19OZXdGdW5jdGlvbiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0Z1bmN0aW9uJywgMyk7XG52YXIgX1FUU19Bcmd2R2V0SlNWYWx1ZUNvbnN0UG9pbnRlciA9IE1vZHVsZVsnX1FUU19Bcmd2R2V0SlNWYWx1ZUNvbnN0UG9pbnRlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0FyZ3ZHZXRKU1ZhbHVlQ29uc3RQb2ludGVyJywgMik7XG52YXIgX1FUU19SdW50aW1lRW5hYmxlSW50ZXJydXB0SGFuZGxlciA9IE1vZHVsZVsnX1FUU19SdW50aW1lRW5hYmxlSW50ZXJydXB0SGFuZGxlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVFbmFibGVJbnRlcnJ1cHRIYW5kbGVyJywgMSk7XG52YXIgX1FUU19SdW50aW1lRGlzYWJsZUludGVycnVwdEhhbmRsZXIgPSBNb2R1bGVbJ19RVFNfUnVudGltZURpc2FibGVJbnRlcnJ1cHRIYW5kbGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUnVudGltZURpc2FibGVJbnRlcnJ1cHRIYW5kbGVyJywgMSk7XG52YXIgX1FUU19SdW50aW1lRW5hYmxlTW9kdWxlTG9hZGVyID0gTW9kdWxlWydfUVRTX1J1bnRpbWVFbmFibGVNb2R1bGVMb2FkZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lRW5hYmxlTW9kdWxlTG9hZGVyJywgMik7XG52YXIgX1FUU19SdW50aW1lRGlzYWJsZU1vZHVsZUxvYWRlciA9IE1vZHVsZVsnX1FUU19SdW50aW1lRGlzYWJsZU1vZHVsZUxvYWRlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVEaXNhYmxlTW9kdWxlTG9hZGVyJywgMSk7XG52YXIgX1FUU19ianNvbl9lbmNvZGUgPSBNb2R1bGVbJ19RVFNfYmpzb25fZW5jb2RlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfYmpzb25fZW5jb2RlJywgMik7XG52YXIgX1FUU19ianNvbl9kZWNvZGUgPSBNb2R1bGVbJ19RVFNfYmpzb25fZGVjb2RlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfYmpzb25fZGVjb2RlJywgMik7XG52YXIgX2ZmbHVzaCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2ZmbHVzaCcsIDEpO1xudmFyIF9zdHJlcnJvciA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ3N0cmVycm9yJywgMSk7XG52YXIgX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tYWxsb2MgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdlbXNjcmlwdGVuX2J1aWx0aW5fbWFsbG9jJywgMSk7XG52YXIgX19fZnVuY3Nfb25fZXhpdCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ19fZnVuY3Nfb25fZXhpdCcsIDApO1xudmFyIF9lbXNjcmlwdGVuX2J1aWx0aW5fZnJlZSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2Vtc2NyaXB0ZW5fYnVpbHRpbl9mcmVlJywgMSk7XG52YXIgX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbicsIDIpO1xudmFyIF9tZW1hbGlnbiA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ21lbWFsaWduJywgMik7XG52YXIgX19lbXNjcmlwdGVuX3RlbXByZXRfc2V0ID0gY3JlYXRlRXhwb3J0V3JhcHBlcignX2Vtc2NyaXB0ZW5fdGVtcHJldF9zZXQnLCAxKTtcbnZhciBfZW1zY3JpcHRlbl9zdGFja19pbml0ID0gKCkgPT4gKF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19pbml0J10pKCk7XG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSAoKSA9PiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSddKSgpO1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlID0gKCkgPT4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlID0gd2FzbUV4cG9ydHNbJ2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UnXSkoKTtcbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kID0gKCkgPT4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kJ10pKCk7XG52YXIgX19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUgPSAoYTApID0+IChfX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSA9IHdhc21FeHBvcnRzWydfZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlJ10pKGEwKTtcbnZhciBfX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MgPSAoYTApID0+IChfX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MgPSB3YXNtRXhwb3J0c1snX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MnXSkoYTApO1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50ID0gKCkgPT4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50ID0gd2FzbUV4cG9ydHNbJ2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQnXSkoKTtcbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWlpaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWppaWlpJywgOCk7XG52YXIgZHluQ2FsbF9qaWppaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamlpaScsIDcpO1xudmFyIGR5bkNhbGxfamlqamlpaSA9IE1vZHVsZVsnZHluQ2FsbF9qaWpqaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamppaWknLCA5KTtcbnZhciBkeW5DYWxsX2ppaiA9IE1vZHVsZVsnZHluQ2FsbF9qaWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqJywgNCk7XG52YXIgZHluQ2FsbF9qaWlpaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlpaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppaWlpaScsIDYpO1xudmFyIGR5bkNhbGxfaWlpaWogPSBNb2R1bGVbJ2R5bkNhbGxfaWlpaWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlpaWonLCA2KTtcbnZhciBkeW5DYWxsX2lpaWlqaiA9IE1vZHVsZVsnZHluQ2FsbF9paWlpamonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlpaWpqJywgOCk7XG52YXIgZHluQ2FsbF9qaWlqID0gTW9kdWxlWydkeW5DYWxsX2ppaWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlpaicsIDUpO1xudmFyIGR5bkNhbGxfamlqaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqaWknLCA2KTtcbnZhciBkeW5DYWxsX2ppamlpaWlpID0gTW9kdWxlWydkeW5DYWxsX2ppamlpaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamlpaWlpJywgOSk7XG52YXIgZHluQ2FsbF9paWlqaiA9IE1vZHVsZVsnZHluQ2FsbF9paWlqaiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWlqaicsIDcpO1xudmFyIGR5bkNhbGxfamlqaiA9IE1vZHVsZVsnZHluQ2FsbF9qaWpqJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamonLCA2KTtcbnZhciBkeW5DYWxsX2ppaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlpaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWlpJywgNCk7XG52YXIgZHluQ2FsbF9qaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppaScsIDMpO1xudmFyIGR5bkNhbGxfdmlqID0gTW9kdWxlWydkeW5DYWxsX3ZpaiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF92aWonLCA0KTtcbnZhciBkeW5DYWxsX3ZpamkgPSBNb2R1bGVbJ2R5bkNhbGxfdmlqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF92aWppJywgNSk7XG52YXIgZHluQ2FsbF9paWppampqaSA9IE1vZHVsZVsnZHluQ2FsbF9paWppampqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWppampqaScsIDEyKTtcbnZhciBkeW5DYWxsX2lpaWppID0gTW9kdWxlWydkeW5DYWxsX2lpaWppJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2lpaWppJywgNik7XG52YXIgZHluQ2FsbF9paWppID0gTW9kdWxlWydkeW5DYWxsX2lpamknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlqaScsIDUpO1xudmFyIGR5bkNhbGxfamlqaWogPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqaWonLCA3KTtcbnZhciBkeW5DYWxsX2lpamlqamkgPSBNb2R1bGVbJ2R5bkNhbGxfaWlqaWpqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWppamppJywgMTApO1xudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlpaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlpaWknLCA1KTtcbnZhciBkeW5DYWxsX2ppamkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWppJywgNSk7XG52YXIgZHluQ2FsbF9qaWpqaSA9IE1vZHVsZVsnZHluQ2FsbF9qaWpqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWpqaScsIDcpO1xuXG5cbi8vIGluY2x1ZGU6IHBvc3RhbWJsZS5qc1xuLy8gPT09IEF1dG8tZ2VuZXJhdGVkIHBvc3RhbWJsZSBzZXR1cCBlbnRyeSBzdHVmZiA9PT1cblxuTW9kdWxlWydjd3JhcCddID0gY3dyYXA7XG5Nb2R1bGVbJ1VURjhUb1N0cmluZyddID0gVVRGOFRvU3RyaW5nO1xuTW9kdWxlWydzdHJpbmdUb1VURjgnXSA9IHN0cmluZ1RvVVRGODtcbk1vZHVsZVsnbGVuZ3RoQnl0ZXNVVEY4J10gPSBsZW5ndGhCeXRlc1VURjg7XG52YXIgbWlzc2luZ0xpYnJhcnlTeW1ib2xzID0gW1xuICAnd3JpdGVJNTNUb0k2NCcsXG4gICd3cml0ZUk1M1RvSTY0Q2xhbXBlZCcsXG4gICd3cml0ZUk1M1RvSTY0U2lnbmFsaW5nJyxcbiAgJ3dyaXRlSTUzVG9VNjRDbGFtcGVkJyxcbiAgJ3dyaXRlSTUzVG9VNjRTaWduYWxpbmcnLFxuICAncmVhZEk1M0Zyb21JNjQnLFxuICAncmVhZEk1M0Zyb21VNjQnLFxuICAnY29udmVydEkzMlBhaXJUb0k1MycsXG4gICdjb252ZXJ0VTMyUGFpclRvSTUzJyxcbiAgJ2dldFRlbXBSZXQwJyxcbiAgJ3NldFRlbXBSZXQwJyxcbiAgJ2V4aXRKUycsXG4gICdpbmV0UHRvbjQnLFxuICAnaW5ldE50b3A0JyxcbiAgJ2luZXRQdG9uNicsXG4gICdpbmV0TnRvcDYnLFxuICAncmVhZFNvY2thZGRyJyxcbiAgJ3dyaXRlU29ja2FkZHInLFxuICAnZW1zY3JpcHRlbkxvZycsXG4gICdyZWFkRW1Bc21BcmdzJyxcbiAgJ2pzdG9pX3EnLFxuICAnbGlzdGVuT25jZScsXG4gICdhdXRvUmVzdW1lQXVkaW9Db250ZXh0JyxcbiAgJ2R5bkNhbGxMZWdhY3knLFxuICAnZ2V0RHluQ2FsbGVyJyxcbiAgJ2R5bkNhbGwnLFxuICAnaGFuZGxlRXhjZXB0aW9uJyxcbiAgJ3J1bnRpbWVLZWVwYWxpdmVQdXNoJyxcbiAgJ3J1bnRpbWVLZWVwYWxpdmVQb3AnLFxuICAnY2FsbFVzZXJDYWxsYmFjaycsXG4gICdtYXliZUV4aXQnLFxuICAnYXNtanNNYW5nbGUnLFxuICAnSGFuZGxlQWxsb2NhdG9yJyxcbiAgJ2dldE5hdGl2ZVR5cGVTaXplJyxcbiAgJ1NUQUNLX1NJWkUnLFxuICAnU1RBQ0tfQUxJR04nLFxuICAnUE9JTlRFUl9TSVpFJyxcbiAgJ0FTU0VSVElPTlMnLFxuICAndWxlYjEyOEVuY29kZScsXG4gICdzaWdUb1dhc21UeXBlcycsXG4gICdnZW5lcmF0ZUZ1bmNUeXBlJyxcbiAgJ2NvbnZlcnRKc0Z1bmN0aW9uVG9XYXNtJyxcbiAgJ2dldEVtcHR5VGFibGVTbG90JyxcbiAgJ3VwZGF0ZVRhYmxlTWFwJyxcbiAgJ2dldEZ1bmN0aW9uQWRkcmVzcycsXG4gICdhZGRGdW5jdGlvbicsXG4gICdyZW1vdmVGdW5jdGlvbicsXG4gICdyZWFsbHlOZWdhdGl2ZScsXG4gICd1blNpZ24nLFxuICAnc3RyTGVuJyxcbiAgJ3JlU2lnbicsXG4gICdmb3JtYXRTdHJpbmcnLFxuICAnaW50QXJyYXlUb1N0cmluZycsXG4gICdBc2NpaVRvU3RyaW5nJyxcbiAgJ3N0cmluZ1RvQXNjaWknLFxuICAnVVRGMTZUb1N0cmluZycsXG4gICdzdHJpbmdUb1VURjE2JyxcbiAgJ2xlbmd0aEJ5dGVzVVRGMTYnLFxuICAnVVRGMzJUb1N0cmluZycsXG4gICdzdHJpbmdUb1VURjMyJyxcbiAgJ2xlbmd0aEJ5dGVzVVRGMzInLFxuICAncmVnaXN0ZXJLZXlFdmVudENhbGxiYWNrJyxcbiAgJ21heWJlQ1N0cmluZ1RvSnNTdHJpbmcnLFxuICAnZmluZEV2ZW50VGFyZ2V0JyxcbiAgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICdmaWxsTW91c2VFdmVudERhdGEnLFxuICAncmVnaXN0ZXJNb3VzZUV2ZW50Q2FsbGJhY2snLFxuICAncmVnaXN0ZXJXaGVlbEV2ZW50Q2FsbGJhY2snLFxuICAncmVnaXN0ZXJVaUV2ZW50Q2FsbGJhY2snLFxuICAncmVnaXN0ZXJGb2N1c0V2ZW50Q2FsbGJhY2snLFxuICAnZmlsbERldmljZU9yaWVudGF0aW9uRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyRGV2aWNlT3JpZW50YXRpb25FdmVudENhbGxiYWNrJyxcbiAgJ2ZpbGxEZXZpY2VNb3Rpb25FdmVudERhdGEnLFxuICAncmVnaXN0ZXJEZXZpY2VNb3Rpb25FdmVudENhbGxiYWNrJyxcbiAgJ3NjcmVlbk9yaWVudGF0aW9uJyxcbiAgJ2ZpbGxPcmllbnRhdGlvbkNoYW5nZUV2ZW50RGF0YScsXG4gICdyZWdpc3Rlck9yaWVudGF0aW9uQ2hhbmdlRXZlbnRDYWxsYmFjaycsXG4gICdmaWxsRnVsbHNjcmVlbkNoYW5nZUV2ZW50RGF0YScsXG4gICdyZWdpc3RlckZ1bGxzY3JlZW5DaGFuZ2VFdmVudENhbGxiYWNrJyxcbiAgJ0pTRXZlbnRzX3JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgJ0pTRXZlbnRzX3Jlc2l6ZUNhbnZhc0ZvckZ1bGxzY3JlZW4nLFxuICAncmVnaXN0ZXJSZXN0b3JlT2xkU3R5bGUnLFxuICAnaGlkZUV2ZXJ5dGhpbmdFeGNlcHRHaXZlbkVsZW1lbnQnLFxuICAncmVzdG9yZUhpZGRlbkVsZW1lbnRzJyxcbiAgJ3NldExldHRlcmJveCcsXG4gICdzb2Z0RnVsbHNjcmVlblJlc2l6ZVdlYkdMUmVuZGVyVGFyZ2V0JyxcbiAgJ2RvUmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAnZmlsbFBvaW50ZXJsb2NrQ2hhbmdlRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrJyxcbiAgJ3JlZ2lzdGVyUG9pbnRlcmxvY2tFcnJvckV2ZW50Q2FsbGJhY2snLFxuICAncmVxdWVzdFBvaW50ZXJMb2NrJyxcbiAgJ2ZpbGxWaXNpYmlsaXR5Q2hhbmdlRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUV2ZW50Q2FsbGJhY2snLFxuICAncmVnaXN0ZXJUb3VjaEV2ZW50Q2FsbGJhY2snLFxuICAnZmlsbEdhbWVwYWRFdmVudERhdGEnLFxuICAncmVnaXN0ZXJHYW1lcGFkRXZlbnRDYWxsYmFjaycsXG4gICdyZWdpc3RlckJlZm9yZVVubG9hZEV2ZW50Q2FsbGJhY2snLFxuICAnZmlsbEJhdHRlcnlFdmVudERhdGEnLFxuICAnYmF0dGVyeScsXG4gICdyZWdpc3RlckJhdHRlcnlFdmVudENhbGxiYWNrJyxcbiAgJ3NldENhbnZhc0VsZW1lbnRTaXplJyxcbiAgJ2dldENhbnZhc0VsZW1lbnRTaXplJyxcbiAgJ2dldENhbGxzdGFjaycsXG4gICdnZXRFbnZTdHJpbmdzJyxcbiAgJ2NoZWNrV2FzaUNsb2NrJyxcbiAgJ3dhc2lSaWdodHNUb011c2xPRmxhZ3MnLFxuICAnd2FzaU9GbGFnc1RvTXVzbE9GbGFncycsXG4gICdjcmVhdGVEeW5jYWxsV3JhcHBlcicsXG4gICdzYWZlU2V0VGltZW91dCcsXG4gICdzZXRJbW1lZGlhdGVXcmFwcGVkJyxcbiAgJ2NsZWFySW1tZWRpYXRlV3JhcHBlZCcsXG4gICdwb2x5ZmlsbFNldEltbWVkaWF0ZScsXG4gICdnZXRQcm9taXNlJyxcbiAgJ21ha2VQcm9taXNlJyxcbiAgJ2lkc1RvUHJvbWlzZXMnLFxuICAnbWFrZVByb21pc2VDYWxsYmFjaycsXG4gICdCcm93c2VyX2FzeW5jUHJlcGFyZURhdGFDb3VudGVyJyxcbiAgJ3NldE1haW5Mb29wJyxcbiAgJ2FycmF5U3VtJyxcbiAgJ2FkZERheXMnLFxuICAnZ2V0U29ja2V0RnJvbUZEJyxcbiAgJ2dldFNvY2tldEFkZHJlc3MnLFxuICAnRlNfdW5saW5rJyxcbiAgJ0ZTX21rZGlyVHJlZScsXG4gICdfc2V0TmV0d29ya0NhbGxiYWNrJyxcbiAgJ0FMTE9DX05PUk1BTCcsXG4gICdBTExPQ19TVEFDSycsXG4gICdhbGxvY2F0ZScsXG4gICd3cml0ZVN0cmluZ1RvTWVtb3J5JyxcbiAgJ3dyaXRlQXNjaWlUb01lbW9yeScsXG4gICdzZXRFcnJObycsXG4gICdzdGFja1RyYWNlJyxcbl07XG5taXNzaW5nTGlicmFyeVN5bWJvbHMuZm9yRWFjaChtaXNzaW5nTGlicmFyeVN5bWJvbClcblxudmFyIHVuZXhwb3J0ZWRTeW1ib2xzID0gW1xuICAncnVuJyxcbiAgJ2FkZE9uUHJlUnVuJyxcbiAgJ2FkZE9uSW5pdCcsXG4gICdhZGRPblByZU1haW4nLFxuICAnYWRkT25FeGl0JyxcbiAgJ2FkZE9uUG9zdFJ1bicsXG4gICdhZGRSdW5EZXBlbmRlbmN5JyxcbiAgJ3JlbW92ZVJ1bkRlcGVuZGVuY3knLFxuICAnb3V0JyxcbiAgJ2VycicsXG4gICdjYWxsTWFpbicsXG4gICdhYm9ydCcsXG4gICd3YXNtTWVtb3J5JyxcbiAgJ3dhc21FeHBvcnRzJyxcbiAgJ1dhc21PZmZzZXRDb252ZXJ0ZXInLFxuICAnV2FzbVNvdXJjZU1hcCcsXG4gICd3cml0ZVN0YWNrQ29va2llJyxcbiAgJ2NoZWNrU3RhY2tDb29raWUnLFxuICAnY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQnLFxuICAnc3RhY2tTYXZlJyxcbiAgJ3N0YWNrUmVzdG9yZScsXG4gICdzdGFja0FsbG9jJyxcbiAgJ3B0clRvU3RyaW5nJyxcbiAgJ3plcm9NZW1vcnknLFxuICAnZ2V0SGVhcE1heCcsXG4gICdncm93TWVtb3J5JyxcbiAgJ0VOVicsXG4gICdFUlJOT19DT0RFUycsXG4gICdzdHJFcnJvcicsXG4gICdETlMnLFxuICAnUHJvdG9jb2xzJyxcbiAgJ1NvY2tldHMnLFxuICAnaW5pdFJhbmRvbUZpbGwnLFxuICAncmFuZG9tRmlsbCcsXG4gICd0aW1lcnMnLFxuICAnd2Fybk9uY2UnLFxuICAnd2l0aEJ1aWx0aW5NYWxsb2MnLFxuICAncmVhZEVtQXNtQXJnc0FycmF5JyxcbiAgJ2pzdG9pX3MnLFxuICAnZ2V0RXhlY3V0YWJsZU5hbWUnLFxuICAna2VlcFJ1bnRpbWVBbGl2ZScsXG4gICdhc3luY0xvYWQnLFxuICAnYWxpZ25NZW1vcnknLFxuICAnbW1hcEFsbG9jJyxcbiAgJ3dhc21UYWJsZScsXG4gICdub0V4aXRSdW50aW1lJyxcbiAgJ2dldENGdW5jJyxcbiAgJ2NjYWxsJyxcbiAgJ2ZyZWVUYWJsZUluZGV4ZXMnLFxuICAnZnVuY3Rpb25zSW5UYWJsZU1hcCcsXG4gICdzZXRWYWx1ZScsXG4gICdnZXRWYWx1ZScsXG4gICdQQVRIJyxcbiAgJ1BBVEhfRlMnLFxuICAnVVRGOERlY29kZXInLFxuICAnVVRGOEFycmF5VG9TdHJpbmcnLFxuICAnc3RyaW5nVG9VVEY4QXJyYXknLFxuICAnaW50QXJyYXlGcm9tU3RyaW5nJyxcbiAgJ1VURjE2RGVjb2RlcicsXG4gICdzdHJpbmdUb05ld1VURjgnLFxuICAnc3RyaW5nVG9VVEY4T25TdGFjaycsXG4gICd3cml0ZUFycmF5VG9NZW1vcnknLFxuICAnSlNFdmVudHMnLFxuICAnc3BlY2lhbEhUTUxUYXJnZXRzJyxcbiAgJ2ZpbmRDYW52YXNFdmVudFRhcmdldCcsXG4gICdjdXJyZW50RnVsbHNjcmVlblN0cmF0ZWd5JyxcbiAgJ3Jlc3RvcmVPbGRXaW5kb3dlZFN0eWxlJyxcbiAgJ2pzU3RhY2tUcmFjZScsXG4gICdVTldJTkRfQ0FDSEUnLFxuICAnY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvbicsXG4gICdFeGl0U3RhdHVzJyxcbiAgJ2RvUmVhZHYnLFxuICAnZG9Xcml0ZXYnLFxuICAncHJvbWlzZU1hcCcsXG4gICdCcm93c2VyJyxcbiAgJ2dldFByZWxvYWRlZEltYWdlRGF0YV9fZGF0YScsXG4gICd3Z2V0JyxcbiAgJ01PTlRIX0RBWVNfUkVHVUxBUicsXG4gICdNT05USF9EQVlTX0xFQVAnLFxuICAnTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUnLFxuICAnTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUnLFxuICAnaXNMZWFwWWVhcicsXG4gICd5ZGF5RnJvbURhdGUnLFxuICAnU1lTQ0FMTFMnLFxuICAncHJlbG9hZFBsdWdpbnMnLFxuICAnRlNfY3JlYXRlUHJlbG9hZGVkRmlsZScsXG4gICdGU19tb2RlU3RyaW5nVG9GbGFncycsXG4gICdGU19nZXRNb2RlJyxcbiAgJ0ZTX3N0ZGluX2dldENoYXJfYnVmZmVyJyxcbiAgJ0ZTX3N0ZGluX2dldENoYXInLFxuICAnRlNfY3JlYXRlUGF0aCcsXG4gICdGU19jcmVhdGVEZXZpY2UnLFxuICAnRlNfcmVhZEZpbGUnLFxuICAnRlMnLFxuICAnRlNfY3JlYXRlRGF0YUZpbGUnLFxuICAnRlNfY3JlYXRlTGF6eUZpbGUnLFxuICAnTUVNRlMnLFxuICAnVFRZJyxcbiAgJ1BJUEVGUycsXG4gICdTT0NLRlMnLFxuICAnYWxsb2NhdGVVVEY4JyxcbiAgJ2FsbG9jYXRlVVRGOE9uU3RhY2snLFxuICAncHJpbnQnLFxuICAncHJpbnRFcnInLFxuXTtcbnVuZXhwb3J0ZWRTeW1ib2xzLmZvckVhY2godW5leHBvcnRlZFJ1bnRpbWVTeW1ib2wpO1xuXG5cblxudmFyIGNhbGxlZFJ1bjtcblxuZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAvLyBJZiBydW4gaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCBhbmQgd2Ugc2hvdWxkIGNhbGwgcnVuIChJTlZPS0VfUlVOIGlzIHRydWUsIGFuZCBNb2R1bGUubm9Jbml0aWFsUnVuIGlzIG5vdCBmYWxzZSlcbiAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICBpZiAoIWNhbGxlZFJ1bikgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyOyAvLyB0cnkgdGhpcyBhZ2FpbiBsYXRlciwgYWZ0ZXIgbmV3IGRlcHMgYXJlIGZ1bGZpbGxlZFxufTtcblxuZnVuY3Rpb24gc3RhY2tDaGVja0luaXQoKSB7XG4gIC8vIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIF9fd2FzbV9jYWxsX2N0b3JzIGJ1dCBuZWVkIHRvXG4gIC8vIGdldCB0aGVzZSB2YWx1ZXMgYmVmb3JlIGV2ZW4gcnVubmluZyBhbnkgb2YgdGhlIGN0b3JzIHNvIHdlIGNhbGwgaXQgcmVkdW5kYW50bHlcbiAgLy8gaGVyZS5cbiAgX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCgpO1xuICAvLyBUT0RPKHNiYyk6IE1vdmUgd3JpdGVTdGFja0Nvb2tpZSB0byBuYXRpdmUgdG8gdG8gYXZvaWQgdGhpcy5cbiAgd3JpdGVTdGFja0Nvb2tpZSgpO1xufVxuXG5mdW5jdGlvbiBydW4oKSB7XG5cbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAgIHN0YWNrQ2hlY2tJbml0KCk7XG5cbiAgcHJlUnVuKCk7XG5cbiAgLy8gYSBwcmVSdW4gYWRkZWQgYSBkZXBlbmRlbmN5LCBydW4gd2lsbCBiZSBjYWxsZWQgbGF0ZXJcbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBkb1J1bigpIHtcbiAgICAvLyBydW4gbWF5IGhhdmUganVzdCBiZWVuIGNhbGxlZCB0aHJvdWdoIGRlcGVuZGVuY2llcyBiZWluZyBmdWxmaWxsZWQganVzdCBpbiB0aGlzIHZlcnkgZnJhbWUsXG4gICAgLy8gb3Igd2hpbGUgdGhlIGFzeW5jIHNldFN0YXR1cyB0aW1lIGJlbG93IHdhcyBoYXBwZW5pbmdcbiAgICBpZiAoY2FsbGVkUnVuKSByZXR1cm47XG4gICAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gdHJ1ZTtcblxuICAgIGlmIChBQk9SVCkgcmV0dXJuO1xuXG4gICAgaW5pdFJ1bnRpbWUoKTtcblxuICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgICBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10/LigpO1xuXG4gICAgYXNzZXJ0KCFNb2R1bGVbJ19tYWluJ10sICdjb21waWxlZCB3aXRob3V0IGEgbWFpbiwgYnV0IG9uZSBpcyBwcmVzZW50LiBpZiB5b3UgYWRkZWQgaXQgZnJvbSBKUywgdXNlIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdJyk7XG5cbiAgICBwb3N0UnVuKCk7XG4gIH1cblxuICBpZiAoTW9kdWxlWydzZXRTdGF0dXMnXSkge1xuICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJ1J1bm5pbmcuLi4nKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7XG4gICAgICB9LCAxKTtcbiAgICAgIGRvUnVuKCk7XG4gICAgfSwgMSk7XG4gIH0gZWxzZVxuICB7XG4gICAgZG9SdW4oKTtcbiAgfVxuICBjaGVja1N0YWNrQ29va2llKCk7XG59XG5cbmlmIChNb2R1bGVbJ3ByZUluaXQnXSkge1xuICBpZiAodHlwZW9mIE1vZHVsZVsncHJlSW5pdCddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncHJlSW5pdCddID0gW01vZHVsZVsncHJlSW5pdCddXTtcbiAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xuICB9XG59XG5cbnJ1bigpO1xuXG4vLyBlbmQgaW5jbHVkZTogcG9zdGFtYmxlLmpzXG5cbi8vIGluY2x1ZGU6IHBvc3RhbWJsZV9tb2R1bGFyaXplLmpzXG4vLyBJbiBNT0RVTEFSSVpFIG1vZGUgd2Ugd3JhcCB0aGUgZ2VuZXJhdGVkIGNvZGUgaW4gYSBmYWN0b3J5IGZ1bmN0aW9uXG4vLyBhbmQgcmV0dXJuIGVpdGhlciB0aGUgTW9kdWxlIGl0c2VsZiwgb3IgYSBwcm9taXNlIG9mIHRoZSBtb2R1bGUuXG4vL1xuLy8gV2UgYXNzaWduIHRvIHRoZSBgbW9kdWxlUnRuYCBnbG9iYWwgaGVyZSBhbmQgY29uZmlndXJlIGNsb3N1cmUgdG8gc2VlXG4vLyB0aGlzIGFzIGFuZCBleHRlcm4gc28gaXQgd29uJ3QgZ2V0IG1pbmlmaWVkLlxuXG5tb2R1bGVSdG4gPSByZWFkeVByb21pc2U7XG5cbi8vIEFzc2VydGlvbiBmb3IgYXR0ZW1wdGluZyB0byBhY2Nlc3MgbW9kdWxlIHByb3BlcnRpZXMgb24gdGhlIGluY29taW5nXG4vLyBtb2R1bGVBcmcuICBJbiB0aGUgcGFzdCB3ZSB1c2VkIHRoaXMgb2JqZWN0IGFzIHRoZSBwcm90b3R5cGUgb2YgdGhlIG1vZHVsZVxuLy8gYW5kIGFzc2lnbmVkIHByb3BlcnRpZXMgdG8gaXQsIGJ1dCBub3cgd2UgcmV0dXJuIGEgZGlzdGluY3Qgb2JqZWN0LiAgVGhpc1xuLy8ga2VlcHMgdGhlIGluc3RhbmNlIHByaXZhdGUgdW50aWwgaXQgaXMgcmVhZHkgKGkuZSB0aGUgcHJvbWlzZSBoYXMgYmVlblxuLy8gcmVzb2x2ZWQpLlxuZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKE1vZHVsZSkpIHtcbiAgaWYgKCEocHJvcCBpbiBtb2R1bGVBcmcpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZUFyZywgcHJvcCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBhYm9ydChgQWNjZXNzIHRvIG1vZHVsZSBwcm9wZXJ0eSAoJyR7cHJvcH0nKSBpcyBubyBsb25nZXIgcG9zc2libGUgdmlhIHRoZSBtb2R1bGUgY29uc3RydWN0b3IgYXJndW1lbnQ7IEluc3RlYWQsIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb2R1bGUgY29uc3RydWN0b3IuYClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLy8gZW5kIGluY2x1ZGU6IHBvc3RhbWJsZV9tb2R1bGFyaXplLmpzXG5cblxuXG4gIHJldHVybiBtb2R1bGVSdG47XG59XG4pO1xufSkoKTtcbmV4cG9ydCBkZWZhdWx0IFF1aWNrSlNSYXc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.browser.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.wasm":
/*!************************************************************************************!*\
  !*** ./node_modules/@jitl/quickjs-wasmfile-debug-sync/dist/emscripten-module.wasm ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/emscripten-module.5d5a1fab.wasm";

/***/ })

}]);