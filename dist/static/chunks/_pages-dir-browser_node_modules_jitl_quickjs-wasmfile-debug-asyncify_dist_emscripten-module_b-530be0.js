"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_jitl_quickjs-wasmfile-debug-asyncify_dist_emscripten-module_b-530be0"],{

/***/ "(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.browser.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.browser.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\nvar QuickJSRaw = (() => {\n  var _scriptName = \"file:///C:/Users/User/Documents/Sites/Sites/em%20desenvolvimento/Portfolio2/node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.browser.mjs\";\n  \n  return (\nfunction(moduleArg = {}) {\n  var moduleRtn;\n\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = moduleArg;\n\n// Set up the promise that indicates the Module is initialized\nvar readyPromiseResolve, readyPromiseReject;\nvar readyPromise = new Promise((resolve, reject) => {\n  readyPromiseResolve = resolve;\n  readyPromiseReject = reject;\n});\n[\"_QTS_Throw\",\"_QTS_NewError\",\"_QTS_RuntimeSetMemoryLimit\",\"_QTS_RuntimeComputeMemoryUsage\",\"_QTS_RuntimeDumpMemoryUsage\",\"_QTS_RecoverableLeakCheck\",\"_QTS_BuildIsSanitizeLeak\",\"_QTS_RuntimeSetMaxStackSize\",\"_QTS_GetUndefined\",\"_QTS_GetNull\",\"_QTS_GetFalse\",\"_QTS_GetTrue\",\"_QTS_NewRuntime\",\"_QTS_FreeRuntime\",\"_QTS_NewContext\",\"_QTS_FreeContext\",\"_QTS_FreeValuePointer\",\"_QTS_FreeValuePointerRuntime\",\"_QTS_FreeVoidPointer\",\"_QTS_FreeCString\",\"_QTS_DupValuePointer\",\"_QTS_NewObject\",\"_QTS_NewObjectProto\",\"_QTS_NewArray\",\"_QTS_NewArrayBuffer\",\"_QTS_NewFloat64\",\"_QTS_GetFloat64\",\"_QTS_NewString\",\"_QTS_GetString\",\"_QTS_GetArrayBuffer\",\"_QTS_GetArrayBufferLength\",\"_QTS_NewSymbol\",\"_QTS_GetSymbolDescriptionOrKey\",\"_QTS_IsGlobalSymbol\",\"_QTS_IsJobPending\",\"_QTS_ExecutePendingJob\",\"_QTS_GetProp\",\"_QTS_GetPropNumber\",\"_QTS_SetProp\",\"_QTS_DefineProp\",\"_QTS_GetOwnPropertyNames\",\"_QTS_Call\",\"_QTS_ResolveException\",\"_QTS_Dump\",\"_QTS_Eval\",\"_QTS_GetModuleNamespace\",\"_QTS_Typeof\",\"_QTS_GetLength\",\"_QTS_IsEqual\",\"_QTS_GetGlobalObject\",\"_QTS_NewPromiseCapability\",\"_QTS_PromiseState\",\"_QTS_PromiseResult\",\"_QTS_TestStringArg\",\"_QTS_GetDebugLogEnabled\",\"_QTS_SetDebugLogEnabled\",\"_QTS_BuildIsDebug\",\"_QTS_BuildIsAsyncify\",\"_QTS_NewFunction\",\"_QTS_ArgvGetJSValueConstPointer\",\"_QTS_RuntimeEnableInterruptHandler\",\"_QTS_RuntimeDisableInterruptHandler\",\"_QTS_RuntimeEnableModuleLoader\",\"_QTS_RuntimeDisableModuleLoader\",\"_QTS_bjson_encode\",\"_QTS_bjson_decode\",\"_malloc\",\"_free\",\"_set_asyncify_stack_size\",\"_qts_host_call_function\",\"_qts_host_interrupt_handler\",\"_qts_host_load_module_source\",\"_qts_host_normalize_module\",\"___indirect_function_table\",\"onRuntimeInitialized\"].forEach((prop) => {\n  if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\n    Object.defineProperty(readyPromise, prop, {\n      get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n      set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n    });\n  }\n});\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n}\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-extension.js\n/* eslint-disable no-undef */\n// quickjs-emscripten code injected into emscripten-module.js\n// We use this to expose and patch up issues with Emscripten's source map handling...\nfunction quickjsEmscriptenInit(debugLog) {\n  const log = debugLog || function () {}\n  // Everything goes in a function so we can defer running until other variables\n  // are initialized in case they change.\n  const extension = { log }\n  for (const init of quickjsEmscriptenInit.inits) {\n    init(extension)\n  }\n  Module[\"quickJSEmscriptenExtensions\"] = extension\n  return extension\n}\nquickjsEmscriptenInit.inits = []\nModule[\"quickjsEmscriptenInit\"] = quickjsEmscriptenInit\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-extension.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-sourceMapJson.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  if (typeof receiveSourceMapJSON !== \"undefined\") {\n    extension[\"receiveSourceMapJSON\"] = (data) => {\n      if (typeof wasmSourceMap === \"undefined\") {\n        extension.log(\"receiveSourceMapJSON: received\", data)\n        return receiveSourceMapJSON(data)\n      } else {\n        extension.log(\"receiveSourceMapJSON: already have data:\", wasmSourceMap, \"ignoring\", data)\n      }\n    }\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-sourceMapJson.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmOffsetConverter.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  if (typeof WasmOffsetConverter !== \"undefined\") {\n    extension[\"WasmOffsetConverter\"] = WasmOffsetConverter\n    // Expose function to receive WasmOffsetConverter, set to wasmOffsetConverter local variable\n    // if it exists\n    try {\n      // Check if wasmOffsetConverter variable exists. If it isn't defined, this\n      // will throw and we'll skip the rest of the branch.\n      extension[\"existingWasmOffsetConverter\"] = wasmOffsetConverter\n      extension[\"receiveWasmOffsetConverter\"] = function (wasmBinary, wasmModule) {\n        if (!wasmOffsetConverter) {\n          extension.log(\"wasmOffsetConverter set\")\n          wasmOffsetConverter = new WasmOffsetConverter(wasmBinary, wasmModule)\n        } else {\n          extension.log(\"wasmOffsetConverter already set, ignored\")\n        }\n      }\n    } catch (error) {\n      // Nothing.\n      extension[\"receiveWasmOffsetConverter\"] = function () {\n        extension.log(\"wasmOffsetConverter variable not defined, this is a no-op\")\n      }\n    }\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmOffsetConverter.js\n// include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmMemory.js\n/* eslint-disable no-undef */\nquickjsEmscriptenInit.inits.push((extension) => {\n  extension[\"getWasmMemory\"] = function () {\n    return wasmMemory\n  }\n})\n// end include: /Users/jitl/src/quickjs-emscripten/templates/pre-wasmMemory.js\n\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_SHELL) {\n\n  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptName) {\n    scriptDirectory = _scriptName;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n  // they are removed because they could contain a slash.\n  if (scriptDirectory.startsWith('blob:')) {\n    scriptDirectory = '';\n  } else {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);\n  }\n\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  {\n// include: web_or_worker_shell_read.js\nif (ENVIRONMENT_IS_WORKER) {\n    readBinary = (url) => {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.responseType = 'arraybuffer';\n      xhr.send(null);\n      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n    };\n  }\n\n  readAsync = (url) => {\n    assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\n    return fetch(url, { credentials: 'same-origin' })\n      .then((response) => {\n        if (response.ok) {\n          return response.arrayBuffer();\n        }\n        return Promise.reject(new Error(response.status + ' : ' + response.url));\n      })\n  };\n// end include: web_or_worker_shell_read.js\n  }\n} else\n{\n  throw new Error('environment detection error');\n}\n\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.error.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used.\nmoduleOverrides = null;\ncheckIncomingModuleAPI();\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\n\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\nlegacyModuleProp('asm', 'wasmExports');\nlegacyModuleProp('readAsync', 'readAsync');\nlegacyModuleProp('readBinary', 'readBinary');\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\nassert(!ENVIRONMENT_IS_NODE, 'node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.');\n\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n\n// end include: shell.js\n\n// include: preamble.js\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\n\nif (typeof WebAssembly != 'object') {\n  err('no native wasm support detected');\n}\n\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\n\n// Memory management\n\nvar HEAP,\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\n// include: runtime_shared.js\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n}\n// end include: runtime_shared.js\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\n\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\n       'JS engine does not provide full typed array support');\n\n// In non-standalone/normal mode, we create the memory here.\n// include: runtime_init_memory.js\n// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');\n\n    assert(INITIAL_MEMORY >= 5242880, 'INITIAL_MEMORY should be larger than STACK_SIZE, was ' + INITIAL_MEMORY + '! (STACK_SIZE=' + 5242880 + ')');\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_MEMORY / 65536,\n      // In theory we should not need to emit the maximum if we want \"unlimited\"\n      // or 4GB of memory, but VMs error on that atm, see\n      // https://github.com/emscripten-core/emscripten/issues/14130\n      // And in the pthreads case we definitely need to emit a maximum. So\n      // always emit one.\n      'maximum': 2147483648 / 65536,\n    });\n  }\n\n  updateMemoryViews();\n\n// end include: runtime_init_memory.js\n\n// include: runtime_stack_check.js\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end();\n  assert((max & 3) == 0);\n  // If the stack ends at address zero we write our cookies 4 bytes into the\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n  // monitor writes to address zero.\n  if (max == 0) {\n    max += 4;\n  }\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[((max)>>2)] = 0x02135467;\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[((0)>>2)] = 1668509029;\n}\n\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end();\n  // See writeStackCookie().\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = HEAPU32[((max)>>2)];\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n  }\n}\n// end include: runtime_stack_check.js\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\n\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n\n  checkStackCookie();\n\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(() => {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err(`dependency: ${dep}`);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  Module['onAbort']?.(what);\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  if (what.indexOf('RuntimeError: unreachable') >= 0) {\n    what += '. \"unreachable\" may be due to ASYNCIFY_STACK_SIZE not being large enough (try increasing it)';\n  }\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  readyPromiseReject(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\n  },\n  init() { FS.error() },\n  createDataFile() { FS.error() },\n  createPreloadedFile() { FS.error() },\n  createLazyFile() { FS.error() },\n  open() { FS.error() },\n  mkdev() { FS.error() },\n  registerDevice() { FS.error() },\n  analyzePath() { FS.error() },\n\n  ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n// include: URIUtils.js\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n/**\n * Indicates whether filename is a base64 data URI.\n * @noinline\n */\nvar isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */\nvar isFileURI = (filename) => filename.startsWith('file://');\n// end include: URIUtils.js\nfunction createExportWrapper(name, nargs) {\n  return (...args) => {\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n    var f = wasmExports[name];\n    assert(f, `exported native function \\`${name}\\` not found`);\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\n    return f(...args);\n  };\n}\n\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\nfunction findWasmBinary() {\n  if (Module['locateFile']) {\n    var f = 'emscripten-module.wasm';\n    if (!isDataURI(f)) {\n      return locateFile(f);\n    }\n    return f;\n  }\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n  return /* asset import */ new __webpack_require__.U(__webpack_require__(/*! emscripten-module.wasm */ \"(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.wasm\")).href;\n}\n\nvar wasmBinaryFile;\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw 'both async and sync fetching of the wasm failed';\n}\n\nfunction getBinaryPromise(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary\n      ) {\n    // Fetch the binary using readAsync\n    return readAsync(binaryFile).then(\n      (response) => new Uint8Array(/** @type{!ArrayBuffer} */(response)),\n      // Fall back to getBinarySync if readAsync fails\n      () => getBinarySync(binaryFile)\n    );\n  }\n\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return Promise.resolve().then(() => getBinarySync(binaryFile));\n}\n\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\n  return getBinaryPromise(binaryFile).then((binary) => {\n    return WebAssembly.instantiate(binary, imports);\n  }).then(receiver, (reason) => {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n\n    // Warn on some common problems.\n    if (isFileURI(wasmBinaryFile)) {\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n    }\n    abort(reason);\n  });\n}\n\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\n  if (!binary &&\n      typeof WebAssembly.instantiateStreaming == 'function' &&\n      !isDataURI(binaryFile) &&\n      typeof fetch == 'function') {\n    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\n      // Suppress closure warning here since the upstream definition for\n      // instantiateStreaming only allows Promise<Repsponse> rather than\n      // an actual Response.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n      /** @suppress {checkTypes} */\n      var result = WebAssembly.instantiateStreaming(response, imports);\n\n      return result.then(\n        callback,\n        function(reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          err(`wasm streaming compile failed: ${reason}`);\n          err('falling back to ArrayBuffer instantiation');\n          return instantiateArrayBuffer(binaryFile, imports, callback);\n        });\n    });\n  }\n  return instantiateArrayBuffer(binaryFile, imports, callback);\n}\n\nfunction getWasmImports() {\n  // instrumenting imports is used in asyncify in two ways: to add assertions\n  // that check for proper import use, and for ASYNCIFY=2 we use them to set up\n  // the Promise API on the import side.\n  Asyncify.instrumentWasmImports(wasmImports);\n  // prepare imports\n  return {\n    'env': wasmImports,\n    'wasi_snapshot_preview1': wasmImports,\n  }\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  var info = getWasmImports();\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n\n    wasmExports = Asyncify.instrumentWasmExports(wasmExports);\n\n    \n\n    addOnInit(wasmExports['__wasm_call_ctors']);\n\n    removeRunDependency('wasm-instantiate');\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\n    receiveInstance(result['instance']);\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module['instantiateWasm']) {\n    try {\n      return Module['instantiateWasm'](info, receiveInstance);\n    } catch(e) {\n      err(`Module.instantiateWasm callback failed with error: ${e}`);\n        // If instantiation fails, reject the module ready promise.\n        readyPromiseReject(e);\n    }\n  }\n\n  if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();\n\n  // If instantiation fails, reject the module ready promise.\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// include: runtime_debug.js\n// Endianness check\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n})();\n\nfunction legacyModuleProp(prop, newName, incoming=true) {\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      get() {\n        let extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\n        abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n\n      }\n    });\n  }\n}\n\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' ||\n         name === 'FS_createDataFile' ||\n         name === 'FS_createPreloadedFile' ||\n         name === 'FS_unlink' ||\n         name === 'addRunDependency' ||\n         // The old FS has some functionality that WasmFS lacks.\n         name === 'FS_createLazyFile' ||\n         name === 'FS_createDevice' ||\n         name === 'removeRunDependency';\n}\n\nfunction missingGlobal(sym, msg) {\n  if (typeof globalThis != 'undefined') {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get() {\n        warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n        return undefined;\n      }\n    });\n  }\n}\n\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\nmissingGlobal('asm', 'Please use wasmExports instead');\n\nfunction missingLibrarySymbol(sym) {\n  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get() {\n        // Can't `abort()` here because it would break code that does runtime\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n        var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n        // library.js, which means $name for a JS name with no prefix, or name\n        // for a JS name like _name.\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith('_')) {\n          librarySymbol = '$' + sym;\n        }\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        warnOnce(msg);\n        return undefined;\n      }\n    });\n  }\n  // Any symbol that is not included from the JS library is also (by definition)\n  // not exported on the Module object.\n  unexportedRuntimeSymbol(sym);\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get() {\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      }\n    });\n  }\n}\n\n// Used by XXXXX_DEBUG settings to output debug messages.\nfunction dbg(...args) {\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n  // logging to show up as warnings.\n  console.warn(...args);\n}\n// end include: runtime_debug.js\n// === Body ===\n\nfunction set_asyncify_stack_size(size,default_size) { Asyncify.StackSize = size || default_size; }\nfunction qts_host_call_function(ctx,this_ptr,argc,argv,magic_func_id) { const asyncify = {['handleSleep'] : Asyncify.handleSleep}; return Module['callbacks']['callFunction'](asyncify, ctx, this_ptr, argc, argv, magic_func_id); }\nfunction qts_host_interrupt_handler(rt) { const asyncify = undefined; return Module['callbacks']['shouldInterrupt'](asyncify, rt); }\nfunction qts_host_load_module_source(rt,ctx,module_name) { const asyncify = {['handleSleep'] : Asyncify.handleSleep}; const moduleNameString = UTF8ToString(module_name); return Module['callbacks']['loadModuleSource'](asyncify, rt, ctx, moduleNameString); }\nfunction qts_host_normalize_module(rt,ctx,module_base_name,module_name) { const asyncify = {['handleSleep'] : Asyncify.handleSleep}; const moduleBaseNameString = UTF8ToString(module_base_name); const moduleNameString = UTF8ToString(module_name); return Module['callbacks']['normalizeModule'](asyncify, rt, ctx, moduleBaseNameString, moduleNameString); }\n\n// end include: preamble.js\n\n\n  /** @constructor */\n  function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n  var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': return HEAP8[ptr];\n      case 'i8': return HEAP8[ptr];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      case '*': return HEAPU32[((ptr)>>2)];\n      default: abort(`invalid type for getValue: ${type}`);\n    }\n  }\n\n  var noExitRuntime = Module['noExitRuntime'] || true;\n\n  var ptrToString = (ptr) => {\n      assert(typeof ptr === 'number');\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return '0x' + ptr.toString(16).padStart(8, '0');\n    };\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': HEAP8[ptr] = value; break;\n      case 'i8': HEAP8[ptr] = value; break;\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\n      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\n      default: abort(`invalid type for setValue: ${type}`);\n    }\n  }\n\n  var stackRestore = (val) => __emscripten_stack_restore(val);\n\n  var stackSave = () => _emscripten_stack_get_current();\n\n  var warnOnce = (text) => {\n      warnOnce.shown ||= {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n  \n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  \n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n  \n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        }\n      }\n      return str;\n    };\n  \n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n  var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n  var ___assert_fail = (condition, filename, line, func) => {\n      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n    };\n\n  var __abort_js = () => {\n      abort('native code called abort()');\n    };\n\n  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n\n  var isLeapYear = (year) => year%4 === 0 && (year%100 !== 0 || year%400 === 0);\n  \n  var MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];\n  \n  var MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];\n  var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = (leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE);\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1\n  \n      return yday;\n    };\n  \n  var convertI32PairToI53Checked = (lo, hi) => {\n      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32\n      assert(hi === (hi|0));                    // hi should be a i32\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n  function __localtime_js(time_low, time_high,tmPtr) {\n    var time = convertI32PairToI53Checked(time_low, time_high);\n  \n    \n      var date = new Date(time*1000);\n      HEAP32[((tmPtr)>>2)] = date.getSeconds();\n      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();\n      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();\n      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();\n      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();\n      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;\n      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();\n  \n      var yday = ydayFromDate(date)|0;\n      HEAP32[(((tmPtr)+(28))>>2)] = yday;\n      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);\n  \n      // Attention: DST is in December in South, and some regions don't have DST at all.\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;\n      HEAP32[(((tmPtr)+(32))>>2)] = dst;\n    ;\n  }\n\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0))\n        return 0;\n  \n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n        }\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xC0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xE0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n          heap[outIdx++] = 0xF0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n  \n  var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7F) {\n          len++;\n        } else if (c <= 0x7FF) {\n          len += 2;\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\n          len += 4; ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n  var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      // TODO: Use (malleable) environment variables instead of system settings.\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n  \n      // Local standard timezone offset. Local standard time is not adjusted for\n      // daylight savings.  This code uses the fact that getTimezoneOffset returns\n      // a greater value during Standard Time versus Daylight Saving Time (DST).\n      // Thus it determines the expected output during Standard Time, and it\n      // compares whether the output of the given date the same (Standard) or less\n      // (DST).\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n  \n      // timezone is specified as seconds west of UTC (\"The external variable\n      // `timezone` shall be set to the difference, in seconds, between\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\n      // as returned by stdTimezoneOffset.\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;\n  \n      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);\n  \n      var extractZone = (timezoneOffset) => {\n        // Why inverse sign?\n        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n        var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\n  \n        var absOffset = Math.abs(timezoneOffset)\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\n        var minutes = String(absOffset % 60).padStart(2, \"0\");\n  \n        return `UTC${sign}${hours}${minutes}`;\n      }\n  \n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      assert(winterName);\n      assert(summerName);\n      assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`);\n      assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`);\n      if (summerOffset < winterOffset) {\n        // Northern hemisphere\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n\n  var _emscripten_date_now = () => Date.now();\n\n  var getHeapMax = () =>\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      2147483648;\n  \n  var alignMemory = (size, alignment) => {\n      assert(alignment, \"alignment argument is required\");\n      return Math.ceil(size / alignment) * alignment;\n    };\n  \n  var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\n        updateMemoryViews();\n        return 1 /*success*/;\n      } catch(e) {\n        err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    };\n  var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      // With multithreaded builds, races can happen (another thread might increase the size\n      // in between), so return a failure, and let the caller retry.\n      assert(requestedSize > oldSize);\n  \n      // Memory resize rules:\n      // 1.  Always increase heap size to at least the requested size, rounded up\n      //     to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n      //     geometrically: increase the heap size according to\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n      //     linearly: increase the heap size by at least\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4.  If we were unable to allocate as much memory, it may be due to\n      //     over-eager decision to excessively reserve due to (3) above.\n      //     Hence if an allocation fails, cut down on the amount of excess\n      //     growth, in an attempt to succeed to perform a smaller allocation.\n  \n      // A limit is set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\n        return false;\n      }\n  \n      // Loop through potential heap size increases. If we attempt a too eager\n      // reservation that fails, cut down on the attempted size and reserve a\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n  \n        var replacement = growMemory(newSize);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n      return false;\n    };\n\n  var SYSCALLS = {\n  varargs:undefined,\n  getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n  };\n  var _fd_close = (fd) => {\n      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');\n    };\n\n  function _fd_seek(fd,offset_low, offset_high,whence,newOffset) {\n    var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  \n    \n      return 70;\n    ;\n  }\n\n  var printCharBuffers = [null,[],[]];\n  \n  var printChar = (stream, curr) => {\n      var buffer = printCharBuffers[stream];\n      assert(buffer);\n      if (curr === 0 || curr === 10) {\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n        buffer.length = 0;\n      } else {\n        buffer.push(curr);\n      }\n    };\n  \n  var flush_NO_FILESYSTEM = () => {\n      // flush anything remaining in the buffers during shutdown\n      _fflush(0);\n      if (printCharBuffers[1].length) printChar(1, 10);\n      if (printCharBuffers[2].length) printChar(2, 10);\n    };\n  \n  \n  var _fd_write = (fd, iov, iovcnt, pnum) => {\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        for (var j = 0; j < len; j++) {\n          printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    };\n\n  var runAndAbortIfError = (func) => {\n      try {\n        return func();\n      } catch (e) {\n        abort(e);\n      }\n    };\n  \n  var handleException = (e) => {\n      // Certain exception types we do not treat as errors since they are used for\n      // internal control flow.\n      // 1. ExitStatus, which is thrown by exit()\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n      //    that wish to return to JS event loop.\n      if (e instanceof ExitStatus || e == 'unwind') {\n        return EXITSTATUS;\n      }\n      checkStackCookie();\n      if (e instanceof WebAssembly.RuntimeError) {\n        if (_emscripten_stack_get_current() <= 0) {\n          err('Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 5242880)');\n        }\n      }\n      quit_(1, e);\n    };\n  \n  \n  var runtimeKeepaliveCounter = 0;\n  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\n  var _proc_exit = (code) => {\n      EXITSTATUS = code;\n      if (!keepRuntimeAlive()) {\n        Module['onExit']?.(code);\n        ABORT = true;\n      }\n      quit_(code, new ExitStatus(code));\n    };\n  \n  /** @suppress {duplicate } */\n  /** @param {boolean|number=} implicit */\n  var exitJS = (status, implicit) => {\n      EXITSTATUS = status;\n  \n      checkUnflushedContent();\n  \n      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\n      if (keepRuntimeAlive() && !implicit) {\n        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\n        readyPromiseReject(msg);\n        err(msg);\n      }\n  \n      _proc_exit(status);\n    };\n  var _exit = exitJS;\n  \n  \n  var maybeExit = () => {\n      if (!keepRuntimeAlive()) {\n        try {\n          _exit(EXITSTATUS);\n        } catch (e) {\n          handleException(e);\n        }\n      }\n    };\n  var callUserCallback = (func) => {\n      if (ABORT) {\n        err('user callback triggered after runtime exited or application aborted.  Ignoring.');\n        return;\n      }\n      try {\n        func();\n        maybeExit();\n      } catch (e) {\n        handleException(e);\n      }\n    };\n  \n  var sigToWasmTypes = (sig) => {\n      assert(!sig.includes('j'), 'i64 not permitted in function signatures when WASM_BIGINT is disabled');\n      var typeNames = {\n        'i': 'i32',\n        'j': 'i64',\n        'f': 'f32',\n        'd': 'f64',\n        'e': 'externref',\n        'p': 'i32',\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        assert(sig[i] in typeNames, 'invalid signature char: ' + sig[i]);\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    };\n  \n  var runtimeKeepalivePush = () => {\n      runtimeKeepaliveCounter += 1;\n    };\n  \n  var runtimeKeepalivePop = () => {\n      assert(runtimeKeepaliveCounter > 0);\n      runtimeKeepaliveCounter -= 1;\n    };\n  \n  \n  var Asyncify = {\n  instrumentWasmImports(imports) {\n        var importPattern = /^(qts_host_call_function|qts_host_load_module_source|qts_host_normalize_module|invoke_.*|__asyncjs__.*)$/;\n  \n        for (let [x, original] of Object.entries(imports)) {\n          if (typeof original == 'function') {\n            let isAsyncifyImport = original.isAsync || importPattern.test(x);\n            imports[x] = (...args) => {\n              var originalAsyncifyState = Asyncify.state;\n              try {\n                return original(...args);\n              } finally {\n                // Only asyncify-declared imports are allowed to change the\n                // state.\n                // Changing the state from normal to disabled is allowed (in any\n                // function) as that is what shutdown does (and we don't have an\n                // explicit list of shutdown imports).\n                var changedToDisabled =\n                      originalAsyncifyState === Asyncify.State.Normal &&\n                      Asyncify.state        === Asyncify.State.Disabled;\n                // invoke_* functions are allowed to change the state if we do\n                // not ignore indirect calls.\n                var ignoredInvoke = x.startsWith('invoke_') &&\n                                    true;\n                if (Asyncify.state !== originalAsyncifyState &&\n                    !isAsyncifyImport &&\n                    !changedToDisabled &&\n                    !ignoredInvoke) {\n                  throw new Error(`import ${x} was not in ASYNCIFY_IMPORTS, but changed the state`);\n                }\n              }\n            };\n          }\n        }\n      },\n  instrumentWasmExports(exports) {\n        var ret = {};\n        for (let [x, original] of Object.entries(exports)) {\n          if (typeof original == 'function') {\n            ret[x] = (...args) => {\n              Asyncify.exportCallStack.push(x);\n              try {\n                return original(...args);\n              } finally {\n                if (!ABORT) {\n                  var y = Asyncify.exportCallStack.pop();\n                  assert(y === x);\n                  Asyncify.maybeStopUnwind();\n                }\n              }\n            };\n          } else {\n            ret[x] = original;\n          }\n        }\n        return ret;\n      },\n  State:{\n  Normal:0,\n  Unwinding:1,\n  Rewinding:2,\n  Disabled:3,\n  },\n  state:0,\n  StackSize:81920,\n  currData:null,\n  handleSleepReturnValue:0,\n  exportCallStack:[],\n  callStackNameToId:{\n  },\n  callStackIdToName:{\n  },\n  callStackId:0,\n  asyncPromiseHandlers:null,\n  sleepCallbacks:[],\n  getCallStackId(funcName) {\n        var id = Asyncify.callStackNameToId[funcName];\n        if (id === undefined) {\n          id = Asyncify.callStackId++;\n          Asyncify.callStackNameToId[funcName] = id;\n          Asyncify.callStackIdToName[id] = funcName;\n        }\n        return id;\n      },\n  maybeStopUnwind() {\n        if (Asyncify.currData &&\n            Asyncify.state === Asyncify.State.Unwinding &&\n            Asyncify.exportCallStack.length === 0) {\n          // We just finished unwinding.\n          // Be sure to set the state before calling any other functions to avoid\n          // possible infinite recursion here (For example in debug pthread builds\n          // the dbg() function itself can call back into WebAssembly to get the\n          // current pthread_self() pointer).\n          Asyncify.state = Asyncify.State.Normal;\n          \n          // Keep the runtime alive so that a re-wind can be done later.\n          runAndAbortIfError(_asyncify_stop_unwind);\n          if (typeof Fibers != 'undefined') {\n            Fibers.trampoline();\n          }\n        }\n      },\n  whenDone() {\n        assert(Asyncify.currData, 'Tried to wait for an async operation when none is in progress.');\n        assert(!Asyncify.asyncPromiseHandlers, 'Cannot have multiple async operations in flight at once');\n        return new Promise((resolve, reject) => {\n          Asyncify.asyncPromiseHandlers = { resolve, reject };\n        });\n      },\n  allocateData() {\n        // An asyncify data structure has three fields:\n        //  0  current stack pos\n        //  4  max stack pos\n        //  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)\n        //\n        // The Asyncify ABI only interprets the first two fields, the rest is for the runtime.\n        // We also embed a stack in the same memory region here, right next to the structure.\n        // This struct is also defined as asyncify_data_t in emscripten/fiber.h\n        var ptr = _malloc(12 + Asyncify.StackSize);\n        Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);\n        Asyncify.setDataRewindFunc(ptr);\n        return ptr;\n      },\n  setDataHeader(ptr, stack, stackSize) {\n        HEAPU32[((ptr)>>2)] = stack;\n        HEAPU32[(((ptr)+(4))>>2)] = stack + stackSize;\n      },\n  setDataRewindFunc(ptr) {\n        var bottomOfCallStack = Asyncify.exportCallStack[0];\n        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);\n        HEAP32[(((ptr)+(8))>>2)] = rewindId;\n      },\n  getDataRewindFuncName(ptr) {\n        var id = HEAP32[(((ptr)+(8))>>2)];\n        var name = Asyncify.callStackIdToName[id];\n        return name;\n      },\n  getDataRewindFunc(name) {\n        var func = wasmExports[name];\n        return func;\n      },\n  doRewind(ptr) {\n        var name = Asyncify.getDataRewindFuncName(ptr);\n        var func = Asyncify.getDataRewindFunc(name);\n        // Once we have rewound and the stack we no longer need to artificially\n        // keep the runtime alive.\n        \n        return func();\n      },\n  handleSleep(startAsync) {\n        assert(Asyncify.state !== Asyncify.State.Disabled, 'Asyncify cannot be done during or after the runtime exits');\n        if (ABORT) return;\n        if (Asyncify.state === Asyncify.State.Normal) {\n          // Prepare to sleep. Call startAsync, and see what happens:\n          // if the code decided to call our callback synchronously,\n          // then no async operation was in fact begun, and we don't\n          // need to do anything.\n          var reachedCallback = false;\n          var reachedAfterCallback = false;\n          startAsync((handleSleepReturnValue = 0) => {\n            assert(!handleSleepReturnValue || typeof handleSleepReturnValue == 'number' || typeof handleSleepReturnValue == 'boolean'); // old emterpretify API supported other stuff\n            if (ABORT) return;\n            Asyncify.handleSleepReturnValue = handleSleepReturnValue;\n            reachedCallback = true;\n            if (!reachedAfterCallback) {\n              // We are happening synchronously, so no need for async.\n              return;\n            }\n            // This async operation did not happen synchronously, so we did\n            // unwind. In that case there can be no compiled code on the stack,\n            // as it might break later operations (we can rewind ok now, but if\n            // we unwind again, we would unwind through the extra compiled code\n            // too).\n            assert(!Asyncify.exportCallStack.length, 'Waking up (starting to rewind) must be done from JS, without compiled code on the stack.');\n            Asyncify.state = Asyncify.State.Rewinding;\n            runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));\n            if (typeof Browser != 'undefined' && Browser.mainLoop.func) {\n              Browser.mainLoop.resume();\n            }\n            var asyncWasmReturnValue, isError = false;\n            try {\n              asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);\n            } catch (err) {\n              asyncWasmReturnValue = err;\n              isError = true;\n            }\n            // Track whether the return value was handled by any promise handlers.\n            var handled = false;\n            if (!Asyncify.currData) {\n              // All asynchronous execution has finished.\n              // `asyncWasmReturnValue` now contains the final\n              // return value of the exported async WASM function.\n              //\n              // Note: `asyncWasmReturnValue` is distinct from\n              // `Asyncify.handleSleepReturnValue`.\n              // `Asyncify.handleSleepReturnValue` contains the return\n              // value of the last C function to have executed\n              // `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`\n              // contains the return value of the exported WASM function\n              // that may have called C functions that\n              // call `Asyncify.handleSleep()`.\n              var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;\n              if (asyncPromiseHandlers) {\n                Asyncify.asyncPromiseHandlers = null;\n                (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);\n                handled = true;\n              }\n            }\n            if (isError && !handled) {\n              // If there was an error and it was not handled by now, we have no choice but to\n              // rethrow that error into the global scope where it can be caught only by\n              // `onerror` or `onunhandledpromiserejection`.\n              throw asyncWasmReturnValue;\n            }\n          });\n          reachedAfterCallback = true;\n          if (!reachedCallback) {\n            // A true async operation was begun; start a sleep.\n            Asyncify.state = Asyncify.State.Unwinding;\n            // TODO: reuse, don't alloc/free every sleep\n            Asyncify.currData = Asyncify.allocateData();\n            if (typeof Browser != 'undefined' && Browser.mainLoop.func) {\n              Browser.mainLoop.pause();\n            }\n            runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));\n          }\n        } else if (Asyncify.state === Asyncify.State.Rewinding) {\n          // Stop a resume.\n          Asyncify.state = Asyncify.State.Normal;\n          runAndAbortIfError(_asyncify_stop_rewind);\n          _free(Asyncify.currData);\n          Asyncify.currData = null;\n          // Call all sleep callbacks now that the sleep-resume is all done.\n          Asyncify.sleepCallbacks.forEach(callUserCallback);\n        } else {\n          abort(`invalid state: ${Asyncify.state}`);\n        }\n        return Asyncify.handleSleepReturnValue;\n      },\n  handleAsync(startAsync) {\n        return Asyncify.handleSleep((wakeUp) => {\n          // TODO: add error handling as a second param when handleSleep implements it.\n          startAsync().then(wakeUp);\n        });\n      },\n  };\n\n  var getCFunc = (ident) => {\n      var func = Module['_' + ident]; // closure exported function\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    };\n  \n  \n  var writeArrayToMemory = (array, buffer) => {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n      HEAP8.set(array, buffer);\n    };\n  \n  \n  \n  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n  var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n  \n  \n  \n  \n  \n  \n  \n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n  var ccall = (ident, returnType, argTypes, args, opts) => {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) { // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        'array': (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n  \n      function convertReturnValue(ret) {\n        if (returnType === 'string') {\n          \n          return UTF8ToString(ret);\n        }\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n  \n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      // Data for a previous async operation that was in flight before us.\n      var previousAsync = Asyncify.currData;\n      var ret = func(...cArgs);\n      function onDone(ret) {\n        runtimeKeepalivePop();\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n    var asyncMode = opts?.async;\n  \n      // Keep the runtime alive through all calls. Note that this call might not be\n      // async, but for simplicity we push and pop in all calls.\n      runtimeKeepalivePush();\n      if (Asyncify.currData != previousAsync) {\n        // A change in async operation happened. If there was already an async\n        // operation in flight before us, that is an error: we should not start\n        // another async operation while one is active, and we should not stop one\n        // either. The only valid combination is to have no change in the async\n        // data (so we either had one in flight and left it alone, or we didn't have\n        // one), or to have nothing in flight and to start one.\n        assert(!(previousAsync && Asyncify.currData), 'We cannot start an async operation when one is already flight');\n        assert(!(previousAsync && !Asyncify.currData), 'We cannot stop an async operation in flight');\n        // This is a new async operation. The wasm is paused and has unwound its stack.\n        // We need to return a Promise that resolves the return value\n        // once the stack is rewound and execution finishes.\n        assert(asyncMode, 'The call to ' + ident + ' is running asynchronously. If this was intended, add the async option to the ccall/cwrap call.');\n        return Asyncify.whenDone().then(onDone);\n      }\n  \n      ret = onDone(ret);\n      // If this is an async ccall, ensure we return a promise\n      if (asyncMode) return Promise.resolve(ret);\n      return ret;\n    };\n  \n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n  var cwrap = (ident, returnType, argTypes, opts) => {\n      return (...args) => ccall(ident, returnType, argTypes, args, opts);\n    };\n\n\n\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\nvar wasmImports = {\n  /** @export */\n  __assert_fail: ___assert_fail,\n  /** @export */\n  _abort_js: __abort_js,\n  /** @export */\n  _emscripten_memcpy_js: __emscripten_memcpy_js,\n  /** @export */\n  _localtime_js: __localtime_js,\n  /** @export */\n  _tzset_js: __tzset_js,\n  /** @export */\n  emscripten_date_now: _emscripten_date_now,\n  /** @export */\n  emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */\n  fd_close: _fd_close,\n  /** @export */\n  fd_seek: _fd_seek,\n  /** @export */\n  fd_write: _fd_write,\n  /** @export */\n  memory: wasmMemory,\n  /** @export */\n  qts_host_call_function,\n  /** @export */\n  qts_host_interrupt_handler,\n  /** @export */\n  qts_host_load_module_source,\n  /** @export */\n  qts_host_normalize_module,\n  /** @export */\n  set_asyncify_stack_size\n};\nvar wasmExports = createWasm();\nvar ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);\nvar _malloc = Module['_malloc'] = createExportWrapper('malloc', 1);\nvar _QTS_Throw = Module['_QTS_Throw'] = createExportWrapper('QTS_Throw', 2);\nvar _QTS_NewError = Module['_QTS_NewError'] = createExportWrapper('QTS_NewError', 1);\nvar _QTS_RuntimeSetMemoryLimit = Module['_QTS_RuntimeSetMemoryLimit'] = createExportWrapper('QTS_RuntimeSetMemoryLimit', 2);\nvar _QTS_RuntimeComputeMemoryUsage = Module['_QTS_RuntimeComputeMemoryUsage'] = createExportWrapper('QTS_RuntimeComputeMemoryUsage', 2);\nvar _QTS_RuntimeDumpMemoryUsage = Module['_QTS_RuntimeDumpMemoryUsage'] = createExportWrapper('QTS_RuntimeDumpMemoryUsage', 1);\nvar _QTS_RecoverableLeakCheck = Module['_QTS_RecoverableLeakCheck'] = createExportWrapper('QTS_RecoverableLeakCheck', 0);\nvar _QTS_BuildIsSanitizeLeak = Module['_QTS_BuildIsSanitizeLeak'] = createExportWrapper('QTS_BuildIsSanitizeLeak', 0);\nvar _QTS_RuntimeSetMaxStackSize = Module['_QTS_RuntimeSetMaxStackSize'] = createExportWrapper('QTS_RuntimeSetMaxStackSize', 2);\nvar _QTS_GetUndefined = Module['_QTS_GetUndefined'] = createExportWrapper('QTS_GetUndefined', 0);\nvar _QTS_GetNull = Module['_QTS_GetNull'] = createExportWrapper('QTS_GetNull', 0);\nvar _QTS_GetFalse = Module['_QTS_GetFalse'] = createExportWrapper('QTS_GetFalse', 0);\nvar _QTS_GetTrue = Module['_QTS_GetTrue'] = createExportWrapper('QTS_GetTrue', 0);\nvar _QTS_NewRuntime = Module['_QTS_NewRuntime'] = createExportWrapper('QTS_NewRuntime', 0);\nvar _QTS_FreeRuntime = Module['_QTS_FreeRuntime'] = createExportWrapper('QTS_FreeRuntime', 1);\nvar _free = Module['_free'] = createExportWrapper('free', 1);\nvar _QTS_NewContext = Module['_QTS_NewContext'] = createExportWrapper('QTS_NewContext', 2);\nvar _QTS_FreeContext = Module['_QTS_FreeContext'] = createExportWrapper('QTS_FreeContext', 1);\nvar _QTS_FreeValuePointer = Module['_QTS_FreeValuePointer'] = createExportWrapper('QTS_FreeValuePointer', 2);\nvar _QTS_FreeValuePointerRuntime = Module['_QTS_FreeValuePointerRuntime'] = createExportWrapper('QTS_FreeValuePointerRuntime', 2);\nvar _QTS_FreeVoidPointer = Module['_QTS_FreeVoidPointer'] = createExportWrapper('QTS_FreeVoidPointer', 2);\nvar _QTS_FreeCString = Module['_QTS_FreeCString'] = createExportWrapper('QTS_FreeCString', 2);\nvar _QTS_DupValuePointer = Module['_QTS_DupValuePointer'] = createExportWrapper('QTS_DupValuePointer', 2);\nvar _QTS_NewObject = Module['_QTS_NewObject'] = createExportWrapper('QTS_NewObject', 1);\nvar _QTS_NewObjectProto = Module['_QTS_NewObjectProto'] = createExportWrapper('QTS_NewObjectProto', 2);\nvar _QTS_NewArray = Module['_QTS_NewArray'] = createExportWrapper('QTS_NewArray', 1);\nvar _QTS_NewArrayBuffer = Module['_QTS_NewArrayBuffer'] = createExportWrapper('QTS_NewArrayBuffer', 3);\nvar _QTS_NewFloat64 = Module['_QTS_NewFloat64'] = createExportWrapper('QTS_NewFloat64', 2);\nvar _QTS_GetFloat64 = Module['_QTS_GetFloat64'] = createExportWrapper('QTS_GetFloat64', 2);\nvar _QTS_NewString = Module['_QTS_NewString'] = createExportWrapper('QTS_NewString', 2);\nvar _QTS_GetString = Module['_QTS_GetString'] = createExportWrapper('QTS_GetString', 2);\nvar _QTS_GetArrayBuffer = Module['_QTS_GetArrayBuffer'] = createExportWrapper('QTS_GetArrayBuffer', 2);\nvar _QTS_GetArrayBufferLength = Module['_QTS_GetArrayBufferLength'] = createExportWrapper('QTS_GetArrayBufferLength', 2);\nvar _QTS_NewSymbol = Module['_QTS_NewSymbol'] = createExportWrapper('QTS_NewSymbol', 3);\nvar _QTS_GetSymbolDescriptionOrKey = Module['_QTS_GetSymbolDescriptionOrKey'] = createExportWrapper('QTS_GetSymbolDescriptionOrKey', 2);\nvar _QTS_IsGlobalSymbol = Module['_QTS_IsGlobalSymbol'] = createExportWrapper('QTS_IsGlobalSymbol', 2);\nvar _QTS_IsJobPending = Module['_QTS_IsJobPending'] = createExportWrapper('QTS_IsJobPending', 1);\nvar _QTS_ExecutePendingJob = Module['_QTS_ExecutePendingJob'] = createExportWrapper('QTS_ExecutePendingJob', 3);\nvar _QTS_GetProp = Module['_QTS_GetProp'] = createExportWrapper('QTS_GetProp', 3);\nvar _QTS_GetPropNumber = Module['_QTS_GetPropNumber'] = createExportWrapper('QTS_GetPropNumber', 3);\nvar _QTS_SetProp = Module['_QTS_SetProp'] = createExportWrapper('QTS_SetProp', 4);\nvar _QTS_DefineProp = Module['_QTS_DefineProp'] = createExportWrapper('QTS_DefineProp', 9);\nvar _QTS_GetOwnPropertyNames = Module['_QTS_GetOwnPropertyNames'] = createExportWrapper('QTS_GetOwnPropertyNames', 5);\nvar _QTS_Call = Module['_QTS_Call'] = createExportWrapper('QTS_Call', 5);\nvar _QTS_ResolveException = Module['_QTS_ResolveException'] = createExportWrapper('QTS_ResolveException', 2);\nvar _QTS_Dump = Module['_QTS_Dump'] = createExportWrapper('QTS_Dump', 2);\nvar _QTS_Eval = Module['_QTS_Eval'] = createExportWrapper('QTS_Eval', 6);\nvar _QTS_GetModuleNamespace = Module['_QTS_GetModuleNamespace'] = createExportWrapper('QTS_GetModuleNamespace', 2);\nvar _QTS_Typeof = Module['_QTS_Typeof'] = createExportWrapper('QTS_Typeof', 2);\nvar _QTS_GetLength = Module['_QTS_GetLength'] = createExportWrapper('QTS_GetLength', 3);\nvar _QTS_IsEqual = Module['_QTS_IsEqual'] = createExportWrapper('QTS_IsEqual', 4);\nvar _QTS_GetGlobalObject = Module['_QTS_GetGlobalObject'] = createExportWrapper('QTS_GetGlobalObject', 1);\nvar _QTS_NewPromiseCapability = Module['_QTS_NewPromiseCapability'] = createExportWrapper('QTS_NewPromiseCapability', 2);\nvar _QTS_PromiseState = Module['_QTS_PromiseState'] = createExportWrapper('QTS_PromiseState', 2);\nvar _QTS_PromiseResult = Module['_QTS_PromiseResult'] = createExportWrapper('QTS_PromiseResult', 2);\nvar _QTS_TestStringArg = Module['_QTS_TestStringArg'] = createExportWrapper('QTS_TestStringArg', 1);\nvar _QTS_GetDebugLogEnabled = Module['_QTS_GetDebugLogEnabled'] = createExportWrapper('QTS_GetDebugLogEnabled', 1);\nvar _QTS_SetDebugLogEnabled = Module['_QTS_SetDebugLogEnabled'] = createExportWrapper('QTS_SetDebugLogEnabled', 2);\nvar _QTS_BuildIsDebug = Module['_QTS_BuildIsDebug'] = createExportWrapper('QTS_BuildIsDebug', 0);\nvar _QTS_BuildIsAsyncify = Module['_QTS_BuildIsAsyncify'] = createExportWrapper('QTS_BuildIsAsyncify', 0);\nvar _QTS_NewFunction = Module['_QTS_NewFunction'] = createExportWrapper('QTS_NewFunction', 3);\nvar _QTS_ArgvGetJSValueConstPointer = Module['_QTS_ArgvGetJSValueConstPointer'] = createExportWrapper('QTS_ArgvGetJSValueConstPointer', 2);\nvar _QTS_RuntimeEnableInterruptHandler = Module['_QTS_RuntimeEnableInterruptHandler'] = createExportWrapper('QTS_RuntimeEnableInterruptHandler', 1);\nvar _QTS_RuntimeDisableInterruptHandler = Module['_QTS_RuntimeDisableInterruptHandler'] = createExportWrapper('QTS_RuntimeDisableInterruptHandler', 1);\nvar _QTS_RuntimeEnableModuleLoader = Module['_QTS_RuntimeEnableModuleLoader'] = createExportWrapper('QTS_RuntimeEnableModuleLoader', 2);\nvar _QTS_RuntimeDisableModuleLoader = Module['_QTS_RuntimeDisableModuleLoader'] = createExportWrapper('QTS_RuntimeDisableModuleLoader', 1);\nvar _QTS_bjson_encode = Module['_QTS_bjson_encode'] = createExportWrapper('QTS_bjson_encode', 2);\nvar _QTS_bjson_decode = Module['_QTS_bjson_decode'] = createExportWrapper('QTS_bjson_decode', 2);\nvar _fflush = createExportWrapper('fflush', 1);\nvar _strerror = createExportWrapper('strerror', 1);\nvar __emscripten_tempret_set = createExportWrapper('_emscripten_tempret_set', 1);\nvar _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\nvar _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();\nvar _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();\nvar _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\nvar __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\nvar __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\nvar _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\nvar dynCall_viii = Module['dynCall_viii'] = createExportWrapper('dynCall_viii', 4);\nvar dynCall_jijiiii = Module['dynCall_jijiiii'] = createExportWrapper('dynCall_jijiiii', 8);\nvar dynCall_jijiii = Module['dynCall_jijiii'] = createExportWrapper('dynCall_jijiii', 7);\nvar dynCall_iii = Module['dynCall_iii'] = createExportWrapper('dynCall_iii', 3);\nvar dynCall_iiiii = Module['dynCall_iiiii'] = createExportWrapper('dynCall_iiiii', 5);\nvar dynCall_iiii = Module['dynCall_iiii'] = createExportWrapper('dynCall_iiii', 4);\nvar dynCall_ii = Module['dynCall_ii'] = createExportWrapper('dynCall_ii', 2);\nvar dynCall_jiij = Module['dynCall_jiij'] = createExportWrapper('dynCall_jiij', 5);\nvar dynCall_iiiijj = Module['dynCall_iiiijj'] = createExportWrapper('dynCall_iiiijj', 8);\nvar dynCall_iiiij = Module['dynCall_iiiij'] = createExportWrapper('dynCall_iiiij', 6);\nvar dynCall_jiiiii = Module['dynCall_jiiiii'] = createExportWrapper('dynCall_jiiiii', 6);\nvar dynCall_jij = Module['dynCall_jij'] = createExportWrapper('dynCall_jij', 4);\nvar dynCall_jijjiii = Module['dynCall_jijjiii'] = createExportWrapper('dynCall_jijjiii', 9);\nvar dynCall_vii = Module['dynCall_vii'] = createExportWrapper('dynCall_vii', 3);\nvar dynCall_jiii = Module['dynCall_jiii'] = createExportWrapper('dynCall_jiii', 4);\nvar dynCall_jijii = Module['dynCall_jijii'] = createExportWrapper('dynCall_jijii', 6);\nvar dynCall_jijiiiii = Module['dynCall_jijiiiii'] = createExportWrapper('dynCall_jijiiiii', 9);\nvar dynCall_jijj = Module['dynCall_jijj'] = createExportWrapper('dynCall_jijj', 6);\nvar dynCall_viji = Module['dynCall_viji'] = createExportWrapper('dynCall_viji', 5);\nvar dynCall_vij = Module['dynCall_vij'] = createExportWrapper('dynCall_vij', 4);\nvar dynCall_iiijj = Module['dynCall_iiijj'] = createExportWrapper('dynCall_iiijj', 7);\nvar dynCall_iijijjji = Module['dynCall_iijijjji'] = createExportWrapper('dynCall_iijijjji', 12);\nvar dynCall_iiiji = Module['dynCall_iiiji'] = createExportWrapper('dynCall_iiiji', 6);\nvar dynCall_iiji = Module['dynCall_iiji'] = createExportWrapper('dynCall_iiji', 5);\nvar dynCall_jijij = Module['dynCall_jijij'] = createExportWrapper('dynCall_jijij', 7);\nvar dynCall_iijijji = Module['dynCall_iijijji'] = createExportWrapper('dynCall_iijijji', 10);\nvar dynCall_jiiii = Module['dynCall_jiiii'] = createExportWrapper('dynCall_jiiii', 5);\nvar dynCall_jiji = Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji', 5);\nvar dynCall_jijji = Module['dynCall_jijji'] = createExportWrapper('dynCall_jijji', 7);\nvar dynCall_dd = Module['dynCall_dd'] = createExportWrapper('dynCall_dd', 2);\nvar dynCall_ddd = Module['dynCall_ddd'] = createExportWrapper('dynCall_ddd', 3);\nvar dynCall_jii = Module['dynCall_jii'] = createExportWrapper('dynCall_jii', 3);\nvar dynCall_iiiiii = Module['dynCall_iiiiii'] = createExportWrapper('dynCall_iiiiii', 6);\nvar dynCall_iidiiii = Module['dynCall_iidiiii'] = createExportWrapper('dynCall_iidiiii', 7);\nvar _asyncify_start_unwind = createExportWrapper('asyncify_start_unwind', 1);\nvar _asyncify_stop_unwind = createExportWrapper('asyncify_stop_unwind', 0);\nvar _asyncify_start_rewind = createExportWrapper('asyncify_start_rewind', 1);\nvar _asyncify_stop_rewind = createExportWrapper('asyncify_stop_rewind', 0);\n\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\n\nModule['cwrap'] = cwrap;\nModule['UTF8ToString'] = UTF8ToString;\nModule['stringToUTF8'] = stringToUTF8;\nModule['lengthBytesUTF8'] = lengthBytesUTF8;\nvar missingLibrarySymbols = [\n  'writeI53ToI64',\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'readI53FromI64',\n  'readI53FromU64',\n  'convertI32PairToI53',\n  'convertU32PairToI53',\n  'getTempRet0',\n  'setTempRet0',\n  'zeroMemory',\n  'strError',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'initRandomFill',\n  'randomFill',\n  'emscriptenLog',\n  'readEmAsmArgs',\n  'jstoi_q',\n  'getExecutableName',\n  'listenOnce',\n  'autoResumeAudioContext',\n  'dynCallLegacy',\n  'getDynCaller',\n  'dynCall',\n  'asmjsMangle',\n  'asyncLoad',\n  'mmapAlloc',\n  'HandleAllocator',\n  'getNativeTypeSize',\n  'STACK_SIZE',\n  'STACK_ALIGN',\n  'POINTER_SIZE',\n  'ASSERTIONS',\n  'uleb128Encode',\n  'generateFuncType',\n  'convertJsFunctionToWasm',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'getFunctionAddress',\n  'addFunction',\n  'removeFunction',\n  'reallyNegative',\n  'unSign',\n  'strLen',\n  'reSign',\n  'formatString',\n  'intArrayFromString',\n  'intArrayToString',\n  'AsciiToString',\n  'stringToAscii',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'stringToNewUTF8',\n  'registerKeyEventCallback',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerMouseEventCallback',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'battery',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'jsStackTrace',\n  'getCallstack',\n  'convertPCtoSourceLocation',\n  'getEnvStrings',\n  'checkWasiClock',\n  'wasiRightsToMuslOFlags',\n  'wasiOFlagsToMuslOFlags',\n  'createDyncallWrapper',\n  'safeSetTimeout',\n  'setImmediateWrapped',\n  'clearImmediateWrapped',\n  'polyfillSetImmediate',\n  'getPromise',\n  'makePromise',\n  'idsToPromises',\n  'makePromiseCallback',\n  'Browser_asyncPrepareDataCounter',\n  'setMainLoop',\n  'arraySum',\n  'addDays',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'FS_createPreloadedFile',\n  'FS_modeStringToFlags',\n  'FS_getMode',\n  'FS_stdin_getChar',\n  'FS_unlink',\n  'FS_createDataFile',\n  'FS_mkdirTree',\n  '_setNetworkCallback',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n  'writeStringToMemory',\n  'writeAsciiToMemory',\n  'setErrNo',\n  'stackTrace',\n];\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\n\nvar unexportedSymbols = [\n  'run',\n  'addOnPreRun',\n  'addOnInit',\n  'addOnPreMain',\n  'addOnExit',\n  'addOnPostRun',\n  'addRunDependency',\n  'removeRunDependency',\n  'out',\n  'err',\n  'callMain',\n  'abort',\n  'wasmMemory',\n  'wasmExports',\n  'writeStackCookie',\n  'checkStackCookie',\n  'convertI32PairToI53Checked',\n  'stackSave',\n  'stackRestore',\n  'stackAlloc',\n  'ptrToString',\n  'exitJS',\n  'getHeapMax',\n  'growMemory',\n  'ENV',\n  'ERRNO_CODES',\n  'DNS',\n  'Protocols',\n  'Sockets',\n  'timers',\n  'warnOnce',\n  'readEmAsmArgsArray',\n  'jstoi_s',\n  'handleException',\n  'keepRuntimeAlive',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'callUserCallback',\n  'maybeExit',\n  'alignMemory',\n  'wasmTable',\n  'noExitRuntime',\n  'getCFunc',\n  'ccall',\n  'sigToWasmTypes',\n  'freeTableIndexes',\n  'functionsInTableMap',\n  'setValue',\n  'getValue',\n  'PATH',\n  'PATH_FS',\n  'UTF8Decoder',\n  'UTF8ArrayToString',\n  'stringToUTF8Array',\n  'UTF16Decoder',\n  'stringToUTF8OnStack',\n  'writeArrayToMemory',\n  'JSEvents',\n  'specialHTMLTargets',\n  'findCanvasEventTarget',\n  'currentFullscreenStrategy',\n  'restoreOldWindowedStyle',\n  'UNWIND_CACHE',\n  'ExitStatus',\n  'flush_NO_FILESYSTEM',\n  'promiseMap',\n  'Browser',\n  'getPreloadedImageData__data',\n  'wget',\n  'MONTH_DAYS_REGULAR',\n  'MONTH_DAYS_LEAP',\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\n  'MONTH_DAYS_LEAP_CUMULATIVE',\n  'isLeapYear',\n  'ydayFromDate',\n  'SYSCALLS',\n  'preloadPlugins',\n  'FS_stdin_getChar_buffer',\n  'FS_createPath',\n  'FS_createDevice',\n  'FS_readFile',\n  'FS',\n  'FS_createLazyFile',\n  'MEMFS',\n  'TTY',\n  'PIPEFS',\n  'SOCKFS',\n  'runAndAbortIfError',\n  'Asyncify',\n  'Fibers',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'print',\n  'printErr',\n];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n\n\nvar calledRun;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\n\nfunction run() {\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n    stackCheckInit();\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    readyPromiseResolve(Module);\n    Module['onRuntimeInitialized']?.();\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = (x) => {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    flush_NO_FILESYSTEM();\n  } catch(e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\n  }\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nrun();\n\n// end include: postamble.js\n\n// include: postamble_modularize.js\n// In MODULARIZE mode we wrap the generated code in a factory function\n// and return either the Module itself, or a promise of the module.\n//\n// We assign to the `moduleRtn` global here and configure closure to see\n// this as and extern so it won't get minified.\n\nmoduleRtn = readyPromise;\n\n// Assertion for attempting to access module properties on the incoming\n// moduleArg.  In the past we used this object as the prototype of the module\n// and assigned properties to it, but now we return a distinct object.  This\n// keeps the instance private until it is ready (i.e the promise has been\n// resolved).\nfor (const prop of Object.keys(Module)) {\n  if (!(prop in moduleArg)) {\n    Object.defineProperty(moduleArg, prop, {\n      configurable: true,\n      get() {\n        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`)\n      }\n    });\n  }\n}\n// end include: postamble_modularize.js\n\n\n\n  return moduleRtn;\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuickJSRaw);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aaml0bC9xdWlja2pzLXdhc21maWxlLWRlYnVnLWFzeW5jaWZ5L2Rpc3QvZW1zY3JpcHRlbi1tb2R1bGUuYnJvd3Nlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7QUFDQSxvQkFBb0IsbUtBQWU7QUFDbkM7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLHVCQUF1QixPQUFPLGdDQUFnQyxPQUFPO0FBQzdHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLDhEQUE4RDtBQUNoSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGppdGxcXHF1aWNranMtd2FzbWZpbGUtZGVidWctYXN5bmNpZnlcXGRpc3RcXGVtc2NyaXB0ZW4tbW9kdWxlLmJyb3dzZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIFF1aWNrSlNSYXcgPSAoKCkgPT4ge1xuICB2YXIgX3NjcmlwdE5hbWUgPSBpbXBvcnQubWV0YS51cmw7XG4gIFxuICByZXR1cm4gKFxuZnVuY3Rpb24obW9kdWxlQXJnID0ge30pIHtcbiAgdmFyIG1vZHVsZVJ0bjtcblxuLy8gaW5jbHVkZTogc2hlbGwuanNcbi8vIFRoZSBNb2R1bGUgb2JqZWN0OiBPdXIgaW50ZXJmYWNlIHRvIHRoZSBvdXRzaWRlIHdvcmxkLiBXZSBpbXBvcnRcbi8vIGFuZCBleHBvcnQgdmFsdWVzIG9uIGl0LiBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIE1vZHVsZSBjYW4gYmUgdXNlZDpcbi8vIDEuIE5vdCBkZWZpbmVkLiBXZSBjcmVhdGUgaXQgaGVyZVxuLy8gMi4gQSBmdW5jdGlvbiBwYXJhbWV0ZXIsIGZ1bmN0aW9uKG1vZHVsZUFyZykgPT4gUHJvbWlzZTxNb2R1bGU+XG4vLyAzLiBwcmUtcnVuIGFwcGVuZGVkIGl0LCB2YXIgTW9kdWxlID0ge307IC4uZ2VuZXJhdGVkIGNvZGUuLlxuLy8gNC4gRXh0ZXJuYWwgc2NyaXB0IHRhZyBkZWZpbmVzIHZhciBNb2R1bGUuXG4vLyBXZSBuZWVkIHRvIGNoZWNrIGlmIE1vZHVsZSBhbHJlYWR5IGV4aXN0cyAoZS5nLiBjYXNlIDMgYWJvdmUpLlxuLy8gU3Vic3RpdHV0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgY29kZSBvbiBsYXRlciBzdGFnZSBvZiB0aGUgYnVpbGQsXG4vLyB0aGlzIHdheSBDbG9zdXJlIENvbXBpbGVyIHdpbGwgbm90IG1hbmdsZSBpdCAoZS5nLiBjYXNlIDQuIGFib3ZlKS5cbi8vIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBydW4gY2xvc3VyZSwgYW5kIGFsc28gdG8gdXNlIE1vZHVsZVxuLy8gYWZ0ZXIgdGhlIGdlbmVyYXRlZCBjb2RlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZSAgIHZhciBNb2R1bGUgPSB7fTtcbi8vIGJlZm9yZSB0aGUgY29kZS4gVGhlbiB0aGF0IG9iamVjdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNvZGUsIGFuZCB5b3Vcbi8vIGNhbiBjb250aW51ZSB0byB1c2UgTW9kdWxlIGFmdGVyd2FyZHMgYXMgd2VsbC5cbnZhciBNb2R1bGUgPSBtb2R1bGVBcmc7XG5cbi8vIFNldCB1cCB0aGUgcHJvbWlzZSB0aGF0IGluZGljYXRlcyB0aGUgTW9kdWxlIGlzIGluaXRpYWxpemVkXG52YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xudmFyIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbn0pO1xuW1wiX1FUU19UaHJvd1wiLFwiX1FUU19OZXdFcnJvclwiLFwiX1FUU19SdW50aW1lU2V0TWVtb3J5TGltaXRcIixcIl9RVFNfUnVudGltZUNvbXB1dGVNZW1vcnlVc2FnZVwiLFwiX1FUU19SdW50aW1lRHVtcE1lbW9yeVVzYWdlXCIsXCJfUVRTX1JlY292ZXJhYmxlTGVha0NoZWNrXCIsXCJfUVRTX0J1aWxkSXNTYW5pdGl6ZUxlYWtcIixcIl9RVFNfUnVudGltZVNldE1heFN0YWNrU2l6ZVwiLFwiX1FUU19HZXRVbmRlZmluZWRcIixcIl9RVFNfR2V0TnVsbFwiLFwiX1FUU19HZXRGYWxzZVwiLFwiX1FUU19HZXRUcnVlXCIsXCJfUVRTX05ld1J1bnRpbWVcIixcIl9RVFNfRnJlZVJ1bnRpbWVcIixcIl9RVFNfTmV3Q29udGV4dFwiLFwiX1FUU19GcmVlQ29udGV4dFwiLFwiX1FUU19GcmVlVmFsdWVQb2ludGVyXCIsXCJfUVRTX0ZyZWVWYWx1ZVBvaW50ZXJSdW50aW1lXCIsXCJfUVRTX0ZyZWVWb2lkUG9pbnRlclwiLFwiX1FUU19GcmVlQ1N0cmluZ1wiLFwiX1FUU19EdXBWYWx1ZVBvaW50ZXJcIixcIl9RVFNfTmV3T2JqZWN0XCIsXCJfUVRTX05ld09iamVjdFByb3RvXCIsXCJfUVRTX05ld0FycmF5XCIsXCJfUVRTX05ld0FycmF5QnVmZmVyXCIsXCJfUVRTX05ld0Zsb2F0NjRcIixcIl9RVFNfR2V0RmxvYXQ2NFwiLFwiX1FUU19OZXdTdHJpbmdcIixcIl9RVFNfR2V0U3RyaW5nXCIsXCJfUVRTX0dldEFycmF5QnVmZmVyXCIsXCJfUVRTX0dldEFycmF5QnVmZmVyTGVuZ3RoXCIsXCJfUVRTX05ld1N5bWJvbFwiLFwiX1FUU19HZXRTeW1ib2xEZXNjcmlwdGlvbk9yS2V5XCIsXCJfUVRTX0lzR2xvYmFsU3ltYm9sXCIsXCJfUVRTX0lzSm9iUGVuZGluZ1wiLFwiX1FUU19FeGVjdXRlUGVuZGluZ0pvYlwiLFwiX1FUU19HZXRQcm9wXCIsXCJfUVRTX0dldFByb3BOdW1iZXJcIixcIl9RVFNfU2V0UHJvcFwiLFwiX1FUU19EZWZpbmVQcm9wXCIsXCJfUVRTX0dldE93blByb3BlcnR5TmFtZXNcIixcIl9RVFNfQ2FsbFwiLFwiX1FUU19SZXNvbHZlRXhjZXB0aW9uXCIsXCJfUVRTX0R1bXBcIixcIl9RVFNfRXZhbFwiLFwiX1FUU19HZXRNb2R1bGVOYW1lc3BhY2VcIixcIl9RVFNfVHlwZW9mXCIsXCJfUVRTX0dldExlbmd0aFwiLFwiX1FUU19Jc0VxdWFsXCIsXCJfUVRTX0dldEdsb2JhbE9iamVjdFwiLFwiX1FUU19OZXdQcm9taXNlQ2FwYWJpbGl0eVwiLFwiX1FUU19Qcm9taXNlU3RhdGVcIixcIl9RVFNfUHJvbWlzZVJlc3VsdFwiLFwiX1FUU19UZXN0U3RyaW5nQXJnXCIsXCJfUVRTX0dldERlYnVnTG9nRW5hYmxlZFwiLFwiX1FUU19TZXREZWJ1Z0xvZ0VuYWJsZWRcIixcIl9RVFNfQnVpbGRJc0RlYnVnXCIsXCJfUVRTX0J1aWxkSXNBc3luY2lmeVwiLFwiX1FUU19OZXdGdW5jdGlvblwiLFwiX1FUU19Bcmd2R2V0SlNWYWx1ZUNvbnN0UG9pbnRlclwiLFwiX1FUU19SdW50aW1lRW5hYmxlSW50ZXJydXB0SGFuZGxlclwiLFwiX1FUU19SdW50aW1lRGlzYWJsZUludGVycnVwdEhhbmRsZXJcIixcIl9RVFNfUnVudGltZUVuYWJsZU1vZHVsZUxvYWRlclwiLFwiX1FUU19SdW50aW1lRGlzYWJsZU1vZHVsZUxvYWRlclwiLFwiX1FUU19ianNvbl9lbmNvZGVcIixcIl9RVFNfYmpzb25fZGVjb2RlXCIsXCJfbWFsbG9jXCIsXCJfZnJlZVwiLFwiX3NldF9hc3luY2lmeV9zdGFja19zaXplXCIsXCJfcXRzX2hvc3RfY2FsbF9mdW5jdGlvblwiLFwiX3F0c19ob3N0X2ludGVycnVwdF9oYW5kbGVyXCIsXCJfcXRzX2hvc3RfbG9hZF9tb2R1bGVfc291cmNlXCIsXCJfcXRzX2hvc3Rfbm9ybWFsaXplX21vZHVsZVwiLFwiX19faW5kaXJlY3RfZnVuY3Rpb25fdGFibGVcIixcIm9uUnVudGltZUluaXRpYWxpemVkXCJdLmZvckVhY2goKHByb3ApID0+IHtcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlYWR5UHJvbWlzZSwgcHJvcCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVhZHlQcm9taXNlLCBwcm9wLCB7XG4gICAgICBnZXQ6ICgpID0+IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgJyArIHByb3AgKyAnIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJyksXG4gICAgICBzZXQ6ICgpID0+IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgJyArIHByb3AgKyAnIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJyksXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBEZXRlcm1pbmUgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgd2UgYXJlIGluLiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGlzIGJ5XG4vLyBzZXR0aW5nIHRoZSBFTlZJUk9OTUVOVCBzZXR0aW5nIGF0IGNvbXBpbGUgdGltZSAoc2VlIHNldHRpbmdzLmpzKS5cblxuLy8gQXR0ZW1wdCB0byBhdXRvLWRldGVjdCB0aGUgZW52aXJvbm1lbnRcbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnO1xudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09ICdmdW5jdGlvbic7XG4vLyBOLmIuIEVsZWN0cm9uLmpzIGVudmlyb25tZW50IGlzIHNpbXVsdGFuZW91c2x5IGEgTk9ERS1lbnZpcm9ubWVudCwgYnV0XG4vLyBhbHNvIGEgd2ViIGVudmlyb25tZW50LlxudmFyIEVOVklST05NRU5UX0lTX05PREUgPSB0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09ICdzdHJpbmcnO1xudmFyIEVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG5pZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddKSB7XG4gIHRocm93IG5ldyBFcnJvcignTW9kdWxlLkVOVklST05NRU5UIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFRvIGZvcmNlIHRoZSBlbnZpcm9ubWVudCwgdXNlIHRoZSBFTlZJUk9OTUVOVCBjb21waWxlLXRpbWUgb3B0aW9uIChmb3IgZXhhbXBsZSwgLXNFTlZJUk9OTUVOVD13ZWIgb3IgLXNFTlZJUk9OTUVOVD1ub2RlKScpO1xufVxuXG4vLyAtLXByZS1qc2VzIGFyZSBlbWl0dGVkIGFmdGVyIHRoZSBNb2R1bGUgaW50ZWdyYXRpb24gY29kZSwgc28gdGhhdCB0aGV5IGNhblxuLy8gcmVmZXIgdG8gTW9kdWxlIChpZiB0aGV5IGNob29zZTsgdGhleSBjYW4gYWxzbyBkZWZpbmUgTW9kdWxlKVxuLy8gaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLWV4dGVuc2lvbi5qc1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbi8vIHF1aWNranMtZW1zY3JpcHRlbiBjb2RlIGluamVjdGVkIGludG8gZW1zY3JpcHRlbi1tb2R1bGUuanNcbi8vIFdlIHVzZSB0aGlzIHRvIGV4cG9zZSBhbmQgcGF0Y2ggdXAgaXNzdWVzIHdpdGggRW1zY3JpcHRlbidzIHNvdXJjZSBtYXAgaGFuZGxpbmcuLi5cbmZ1bmN0aW9uIHF1aWNranNFbXNjcmlwdGVuSW5pdChkZWJ1Z0xvZykge1xuICBjb25zdCBsb2cgPSBkZWJ1Z0xvZyB8fCBmdW5jdGlvbiAoKSB7fVxuICAvLyBFdmVyeXRoaW5nIGdvZXMgaW4gYSBmdW5jdGlvbiBzbyB3ZSBjYW4gZGVmZXIgcnVubmluZyB1bnRpbCBvdGhlciB2YXJpYWJsZXNcbiAgLy8gYXJlIGluaXRpYWxpemVkIGluIGNhc2UgdGhleSBjaGFuZ2UuXG4gIGNvbnN0IGV4dGVuc2lvbiA9IHsgbG9nIH1cbiAgZm9yIChjb25zdCBpbml0IG9mIHF1aWNranNFbXNjcmlwdGVuSW5pdC5pbml0cykge1xuICAgIGluaXQoZXh0ZW5zaW9uKVxuICB9XG4gIE1vZHVsZVtcInF1aWNrSlNFbXNjcmlwdGVuRXh0ZW5zaW9uc1wiXSA9IGV4dGVuc2lvblxuICByZXR1cm4gZXh0ZW5zaW9uXG59XG5xdWlja2pzRW1zY3JpcHRlbkluaXQuaW5pdHMgPSBbXVxuTW9kdWxlW1wicXVpY2tqc0Vtc2NyaXB0ZW5Jbml0XCJdID0gcXVpY2tqc0Vtc2NyaXB0ZW5Jbml0XG4vLyBlbmQgaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLWV4dGVuc2lvbi5qc1xuLy8gaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLXNvdXJjZU1hcEpzb24uanNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5xdWlja2pzRW1zY3JpcHRlbkluaXQuaW5pdHMucHVzaCgoZXh0ZW5zaW9uKSA9PiB7XG4gIGlmICh0eXBlb2YgcmVjZWl2ZVNvdXJjZU1hcEpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBleHRlbnNpb25bXCJyZWNlaXZlU291cmNlTWFwSlNPTlwiXSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdhc21Tb3VyY2VNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZXh0ZW5zaW9uLmxvZyhcInJlY2VpdmVTb3VyY2VNYXBKU09OOiByZWNlaXZlZFwiLCBkYXRhKVxuICAgICAgICByZXR1cm4gcmVjZWl2ZVNvdXJjZU1hcEpTT04oZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuc2lvbi5sb2coXCJyZWNlaXZlU291cmNlTWFwSlNPTjogYWxyZWFkeSBoYXZlIGRhdGE6XCIsIHdhc21Tb3VyY2VNYXAsIFwiaWdub3JpbmdcIiwgZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG4vLyBlbmQgaW5jbHVkZTogL1VzZXJzL2ppdGwvc3JjL3F1aWNranMtZW1zY3JpcHRlbi90ZW1wbGF0ZXMvcHJlLXNvdXJjZU1hcEpzb24uanNcbi8vIGluY2x1ZGU6IC9Vc2Vycy9qaXRsL3NyYy9xdWlja2pzLWVtc2NyaXB0ZW4vdGVtcGxhdGVzL3ByZS13YXNtT2Zmc2V0Q29udmVydGVyLmpzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xucXVpY2tqc0Vtc2NyaXB0ZW5Jbml0LmluaXRzLnB1c2goKGV4dGVuc2lvbikgPT4ge1xuICBpZiAodHlwZW9mIFdhc21PZmZzZXRDb252ZXJ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBleHRlbnNpb25bXCJXYXNtT2Zmc2V0Q29udmVydGVyXCJdID0gV2FzbU9mZnNldENvbnZlcnRlclxuICAgIC8vIEV4cG9zZSBmdW5jdGlvbiB0byByZWNlaXZlIFdhc21PZmZzZXRDb252ZXJ0ZXIsIHNldCB0byB3YXNtT2Zmc2V0Q29udmVydGVyIGxvY2FsIHZhcmlhYmxlXG4gICAgLy8gaWYgaXQgZXhpc3RzXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdhc21PZmZzZXRDb252ZXJ0ZXIgdmFyaWFibGUgZXhpc3RzLiBJZiBpdCBpc24ndCBkZWZpbmVkLCB0aGlzXG4gICAgICAvLyB3aWxsIHRocm93IGFuZCB3ZSdsbCBza2lwIHRoZSByZXN0IG9mIHRoZSBicmFuY2guXG4gICAgICBleHRlbnNpb25bXCJleGlzdGluZ1dhc21PZmZzZXRDb252ZXJ0ZXJcIl0gPSB3YXNtT2Zmc2V0Q29udmVydGVyXG4gICAgICBleHRlbnNpb25bXCJyZWNlaXZlV2FzbU9mZnNldENvbnZlcnRlclwiXSA9IGZ1bmN0aW9uICh3YXNtQmluYXJ5LCB3YXNtTW9kdWxlKSB7XG4gICAgICAgIGlmICghd2FzbU9mZnNldENvbnZlcnRlcikge1xuICAgICAgICAgIGV4dGVuc2lvbi5sb2coXCJ3YXNtT2Zmc2V0Q29udmVydGVyIHNldFwiKVxuICAgICAgICAgIHdhc21PZmZzZXRDb252ZXJ0ZXIgPSBuZXcgV2FzbU9mZnNldENvbnZlcnRlcih3YXNtQmluYXJ5LCB3YXNtTW9kdWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbi5sb2coXCJ3YXNtT2Zmc2V0Q29udmVydGVyIGFscmVhZHkgc2V0LCBpZ25vcmVkXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTm90aGluZy5cbiAgICAgIGV4dGVuc2lvbltcInJlY2VpdmVXYXNtT2Zmc2V0Q29udmVydGVyXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHRlbnNpb24ubG9nKFwid2FzbU9mZnNldENvbnZlcnRlciB2YXJpYWJsZSBub3QgZGVmaW5lZCwgdGhpcyBpcyBhIG5vLW9wXCIpXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuLy8gZW5kIGluY2x1ZGU6IC9Vc2Vycy9qaXRsL3NyYy9xdWlja2pzLWVtc2NyaXB0ZW4vdGVtcGxhdGVzL3ByZS13YXNtT2Zmc2V0Q29udmVydGVyLmpzXG4vLyBpbmNsdWRlOiAvVXNlcnMvaml0bC9zcmMvcXVpY2tqcy1lbXNjcmlwdGVuL3RlbXBsYXRlcy9wcmUtd2FzbU1lbW9yeS5qc1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbnF1aWNranNFbXNjcmlwdGVuSW5pdC5pbml0cy5wdXNoKChleHRlbnNpb24pID0+IHtcbiAgZXh0ZW5zaW9uW1wiZ2V0V2FzbU1lbW9yeVwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2FzbU1lbW9yeVxuICB9XG59KVxuLy8gZW5kIGluY2x1ZGU6IC9Vc2Vycy9qaXRsL3NyYy9xdWlja2pzLWVtc2NyaXB0ZW4vdGVtcGxhdGVzL3ByZS13YXNtTWVtb3J5LmpzXG5cblxuLy8gU29tZXRpbWVzIGFuIGV4aXN0aW5nIE1vZHVsZSBvYmplY3QgZXhpc3RzIHdpdGggcHJvcGVydGllc1xuLy8gbWVhbnQgdG8gb3ZlcndyaXRlIHRoZSBkZWZhdWx0IG1vZHVsZSBmdW5jdGlvbmFsaXR5LiBIZXJlXG4vLyB3ZSBjb2xsZWN0IHRob3NlIHByb3BlcnRpZXMgYW5kIHJlYXBwbHkgX2FmdGVyXyB3ZSBjb25maWd1cmVcbi8vIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgZGVmYXVsdHMgdG8gYXZvaWQgaGF2aW5nIHRvIGJlIHNvXG4vLyBkZWZlbnNpdmUgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxudmFyIG1vZHVsZU92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oe30sIE1vZHVsZSk7XG5cbnZhciBhcmd1bWVudHNfID0gW107XG52YXIgdGhpc1Byb2dyYW0gPSAnLi90aGlzLnByb2dyYW0nO1xudmFyIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICB0aHJvdyB0b1Rocm93O1xufTtcblxuLy8gYC9gIHNob3VsZCBiZSBwcmVzZW50IGF0IHRoZSBlbmQgaWYgYHNjcmlwdERpcmVjdG9yeWAgaXMgbm90IGVtcHR5XG52YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgcmV0dXJuIE1vZHVsZVsnbG9jYXRlRmlsZSddKHBhdGgsIHNjcmlwdERpcmVjdG9yeSk7XG4gIH1cbiAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG59XG5cbi8vIEhvb2tzIHRoYXQgYXJlIGltcGxlbWVudGVkIGRpZmZlcmVudGx5IGluIGRpZmZlcmVudCBydW50aW1lIGVudmlyb25tZW50cy5cbnZhciByZWFkQXN5bmMsIHJlYWRCaW5hcnk7XG5cbmlmIChFTlZJUk9OTUVOVF9JU19TSEVMTCkge1xuXG4gIGlmICgodHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KScpO1xuXG59IGVsc2VcblxuLy8gTm90ZSB0aGF0IHRoaXMgaW5jbHVkZXMgTm9kZS5qcyB3b3JrZXJzIHdoZW4gcmVsZXZhbnQgKHB0aHJlYWRzIGlzIGVuYWJsZWQpLlxuLy8gTm9kZS5qcyB3b3JrZXJzIGFyZSBkZXRlY3RlZCBhcyBhIGNvbWJpbmF0aW9uIG9mIEVOVklST05NRU5UX0lTX1dPUktFUiBhbmRcbi8vIEVOVklST05NRU5UX0lTX05PREUuXG5pZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7IC8vIENoZWNrIHdvcmtlciwgbm90IHdlYiwgc2luY2Ugd2luZG93IGNvdWxkIGJlIHBvbHlmaWxsZWRcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzZWxmLmxvY2F0aW9uLmhyZWY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHsgLy8gd2ViXG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gIH1cbiAgLy8gV2hlbiBNT0RVTEFSSVpFLCB0aGlzIEpTIG1heSBiZSBleGVjdXRlZCBsYXRlciwgYWZ0ZXIgZG9jdW1lbnQuY3VycmVudFNjcmlwdFxuICAvLyBpcyBnb25lLCBzbyB3ZSBzYXZlZCBpdCwgYW5kIHdlIHVzZSBpdCBoZXJlIGluc3RlYWQgb2YgYW55IG90aGVyIGluZm8uXG4gIGlmIChfc2NyaXB0TmFtZSkge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHROYW1lO1xuICB9XG4gIC8vIGJsb2IgdXJscyBsb29rIGxpa2UgYmxvYjpodHRwOi8vc2l0ZS5jb20vZXRjL2V0YyBhbmQgd2UgY2Fubm90IGluZmVyIGFueXRoaW5nIGZyb20gdGhlbS5cbiAgLy8gb3RoZXJ3aXNlLCBzbGljZSBvZmYgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHVybCB0byBmaW5kIHRoZSBzY3JpcHQgZGlyZWN0b3J5LlxuICAvLyBpZiBzY3JpcHREaXJlY3RvcnkgZG9lcyBub3QgY29udGFpbiBhIHNsYXNoLCBsYXN0SW5kZXhPZiB3aWxsIHJldHVybiAtMSxcbiAgLy8gYW5kIHNjcmlwdERpcmVjdG9yeSB3aWxsIGNvcnJlY3RseSBiZSByZXBsYWNlZCB3aXRoIGFuIGVtcHR5IHN0cmluZy5cbiAgLy8gSWYgc2NyaXB0RGlyZWN0b3J5IGNvbnRhaW5zIGEgcXVlcnkgKHN0YXJ0aW5nIHdpdGggPykgb3IgYSBmcmFnbWVudCAoc3RhcnRpbmcgd2l0aCAjKSxcbiAgLy8gdGhleSBhcmUgcmVtb3ZlZCBiZWNhdXNlIHRoZXkgY291bGQgY29udGFpbiBhIHNsYXNoLlxuICBpZiAoc2NyaXB0RGlyZWN0b3J5LnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgfSBlbHNlIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCAnJykubGFzdEluZGV4T2YoJy8nKSsxKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJykpIHRocm93IG5ldyBFcnJvcignbm90IGNvbXBpbGVkIGZvciB0aGlzIGVudmlyb25tZW50IChkaWQgeW91IGJ1aWxkIHRvIEhUTUwgYW5kIHRyeSB0byBydW4gaXQgbm90IG9uIHRoZSB3ZWIsIG9yIHNldCBFTlZJUk9OTUVOVCB0byBzb21ldGhpbmcgLSBsaWtlIG5vZGUgLSBhbmQgcnVuIGl0IHNvbWVwbGFjZSBlbHNlIC0gbGlrZSBvbiB0aGUgd2ViPyknKTtcblxuICB7XG4vLyBpbmNsdWRlOiB3ZWJfb3Jfd29ya2VyX3NoZWxsX3JlYWQuanNcbmlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICByZWFkQmluYXJ5ID0gKHVybCkgPT4ge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgvKiogQHR5cGV7IUFycmF5QnVmZmVyfSAqLyh4aHIucmVzcG9uc2UpKTtcbiAgICB9O1xuICB9XG5cbiAgcmVhZEFzeW5jID0gKHVybCkgPT4ge1xuICAgIGFzc2VydCghaXNGaWxlVVJJKHVybCksIFwicmVhZEFzeW5jIGRvZXMgbm90IHdvcmsgd2l0aCBmaWxlOi8vIFVSTHNcIik7XG4gICAgcmV0dXJuIGZldGNoKHVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgJyA6ICcgKyByZXNwb25zZS51cmwpKTtcbiAgICAgIH0pXG4gIH07XG4vLyBlbmQgaW5jbHVkZTogd2ViX29yX3dvcmtlcl9zaGVsbF9yZWFkLmpzXG4gIH1cbn0gZWxzZVxue1xuICB0aHJvdyBuZXcgRXJyb3IoJ2Vudmlyb25tZW50IGRldGVjdGlvbiBlcnJvcicpO1xufVxuXG52YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG52YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblxuLy8gTWVyZ2UgYmFjayBpbiB0aGUgb3ZlcnJpZGVzXG5PYmplY3QuYXNzaWduKE1vZHVsZSwgbW9kdWxlT3ZlcnJpZGVzKTtcbi8vIEZyZWUgdGhlIG9iamVjdCBoaWVyYXJjaHkgY29udGFpbmVkIGluIHRoZSBvdmVycmlkZXMsIHRoaXMgbGV0cyB0aGUgR0Ncbi8vIHJlY2xhaW0gZGF0YSB1c2VkLlxubW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcbmNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKTtcblxuLy8gRW1pdCBjb2RlIHRvIGhhbmRsZSBleHBlY3RlZCB2YWx1ZXMgb24gdGhlIE1vZHVsZSBvYmplY3QuIFRoaXMgYXBwbGllcyBNb2R1bGUueFxuLy8gdG8gdGhlIHByb3BlciBsb2NhbCB4LiBUaGlzIGhhcyB0d28gYmVuZWZpdHM6IGZpcnN0LCB3ZSBvbmx5IGVtaXQgaXQgaWYgaXQgaXNcbi8vIGV4cGVjdGVkIHRvIGFycml2ZSwgYW5kIHNlY29uZCwgYnkgdXNpbmcgYSBsb2NhbCBldmVyeXdoZXJlIGVsc2UgdGhhdCBjYW4gYmVcbi8vIG1pbmlmaWVkLlxuXG5pZiAoTW9kdWxlWydhcmd1bWVudHMnXSkgYXJndW1lbnRzXyA9IE1vZHVsZVsnYXJndW1lbnRzJ107bGVnYWN5TW9kdWxlUHJvcCgnYXJndW1lbnRzJywgJ2FyZ3VtZW50c18nKTtcblxuaWYgKE1vZHVsZVsndGhpc1Byb2dyYW0nXSkgdGhpc1Byb2dyYW0gPSBNb2R1bGVbJ3RoaXNQcm9ncmFtJ107bGVnYWN5TW9kdWxlUHJvcCgndGhpc1Byb2dyYW0nLCAndGhpc1Byb2dyYW0nKTtcblxuLy8gcGVyZm9ybSBhc3NlcnRpb25zIGluIHNoZWxsLmpzIGFmdGVyIHdlIHNldCB1cCBvdXQoKSBhbmQgZXJyKCksIGFzIG90aGVyd2lzZSBpZiBhbiBhc3NlcnRpb24gZmFpbHMgaXQgY2Fubm90IHByaW50IHRoZSBtZXNzYWdlXG4vLyBBc3NlcnRpb25zIG9uIHJlbW92ZWQgaW5jb21pbmcgTW9kdWxlIEpTIEFQSXMuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnbWVtb3J5SW5pdGlhbGl6ZXJQcmVmaXhVUkwnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5tZW1vcnlJbml0aWFsaXplclByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncHRocmVhZE1haW5QcmVmaXhVUkwnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5wdGhyZWFkTWFpblByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnY2RJbml0aWFsaXplclByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLmNkSW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZCcpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ2ZpbGVQYWNrYWdlUHJlZml4VVJMJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuZmlsZVBhY2thZ2VQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZCcpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3JlYWQnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5yZWFkIG9wdGlvbiB3YXMgcmVtb3ZlZCcpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3JlYWRBc3luYyddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnJlYWRBc3luYyBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQXN5bmMgaW4gSlMpJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncmVhZEJpbmFyeSddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnJlYWRCaW5hcnkgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZEJpbmFyeSBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydzZXRXaW5kb3dUaXRsZSddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnNldFdpbmRvd1RpdGxlIG9wdGlvbiB3YXMgcmVtb3ZlZCAobW9kaWZ5IGVtc2NyaXB0ZW5fc2V0X3dpbmRvd190aXRsZSBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydUT1RBTF9NRU1PUlknXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5UT1RBTF9NRU1PUlkgaGFzIGJlZW4gcmVuYW1lZCBNb2R1bGUuSU5JVElBTF9NRU1PUlknKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ2FzbScsICd3YXNtRXhwb3J0cycpO1xubGVnYWN5TW9kdWxlUHJvcCgncmVhZEFzeW5jJywgJ3JlYWRBc3luYycpO1xubGVnYWN5TW9kdWxlUHJvcCgncmVhZEJpbmFyeScsICdyZWFkQmluYXJ5Jyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdzZXRXaW5kb3dUaXRsZScsICdzZXRXaW5kb3dUaXRsZScpO1xudmFyIElEQkZTID0gJ0lEQkZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1saWRiZnMuanMnO1xudmFyIFBST1hZRlMgPSAnUFJPWFlGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbHByb3h5ZnMuanMnO1xudmFyIFdPUktFUkZTID0gJ1dPUktFUkZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sd29ya2VyZnMuanMnO1xudmFyIEZFVENIRlMgPSAnRkVUQ0hGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGZldGNoZnMuanMnO1xudmFyIElDQVNFRlMgPSAnSUNBU0VGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGljYXNlZnMuanMnO1xudmFyIEpTRklMRUZTID0gJ0pTRklMRUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sanNmaWxlZnMuanMnO1xudmFyIE9QRlMgPSAnT1BGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbG9wZnMuanMnO1xuXG52YXIgTk9ERUZTID0gJ05PREVGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbG5vZGVmcy5qcyc7XG5cbmFzc2VydCghRU5WSVJPTk1FTlRfSVNfTk9ERSwgJ25vZGUgZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IG5vdCBlbmFibGVkIGF0IGJ1aWxkIHRpbWUuICBBZGQgYG5vZGVgIHRvIGAtc0VOVklST05NRU5UYCB0byBlbmFibGUuJyk7XG5cbmFzc2VydCghRU5WSVJPTk1FTlRfSVNfU0hFTEwsICdzaGVsbCBlbnZpcm9ubWVudCBkZXRlY3RlZCBidXQgbm90IGVuYWJsZWQgYXQgYnVpbGQgdGltZS4gIEFkZCBgc2hlbGxgIHRvIGAtc0VOVklST05NRU5UYCB0byBlbmFibGUuJyk7XG5cbi8vIGVuZCBpbmNsdWRlOiBzaGVsbC5qc1xuXG4vLyBpbmNsdWRlOiBwcmVhbWJsZS5qc1xuLy8gPT09IFByZWFtYmxlIGxpYnJhcnkgc3R1ZmYgPT09XG5cbi8vIERvY3VtZW50YXRpb24gZm9yIHRoZSBwdWJsaWMgQVBJcyBkZWZpbmVkIGluIHRoaXMgZmlsZSBtdXN0IGJlIHVwZGF0ZWQgaW46XG4vLyAgICBzaXRlL3NvdXJjZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMucnN0XG4vLyBBIHByZWJ1aWx0IGxvY2FsIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0OlxuLy8gICAgc2l0ZS9idWlsZC90ZXh0L2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy50eHRcbi8vIFlvdSBjYW4gYWxzbyBidWlsZCBkb2NzIGxvY2FsbHkgYXMgSFRNTCBvciBvdGhlciBmb3JtYXRzIGluIHNpdGUvXG4vLyBBbiBvbmxpbmUgSFRNTCB2ZXJzaW9uICh3aGljaCBtYXkgYmUgb2YgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBFbXNjcmlwdGVuKVxuLy8gICAgaXMgdXAgYXQgaHR0cDovL2tyaXBrZW4uZ2l0aHViLmlvL2Vtc2NyaXB0ZW4tc2l0ZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMuaHRtbFxuXG52YXIgd2FzbUJpbmFyeSA9IE1vZHVsZVsnd2FzbUJpbmFyeSddO2xlZ2FjeU1vZHVsZVByb3AoJ3dhc21CaW5hcnknLCAnd2FzbUJpbmFyeScpO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gIGVycignbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xufVxuXG4vLyBXYXNtIGdsb2JhbHNcblxudmFyIHdhc21NZW1vcnk7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUnVudGltZSBlc3NlbnRpYWxzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gd2hldGhlciB3ZSBhcmUgcXVpdHRpbmcgdGhlIGFwcGxpY2F0aW9uLiBubyBjb2RlIHNob3VsZCBydW4gYWZ0ZXIgdGhpcy5cbi8vIHNldCBpbiBleGl0KCkgYW5kIGFib3J0KClcbnZhciBBQk9SVCA9IGZhbHNlO1xuXG4vLyBzZXQgYnkgZXhpdCgpIGFuZCBhYm9ydCgpLiAgUGFzc2VkIHRvICdvbkV4aXQnIGhhbmRsZXIuXG4vLyBOT1RFOiBUaGlzIGlzIGFsc28gdXNlZCBhcyB0aGUgcHJvY2VzcyByZXR1cm4gY29kZSBjb2RlIGluIHNoZWxsIGVudmlyb25tZW50c1xuLy8gYnV0IG9ubHkgd2hlbiBub0V4aXRSdW50aW1lIGlzIGZhbHNlLlxudmFyIEVYSVRTVEFUVVM7XG5cbi8vIEluIFNUUklDVCBtb2RlLCB3ZSBvbmx5IGRlZmluZSBhc3NlcnQoKSB3aGVuIEFTU0VSVElPTlMgaXMgc2V0LiAgaS5lLiB3ZVxuLy8gZG9uJ3QgZGVmaW5lIGl0IGF0IGFsbCBpbiByZWxlYXNlIG1vZGVzLiAgVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvdXIgb2Zcbi8vIE1JTklNQUxfUlVOVElNRS5cbi8vIFRPRE8oc2JjKTogTWFrZSB0aGlzIHRoZSBkZWZhdWx0IGV2ZW4gd2l0aG91dCBTVFJJQ1QgZW5hYmxlZC5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKiwgc3RyaW5nPSl9ICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQnICsgKHRleHQgPyAnOiAnICsgdGV4dCA6ICcnKSk7XG4gIH1cbn1cblxuLy8gV2UgdXNlZCB0byBpbmNsdWRlIG1hbGxvYy9mcmVlIGJ5IGRlZmF1bHQgaW4gdGhlIHBhc3QuIFNob3cgYSBoZWxwZnVsIGVycm9yIGluXG4vLyBidWlsZHMgd2l0aCBhc3NlcnRpb25zLlxuXG4vLyBNZW1vcnkgbWFuYWdlbWVudFxuXG52YXIgSEVBUCxcbi8qKiBAdHlwZSB7IUludDhBcnJheX0gKi9cbiAgSEVBUDgsXG4vKiogQHR5cGUgeyFVaW50OEFycmF5fSAqL1xuICBIRUFQVTgsXG4vKiogQHR5cGUgeyFJbnQxNkFycmF5fSAqL1xuICBIRUFQMTYsXG4vKiogQHR5cGUgeyFVaW50MTZBcnJheX0gKi9cbiAgSEVBUFUxNixcbi8qKiBAdHlwZSB7IUludDMyQXJyYXl9ICovXG4gIEhFQVAzMixcbi8qKiBAdHlwZSB7IVVpbnQzMkFycmF5fSAqL1xuICBIRUFQVTMyLFxuLyoqIEB0eXBlIHshRmxvYXQzMkFycmF5fSAqL1xuICBIRUFQRjMyLFxuLyoqIEB0eXBlIHshRmxvYXQ2NEFycmF5fSAqL1xuICBIRUFQRjY0O1xuXG4vLyBpbmNsdWRlOiBydW50aW1lX3NoYXJlZC5qc1xuZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQMzInXSA9IEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG59XG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zaGFyZWQuanNcbmFzc2VydCghTW9kdWxlWydTVEFDS19TSVpFJ10sICdTVEFDS19TSVpFIGNhbiBubyBsb25nZXIgYmUgc2V0IGF0IHJ1bnRpbWUuICBVc2UgLXNTVEFDS19TSVpFIGF0IGxpbmsgdGltZScpXG5cbmFzc2VydCh0eXBlb2YgSW50MzJBcnJheSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSAhPSB1bmRlZmluZWQgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc2V0ICE9IHVuZGVmaW5lZCxcbiAgICAgICAnSlMgZW5naW5lIGRvZXMgbm90IHByb3ZpZGUgZnVsbCB0eXBlZCBhcnJheSBzdXBwb3J0Jyk7XG5cbi8vIEluIG5vbi1zdGFuZGFsb25lL25vcm1hbCBtb2RlLCB3ZSBjcmVhdGUgdGhlIG1lbW9yeSBoZXJlLlxuLy8gaW5jbHVkZTogcnVudGltZV9pbml0X21lbW9yeS5qc1xuLy8gQ3JlYXRlIHRoZSB3YXNtIG1lbW9yeS4gKE5vdGU6IHRoaXMgb25seSBhcHBsaWVzIGlmIElNUE9SVEVEX01FTU9SWSBpcyBkZWZpbmVkKVxuXG4vLyBjaGVjayBmb3IgZnVsbCBlbmdpbmUgc3VwcG9ydCAodXNlIHN0cmluZyAnc3ViYXJyYXknIHRvIGF2b2lkIGNsb3N1cmUgY29tcGlsZXIgY29uZnVzaW9uKVxuXG4gIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ3dhc21NZW1vcnknXTtcbiAgfSBlbHNlXG4gIHtcbiAgICB2YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7bGVnYWN5TW9kdWxlUHJvcCgnSU5JVElBTF9NRU1PUlknLCAnSU5JVElBTF9NRU1PUlknKTtcblxuICAgIGFzc2VydChJTklUSUFMX01FTU9SWSA+PSA1MjQyODgwLCAnSU5JVElBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFNUQUNLX1NJWkUsIHdhcyAnICsgSU5JVElBTF9NRU1PUlkgKyAnISAoU1RBQ0tfU0laRT0nICsgNTI0Mjg4MCArICcpJyk7XG4gICAgd2FzbU1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICAgICAgJ2luaXRpYWwnOiBJTklUSUFMX01FTU9SWSAvIDY1NTM2LFxuICAgICAgLy8gSW4gdGhlb3J5IHdlIHNob3VsZCBub3QgbmVlZCB0byBlbWl0IHRoZSBtYXhpbXVtIGlmIHdlIHdhbnQgXCJ1bmxpbWl0ZWRcIlxuICAgICAgLy8gb3IgNEdCIG9mIG1lbW9yeSwgYnV0IFZNcyBlcnJvciBvbiB0aGF0IGF0bSwgc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vaXNzdWVzLzE0MTMwXG4gICAgICAvLyBBbmQgaW4gdGhlIHB0aHJlYWRzIGNhc2Ugd2UgZGVmaW5pdGVseSBuZWVkIHRvIGVtaXQgYSBtYXhpbXVtLiBTb1xuICAgICAgLy8gYWx3YXlzIGVtaXQgb25lLlxuICAgICAgJ21heGltdW0nOiAyMTQ3NDgzNjQ4IC8gNjU1MzYsXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9pbml0X21lbW9yeS5qc1xuXG4vLyBpbmNsdWRlOiBydW50aW1lX3N0YWNrX2NoZWNrLmpzXG4vLyBJbml0aWFsaXplcyB0aGUgc3RhY2sgY29va2llLiBDYWxsZWQgYXQgdGhlIHN0YXJ0dXAgb2YgbWFpbiBhbmQgYXQgdGhlIHN0YXJ0dXAgb2YgZWFjaCB0aHJlYWQgaW4gcHRocmVhZHMgbW9kZS5cbmZ1bmN0aW9uIHdyaXRlU3RhY2tDb29raWUoKSB7XG4gIHZhciBtYXggPSBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kKCk7XG4gIGFzc2VydCgobWF4ICYgMykgPT0gMCk7XG4gIC8vIElmIHRoZSBzdGFjayBlbmRzIGF0IGFkZHJlc3MgemVybyB3ZSB3cml0ZSBvdXIgY29va2llcyA0IGJ5dGVzIGludG8gdGhlXG4gIC8vIHN0YWNrLiAgVGhpcyBwcmV2ZW50cyBpbnRlcmZlcmVuY2Ugd2l0aCBTQUZFX0hFQVAgYW5kIEFTQU4gd2hpY2ggYWxzb1xuICAvLyBtb25pdG9yIHdyaXRlcyB0byBhZGRyZXNzIHplcm8uXG4gIGlmIChtYXggPT0gMCkge1xuICAgIG1heCArPSA0O1xuICB9XG4gIC8vIFRoZSBzdGFjayBncm93IGRvd253YXJkcyB0b3dhcmRzIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQuXG4gIC8vIFdlIHdyaXRlIGNvb2tpZXMgdG8gdGhlIGZpbmFsIHR3byB3b3JkcyBpbiB0aGUgc3RhY2sgYW5kIGRldGVjdCBpZiB0aGV5IGFyZVxuICAvLyBldmVyIG92ZXJ3cml0dGVuLlxuICBIRUFQVTMyWygobWF4KT4+MildID0gMHgwMjEzNTQ2NztcbiAgSEVBUFUzMlsoKChtYXgpKyg0KSk+PjIpXSA9IDB4ODlCQUNERkU7XG4gIC8vIEFsc28gdGVzdCB0aGUgZ2xvYmFsIGFkZHJlc3MgMCBmb3IgaW50ZWdyaXR5LlxuICBIRUFQVTMyWygoMCk+PjIpXSA9IDE2Njg1MDkwMjk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhY2tDb29raWUoKSB7XG4gIGlmIChBQk9SVCkgcmV0dXJuO1xuICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuICAvLyBTZWUgd3JpdGVTdGFja0Nvb2tpZSgpLlxuICBpZiAobWF4ID09IDApIHtcbiAgICBtYXggKz0gNDtcbiAgfVxuICB2YXIgY29va2llMSA9IEhFQVBVMzJbKChtYXgpPj4yKV07XG4gIHZhciBjb29raWUyID0gSEVBUFUzMlsoKChtYXgpKyg0KSk+PjIpXTtcbiAgaWYgKGNvb2tpZTEgIT0gMHgwMjEzNTQ2NyB8fCBjb29raWUyICE9IDB4ODlCQUNERkUpIHtcbiAgICBhYm9ydChgU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBhdCAke3B0clRvU3RyaW5nKG1heCl9LCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgYnV0IHJlY2VpdmVkICR7cHRyVG9TdHJpbmcoY29va2llMil9ICR7cHRyVG9TdHJpbmcoY29va2llMSl9YCk7XG4gIH1cbiAgLy8gQWxzbyB0ZXN0IHRoZSBnbG9iYWwgYWRkcmVzcyAwIGZvciBpbnRlZ3JpdHkuXG4gIGlmIChIRUFQVTMyWygoMCk+PjIpXSAhPSAweDYzNzM2ZDY1IC8qICdlbXNjJyAqLykge1xuICAgIGFib3J0KCdSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSEnKTtcbiAgfVxufVxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfc3RhY2tfY2hlY2suanNcbnZhciBfX0FUUFJFUlVOX18gID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgYmVmb3JlIHRoZSBydW50aW1lIGlzIGluaXRpYWxpemVkXG52YXIgX19BVElOSVRfXyAgICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzdGFydHVwXG52YXIgX19BVEVYSVRfXyAgICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzaHV0ZG93blxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBhZnRlciB0aGUgbWFpbigpIGlzIGNhbGxlZFxuXG52YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcbiAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwcmVSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuICBhc3NlcnQoIXJ1bnRpbWVJbml0aWFsaXplZCk7XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuXG4gIFxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG4vLyBpbmNsdWRlOiBydW50aW1lX21hdGguanNcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvaW11bFxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Zyb3VuZFxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmNcblxuYXNzZXJ0KE1hdGguaW11bCwgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGguaW11bCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGguZnJvdW5kLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5mcm91bmQoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGwnKTtcbmFzc2VydChNYXRoLmNsejMyLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5jbHozMigpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGgudHJ1bmMsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLnRydW5jKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9tYXRoLmpzXG4vLyBBIGNvdW50ZXIgb2YgZGVwZW5kZW5jaWVzIGZvciBjYWxsaW5nIHJ1bigpLiBJZiB3ZSBuZWVkIHRvXG4vLyBkbyBhc3luY2hyb25vdXMgd29yayBiZWZvcmUgcnVubmluZywgaW5jcmVtZW50IHRoaXMgYW5kXG4vLyBkZWNyZW1lbnQgaXQuIEluY3JlbWVudGluZyBtdXN0IGhhcHBlbiBpbiBhIHBsYWNlIGxpa2Vcbi8vIE1vZHVsZS5wcmVSdW4gKHVzZWQgYnkgZW1jYyB0byBhZGQgZmlsZSBwcmVsb2FkaW5nKS5cbi8vIE5vdGUgdGhhdCB5b3UgY2FuIGFkZCBkZXBlbmRlbmNpZXMgaW4gcHJlUnVuLCBldmVuIHRob3VnaFxuLy8gaXQgaGFwcGVucyByaWdodCBiZWZvcmUgcnVuIC0gcnVuIHdpbGwgYmUgcG9zdHBvbmVkIHVudGlsXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGFyZSBtZXQuXG52YXIgcnVuRGVwZW5kZW5jaWVzID0gMDtcbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG52YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsgLy8gb3ZlcnJpZGRlbiB0byB0YWtlIGRpZmZlcmVudCBhY3Rpb25zIHdoZW4gYWxsIHJ1biBkZXBlbmRlbmNpZXMgYXJlIGZ1bGZpbGxlZFxudmFyIHJ1bkRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHZhciBvcmlnID0gaWQ7XG4gIHdoaWxlICgxKSB7XG4gICAgaWYgKCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBvcmlnICsgTWF0aC5yYW5kb20oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcysrO1xuXG4gIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddPy4ocnVuRGVwZW5kZW5jaWVzKTtcblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xuICAgIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xuICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciA9PT0gbnVsbCAmJiB0eXBlb2Ygc2V0SW50ZXJ2YWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGRlcGVuZGVuY2llcyBldmVyeSBmZXcgc2Vjb25kc1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChBQk9SVCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICBpZiAoIXNob3duKSB7XG4gICAgICAgICAgICBzaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnIoJ3N0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczonKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyKGBkZXBlbmRlbmN5OiAke2RlcH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd24pIHtcbiAgICAgICAgICBlcnIoJyhlbmQgb2YgbGlzdCknKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IGFkZGVkIHdpdGhvdXQgSUQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddPy4ocnVuRGVwZW5kZW5jaWVzKTtcblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gIH0gZWxzZSB7XG4gICAgZXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSByZW1vdmVkIHdpdGhvdXQgSUQnKTtcbiAgfVxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgIH1cbiAgfVxufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd8bnVtYmVyPX0gd2hhdCAqL1xuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuICBNb2R1bGVbJ29uQWJvcnQnXT8uKHdoYXQpO1xuXG4gIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgLy8gVE9ETyhzYmMpOiBTaG91bGQgd2UgcmVtb3ZlIHByaW50aW5nIGFuZCBsZWF2ZSBpdCB1cCB0byB3aG9ldmVyXG4gIC8vIGNhdGNoZXMgdGhlIGV4Y2VwdGlvbj9cbiAgZXJyKHdoYXQpO1xuXG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG5cbiAgaWYgKHdoYXQuaW5kZXhPZignUnVudGltZUVycm9yOiB1bnJlYWNoYWJsZScpID49IDApIHtcbiAgICB3aGF0ICs9ICcuIFwidW5yZWFjaGFibGVcIiBtYXkgYmUgZHVlIHRvIEFTWU5DSUZZX1NUQUNLX1NJWkUgbm90IGJlaW5nIGxhcmdlIGVub3VnaCAodHJ5IGluY3JlYXNpbmcgaXQpJztcbiAgfVxuXG4gIC8vIFVzZSBhIHdhc20gcnVudGltZSBlcnJvciwgYmVjYXVzZSBhIEpTIGVycm9yIG1pZ2h0IGJlIHNlZW4gYXMgYSBmb3JlaWduXG4gIC8vIGV4Y2VwdGlvbiwgd2hpY2ggbWVhbnMgd2UnZCBydW4gZGVzdHJ1Y3RvcnMgb24gaXQuIFdlIG5lZWQgdGhlIGVycm9yIHRvXG4gIC8vIHNpbXBseSBtYWtlIHRoZSBwcm9ncmFtIHN0b3AuXG4gIC8vIEZJWE1FIFRoaXMgYXBwcm9hY2ggZG9lcyBub3Qgd29yayBpbiBXYXNtIEVIIGJlY2F1c2UgaXQgY3VycmVudGx5IGRvZXMgbm90IGFzc3VtZVxuICAvLyBhbGwgUnVudGltZUVycm9ycyBhcmUgZnJvbSB0cmFwczsgaXQgZGVjaWRlcyB3aGV0aGVyIGEgUnVudGltZUVycm9yIGlzIGZyb21cbiAgLy8gYSB0cmFwIG9yIG5vdCBiYXNlZCBvbiBhIGhpZGRlbiBmaWVsZCB3aXRoaW4gdGhlIG9iamVjdC4gU28gYXQgdGhlIG1vbWVudFxuICAvLyB3ZSBkb24ndCBoYXZlIGEgd2F5IG9mIHRocm93aW5nIGEgd2FzbSB0cmFwIGZyb20gSlMuIFRPRE8gTWFrZSBhIEpTIEFQSSB0aGF0XG4gIC8vIGFsbG93cyB0aGlzIGluIHRoZSB3YXNtIHNwZWMuXG5cbiAgLy8gU3VwcHJlc3MgY2xvc3VyZSBjb21waWxlciB3YXJuaW5nIGhlcmUuIENsb3N1cmUgY29tcGlsZXIncyBidWlsdGluIGV4dGVyblxuICAvLyBkZWZpbml0aW9uIGZvciBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IgY2xhaW1zIGl0IHRha2VzIG5vIGFyZ3VtZW50cyBldmVuXG4gIC8vIHRob3VnaCBpdCBjYW4uXG4gIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL3B1bGwvMzkxMyk6IFJlbW92ZSBpZi93aGVuIHVwc3RyZWFtIGNsb3N1cmUgZ2V0cyBmaXhlZC5cbiAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgLy8gVGhyb3cgdGhlIGVycm9yIHdoZXRoZXIgb3Igbm90IE1PRFVMQVJJWkUgaXMgc2V0IGJlY2F1c2UgYWJvcnQgaXMgdXNlZFxuICAvLyBpbiBjb2RlIHBhdGhzIGFwYXJ0IGZyb20gaW5zdGFudGlhdGlvbiB3aGVyZSBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWRcbiAgLy8gdG8gYmUgdGhyb3duIHdoZW4gYWJvcnQgaXMgY2FsbGVkLlxuICB0aHJvdyBlO1xufVxuXG4vLyBpbmNsdWRlOiBtZW1vcnlwcm9maWxlci5qc1xuLy8gZW5kIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG4vLyBzaG93IGVycm9ycyBvbiBsaWtlbHkgY2FsbHMgdG8gRlMgd2hlbiBpdCB3YXMgbm90IGluY2x1ZGVkXG52YXIgRlMgPSB7XG4gIGVycm9yKCkge1xuICAgIGFib3J0KCdGaWxlc3lzdGVtIHN1cHBvcnQgKEZTKSB3YXMgbm90IGluY2x1ZGVkLiBUaGUgcHJvYmxlbSBpcyB0aGF0IHlvdSBhcmUgdXNpbmcgZmlsZXMgZnJvbSBKUywgYnV0IGZpbGVzIHdlcmUgbm90IHVzZWQgZnJvbSBDL0MrKywgc28gZmlsZXN5c3RlbSBzdXBwb3J0IHdhcyBub3QgYXV0by1pbmNsdWRlZC4gWW91IGNhbiBmb3JjZS1pbmNsdWRlIGZpbGVzeXN0ZW0gc3VwcG9ydCB3aXRoIC1zRk9SQ0VfRklMRVNZU1RFTScpO1xuICB9LFxuICBpbml0KCkgeyBGUy5lcnJvcigpIH0sXG4gIGNyZWF0ZURhdGFGaWxlKCkgeyBGUy5lcnJvcigpIH0sXG4gIGNyZWF0ZVByZWxvYWRlZEZpbGUoKSB7IEZTLmVycm9yKCkgfSxcbiAgY3JlYXRlTGF6eUZpbGUoKSB7IEZTLmVycm9yKCkgfSxcbiAgb3BlbigpIHsgRlMuZXJyb3IoKSB9LFxuICBta2RldigpIHsgRlMuZXJyb3IoKSB9LFxuICByZWdpc3RlckRldmljZSgpIHsgRlMuZXJyb3IoKSB9LFxuICBhbmFseXplUGF0aCgpIHsgRlMuZXJyb3IoKSB9LFxuXG4gIEVycm5vRXJyb3IoKSB7IEZTLmVycm9yKCkgfSxcbn07XG5Nb2R1bGVbJ0ZTX2NyZWF0ZURhdGFGaWxlJ10gPSBGUy5jcmVhdGVEYXRhRmlsZTtcbk1vZHVsZVsnRlNfY3JlYXRlUHJlbG9hZGVkRmlsZSddID0gRlMuY3JlYXRlUHJlbG9hZGVkRmlsZTtcblxuLy8gaW5jbHVkZTogVVJJVXRpbHMuanNcbi8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgZmlsZW5hbWUgaXMgYSBiYXNlNjQgZGF0YSBVUkkuXG4gKiBAbm9pbmxpbmVcbiAqL1xudmFyIGlzRGF0YVVSSSA9IChmaWxlbmFtZSkgPT4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciBmaWxlbmFtZSBpcyBkZWxpdmVyZWQgdmlhIGZpbGUgcHJvdG9jb2wgKGFzIG9wcG9zZWQgdG8gaHR0cC9odHRwcylcbiAqIEBub2lubGluZVxuICovXG52YXIgaXNGaWxlVVJJID0gKGZpbGVuYW1lKSA9PiBmaWxlbmFtZS5zdGFydHNXaXRoKCdmaWxlOi8vJyk7XG4vLyBlbmQgaW5jbHVkZTogVVJJVXRpbHMuanNcbmZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgbmFyZ3MpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgYG5hdGl2ZSBmdW5jdGlvbiBcXGAke25hbWV9XFxgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvbmApO1xuICAgIHZhciBmID0gd2FzbUV4cG9ydHNbbmFtZV07XG4gICAgYXNzZXJ0KGYsIGBleHBvcnRlZCBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBub3QgZm91bmRgKTtcbiAgICAvLyBPbmx5IGFzc2VydCBmb3IgdG9vIG1hbnkgYXJndW1lbnRzLiBUb28gZmV3IGNhbiBiZSB2YWxpZCBzaW5jZSB0aGUgbWlzc2luZyBhcmd1bWVudHMgd2lsbCBiZSB6ZXJvIGZpbGxlZC5cbiAgICBhc3NlcnQoYXJncy5sZW5ndGggPD0gbmFyZ3MsIGBuYXRpdmUgZnVuY3Rpb24gXFxgJHtuYW1lfVxcYCBjYWxsZWQgd2l0aCAke2FyZ3MubGVuZ3RofSBhcmdzIGJ1dCBleHBlY3RzICR7bmFyZ3N9YCk7XG4gICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gIH07XG59XG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfZXhjZXB0aW9ucy5qc1xuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZXhjZXB0aW9ucy5qc1xuZnVuY3Rpb24gZmluZFdhc21CaW5hcnkoKSB7XG4gIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgIHZhciBmID0gJ2Vtc2NyaXB0ZW4tbW9kdWxlLndhc20nO1xuICAgIGlmICghaXNEYXRhVVJJKGYpKSB7XG4gICAgICByZXR1cm4gbG9jYXRlRmlsZShmKTtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgLy8gVXNlIGJ1bmRsZXItZnJpZW5kbHkgYG5ldyBVUkwoLi4uLCBpbXBvcnQubWV0YS51cmwpYCBwYXR0ZXJuOyB3b3JrcyBpbiBicm93c2VycyB0b28uXG4gIHJldHVybiBuZXcgVVJMKCdlbXNjcmlwdGVuLW1vZHVsZS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG5cbmZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZmlsZSkge1xuICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICB9XG4gIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH1cbiAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgdGhlIGJpbmFyeSB5ZXQsIGxvYWQgaXQgYXN5bmNocm9ub3VzbHkgdXNpbmcgcmVhZEFzeW5jLlxuICBpZiAoIXdhc21CaW5hcnlcbiAgICAgICkge1xuICAgIC8vIEZldGNoIHRoZSBiaW5hcnkgdXNpbmcgcmVhZEFzeW5jXG4gICAgcmV0dXJuIHJlYWRBc3luYyhiaW5hcnlGaWxlKS50aGVuKFxuICAgICAgKHJlc3BvbnNlKSA9PiBuZXcgVWludDhBcnJheSgvKiogQHR5cGV7IUFycmF5QnVmZmVyfSAqLyhyZXNwb25zZSkpLFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGdldEJpbmFyeVN5bmMgaWYgcmVhZEFzeW5jIGZhaWxzXG4gICAgICAoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpXG4gICAgKTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZ2V0QmluYXJ5U3luYyBzaG91bGQgYmUgYWJsZSB0byBnZXQgaXQgc3luY2hyb25vdXNseVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCByZWNlaXZlcikge1xuICByZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKS50aGVuKChiaW5hcnkpID0+IHtcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbXBvcnRzKTtcbiAgfSkudGhlbihyZWNlaXZlciwgKHJlYXNvbikgPT4ge1xuICAgIGVycihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtyZWFzb259YCk7XG5cbiAgICAvLyBXYXJuIG9uIHNvbWUgY29tbW9uIHByb2JsZW1zLlxuICAgIGlmIChpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgICBlcnIoYHdhcm5pbmc6IExvYWRpbmcgZnJvbSBhIGZpbGUgVVJJICgke3dhc21CaW5hcnlGaWxlfSkgaXMgbm90IHN1cHBvcnRlZCBpbiBtb3N0IGJyb3dzZXJzLiBTZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2dldHRpbmdfc3RhcnRlZC9GQVEuaHRtbCNob3ctZG8taS1ydW4tYS1sb2NhbC13ZWJzZXJ2ZXItZm9yLXRlc3Rpbmctd2h5LWRvZXMtbXktcHJvZ3JhbS1zdGFsbC1pbi1kb3dubG9hZGluZy1vci1wcmVwYXJpbmdgKTtcbiAgICB9XG4gICAgYWJvcnQocmVhc29uKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LCBiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjaykge1xuICBpZiAoIWJpbmFyeSAmJlxuICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09ICdmdW5jdGlvbicgJiZcbiAgICAgICFpc0RhdGFVUkkoYmluYXJ5RmlsZSkgJiZcbiAgICAgIHR5cGVvZiBmZXRjaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZldGNoKGJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIC8vIFN1cHByZXNzIGNsb3N1cmUgd2FybmluZyBoZXJlIHNpbmNlIHRoZSB1cHN0cmVhbSBkZWZpbml0aW9uIGZvclxuICAgICAgLy8gaW5zdGFudGlhdGVTdHJlYW1pbmcgb25seSBhbGxvd3MgUHJvbWlzZTxSZXBzcG9uc2U+IHJhdGhlciB0aGFuXG4gICAgICAvLyBhbiBhY3R1YWwgUmVzcG9uc2UuXG4gICAgICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9wdWxsLzM5MTMpOiBSZW1vdmUgaWYvd2hlbiB1cHN0cmVhbSBjbG9zdXJlIGlzIGZpeGVkLlxuICAgICAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgICAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW1wb3J0cyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQudGhlbihcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgbW9zdCBjb21tb24gZmFpbHVyZSBjYXVzZSB0byBiZSBhIGJhZCBNSU1FIHR5cGUgZm9yIHRoZSBiaW5hcnksXG4gICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSBmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbiBzaG91bGQgd29yay5cbiAgICAgICAgICBlcnIoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke3JlYXNvbn1gKTtcbiAgICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFdhc21JbXBvcnRzKCkge1xuICAvLyBpbnN0cnVtZW50aW5nIGltcG9ydHMgaXMgdXNlZCBpbiBhc3luY2lmeSBpbiB0d28gd2F5czogdG8gYWRkIGFzc2VydGlvbnNcbiAgLy8gdGhhdCBjaGVjayBmb3IgcHJvcGVyIGltcG9ydCB1c2UsIGFuZCBmb3IgQVNZTkNJRlk9MiB3ZSB1c2UgdGhlbSB0byBzZXQgdXBcbiAgLy8gdGhlIFByb21pc2UgQVBJIG9uIHRoZSBpbXBvcnQgc2lkZS5cbiAgQXN5bmNpZnkuaW5zdHJ1bWVudFdhc21JbXBvcnRzKHdhc21JbXBvcnRzKTtcbiAgLy8gcHJlcGFyZSBpbXBvcnRzXG4gIHJldHVybiB7XG4gICAgJ2Vudic6IHdhc21JbXBvcnRzLFxuICAgICd3YXNpX3NuYXBzaG90X3ByZXZpZXcxJzogd2FzbUltcG9ydHMsXG4gIH1cbn1cblxuLy8gQ3JlYXRlIHRoZSB3YXNtIGluc3RhbmNlLlxuLy8gUmVjZWl2ZXMgdGhlIHdhc20gaW1wb3J0cywgcmV0dXJucyB0aGUgZXhwb3J0cy5cbmZ1bmN0aW9uIGNyZWF0ZVdhc20oKSB7XG4gIHZhciBpbmZvID0gZ2V0V2FzbUltcG9ydHMoKTtcbiAgLy8gTG9hZCB0aGUgd2FzbSBtb2R1bGUgYW5kIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB1c2luZyBuYXRpdmUgc3VwcG9ydCBpbiB0aGUgSlMgZW5naW5lLlxuICAvLyBoYW5kbGUgYSBnZW5lcmF0ZWQgd2FzbSBpbnN0YW5jZSwgcmVjZWl2aW5nIGl0cyBleHBvcnRzIGFuZFxuICAvLyBwZXJmb3JtaW5nIG90aGVyIG5lY2Vzc2FyeSBzZXR1cFxuICAvKiogQHBhcmFtIHtXZWJBc3NlbWJseS5Nb2R1bGU9fSBtb2R1bGUqL1xuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHdhc21FeHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcblxuICAgIHdhc21FeHBvcnRzID0gQXN5bmNpZnkuaW5zdHJ1bWVudFdhc21FeHBvcnRzKHdhc21FeHBvcnRzKTtcblxuICAgIFxuXG4gICAgYWRkT25Jbml0KHdhc21FeHBvcnRzWydfX3dhc21fY2FsbF9jdG9ycyddKTtcblxuICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcbiAgICByZXR1cm4gd2FzbUV4cG9ydHM7XG4gIH1cbiAgLy8gd2FpdCBmb3IgdGhlIHB0aHJlYWQgcG9vbCAoaWYgYW55KVxuICBhZGRSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgLy8gUHJlZmVyIHN0cmVhbWluZyBpbnN0YW50aWF0aW9uIGlmIGF2YWlsYWJsZS5cbiAgLy8gQXN5bmMgY29tcGlsYXRpb24gY2FuIGJlIGNvbmZ1c2luZyB3aGVuIGFuIGVycm9yIG9uIHRoZSBwYWdlIG92ZXJ3cml0ZXMgTW9kdWxlXG4gIC8vIChmb3IgZXhhbXBsZSwgaWYgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIHdyb25nLCBhbmQgdGhlIG9uZSBkZWZpbmluZyBNb2R1bGUgaXNcbiAgLy8gbGF0ZXIpLCBzbyB3ZSBzYXZlIE1vZHVsZSBhbmQgY2hlY2sgaXQgbGF0ZXIuXG4gIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyAncmVzdWx0JyBpcyBhIFJlc3VsdE9iamVjdCBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXG4gICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcbiAgICBhc3NlcnQoTW9kdWxlID09PSB0cnVlTW9kdWxlLCAndGhlIE1vZHVsZSBvYmplY3Qgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBkdXJpbmcgYXN5bmMgY29tcGlsYXRpb24gLSBwZXJoYXBzIHRoZSBvcmRlciBvZiBIVE1MIGVsZW1lbnRzIGlzIHdyb25nPycpO1xuICAgIHRydWVNb2R1bGUgPSBudWxsO1xuICAgIC8vIFRPRE86IER1ZSB0byBDbG9zdXJlIHJlZ3Jlc3Npb24gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMTkzLCB0aGUgYWJvdmUgbGluZSBubyBsb25nZXIgb3B0aW1pemVzIG91dCBkb3duIHRvIHRoZSBmb2xsb3dpbmcgbGluZS5cbiAgICAvLyBXaGVuIHRoZSByZWdyZXNzaW9uIGlzIGZpeGVkLCBjYW4gcmVzdG9yZSB0aGUgYWJvdmUgUFRIUkVBRFMtZW5hYmxlZCBwYXRoLlxuICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICB9XG5cbiAgLy8gVXNlciBzaGVsbCBwYWdlcyBjYW4gd3JpdGUgdGhlaXIgb3duIE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gPSBmdW5jdGlvbihpbXBvcnRzLCBzdWNjZXNzQ2FsbGJhY2spIGNhbGxiYWNrXG4gIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0b1xuICAvLyBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWwgdG8gYW55IG90aGVyIGFzeW5jIHN0YXJ0dXAgYWN0aW9ucyB0aGV5IGFyZVxuICAvLyBwZXJmb3JtaW5nLlxuICAvLyBBbHNvIHB0aHJlYWRzIGFuZCB3YXNtIHdvcmtlcnMgaW5pdGlhbGl6ZSB0aGUgd2FzbSBpbnN0YW5jZSB0aHJvdWdoIHRoaXNcbiAgLy8gcGF0aC5cbiAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfWApO1xuICAgICAgICAvLyBJZiBpbnN0YW50aWF0aW9uIGZhaWxzLCByZWplY3QgdGhlIG1vZHVsZSByZWFkeSBwcm9taXNlLlxuICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF3YXNtQmluYXJ5RmlsZSkgd2FzbUJpbmFyeUZpbGUgPSBmaW5kV2FzbUJpbmFyeSgpO1xuXG4gIC8vIElmIGluc3RhbnRpYXRpb24gZmFpbHMsIHJlamVjdCB0aGUgbW9kdWxlIHJlYWR5IHByb21pc2UuXG4gIGluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSwgd2FzbUJpbmFyeUZpbGUsIGluZm8sIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICByZXR1cm4ge307IC8vIG5vIGV4cG9ydHMgeWV0OyB3ZSdsbCBmaWxsIHRoZW0gaW4gbGF0ZXJcbn1cblxuLy8gR2xvYmFscyB1c2VkIGJ5IEpTIGk2NCBjb252ZXJzaW9ucyAoc2VlIG1ha2VTZXRWYWx1ZSlcbnZhciB0ZW1wRG91YmxlO1xudmFyIHRlbXBJNjQ7XG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfZGVidWcuanNcbi8vIEVuZGlhbm5lc3MgY2hlY2tcbihmdW5jdGlvbigpIHtcbiAgdmFyIGgxNiA9IG5ldyBJbnQxNkFycmF5KDEpO1xuICB2YXIgaDggPSBuZXcgSW50OEFycmF5KGgxNi5idWZmZXIpO1xuICBoMTZbMF0gPSAweDYzNzM7XG4gIGlmIChoOFswXSAhPT0gMHg3MyB8fCBoOFsxXSAhPT0gMHg2MykgdGhyb3cgJ1J1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEgKFJ1biB3aXRoIC1zU1VQUE9SVF9CSUdfRU5ESUFOIHRvIGJ5cGFzcyknO1xufSkoKTtcblxuZnVuY3Rpb24gbGVnYWN5TW9kdWxlUHJvcChwcm9wLCBuZXdOYW1lLCBpbmNvbWluZz10cnVlKSB7XG4gIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgcHJvcCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBsZXQgZXh0cmEgPSBpbmNvbWluZyA/ICcgKHRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBwcm92aWRlZCBvbiBNb2R1bGUsIGJ1dCBhZnRlciBzdGFydHVwIHRoZSB2YWx1ZSBpcyBvbmx5IGxvb2tlZCBmb3Igb24gYSBsb2NhbCB2YXJpYWJsZSBvZiB0aGF0IG5hbWUpJyA6ICcnO1xuICAgICAgICBhYm9ydChgXFxgTW9kdWxlLiR7cHJvcH1cXGAgaGFzIGJlZW4gcmVwbGFjZWQgYnkgXFxgJHtuZXdOYW1lfVxcYGAgKyBleHRyYSk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVkTW9kdWxlUHJvcChwcm9wKSB7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgcHJvcCkpIHtcbiAgICBhYm9ydChgXFxgTW9kdWxlLiR7cHJvcH1cXGAgd2FzIHN1cHBsaWVkIGJ1dCBcXGAke3Byb3B9XFxgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJYCk7XG4gIH1cbn1cblxuLy8gZm9yY2luZyB0aGUgZmlsZXN5c3RlbSBleHBvcnRzIGEgZmV3IHRoaW5ncyBieSBkZWZhdWx0XG5mdW5jdGlvbiBpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0obmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ0ZTX2NyZWF0ZVBhdGgnIHx8XG4gICAgICAgICBuYW1lID09PSAnRlNfY3JlYXRlRGF0YUZpbGUnIHx8XG4gICAgICAgICBuYW1lID09PSAnRlNfY3JlYXRlUHJlbG9hZGVkRmlsZScgfHxcbiAgICAgICAgIG5hbWUgPT09ICdGU191bmxpbmsnIHx8XG4gICAgICAgICBuYW1lID09PSAnYWRkUnVuRGVwZW5kZW5jeScgfHxcbiAgICAgICAgIC8vIFRoZSBvbGQgRlMgaGFzIHNvbWUgZnVuY3Rpb25hbGl0eSB0aGF0IFdhc21GUyBsYWNrcy5cbiAgICAgICAgIG5hbWUgPT09ICdGU19jcmVhdGVMYXp5RmlsZScgfHxcbiAgICAgICAgIG5hbWUgPT09ICdGU19jcmVhdGVEZXZpY2UnIHx8XG4gICAgICAgICBuYW1lID09PSAncmVtb3ZlUnVuRGVwZW5kZW5jeSc7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdHbG9iYWwoc3ltLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHN5bSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICB3YXJuT25jZShgXFxgJHtzeW19XFxgIGlzIG5vdCBsb25nZXIgZGVmaW5lZCBieSBlbXNjcmlwdGVuLiAke21zZ31gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5taXNzaW5nR2xvYmFsKCdidWZmZXInLCAnUGxlYXNlIHVzZSBIRUFQOC5idWZmZXIgb3Igd2FzbU1lbW9yeS5idWZmZXInKTtcbm1pc3NpbmdHbG9iYWwoJ2FzbScsICdQbGVhc2UgdXNlIHdhc21FeHBvcnRzIGluc3RlYWQnKTtcblxuZnVuY3Rpb24gbWlzc2luZ0xpYnJhcnlTeW1ib2woc3ltKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPSAndW5kZWZpbmVkJyAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBzeW0pKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHN5bSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICAvLyBDYW4ndCBgYWJvcnQoKWAgaGVyZSBiZWNhdXNlIGl0IHdvdWxkIGJyZWFrIGNvZGUgdGhhdCBkb2VzIHJ1bnRpbWVcbiAgICAgICAgLy8gY2hlY2tzLiAgZS5nLiBgaWYgKHR5cGVvZiBTREwgPT09ICd1bmRlZmluZWQnKWAuXG4gICAgICAgIHZhciBtc2cgPSBgXFxgJHtzeW19XFxgIGlzIGEgbGlicmFyeSBzeW1ib2wgYW5kIG5vdCBpbmNsdWRlZCBieSBkZWZhdWx0OyBhZGQgaXQgdG8geW91ciBsaWJyYXJ5LmpzIF9fZGVwcyBvciB0byBERUZBVUxUX0xJQlJBUllfRlVOQ1NfVE9fSU5DTFVERSBvbiB0aGUgY29tbWFuZCBsaW5lYDtcbiAgICAgICAgLy8gREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREUgcmVxdWlyZXMgdGhlIG5hbWUgYXMgaXQgYXBwZWFycyBpblxuICAgICAgICAvLyBsaWJyYXJ5LmpzLCB3aGljaCBtZWFucyAkbmFtZSBmb3IgYSBKUyBuYW1lIHdpdGggbm8gcHJlZml4LCBvciBuYW1lXG4gICAgICAgIC8vIGZvciBhIEpTIG5hbWUgbGlrZSBfbmFtZS5cbiAgICAgICAgdmFyIGxpYnJhcnlTeW1ib2wgPSBzeW07XG4gICAgICAgIGlmICghbGlicmFyeVN5bWJvbC5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAgICAgICBsaWJyYXJ5U3ltYm9sID0gJyQnICsgc3ltO1xuICAgICAgICB9XG4gICAgICAgIG1zZyArPSBgIChlLmcuIC1zREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREU9JyR7bGlicmFyeVN5bWJvbH0nKWA7XG4gICAgICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xuICAgICAgICAgIG1zZyArPSAnLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXNGT1JDRV9GSUxFU1lTVEVNKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdSc7XG4gICAgICAgIH1cbiAgICAgICAgd2Fybk9uY2UobXNnKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBBbnkgc3ltYm9sIHRoYXQgaXMgbm90IGluY2x1ZGVkIGZyb20gdGhlIEpTIGxpYnJhcnkgaXMgYWxzbyAoYnkgZGVmaW5pdGlvbilcbiAgLy8gbm90IGV4cG9ydGVkIG9uIHRoZSBNb2R1bGUgb2JqZWN0LlxuICB1bmV4cG9ydGVkUnVudGltZVN5bWJvbChzeW0pO1xufVxuXG5mdW5jdGlvbiB1bmV4cG9ydGVkUnVudGltZVN5bWJvbChzeW0pIHtcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgc3ltKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIHN5bSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICB2YXIgbXNnID0gYCcke3N5bX0nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRW1zY3JpcHRlbiBGQVEpYDtcbiAgICAgICAgaWYgKGlzRXhwb3J0ZWRCeUZvcmNlRmlsZXN5c3RlbShzeW0pKSB7XG4gICAgICAgICAgbXNnICs9ICcuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91JztcbiAgICAgICAgfVxuICAgICAgICBhYm9ydChtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vIFVzZWQgYnkgWFhYWFhfREVCVUcgc2V0dGluZ3MgdG8gb3V0cHV0IGRlYnVnIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZGJnKC4uLmFyZ3MpIHtcbiAgLy8gVE9ETyhzYmMpOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlIHNvbWVob3cuICBJdHMgbm90IGFsd2F5cyBjb252ZW5pZW50IGZvclxuICAvLyBsb2dnaW5nIHRvIHNob3cgdXAgYXMgd2FybmluZ3MuXG4gIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbn1cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2RlYnVnLmpzXG4vLyA9PT0gQm9keSA9PT1cblxuZnVuY3Rpb24gc2V0X2FzeW5jaWZ5X3N0YWNrX3NpemUoc2l6ZSxkZWZhdWx0X3NpemUpIHsgQXN5bmNpZnkuU3RhY2tTaXplID0gc2l6ZSB8fCBkZWZhdWx0X3NpemU7IH1cbmZ1bmN0aW9uIHF0c19ob3N0X2NhbGxfZnVuY3Rpb24oY3R4LHRoaXNfcHRyLGFyZ2MsYXJndixtYWdpY19mdW5jX2lkKSB7IGNvbnN0IGFzeW5jaWZ5ID0ge1snaGFuZGxlU2xlZXAnXSA6IEFzeW5jaWZ5LmhhbmRsZVNsZWVwfTsgcmV0dXJuIE1vZHVsZVsnY2FsbGJhY2tzJ11bJ2NhbGxGdW5jdGlvbiddKGFzeW5jaWZ5LCBjdHgsIHRoaXNfcHRyLCBhcmdjLCBhcmd2LCBtYWdpY19mdW5jX2lkKTsgfVxuZnVuY3Rpb24gcXRzX2hvc3RfaW50ZXJydXB0X2hhbmRsZXIocnQpIHsgY29uc3QgYXN5bmNpZnkgPSB1bmRlZmluZWQ7IHJldHVybiBNb2R1bGVbJ2NhbGxiYWNrcyddWydzaG91bGRJbnRlcnJ1cHQnXShhc3luY2lmeSwgcnQpOyB9XG5mdW5jdGlvbiBxdHNfaG9zdF9sb2FkX21vZHVsZV9zb3VyY2UocnQsY3R4LG1vZHVsZV9uYW1lKSB7IGNvbnN0IGFzeW5jaWZ5ID0ge1snaGFuZGxlU2xlZXAnXSA6IEFzeW5jaWZ5LmhhbmRsZVNsZWVwfTsgY29uc3QgbW9kdWxlTmFtZVN0cmluZyA9IFVURjhUb1N0cmluZyhtb2R1bGVfbmFtZSk7IHJldHVybiBNb2R1bGVbJ2NhbGxiYWNrcyddWydsb2FkTW9kdWxlU291cmNlJ10oYXN5bmNpZnksIHJ0LCBjdHgsIG1vZHVsZU5hbWVTdHJpbmcpOyB9XG5mdW5jdGlvbiBxdHNfaG9zdF9ub3JtYWxpemVfbW9kdWxlKHJ0LGN0eCxtb2R1bGVfYmFzZV9uYW1lLG1vZHVsZV9uYW1lKSB7IGNvbnN0IGFzeW5jaWZ5ID0ge1snaGFuZGxlU2xlZXAnXSA6IEFzeW5jaWZ5LmhhbmRsZVNsZWVwfTsgY29uc3QgbW9kdWxlQmFzZU5hbWVTdHJpbmcgPSBVVEY4VG9TdHJpbmcobW9kdWxlX2Jhc2VfbmFtZSk7IGNvbnN0IG1vZHVsZU5hbWVTdHJpbmcgPSBVVEY4VG9TdHJpbmcobW9kdWxlX25hbWUpOyByZXR1cm4gTW9kdWxlWydjYWxsYmFja3MnXVsnbm9ybWFsaXplTW9kdWxlJ10oYXN5bmNpZnksIHJ0LCBjdHgsIG1vZHVsZUJhc2VOYW1lU3RyaW5nLCBtb2R1bGVOYW1lU3RyaW5nKTsgfVxuXG4vLyBlbmQgaW5jbHVkZTogcHJlYW1ibGUuanNcblxuXG4gIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHRoaXMubmFtZSA9ICdFeGl0U3RhdHVzJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IGBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7c3RhdHVzfSlgO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxuXG4gIHZhciBjYWxsUnVudGltZUNhbGxiYWNrcyA9IChjYWxsYmFja3MpID0+IHtcbiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBQYXNzIHRoZSBtb2R1bGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHB0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gJyonO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaTEnOiByZXR1cm4gSEVBUDhbcHRyXTtcbiAgICAgIGNhc2UgJ2k4JzogcmV0dXJuIEhFQVA4W3B0cl07XG4gICAgICBjYXNlICdpMTYnOiByZXR1cm4gSEVBUDE2WygocHRyKT4+MSldO1xuICAgICAgY2FzZSAnaTMyJzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcbiAgICAgIGNhc2UgJ2k2NCc6IGFib3J0KCd0byBkbyBnZXRWYWx1ZShpNjQpIHVzZSBXQVNNX0JJR0lOVCcpO1xuICAgICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gSEVBUEYzMlsoKHB0cik+PjIpXTtcbiAgICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiBIRUFQRjY0WygocHRyKT4+MyldO1xuICAgICAgY2FzZSAnKic6IHJldHVybiBIRUFQVTMyWygocHRyKT4+MildO1xuICAgICAgZGVmYXVsdDogYWJvcnQoYGludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG5cbiAgdmFyIHB0clRvU3RyaW5nID0gKHB0cikgPT4ge1xuICAgICAgYXNzZXJ0KHR5cGVvZiBwdHIgPT09ICdudW1iZXInKTtcbiAgICAgIC8vIFdpdGggQ0FOX0FERFJFU1NfMkdCIG9yIE1FTU9SWTY0LCBwb2ludGVycyBhcmUgYWxyZWFkeSB1bnNpZ25lZC5cbiAgICAgIHB0ciA+Pj49IDA7XG4gICAgICByZXR1cm4gJzB4JyArIHB0ci50b1N0cmluZygxNikucGFkU3RhcnQoOCwgJzAnKTtcbiAgICB9O1xuXG4gIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqL1xuICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jykge1xuICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpMSc6IEhFQVA4W3B0cl0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpOCc6IEhFQVA4W3B0cl0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpMTYnOiBIRUFQMTZbKChwdHIpPj4xKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpMzInOiBIRUFQMzJbKChwdHIpPj4yKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpNjQnOiBhYm9ydCgndG8gZG8gc2V0VmFsdWUoaTY0KSB1c2UgV0FTTV9CSUdJTlQnKTtcbiAgICAgIGNhc2UgJ2Zsb2F0JzogSEVBUEYzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2RvdWJsZSc6IEhFQVBGNjRbKChwdHIpPj4zKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICcqJzogSEVBUFUzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YWNrUmVzdG9yZSA9ICh2YWwpID0+IF9fZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlKHZhbCk7XG5cbiAgdmFyIHN0YWNrU2F2ZSA9ICgpID0+IF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50KCk7XG5cbiAgdmFyIHdhcm5PbmNlID0gKHRleHQpID0+IHtcbiAgICAgIHdhcm5PbmNlLnNob3duIHx8PSB7fTtcbiAgICAgIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHtcbiAgICAgICAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xuICAgICAgICBlcnIodGV4dCk7XG4gICAgICB9XG4gICAgfTtcblxuICB2YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbiAgXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludGVyICdpZHgnIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGdpdmVuXG4gICAgICogYXJyYXkgdGhhdCBjb250YWlucyB1aW50OCB2YWx1ZXMsIHJldHVybnMgYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGFcbiAgICAgKiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4gICAgICogaGVhcE9yQXJyYXkgaXMgZWl0aGVyIGEgcmVndWxhciBhcnJheSwgb3IgYSBKYXZhU2NyaXB0IHR5cGVkIGFycmF5IHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4Qnl0ZXNUb1JlYWRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gIHZhciBVVEY4QXJyYXlUb1N0cmluZyA9IChoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkgPT4ge1xuICAgICAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICAgICAgdmFyIGVuZFB0ciA9IGlkeDtcbiAgICAgIC8vIFRleHREZWNvZGVyIG5lZWRzIHRvIGtub3cgdGhlIGJ5dGUgbGVuZ3RoIGluIGFkdmFuY2UsIGl0IGRvZXNuJ3Qgc3RvcCBvblxuICAgICAgLy8gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi4gIEFsc28sIHVzZSB0aGUgbGVuZ3RoIGluZm8gdG8gYXZvaWQgcnVubmluZyB0aW55XG4gICAgICAvLyBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxuICAgICAgLy8gKEFzIGEgdGlueSBjb2RlIHNhdmUgdHJpY2ssIGNvbXBhcmUgZW5kUHRyIGFnYWluc3QgZW5kSWR4IHVzaW5nIGEgbmVnYXRpb24sXG4gICAgICAvLyBzbyB0aGF0IHVuZGVmaW5lZCBtZWFucyBJbmZpbml0eSlcbiAgICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuICBcbiAgICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgLy8gSWYgYnVpbGRpbmcgd2l0aCBUZXh0RGVjb2Rlciwgd2UgaGF2ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSBzdHJpbmcgbGVuZ3RoXG4gICAgICAvLyBhYm92ZSwgc28gdGVzdCBsb29wIGVuZCBjb25kaXRpb24gYWdhaW5zdCB0aGF0XG4gICAgICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICAgICAgIC8vIEZvciBVVEY4IGJ5dGUgc3RydWN0dXJlLCBzZWU6XG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjI5XG4gICAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgICAgaWYgKCEodTAgJiAweDgwKSkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgICAgaWYgKCh1MCAmIDB4RjApID09IDB4RTApIHtcbiAgICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCh1MCAmIDB4RjgpICE9IDB4RjApIHdhcm5PbmNlKCdJbnZhbGlkIFVURi04IGxlYWRpbmcgYnl0ZSAnICsgcHRyVG9TdHJpbmcodTApICsgJyBlbmNvdW50ZXJlZCB3aGVuIGRlc2VyaWFsaXppbmcgYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkgdG8gYSBKUyBzdHJpbmchJyk7XG4gICAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IChoZWFwT3JBcnJheVtpZHgrK10gJiA2Myk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlXG4gICAgICogZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG1heEJ5dGVzVG9SZWFkIC0gQW4gb3B0aW9uYWwgbGVuZ3RoIHRoYXQgc3BlY2lmaWVzIHRoZVxuICAgICAqICAgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gWW91IGNhbiBvbWl0IHRoaXMgcGFyYW1ldGVyIHRvIHNjYW4gdGhlXG4gICAgICogICBzdHJpbmcgdW50aWwgdGhlIGZpcnN0IDAgYnl0ZS4gSWYgbWF4Qnl0ZXNUb1JlYWQgaXMgcGFzc2VkLCBhbmQgdGhlIHN0cmluZ1xuICAgICAqICAgYXQgW3B0ciwgcHRyK21heEJ5dGVzVG9SZWFkclsgY29udGFpbnMgYSBudWxsIGJ5dGUgaW4gdGhlIG1pZGRsZSwgdGhlbiB0aGVcbiAgICAgKiAgIHN0cmluZyB3aWxsIGN1dCBzaG9ydCBhdCB0aGF0IGJ5dGUgaW5kZXggKGkuZS4gbWF4Qnl0ZXNUb1JlYWQgd2lsbCBub3RcbiAgICAgKiAgIHByb2R1Y2UgYSBzdHJpbmcgb2YgZXhhY3QgbGVuZ3RoIFtwdHIsIHB0cittYXhCeXRlc1RvUmVhZFspIE4uQi4gbWl4aW5nXG4gICAgICogICBmcmVxdWVudCB1c2VzIG9mIFVURjhUb1N0cmluZygpIHdpdGggYW5kIHdpdGhvdXQgbWF4Qnl0ZXNUb1JlYWQgbWF5IHRocm93XG4gICAgICogICBKUyBKSVQgb3B0aW1pemF0aW9ucyBvZmYsIHNvIGl0IGlzIHdvcnRoIHRvIGNvbnNpZGVyIGNvbnNpc3RlbnRseSB1c2luZyBvbmVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gIHZhciBVVEY4VG9TdHJpbmcgPSAocHRyLCBtYXhCeXRlc1RvUmVhZCkgPT4ge1xuICAgICAgYXNzZXJ0KHR5cGVvZiBwdHIgPT0gJ251bWJlcicsIGBVVEY4VG9TdHJpbmcgZXhwZWN0cyBhIG51bWJlciAoZ290ICR7dHlwZW9mIHB0cn0pYCk7XG4gICAgICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xuICAgIH07XG4gIHZhciBfX19hc3NlcnRfZmFpbCA9IChjb25kaXRpb24sIGZpbGVuYW1lLCBsaW5lLCBmdW5jKSA9PiB7XG4gICAgICBhYm9ydChgQXNzZXJ0aW9uIGZhaWxlZDogJHtVVEY4VG9TdHJpbmcoY29uZGl0aW9uKX0sIGF0OiBgICsgW2ZpbGVuYW1lID8gVVRGOFRvU3RyaW5nKGZpbGVuYW1lKSA6ICd1bmtub3duIGZpbGVuYW1lJywgbGluZSwgZnVuYyA/IFVURjhUb1N0cmluZyhmdW5jKSA6ICd1bmtub3duIGZ1bmN0aW9uJ10pO1xuICAgIH07XG5cbiAgdmFyIF9fYWJvcnRfanMgPSAoKSA9PiB7XG4gICAgICBhYm9ydCgnbmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KCknKTtcbiAgICB9O1xuXG4gIHZhciBfX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzID0gKGRlc3QsIHNyYywgbnVtKSA9PiBIRUFQVTguY29weVdpdGhpbihkZXN0LCBzcmMsIHNyYyArIG51bSk7XG5cbiAgdmFyIGlzTGVhcFllYXIgPSAoeWVhcikgPT4geWVhciU0ID09PSAwICYmICh5ZWFyJTEwMCAhPT0gMCB8fCB5ZWFyJTQwMCA9PT0gMCk7XG4gIFxuICB2YXIgTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgPSBbMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XTtcbiAgXG4gIHZhciBNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO1xuICB2YXIgeWRheUZyb21EYXRlID0gKGRhdGUpID0+IHtcbiAgICAgIHZhciBsZWFwID0gaXNMZWFwWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSAobGVhcCA/IE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFIDogTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUpO1xuICAgICAgdmFyIHlkYXkgPSBtb250aERheXNDdW11bGF0aXZlW2RhdGUuZ2V0TW9udGgoKV0gKyBkYXRlLmdldERhdGUoKSAtIDE7IC8vIC0xIHNpbmNlIGl0J3MgZGF5cyBzaW5jZSBKYW4gMVxuICBcbiAgICAgIHJldHVybiB5ZGF5O1xuICAgIH07XG4gIFxuICB2YXIgY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQgPSAobG8sIGhpKSA9PiB7XG4gICAgICBhc3NlcnQobG8gPT0gKGxvID4+PiAwKSB8fCBsbyA9PSAobG98MCkpOyAvLyBsbyBzaG91bGQgZWl0aGVyIGJlIGEgaTMyIG9yIGEgdTMyXG4gICAgICBhc3NlcnQoaGkgPT09IChoaXwwKSk7ICAgICAgICAgICAgICAgICAgICAvLyBoaSBzaG91bGQgYmUgYSBpMzJcbiAgICAgIHJldHVybiAoKGhpICsgMHgyMDAwMDApID4+PiAwIDwgMHg0MDAwMDEgLSAhIWxvKSA/IChsbyA+Pj4gMCkgKyBoaSAqIDQyOTQ5NjcyOTYgOiBOYU47XG4gICAgfTtcbiAgZnVuY3Rpb24gX19sb2NhbHRpbWVfanModGltZV9sb3csIHRpbWVfaGlnaCx0bVB0cikge1xuICAgIHZhciB0aW1lID0gY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQodGltZV9sb3csIHRpbWVfaGlnaCk7XG4gIFxuICAgIFxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKjEwMDApO1xuICAgICAgSEVBUDMyWygodG1QdHIpPj4yKV0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg4KSk+PjIpXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTYpKT4+MildID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjApKT4+MildID0gZGF0ZS5nZXRGdWxsWWVhcigpLTE5MDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyNCkpPj4yKV0gPSBkYXRlLmdldERheSgpO1xuICBcbiAgICAgIHZhciB5ZGF5ID0geWRheUZyb21EYXRlKGRhdGUpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyOCkpPj4yKV0gPSB5ZGF5O1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzYpKT4+MildID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG4gIFxuICAgICAgLy8gQXR0ZW50aW9uOiBEU1QgaXMgaW4gRGVjZW1iZXIgaW4gU291dGgsIGFuZCBzb21lIHJlZ2lvbnMgZG9uJ3QgaGF2ZSBEU1QgYXQgYWxsLlxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBkc3QgPSAoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT0gTWF0aC5taW4od2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzIpKT4+MildID0gZHN0O1xuICAgIDtcbiAgfVxuXG4gIHZhciBzdHJpbmdUb1VURjhBcnJheSA9IChzdHIsIGhlYXAsIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycsIGBzdHJpbmdUb1VURjhBcnJheSBleHBlY3RzIGEgc3RyaW5nIChnb3QgJHt0eXBlb2Ygc3RyfSlgKTtcbiAgICAgIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsXG4gICAgICAvLyB1bmRlZmluZWQgYW5kIGZhbHNlIGVhY2ggZG9uJ3Qgd3JpdGUgb3V0IGFueSBieXRlcy5cbiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKVxuICAgICAgICByZXR1cm4gMDtcbiAgXG4gICAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gICAgICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsgLy8gLTEgZm9yIHN0cmluZyBudWxsIHRlcm1pbmF0b3IuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlXG4gICAgICAgIC8vIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGVcbiAgICAgICAgLy8gVVRGMTYtPlVURjMyLT5VVEY4LlxuICAgICAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xuICAgICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dFxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgICAgICBpZiAodSA+PSAweEQ4MDAgJiYgdSA8PSAweERGRkYpIHtcbiAgICAgICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8ICh1MSAmIDB4M0ZGKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gdTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4QzAgfCAodSA+PiA2KTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEUwIHwgKHUgPj4gMTIpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGlmICh1ID4gMHgxMEZGRkYpIHdhcm5PbmNlKCdJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCAnICsgcHRyVG9TdHJpbmcodSkgKyAnIGVuY291bnRlcmVkIHdoZW4gc2VyaWFsaXppbmcgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkhIChWYWxpZCB1bmljb2RlIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbiByYW5nZSAwLTB4MTBGRkZGKS4nKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4RjAgfCAodSA+PiAxOCk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBidWZmZXIuXG4gICAgICBoZWFwW291dElkeF0gPSAwO1xuICAgICAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xuICAgIH07XG4gIHZhciBzdHJpbmdUb1VURjggPSAoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgPT4ge1xuICAgICAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgaXMgbWlzc2luZyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBidWZmZXIhJyk7XG4gICAgICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbiAgICB9O1xuICBcbiAgdmFyIGxlbmd0aEJ5dGVzVVRGOCA9IChzdHIpID0+IHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZVxuICAgICAgICAvLyB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgU28gZGVjb2RlXG4gICAgICAgIC8vIFVURjE2LT5VVEYzMi0+VVRGOC5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8PSAweDdGRikge1xuICAgICAgICAgIGxlbiArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7XG4gICAgICAgICAgbGVuICs9IDQ7ICsraTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW4gKz0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9O1xuICB2YXIgX190enNldF9qcyA9ICh0aW1lem9uZSwgZGF5bGlnaHQsIHN0ZF9uYW1lLCBkc3RfbmFtZSkgPT4ge1xuICAgICAgLy8gVE9ETzogVXNlIChtYWxsZWFibGUpIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbnN0ZWFkIG9mIHN5c3RlbSBzZXR0aW5ncy5cbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBcbiAgICAgIC8vIExvY2FsIHN0YW5kYXJkIHRpbWV6b25lIG9mZnNldC4gTG9jYWwgc3RhbmRhcmQgdGltZSBpcyBub3QgYWRqdXN0ZWQgZm9yXG4gICAgICAvLyBkYXlsaWdodCBzYXZpbmdzLiAgVGhpcyBjb2RlIHVzZXMgdGhlIGZhY3QgdGhhdCBnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zXG4gICAgICAvLyBhIGdyZWF0ZXIgdmFsdWUgZHVyaW5nIFN0YW5kYXJkIFRpbWUgdmVyc3VzIERheWxpZ2h0IFNhdmluZyBUaW1lIChEU1QpLlxuICAgICAgLy8gVGh1cyBpdCBkZXRlcm1pbmVzIHRoZSBleHBlY3RlZCBvdXRwdXQgZHVyaW5nIFN0YW5kYXJkIFRpbWUsIGFuZCBpdFxuICAgICAgLy8gY29tcGFyZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBkYXRlIHRoZSBzYW1lIChTdGFuZGFyZCkgb3IgbGVzc1xuICAgICAgLy8gKERTVCkuXG4gICAgICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgLy8gdGltZXpvbmUgaXMgc3BlY2lmaWVkIGFzIHNlY29uZHMgd2VzdCBvZiBVVEMgKFwiVGhlIGV4dGVybmFsIHZhcmlhYmxlXG4gICAgICAvLyBgdGltZXpvbmVgIHNoYWxsIGJlIHNldCB0byB0aGUgZGlmZmVyZW5jZSwgaW4gc2Vjb25kcywgYmV0d2VlblxuICAgICAgLy8gQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUgKFVUQykgYW5kIGxvY2FsIHN0YW5kYXJkIHRpbWUuXCIpLCB0aGUgc2FtZVxuICAgICAgLy8gYXMgcmV0dXJuZWQgYnkgc3RkVGltZXpvbmVPZmZzZXQuXG4gICAgICAvLyBTZWUgaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvdHpzZXQuaHRtbFxuICAgICAgSEVBUFUzMlsoKHRpbWV6b25lKT4+MildID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcbiAgXG4gICAgICBIRUFQMzJbKChkYXlsaWdodCk+PjIpXSA9IE51bWJlcih3aW50ZXJPZmZzZXQgIT0gc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICB2YXIgZXh0cmFjdFpvbmUgPSAodGltZXpvbmVPZmZzZXQpID0+IHtcbiAgICAgICAgLy8gV2h5IGludmVyc2Ugc2lnbj9cbiAgICAgICAgLy8gUmVhZCBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0VGltZXpvbmVPZmZzZXRcbiAgICAgICAgdmFyIHNpZ24gPSB0aW1lem9uZU9mZnNldCA+PSAwID8gXCItXCIgOiBcIitcIjtcbiAgXG4gICAgICAgIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyh0aW1lem9uZU9mZnNldClcbiAgICAgICAgdmFyIGhvdXJzID0gU3RyaW5nKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICAgIHZhciBtaW51dGVzID0gU3RyaW5nKGFic09mZnNldCAlIDYwKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gIFxuICAgICAgICByZXR1cm4gYFVUQyR7c2lnbn0ke2hvdXJzfSR7bWludXRlc31gO1xuICAgICAgfVxuICBcbiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyT2Zmc2V0KTtcbiAgICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyT2Zmc2V0KTtcbiAgICAgIGFzc2VydCh3aW50ZXJOYW1lKTtcbiAgICAgIGFzc2VydChzdW1tZXJOYW1lKTtcbiAgICAgIGFzc2VydChsZW5ndGhCeXRlc1VURjgod2ludGVyTmFtZSkgPD0gMTYsIGB0aW1lem9uZSBuYW1lIHRydW5jYXRlZCB0byBmaXQgaW4gVFpOQU1FX01BWCAoJHt3aW50ZXJOYW1lfSlgKTtcbiAgICAgIGFzc2VydChsZW5ndGhCeXRlc1VURjgoc3VtbWVyTmFtZSkgPD0gMTYsIGB0aW1lem9uZSBuYW1lIHRydW5jYXRlZCB0byBmaXQgaW4gVFpOQU1FX01BWCAoJHtzdW1tZXJOYW1lfSlgKTtcbiAgICAgIGlmIChzdW1tZXJPZmZzZXQgPCB3aW50ZXJPZmZzZXQpIHtcbiAgICAgICAgLy8gTm9ydGhlcm4gaGVtaXNwaGVyZVxuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgc3RkX25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIGRzdF9uYW1lLCAxNyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgZHN0X25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIHN0ZF9uYW1lLCAxNyk7XG4gICAgICB9XG4gICAgfTtcblxuICB2YXIgX2Vtc2NyaXB0ZW5fZGF0ZV9ub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xuXG4gIHZhciBnZXRIZWFwTWF4ID0gKCkgPT5cbiAgICAgIC8vIFN0YXkgb25lIFdhc20gcGFnZSBzaG9ydCBvZiA0R0I6IHdoaWxlIGUuZy4gQ2hyb21lIGlzIGFibGUgdG8gYWxsb2NhdGVcbiAgICAgIC8vIGZ1bGwgNEdCIFdhc20gbWVtb3JpZXMsIHRoZSBzaXplIHdpbGwgd3JhcCBiYWNrIHRvIDAgYnl0ZXMgaW4gV2FzbSBzaWRlXG4gICAgICAvLyBmb3IgYW55IGNvZGUgdGhhdCBkZWFscyB3aXRoIGhlYXAgc2l6ZXMsIHdoaWNoIHdvdWxkIHJlcXVpcmUgc3BlY2lhbFxuICAgICAgLy8gY2FzaW5nIGFsbCBoZWFwIHNpemUgcmVsYXRlZCBjb2RlIHRvIHRyZWF0IDAgc3BlY2lhbGx5LlxuICAgICAgMjE0NzQ4MzY0ODtcbiAgXG4gIHZhciBhbGlnbk1lbW9yeSA9IChzaXplLCBhbGlnbm1lbnQpID0+IHtcbiAgICAgIGFzc2VydChhbGlnbm1lbnQsIFwiYWxpZ25tZW50IGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gYWxpZ25tZW50KSAqIGFsaWdubWVudDtcbiAgICB9O1xuICBcbiAgdmFyIGdyb3dNZW1vcnkgPSAoc2l6ZSkgPT4ge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHZhciBwYWdlcyA9IChzaXplIC0gYi5ieXRlTGVuZ3RoICsgNjU1MzUpIC8gNjU1MzY7XG4gICAgICB0cnkge1xuICAgICAgICAvLyByb3VuZCBzaXplIGdyb3cgcmVxdWVzdCB1cCB0byB3YXNtIHBhZ2Ugc2l6ZSAoZml4ZWQgNjRLQiBwZXIgc3BlYylcbiAgICAgICAgd2FzbU1lbW9yeS5ncm93KHBhZ2VzKTsgLy8gLmdyb3coKSB0YWtlcyBhIGRlbHRhIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzaXplXG4gICAgICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gICAgICAgIHJldHVybiAxIC8qc3VjY2VzcyovO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGVycihgZ3Jvd01lbW9yeTogQXR0ZW1wdGVkIHRvIGdyb3cgaGVhcCBmcm9tICR7Yi5ieXRlTGVuZ3RofSBieXRlcyB0byAke3NpemV9IGJ5dGVzLCBidXQgZ290IGVycm9yOiAke2V9YCk7XG4gICAgICB9XG4gICAgICAvLyBpbXBsaWNpdCAwIHJldHVybiB0byBzYXZlIGNvZGUgc2l6ZSAoY2FsbGVyIHdpbGwgY2FzdCBcInVuZGVmaW5lZFwiIGludG8gMFxuICAgICAgLy8gYW55aG93KVxuICAgIH07XG4gIHZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCA9IChyZXF1ZXN0ZWRTaXplKSA9PiB7XG4gICAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gICAgICAvLyBXaXRoIENBTl9BRERSRVNTXzJHQiBvciBNRU1PUlk2NCwgcG9pbnRlcnMgYXJlIGFscmVhZHkgdW5zaWduZWQuXG4gICAgICByZXF1ZXN0ZWRTaXplID4+Pj0gMDtcbiAgICAgIC8vIFdpdGggbXVsdGl0aHJlYWRlZCBidWlsZHMsIHJhY2VzIGNhbiBoYXBwZW4gKGFub3RoZXIgdGhyZWFkIG1pZ2h0IGluY3JlYXNlIHRoZSBzaXplXG4gICAgICAvLyBpbiBiZXR3ZWVuKSwgc28gcmV0dXJuIGEgZmFpbHVyZSwgYW5kIGxldCB0aGUgY2FsbGVyIHJldHJ5LlxuICAgICAgYXNzZXJ0KHJlcXVlc3RlZFNpemUgPiBvbGRTaXplKTtcbiAgXG4gICAgICAvLyBNZW1vcnkgcmVzaXplIHJ1bGVzOlxuICAgICAgLy8gMS4gIEFsd2F5cyBpbmNyZWFzZSBoZWFwIHNpemUgdG8gYXQgbGVhc3QgdGhlIHJlcXVlc3RlZCBzaXplLCByb3VuZGVkIHVwXG4gICAgICAvLyAgICAgdG8gbmV4dCBwYWdlIG11bHRpcGxlLlxuICAgICAgLy8gMmEuIElmIE1FTU9SWV9HUk9XVEhfTElORUFSX1NURVAgPT0gLTEsIGV4Y2Vzc2l2ZWx5IHJlc2l6ZSB0aGUgaGVhcFxuICAgICAgLy8gICAgIGdlb21ldHJpY2FsbHk6IGluY3JlYXNlIHRoZSBoZWFwIHNpemUgYWNjb3JkaW5nIHRvXG4gICAgICAvLyAgICAgTUVNT1JZX0dST1dUSF9HRU9NRVRSSUNfU1RFUCBmYWN0b3IgKGRlZmF1bHQgKzIwJSksIEF0IG1vc3RcbiAgICAgIC8vICAgICBvdmVycmVzZXJ2ZSBieSBNRU1PUllfR1JPV1RIX0dFT01FVFJJQ19DQVAgYnl0ZXMgKGRlZmF1bHQgOTZNQikuXG4gICAgICAvLyAyYi4gSWYgTUVNT1JZX0dST1dUSF9MSU5FQVJfU1RFUCAhPSAtMSwgZXhjZXNzaXZlbHkgcmVzaXplIHRoZSBoZWFwXG4gICAgICAvLyAgICAgbGluZWFybHk6IGluY3JlYXNlIHRoZSBoZWFwIHNpemUgYnkgYXQgbGVhc3RcbiAgICAgIC8vICAgICBNRU1PUllfR1JPV1RIX0xJTkVBUl9TVEVQIGJ5dGVzLlxuICAgICAgLy8gMy4gIE1heCBzaXplIGZvciB0aGUgaGVhcCBpcyBjYXBwZWQgYXQgMjA0OE1CLVdBU01fUEFHRV9TSVpFLCBvciBieVxuICAgICAgLy8gICAgIE1BWElNVU1fTUVNT1JZLCBvciBieSBBU0FOIGxpbWl0LCBkZXBlbmRpbmcgb24gd2hpY2ggaXMgc21hbGxlc3RcbiAgICAgIC8vIDQuICBJZiB3ZSB3ZXJlIHVuYWJsZSB0byBhbGxvY2F0ZSBhcyBtdWNoIG1lbW9yeSwgaXQgbWF5IGJlIGR1ZSB0b1xuICAgICAgLy8gICAgIG92ZXItZWFnZXIgZGVjaXNpb24gdG8gZXhjZXNzaXZlbHkgcmVzZXJ2ZSBkdWUgdG8gKDMpIGFib3ZlLlxuICAgICAgLy8gICAgIEhlbmNlIGlmIGFuIGFsbG9jYXRpb24gZmFpbHMsIGN1dCBkb3duIG9uIHRoZSBhbW91bnQgb2YgZXhjZXNzXG4gICAgICAvLyAgICAgZ3Jvd3RoLCBpbiBhbiBhdHRlbXB0IHRvIHN1Y2NlZWQgdG8gcGVyZm9ybSBhIHNtYWxsZXIgYWxsb2NhdGlvbi5cbiAgXG4gICAgICAvLyBBIGxpbWl0IGlzIHNldCBmb3IgaG93IG11Y2ggd2UgY2FuIGdyb3cuIFdlIHNob3VsZCBub3QgZXhjZWVkIHRoYXRcbiAgICAgIC8vICh0aGUgd2FzbSBiaW5hcnkgc3BlY2lmaWVzIGl0LCBzbyBpZiB3ZSB0cmllZCwgd2UnZCBmYWlsIGFueWhvdykuXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIGVycihgQ2Fubm90IGVubGFyZ2UgbWVtb3J5LCByZXF1ZXN0ZWQgJHtyZXF1ZXN0ZWRTaXplfSBieXRlcywgYnV0IHRoZSBsaW1pdCBpcyAke21heEhlYXBTaXplfSBieXRlcyFgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICBcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwb3RlbnRpYWwgaGVhcCBzaXplIGluY3JlYXNlcy4gSWYgd2UgYXR0ZW1wdCBhIHRvbyBlYWdlclxuICAgICAgLy8gcmVzZXJ2YXRpb24gdGhhdCBmYWlscywgY3V0IGRvd24gb24gdGhlIGF0dGVtcHRlZCBzaXplIGFuZCByZXNlcnZlIGFcbiAgICAgIC8vIHNtYWxsZXIgYnVtcCBpbnN0ZWFkLiAobWF4IDMgdGltZXMsIGNob3NlbiBzb21ld2hhdCBhcmJpdHJhcmlseSlcbiAgICAgIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICAgICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTsgLy8gZW5zdXJlIGdlb21ldHJpYyBncm93dGhcbiAgICAgICAgLy8gYnV0IGxpbWl0IG92ZXJyZXNlcnZpbmcgKGRlZmF1bHQgdG8gY2FwcGluZyBhdCArOTZNQiBvdmVyZ3Jvd3RoIGF0IG1vc3QpXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUsIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYgKTtcbiAgXG4gICAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4obWF4SGVhcFNpemUsIGFsaWduTWVtb3J5KE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpKTtcbiAgXG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IGdyb3dNZW1vcnkobmV3U2l6ZSk7XG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyKGBGYWlsZWQgdG8gZ3JvdyB0aGUgaGVhcCBmcm9tICR7b2xkU2l6ZX0gYnl0ZXMgdG8gJHtuZXdTaXplfSBieXRlcywgbm90IGVub3VnaCBtZW1vcnkhYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICB2YXIgU1lTQ0FMTFMgPSB7XG4gIHZhcmFyZ3M6dW5kZWZpbmVkLFxuICBnZXRTdHIocHRyKSB7XG4gICAgICAgIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gIH07XG4gIHZhciBfZmRfY2xvc2UgPSAoZmQpID0+IHtcbiAgICAgIGFib3J0KCdmZF9jbG9zZSBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU0nKTtcbiAgICB9O1xuXG4gIGZ1bmN0aW9uIF9mZF9zZWVrKGZkLG9mZnNldF9sb3csIG9mZnNldF9oaWdoLHdoZW5jZSxuZXdPZmZzZXQpIHtcbiAgICB2YXIgb2Zmc2V0ID0gY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQob2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gpO1xuICBcbiAgICBcbiAgICAgIHJldHVybiA3MDtcbiAgICA7XG4gIH1cblxuICB2YXIgcHJpbnRDaGFyQnVmZmVycyA9IFtudWxsLFtdLFtdXTtcbiAgXG4gIHZhciBwcmludENoYXIgPSAoc3RyZWFtLCBjdXJyKSA9PiB7XG4gICAgICB2YXIgYnVmZmVyID0gcHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO1xuICAgICAgYXNzZXJ0KGJ1ZmZlcik7XG4gICAgICBpZiAoY3VyciA9PT0gMCB8fCBjdXJyID09PSAxMCkge1xuICAgICAgICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgdmFyIGZsdXNoX05PX0ZJTEVTWVNURU0gPSAoKSA9PiB7XG4gICAgICAvLyBmbHVzaCBhbnl0aGluZyByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlcnMgZHVyaW5nIHNodXRkb3duXG4gICAgICBfZmZsdXNoKDApO1xuICAgICAgaWYgKHByaW50Q2hhckJ1ZmZlcnNbMV0ubGVuZ3RoKSBwcmludENoYXIoMSwgMTApO1xuICAgICAgaWYgKHByaW50Q2hhckJ1ZmZlcnNbMl0ubGVuZ3RoKSBwcmludENoYXIoMiwgMTApO1xuICAgIH07XG4gIFxuICBcbiAgdmFyIF9mZF93cml0ZSA9IChmZCwgaW92LCBpb3ZjbnQsIHBudW0pID0+IHtcbiAgICAgIC8vIGhhY2sgdG8gc3VwcG9ydCBwcmludGYgaW4gU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNPTBcbiAgICAgIHZhciBudW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMlsoKGlvdik+PjIpXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKCgoaW92KSsoNCkpPj4yKV07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgcHJpbnRDaGFyKGZkLCBIRUFQVThbcHRyK2pdKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gKz0gbGVuO1xuICAgICAgfVxuICAgICAgSEVBUFUzMlsoKHBudW0pPj4yKV0gPSBudW07XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gIHZhciBydW5BbmRBYm9ydElmRXJyb3IgPSAoZnVuYykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYWJvcnQoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gIHZhciBoYW5kbGVFeGNlcHRpb24gPSAoZSkgPT4ge1xuICAgICAgLy8gQ2VydGFpbiBleGNlcHRpb24gdHlwZXMgd2UgZG8gbm90IHRyZWF0IGFzIGVycm9ycyBzaW5jZSB0aGV5IGFyZSB1c2VkIGZvclxuICAgICAgLy8gaW50ZXJuYWwgY29udHJvbCBmbG93LlxuICAgICAgLy8gMS4gRXhpdFN0YXR1cywgd2hpY2ggaXMgdGhyb3duIGJ5IGV4aXQoKVxuICAgICAgLy8gMi4gXCJ1bndpbmRcIiwgd2hpY2ggaXMgdGhyb3duIGJ5IGVtc2NyaXB0ZW5fdW53aW5kX3RvX2pzX2V2ZW50X2xvb3AoKSBhbmQgb3RoZXJzXG4gICAgICAvLyAgICB0aGF0IHdpc2ggdG8gcmV0dXJuIHRvIEpTIGV2ZW50IGxvb3AuXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4aXRTdGF0dXMgfHwgZSA9PSAndW53aW5kJykge1xuICAgICAgICByZXR1cm4gRVhJVFNUQVRVUztcbiAgICAgIH1cbiAgICAgIGNoZWNrU3RhY2tDb29raWUoKTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKSB7XG4gICAgICAgIGlmIChfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCgpIDw9IDApIHtcbiAgICAgICAgICBlcnIoJ1N0YWNrIG92ZXJmbG93IGRldGVjdGVkLiAgWW91IGNhbiB0cnkgaW5jcmVhc2luZyAtc1NUQUNLX1NJWkUgKGN1cnJlbnRseSBzZXQgdG8gNTI0Mjg4MCknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdF8oMSwgZSk7XG4gICAgfTtcbiAgXG4gIFxuICB2YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPSAwO1xuICB2YXIga2VlcFJ1bnRpbWVBbGl2ZSA9ICgpID0+IG5vRXhpdFJ1bnRpbWUgfHwgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPiAwO1xuICB2YXIgX3Byb2NfZXhpdCA9IChjb2RlKSA9PiB7XG4gICAgICBFWElUU1RBVFVTID0gY29kZTtcbiAgICAgIGlmICgha2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XG4gICAgICAgIE1vZHVsZVsnb25FeGl0J10/Lihjb2RlKTtcbiAgICAgICAgQUJPUlQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xuICAgIH07XG4gIFxuICAvKiogQHN1cHByZXNzIHtkdXBsaWNhdGUgfSAqL1xuICAvKiogQHBhcmFtIHtib29sZWFufG51bWJlcj19IGltcGxpY2l0ICovXG4gIHZhciBleGl0SlMgPSAoc3RhdHVzLCBpbXBsaWNpdCkgPT4ge1xuICAgICAgRVhJVFNUQVRVUyA9IHN0YXR1cztcbiAgXG4gICAgICBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTtcbiAgXG4gICAgICAvLyBpZiBleGl0KCkgd2FzIGNhbGxlZCBleHBsaWNpdGx5LCB3YXJuIHRoZSB1c2VyIGlmIHRoZSBydW50aW1lIGlzbid0IGFjdHVhbGx5IGJlaW5nIHNodXQgZG93blxuICAgICAgaWYgKGtlZXBSdW50aW1lQWxpdmUoKSAmJiAhaW1wbGljaXQpIHtcbiAgICAgICAgdmFyIG1zZyA9IGBwcm9ncmFtIGV4aXRlZCAod2l0aCBzdGF0dXM6ICR7c3RhdHVzfSksIGJ1dCBrZWVwUnVudGltZUFsaXZlKCkgaXMgc2V0IChjb3VudGVyPSR7cnVudGltZUtlZXBhbGl2ZUNvdW50ZXJ9KSBkdWUgdG8gYW4gYXN5bmMgb3BlcmF0aW9uLCBzbyBoYWx0aW5nIGV4ZWN1dGlvbiBidXQgbm90IGV4aXRpbmcgdGhlIHJ1bnRpbWUgb3IgcHJldmVudGluZyBmdXJ0aGVyIGFzeW5jIGV4ZWN1dGlvbiAoeW91IGNhbiB1c2UgZW1zY3JpcHRlbl9mb3JjZV9leGl0LCBpZiB5b3Ugd2FudCB0byBmb3JjZSBhIHRydWUgc2h1dGRvd24pYDtcbiAgICAgICAgcmVhZHlQcm9taXNlUmVqZWN0KG1zZyk7XG4gICAgICAgIGVycihtc2cpO1xuICAgICAgfVxuICBcbiAgICAgIF9wcm9jX2V4aXQoc3RhdHVzKTtcbiAgICB9O1xuICB2YXIgX2V4aXQgPSBleGl0SlM7XG4gIFxuICBcbiAgdmFyIG1heWJlRXhpdCA9ICgpID0+IHtcbiAgICAgIGlmICgha2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX2V4aXQoRVhJVFNUQVRVUyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB2YXIgY2FsbFVzZXJDYWxsYmFjayA9IChmdW5jKSA9PiB7XG4gICAgICBpZiAoQUJPUlQpIHtcbiAgICAgICAgZXJyKCd1c2VyIGNhbGxiYWNrIHRyaWdnZXJlZCBhZnRlciBydW50aW1lIGV4aXRlZCBvciBhcHBsaWNhdGlvbiBhYm9ydGVkLiAgSWdub3JpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgbWF5YmVFeGl0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUV4Y2VwdGlvbihlKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgdmFyIHNpZ1RvV2FzbVR5cGVzID0gKHNpZykgPT4ge1xuICAgICAgYXNzZXJ0KCFzaWcuaW5jbHVkZXMoJ2onKSwgJ2k2NCBub3QgcGVybWl0dGVkIGluIGZ1bmN0aW9uIHNpZ25hdHVyZXMgd2hlbiBXQVNNX0JJR0lOVCBpcyBkaXNhYmxlZCcpO1xuICAgICAgdmFyIHR5cGVOYW1lcyA9IHtcbiAgICAgICAgJ2knOiAnaTMyJyxcbiAgICAgICAgJ2onOiAnaTY0JyxcbiAgICAgICAgJ2YnOiAnZjMyJyxcbiAgICAgICAgJ2QnOiAnZjY0JyxcbiAgICAgICAgJ2UnOiAnZXh0ZXJucmVmJyxcbiAgICAgICAgJ3AnOiAnaTMyJyxcbiAgICAgIH07XG4gICAgICB2YXIgdHlwZSA9IHtcbiAgICAgICAgcGFyYW1ldGVyczogW10sXG4gICAgICAgIHJlc3VsdHM6IHNpZ1swXSA9PSAndicgPyBbXSA6IFt0eXBlTmFtZXNbc2lnWzBdXV1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNpZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBhc3NlcnQoc2lnW2ldIGluIHR5cGVOYW1lcywgJ2ludmFsaWQgc2lnbmF0dXJlIGNoYXI6ICcgKyBzaWdbaV0pO1xuICAgICAgICB0eXBlLnBhcmFtZXRlcnMucHVzaCh0eXBlTmFtZXNbc2lnW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9O1xuICBcbiAgdmFyIHJ1bnRpbWVLZWVwYWxpdmVQdXNoID0gKCkgPT4ge1xuICAgICAgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgKz0gMTtcbiAgICB9O1xuICBcbiAgdmFyIHJ1bnRpbWVLZWVwYWxpdmVQb3AgPSAoKSA9PiB7XG4gICAgICBhc3NlcnQocnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPiAwKTtcbiAgICAgIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyIC09IDE7XG4gICAgfTtcbiAgXG4gIFxuICB2YXIgQXN5bmNpZnkgPSB7XG4gIGluc3RydW1lbnRXYXNtSW1wb3J0cyhpbXBvcnRzKSB7XG4gICAgICAgIHZhciBpbXBvcnRQYXR0ZXJuID0gL14ocXRzX2hvc3RfY2FsbF9mdW5jdGlvbnxxdHNfaG9zdF9sb2FkX21vZHVsZV9zb3VyY2V8cXRzX2hvc3Rfbm9ybWFsaXplX21vZHVsZXxpbnZva2VfLip8X19hc3luY2pzX18uKikkLztcbiAgXG4gICAgICAgIGZvciAobGV0IFt4LCBvcmlnaW5hbF0gb2YgT2JqZWN0LmVudHJpZXMoaW1wb3J0cykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBpc0FzeW5jaWZ5SW1wb3J0ID0gb3JpZ2luYWwuaXNBc3luYyB8fCBpbXBvcnRQYXR0ZXJuLnRlc3QoeCk7XG4gICAgICAgICAgICBpbXBvcnRzW3hdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsQXN5bmNpZnlTdGF0ZSA9IEFzeW5jaWZ5LnN0YXRlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFzeW5jaWZ5LWRlY2xhcmVkIGltcG9ydHMgYXJlIGFsbG93ZWQgdG8gY2hhbmdlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBzdGF0ZSBmcm9tIG5vcm1hbCB0byBkaXNhYmxlZCBpcyBhbGxvd2VkIChpbiBhbnlcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbikgYXMgdGhhdCBpcyB3aGF0IHNodXRkb3duIGRvZXMgKGFuZCB3ZSBkb24ndCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgLy8gZXhwbGljaXQgbGlzdCBvZiBzaHV0ZG93biBpbXBvcnRzKS5cbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFRvRGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQXN5bmNpZnlTdGF0ZSA9PT0gQXN5bmNpZnkuU3RhdGUuTm9ybWFsICYmXG4gICAgICAgICAgICAgICAgICAgICAgQXN5bmNpZnkuc3RhdGUgICAgICAgID09PSBBc3luY2lmeS5TdGF0ZS5EaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAvLyBpbnZva2VfKiBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgdG8gY2hhbmdlIHRoZSBzdGF0ZSBpZiB3ZSBkb1xuICAgICAgICAgICAgICAgIC8vIG5vdCBpZ25vcmUgaW5kaXJlY3QgY2FsbHMuXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRJbnZva2UgPSB4LnN0YXJ0c1dpdGgoJ2ludm9rZV8nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQXN5bmNpZnkuc3RhdGUgIT09IG9yaWdpbmFsQXN5bmNpZnlTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNBc3luY2lmeUltcG9ydCAmJlxuICAgICAgICAgICAgICAgICAgICAhY2hhbmdlZFRvRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlnbm9yZWRJbnZva2UpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW1wb3J0ICR7eH0gd2FzIG5vdCBpbiBBU1lOQ0lGWV9JTVBPUlRTLCBidXQgY2hhbmdlZCB0aGUgc3RhdGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICBpbnN0cnVtZW50V2FzbUV4cG9ydHMoZXhwb3J0cykge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIGZvciAobGV0IFt4LCBvcmlnaW5hbF0gb2YgT2JqZWN0LmVudHJpZXMoZXhwb3J0cykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldFt4XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIEFzeW5jaWZ5LmV4cG9ydENhbGxTdGFjay5wdXNoKHgpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoIUFCT1JUKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeSA9IEFzeW5jaWZ5LmV4cG9ydENhbGxTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGFzc2VydCh5ID09PSB4KTtcbiAgICAgICAgICAgICAgICAgIEFzeW5jaWZ5Lm1heWJlU3RvcFVud2luZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W3hdID0gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICBTdGF0ZTp7XG4gIE5vcm1hbDowLFxuICBVbndpbmRpbmc6MSxcbiAgUmV3aW5kaW5nOjIsXG4gIERpc2FibGVkOjMsXG4gIH0sXG4gIHN0YXRlOjAsXG4gIFN0YWNrU2l6ZTo4MTkyMCxcbiAgY3VyckRhdGE6bnVsbCxcbiAgaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZTowLFxuICBleHBvcnRDYWxsU3RhY2s6W10sXG4gIGNhbGxTdGFja05hbWVUb0lkOntcbiAgfSxcbiAgY2FsbFN0YWNrSWRUb05hbWU6e1xuICB9LFxuICBjYWxsU3RhY2tJZDowLFxuICBhc3luY1Byb21pc2VIYW5kbGVyczpudWxsLFxuICBzbGVlcENhbGxiYWNrczpbXSxcbiAgZ2V0Q2FsbFN0YWNrSWQoZnVuY05hbWUpIHtcbiAgICAgICAgdmFyIGlkID0gQXN5bmNpZnkuY2FsbFN0YWNrTmFtZVRvSWRbZnVuY05hbWVdO1xuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlkID0gQXN5bmNpZnkuY2FsbFN0YWNrSWQrKztcbiAgICAgICAgICBBc3luY2lmeS5jYWxsU3RhY2tOYW1lVG9JZFtmdW5jTmFtZV0gPSBpZDtcbiAgICAgICAgICBBc3luY2lmeS5jYWxsU3RhY2tJZFRvTmFtZVtpZF0gPSBmdW5jTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9LFxuICBtYXliZVN0b3BVbndpbmQoKSB7XG4gICAgICAgIGlmIChBc3luY2lmeS5jdXJyRGF0YSAmJlxuICAgICAgICAgICAgQXN5bmNpZnkuc3RhdGUgPT09IEFzeW5jaWZ5LlN0YXRlLlVud2luZGluZyAmJlxuICAgICAgICAgICAgQXN5bmNpZnkuZXhwb3J0Q2FsbFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgZmluaXNoZWQgdW53aW5kaW5nLlxuICAgICAgICAgIC8vIEJlIHN1cmUgdG8gc2V0IHRoZSBzdGF0ZSBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgZnVuY3Rpb25zIHRvIGF2b2lkXG4gICAgICAgICAgLy8gcG9zc2libGUgaW5maW5pdGUgcmVjdXJzaW9uIGhlcmUgKEZvciBleGFtcGxlIGluIGRlYnVnIHB0aHJlYWQgYnVpbGRzXG4gICAgICAgICAgLy8gdGhlIGRiZygpIGZ1bmN0aW9uIGl0c2VsZiBjYW4gY2FsbCBiYWNrIGludG8gV2ViQXNzZW1ibHkgdG8gZ2V0IHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcHRocmVhZF9zZWxmKCkgcG9pbnRlcikuXG4gICAgICAgICAgQXN5bmNpZnkuc3RhdGUgPSBBc3luY2lmeS5TdGF0ZS5Ob3JtYWw7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gS2VlcCB0aGUgcnVudGltZSBhbGl2ZSBzbyB0aGF0IGEgcmUtd2luZCBjYW4gYmUgZG9uZSBsYXRlci5cbiAgICAgICAgICBydW5BbmRBYm9ydElmRXJyb3IoX2FzeW5jaWZ5X3N0b3BfdW53aW5kKTtcbiAgICAgICAgICBpZiAodHlwZW9mIEZpYmVycyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgRmliZXJzLnRyYW1wb2xpbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gIHdoZW5Eb25lKCkge1xuICAgICAgICBhc3NlcnQoQXN5bmNpZnkuY3VyckRhdGEsICdUcmllZCB0byB3YWl0IGZvciBhbiBhc3luYyBvcGVyYXRpb24gd2hlbiBub25lIGlzIGluIHByb2dyZXNzLicpO1xuICAgICAgICBhc3NlcnQoIUFzeW5jaWZ5LmFzeW5jUHJvbWlzZUhhbmRsZXJzLCAnQ2Fubm90IGhhdmUgbXVsdGlwbGUgYXN5bmMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZScpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIEFzeW5jaWZ5LmFzeW5jUHJvbWlzZUhhbmRsZXJzID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICBhbGxvY2F0ZURhdGEoKSB7XG4gICAgICAgIC8vIEFuIGFzeW5jaWZ5IGRhdGEgc3RydWN0dXJlIGhhcyB0aHJlZSBmaWVsZHM6XG4gICAgICAgIC8vICAwICBjdXJyZW50IHN0YWNrIHBvc1xuICAgICAgICAvLyAgNCAgbWF4IHN0YWNrIHBvc1xuICAgICAgICAvLyAgOCAgaWQgb2YgZnVuY3Rpb24gYXQgYm90dG9tIG9mIHRoZSBjYWxsIHN0YWNrIChjYWxsU3RhY2tJZFRvTmFtZVtpZF0gPT0gbmFtZSBvZiBqcyBmdW5jdGlvbilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIEFzeW5jaWZ5IEFCSSBvbmx5IGludGVycHJldHMgdGhlIGZpcnN0IHR3byBmaWVsZHMsIHRoZSByZXN0IGlzIGZvciB0aGUgcnVudGltZS5cbiAgICAgICAgLy8gV2UgYWxzbyBlbWJlZCBhIHN0YWNrIGluIHRoZSBzYW1lIG1lbW9yeSByZWdpb24gaGVyZSwgcmlnaHQgbmV4dCB0byB0aGUgc3RydWN0dXJlLlxuICAgICAgICAvLyBUaGlzIHN0cnVjdCBpcyBhbHNvIGRlZmluZWQgYXMgYXN5bmNpZnlfZGF0YV90IGluIGVtc2NyaXB0ZW4vZmliZXIuaFxuICAgICAgICB2YXIgcHRyID0gX21hbGxvYygxMiArIEFzeW5jaWZ5LlN0YWNrU2l6ZSk7XG4gICAgICAgIEFzeW5jaWZ5LnNldERhdGFIZWFkZXIocHRyLCBwdHIgKyAxMiwgQXN5bmNpZnkuU3RhY2tTaXplKTtcbiAgICAgICAgQXN5bmNpZnkuc2V0RGF0YVJld2luZEZ1bmMocHRyKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgIH0sXG4gIHNldERhdGFIZWFkZXIocHRyLCBzdGFjaywgc3RhY2tTaXplKSB7XG4gICAgICAgIEhFQVBVMzJbKChwdHIpPj4yKV0gPSBzdGFjaztcbiAgICAgICAgSEVBUFUzMlsoKChwdHIpKyg0KSk+PjIpXSA9IHN0YWNrICsgc3RhY2tTaXplO1xuICAgICAgfSxcbiAgc2V0RGF0YVJld2luZEZ1bmMocHRyKSB7XG4gICAgICAgIHZhciBib3R0b21PZkNhbGxTdGFjayA9IEFzeW5jaWZ5LmV4cG9ydENhbGxTdGFja1swXTtcbiAgICAgICAgdmFyIHJld2luZElkID0gQXN5bmNpZnkuZ2V0Q2FsbFN0YWNrSWQoYm90dG9tT2ZDYWxsU3RhY2spO1xuICAgICAgICBIRUFQMzJbKCgocHRyKSsoOCkpPj4yKV0gPSByZXdpbmRJZDtcbiAgICAgIH0sXG4gIGdldERhdGFSZXdpbmRGdW5jTmFtZShwdHIpIHtcbiAgICAgICAgdmFyIGlkID0gSEVBUDMyWygoKHB0cikrKDgpKT4+MildO1xuICAgICAgICB2YXIgbmFtZSA9IEFzeW5jaWZ5LmNhbGxTdGFja0lkVG9OYW1lW2lkXTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICBnZXREYXRhUmV3aW5kRnVuYyhuYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gd2FzbUV4cG9ydHNbbmFtZV07XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSxcbiAgZG9SZXdpbmQocHRyKSB7XG4gICAgICAgIHZhciBuYW1lID0gQXN5bmNpZnkuZ2V0RGF0YVJld2luZEZ1bmNOYW1lKHB0cik7XG4gICAgICAgIHZhciBmdW5jID0gQXN5bmNpZnkuZ2V0RGF0YVJld2luZEZ1bmMobmFtZSk7XG4gICAgICAgIC8vIE9uY2Ugd2UgaGF2ZSByZXdvdW5kIGFuZCB0aGUgc3RhY2sgd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gYXJ0aWZpY2lhbGx5XG4gICAgICAgIC8vIGtlZXAgdGhlIHJ1bnRpbWUgYWxpdmUuXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZnVuYygpO1xuICAgICAgfSxcbiAgaGFuZGxlU2xlZXAoc3RhcnRBc3luYykge1xuICAgICAgICBhc3NlcnQoQXN5bmNpZnkuc3RhdGUgIT09IEFzeW5jaWZ5LlN0YXRlLkRpc2FibGVkLCAnQXN5bmNpZnkgY2Fubm90IGJlIGRvbmUgZHVyaW5nIG9yIGFmdGVyIHRoZSBydW50aW1lIGV4aXRzJyk7XG4gICAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xuICAgICAgICBpZiAoQXN5bmNpZnkuc3RhdGUgPT09IEFzeW5jaWZ5LlN0YXRlLk5vcm1hbCkge1xuICAgICAgICAgIC8vIFByZXBhcmUgdG8gc2xlZXAuIENhbGwgc3RhcnRBc3luYywgYW5kIHNlZSB3aGF0IGhhcHBlbnM6XG4gICAgICAgICAgLy8gaWYgdGhlIGNvZGUgZGVjaWRlZCB0byBjYWxsIG91ciBjYWxsYmFjayBzeW5jaHJvbm91c2x5LFxuICAgICAgICAgIC8vIHRoZW4gbm8gYXN5bmMgb3BlcmF0aW9uIHdhcyBpbiBmYWN0IGJlZ3VuLCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgIHZhciByZWFjaGVkQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVhY2hlZEFmdGVyQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICBzdGFydEFzeW5jKChoYW5kbGVTbGVlcFJldHVyblZhbHVlID0gMCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0KCFoYW5kbGVTbGVlcFJldHVyblZhbHVlIHx8IHR5cGVvZiBoYW5kbGVTbGVlcFJldHVyblZhbHVlID09ICdudW1iZXInIHx8IHR5cGVvZiBoYW5kbGVTbGVlcFJldHVyblZhbHVlID09ICdib29sZWFuJyk7IC8vIG9sZCBlbXRlcnByZXRpZnkgQVBJIHN1cHBvcnRlZCBvdGhlciBzdHVmZlxuICAgICAgICAgICAgaWYgKEFCT1JUKSByZXR1cm47XG4gICAgICAgICAgICBBc3luY2lmeS5oYW5kbGVTbGVlcFJldHVyblZhbHVlID0gaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHJlYWNoZWRDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXJlYWNoZWRBZnRlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBoYXBwZW5pbmcgc3luY2hyb25vdXNseSwgc28gbm8gbmVlZCBmb3IgYXN5bmMuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgYXN5bmMgb3BlcmF0aW9uIGRpZCBub3QgaGFwcGVuIHN5bmNocm9ub3VzbHksIHNvIHdlIGRpZFxuICAgICAgICAgICAgLy8gdW53aW5kLiBJbiB0aGF0IGNhc2UgdGhlcmUgY2FuIGJlIG5vIGNvbXBpbGVkIGNvZGUgb24gdGhlIHN0YWNrLFxuICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYnJlYWsgbGF0ZXIgb3BlcmF0aW9ucyAod2UgY2FuIHJld2luZCBvayBub3csIGJ1dCBpZlxuICAgICAgICAgICAgLy8gd2UgdW53aW5kIGFnYWluLCB3ZSB3b3VsZCB1bndpbmQgdGhyb3VnaCB0aGUgZXh0cmEgY29tcGlsZWQgY29kZVxuICAgICAgICAgICAgLy8gdG9vKS5cbiAgICAgICAgICAgIGFzc2VydCghQXN5bmNpZnkuZXhwb3J0Q2FsbFN0YWNrLmxlbmd0aCwgJ1dha2luZyB1cCAoc3RhcnRpbmcgdG8gcmV3aW5kKSBtdXN0IGJlIGRvbmUgZnJvbSBKUywgd2l0aG91dCBjb21waWxlZCBjb2RlIG9uIHRoZSBzdGFjay4nKTtcbiAgICAgICAgICAgIEFzeW5jaWZ5LnN0YXRlID0gQXN5bmNpZnkuU3RhdGUuUmV3aW5kaW5nO1xuICAgICAgICAgICAgcnVuQW5kQWJvcnRJZkVycm9yKCgpID0+IF9hc3luY2lmeV9zdGFydF9yZXdpbmQoQXN5bmNpZnkuY3VyckRhdGEpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQnJvd3NlciAhPSAndW5kZWZpbmVkJyAmJiBCcm93c2VyLm1haW5Mb29wLmZ1bmMpIHtcbiAgICAgICAgICAgICAgQnJvd3Nlci5tYWluTG9vcC5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhc3luY1dhc21SZXR1cm5WYWx1ZSwgaXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXN5bmNXYXNtUmV0dXJuVmFsdWUgPSBBc3luY2lmeS5kb1Jld2luZChBc3luY2lmeS5jdXJyRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgYXN5bmNXYXNtUmV0dXJuVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgcmV0dXJuIHZhbHVlIHdhcyBoYW5kbGVkIGJ5IGFueSBwcm9taXNlIGhhbmRsZXJzLlxuICAgICAgICAgICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghQXN5bmNpZnkuY3VyckRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gQWxsIGFzeW5jaHJvbm91cyBleGVjdXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAvLyBgYXN5bmNXYXNtUmV0dXJuVmFsdWVgIG5vdyBjb250YWlucyB0aGUgZmluYWxcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIG9mIHRoZSBleHBvcnRlZCBhc3luYyBXQVNNIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBOb3RlOiBgYXN5bmNXYXNtUmV0dXJuVmFsdWVgIGlzIGRpc3RpbmN0IGZyb21cbiAgICAgICAgICAgICAgLy8gYEFzeW5jaWZ5LmhhbmRsZVNsZWVwUmV0dXJuVmFsdWVgLlxuICAgICAgICAgICAgICAvLyBgQXN5bmNpZnkuaGFuZGxlU2xlZXBSZXR1cm5WYWx1ZWAgY29udGFpbnMgdGhlIHJldHVyblxuICAgICAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgbGFzdCBDIGZ1bmN0aW9uIHRvIGhhdmUgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgLy8gYEFzeW5jaWZ5LmhhbmRsZVNsZWVwKClgLCB3aGVyZSBhcyBgYXN5bmNXYXNtUmV0dXJuVmFsdWVgXG4gICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4cG9ydGVkIFdBU00gZnVuY3Rpb25cbiAgICAgICAgICAgICAgLy8gdGhhdCBtYXkgaGF2ZSBjYWxsZWQgQyBmdW5jdGlvbnMgdGhhdFxuICAgICAgICAgICAgICAvLyBjYWxsIGBBc3luY2lmeS5oYW5kbGVTbGVlcCgpYC5cbiAgICAgICAgICAgICAgdmFyIGFzeW5jUHJvbWlzZUhhbmRsZXJzID0gQXN5bmNpZnkuYXN5bmNQcm9taXNlSGFuZGxlcnM7XG4gICAgICAgICAgICAgIGlmIChhc3luY1Byb21pc2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIEFzeW5jaWZ5LmFzeW5jUHJvbWlzZUhhbmRsZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoaXNFcnJvciA/IGFzeW5jUHJvbWlzZUhhbmRsZXJzLnJlamVjdCA6IGFzeW5jUHJvbWlzZUhhbmRsZXJzLnJlc29sdmUpKGFzeW5jV2FzbVJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3IgJiYgIWhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIGFuZCBpdCB3YXMgbm90IGhhbmRsZWQgYnkgbm93LCB3ZSBoYXZlIG5vIGNob2ljZSBidXQgdG9cbiAgICAgICAgICAgICAgLy8gcmV0aHJvdyB0aGF0IGVycm9yIGludG8gdGhlIGdsb2JhbCBzY29wZSB3aGVyZSBpdCBjYW4gYmUgY2F1Z2h0IG9ubHkgYnlcbiAgICAgICAgICAgICAgLy8gYG9uZXJyb3JgIG9yIGBvbnVuaGFuZGxlZHByb21pc2VyZWplY3Rpb25gLlxuICAgICAgICAgICAgICB0aHJvdyBhc3luY1dhc21SZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWFjaGVkQWZ0ZXJDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaWYgKCFyZWFjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIEEgdHJ1ZSBhc3luYyBvcGVyYXRpb24gd2FzIGJlZ3VuOyBzdGFydCBhIHNsZWVwLlxuICAgICAgICAgICAgQXN5bmNpZnkuc3RhdGUgPSBBc3luY2lmeS5TdGF0ZS5VbndpbmRpbmc7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXVzZSwgZG9uJ3QgYWxsb2MvZnJlZSBldmVyeSBzbGVlcFxuICAgICAgICAgICAgQXN5bmNpZnkuY3VyckRhdGEgPSBBc3luY2lmeS5hbGxvY2F0ZURhdGEoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQnJvd3NlciAhPSAndW5kZWZpbmVkJyAmJiBCcm93c2VyLm1haW5Mb29wLmZ1bmMpIHtcbiAgICAgICAgICAgICAgQnJvd3Nlci5tYWluTG9vcC5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuQW5kQWJvcnRJZkVycm9yKCgpID0+IF9hc3luY2lmeV9zdGFydF91bndpbmQoQXN5bmNpZnkuY3VyckRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXN5bmNpZnkuc3RhdGUgPT09IEFzeW5jaWZ5LlN0YXRlLlJld2luZGluZykge1xuICAgICAgICAgIC8vIFN0b3AgYSByZXN1bWUuXG4gICAgICAgICAgQXN5bmNpZnkuc3RhdGUgPSBBc3luY2lmeS5TdGF0ZS5Ob3JtYWw7XG4gICAgICAgICAgcnVuQW5kQWJvcnRJZkVycm9yKF9hc3luY2lmeV9zdG9wX3Jld2luZCk7XG4gICAgICAgICAgX2ZyZWUoQXN5bmNpZnkuY3VyckRhdGEpO1xuICAgICAgICAgIEFzeW5jaWZ5LmN1cnJEYXRhID0gbnVsbDtcbiAgICAgICAgICAvLyBDYWxsIGFsbCBzbGVlcCBjYWxsYmFja3Mgbm93IHRoYXQgdGhlIHNsZWVwLXJlc3VtZSBpcyBhbGwgZG9uZS5cbiAgICAgICAgICBBc3luY2lmeS5zbGVlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxVc2VyQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFib3J0KGBpbnZhbGlkIHN0YXRlOiAke0FzeW5jaWZ5LnN0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBc3luY2lmeS5oYW5kbGVTbGVlcFJldHVyblZhbHVlO1xuICAgICAgfSxcbiAgaGFuZGxlQXN5bmMoc3RhcnRBc3luYykge1xuICAgICAgICByZXR1cm4gQXN5bmNpZnkuaGFuZGxlU2xlZXAoKHdha2VVcCkgPT4ge1xuICAgICAgICAgIC8vIFRPRE86IGFkZCBlcnJvciBoYW5kbGluZyBhcyBhIHNlY29uZCBwYXJhbSB3aGVuIGhhbmRsZVNsZWVwIGltcGxlbWVudHMgaXQuXG4gICAgICAgICAgc3RhcnRBc3luYygpLnRoZW4od2FrZVVwKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICB9O1xuXG4gIHZhciBnZXRDRnVuYyA9IChpZGVudCkgPT4ge1xuICAgICAgdmFyIGZ1bmMgPSBNb2R1bGVbJ18nICsgaWRlbnRdOyAvLyBjbG9zdXJlIGV4cG9ydGVkIGZ1bmN0aW9uXG4gICAgICBhc3NlcnQoZnVuYywgJ0Nhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gJyArIGlkZW50ICsgJywgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkJyk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuICBcbiAgXG4gIHZhciB3cml0ZUFycmF5VG9NZW1vcnkgPSAoYXJyYXksIGJ1ZmZlcikgPT4ge1xuICAgICAgYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCAnd3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KScpXG4gICAgICBIRUFQOC5zZXQoYXJyYXksIGJ1ZmZlcik7XG4gICAgfTtcbiAgXG4gIFxuICBcbiAgdmFyIHN0YWNrQWxsb2MgPSAoc3opID0+IF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyhzeik7XG4gIHZhciBzdHJpbmdUb1VURjhPblN0YWNrID0gKHN0cikgPT4ge1xuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gICAgICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcbiAgICAgIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgc2l6ZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGw9fSByZXR1cm5UeXBlXG4gICAgICogQHBhcmFtIHtBcnJheT19IGFyZ1R5cGVzXG4gICAgICogQHBhcmFtIHtBcmd1bWVudHN8QXJyYXk9fSBhcmdzXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRzXG4gICAgICovXG4gIHZhciBjY2FsbCA9IChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpID0+IHtcbiAgICAgIC8vIEZvciBmYXN0IGxvb2t1cCBvZiBjb252ZXJzaW9uIGZ1bmN0aW9uc1xuICAgICAgdmFyIHRvQyA9IHtcbiAgICAgICAgJ3N0cmluZyc6IChzdHIpID0+IHtcbiAgICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgICBpZiAoc3RyICE9PSBudWxsICYmIHN0ciAhPT0gdW5kZWZpbmVkICYmIHN0ciAhPT0gMCkgeyAvLyBudWxsIHN0cmluZ1xuICAgICAgICAgICAgLy8gYXQgbW9zdCA0IGJ5dGVzIHBlciBVVEYtOCBjb2RlIHBvaW50LCArMSBmb3IgdGhlIHRyYWlsaW5nICdcXDAnXG4gICAgICAgICAgICByZXQgPSBzdHJpbmdUb1VURjhPblN0YWNrKHN0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdhcnJheSc6IChhcnIpID0+IHtcbiAgICAgICAgICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhhcnIubGVuZ3RoKTtcbiAgICAgICAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gIFxuICAgICAgZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCkge1xuICAgICAgICBpZiAocmV0dXJuVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gVVRGOFRvU3RyaW5nKHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHVyblR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuIEJvb2xlYW4ocmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgZnVuYyA9IGdldENGdW5jKGlkZW50KTtcbiAgICAgIHZhciBjQXJncyA9IFtdO1xuICAgICAgdmFyIHN0YWNrID0gMDtcbiAgICAgIGFzc2VydChyZXR1cm5UeXBlICE9PSAnYXJyYXknLCAnUmV0dXJuIHR5cGUgc2hvdWxkIG5vdCBiZSBcImFycmF5XCIuJyk7XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29udmVydGVyID0gdG9DW2FyZ1R5cGVzW2ldXTtcbiAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgICAgICAgICBjQXJnc1tpXSA9IGNvbnZlcnRlcihhcmdzW2ldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGF0YSBmb3IgYSBwcmV2aW91cyBhc3luYyBvcGVyYXRpb24gdGhhdCB3YXMgaW4gZmxpZ2h0IGJlZm9yZSB1cy5cbiAgICAgIHZhciBwcmV2aW91c0FzeW5jID0gQXN5bmNpZnkuY3VyckRhdGE7XG4gICAgICB2YXIgcmV0ID0gZnVuYyguLi5jQXJncyk7XG4gICAgICBmdW5jdGlvbiBvbkRvbmUocmV0KSB7XG4gICAgICAgIHJ1bnRpbWVLZWVwYWxpdmVQb3AoKTtcbiAgICAgICAgaWYgKHN0YWNrICE9PSAwKSBzdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgICAgICByZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCk7XG4gICAgICB9XG4gICAgdmFyIGFzeW5jTW9kZSA9IG9wdHM/LmFzeW5jO1xuICBcbiAgICAgIC8vIEtlZXAgdGhlIHJ1bnRpbWUgYWxpdmUgdGhyb3VnaCBhbGwgY2FsbHMuIE5vdGUgdGhhdCB0aGlzIGNhbGwgbWlnaHQgbm90IGJlXG4gICAgICAvLyBhc3luYywgYnV0IGZvciBzaW1wbGljaXR5IHdlIHB1c2ggYW5kIHBvcCBpbiBhbGwgY2FsbHMuXG4gICAgICBydW50aW1lS2VlcGFsaXZlUHVzaCgpO1xuICAgICAgaWYgKEFzeW5jaWZ5LmN1cnJEYXRhICE9IHByZXZpb3VzQXN5bmMpIHtcbiAgICAgICAgLy8gQSBjaGFuZ2UgaW4gYXN5bmMgb3BlcmF0aW9uIGhhcHBlbmVkLiBJZiB0aGVyZSB3YXMgYWxyZWFkeSBhbiBhc3luY1xuICAgICAgICAvLyBvcGVyYXRpb24gaW4gZmxpZ2h0IGJlZm9yZSB1cywgdGhhdCBpcyBhbiBlcnJvcjogd2Ugc2hvdWxkIG5vdCBzdGFydFxuICAgICAgICAvLyBhbm90aGVyIGFzeW5jIG9wZXJhdGlvbiB3aGlsZSBvbmUgaXMgYWN0aXZlLCBhbmQgd2Ugc2hvdWxkIG5vdCBzdG9wIG9uZVxuICAgICAgICAvLyBlaXRoZXIuIFRoZSBvbmx5IHZhbGlkIGNvbWJpbmF0aW9uIGlzIHRvIGhhdmUgbm8gY2hhbmdlIGluIHRoZSBhc3luY1xuICAgICAgICAvLyBkYXRhIChzbyB3ZSBlaXRoZXIgaGFkIG9uZSBpbiBmbGlnaHQgYW5kIGxlZnQgaXQgYWxvbmUsIG9yIHdlIGRpZG4ndCBoYXZlXG4gICAgICAgIC8vIG9uZSksIG9yIHRvIGhhdmUgbm90aGluZyBpbiBmbGlnaHQgYW5kIHRvIHN0YXJ0IG9uZS5cbiAgICAgICAgYXNzZXJ0KCEocHJldmlvdXNBc3luYyAmJiBBc3luY2lmeS5jdXJyRGF0YSksICdXZSBjYW5ub3Qgc3RhcnQgYW4gYXN5bmMgb3BlcmF0aW9uIHdoZW4gb25lIGlzIGFscmVhZHkgZmxpZ2h0Jyk7XG4gICAgICAgIGFzc2VydCghKHByZXZpb3VzQXN5bmMgJiYgIUFzeW5jaWZ5LmN1cnJEYXRhKSwgJ1dlIGNhbm5vdCBzdG9wIGFuIGFzeW5jIG9wZXJhdGlvbiBpbiBmbGlnaHQnKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBhc3luYyBvcGVyYXRpb24uIFRoZSB3YXNtIGlzIHBhdXNlZCBhbmQgaGFzIHVud291bmQgaXRzIHN0YWNrLlxuICAgICAgICAvLyBXZSBuZWVkIHRvIHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9uY2UgdGhlIHN0YWNrIGlzIHJld291bmQgYW5kIGV4ZWN1dGlvbiBmaW5pc2hlcy5cbiAgICAgICAgYXNzZXJ0KGFzeW5jTW9kZSwgJ1RoZSBjYWxsIHRvICcgKyBpZGVudCArICcgaXMgcnVubmluZyBhc3luY2hyb25vdXNseS4gSWYgdGhpcyB3YXMgaW50ZW5kZWQsIGFkZCB0aGUgYXN5bmMgb3B0aW9uIHRvIHRoZSBjY2FsbC9jd3JhcCBjYWxsLicpO1xuICAgICAgICByZXR1cm4gQXN5bmNpZnkud2hlbkRvbmUoKS50aGVuKG9uRG9uZSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0ID0gb25Eb25lKHJldCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIGFzeW5jIGNjYWxsLCBlbnN1cmUgd2UgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgaWYgKGFzeW5jTW9kZSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICBcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHJldHVyblR5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gYXJnVHlwZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG9wdHNcbiAgICAgKi9cbiAgdmFyIGN3cmFwID0gKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgb3B0cykgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpO1xuICAgIH07XG5cblxuXG5mdW5jdGlvbiBjaGVja0luY29taW5nTW9kdWxlQVBJKCkge1xuICBpZ25vcmVkTW9kdWxlUHJvcCgnZmV0Y2hTZXR0aW5ncycpO1xufVxudmFyIHdhc21JbXBvcnRzID0ge1xuICAvKiogQGV4cG9ydCAqL1xuICBfX2Fzc2VydF9mYWlsOiBfX19hc3NlcnRfZmFpbCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgX2Fib3J0X2pzOiBfX2Fib3J0X2pzLFxuICAvKiogQGV4cG9ydCAqL1xuICBfZW1zY3JpcHRlbl9tZW1jcHlfanM6IF9fZW1zY3JpcHRlbl9tZW1jcHlfanMsXG4gIC8qKiBAZXhwb3J0ICovXG4gIF9sb2NhbHRpbWVfanM6IF9fbG9jYWx0aW1lX2pzLFxuICAvKiogQGV4cG9ydCAqL1xuICBfdHpzZXRfanM6IF9fdHpzZXRfanMsXG4gIC8qKiBAZXhwb3J0ICovXG4gIGVtc2NyaXB0ZW5fZGF0ZV9ub3c6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuICAvKiogQGV4cG9ydCAqL1xuICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgZmRfc2VlazogX2ZkX3NlZWssXG4gIC8qKiBAZXhwb3J0ICovXG4gIGZkX3dyaXRlOiBfZmRfd3JpdGUsXG4gIC8qKiBAZXhwb3J0ICovXG4gIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgcXRzX2hvc3RfY2FsbF9mdW5jdGlvbixcbiAgLyoqIEBleHBvcnQgKi9cbiAgcXRzX2hvc3RfaW50ZXJydXB0X2hhbmRsZXIsXG4gIC8qKiBAZXhwb3J0ICovXG4gIHF0c19ob3N0X2xvYWRfbW9kdWxlX3NvdXJjZSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgcXRzX2hvc3Rfbm9ybWFsaXplX21vZHVsZSxcbiAgLyoqIEBleHBvcnQgKi9cbiAgc2V0X2FzeW5jaWZ5X3N0YWNrX3NpemVcbn07XG52YXIgd2FzbUV4cG9ydHMgPSBjcmVhdGVXYXNtKCk7XG52YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gY3JlYXRlRXhwb3J0V3JhcHBlcignX193YXNtX2NhbGxfY3RvcnMnLCAwKTtcbnZhciBfbWFsbG9jID0gTW9kdWxlWydfbWFsbG9jJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdtYWxsb2MnLCAxKTtcbnZhciBfUVRTX1Rocm93ID0gTW9kdWxlWydfUVRTX1Rocm93J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfVGhyb3cnLCAyKTtcbnZhciBfUVRTX05ld0Vycm9yID0gTW9kdWxlWydfUVRTX05ld0Vycm9yJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3RXJyb3InLCAxKTtcbnZhciBfUVRTX1J1bnRpbWVTZXRNZW1vcnlMaW1pdCA9IE1vZHVsZVsnX1FUU19SdW50aW1lU2V0TWVtb3J5TGltaXQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lU2V0TWVtb3J5TGltaXQnLCAyKTtcbnZhciBfUVRTX1J1bnRpbWVDb21wdXRlTWVtb3J5VXNhZ2UgPSBNb2R1bGVbJ19RVFNfUnVudGltZUNvbXB1dGVNZW1vcnlVc2FnZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVDb21wdXRlTWVtb3J5VXNhZ2UnLCAyKTtcbnZhciBfUVRTX1J1bnRpbWVEdW1wTWVtb3J5VXNhZ2UgPSBNb2R1bGVbJ19RVFNfUnVudGltZUR1bXBNZW1vcnlVc2FnZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVEdW1wTWVtb3J5VXNhZ2UnLCAxKTtcbnZhciBfUVRTX1JlY292ZXJhYmxlTGVha0NoZWNrID0gTW9kdWxlWydfUVRTX1JlY292ZXJhYmxlTGVha0NoZWNrJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUmVjb3ZlcmFibGVMZWFrQ2hlY2snLCAwKTtcbnZhciBfUVRTX0J1aWxkSXNTYW5pdGl6ZUxlYWsgPSBNb2R1bGVbJ19RVFNfQnVpbGRJc1Nhbml0aXplTGVhayddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0J1aWxkSXNTYW5pdGl6ZUxlYWsnLCAwKTtcbnZhciBfUVRTX1J1bnRpbWVTZXRNYXhTdGFja1NpemUgPSBNb2R1bGVbJ19RVFNfUnVudGltZVNldE1heFN0YWNrU2l6ZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVTZXRNYXhTdGFja1NpemUnLCAyKTtcbnZhciBfUVRTX0dldFVuZGVmaW5lZCA9IE1vZHVsZVsnX1FUU19HZXRVbmRlZmluZWQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRVbmRlZmluZWQnLCAwKTtcbnZhciBfUVRTX0dldE51bGwgPSBNb2R1bGVbJ19RVFNfR2V0TnVsbCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldE51bGwnLCAwKTtcbnZhciBfUVRTX0dldEZhbHNlID0gTW9kdWxlWydfUVRTX0dldEZhbHNlJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0RmFsc2UnLCAwKTtcbnZhciBfUVRTX0dldFRydWUgPSBNb2R1bGVbJ19RVFNfR2V0VHJ1ZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldFRydWUnLCAwKTtcbnZhciBfUVRTX05ld1J1bnRpbWUgPSBNb2R1bGVbJ19RVFNfTmV3UnVudGltZSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld1J1bnRpbWUnLCAwKTtcbnZhciBfUVRTX0ZyZWVSdW50aW1lID0gTW9kdWxlWydfUVRTX0ZyZWVSdW50aW1lJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRnJlZVJ1bnRpbWUnLCAxKTtcbnZhciBfZnJlZSA9IE1vZHVsZVsnX2ZyZWUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2ZyZWUnLCAxKTtcbnZhciBfUVRTX05ld0NvbnRleHQgPSBNb2R1bGVbJ19RVFNfTmV3Q29udGV4dCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0NvbnRleHQnLCAyKTtcbnZhciBfUVRTX0ZyZWVDb250ZXh0ID0gTW9kdWxlWydfUVRTX0ZyZWVDb250ZXh0J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRnJlZUNvbnRleHQnLCAxKTtcbnZhciBfUVRTX0ZyZWVWYWx1ZVBvaW50ZXIgPSBNb2R1bGVbJ19RVFNfRnJlZVZhbHVlUG9pbnRlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0ZyZWVWYWx1ZVBvaW50ZXInLCAyKTtcbnZhciBfUVRTX0ZyZWVWYWx1ZVBvaW50ZXJSdW50aW1lID0gTW9kdWxlWydfUVRTX0ZyZWVWYWx1ZVBvaW50ZXJSdW50aW1lJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRnJlZVZhbHVlUG9pbnRlclJ1bnRpbWUnLCAyKTtcbnZhciBfUVRTX0ZyZWVWb2lkUG9pbnRlciA9IE1vZHVsZVsnX1FUU19GcmVlVm9pZFBvaW50ZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19GcmVlVm9pZFBvaW50ZXInLCAyKTtcbnZhciBfUVRTX0ZyZWVDU3RyaW5nID0gTW9kdWxlWydfUVRTX0ZyZWVDU3RyaW5nJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRnJlZUNTdHJpbmcnLCAyKTtcbnZhciBfUVRTX0R1cFZhbHVlUG9pbnRlciA9IE1vZHVsZVsnX1FUU19EdXBWYWx1ZVBvaW50ZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19EdXBWYWx1ZVBvaW50ZXInLCAyKTtcbnZhciBfUVRTX05ld09iamVjdCA9IE1vZHVsZVsnX1FUU19OZXdPYmplY3QnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdPYmplY3QnLCAxKTtcbnZhciBfUVRTX05ld09iamVjdFByb3RvID0gTW9kdWxlWydfUVRTX05ld09iamVjdFByb3RvJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3T2JqZWN0UHJvdG8nLCAyKTtcbnZhciBfUVRTX05ld0FycmF5ID0gTW9kdWxlWydfUVRTX05ld0FycmF5J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3QXJyYXknLCAxKTtcbnZhciBfUVRTX05ld0FycmF5QnVmZmVyID0gTW9kdWxlWydfUVRTX05ld0FycmF5QnVmZmVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3QXJyYXlCdWZmZXInLCAzKTtcbnZhciBfUVRTX05ld0Zsb2F0NjQgPSBNb2R1bGVbJ19RVFNfTmV3RmxvYXQ2NCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX05ld0Zsb2F0NjQnLCAyKTtcbnZhciBfUVRTX0dldEZsb2F0NjQgPSBNb2R1bGVbJ19RVFNfR2V0RmxvYXQ2NCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldEZsb2F0NjQnLCAyKTtcbnZhciBfUVRTX05ld1N0cmluZyA9IE1vZHVsZVsnX1FUU19OZXdTdHJpbmcnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdTdHJpbmcnLCAyKTtcbnZhciBfUVRTX0dldFN0cmluZyA9IE1vZHVsZVsnX1FUU19HZXRTdHJpbmcnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRTdHJpbmcnLCAyKTtcbnZhciBfUVRTX0dldEFycmF5QnVmZmVyID0gTW9kdWxlWydfUVRTX0dldEFycmF5QnVmZmVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0QXJyYXlCdWZmZXInLCAyKTtcbnZhciBfUVRTX0dldEFycmF5QnVmZmVyTGVuZ3RoID0gTW9kdWxlWydfUVRTX0dldEFycmF5QnVmZmVyTGVuZ3RoJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfR2V0QXJyYXlCdWZmZXJMZW5ndGgnLCAyKTtcbnZhciBfUVRTX05ld1N5bWJvbCA9IE1vZHVsZVsnX1FUU19OZXdTeW1ib2wnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19OZXdTeW1ib2wnLCAzKTtcbnZhciBfUVRTX0dldFN5bWJvbERlc2NyaXB0aW9uT3JLZXkgPSBNb2R1bGVbJ19RVFNfR2V0U3ltYm9sRGVzY3JpcHRpb25PcktleSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldFN5bWJvbERlc2NyaXB0aW9uT3JLZXknLCAyKTtcbnZhciBfUVRTX0lzR2xvYmFsU3ltYm9sID0gTW9kdWxlWydfUVRTX0lzR2xvYmFsU3ltYm9sJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfSXNHbG9iYWxTeW1ib2wnLCAyKTtcbnZhciBfUVRTX0lzSm9iUGVuZGluZyA9IE1vZHVsZVsnX1FUU19Jc0pvYlBlbmRpbmcnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19Jc0pvYlBlbmRpbmcnLCAxKTtcbnZhciBfUVRTX0V4ZWN1dGVQZW5kaW5nSm9iID0gTW9kdWxlWydfUVRTX0V4ZWN1dGVQZW5kaW5nSm9iJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfRXhlY3V0ZVBlbmRpbmdKb2InLCAzKTtcbnZhciBfUVRTX0dldFByb3AgPSBNb2R1bGVbJ19RVFNfR2V0UHJvcCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldFByb3AnLCAzKTtcbnZhciBfUVRTX0dldFByb3BOdW1iZXIgPSBNb2R1bGVbJ19RVFNfR2V0UHJvcE51bWJlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldFByb3BOdW1iZXInLCAzKTtcbnZhciBfUVRTX1NldFByb3AgPSBNb2R1bGVbJ19RVFNfU2V0UHJvcCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1NldFByb3AnLCA0KTtcbnZhciBfUVRTX0RlZmluZVByb3AgPSBNb2R1bGVbJ19RVFNfRGVmaW5lUHJvcCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0RlZmluZVByb3AnLCA5KTtcbnZhciBfUVRTX0dldE93blByb3BlcnR5TmFtZXMgPSBNb2R1bGVbJ19RVFNfR2V0T3duUHJvcGVydHlOYW1lcyddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0dldE93blByb3BlcnR5TmFtZXMnLCA1KTtcbnZhciBfUVRTX0NhbGwgPSBNb2R1bGVbJ19RVFNfQ2FsbCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0NhbGwnLCA1KTtcbnZhciBfUVRTX1Jlc29sdmVFeGNlcHRpb24gPSBNb2R1bGVbJ19RVFNfUmVzb2x2ZUV4Y2VwdGlvbiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1Jlc29sdmVFeGNlcHRpb24nLCAyKTtcbnZhciBfUVRTX0R1bXAgPSBNb2R1bGVbJ19RVFNfRHVtcCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0R1bXAnLCAyKTtcbnZhciBfUVRTX0V2YWwgPSBNb2R1bGVbJ19RVFNfRXZhbCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0V2YWwnLCA2KTtcbnZhciBfUVRTX0dldE1vZHVsZU5hbWVzcGFjZSA9IE1vZHVsZVsnX1FUU19HZXRNb2R1bGVOYW1lc3BhY2UnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRNb2R1bGVOYW1lc3BhY2UnLCAyKTtcbnZhciBfUVRTX1R5cGVvZiA9IE1vZHVsZVsnX1FUU19UeXBlb2YnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19UeXBlb2YnLCAyKTtcbnZhciBfUVRTX0dldExlbmd0aCA9IE1vZHVsZVsnX1FUU19HZXRMZW5ndGgnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRMZW5ndGgnLCAzKTtcbnZhciBfUVRTX0lzRXF1YWwgPSBNb2R1bGVbJ19RVFNfSXNFcXVhbCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX0lzRXF1YWwnLCA0KTtcbnZhciBfUVRTX0dldEdsb2JhbE9iamVjdCA9IE1vZHVsZVsnX1FUU19HZXRHbG9iYWxPYmplY3QnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXRHbG9iYWxPYmplY3QnLCAxKTtcbnZhciBfUVRTX05ld1Byb21pc2VDYXBhYmlsaXR5ID0gTW9kdWxlWydfUVRTX05ld1Byb21pc2VDYXBhYmlsaXR5J10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3UHJvbWlzZUNhcGFiaWxpdHknLCAyKTtcbnZhciBfUVRTX1Byb21pc2VTdGF0ZSA9IE1vZHVsZVsnX1FUU19Qcm9taXNlU3RhdGUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19Qcm9taXNlU3RhdGUnLCAyKTtcbnZhciBfUVRTX1Byb21pc2VSZXN1bHQgPSBNb2R1bGVbJ19RVFNfUHJvbWlzZVJlc3VsdCddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1Byb21pc2VSZXN1bHQnLCAyKTtcbnZhciBfUVRTX1Rlc3RTdHJpbmdBcmcgPSBNb2R1bGVbJ19RVFNfVGVzdFN0cmluZ0FyZyddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1Rlc3RTdHJpbmdBcmcnLCAxKTtcbnZhciBfUVRTX0dldERlYnVnTG9nRW5hYmxlZCA9IE1vZHVsZVsnX1FUU19HZXREZWJ1Z0xvZ0VuYWJsZWQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19HZXREZWJ1Z0xvZ0VuYWJsZWQnLCAxKTtcbnZhciBfUVRTX1NldERlYnVnTG9nRW5hYmxlZCA9IE1vZHVsZVsnX1FUU19TZXREZWJ1Z0xvZ0VuYWJsZWQnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19TZXREZWJ1Z0xvZ0VuYWJsZWQnLCAyKTtcbnZhciBfUVRTX0J1aWxkSXNEZWJ1ZyA9IE1vZHVsZVsnX1FUU19CdWlsZElzRGVidWcnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19CdWlsZElzRGVidWcnLCAwKTtcbnZhciBfUVRTX0J1aWxkSXNBc3luY2lmeSA9IE1vZHVsZVsnX1FUU19CdWlsZElzQXN5bmNpZnknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19CdWlsZElzQXN5bmNpZnknLCAwKTtcbnZhciBfUVRTX05ld0Z1bmN0aW9uID0gTW9kdWxlWydfUVRTX05ld0Z1bmN0aW9uJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfTmV3RnVuY3Rpb24nLCAzKTtcbnZhciBfUVRTX0FyZ3ZHZXRKU1ZhbHVlQ29uc3RQb2ludGVyID0gTW9kdWxlWydfUVRTX0FyZ3ZHZXRKU1ZhbHVlQ29uc3RQb2ludGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfQXJndkdldEpTVmFsdWVDb25zdFBvaW50ZXInLCAyKTtcbnZhciBfUVRTX1J1bnRpbWVFbmFibGVJbnRlcnJ1cHRIYW5kbGVyID0gTW9kdWxlWydfUVRTX1J1bnRpbWVFbmFibGVJbnRlcnJ1cHRIYW5kbGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUnVudGltZUVuYWJsZUludGVycnVwdEhhbmRsZXInLCAxKTtcbnZhciBfUVRTX1J1bnRpbWVEaXNhYmxlSW50ZXJydXB0SGFuZGxlciA9IE1vZHVsZVsnX1FUU19SdW50aW1lRGlzYWJsZUludGVycnVwdEhhbmRsZXInXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19SdW50aW1lRGlzYWJsZUludGVycnVwdEhhbmRsZXInLCAxKTtcbnZhciBfUVRTX1J1bnRpbWVFbmFibGVNb2R1bGVMb2FkZXIgPSBNb2R1bGVbJ19RVFNfUnVudGltZUVuYWJsZU1vZHVsZUxvYWRlciddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignUVRTX1J1bnRpbWVFbmFibGVNb2R1bGVMb2FkZXInLCAyKTtcbnZhciBfUVRTX1J1bnRpbWVEaXNhYmxlTW9kdWxlTG9hZGVyID0gTW9kdWxlWydfUVRTX1J1bnRpbWVEaXNhYmxlTW9kdWxlTG9hZGVyJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdRVFNfUnVudGltZURpc2FibGVNb2R1bGVMb2FkZXInLCAxKTtcbnZhciBfUVRTX2Jqc29uX2VuY29kZSA9IE1vZHVsZVsnX1FUU19ianNvbl9lbmNvZGUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19ianNvbl9lbmNvZGUnLCAyKTtcbnZhciBfUVRTX2Jqc29uX2RlY29kZSA9IE1vZHVsZVsnX1FUU19ianNvbl9kZWNvZGUnXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ1FUU19ianNvbl9kZWNvZGUnLCAyKTtcbnZhciBfZmZsdXNoID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZmZsdXNoJywgMSk7XG52YXIgX3N0cmVycm9yID0gY3JlYXRlRXhwb3J0V3JhcHBlcignc3RyZXJyb3InLCAxKTtcbnZhciBfX2Vtc2NyaXB0ZW5fdGVtcHJldF9zZXQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdfZW1zY3JpcHRlbl90ZW1wcmV0X3NldCcsIDEpO1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSAoKSA9PiAoX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCA9IHdhc21FeHBvcnRzWydlbXNjcmlwdGVuX3N0YWNrX2luaXQnXSkoKTtcbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSA9ICgpID0+IChfZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSA9IHdhc21FeHBvcnRzWydlbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlJ10pKCk7XG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSAoKSA9PiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSddKSgpO1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSAoKSA9PiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCA9IHdhc21FeHBvcnRzWydlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQnXSkoKTtcbnZhciBfX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSA9IChhMCkgPT4gKF9fZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlID0gd2FzbUV4cG9ydHNbJ19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUnXSkoYTApO1xudmFyIF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyA9IChhMCkgPT4gKF9fZW1zY3JpcHRlbl9zdGFja19hbGxvYyA9IHdhc21FeHBvcnRzWydfZW1zY3JpcHRlbl9zdGFja19hbGxvYyddKShhMCk7XG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSAoKSA9PiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSB3YXNtRXhwb3J0c1snZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCddKSgpO1xudmFyIGR5bkNhbGxfdmlpaSA9IE1vZHVsZVsnZHluQ2FsbF92aWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX3ZpaWknLCA0KTtcbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWlpaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWppaWlpJywgOCk7XG52YXIgZHluQ2FsbF9qaWppaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamlpaScsIDcpO1xudmFyIGR5bkNhbGxfaWlpID0gTW9kdWxlWydkeW5DYWxsX2lpaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWknLCAzKTtcbnZhciBkeW5DYWxsX2lpaWlpID0gTW9kdWxlWydkeW5DYWxsX2lpaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2lpaWlpJywgNSk7XG52YXIgZHluQ2FsbF9paWlpID0gTW9kdWxlWydkeW5DYWxsX2lpaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlpaScsIDQpO1xudmFyIGR5bkNhbGxfaWkgPSBNb2R1bGVbJ2R5bkNhbGxfaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWknLCAyKTtcbnZhciBkeW5DYWxsX2ppaWogPSBNb2R1bGVbJ2R5bkNhbGxfamlpaiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWlqJywgNSk7XG52YXIgZHluQ2FsbF9paWlpamogPSBNb2R1bGVbJ2R5bkNhbGxfaWlpaWpqJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2lpaWlqaicsIDgpO1xudmFyIGR5bkNhbGxfaWlpaWogPSBNb2R1bGVbJ2R5bkNhbGxfaWlpaWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlpaWonLCA2KTtcbnZhciBkeW5DYWxsX2ppaWlpaSA9IE1vZHVsZVsnZHluQ2FsbF9qaWlpaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlpaWlpJywgNik7XG52YXIgZHluQ2FsbF9qaWogPSBNb2R1bGVbJ2R5bkNhbGxfamlqJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppaicsIDQpO1xudmFyIGR5bkNhbGxfamlqamlpaSA9IE1vZHVsZVsnZHluQ2FsbF9qaWpqaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamppaWknLCA5KTtcbnZhciBkeW5DYWxsX3ZpaSA9IE1vZHVsZVsnZHluQ2FsbF92aWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfdmlpJywgMyk7XG52YXIgZHluQ2FsbF9qaWlpID0gTW9kdWxlWydkeW5DYWxsX2ppaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlpaScsIDQpO1xudmFyIGR5bkNhbGxfamlqaWkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqaWknLCA2KTtcbnZhciBkeW5DYWxsX2ppamlpaWlpID0gTW9kdWxlWydkeW5DYWxsX2ppamlpaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamlpaWlpJywgOSk7XG52YXIgZHluQ2FsbF9qaWpqID0gTW9kdWxlWydkeW5DYWxsX2ppamonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqaicsIDYpO1xudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVsnZHluQ2FsbF92aWppJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX3ZpamknLCA1KTtcbnZhciBkeW5DYWxsX3ZpaiA9IE1vZHVsZVsnZHluQ2FsbF92aWonXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfdmlqJywgNCk7XG52YXIgZHluQ2FsbF9paWlqaiA9IE1vZHVsZVsnZHluQ2FsbF9paWlqaiddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWlqaicsIDcpO1xudmFyIGR5bkNhbGxfaWlqaWpqamkgPSBNb2R1bGVbJ2R5bkNhbGxfaWlqaWpqamknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlqaWpqamknLCAxMik7XG52YXIgZHluQ2FsbF9paWlqaSA9IE1vZHVsZVsnZHluQ2FsbF9paWlqaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9paWlqaScsIDYpO1xudmFyIGR5bkNhbGxfaWlqaSA9IE1vZHVsZVsnZHluQ2FsbF9paWppJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2lpamknLCA1KTtcbnZhciBkeW5DYWxsX2ppamlqID0gTW9kdWxlWydkeW5DYWxsX2ppamlqJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppamlqJywgNyk7XG52YXIgZHluQ2FsbF9paWppamppID0gTW9kdWxlWydkeW5DYWxsX2lpamlqamknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlqaWpqaScsIDEwKTtcbnZhciBkeW5DYWxsX2ppaWlpID0gTW9kdWxlWydkeW5DYWxsX2ppaWlpJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2ppaWlpJywgNSk7XG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlWydkeW5DYWxsX2ppamknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqaScsIDUpO1xudmFyIGR5bkNhbGxfamlqamkgPSBNb2R1bGVbJ2R5bkNhbGxfamlqamknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfamlqamknLCA3KTtcbnZhciBkeW5DYWxsX2RkID0gTW9kdWxlWydkeW5DYWxsX2RkJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2RkJywgMik7XG52YXIgZHluQ2FsbF9kZGQgPSBNb2R1bGVbJ2R5bkNhbGxfZGRkJ10gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdkeW5DYWxsX2RkZCcsIDMpO1xudmFyIGR5bkNhbGxfamlpID0gTW9kdWxlWydkeW5DYWxsX2ppaSddID0gY3JlYXRlRXhwb3J0V3JhcHBlcignZHluQ2FsbF9qaWknLCAzKTtcbnZhciBkeW5DYWxsX2lpaWlpaSA9IE1vZHVsZVsnZHluQ2FsbF9paWlpaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlpaWlpJywgNik7XG52YXIgZHluQ2FsbF9paWRpaWlpID0gTW9kdWxlWydkeW5DYWxsX2lpZGlpaWknXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoJ2R5bkNhbGxfaWlkaWlpaScsIDcpO1xudmFyIF9hc3luY2lmeV9zdGFydF91bndpbmQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdhc3luY2lmeV9zdGFydF91bndpbmQnLCAxKTtcbnZhciBfYXN5bmNpZnlfc3RvcF91bndpbmQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdhc3luY2lmeV9zdG9wX3Vud2luZCcsIDApO1xudmFyIF9hc3luY2lmeV9zdGFydF9yZXdpbmQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdhc3luY2lmeV9zdGFydF9yZXdpbmQnLCAxKTtcbnZhciBfYXN5bmNpZnlfc3RvcF9yZXdpbmQgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKCdhc3luY2lmeV9zdG9wX3Jld2luZCcsIDApO1xuXG5cbi8vIGluY2x1ZGU6IHBvc3RhbWJsZS5qc1xuLy8gPT09IEF1dG8tZ2VuZXJhdGVkIHBvc3RhbWJsZSBzZXR1cCBlbnRyeSBzdHVmZiA9PT1cblxuTW9kdWxlWydjd3JhcCddID0gY3dyYXA7XG5Nb2R1bGVbJ1VURjhUb1N0cmluZyddID0gVVRGOFRvU3RyaW5nO1xuTW9kdWxlWydzdHJpbmdUb1VURjgnXSA9IHN0cmluZ1RvVVRGODtcbk1vZHVsZVsnbGVuZ3RoQnl0ZXNVVEY4J10gPSBsZW5ndGhCeXRlc1VURjg7XG52YXIgbWlzc2luZ0xpYnJhcnlTeW1ib2xzID0gW1xuICAnd3JpdGVJNTNUb0k2NCcsXG4gICd3cml0ZUk1M1RvSTY0Q2xhbXBlZCcsXG4gICd3cml0ZUk1M1RvSTY0U2lnbmFsaW5nJyxcbiAgJ3dyaXRlSTUzVG9VNjRDbGFtcGVkJyxcbiAgJ3dyaXRlSTUzVG9VNjRTaWduYWxpbmcnLFxuICAncmVhZEk1M0Zyb21JNjQnLFxuICAncmVhZEk1M0Zyb21VNjQnLFxuICAnY29udmVydEkzMlBhaXJUb0k1MycsXG4gICdjb252ZXJ0VTMyUGFpclRvSTUzJyxcbiAgJ2dldFRlbXBSZXQwJyxcbiAgJ3NldFRlbXBSZXQwJyxcbiAgJ3plcm9NZW1vcnknLFxuICAnc3RyRXJyb3InLFxuICAnaW5ldFB0b240JyxcbiAgJ2luZXROdG9wNCcsXG4gICdpbmV0UHRvbjYnLFxuICAnaW5ldE50b3A2JyxcbiAgJ3JlYWRTb2NrYWRkcicsXG4gICd3cml0ZVNvY2thZGRyJyxcbiAgJ2luaXRSYW5kb21GaWxsJyxcbiAgJ3JhbmRvbUZpbGwnLFxuICAnZW1zY3JpcHRlbkxvZycsXG4gICdyZWFkRW1Bc21BcmdzJyxcbiAgJ2pzdG9pX3EnLFxuICAnZ2V0RXhlY3V0YWJsZU5hbWUnLFxuICAnbGlzdGVuT25jZScsXG4gICdhdXRvUmVzdW1lQXVkaW9Db250ZXh0JyxcbiAgJ2R5bkNhbGxMZWdhY3knLFxuICAnZ2V0RHluQ2FsbGVyJyxcbiAgJ2R5bkNhbGwnLFxuICAnYXNtanNNYW5nbGUnLFxuICAnYXN5bmNMb2FkJyxcbiAgJ21tYXBBbGxvYycsXG4gICdIYW5kbGVBbGxvY2F0b3InLFxuICAnZ2V0TmF0aXZlVHlwZVNpemUnLFxuICAnU1RBQ0tfU0laRScsXG4gICdTVEFDS19BTElHTicsXG4gICdQT0lOVEVSX1NJWkUnLFxuICAnQVNTRVJUSU9OUycsXG4gICd1bGViMTI4RW5jb2RlJyxcbiAgJ2dlbmVyYXRlRnVuY1R5cGUnLFxuICAnY29udmVydEpzRnVuY3Rpb25Ub1dhc20nLFxuICAnZ2V0RW1wdHlUYWJsZVNsb3QnLFxuICAndXBkYXRlVGFibGVNYXAnLFxuICAnZ2V0RnVuY3Rpb25BZGRyZXNzJyxcbiAgJ2FkZEZ1bmN0aW9uJyxcbiAgJ3JlbW92ZUZ1bmN0aW9uJyxcbiAgJ3JlYWxseU5lZ2F0aXZlJyxcbiAgJ3VuU2lnbicsXG4gICdzdHJMZW4nLFxuICAncmVTaWduJyxcbiAgJ2Zvcm1hdFN0cmluZycsXG4gICdpbnRBcnJheUZyb21TdHJpbmcnLFxuICAnaW50QXJyYXlUb1N0cmluZycsXG4gICdBc2NpaVRvU3RyaW5nJyxcbiAgJ3N0cmluZ1RvQXNjaWknLFxuICAnVVRGMTZUb1N0cmluZycsXG4gICdzdHJpbmdUb1VURjE2JyxcbiAgJ2xlbmd0aEJ5dGVzVVRGMTYnLFxuICAnVVRGMzJUb1N0cmluZycsXG4gICdzdHJpbmdUb1VURjMyJyxcbiAgJ2xlbmd0aEJ5dGVzVVRGMzInLFxuICAnc3RyaW5nVG9OZXdVVEY4JyxcbiAgJ3JlZ2lzdGVyS2V5RXZlbnRDYWxsYmFjaycsXG4gICdtYXliZUNTdHJpbmdUb0pzU3RyaW5nJyxcbiAgJ2ZpbmRFdmVudFRhcmdldCcsXG4gICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnLFxuICAnZmlsbE1vdXNlRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrJyxcbiAgJ3JlZ2lzdGVyV2hlZWxFdmVudENhbGxiYWNrJyxcbiAgJ3JlZ2lzdGVyVWlFdmVudENhbGxiYWNrJyxcbiAgJ3JlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrJyxcbiAgJ2ZpbGxEZXZpY2VPcmllbnRhdGlvbkV2ZW50RGF0YScsXG4gICdyZWdpc3RlckRldmljZU9yaWVudGF0aW9uRXZlbnRDYWxsYmFjaycsXG4gICdmaWxsRGV2aWNlTW90aW9uRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyRGV2aWNlTW90aW9uRXZlbnRDYWxsYmFjaycsXG4gICdzY3JlZW5PcmllbnRhdGlvbicsXG4gICdmaWxsT3JpZW50YXRpb25DaGFuZ2VFdmVudERhdGEnLFxuICAncmVnaXN0ZXJPcmllbnRhdGlvbkNoYW5nZUV2ZW50Q2FsbGJhY2snLFxuICAnZmlsbEZ1bGxzY3JlZW5DaGFuZ2VFdmVudERhdGEnLFxuICAncmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFjaycsXG4gICdKU0V2ZW50c19yZXF1ZXN0RnVsbHNjcmVlbicsXG4gICdKU0V2ZW50c19yZXNpemVDYW52YXNGb3JGdWxsc2NyZWVuJyxcbiAgJ3JlZ2lzdGVyUmVzdG9yZU9sZFN0eWxlJyxcbiAgJ2hpZGVFdmVyeXRoaW5nRXhjZXB0R2l2ZW5FbGVtZW50JyxcbiAgJ3Jlc3RvcmVIaWRkZW5FbGVtZW50cycsXG4gICdzZXRMZXR0ZXJib3gnLFxuICAnc29mdEZ1bGxzY3JlZW5SZXNpemVXZWJHTFJlbmRlclRhcmdldCcsXG4gICdkb1JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgJ2ZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YScsXG4gICdyZWdpc3RlclBvaW50ZXJsb2NrQ2hhbmdlRXZlbnRDYWxsYmFjaycsXG4gICdyZWdpc3RlclBvaW50ZXJsb2NrRXJyb3JFdmVudENhbGxiYWNrJyxcbiAgJ3JlcXVlc3RQb2ludGVyTG9jaycsXG4gICdmaWxsVmlzaWJpbGl0eUNoYW5nZUV2ZW50RGF0YScsXG4gICdyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VFdmVudENhbGxiYWNrJyxcbiAgJ3JlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrJyxcbiAgJ2ZpbGxHYW1lcGFkRXZlbnREYXRhJyxcbiAgJ3JlZ2lzdGVyR2FtZXBhZEV2ZW50Q2FsbGJhY2snLFxuICAncmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrJyxcbiAgJ2ZpbGxCYXR0ZXJ5RXZlbnREYXRhJyxcbiAgJ2JhdHRlcnknLFxuICAncmVnaXN0ZXJCYXR0ZXJ5RXZlbnRDYWxsYmFjaycsXG4gICdzZXRDYW52YXNFbGVtZW50U2l6ZScsXG4gICdnZXRDYW52YXNFbGVtZW50U2l6ZScsXG4gICdqc1N0YWNrVHJhY2UnLFxuICAnZ2V0Q2FsbHN0YWNrJyxcbiAgJ2NvbnZlcnRQQ3RvU291cmNlTG9jYXRpb24nLFxuICAnZ2V0RW52U3RyaW5ncycsXG4gICdjaGVja1dhc2lDbG9jaycsXG4gICd3YXNpUmlnaHRzVG9NdXNsT0ZsYWdzJyxcbiAgJ3dhc2lPRmxhZ3NUb011c2xPRmxhZ3MnLFxuICAnY3JlYXRlRHluY2FsbFdyYXBwZXInLFxuICAnc2FmZVNldFRpbWVvdXQnLFxuICAnc2V0SW1tZWRpYXRlV3JhcHBlZCcsXG4gICdjbGVhckltbWVkaWF0ZVdyYXBwZWQnLFxuICAncG9seWZpbGxTZXRJbW1lZGlhdGUnLFxuICAnZ2V0UHJvbWlzZScsXG4gICdtYWtlUHJvbWlzZScsXG4gICdpZHNUb1Byb21pc2VzJyxcbiAgJ21ha2VQcm9taXNlQ2FsbGJhY2snLFxuICAnQnJvd3Nlcl9hc3luY1ByZXBhcmVEYXRhQ291bnRlcicsXG4gICdzZXRNYWluTG9vcCcsXG4gICdhcnJheVN1bScsXG4gICdhZGREYXlzJyxcbiAgJ2dldFNvY2tldEZyb21GRCcsXG4gICdnZXRTb2NrZXRBZGRyZXNzJyxcbiAgJ0ZTX2NyZWF0ZVByZWxvYWRlZEZpbGUnLFxuICAnRlNfbW9kZVN0cmluZ1RvRmxhZ3MnLFxuICAnRlNfZ2V0TW9kZScsXG4gICdGU19zdGRpbl9nZXRDaGFyJyxcbiAgJ0ZTX3VubGluaycsXG4gICdGU19jcmVhdGVEYXRhRmlsZScsXG4gICdGU19ta2RpclRyZWUnLFxuICAnX3NldE5ldHdvcmtDYWxsYmFjaycsXG4gICdBTExPQ19OT1JNQUwnLFxuICAnQUxMT0NfU1RBQ0snLFxuICAnYWxsb2NhdGUnLFxuICAnd3JpdGVTdHJpbmdUb01lbW9yeScsXG4gICd3cml0ZUFzY2lpVG9NZW1vcnknLFxuICAnc2V0RXJyTm8nLFxuICAnc3RhY2tUcmFjZScsXG5dO1xubWlzc2luZ0xpYnJhcnlTeW1ib2xzLmZvckVhY2gobWlzc2luZ0xpYnJhcnlTeW1ib2wpXG5cbnZhciB1bmV4cG9ydGVkU3ltYm9scyA9IFtcbiAgJ3J1bicsXG4gICdhZGRPblByZVJ1bicsXG4gICdhZGRPbkluaXQnLFxuICAnYWRkT25QcmVNYWluJyxcbiAgJ2FkZE9uRXhpdCcsXG4gICdhZGRPblBvc3RSdW4nLFxuICAnYWRkUnVuRGVwZW5kZW5jeScsXG4gICdyZW1vdmVSdW5EZXBlbmRlbmN5JyxcbiAgJ291dCcsXG4gICdlcnInLFxuICAnY2FsbE1haW4nLFxuICAnYWJvcnQnLFxuICAnd2FzbU1lbW9yeScsXG4gICd3YXNtRXhwb3J0cycsXG4gICd3cml0ZVN0YWNrQ29va2llJyxcbiAgJ2NoZWNrU3RhY2tDb29raWUnLFxuICAnY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQnLFxuICAnc3RhY2tTYXZlJyxcbiAgJ3N0YWNrUmVzdG9yZScsXG4gICdzdGFja0FsbG9jJyxcbiAgJ3B0clRvU3RyaW5nJyxcbiAgJ2V4aXRKUycsXG4gICdnZXRIZWFwTWF4JyxcbiAgJ2dyb3dNZW1vcnknLFxuICAnRU5WJyxcbiAgJ0VSUk5PX0NPREVTJyxcbiAgJ0ROUycsXG4gICdQcm90b2NvbHMnLFxuICAnU29ja2V0cycsXG4gICd0aW1lcnMnLFxuICAnd2Fybk9uY2UnLFxuICAncmVhZEVtQXNtQXJnc0FycmF5JyxcbiAgJ2pzdG9pX3MnLFxuICAnaGFuZGxlRXhjZXB0aW9uJyxcbiAgJ2tlZXBSdW50aW1lQWxpdmUnLFxuICAncnVudGltZUtlZXBhbGl2ZVB1c2gnLFxuICAncnVudGltZUtlZXBhbGl2ZVBvcCcsXG4gICdjYWxsVXNlckNhbGxiYWNrJyxcbiAgJ21heWJlRXhpdCcsXG4gICdhbGlnbk1lbW9yeScsXG4gICd3YXNtVGFibGUnLFxuICAnbm9FeGl0UnVudGltZScsXG4gICdnZXRDRnVuYycsXG4gICdjY2FsbCcsXG4gICdzaWdUb1dhc21UeXBlcycsXG4gICdmcmVlVGFibGVJbmRleGVzJyxcbiAgJ2Z1bmN0aW9uc0luVGFibGVNYXAnLFxuICAnc2V0VmFsdWUnLFxuICAnZ2V0VmFsdWUnLFxuICAnUEFUSCcsXG4gICdQQVRIX0ZTJyxcbiAgJ1VURjhEZWNvZGVyJyxcbiAgJ1VURjhBcnJheVRvU3RyaW5nJyxcbiAgJ3N0cmluZ1RvVVRGOEFycmF5JyxcbiAgJ1VURjE2RGVjb2RlcicsXG4gICdzdHJpbmdUb1VURjhPblN0YWNrJyxcbiAgJ3dyaXRlQXJyYXlUb01lbW9yeScsXG4gICdKU0V2ZW50cycsXG4gICdzcGVjaWFsSFRNTFRhcmdldHMnLFxuICAnZmluZENhbnZhc0V2ZW50VGFyZ2V0JyxcbiAgJ2N1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3knLFxuICAncmVzdG9yZU9sZFdpbmRvd2VkU3R5bGUnLFxuICAnVU5XSU5EX0NBQ0hFJyxcbiAgJ0V4aXRTdGF0dXMnLFxuICAnZmx1c2hfTk9fRklMRVNZU1RFTScsXG4gICdwcm9taXNlTWFwJyxcbiAgJ0Jyb3dzZXInLFxuICAnZ2V0UHJlbG9hZGVkSW1hZ2VEYXRhX19kYXRhJyxcbiAgJ3dnZXQnLFxuICAnTU9OVEhfREFZU19SRUdVTEFSJyxcbiAgJ01PTlRIX0RBWVNfTEVBUCcsXG4gICdNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRScsXG4gICdNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRScsXG4gICdpc0xlYXBZZWFyJyxcbiAgJ3lkYXlGcm9tRGF0ZScsXG4gICdTWVNDQUxMUycsXG4gICdwcmVsb2FkUGx1Z2lucycsXG4gICdGU19zdGRpbl9nZXRDaGFyX2J1ZmZlcicsXG4gICdGU19jcmVhdGVQYXRoJyxcbiAgJ0ZTX2NyZWF0ZURldmljZScsXG4gICdGU19yZWFkRmlsZScsXG4gICdGUycsXG4gICdGU19jcmVhdGVMYXp5RmlsZScsXG4gICdNRU1GUycsXG4gICdUVFknLFxuICAnUElQRUZTJyxcbiAgJ1NPQ0tGUycsXG4gICdydW5BbmRBYm9ydElmRXJyb3InLFxuICAnQXN5bmNpZnknLFxuICAnRmliZXJzJyxcbiAgJ2FsbG9jYXRlVVRGOCcsXG4gICdhbGxvY2F0ZVVURjhPblN0YWNrJyxcbiAgJ3ByaW50JyxcbiAgJ3ByaW50RXJyJyxcbl07XG51bmV4cG9ydGVkU3ltYm9scy5mb3JFYWNoKHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKTtcblxuXG5cbnZhciBjYWxsZWRSdW47XG5cbmRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcbiAgLy8gSWYgcnVuIGhhcyBuZXZlciBiZWVuIGNhbGxlZCwgYW5kIHdlIHNob3VsZCBjYWxsIHJ1biAoSU5WT0tFX1JVTiBpcyB0cnVlLCBhbmQgTW9kdWxlLm5vSW5pdGlhbFJ1biBpcyBub3QgZmFsc2UpXG4gIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjsgLy8gdHJ5IHRoaXMgYWdhaW4gbGF0ZXIsIGFmdGVyIG5ldyBkZXBzIGFyZSBmdWxmaWxsZWRcbn07XG5cbmZ1bmN0aW9uIHN0YWNrQ2hlY2tJbml0KCkge1xuICAvLyBUaGlzIGlzIG5vcm1hbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyBfX3dhc21fY2FsbF9jdG9ycyBidXQgbmVlZCB0b1xuICAvLyBnZXQgdGhlc2UgdmFsdWVzIGJlZm9yZSBldmVuIHJ1bm5pbmcgYW55IG9mIHRoZSBjdG9ycyBzbyB3ZSBjYWxsIGl0IHJlZHVuZGFudGx5XG4gIC8vIGhlcmUuXG4gIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQoKTtcbiAgLy8gVE9ETyhzYmMpOiBNb3ZlIHdyaXRlU3RhY2tDb29raWUgdG8gbmF0aXZlIHRvIHRvIGF2b2lkIHRoaXMuXG4gIHdyaXRlU3RhY2tDb29raWUoKTtcbn1cblxuZnVuY3Rpb24gcnVuKCkge1xuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgICBzdGFja0NoZWNrSW5pdCgpO1xuXG4gIHByZVJ1bigpO1xuXG4gIC8vIGEgcHJlUnVuIGFkZGVkIGEgZGVwZW5kZW5jeSwgcnVuIHdpbGwgYmUgY2FsbGVkIGxhdGVyXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgLy8gcnVuIG1heSBoYXZlIGp1c3QgYmVlbiBjYWxsZWQgdGhyb3VnaCBkZXBlbmRlbmNpZXMgYmVpbmcgZnVsZmlsbGVkIGp1c3QgaW4gdGhpcyB2ZXJ5IGZyYW1lLFxuICAgIC8vIG9yIHdoaWxlIHRoZSBhc3luYyBzZXRTdGF0dXMgdGltZSBiZWxvdyB3YXMgaGFwcGVuaW5nXG4gICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgIGluaXRSdW50aW1lKCk7XG5cbiAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddPy4oKTtcblxuICAgIGFzc2VydCghTW9kdWxlWydfbWFpbiddLCAnY29tcGlsZWQgd2l0aG91dCBhIG1haW4sIGJ1dCBvbmUgaXMgcHJlc2VudC4gaWYgeW91IGFkZGVkIGl0IGZyb20gSlMsIHVzZSBNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXScpO1xuXG4gICAgcG9zdFJ1bigpO1xuICB9XG5cbiAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgfSwgMSk7XG4gICAgICBkb1J1bigpO1xuICAgIH0sIDEpO1xuICB9IGVsc2VcbiAge1xuICAgIGRvUnVuKCk7XG4gIH1cbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xufVxuXG5mdW5jdGlvbiBjaGVja1VuZmx1c2hlZENvbnRlbnQoKSB7XG4gIC8vIENvbXBpbGVyIHNldHRpbmdzIGRvIG5vdCBhbGxvdyBleGl0aW5nIHRoZSBydW50aW1lLCBzbyBmbHVzaGluZ1xuICAvLyB0aGUgc3RyZWFtcyBpcyBub3QgcG9zc2libGUuIGJ1dCBpbiBBU1NFUlRJT05TIG1vZGUgd2UgY2hlY2tcbiAgLy8gaWYgdGhlcmUgd2FzIHNvbWV0aGluZyB0byBmbHVzaCwgYW5kIGlmIHNvIHRlbGwgdGhlIHVzZXIgdGhleVxuICAvLyBzaG91bGQgcmVxdWVzdCB0aGF0IHRoZSBydW50aW1lIGJlIGV4aXRhYmxlLlxuICAvLyBOb3JtYWxseSB3ZSB3b3VsZCBub3QgZXZlbiBpbmNsdWRlIGZsdXNoKCkgYXQgYWxsLCBidXQgaW4gQVNTRVJUSU9OU1xuICAvLyBidWlsZHMgd2UgZG8gc28ganVzdCBmb3IgdGhpcyBjaGVjaywgYW5kIGhlcmUgd2Ugc2VlIGlmIHRoZXJlIGlzIGFueVxuICAvLyBjb250ZW50IHRvIGZsdXNoLCB0aGF0IGlzLCB3ZSBjaGVjayBpZiB0aGVyZSB3b3VsZCBoYXZlIGJlZW5cbiAgLy8gc29tZXRoaW5nIGEgbm9uLUFTU0VSVElPTlMgYnVpbGQgd291bGQgaGF2ZSBub3Qgc2Vlbi5cbiAgLy8gSG93IHdlIGZsdXNoIHRoZSBzdHJlYW1zIGRlcGVuZHMgb24gd2hldGhlciB3ZSBhcmUgaW4gU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNPTBcbiAgLy8gbW9kZSAod2hpY2ggaGFzIGl0cyBvd24gc3BlY2lhbCBmdW5jdGlvbiBmb3IgdGhpczsgb3RoZXJ3aXNlLCBhbGxcbiAgLy8gdGhlIGNvZGUgaXMgaW5zaWRlIGxpYmMpXG4gIHZhciBvbGRPdXQgPSBvdXQ7XG4gIHZhciBvbGRFcnIgPSBlcnI7XG4gIHZhciBoYXMgPSBmYWxzZTtcbiAgb3V0ID0gZXJyID0gKHgpID0+IHtcbiAgICBoYXMgPSB0cnVlO1xuICB9XG4gIHRyeSB7IC8vIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIGl0IGZhaWxzXG4gICAgZmx1c2hfTk9fRklMRVNZU1RFTSgpO1xuICB9IGNhdGNoKGUpIHt9XG4gIG91dCA9IG9sZE91dDtcbiAgZXJyID0gb2xkRXJyO1xuICBpZiAoaGFzKSB7XG4gICAgd2Fybk9uY2UoJ3N0ZGlvIHN0cmVhbXMgaGFkIGNvbnRlbnQgaW4gdGhlbSB0aGF0IHdhcyBub3QgZmx1c2hlZC4geW91IHNob3VsZCBzZXQgRVhJVF9SVU5USU1FIHRvIDEgKHNlZSB0aGUgRW1zY3JpcHRlbiBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy4nKTtcbiAgICB3YXJuT25jZSgnKHRoaXMgbWF5IGFsc28gYmUgZHVlIHRvIG5vdCBpbmNsdWRpbmcgZnVsbCBmaWxlc3lzdGVtIHN1cHBvcnQgLSB0cnkgYnVpbGRpbmcgd2l0aCAtc0ZPUkNFX0ZJTEVTWVNURU0pJyk7XG4gIH1cbn1cblxuaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICB3aGlsZSAoTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkge1xuICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7XG4gIH1cbn1cblxucnVuKCk7XG5cbi8vIGVuZCBpbmNsdWRlOiBwb3N0YW1ibGUuanNcblxuLy8gaW5jbHVkZTogcG9zdGFtYmxlX21vZHVsYXJpemUuanNcbi8vIEluIE1PRFVMQVJJWkUgbW9kZSB3ZSB3cmFwIHRoZSBnZW5lcmF0ZWQgY29kZSBpbiBhIGZhY3RvcnkgZnVuY3Rpb25cbi8vIGFuZCByZXR1cm4gZWl0aGVyIHRoZSBNb2R1bGUgaXRzZWxmLCBvciBhIHByb21pc2Ugb2YgdGhlIG1vZHVsZS5cbi8vXG4vLyBXZSBhc3NpZ24gdG8gdGhlIGBtb2R1bGVSdG5gIGdsb2JhbCBoZXJlIGFuZCBjb25maWd1cmUgY2xvc3VyZSB0byBzZWVcbi8vIHRoaXMgYXMgYW5kIGV4dGVybiBzbyBpdCB3b24ndCBnZXQgbWluaWZpZWQuXG5cbm1vZHVsZVJ0biA9IHJlYWR5UHJvbWlzZTtcblxuLy8gQXNzZXJ0aW9uIGZvciBhdHRlbXB0aW5nIHRvIGFjY2VzcyBtb2R1bGUgcHJvcGVydGllcyBvbiB0aGUgaW5jb21pbmdcbi8vIG1vZHVsZUFyZy4gIEluIHRoZSBwYXN0IHdlIHVzZWQgdGhpcyBvYmplY3QgYXMgdGhlIHByb3RvdHlwZSBvZiB0aGUgbW9kdWxlXG4vLyBhbmQgYXNzaWduZWQgcHJvcGVydGllcyB0byBpdCwgYnV0IG5vdyB3ZSByZXR1cm4gYSBkaXN0aW5jdCBvYmplY3QuICBUaGlzXG4vLyBrZWVwcyB0aGUgaW5zdGFuY2UgcHJpdmF0ZSB1bnRpbCBpdCBpcyByZWFkeSAoaS5lIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4vLyByZXNvbHZlZCkuXG5mb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoTW9kdWxlKSkge1xuICBpZiAoIShwcm9wIGluIG1vZHVsZUFyZykpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlQXJnLCBwcm9wLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGFib3J0KGBBY2Nlc3MgdG8gbW9kdWxlIHByb3BlcnR5ICgnJHtwcm9wfScpIGlzIG5vIGxvbmdlciBwb3NzaWJsZSB2aWEgdGhlIG1vZHVsZSBjb25zdHJ1Y3RvciBhcmd1bWVudDsgSW5zdGVhZCwgdXNlIHRoZSByZXN1bHQgb2YgdGhlIG1vZHVsZSBjb25zdHJ1Y3Rvci5gKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vLyBlbmQgaW5jbHVkZTogcG9zdGFtYmxlX21vZHVsYXJpemUuanNcblxuXG5cbiAgcmV0dXJuIG1vZHVsZVJ0bjtcbn1cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgUXVpY2tKU1JhdztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.browser.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.wasm":
/*!****************************************************************************************!*\
  !*** ./node_modules/@jitl/quickjs-wasmfile-debug-asyncify/dist/emscripten-module.wasm ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/emscripten-module.3353f8ae.wasm";

/***/ })

}]);