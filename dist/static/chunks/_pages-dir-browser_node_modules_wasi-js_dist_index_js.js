/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_wasi-js_dist_index_js"],{

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Dirent.js":
/*!**************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/Dirent.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dirent = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/encoding.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK, } = constants_1.constants;\n/**\n * A directory entry, like `fs.Dirent`.\n */\nclass Dirent {\n    constructor() {\n        this.name = \"\";\n        this.mode = 0;\n    }\n    static build(link, encoding) {\n        const dirent = new Dirent();\n        const { mode } = link.getNode();\n        dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);\n        dirent.mode = mode;\n        return dirent;\n    }\n    _checkModeProperty(property) {\n        return (this.mode & S_IFMT) === property;\n    }\n    isDirectory() {\n        return this._checkModeProperty(S_IFDIR);\n    }\n    isFile() {\n        return this._checkModeProperty(S_IFREG);\n    }\n    isBlockDevice() {\n        return this._checkModeProperty(S_IFBLK);\n    }\n    isCharacterDevice() {\n        return this._checkModeProperty(S_IFCHR);\n    }\n    isSymbolicLink() {\n        return this._checkModeProperty(S_IFLNK);\n    }\n    isFIFO() {\n        return this._checkModeProperty(S_IFIFO);\n    }\n    isSocket() {\n        return this._checkModeProperty(S_IFSOCK);\n    }\n}\nexports.Dirent = Dirent;\nexports[\"default\"] = Dirent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9EaXJlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFZO0FBQ3ZDLFFBQVEsMEVBQTBFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBZSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBjb3dhc21cXG1lbWZzXFxsaWJcXERpcmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlyZW50ID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG5jb25zdCB7IFNfSUZNVCwgU19JRkRJUiwgU19JRlJFRywgU19JRkJMSywgU19JRkNIUiwgU19JRkxOSywgU19JRklGTywgU19JRlNPQ0ssIH0gPSBjb25zdGFudHNfMS5jb25zdGFudHM7XG4vKipcbiAqIEEgZGlyZWN0b3J5IGVudHJ5LCBsaWtlIGBmcy5EaXJlbnRgLlxuICovXG5jbGFzcyBEaXJlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm1vZGUgPSAwO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQobGluaywgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZGlyZW50ID0gbmV3IERpcmVudCgpO1xuICAgICAgICBjb25zdCB7IG1vZGUgfSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBkaXJlbnQubmFtZSA9ICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKGxpbmsuZ2V0TmFtZSgpLCBlbmNvZGluZyk7XG4gICAgICAgIGRpcmVudC5tb2RlID0gbW9kZTtcbiAgICAgICAgcmV0dXJuIGRpcmVudDtcbiAgICB9XG4gICAgX2NoZWNrTW9kZVByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gcHJvcGVydHk7XG4gICAgfVxuICAgIGlzRGlyZWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkRJUik7XG4gICAgfVxuICAgIGlzRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZSRUcpO1xuICAgIH1cbiAgICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkJMSyk7XG4gICAgfVxuICAgIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkNIUik7XG4gICAgfVxuICAgIGlzU3ltYm9saWNMaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkxOSyk7XG4gICAgfVxuICAgIGlzRklGTygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZJRk8pO1xuICAgIH1cbiAgICBpc1NvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZTT0NLKTtcbiAgICB9XG59XG5leHBvcnRzLkRpcmVudCA9IERpcmVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IERpcmVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Dirent.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Stats.js":
/*!*************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/Stats.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Stats = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\");\nconst getBigInt_1 = __webpack_require__(/*! ./getBigInt */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/getBigInt.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK, } = constants_1.constants;\n/**\n * Statistics about a file/directory, like `fs.Stats`.\n */\nclass Stats {\n    static build(node, bigint = false) {\n        const stats = new Stats();\n        const { uid, gid, atime, mtime, ctime } = node;\n        const getStatNumber = !bigint ? (number) => number : getBigInt_1.default;\n        // Copy all values on Stats from Node, so that if Node values\n        // change, values on Stats would still be the old ones,\n        // just like in Node fs.\n        stats.uid = getStatNumber(uid);\n        stats.gid = getStatNumber(gid);\n        stats.rdev = getStatNumber(0);\n        stats.blksize = getStatNumber(4096);\n        stats.ino = getStatNumber(node.ino);\n        stats.size = getStatNumber(node.getSize());\n        stats.blocks = getStatNumber(1);\n        stats.atime = atime;\n        stats.mtime = mtime;\n        stats.ctime = ctime;\n        stats.birthtime = ctime;\n        stats.atimeMs = getStatNumber(atime.getTime());\n        stats.mtimeMs = getStatNumber(mtime.getTime());\n        const ctimeMs = getStatNumber(ctime.getTime());\n        stats.ctimeMs = ctimeMs;\n        stats.birthtimeMs = ctimeMs;\n        stats.dev = getStatNumber(0);\n        stats.mode = getStatNumber(node.mode);\n        stats.nlink = getStatNumber(node.nlink);\n        return stats;\n    }\n    _checkModeProperty(property) {\n        return (Number(this.mode) & S_IFMT) === property;\n    }\n    isDirectory() {\n        return this._checkModeProperty(S_IFDIR);\n    }\n    isFile() {\n        return this._checkModeProperty(S_IFREG);\n    }\n    isBlockDevice() {\n        return this._checkModeProperty(S_IFBLK);\n    }\n    isCharacterDevice() {\n        return this._checkModeProperty(S_IFCHR);\n    }\n    isSymbolicLink() {\n        return this._checkModeProperty(S_IFLNK);\n    }\n    isFIFO() {\n        return this._checkModeProperty(S_IFIFO);\n    }\n    isSocket() {\n        return this._checkModeProperty(S_IFSOCK);\n    }\n}\nexports.Stats = Stats;\nexports[\"default\"] = Stats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9TdGF0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2Isb0JBQW9CLG1CQUFPLENBQUMsc0ZBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsc0ZBQWE7QUFDekMsUUFBUSwwRUFBMEU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCQUFlIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcU3RhdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXRzID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBnZXRCaWdJbnRfMSA9IHJlcXVpcmUoXCIuL2dldEJpZ0ludFwiKTtcbmNvbnN0IHsgU19JRk1ULCBTX0lGRElSLCBTX0lGUkVHLCBTX0lGQkxLLCBTX0lGQ0hSLCBTX0lGTE5LLCBTX0lGSUZPLCBTX0lGU09DSywgfSA9IGNvbnN0YW50c18xLmNvbnN0YW50cztcbi8qKlxuICogU3RhdGlzdGljcyBhYm91dCBhIGZpbGUvZGlyZWN0b3J5LCBsaWtlIGBmcy5TdGF0c2AuXG4gKi9cbmNsYXNzIFN0YXRzIHtcbiAgICBzdGF0aWMgYnVpbGQobm9kZSwgYmlnaW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgICAgICAgY29uc3QgeyB1aWQsIGdpZCwgYXRpbWUsIG10aW1lLCBjdGltZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZ2V0U3RhdE51bWJlciA9ICFiaWdpbnQgPyAobnVtYmVyKSA9PiBudW1iZXIgOiBnZXRCaWdJbnRfMS5kZWZhdWx0O1xuICAgICAgICAvLyBDb3B5IGFsbCB2YWx1ZXMgb24gU3RhdHMgZnJvbSBOb2RlLCBzbyB0aGF0IGlmIE5vZGUgdmFsdWVzXG4gICAgICAgIC8vIGNoYW5nZSwgdmFsdWVzIG9uIFN0YXRzIHdvdWxkIHN0aWxsIGJlIHRoZSBvbGQgb25lcyxcbiAgICAgICAgLy8ganVzdCBsaWtlIGluIE5vZGUgZnMuXG4gICAgICAgIHN0YXRzLnVpZCA9IGdldFN0YXROdW1iZXIodWlkKTtcbiAgICAgICAgc3RhdHMuZ2lkID0gZ2V0U3RhdE51bWJlcihnaWQpO1xuICAgICAgICBzdGF0cy5yZGV2ID0gZ2V0U3RhdE51bWJlcigwKTtcbiAgICAgICAgc3RhdHMuYmxrc2l6ZSA9IGdldFN0YXROdW1iZXIoNDA5Nik7XG4gICAgICAgIHN0YXRzLmlubyA9IGdldFN0YXROdW1iZXIobm9kZS5pbm8pO1xuICAgICAgICBzdGF0cy5zaXplID0gZ2V0U3RhdE51bWJlcihub2RlLmdldFNpemUoKSk7XG4gICAgICAgIHN0YXRzLmJsb2NrcyA9IGdldFN0YXROdW1iZXIoMSk7XG4gICAgICAgIHN0YXRzLmF0aW1lID0gYXRpbWU7XG4gICAgICAgIHN0YXRzLm10aW1lID0gbXRpbWU7XG4gICAgICAgIHN0YXRzLmN0aW1lID0gY3RpbWU7XG4gICAgICAgIHN0YXRzLmJpcnRodGltZSA9IGN0aW1lO1xuICAgICAgICBzdGF0cy5hdGltZU1zID0gZ2V0U3RhdE51bWJlcihhdGltZS5nZXRUaW1lKCkpO1xuICAgICAgICBzdGF0cy5tdGltZU1zID0gZ2V0U3RhdE51bWJlcihtdGltZS5nZXRUaW1lKCkpO1xuICAgICAgICBjb25zdCBjdGltZU1zID0gZ2V0U3RhdE51bWJlcihjdGltZS5nZXRUaW1lKCkpO1xuICAgICAgICBzdGF0cy5jdGltZU1zID0gY3RpbWVNcztcbiAgICAgICAgc3RhdHMuYmlydGh0aW1lTXMgPSBjdGltZU1zO1xuICAgICAgICBzdGF0cy5kZXYgPSBnZXRTdGF0TnVtYmVyKDApO1xuICAgICAgICBzdGF0cy5tb2RlID0gZ2V0U3RhdE51bWJlcihub2RlLm1vZGUpO1xuICAgICAgICBzdGF0cy5ubGluayA9IGdldFN0YXROdW1iZXIobm9kZS5ubGluayk7XG4gICAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gICAgX2NoZWNrTW9kZVByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiAoTnVtYmVyKHRoaXMubW9kZSkgJiBTX0lGTVQpID09PSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGRElSKTtcbiAgICB9XG4gICAgaXNGaWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlJFRyk7XG4gICAgfVxuICAgIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGQkxLKTtcbiAgICB9XG4gICAgaXNDaGFyYWN0ZXJEZXZpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGQ0hSKTtcbiAgICB9XG4gICAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGTE5LKTtcbiAgICB9XG4gICAgaXNGSUZPKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRklGTyk7XG4gICAgfVxuICAgIGlzU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlNPQ0spO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdHMgPSBTdGF0cztcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Stats.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.constants = void 0;\nexports.constants = {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 64,\n    O_EXCL: 128,\n    O_NOCTTY: 256,\n    O_TRUNC: 512,\n    O_APPEND: 1024,\n    O_DIRECTORY: 65536,\n    O_NOATIME: 262144,\n    O_NOFOLLOW: 131072,\n    O_SYNC: 1052672,\n    O_DIRECT: 16384,\n    O_NONBLOCK: 2048,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_SYMLINK_DIR: 1,\n    UV_FS_SYMLINK_JUNCTION: 2,\n    UV_FS_COPYFILE_EXCL: 1,\n    UV_FS_COPYFILE_FICLONE: 2,\n    UV_FS_COPYFILE_FICLONE_FORCE: 4,\n    COPYFILE_EXCL: 1,\n    COPYFILE_FICLONE: 2,\n    COPYFILE_FICLONE_FORCE: 4,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25zdGFudHMgPSB2b2lkIDA7XG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgICBPX1JET05MWTogMCxcbiAgICBPX1dST05MWTogMSxcbiAgICBPX1JEV1I6IDIsXG4gICAgU19JRk1UOiA2MTQ0MCxcbiAgICBTX0lGUkVHOiAzMjc2OCxcbiAgICBTX0lGRElSOiAxNjM4NCxcbiAgICBTX0lGQ0hSOiA4MTkyLFxuICAgIFNfSUZCTEs6IDI0NTc2LFxuICAgIFNfSUZJRk86IDQwOTYsXG4gICAgU19JRkxOSzogNDA5NjAsXG4gICAgU19JRlNPQ0s6IDQ5MTUyLFxuICAgIE9fQ1JFQVQ6IDY0LFxuICAgIE9fRVhDTDogMTI4LFxuICAgIE9fTk9DVFRZOiAyNTYsXG4gICAgT19UUlVOQzogNTEyLFxuICAgIE9fQVBQRU5EOiAxMDI0LFxuICAgIE9fRElSRUNUT1JZOiA2NTUzNixcbiAgICBPX05PQVRJTUU6IDI2MjE0NCxcbiAgICBPX05PRk9MTE9XOiAxMzEwNzIsXG4gICAgT19TWU5DOiAxMDUyNjcyLFxuICAgIE9fRElSRUNUOiAxNjM4NCxcbiAgICBPX05PTkJMT0NLOiAyMDQ4LFxuICAgIFNfSVJXWFU6IDQ0OCxcbiAgICBTX0lSVVNSOiAyNTYsXG4gICAgU19JV1VTUjogMTI4LFxuICAgIFNfSVhVU1I6IDY0LFxuICAgIFNfSVJXWEc6IDU2LFxuICAgIFNfSVJHUlA6IDMyLFxuICAgIFNfSVdHUlA6IDE2LFxuICAgIFNfSVhHUlA6IDgsXG4gICAgU19JUldYTzogNyxcbiAgICBTX0lST1RIOiA0LFxuICAgIFNfSVdPVEg6IDIsXG4gICAgU19JWE9USDogMSxcbiAgICBGX09LOiAwLFxuICAgIFJfT0s6IDQsXG4gICAgV19PSzogMixcbiAgICBYX09LOiAxLFxuICAgIFVWX0ZTX1NZTUxJTktfRElSOiAxLFxuICAgIFVWX0ZTX1NZTUxJTktfSlVOQ1RJT046IDIsXG4gICAgVVZfRlNfQ09QWUZJTEVfRVhDTDogMSxcbiAgICBVVl9GU19DT1BZRklMRV9GSUNMT05FOiAyLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0ZJQ0xPTkVfRk9SQ0U6IDQsXG4gICAgQ09QWUZJTEVfRVhDTDogMSxcbiAgICBDT1BZRklMRV9GSUNMT05FOiAyLFxuICAgIENPUFlGSUxFX0ZJQ0xPTkVfRk9SQ0U6IDQsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/encoding.js":
/*!****************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/encoding.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.strToEncoding = exports.assertEncoding = exports.ENCODING_UTF8 = void 0;\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/buffer.js\");\nconst errors = __webpack_require__(/*! ./internal/errors */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/errors.js\");\nexports.ENCODING_UTF8 = \"utf8\";\nfunction assertEncoding(encoding) {\n    if (encoding && !buffer_1.Buffer.isEncoding(encoding))\n        throw new errors.TypeError(\"ERR_INVALID_OPT_VALUE_ENCODING\", encoding);\n}\nexports.assertEncoding = assertEncoding;\nfunction strToEncoding(str, encoding) {\n    if (!encoding || encoding === exports.ENCODING_UTF8)\n        return str; // UTF-8\n    if (encoding === \"buffer\")\n        return new buffer_1.Buffer(str); // `buffer` encoding\n    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding\n}\nexports.strToEncoding = strToEncoding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUI7QUFDdEUsaUJBQWlCLG1CQUFPLENBQUMsa0dBQW1CO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDMUMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5Q0FBeUM7QUFDekMsd0RBQXdEO0FBQ3hEO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcZW5jb2RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0clRvRW5jb2RpbmcgPSBleHBvcnRzLmFzc2VydEVuY29kaW5nID0gZXhwb3J0cy5FTkNPRElOR19VVEY4ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9idWZmZXJcIik7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9lcnJvcnNcIik7XG5leHBvcnRzLkVOQ09ESU5HX1VURjggPSBcInV0ZjhcIjtcbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nICYmICFidWZmZXJfMS5CdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVHlwZUVycm9yKFwiRVJSX0lOVkFMSURfT1BUX1ZBTFVFX0VOQ09ESU5HXCIsIGVuY29kaW5nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RW5jb2RpbmcgPSBhc3NlcnRFbmNvZGluZztcbmZ1bmN0aW9uIHN0clRvRW5jb2Rpbmcoc3RyLCBlbmNvZGluZykge1xuICAgIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09IGV4cG9ydHMuRU5DT0RJTkdfVVRGOClcbiAgICAgICAgcmV0dXJuIHN0cjsgLy8gVVRGLThcbiAgICBpZiAoZW5jb2RpbmcgPT09IFwiYnVmZmVyXCIpXG4gICAgICAgIHJldHVybiBuZXcgYnVmZmVyXzEuQnVmZmVyKHN0cik7IC8vIGBidWZmZXJgIGVuY29kaW5nXG4gICAgcmV0dXJuIG5ldyBidWZmZXJfMS5CdWZmZXIoc3RyKS50b1N0cmluZyhlbmNvZGluZyk7IC8vIEN1c3RvbSBlbmNvZGluZ1xufVxuZXhwb3J0cy5zdHJUb0VuY29kaW5nID0gc3RyVG9FbmNvZGluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/encoding.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/getBigInt.js":
/*!*****************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/getBigInt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("if (typeof BigInt === \"function\") exports[\"default\"] = BigInt;\nelse\n  exports[\"default\"] = function BigIntNotSupported() {\n    throw new Error(\"BigInt is not supported in this environment.\");\n  };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9nZXRCaWdJbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0NBQWtDLGtCQUFlO0FBQ2pEO0FBQ0EsRUFBRSxrQkFBZTtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcZ2V0QmlnSW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIpIGV4cG9ydHMuZGVmYXVsdCA9IEJpZ0ludDtcbmVsc2VcbiAgZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gQmlnSW50Tm90U3VwcG9ydGVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXCIpO1xuICB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/getBigInt.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/index.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fs = exports.createFsFromVolume = exports.vol = exports.Volume = void 0;\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Stats.js\");\nconst Dirent_1 = __webpack_require__(/*! ./Dirent */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Dirent.js\");\nconst volume_1 = __webpack_require__(/*! ./volume */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/volume.js\");\nconst { fsSyncMethods, fsAsyncMethods } = __webpack_require__(/*! fs-monkey/lib/util/lists */ \"(pages-dir-browser)/./node_modules/fs-monkey/lib/util/lists.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\");\nconst { F_OK, R_OK, W_OK, X_OK } = constants_1.constants;\nexports.Volume = volume_1.Volume;\n// Default volume.\nexports.vol = new volume_1.Volume();\nfunction createFsFromVolume(vol) {\n    const fs = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };\n    // Bind FS methods.\n    for (const method of fsSyncMethods)\n        if (typeof vol[method] === \"function\")\n            fs[method] = vol[method].bind(vol);\n    for (const method of fsAsyncMethods)\n        if (typeof vol[method] === \"function\")\n            fs[method] = vol[method].bind(vol);\n    fs.StatWatcher = vol.StatWatcher;\n    fs.FSWatcher = vol.FSWatcher;\n    fs.WriteStream = vol.WriteStream;\n    fs.ReadStream = vol.ReadStream;\n    fs.promises = vol.promises;\n    fs._toUnixTimestamp = volume_1.toUnixTimestamp;\n    return fs;\n}\nexports.createFsFromVolume = createFsFromVolume;\nexports.fs = createFsFromVolume(exports.vol);\nmodule.exports = { ...module.exports, ...exports.fs };\nmodule.exports.semantic = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxVQUFVLEdBQUcsMEJBQTBCLEdBQUcsV0FBVyxHQUFHLGNBQWM7QUFDdEUsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMsUUFBUSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLGdHQUEwQjtBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN6QyxRQUFRLHlCQUF5QjtBQUNqQyxjQUFjO0FBQ2Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFVBQVU7QUFDVixtQkFBbUI7QUFDbkIsdUJBQXVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZzID0gZXhwb3J0cy5jcmVhdGVGc0Zyb21Wb2x1bWUgPSBleHBvcnRzLnZvbCA9IGV4cG9ydHMuVm9sdW1lID0gdm9pZCAwO1xuY29uc3QgU3RhdHNfMSA9IHJlcXVpcmUoXCIuL1N0YXRzXCIpO1xuY29uc3QgRGlyZW50XzEgPSByZXF1aXJlKFwiLi9EaXJlbnRcIik7XG5jb25zdCB2b2x1bWVfMSA9IHJlcXVpcmUoXCIuL3ZvbHVtZVwiKTtcbmNvbnN0IHsgZnNTeW5jTWV0aG9kcywgZnNBc3luY01ldGhvZHMgfSA9IHJlcXVpcmUoXCJmcy1tb25rZXkvbGliL3V0aWwvbGlzdHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHsgRl9PSywgUl9PSywgV19PSywgWF9PSyB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuZXhwb3J0cy5Wb2x1bWUgPSB2b2x1bWVfMS5Wb2x1bWU7XG4vLyBEZWZhdWx0IHZvbHVtZS5cbmV4cG9ydHMudm9sID0gbmV3IHZvbHVtZV8xLlZvbHVtZSgpO1xuZnVuY3Rpb24gY3JlYXRlRnNGcm9tVm9sdW1lKHZvbCkge1xuICAgIGNvbnN0IGZzID0geyBGX09LLCBSX09LLCBXX09LLCBYX09LLCBjb25zdGFudHM6IGNvbnN0YW50c18xLmNvbnN0YW50cywgU3RhdHM6IFN0YXRzXzEuZGVmYXVsdCwgRGlyZW50OiBEaXJlbnRfMS5kZWZhdWx0IH07XG4gICAgLy8gQmluZCBGUyBtZXRob2RzLlxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGZzU3luY01ldGhvZHMpXG4gICAgICAgIGlmICh0eXBlb2Ygdm9sW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGZzW21ldGhvZF0gPSB2b2xbbWV0aG9kXS5iaW5kKHZvbCk7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgZnNBc3luY01ldGhvZHMpXG4gICAgICAgIGlmICh0eXBlb2Ygdm9sW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGZzW21ldGhvZF0gPSB2b2xbbWV0aG9kXS5iaW5kKHZvbCk7XG4gICAgZnMuU3RhdFdhdGNoZXIgPSB2b2wuU3RhdFdhdGNoZXI7XG4gICAgZnMuRlNXYXRjaGVyID0gdm9sLkZTV2F0Y2hlcjtcbiAgICBmcy5Xcml0ZVN0cmVhbSA9IHZvbC5Xcml0ZVN0cmVhbTtcbiAgICBmcy5SZWFkU3RyZWFtID0gdm9sLlJlYWRTdHJlYW07XG4gICAgZnMucHJvbWlzZXMgPSB2b2wucHJvbWlzZXM7XG4gICAgZnMuX3RvVW5peFRpbWVzdGFtcCA9IHZvbHVtZV8xLnRvVW5peFRpbWVzdGFtcDtcbiAgICByZXR1cm4gZnM7XG59XG5leHBvcnRzLmNyZWF0ZUZzRnJvbVZvbHVtZSA9IGNyZWF0ZUZzRnJvbVZvbHVtZTtcbmV4cG9ydHMuZnMgPSBjcmVhdGVGc0Zyb21Wb2x1bWUoZXhwb3J0cy52b2wpO1xubW9kdWxlLmV4cG9ydHMgPSB7IC4uLm1vZHVsZS5leHBvcnRzLCAuLi5leHBvcnRzLmZzIH07XG5tb2R1bGUuZXhwb3J0cy5zZW1hbnRpYyA9IHRydWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/internal/buffer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\");\nObject.defineProperty(exports, \"Buffer\", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));\nfunction bufferV0P12Ponyfill(arg0, ...args) {\n    return new buffer_1.Buffer(arg0, ...args);\n}\nconst bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;\nexports.bufferAllocUnsafe = bufferAllocUnsafe;\nconst bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;\nexports.bufferFrom = bufferFrom;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9pbnRlcm5hbC9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcsY0FBYztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBUTtBQUNqQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAY293YXNtXFxtZW1mc1xcbGliXFxpbnRlcm5hbFxcYnVmZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZmZXJGcm9tID0gZXhwb3J0cy5idWZmZXJBbGxvY1Vuc2FmZSA9IGV4cG9ydHMuQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfMS5CdWZmZXI7IH0gfSk7XG5mdW5jdGlvbiBidWZmZXJWMFAxMlBvbnlmaWxsKGFyZzAsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihhcmcwLCAuLi5hcmdzKTtcbn1cbmNvbnN0IGJ1ZmZlckFsbG9jVW5zYWZlID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jVW5zYWZlIHx8IGJ1ZmZlclYwUDEyUG9ueWZpbGw7XG5leHBvcnRzLmJ1ZmZlckFsbG9jVW5zYWZlID0gYnVmZmVyQWxsb2NVbnNhZmU7XG5jb25zdCBidWZmZXJGcm9tID0gYnVmZmVyXzEuQnVmZmVyLmZyb20gfHwgYnVmZmVyVjBQMTJQb255ZmlsbDtcbmV4cG9ydHMuYnVmZmVyRnJvbSA9IGJ1ZmZlckZyb207XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/buffer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/errors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/internal/errors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.E = exports.AssertionError = exports.message = exports.RangeError = exports.TypeError = exports.Error = void 0;\nconst assert = __webpack_require__(/*! assert */ \"(pages-dir-browser)/./node_modules/assert/assert.js\");\nconst util = __webpack_require__(/*! util */ \"(pages-dir-browser)/./node_modules/util/util.js\");\nconst kCode = typeof Symbol === \"undefined\" ? \"_kCode\" : Symbol(\"code\");\nconst messages = {}; // new Map();\nfunction makeNodeError(Base) {\n    return class NodeError extends Base {\n        constructor(key, ...args) {\n            super(message(key, args));\n            this.code = key;\n            this[kCode] = key;\n            this.name = `${super.name} [${this[kCode]}]`;\n        }\n    };\n}\nconst g = typeof globalThis !== \"undefined\" ? globalThis : __webpack_require__.g;\nclass AssertionError extends g.Error {\n    constructor(options) {\n        if (typeof options !== \"object\" || options === null) {\n            throw new exports.TypeError(\"ERR_INVALID_ARG_TYPE\", \"options\", \"object\");\n        }\n        if (options.message) {\n            super(options.message);\n        }\n        else {\n            super(`${util.inspect(options.actual).slice(0, 128)} ` +\n                `${options.operator} ${util.inspect(options.expected).slice(0, 128)}`);\n        }\n        this.generatedMessage = !options.message;\n        this.name = \"AssertionError [ERR_ASSERTION]\";\n        this.code = \"ERR_ASSERTION\";\n        this.actual = options.actual;\n        this.expected = options.expected;\n        this.operator = options.operator;\n        exports.Error.captureStackTrace(this, options.stackStartFunction);\n    }\n}\nexports.AssertionError = AssertionError;\nfunction message(key, args) {\n    assert.strictEqual(typeof key, \"string\");\n    // const msg = messages.get(key);\n    const msg = messages[key];\n    assert(msg, `An invalid error message key was used: ${key}.`);\n    let fmt;\n    if (typeof msg === \"function\") {\n        fmt = msg;\n    }\n    else {\n        fmt = util.format;\n        if (args === undefined || args.length === 0)\n            return msg;\n        args.unshift(msg);\n    }\n    return String(fmt.apply(null, args));\n}\nexports.message = message;\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val) {\n    messages[sym] = typeof val === \"function\" ? val : String(val);\n}\nexports.E = E;\nexports.Error = makeNodeError(g.Error);\nexports.TypeError = makeNodeError(g.TypeError);\nexports.RangeError = makeNodeError(g.RangeError);\n// To declare an error message, use the E(sym, val) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value');\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\nE(\"ERR_ARG_NOT_ITERABLE\", \"%s must be iterable\");\nE(\"ERR_ASSERTION\", \"%s\");\nE(\"ERR_BUFFER_OUT_OF_BOUNDS\", bufferOutOfBounds);\nE(\"ERR_CHILD_CLOSED_BEFORE_REPLY\", \"Child closed before reply received\");\nE(\"ERR_CONSOLE_WRITABLE_STREAM\", \"Console expects a writable stream instance for %s\");\nE(\"ERR_CPU_USAGE\", \"Unable to obtain cpu usage %s\");\nE(\"ERR_DNS_SET_SERVERS_FAILED\", (err, servers) => `c-ares failed to set servers: \"${err}\" [${servers}]`);\nE(\"ERR_FALSY_VALUE_REJECTION\", \"Promise was rejected with falsy value\");\nE(\"ERR_ENCODING_NOT_SUPPORTED\", (enc) => `The \"${enc}\" encoding is not supported`);\nE(\"ERR_ENCODING_INVALID_ENCODED_DATA\", (enc) => `The encoded data was not valid for encoding ${enc}`);\nE(\"ERR_HTTP_HEADERS_SENT\", \"Cannot render headers after they are sent to the client\");\nE(\"ERR_HTTP_INVALID_STATUS_CODE\", \"Invalid status code: %s\");\nE(\"ERR_HTTP_TRAILER_INVALID\", \"Trailers are invalid with this transfer encoding\");\nE(\"ERR_INDEX_OUT_OF_RANGE\", \"Index out of range\");\nE(\"ERR_INVALID_ARG_TYPE\", invalidArgType);\nE(\"ERR_INVALID_ARRAY_LENGTH\", (name, len, actual) => {\n    assert.strictEqual(typeof actual, \"number\");\n    return `The array \"${name}\" (length ${actual}) must be of length ${len}.`;\n});\nE(\"ERR_INVALID_BUFFER_SIZE\", \"Buffer size must be a multiple of %s\");\nE(\"ERR_INVALID_CALLBACK\", \"Callback must be a function\");\nE(\"ERR_INVALID_CHAR\", \"Invalid character in %s\");\nE(\"ERR_INVALID_CURSOR_POS\", \"Cannot set cursor row without setting its column\");\nE(\"ERR_INVALID_FD\", '\"fd\" must be a positive integer: %s');\nE(\"ERR_INVALID_FILE_URL_HOST\", 'File URL host must be \"localhost\" or empty on %s');\nE(\"ERR_INVALID_FILE_URL_PATH\", \"File URL path %s\");\nE(\"ERR_INVALID_HANDLE_TYPE\", \"This handle type cannot be sent\");\nE(\"ERR_INVALID_IP_ADDRESS\", \"Invalid IP address: %s\");\nE(\"ERR_INVALID_OPT_VALUE\", (name, value) => {\n    return `The value \"${String(value)}\" is invalid for option \"${name}\"`;\n});\nE(\"ERR_INVALID_OPT_VALUE_ENCODING\", (value) => `The value \"${String(value)}\" is invalid for option \"encoding\"`);\nE(\"ERR_INVALID_REPL_EVAL_CONFIG\", 'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL');\nE(\"ERR_INVALID_SYNC_FORK_INPUT\", \"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\");\nE(\"ERR_INVALID_THIS\", 'Value of \"this\" must be of type %s');\nE(\"ERR_INVALID_TUPLE\", \"%s must be an iterable %s tuple\");\nE(\"ERR_INVALID_URL\", \"Invalid URL: %s\");\nE(\"ERR_INVALID_URL_SCHEME\", (expected) => `The URL must be ${oneOf(expected, \"scheme\")}`);\nE(\"ERR_IPC_CHANNEL_CLOSED\", \"Channel closed\");\nE(\"ERR_IPC_DISCONNECTED\", \"IPC channel is already disconnected\");\nE(\"ERR_IPC_ONE_PIPE\", \"Child process can have only one IPC pipe\");\nE(\"ERR_IPC_SYNC_FORK\", \"IPC cannot be used with synchronous forks\");\nE(\"ERR_MISSING_ARGS\", missingArgs);\nE(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\");\nE(\"ERR_NAPI_CONS_FUNCTION\", \"Constructor must be a function\");\nE(\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\", \"Constructor.prototype must be an object\");\nE(\"ERR_NO_CRYPTO\", \"Node.js is not compiled with OpenSSL crypto support\");\nE(\"ERR_NO_LONGER_SUPPORTED\", \"%s is no longer supported\");\nE(\"ERR_PARSE_HISTORY_DATA\", \"Could not parse history data in %s\");\nE(\"ERR_SOCKET_ALREADY_BOUND\", \"Socket is already bound\");\nE(\"ERR_SOCKET_BAD_PORT\", \"Port should be > 0 and < 65536\");\nE(\"ERR_SOCKET_BAD_TYPE\", \"Bad socket type specified. Valid types are: udp4, udp6\");\nE(\"ERR_SOCKET_CANNOT_SEND\", \"Unable to send data\");\nE(\"ERR_SOCKET_CLOSED\", \"Socket is closed\");\nE(\"ERR_SOCKET_DGRAM_NOT_RUNNING\", \"Not running\");\nE(\"ERR_STDERR_CLOSE\", \"process.stderr cannot be closed\");\nE(\"ERR_STDOUT_CLOSE\", \"process.stdout cannot be closed\");\nE(\"ERR_STREAM_WRAP\", \"Stream has StringDecoder set or is in objectMode\");\nE(\"ERR_TLS_CERT_ALTNAME_INVALID\", \"Hostname/IP does not match certificate's altnames: %s\");\nE(\"ERR_TLS_DH_PARAM_SIZE\", (size) => `DH parameter size ${size} is less than 2048`);\nE(\"ERR_TLS_HANDSHAKE_TIMEOUT\", \"TLS handshake timeout\");\nE(\"ERR_TLS_RENEGOTIATION_FAILED\", \"Failed to renegotiate\");\nE(\"ERR_TLS_REQUIRED_SERVER_NAME\", '\"servername\" is required parameter for Server.addContext');\nE(\"ERR_TLS_SESSION_ATTACK\", \"TSL session renegotiation attack detected\");\nE(\"ERR_TRANSFORM_ALREADY_TRANSFORMING\", \"Calling transform done when still transforming\");\nE(\"ERR_TRANSFORM_WITH_LENGTH_0\", \"Calling transform done when writableState.length != 0\");\nE(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\");\nE(\"ERR_UNKNOWN_SIGNAL\", \"Unknown signal: %s\");\nE(\"ERR_UNKNOWN_STDIN_TYPE\", \"Unknown stdin file type\");\nE(\"ERR_UNKNOWN_STREAM_TYPE\", \"Unknown stream file type\");\nE(\"ERR_V8BREAKITERATOR\", \"Full ICU data not installed. \" +\n    \"See https://github.com/nodejs/node/wiki/Intl\");\nfunction invalidArgType(name, expected, actual) {\n    assert(name, \"name is required\");\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (expected.includes(\"not \")) {\n        determiner = \"must not be\";\n        expected = expected.split(\"not \")[1];\n    }\n    else {\n        determiner = \"must be\";\n    }\n    let msg;\n    if (Array.isArray(name)) {\n        const names = name.map((val) => `\"${val}\"`).join(\", \");\n        msg = `The ${names} arguments ${determiner} ${oneOf(expected, \"type\")}`;\n    }\n    else if (name.includes(\" argument\")) {\n        // for the case like 'first argument'\n        msg = `The ${name} ${determiner} ${oneOf(expected, \"type\")}`;\n    }\n    else {\n        const type = name.includes(\".\") ? \"property\" : \"argument\";\n        msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, \"type\")}`;\n    }\n    // if actual value received, output it\n    if (arguments.length >= 3) {\n        msg += `. Received type ${actual !== null ? typeof actual : \"null\"}`;\n    }\n    return msg;\n}\nfunction missingArgs(...args) {\n    assert(args.length > 0, \"At least one arg needs to be specified\");\n    let msg = \"The \";\n    const len = args.length;\n    args = args.map((a) => `\"${a}\"`);\n    switch (len) {\n        case 1:\n            msg += `${args[0]} argument`;\n            break;\n        case 2:\n            msg += `${args[0]} and ${args[1]} arguments`;\n            break;\n        default:\n            msg += args.slice(0, len - 1).join(\", \");\n            msg += `, and ${args[len - 1]} arguments`;\n            break;\n    }\n    return `${msg} must be specified`;\n}\nfunction oneOf(expected, thing) {\n    assert(expected, \"expected is required\");\n    assert(typeof thing === \"string\", \"thing is required\");\n    if (Array.isArray(expected)) {\n        const len = expected.length;\n        assert(len > 0, \"At least one expected value needs to be specified\");\n        // tslint:disable-next-line\n        expected = expected.map((i) => String(i));\n        if (len > 2) {\n            return (`one of ${thing} ${expected.slice(0, len - 1).join(\", \")}, or ` +\n                expected[len - 1]);\n        }\n        else if (len === 2) {\n            return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n        }\n        else {\n            return `of ${thing} ${expected[0]}`;\n        }\n    }\n    else {\n        return `of ${thing} ${String(expected)}`;\n    }\n}\nfunction bufferOutOfBounds(name, isWriting) {\n    if (isWriting) {\n        return \"Attempt to write outside buffer bounds\";\n    }\n    else {\n        return `\"${name}\" is outside of buffer bounds`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9pbnRlcm5hbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsR0FBRyxzQkFBc0IsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsYUFBYTtBQUM3RyxlQUFlLG1CQUFPLENBQUMsbUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLDZEQUFNO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZLEdBQUcsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QztBQUNqRSxtQkFBbUIsa0JBQWtCLEVBQUUsNkNBQTZDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELElBQUk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHLEVBQUUsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixJQUFJLEtBQUssUUFBUTtBQUNyRztBQUNBLGlEQUFpRCxJQUFJO0FBQ3JELCtGQUErRixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssWUFBWSxPQUFPLHNCQUFzQixJQUFJO0FBQzNFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjLDJCQUEyQixLQUFLO0FBQ3ZFLENBQUM7QUFDRCw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELHFCQUFxQixPQUFPLFlBQVksWUFBWSxFQUFFLHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTSxFQUFFLFlBQVksRUFBRSx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUssSUFBSSxNQUFNLEVBQUUsWUFBWSxFQUFFLHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxNQUFNLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPLEVBQUUsc0NBQXNDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLEVBQUUsYUFBYSxLQUFLLFlBQVk7QUFDcEU7QUFDQTtBQUNBLHlCQUF5QixPQUFPLEVBQUUsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxFQUFFLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAY293YXNtXFxtZW1mc1xcbGliXFxpbnRlcm5hbFxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRSA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBleHBvcnRzLm1lc3NhZ2UgPSBleHBvcnRzLlJhbmdlRXJyb3IgPSBleHBvcnRzLlR5cGVFcnJvciA9IGV4cG9ydHMuRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3Qga0NvZGUgPSB0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiID8gXCJfa0NvZGVcIiA6IFN5bWJvbChcImNvZGVcIik7XG5jb25zdCBtZXNzYWdlcyA9IHt9OyAvLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBtYWtlTm9kZUVycm9yKEJhc2UpIHtcbiAgICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGtleSwgLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZShrZXksIGFyZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGtleTtcbiAgICAgICAgICAgIHRoaXNba0NvZGVdID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7c3VwZXIubmFtZX0gWyR7dGhpc1trQ29kZV19XWA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbDtcbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgZy5FcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVHlwZUVycm9yKFwiRVJSX0lOVkFMSURfQVJHX1RZUEVcIiwgXCJvcHRpb25zXCIsIFwib2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihgJHt1dGlsLmluc3BlY3Qob3B0aW9ucy5hY3R1YWwpLnNsaWNlKDAsIDEyOCl9IGAgK1xuICAgICAgICAgICAgICAgIGAke29wdGlvbnMub3BlcmF0b3J9ICR7dXRpbC5pbnNwZWN0KG9wdGlvbnMuZXhwZWN0ZWQpLnNsaWNlKDAsIDEyOCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl1cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFUlJfQVNTRVJUSU9OXCI7XG4gICAgICAgIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgICAgICAgZXhwb3J0cy5FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuZnVuY3Rpb24gbWVzc2FnZShrZXksIGFyZ3MpIHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGtleSwgXCJzdHJpbmdcIik7XG4gICAgLy8gY29uc3QgbXNnID0gbWVzc2FnZXMuZ2V0KGtleSk7XG4gICAgY29uc3QgbXNnID0gbWVzc2FnZXNba2V5XTtcbiAgICBhc3NlcnQobXNnLCBgQW4gaW52YWxpZCBlcnJvciBtZXNzYWdlIGtleSB3YXMgdXNlZDogJHtrZXl9LmApO1xuICAgIGxldCBmbXQ7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmbXQgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbXQgPSB1dGlsLmZvcm1hdDtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIGFyZ3MudW5zaGlmdChtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGZtdC5hcHBseShudWxsLCBhcmdzKSk7XG59XG5leHBvcnRzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLiBPbmx5IHVzZWQgaGVyZS4gRXhwb3J0ZWRcbi8vICpvbmx5KiB0byBhbGxvdyBmb3IgdGVzdGluZy5cbmZ1bmN0aW9uIEUoc3ltLCB2YWwpIHtcbiAgICBtZXNzYWdlc1tzeW1dID0gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogU3RyaW5nKHZhbCk7XG59XG5leHBvcnRzLkUgPSBFO1xuZXhwb3J0cy5FcnJvciA9IG1ha2VOb2RlRXJyb3IoZy5FcnJvcik7XG5leHBvcnRzLlR5cGVFcnJvciA9IG1ha2VOb2RlRXJyb3IoZy5UeXBlRXJyb3IpO1xuZXhwb3J0cy5SYW5nZUVycm9yID0gbWFrZU5vZGVFcnJvcihnLlJhbmdlRXJyb3IpO1xuLy8gVG8gZGVjbGFyZSBhbiBlcnJvciBtZXNzYWdlLCB1c2UgdGhlIEUoc3ltLCB2YWwpIGZ1bmN0aW9uIGFib3ZlLiBUaGUgc3ltXG4vLyBtdXN0IGJlIGFuIHVwcGVyIGNhc2Ugc3RyaW5nLiBUaGUgdmFsIGNhbiBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhIHN0cmluZy5cbi8vIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIG11c3QgYmUgYSBzdHJpbmcuXG4vLyBFeGFtcGxlczpcbi8vIEUoJ0VYQU1QTEVfS0VZMScsICdUaGlzIGlzIHRoZSBlcnJvciB2YWx1ZScpO1xuLy8gRSgnRVhBTVBMRV9LRVkyJywgKGEsIGIpID0+IHJldHVybiBgJHthfSAke2J9YCk7XG4vL1xuLy8gT25jZSBhbiBlcnJvciBjb2RlIGhhcyBiZWVuIGFzc2lnbmVkLCB0aGUgY29kZSBpdHNlbGYgTVVTVCBOT1QgY2hhbmdlIGFuZFxuLy8gYW55IGdpdmVuIGVycm9yIGNvZGUgbXVzdCBuZXZlciBiZSByZXVzZWQgdG8gaWRlbnRpZnkgYSBkaWZmZXJlbnQgZXJyb3IuXG4vL1xuLy8gQW55IGVycm9yIGNvZGUgYWRkZWQgaGVyZSBzaG91bGQgYWxzbyBiZSBhZGRlZCB0byB0aGUgZG9jdW1lbnRhdGlvblxuLy9cbi8vIE5vdGU6IFBsZWFzZSB0cnkgdG8ga2VlcCB0aGVzZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbkUoXCJFUlJfQVJHX05PVF9JVEVSQUJMRVwiLCBcIiVzIG11c3QgYmUgaXRlcmFibGVcIik7XG5FKFwiRVJSX0FTU0VSVElPTlwiLCBcIiVzXCIpO1xuRShcIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EU1wiLCBidWZmZXJPdXRPZkJvdW5kcyk7XG5FKFwiRVJSX0NISUxEX0NMT1NFRF9CRUZPUkVfUkVQTFlcIiwgXCJDaGlsZCBjbG9zZWQgYmVmb3JlIHJlcGx5IHJlY2VpdmVkXCIpO1xuRShcIkVSUl9DT05TT0xFX1dSSVRBQkxFX1NUUkVBTVwiLCBcIkNvbnNvbGUgZXhwZWN0cyBhIHdyaXRhYmxlIHN0cmVhbSBpbnN0YW5jZSBmb3IgJXNcIik7XG5FKFwiRVJSX0NQVV9VU0FHRVwiLCBcIlVuYWJsZSB0byBvYnRhaW4gY3B1IHVzYWdlICVzXCIpO1xuRShcIkVSUl9ETlNfU0VUX1NFUlZFUlNfRkFJTEVEXCIsIChlcnIsIHNlcnZlcnMpID0+IGBjLWFyZXMgZmFpbGVkIHRvIHNldCBzZXJ2ZXJzOiBcIiR7ZXJyfVwiIFske3NlcnZlcnN9XWApO1xuRShcIkVSUl9GQUxTWV9WQUxVRV9SRUpFQ1RJT05cIiwgXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlXCIpO1xuRShcIkVSUl9FTkNPRElOR19OT1RfU1VQUE9SVEVEXCIsIChlbmMpID0+IGBUaGUgXCIke2VuY31cIiBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkYCk7XG5FKFwiRVJSX0VOQ09ESU5HX0lOVkFMSURfRU5DT0RFRF9EQVRBXCIsIChlbmMpID0+IGBUaGUgZW5jb2RlZCBkYXRhIHdhcyBub3QgdmFsaWQgZm9yIGVuY29kaW5nICR7ZW5jfWApO1xuRShcIkVSUl9IVFRQX0hFQURFUlNfU0VOVFwiLCBcIkNhbm5vdCByZW5kZXIgaGVhZGVycyBhZnRlciB0aGV5IGFyZSBzZW50IHRvIHRoZSBjbGllbnRcIik7XG5FKFwiRVJSX0hUVFBfSU5WQUxJRF9TVEFUVVNfQ09ERVwiLCBcIkludmFsaWQgc3RhdHVzIGNvZGU6ICVzXCIpO1xuRShcIkVSUl9IVFRQX1RSQUlMRVJfSU5WQUxJRFwiLCBcIlRyYWlsZXJzIGFyZSBpbnZhbGlkIHdpdGggdGhpcyB0cmFuc2ZlciBlbmNvZGluZ1wiKTtcbkUoXCJFUlJfSU5ERVhfT1VUX09GX1JBTkdFXCIsIFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuRShcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsIGludmFsaWRBcmdUeXBlKTtcbkUoXCJFUlJfSU5WQUxJRF9BUlJBWV9MRU5HVEhcIiwgKG5hbWUsIGxlbiwgYWN0dWFsKSA9PiB7XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBhY3R1YWwsIFwibnVtYmVyXCIpO1xuICAgIHJldHVybiBgVGhlIGFycmF5IFwiJHtuYW1lfVwiIChsZW5ndGggJHthY3R1YWx9KSBtdXN0IGJlIG9mIGxlbmd0aCAke2xlbn0uYDtcbn0pO1xuRShcIkVSUl9JTlZBTElEX0JVRkZFUl9TSVpFXCIsIFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mICVzXCIpO1xuRShcIkVSUl9JTlZBTElEX0NBTExCQUNLXCIsIFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuRShcIkVSUl9JTlZBTElEX0NIQVJcIiwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiAlc1wiKTtcbkUoXCJFUlJfSU5WQUxJRF9DVVJTT1JfUE9TXCIsIFwiQ2Fubm90IHNldCBjdXJzb3Igcm93IHdpdGhvdXQgc2V0dGluZyBpdHMgY29sdW1uXCIpO1xuRShcIkVSUl9JTlZBTElEX0ZEXCIsICdcImZkXCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICVzJyk7XG5FKFwiRVJSX0lOVkFMSURfRklMRV9VUkxfSE9TVFwiLCAnRmlsZSBVUkwgaG9zdCBtdXN0IGJlIFwibG9jYWxob3N0XCIgb3IgZW1wdHkgb24gJXMnKTtcbkUoXCJFUlJfSU5WQUxJRF9GSUxFX1VSTF9QQVRIXCIsIFwiRmlsZSBVUkwgcGF0aCAlc1wiKTtcbkUoXCJFUlJfSU5WQUxJRF9IQU5ETEVfVFlQRVwiLCBcIlRoaXMgaGFuZGxlIHR5cGUgY2Fubm90IGJlIHNlbnRcIik7XG5FKFwiRVJSX0lOVkFMSURfSVBfQUREUkVTU1wiLCBcIkludmFsaWQgSVAgYWRkcmVzczogJXNcIik7XG5FKFwiRVJSX0lOVkFMSURfT1BUX1ZBTFVFXCIsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBgVGhlIHZhbHVlIFwiJHtTdHJpbmcodmFsdWUpfVwiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIiR7bmFtZX1cImA7XG59KTtcbkUoXCJFUlJfSU5WQUxJRF9PUFRfVkFMVUVfRU5DT0RJTkdcIiwgKHZhbHVlKSA9PiBgVGhlIHZhbHVlIFwiJHtTdHJpbmcodmFsdWUpfVwiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcImVuY29kaW5nXCJgKTtcbkUoXCJFUlJfSU5WQUxJRF9SRVBMX0VWQUxfQ09ORklHXCIsICdDYW5ub3Qgc3BlY2lmeSBib3RoIFwiYnJlYWtFdmFsT25TaWdpbnRcIiBhbmQgXCJldmFsXCIgZm9yIFJFUEwnKTtcbkUoXCJFUlJfSU5WQUxJRF9TWU5DX0ZPUktfSU5QVVRcIiwgXCJBc3luY2hyb25vdXMgZm9ya3MgZG8gbm90IHN1cHBvcnQgQnVmZmVyLCBVaW50OEFycmF5IG9yIHN0cmluZyBpbnB1dDogJXNcIik7XG5FKFwiRVJSX0lOVkFMSURfVEhJU1wiLCAnVmFsdWUgb2YgXCJ0aGlzXCIgbXVzdCBiZSBvZiB0eXBlICVzJyk7XG5FKFwiRVJSX0lOVkFMSURfVFVQTEVcIiwgXCIlcyBtdXN0IGJlIGFuIGl0ZXJhYmxlICVzIHR1cGxlXCIpO1xuRShcIkVSUl9JTlZBTElEX1VSTFwiLCBcIkludmFsaWQgVVJMOiAlc1wiKTtcbkUoXCJFUlJfSU5WQUxJRF9VUkxfU0NIRU1FXCIsIChleHBlY3RlZCkgPT4gYFRoZSBVUkwgbXVzdCBiZSAke29uZU9mKGV4cGVjdGVkLCBcInNjaGVtZVwiKX1gKTtcbkUoXCJFUlJfSVBDX0NIQU5ORUxfQ0xPU0VEXCIsIFwiQ2hhbm5lbCBjbG9zZWRcIik7XG5FKFwiRVJSX0lQQ19ESVNDT05ORUNURURcIiwgXCJJUEMgY2hhbm5lbCBpcyBhbHJlYWR5IGRpc2Nvbm5lY3RlZFwiKTtcbkUoXCJFUlJfSVBDX09ORV9QSVBFXCIsIFwiQ2hpbGQgcHJvY2VzcyBjYW4gaGF2ZSBvbmx5IG9uZSBJUEMgcGlwZVwiKTtcbkUoXCJFUlJfSVBDX1NZTkNfRk9SS1wiLCBcIklQQyBjYW5ub3QgYmUgdXNlZCB3aXRoIHN5bmNocm9ub3VzIGZvcmtzXCIpO1xuRShcIkVSUl9NSVNTSU5HX0FSR1NcIiwgbWlzc2luZ0FyZ3MpO1xuRShcIkVSUl9NVUxUSVBMRV9DQUxMQkFDS1wiLCBcIkNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1wiKTtcbkUoXCJFUlJfTkFQSV9DT05TX0ZVTkNUSU9OXCIsIFwiQ29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuRShcIkVSUl9OQVBJX0NPTlNfUFJPVE9UWVBFX09CSkVDVFwiLCBcIkNvbnN0cnVjdG9yLnByb3RvdHlwZSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbkUoXCJFUlJfTk9fQ1JZUFRPXCIsIFwiTm9kZS5qcyBpcyBub3QgY29tcGlsZWQgd2l0aCBPcGVuU1NMIGNyeXB0byBzdXBwb3J0XCIpO1xuRShcIkVSUl9OT19MT05HRVJfU1VQUE9SVEVEXCIsIFwiJXMgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbkUoXCJFUlJfUEFSU0VfSElTVE9SWV9EQVRBXCIsIFwiQ291bGQgbm90IHBhcnNlIGhpc3RvcnkgZGF0YSBpbiAlc1wiKTtcbkUoXCJFUlJfU09DS0VUX0FMUkVBRFlfQk9VTkRcIiwgXCJTb2NrZXQgaXMgYWxyZWFkeSBib3VuZFwiKTtcbkUoXCJFUlJfU09DS0VUX0JBRF9QT1JUXCIsIFwiUG9ydCBzaG91bGQgYmUgPiAwIGFuZCA8IDY1NTM2XCIpO1xuRShcIkVSUl9TT0NLRVRfQkFEX1RZUEVcIiwgXCJCYWQgc29ja2V0IHR5cGUgc3BlY2lmaWVkLiBWYWxpZCB0eXBlcyBhcmU6IHVkcDQsIHVkcDZcIik7XG5FKFwiRVJSX1NPQ0tFVF9DQU5OT1RfU0VORFwiLCBcIlVuYWJsZSB0byBzZW5kIGRhdGFcIik7XG5FKFwiRVJSX1NPQ0tFVF9DTE9TRURcIiwgXCJTb2NrZXQgaXMgY2xvc2VkXCIpO1xuRShcIkVSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkdcIiwgXCJOb3QgcnVubmluZ1wiKTtcbkUoXCJFUlJfU1RERVJSX0NMT1NFXCIsIFwicHJvY2Vzcy5zdGRlcnIgY2Fubm90IGJlIGNsb3NlZFwiKTtcbkUoXCJFUlJfU1RET1VUX0NMT1NFXCIsIFwicHJvY2Vzcy5zdGRvdXQgY2Fubm90IGJlIGNsb3NlZFwiKTtcbkUoXCJFUlJfU1RSRUFNX1dSQVBcIiwgXCJTdHJlYW0gaGFzIFN0cmluZ0RlY29kZXIgc2V0IG9yIGlzIGluIG9iamVjdE1vZGVcIik7XG5FKFwiRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRFwiLCBcIkhvc3RuYW1lL0lQIGRvZXMgbm90IG1hdGNoIGNlcnRpZmljYXRlJ3MgYWx0bmFtZXM6ICVzXCIpO1xuRShcIkVSUl9UTFNfREhfUEFSQU1fU0laRVwiLCAoc2l6ZSkgPT4gYERIIHBhcmFtZXRlciBzaXplICR7c2l6ZX0gaXMgbGVzcyB0aGFuIDIwNDhgKTtcbkUoXCJFUlJfVExTX0hBTkRTSEFLRV9USU1FT1VUXCIsIFwiVExTIGhhbmRzaGFrZSB0aW1lb3V0XCIpO1xuRShcIkVSUl9UTFNfUkVORUdPVElBVElPTl9GQUlMRURcIiwgXCJGYWlsZWQgdG8gcmVuZWdvdGlhdGVcIik7XG5FKFwiRVJSX1RMU19SRVFVSVJFRF9TRVJWRVJfTkFNRVwiLCAnXCJzZXJ2ZXJuYW1lXCIgaXMgcmVxdWlyZWQgcGFyYW1ldGVyIGZvciBTZXJ2ZXIuYWRkQ29udGV4dCcpO1xuRShcIkVSUl9UTFNfU0VTU0lPTl9BVFRBQ0tcIiwgXCJUU0wgc2Vzc2lvbiByZW5lZ290aWF0aW9uIGF0dGFjayBkZXRlY3RlZFwiKTtcbkUoXCJFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HXCIsIFwiQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZ1wiKTtcbkUoXCJFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzBcIiwgXCJDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3JpdGFibGVTdGF0ZS5sZW5ndGggIT0gMFwiKTtcbkUoXCJFUlJfVU5LTk9XTl9FTkNPRElOR1wiLCBcIlVua25vd24gZW5jb2Rpbmc6ICVzXCIpO1xuRShcIkVSUl9VTktOT1dOX1NJR05BTFwiLCBcIlVua25vd24gc2lnbmFsOiAlc1wiKTtcbkUoXCJFUlJfVU5LTk9XTl9TVERJTl9UWVBFXCIsIFwiVW5rbm93biBzdGRpbiBmaWxlIHR5cGVcIik7XG5FKFwiRVJSX1VOS05PV05fU1RSRUFNX1RZUEVcIiwgXCJVbmtub3duIHN0cmVhbSBmaWxlIHR5cGVcIik7XG5FKFwiRVJSX1Y4QlJFQUtJVEVSQVRPUlwiLCBcIkZ1bGwgSUNVIGRhdGEgbm90IGluc3RhbGxlZC4gXCIgK1xuICAgIFwiU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS93aWtpL0ludGxcIik7XG5mdW5jdGlvbiBpbnZhbGlkQXJnVHlwZShuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgYXNzZXJ0KG5hbWUsIFwibmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICAgIGxldCBkZXRlcm1pbmVyO1xuICAgIGlmIChleHBlY3RlZC5pbmNsdWRlcyhcIm5vdCBcIikpIHtcbiAgICAgICAgZGV0ZXJtaW5lciA9IFwibXVzdCBub3QgYmVcIjtcbiAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5zcGxpdChcIm5vdCBcIilbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZXRlcm1pbmVyID0gXCJtdXN0IGJlXCI7XG4gICAgfVxuICAgIGxldCBtc2c7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBuYW1lLm1hcCgodmFsKSA9PiBgXCIke3ZhbH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgbXNnID0gYFRoZSAke25hbWVzfSBhcmd1bWVudHMgJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCBcInR5cGVcIil9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmNsdWRlcyhcIiBhcmd1bWVudFwiKSkge1xuICAgICAgICAvLyBmb3IgdGhlIGNhc2UgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgICAgIG1zZyA9IGBUaGUgJHtuYW1lfSAke2RldGVybWluZXJ9ICR7b25lT2YoZXhwZWN0ZWQsIFwidHlwZVwiKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5hbWUuaW5jbHVkZXMoXCIuXCIpID8gXCJwcm9wZXJ0eVwiIDogXCJhcmd1bWVudFwiO1xuICAgICAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCBcInR5cGVcIil9YDtcbiAgICB9XG4gICAgLy8gaWYgYWN0dWFsIHZhbHVlIHJlY2VpdmVkLCBvdXRwdXQgaXRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7YWN0dWFsICE9PSBudWxsID8gdHlwZW9mIGFjdHVhbCA6IFwibnVsbFwifWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59XG5mdW5jdGlvbiBtaXNzaW5nQXJncyguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgXCJBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZFwiKTtcbiAgICBsZXQgbXNnID0gXCJUaGUgXCI7XG4gICAgY29uc3QgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgYXJncyA9IGFyZ3MubWFwKChhKSA9PiBgXCIke2F9XCJgKTtcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtc2cgKz0gYCR7YXJnc1swXX0gYXJndW1lbnRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIG1zZyArPSBgJHthcmdzWzBdfSBhbmQgJHthcmdzWzFdfSBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICBtc2cgKz0gYCwgYW5kICR7YXJnc1tsZW4gLSAxXX0gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXNnfSBtdXN0IGJlIHNwZWNpZmllZGA7XG59XG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgICBhc3NlcnQoZXhwZWN0ZWQsIFwiZXhwZWN0ZWQgaXMgcmVxdWlyZWRcIik7XG4gICAgYXNzZXJ0KHR5cGVvZiB0aGluZyA9PT0gXCJzdHJpbmdcIiwgXCJ0aGluZyBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgICAgICBhc3NlcnQobGVuID4gMCwgXCJBdCBsZWFzdCBvbmUgZXhwZWN0ZWQgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoKGkpID0+IFN0cmluZyhpKSk7XG4gICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKFwiLCBcIil9LCBvciBgICtcbiAgICAgICAgICAgICAgICBleHBlY3RlZFtsZW4gLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfSBvciAke2V4cGVjdGVkWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke1N0cmluZyhleHBlY3RlZCl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBidWZmZXJPdXRPZkJvdW5kcyhuYW1lLCBpc1dyaXRpbmcpIHtcbiAgICBpZiAoaXNXcml0aW5nKSB7XG4gICAgICAgIHJldHVybiBcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYFwiJHtuYW1lfVwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/errors.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/node.js":
/*!************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/node.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.File = exports.Link = exports.Node = exports.SEP = void 0;\nconst process_1 = __webpack_require__(/*! ./process */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/process.js\");\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/buffer.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\");\nconst events_1 = __webpack_require__(/*! events */ \"(pages-dir-browser)/./node_modules/events/events.js\");\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Stats.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, O_APPEND } = constants_1.constants;\nconst getuid = () => process_1.default.getuid?.() ?? 0;\nconst getgid = () => process_1.default.getgid?.() ?? 0;\nexports.SEP = \"/\";\n/**\n * Node in a file system (like i-node, v-node).\n */\nclass Node extends events_1.EventEmitter {\n    constructor(ino, perm = 0o666) {\n        super();\n        // User ID and group ID.\n        this.uid = getuid();\n        this.gid = getgid();\n        this.atime = new Date();\n        this.mtime = new Date();\n        this.ctime = new Date();\n        this.perm = 0o666; // Permissions `chmod`, `fchmod`\n        this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)\n        // Number of hard links pointing at this Node.\n        this.nlink = 1;\n        this.perm = perm;\n        this.mode |= perm;\n        this.ino = ino;\n    }\n    getString(encoding = \"utf8\") {\n        return this.getBuffer().toString(encoding);\n    }\n    setString(str) {\n        // this.setBuffer(bufferFrom(str, 'utf8'));\n        this.buf = (0, buffer_1.bufferFrom)(str, \"utf8\");\n        this.touch();\n    }\n    getBuffer() {\n        if (!this.buf)\n            this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));\n        return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.\n    }\n    setBuffer(buf) {\n        this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.\n        this.touch();\n    }\n    getSize() {\n        return this.buf ? this.buf.length : 0;\n    }\n    setModeProperty(property) {\n        this.mode = (this.mode & ~S_IFMT) | property;\n    }\n    setIsFile() {\n        this.setModeProperty(S_IFREG);\n    }\n    setIsDirectory() {\n        this.setModeProperty(S_IFDIR);\n    }\n    setIsSymlink() {\n        this.setModeProperty(S_IFLNK);\n    }\n    isFile() {\n        return (this.mode & S_IFMT) === S_IFREG;\n    }\n    isDirectory() {\n        return (this.mode & S_IFMT) === S_IFDIR;\n    }\n    isSymlink() {\n        // return !!this.symlink;\n        return (this.mode & S_IFMT) === S_IFLNK;\n    }\n    makeSymlink(steps) {\n        this.symlink = steps;\n        this.setIsSymlink();\n    }\n    write(buf, off = 0, len = buf.length, pos = 0) {\n        if (!this.buf)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        if (pos + len > this.buf.length) {\n            const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);\n            this.buf.copy(newBuf, 0, 0, this.buf.length);\n            this.buf = newBuf;\n        }\n        buf.copy(this.buf, pos, off, off + len);\n        this.touch();\n        return len;\n    }\n    // Returns the number of bytes read.\n    read(buf, off = 0, len = buf.byteLength, pos = 0) {\n        if (!this.buf)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        let actualLen = len;\n        if (actualLen > buf.byteLength) {\n            actualLen = buf.byteLength;\n        }\n        if (actualLen + pos > this.buf.length) {\n            actualLen = this.buf.length - pos;\n        }\n        this.buf.copy(buf, off, pos, pos + actualLen);\n        return actualLen;\n    }\n    truncate(len = 0) {\n        if (!len)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        else {\n            if (!this.buf)\n                this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n            if (len <= this.buf.length) {\n                this.buf = this.buf.slice(0, len);\n            }\n            else {\n                const buf = (0, buffer_1.bufferAllocUnsafe)(0);\n                this.buf.copy(buf);\n                buf.fill(0, len);\n            }\n        }\n        this.touch();\n    }\n    chmod(perm) {\n        this.perm = perm;\n        this.mode = (this.mode & ~0o777) | perm;\n        this.touch();\n    }\n    chown(uid, gid) {\n        this.uid = uid;\n        this.gid = gid;\n        this.touch();\n    }\n    touch() {\n        this.mtime = new Date();\n        this.emit(\"change\", this);\n    }\n    canRead(uid = getuid(), gid = getgid()) {\n        if (this.perm & 4 /* S.IROTH */) {\n            return true;\n        }\n        if (gid === this.gid) {\n            if (this.perm & 32 /* S.IRGRP */) {\n                return true;\n            }\n        }\n        if (uid === this.uid) {\n            if (this.perm & 256 /* S.IRUSR */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    canWrite(uid = getuid(), gid = getgid()) {\n        if (this.perm & 2 /* S.IWOTH */) {\n            return true;\n        }\n        if (gid === this.gid) {\n            if (this.perm & 16 /* S.IWGRP */) {\n                return true;\n            }\n        }\n        if (uid === this.uid) {\n            if (this.perm & 128 /* S.IWUSR */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    del() {\n        this.emit(\"delete\", this);\n    }\n    toJSON() {\n        return {\n            ino: this.ino,\n            uid: this.uid,\n            gid: this.gid,\n            atime: this.atime.getTime(),\n            mtime: this.mtime.getTime(),\n            ctime: this.ctime.getTime(),\n            perm: this.perm,\n            mode: this.mode,\n            nlink: this.nlink,\n            symlink: this.symlink,\n            data: this.getString(),\n        };\n    }\n}\nexports.Node = Node;\n/**\n * Represents a hard link that points to an i-node `node`.\n */\nclass Link extends events_1.EventEmitter {\n    constructor(vol, parent, name) {\n        super();\n        this.children = {};\n        // Path to this node as Array: ['usr', 'bin', 'node'].\n        this._steps = [];\n        // \"i-node\" number of the node.\n        this.ino = 0;\n        // Number of children.\n        this.length = 0;\n        this.vol = vol;\n        this.parent = parent;\n        this.name = name;\n        this.syncSteps();\n    }\n    get steps() {\n        return this._steps;\n    }\n    // Recursively sync children steps, e.g. in case of dir rename\n    set steps(val) {\n        this._steps = val;\n        for (const child of Object.values(this.children)) {\n            child?.syncSteps();\n        }\n    }\n    setNode(node) {\n        this.node = node;\n        this.ino = node.ino;\n    }\n    getNode() {\n        return this.node;\n    }\n    createChild(name, node = this.vol.createNode()) {\n        const link = new Link(this.vol, this, name);\n        link.setNode(node);\n        if (node.isDirectory()) {\n            // link.setChild('.', link);\n            // link.getNode().nlink++;\n            // link.setChild('..', this);\n            // this.getNode().nlink++;\n        }\n        this.setChild(name, link);\n        return link;\n    }\n    childrenChanged() {\n        // When a file or directory gets created, mtime and ctime should\n        // get updated.  See https://github.com/sagemathinc/memfs-js/issues/4\n        // atime isn't updated since access isn't happening (?).  I'm just\n        // copying what happens on MacOS natively.\n        this.node.mtime = this.node.ctime = new Date();\n    }\n    setChild(name, link = new Link(this.vol, this, name)) {\n        this.children[name] = link;\n        this.childrenChanged();\n        link.parent = this;\n        this.length++;\n        this.emit(\"child:add\", link, this);\n        return link;\n    }\n    deleteChild(link) {\n        delete this.children[link.getName()];\n        this.childrenChanged();\n        this.length--;\n        this.emit(\"child:delete\", link, this);\n    }\n    getChild(name) {\n        if (Object.hasOwnProperty.call(this.children, name)) {\n            return this.children[name];\n        }\n    }\n    getPath() {\n        return this.steps.join(exports.SEP);\n    }\n    getName() {\n        return this.steps[this.steps.length - 1];\n    }\n    // del() {\n    //     const parent = this.parent;\n    //     if(parent) {\n    //         parent.deleteChild(link);\n    //     }\n    //     this.parent = null;\n    //     this.vol = null;\n    // }\n    /**\n     * Walk the tree path and return the `Link` at that location, if any.\n     * @param steps {string[]} Desired location.\n     * @param stop {number} Max steps to go into.\n     * @param i {number} Current step in the `steps` array.\n     *\n     * @return {Link|null}\n     */\n    walk(steps, stop = steps.length, i = 0) {\n        if (i >= steps.length)\n            return this;\n        if (i >= stop)\n            return this;\n        const step = steps[i];\n        const link = this.getChild(step);\n        if (!link)\n            return null;\n        return link.walk(steps, stop, i + 1);\n    }\n    toJSON() {\n        return {\n            steps: this.steps,\n            ino: this.ino,\n            children: Object.keys(this.children),\n        };\n    }\n    syncSteps() {\n        this.steps = this.parent\n            ? this.parent.steps.concat([this.name])\n            : [this.name];\n    }\n}\nexports.Link = Link;\n/**\n * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.\n */\nclass File {\n    /**\n     * Open a Link-Node pair. `node` is provided separately as that might be a different node\n     * rather the one `link` points to, because it might be a symlink.\n     * @param link\n     * @param node\n     * @param flags\n     * @param fd\n     */\n    constructor(link, node, flags, fd) {\n        /**\n         * A cursor/offset position in a file, where data will be written on write.\n         * User can \"seek\" this position.\n         */\n        this.position = 0;\n        this.link = link;\n        this.node = node;\n        this.flags = flags;\n        this.fd = fd;\n    }\n    getString(encoding = \"utf8\") {\n        return this.node.getString();\n    }\n    setString(str) {\n        this.node.setString(str);\n    }\n    getBuffer() {\n        return this.node.getBuffer();\n    }\n    setBuffer(buf) {\n        this.node.setBuffer(buf);\n    }\n    getSize() {\n        return this.node.getSize();\n    }\n    truncate(len) {\n        this.node.truncate(len);\n    }\n    seekTo(position) {\n        this.position = position;\n    }\n    stats() {\n        return Stats_1.default.build(this.node);\n    }\n    write(buf, offset = 0, length = buf.length, position) {\n        if (typeof position !== \"number\")\n            position = this.position;\n        if (this.flags & O_APPEND)\n            position = this.getSize();\n        const bytes = this.node.write(buf, offset, length, position);\n        this.position = position + bytes;\n        return bytes;\n    }\n    read(buf, offset = 0, length = buf.byteLength, position) {\n        if (typeof position !== \"number\")\n            position = this.position;\n        const bytes = this.node.read(buf, offset, length, position);\n        this.position = position + bytes;\n        return bytes;\n    }\n    chmod(perm) {\n        this.node.chmod(perm);\n    }\n    chown(uid, gid) {\n        this.node.chown(uid, gid);\n    }\n}\nexports.File = File;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLFdBQVc7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQVc7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsa0dBQW1CO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLFFBQVEsOENBQThDO0FBQ3REO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CLG9CQUFvQixRQUFRO0FBQzVCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBjb3dhc21cXG1lbWZzXFxsaWJcXG5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGUgPSBleHBvcnRzLkxpbmsgPSBleHBvcnRzLk5vZGUgPSBleHBvcnRzLlNFUCA9IHZvaWQgMDtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2J1ZmZlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgU3RhdHNfMSA9IHJlcXVpcmUoXCIuL1N0YXRzXCIpO1xuY29uc3QgeyBTX0lGTVQsIFNfSUZESVIsIFNfSUZSRUcsIFNfSUZMTkssIE9fQVBQRU5EIH0gPSBjb25zdGFudHNfMS5jb25zdGFudHM7XG5jb25zdCBnZXR1aWQgPSAoKSA9PiBwcm9jZXNzXzEuZGVmYXVsdC5nZXR1aWQ/LigpID8/IDA7XG5jb25zdCBnZXRnaWQgPSAoKSA9PiBwcm9jZXNzXzEuZGVmYXVsdC5nZXRnaWQ/LigpID8/IDA7XG5leHBvcnRzLlNFUCA9IFwiL1wiO1xuLyoqXG4gKiBOb2RlIGluIGEgZmlsZSBzeXN0ZW0gKGxpa2UgaS1ub2RlLCB2LW5vZGUpLlxuICovXG5jbGFzcyBOb2RlIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm8sIHBlcm0gPSAwbzY2Nikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBVc2VyIElEIGFuZCBncm91cCBJRC5cbiAgICAgICAgdGhpcy51aWQgPSBnZXR1aWQoKTtcbiAgICAgICAgdGhpcy5naWQgPSBnZXRnaWQoKTtcbiAgICAgICAgdGhpcy5hdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMubXRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5wZXJtID0gMG82NjY7IC8vIFBlcm1pc3Npb25zIGBjaG1vZGAsIGBmY2htb2RgXG4gICAgICAgIHRoaXMubW9kZSA9IFNfSUZSRUc7IC8vIFNfSUZESVIsIFNfSUZSRUcsIGV0Yy4uIChmaWxlIGJ5IGRlZmF1bHQ/KVxuICAgICAgICAvLyBOdW1iZXIgb2YgaGFyZCBsaW5rcyBwb2ludGluZyBhdCB0aGlzIE5vZGUuXG4gICAgICAgIHRoaXMubmxpbmsgPSAxO1xuICAgICAgICB0aGlzLnBlcm0gPSBwZXJtO1xuICAgICAgICB0aGlzLm1vZGUgfD0gcGVybTtcbiAgICAgICAgdGhpcy5pbm8gPSBpbm87XG4gICAgfVxuICAgIGdldFN0cmluZyhlbmNvZGluZyA9IFwidXRmOFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9XG4gICAgc2V0U3RyaW5nKHN0cikge1xuICAgICAgICAvLyB0aGlzLnNldEJ1ZmZlcihidWZmZXJGcm9tKHN0ciwgJ3V0ZjgnKSk7XG4gICAgICAgIHRoaXMuYnVmID0gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckZyb20pKHN0ciwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKCgwLCBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSkoMCkpO1xuICAgICAgICByZXR1cm4gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckZyb20pKHRoaXMuYnVmKTsgLy8gUmV0dXJuIGEgY29weS5cbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1Zikge1xuICAgICAgICB0aGlzLmJ1ZiA9ICgwLCBidWZmZXJfMS5idWZmZXJGcm9tKShidWYpOyAvLyBDcmVhdGVzIGEgY29weSBvZiBkYXRhLlxuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxuICAgIGdldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZiA/IHRoaXMuYnVmLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHNldE1vZGVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLm1vZGUgPSAodGhpcy5tb2RlICYgflNfSUZNVCkgfCBwcm9wZXJ0eTtcbiAgICB9XG4gICAgc2V0SXNGaWxlKCkge1xuICAgICAgICB0aGlzLnNldE1vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9XG4gICAgc2V0SXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHRoaXMuc2V0TW9kZVByb3BlcnR5KFNfSUZESVIpO1xuICAgIH1cbiAgICBzZXRJc1N5bWxpbmsoKSB7XG4gICAgICAgIHRoaXMuc2V0TW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH1cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gU19JRlJFRztcbiAgICB9XG4gICAgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gU19JRkRJUjtcbiAgICB9XG4gICAgaXNTeW1saW5rKCkge1xuICAgICAgICAvLyByZXR1cm4gISF0aGlzLnN5bWxpbms7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gU19JRkxOSztcbiAgICB9XG4gICAgbWFrZVN5bWxpbmsoc3RlcHMpIHtcbiAgICAgICAgdGhpcy5zeW1saW5rID0gc3RlcHM7XG4gICAgICAgIHRoaXMuc2V0SXNTeW1saW5rKCk7XG4gICAgfVxuICAgIHdyaXRlKGJ1Ziwgb2ZmID0gMCwgbGVuID0gYnVmLmxlbmd0aCwgcG9zID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmKVxuICAgICAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICBpZiAocG9zICsgbGVuID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCdWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKHBvcyArIGxlbik7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KG5ld0J1ZiwgMCwgMCwgdGhpcy5idWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gbmV3QnVmO1xuICAgICAgICB9XG4gICAgICAgIGJ1Zi5jb3B5KHRoaXMuYnVmLCBwb3MsIG9mZiwgb2ZmICsgbGVuKTtcbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICByZWFkKGJ1Ziwgb2ZmID0gMCwgbGVuID0gYnVmLmJ5dGVMZW5ndGgsIHBvcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuYnVmID0gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKSgwKTtcbiAgICAgICAgbGV0IGFjdHVhbExlbiA9IGxlbjtcbiAgICAgICAgaWYgKGFjdHVhbExlbiA+IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0dWFsTGVuICsgcG9zID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSB0aGlzLmJ1Zi5sZW5ndGggLSBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYuY29weShidWYsIG9mZiwgcG9zLCBwb3MgKyBhY3R1YWxMZW4pO1xuICAgICAgICByZXR1cm4gYWN0dWFsTGVuO1xuICAgIH1cbiAgICB0cnVuY2F0ZShsZW4gPSAwKSB7XG4gICAgICAgIGlmICghbGVuKVxuICAgICAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5idWYpXG4gICAgICAgICAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICAgICAgaWYgKGxlbiA8PSB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZiA9IHRoaXMuYnVmLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgICAgICAgICBidWYuZmlsbCgwLCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9XG4gICAgY2htb2QocGVybSkge1xuICAgICAgICB0aGlzLnBlcm0gPSBwZXJtO1xuICAgICAgICB0aGlzLm1vZGUgPSAodGhpcy5tb2RlICYgfjBvNzc3KSB8IHBlcm07XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9XG4gICAgY2hvd24odWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICAgIHRoaXMuZ2lkID0gZ2lkO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxuICAgIHRvdWNoKCkge1xuICAgICAgICB0aGlzLm10aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICAgIH1cbiAgICBjYW5SZWFkKHVpZCA9IGdldHVpZCgpLCBnaWQgPSBnZXRnaWQoKSkge1xuICAgICAgICBpZiAodGhpcy5wZXJtICYgNCAvKiBTLklST1RIICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2lkID09PSB0aGlzLmdpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDMyIC8qIFMuSVJHUlAgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDI1NiAvKiBTLklSVVNSICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYW5Xcml0ZSh1aWQgPSBnZXR1aWQoKSwgZ2lkID0gZ2V0Z2lkKCkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVybSAmIDIgLyogUy5JV09USCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdGhpcy5naWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxNiAvKiBTLklXR1JQICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxMjggLyogUy5JV1VTUiAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkZWxldGVcIiwgdGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlubzogdGhpcy5pbm8sXG4gICAgICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICAgICAgZ2lkOiB0aGlzLmdpZCxcbiAgICAgICAgICAgIGF0aW1lOiB0aGlzLmF0aW1lLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG10aW1lOiB0aGlzLm10aW1lLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGN0aW1lOiB0aGlzLmN0aW1lLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHBlcm06IHRoaXMucGVybSxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIG5saW5rOiB0aGlzLm5saW5rLFxuICAgICAgICAgICAgc3ltbGluazogdGhpcy5zeW1saW5rLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRTdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgaGFyZCBsaW5rIHRoYXQgcG9pbnRzIHRvIGFuIGktbm9kZSBgbm9kZWAuXG4gKi9cbmNsYXNzIExpbmsgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZvbCwgcGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgLy8gUGF0aCB0byB0aGlzIG5vZGUgYXMgQXJyYXk6IFsndXNyJywgJ2JpbicsICdub2RlJ10uXG4gICAgICAgIHRoaXMuX3N0ZXBzID0gW107XG4gICAgICAgIC8vIFwiaS1ub2RlXCIgbnVtYmVyIG9mIHRoZSBub2RlLlxuICAgICAgICB0aGlzLmlubyA9IDA7XG4gICAgICAgIC8vIE51bWJlciBvZiBjaGlsZHJlbi5cbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZvbCA9IHZvbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3luY1N0ZXBzKCk7XG4gICAgfVxuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBzeW5jIGNoaWxkcmVuIHN0ZXBzLCBlLmcuIGluIGNhc2Ugb2YgZGlyIHJlbmFtZVxuICAgIHNldCBzdGVwcyh2YWwpIHtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSB2YWw7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgY2hpbGQ/LnN5bmNTdGVwcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubyA9IG5vZGUuaW5vO1xuICAgIH1cbiAgICBnZXROb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChuYW1lLCBub2RlID0gdGhpcy52b2wuY3JlYXRlTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBuZXcgTGluayh0aGlzLnZvbCwgdGhpcywgbmFtZSk7XG4gICAgICAgIGxpbmsuc2V0Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgLy8gbGluay5zZXRDaGlsZCgnLicsIGxpbmspO1xuICAgICAgICAgICAgLy8gbGluay5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgICAgIC8vIGxpbmsuc2V0Q2hpbGQoJy4uJywgdGhpcyk7XG4gICAgICAgICAgICAvLyB0aGlzLmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q2hpbGQobmFtZSwgbGluayk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbiAgICBjaGlsZHJlbkNoYW5nZWQoKSB7XG4gICAgICAgIC8vIFdoZW4gYSBmaWxlIG9yIGRpcmVjdG9yeSBnZXRzIGNyZWF0ZWQsIG10aW1lIGFuZCBjdGltZSBzaG91bGRcbiAgICAgICAgLy8gZ2V0IHVwZGF0ZWQuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NhZ2VtYXRoaW5jL21lbWZzLWpzL2lzc3Vlcy80XG4gICAgICAgIC8vIGF0aW1lIGlzbid0IHVwZGF0ZWQgc2luY2UgYWNjZXNzIGlzbid0IGhhcHBlbmluZyAoPykuICBJJ20ganVzdFxuICAgICAgICAvLyBjb3B5aW5nIHdoYXQgaGFwcGVucyBvbiBNYWNPUyBuYXRpdmVseS5cbiAgICAgICAgdGhpcy5ub2RlLm10aW1lID0gdGhpcy5ub2RlLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgc2V0Q2hpbGQobmFtZSwgbGluayA9IG5ldyBMaW5rKHRoaXMudm9sLCB0aGlzLCBuYW1lKSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW25hbWVdID0gbGluaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgbGluay5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGlsZDphZGRcIiwgbGluaywgdGhpcyk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbiAgICBkZWxldGVDaGlsZChsaW5rKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuW2xpbmsuZ2V0TmFtZSgpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hpbGQ6ZGVsZXRlXCIsIGxpbmssIHRoaXMpO1xuICAgIH1cbiAgICBnZXRDaGlsZChuYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMuam9pbihleHBvcnRzLlNFUCk7XG4gICAgfVxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzW3RoaXMuc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIC8vIGRlbCgpIHtcbiAgICAvLyAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgLy8gICAgIGlmKHBhcmVudCkge1xuICAgIC8vICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAvLyAgICAgdGhpcy52b2wgPSBudWxsO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBXYWxrIHRoZSB0cmVlIHBhdGggYW5kIHJldHVybiB0aGUgYExpbmtgIGF0IHRoYXQgbG9jYXRpb24sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0gc3RlcHMge3N0cmluZ1tdfSBEZXNpcmVkIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBzdG9wIHtudW1iZXJ9IE1heCBzdGVwcyB0byBnbyBpbnRvLlxuICAgICAqIEBwYXJhbSBpIHtudW1iZXJ9IEN1cnJlbnQgc3RlcCBpbiB0aGUgYHN0ZXBzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0xpbmt8bnVsbH1cbiAgICAgKi9cbiAgICB3YWxrKHN0ZXBzLCBzdG9wID0gc3RlcHMubGVuZ3RoLCBpID0gMCkge1xuICAgICAgICBpZiAoaSA+PSBzdGVwcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKGkgPj0gc3RvcClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldENoaWxkKHN0ZXApO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxpbmsud2FsayhzdGVwcywgc3RvcCwgaSArIDEpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwczogdGhpcy5zdGVwcyxcbiAgICAgICAgICAgIGlubzogdGhpcy5pbm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogT2JqZWN0LmtleXModGhpcy5jaGlsZHJlbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN5bmNTdGVwcygpIHtcbiAgICAgICAgdGhpcy5zdGVwcyA9IHRoaXMucGFyZW50XG4gICAgICAgICAgICA/IHRoaXMucGFyZW50LnN0ZXBzLmNvbmNhdChbdGhpcy5uYW1lXSlcbiAgICAgICAgICAgIDogW3RoaXMubmFtZV07XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rID0gTGluaztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvcGVuIGZpbGUgKGZpbGUgZGVzY3JpcHRvcikgdGhhdCBwb2ludHMgdG8gYSBgTGlua2AgKEhhcmQtbGluaykgYW5kIGEgYE5vZGVgLlxuICovXG5jbGFzcyBGaWxlIHtcbiAgICAvKipcbiAgICAgKiBPcGVuIGEgTGluay1Ob2RlIHBhaXIuIGBub2RlYCBpcyBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHRoYXQgbWlnaHQgYmUgYSBkaWZmZXJlbnQgbm9kZVxuICAgICAqIHJhdGhlciB0aGUgb25lIGBsaW5rYCBwb2ludHMgdG8sIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBzeW1saW5rLlxuICAgICAqIEBwYXJhbSBsaW5rXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gZmxhZ3NcbiAgICAgKiBAcGFyYW0gZmRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsaW5rLCBub2RlLCBmbGFncywgZmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3Vyc29yL29mZnNldCBwb3NpdGlvbiBpbiBhIGZpbGUsIHdoZXJlIGRhdGEgd2lsbCBiZSB3cml0dGVuIG9uIHdyaXRlLlxuICAgICAgICAgKiBVc2VyIGNhbiBcInNlZWtcIiB0aGlzIHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGluayA9IGxpbms7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5mZCA9IGZkO1xuICAgIH1cbiAgICBnZXRTdHJpbmcoZW5jb2RpbmcgPSBcInV0ZjhcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFN0cmluZygpO1xuICAgIH1cbiAgICBzZXRTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJ1ZmZlcigpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRCdWZmZXIoYnVmKTtcbiAgICB9XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRTaXplKCk7XG4gICAgfVxuICAgIHRydW5jYXRlKGxlbikge1xuICAgICAgICB0aGlzLm5vZGUudHJ1bmNhdGUobGVuKTtcbiAgICB9XG4gICAgc2Vla1RvKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiBTdGF0c18xLmRlZmF1bHQuYnVpbGQodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgd3JpdGUoYnVmLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWYubGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIE9fQVBQRU5EKVxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm5vZGUud3JpdGUoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gKyBieXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICByZWFkKGJ1Ziwgb2Zmc2V0ID0gMCwgbGVuZ3RoID0gYnVmLmJ5dGVMZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5ub2RlLnJlYWQoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gKyBieXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBjaG1vZChwZXJtKSB7XG4gICAgICAgIHRoaXMubm9kZS5jaG1vZChwZXJtKTtcbiAgICB9XG4gICAgY2hvd24odWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNob3duKHVpZCwgZ2lkKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/node.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/process.js":
/*!***************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/process.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\n// Here we mock the global `process` variable in case we are not in Node's environment.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createProcess = void 0;\n/**\n * Looks to return a `process` object, if one is available.\n *\n * The global `process` is returned if defined;\n * otherwise `require('process')` is attempted.\n *\n * If that fails, `undefined` is returned.\n *\n * @return {IProcess | undefined}\n */\nconst maybeReturnProcess = () => {\n    if (typeof process !== \"undefined\") {\n        return process;\n    }\n    try {\n        return __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n    }\n    catch {\n        return undefined;\n    }\n};\nfunction createProcess() {\n    const p = maybeReturnProcess() || {};\n    if (!p.cwd)\n        p.cwd = () => \"/\";\n    if (!p.nextTick)\n        p.nextTick = (__webpack_require__(/*! ./setImmediate */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setImmediate.js\")[\"default\"]);\n    if (!p.emitWarning)\n        p.emitWarning = (message, type) => {\n            // tslint:disable-next-line:no-console\n            console.warn(`${type}${type ? \": \" : \"\"}${message}`);\n        };\n    if (!p.env)\n        p.env = {};\n    return p;\n}\nexports.createProcess = createProcess;\nexports[\"default\"] = createProcess();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0VBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEhBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsaUJBQWlCLEVBQUUsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFlIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxccHJvY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEhlcmUgd2UgbW9jayB0aGUgZ2xvYmFsIGBwcm9jZXNzYCB2YXJpYWJsZSBpbiBjYXNlIHdlIGFyZSBub3QgaW4gTm9kZSdzIGVudmlyb25tZW50LlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVQcm9jZXNzID0gdm9pZCAwO1xuLyoqXG4gKiBMb29rcyB0byByZXR1cm4gYSBgcHJvY2Vzc2Agb2JqZWN0LCBpZiBvbmUgaXMgYXZhaWxhYmxlLlxuICpcbiAqIFRoZSBnbG9iYWwgYHByb2Nlc3NgIGlzIHJldHVybmVkIGlmIGRlZmluZWQ7XG4gKiBvdGhlcndpc2UgYHJlcXVpcmUoJ3Byb2Nlc3MnKWAgaXMgYXR0ZW1wdGVkLlxuICpcbiAqIElmIHRoYXQgZmFpbHMsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEByZXR1cm4ge0lQcm9jZXNzIHwgdW5kZWZpbmVkfVxuICovXG5jb25zdCBtYXliZVJldHVyblByb2Nlc3MgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcInByb2Nlc3NcIik7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUHJvY2VzcygpIHtcbiAgICBjb25zdCBwID0gbWF5YmVSZXR1cm5Qcm9jZXNzKCkgfHwge307XG4gICAgaWYgKCFwLmN3ZClcbiAgICAgICAgcC5jd2QgPSAoKSA9PiBcIi9cIjtcbiAgICBpZiAoIXAubmV4dFRpY2spXG4gICAgICAgIHAubmV4dFRpY2sgPSByZXF1aXJlKFwiLi9zZXRJbW1lZGlhdGVcIikuZGVmYXVsdDtcbiAgICBpZiAoIXAuZW1pdFdhcm5pbmcpXG4gICAgICAgIHAuZW1pdFdhcm5pbmcgPSAobWVzc2FnZSwgdHlwZSkgPT4ge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt0eXBlfSR7dHlwZSA/IFwiOiBcIiA6IFwiXCJ9JHttZXNzYWdlfWApO1xuICAgICAgICB9O1xuICAgIGlmICghcC5lbnYpXG4gICAgICAgIHAuZW52ID0ge307XG4gICAgcmV0dXJuIHA7XG59XG5leHBvcnRzLmNyZWF0ZVByb2Nlc3MgPSBjcmVhdGVQcm9jZXNzO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlUHJvY2VzcygpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/process.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/promises.js":
/*!****************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/promises.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileHandle = void 0;\nfunction promisify(vol, fn, getResult = (input) => input) {\n    return (...args) => new Promise((resolve, reject) => {\n        vol[fn].bind(vol)(...args, (error, result) => {\n            if (error)\n                return reject(error);\n            return resolve(getResult(result));\n        });\n    });\n}\nclass FileHandle {\n    constructor(vol, fd) {\n        this.vol = vol;\n        this.fd = fd;\n    }\n    appendFile(data, options) {\n        return promisify(this.vol, \"appendFile\")(this.fd, data, options);\n    }\n    chmod(mode) {\n        return promisify(this.vol, \"fchmod\")(this.fd, mode);\n    }\n    chown(uid, gid) {\n        return promisify(this.vol, \"fchown\")(this.fd, uid, gid);\n    }\n    close() {\n        return promisify(this.vol, \"close\")(this.fd);\n    }\n    datasync() {\n        return promisify(this.vol, \"fdatasync\")(this.fd);\n    }\n    read(buffer, offset, length, position) {\n        return promisify(this.vol, \"read\", (bytesRead) => ({ bytesRead, buffer }))(this.fd, buffer, offset, length, position);\n    }\n    readFile(options) {\n        return promisify(this.vol, \"readFile\")(this.fd, options);\n    }\n    stat(options) {\n        return promisify(this.vol, \"fstat\")(this.fd, options);\n    }\n    sync() {\n        return promisify(this.vol, \"fsync\")(this.fd);\n    }\n    truncate(len) {\n        return promisify(this.vol, \"ftruncate\")(this.fd, len);\n    }\n    utimes(atime, mtime) {\n        return promisify(this.vol, \"futimes\")(this.fd, atime, mtime);\n    }\n    write(buffer, offset, length, position) {\n        return promisify(this.vol, \"write\", (bytesWritten) => ({\n            bytesWritten,\n            buffer,\n        }))(this.fd, buffer, offset, length, position);\n    }\n    writeFile(data, options) {\n        return promisify(this.vol, \"writeFile\")(this.fd, data, options);\n    }\n}\nexports.FileHandle = FileHandle;\nfunction createPromisesApi(vol) {\n    if (typeof Promise === \"undefined\")\n        return null;\n    return {\n        FileHandle,\n        access(path, mode) {\n            return promisify(vol, \"access\")(path, mode);\n        },\n        appendFile(path, data, options) {\n            return promisify(vol, \"appendFile\")(path instanceof FileHandle ? path.fd : path, data, options);\n        },\n        chmod(path, mode) {\n            return promisify(vol, \"chmod\")(path, mode);\n        },\n        chown(path, uid, gid) {\n            return promisify(vol, \"chown\")(path, uid, gid);\n        },\n        copyFile(src, dest, flags) {\n            return promisify(vol, \"copyFile\")(src, dest, flags);\n        },\n        lchmod(path, mode) {\n            return promisify(vol, \"lchmod\")(path, mode);\n        },\n        lchown(path, uid, gid) {\n            return promisify(vol, \"lchown\")(path, uid, gid);\n        },\n        link(existingPath, newPath) {\n            return promisify(vol, \"link\")(existingPath, newPath);\n        },\n        lstat(path, options) {\n            return promisify(vol, \"lstat\")(path, options);\n        },\n        mkdir(path, options) {\n            return promisify(vol, \"mkdir\")(path, options);\n        },\n        mkdtemp(prefix, options) {\n            return promisify(vol, \"mkdtemp\")(prefix, options);\n        },\n        open(path, flags, mode) {\n            return promisify(vol, \"open\", (fd) => new FileHandle(vol, fd))(path, flags, mode);\n        },\n        readdir(path, options) {\n            return promisify(vol, \"readdir\")(path, options);\n        },\n        readFile(id, options) {\n            return promisify(vol, \"readFile\")(id instanceof FileHandle ? id.fd : id, options);\n        },\n        readlink(path, options) {\n            return promisify(vol, \"readlink\")(path, options);\n        },\n        realpath(path, options) {\n            return promisify(vol, \"realpath\")(path, options);\n        },\n        rename(oldPath, newPath) {\n            return promisify(vol, \"rename\")(oldPath, newPath);\n        },\n        rmdir(path) {\n            return promisify(vol, \"rmdir\")(path);\n        },\n        rm(path, options) {\n            return promisify(vol, \"rm\")(path, options);\n        },\n        stat(path, options) {\n            return promisify(vol, \"stat\")(path, options);\n        },\n        symlink(target, path, type) {\n            return promisify(vol, \"symlink\")(target, path, type);\n        },\n        truncate(path, len) {\n            return promisify(vol, \"truncate\")(path, len);\n        },\n        unlink(path) {\n            return promisify(vol, \"unlink\")(path);\n        },\n        utimes(path, atime, mtime) {\n            return promisify(vol, \"utimes\")(path, atime, mtime);\n        },\n        writeFile(id, data, options) {\n            return promisify(vol, \"writeFile\")(id instanceof FileHandle ? id.fd : id, data, options);\n        },\n    };\n}\nexports[\"default\"] = createPromisesApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9wcm9taXNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBjb3dhc21cXG1lbWZzXFxsaWJcXHByb21pc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlSGFuZGxlID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvbWlzaWZ5KHZvbCwgZm4sIGdldFJlc3VsdCA9IChpbnB1dCkgPT4gaW5wdXQpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdm9sW2ZuXS5iaW5kKHZvbCkoLi4uYXJncywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldFJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jbGFzcyBGaWxlSGFuZGxlIHtcbiAgICBjb25zdHJ1Y3Rvcih2b2wsIGZkKSB7XG4gICAgICAgIHRoaXMudm9sID0gdm9sO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgfVxuICAgIGFwcGVuZEZpbGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCBcImFwcGVuZEZpbGVcIikodGhpcy5mZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNobW9kKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgXCJmY2htb2RcIikodGhpcy5mZCwgbW9kZSk7XG4gICAgfVxuICAgIGNob3duKHVpZCwgZ2lkKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsIFwiZmNob3duXCIpKHRoaXMuZmQsIHVpZCwgZ2lkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsIFwiY2xvc2VcIikodGhpcy5mZCk7XG4gICAgfVxuICAgIGRhdGFzeW5jKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCBcImZkYXRhc3luY1wiKSh0aGlzLmZkKTtcbiAgICB9XG4gICAgcmVhZChidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCBcInJlYWRcIiwgKGJ5dGVzUmVhZCkgPT4gKHsgYnl0ZXNSZWFkLCBidWZmZXIgfSkpKHRoaXMuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmVhZEZpbGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCBcInJlYWRGaWxlXCIpKHRoaXMuZmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgXCJmc3RhdFwiKSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgXCJmc3luY1wiKSh0aGlzLmZkKTtcbiAgICB9XG4gICAgdHJ1bmNhdGUobGVuKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsIFwiZnRydW5jYXRlXCIpKHRoaXMuZmQsIGxlbik7XG4gICAgfVxuICAgIHV0aW1lcyhhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgXCJmdXRpbWVzXCIpKHRoaXMuZmQsIGF0aW1lLCBtdGltZSk7XG4gICAgfVxuICAgIHdyaXRlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsIFwid3JpdGVcIiwgKGJ5dGVzV3JpdHRlbikgPT4gKHtcbiAgICAgICAgICAgIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgfSkpKHRoaXMuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgd3JpdGVGaWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgXCJ3cml0ZUZpbGVcIikodGhpcy5mZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlSGFuZGxlID0gRmlsZUhhbmRsZTtcbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2VzQXBpKHZvbCkge1xuICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgRmlsZUhhbmRsZSxcbiAgICAgICAgYWNjZXNzKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcImFjY2Vzc1wiKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJhcHBlbmRGaWxlXCIpKHBhdGggaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gcGF0aC5mZCA6IHBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBjaG1vZChwYXRoLCBtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJjaG1vZFwiKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hvd24ocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcImNob3duXCIpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwiY29weUZpbGVcIikoc3JjLCBkZXN0LCBmbGFncyk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG1vZChwYXRoLCBtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJsY2htb2RcIikocGF0aCwgbW9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG93bihwYXRoLCB1aWQsIGdpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwibGNob3duXCIpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluayhleGlzdGluZ1BhdGgsIG5ld1BhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcImxpbmtcIikoZXhpc3RpbmdQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbHN0YXQocGF0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwibHN0YXRcIikocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1rZGlyKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcIm1rZGlyXCIpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBta2R0ZW1wKHByZWZpeCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwibWtkdGVtcFwiKShwcmVmaXgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuKHBhdGgsIGZsYWdzLCBtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJvcGVuXCIsIChmZCkgPT4gbmV3IEZpbGVIYW5kbGUodm9sLCBmZCkpKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcihwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJyZWFkZGlyXCIpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkRmlsZShpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwicmVhZEZpbGVcIikoaWQgaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gaWQuZmQgOiBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRsaW5rKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcInJlYWRsaW5rXCIpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFscGF0aChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJyZWFscGF0aFwiKShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcInJlbmFtZVwiKShvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXIocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwicm1kaXJcIikocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJtKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcInJtXCIpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzdGF0KHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcInN0YXRcIikocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWxpbmsodGFyZ2V0LCBwYXRoLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgXCJzeW1saW5rXCIpKHRhcmdldCwgcGF0aCwgdHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRydW5jYXRlKHBhdGgsIGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwidHJ1bmNhdGVcIikocGF0aCwgbGVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saW5rKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCBcInVubGlua1wiKShwYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwidXRpbWVzXCIpKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlRmlsZShpZCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsIFwid3JpdGVGaWxlXCIpKGlkIGluc3RhbmNlb2YgRmlsZUhhbmRsZSA/IGlkLmZkIDogaWQsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVQcm9taXNlc0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/promises.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setImmediate.js":
/*!********************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/setImmediate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet _setImmediate;\nif (typeof setImmediate === \"function\")\n    _setImmediate = setImmediate.bind(typeof globalThis !== \"undefined\" ? globalThis : __webpack_require__.g);\nelse\n    _setImmediate = setTimeout.bind(typeof globalThis !== \"undefined\" ? globalThis : __webpack_require__.g);\nexports[\"default\"] = _setImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9zZXRJbW1lZGlhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLHVGQUF1RixxQkFBTTtBQUM3RjtBQUNBLHFGQUFxRixxQkFBTTtBQUMzRixrQkFBZSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBjb3dhc21cXG1lbWZzXFxsaWJcXHNldEltbWVkaWF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmxldCBfc2V0SW1tZWRpYXRlO1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICBfc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlLmJpbmQodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogZ2xvYmFsKTtcbmVsc2VcbiAgICBfc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dC5iaW5kKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCk7XG5leHBvcnRzLmRlZmF1bHQgPSBfc2V0SW1tZWRpYXRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setImmediate.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setTimeoutUnref.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/setTimeoutUnref.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * `setTimeoutUnref` is just like `setTimeout`,\n * only in Node's environment it will \"unref\" its macro task.\n */\nfunction setTimeoutUnref(callback, time, args) {\n    const ref = setTimeout.apply(typeof globalThis !== \"undefined\" ? globalThis : __webpack_require__.g, arguments);\n    if (ref && typeof ref === \"object\" && typeof ref.unref === \"function\")\n        ref.unref();\n    return ref;\n}\nexports[\"default\"] = setTimeoutUnref;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi9zZXRUaW1lb3V0VW5yZWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixxQkFBTTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQGNvd2FzbVxcbWVtZnNcXGxpYlxcc2V0VGltZW91dFVucmVmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBgc2V0VGltZW91dFVucmVmYCBpcyBqdXN0IGxpa2UgYHNldFRpbWVvdXRgLFxuICogb25seSBpbiBOb2RlJ3MgZW52aXJvbm1lbnQgaXQgd2lsbCBcInVucmVmXCIgaXRzIG1hY3JvIHRhc2suXG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRVbnJlZihjYWxsYmFjaywgdGltZSwgYXJncykge1xuICAgIGNvbnN0IHJlZiA9IHNldFRpbWVvdXQuYXBwbHkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogZ2xvYmFsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZWYgJiYgdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVmLnVucmVmID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJlZi51bnJlZigpO1xuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZXRUaW1lb3V0VW5yZWY7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setTimeoutUnref.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/volume.js":
/*!**************************************************!*\
  !*** ./node_modules/@cowasm/memfs/lib/volume.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FSWatcher = exports.StatWatcher = exports.Volume = exports.toUnixTimestamp = exports.bufferToEncoding = exports.dataToBuffer = exports.dataToStr = exports.pathToSteps = exports.filenameToSteps = exports.pathToFilename = exports.flagsToNumber = exports.FLAGS = void 0;\nconst pathModule = __webpack_require__(/*! path */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst node_1 = __webpack_require__(/*! ./node */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/node.js\");\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Stats.js\");\nconst Dirent_1 = __webpack_require__(/*! ./Dirent */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/Dirent.js\");\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/buffer.js\");\nconst setImmediate_1 = __webpack_require__(/*! ./setImmediate */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setImmediate.js\");\nconst process_1 = __webpack_require__(/*! ./process */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/process.js\");\nconst setTimeoutUnref_1 = __webpack_require__(/*! ./setTimeoutUnref */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/setTimeoutUnref.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/stream-browserify/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/constants.js\");\nconst events_1 = __webpack_require__(/*! events */ \"(pages-dir-browser)/./node_modules/events/events.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/encoding.js\");\nconst errors = __webpack_require__(/*! ./internal/errors */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/internal/errors.js\");\nconst util = __webpack_require__(/*! util */ \"(pages-dir-browser)/./node_modules/util/util.js\");\nconst promises_1 = __webpack_require__(/*! ./promises */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/promises.js\");\nconst resolveCrossPlatform = pathModule.resolve;\nconst { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_SYNC, O_DIRECTORY, F_OK, COPYFILE_EXCL, COPYFILE_FICLONE_FORCE, } = constants_1.constants;\nconst { sep, relative, join, dirname } = pathModule.posix\n    ? pathModule.posix\n    : pathModule;\nconst isWin = process_1.default.platform === \"win32\";\nconst kMinPoolSpace = 128;\n// const kMaxLength = require('buffer').kMaxLength;\n// ---------------------------------------- Error messages\n// TODO: Use `internal/errors.js` in the future.\nconst ERRSTR = {\n    PATH_STR: \"path must be a string or Buffer\",\n    // FD:             'file descriptor must be a unsigned 32-bit integer',\n    FD: \"fd must be a file descriptor\",\n    MODE_INT: \"mode must be an int\",\n    CB: \"callback must be a function\",\n    UID: \"uid must be an unsigned int\",\n    GID: \"gid must be an unsigned int\",\n    LEN: \"len must be an integer\",\n    ATIME: \"atime must be an integer\",\n    MTIME: \"mtime must be an integer\",\n    PREFIX: \"filename prefix is required\",\n    BUFFER: \"buffer must be an instance of Buffer or StaticBuffer\",\n    OFFSET: \"offset must be an integer\",\n    LENGTH: \"length must be an integer\",\n    POSITION: \"position must be an integer\",\n};\nconst ERRSTR_OPTS = (tipeof) => `Expected options to be either an object or a string, but got ${tipeof} instead`;\n// const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;\nconst ENOENT = \"ENOENT\";\nconst EBADF = \"EBADF\";\nconst EINVAL = \"EINVAL\";\nconst EPERM = \"EPERM\";\nconst EPROTO = \"EPROTO\";\nconst EEXIST = \"EEXIST\";\nconst ENOTDIR = \"ENOTDIR\";\nconst EMFILE = \"EMFILE\";\nconst EACCES = \"EACCES\";\nconst EISDIR = \"EISDIR\";\nconst ENOTEMPTY = \"ENOTEMPTY\";\nconst ENOSYS = \"ENOSYS\";\nconst ERR_FS_EISDIR = \"ERR_FS_EISDIR\";\nfunction formatError(errorCode, func = \"\", path = \"\", path2 = \"\") {\n    let pathFormatted = \"\";\n    if (path)\n        pathFormatted = ` '${path}'`;\n    if (path2)\n        pathFormatted += ` -> '${path2}'`;\n    switch (errorCode) {\n        case ENOENT:\n            return `ENOENT: no such file or directory, ${func}${pathFormatted}`;\n        case EBADF:\n            return `EBADF: bad file descriptor, ${func}${pathFormatted}`;\n        case EINVAL:\n            return `EINVAL: invalid argument, ${func}${pathFormatted}`;\n        case EPERM:\n            return `EPERM: operation not permitted, ${func}${pathFormatted}`;\n        case EPROTO:\n            return `EPROTO: protocol error, ${func}${pathFormatted}`;\n        case EEXIST:\n            return `EEXIST: file already exists, ${func}${pathFormatted}`;\n        case ENOTDIR:\n            return `ENOTDIR: not a directory, ${func}${pathFormatted}`;\n        case EISDIR:\n            return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;\n        case EACCES:\n            return `EACCES: permission denied, ${func}${pathFormatted}`;\n        case ENOTEMPTY:\n            return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;\n        case EMFILE:\n            return `EMFILE: too many open files, ${func}${pathFormatted}`;\n        case ENOSYS:\n            return `ENOSYS: function not implemented, ${func}${pathFormatted}`;\n        case ERR_FS_EISDIR:\n            return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path}`;\n        default:\n            return `${errorCode}: error occurred, ${func}${pathFormatted}`;\n    }\n}\nfunction createError(errorCode, func = \"\", path = \"\", path2 = \"\", Constructor = Error) {\n    const error = new Constructor(formatError(errorCode, func, path, path2));\n    error.code = errorCode;\n    return error;\n}\n// ---------------------------------------- Flags\n// List of file `flags` as defined by Node.\nvar FLAGS;\n(function (FLAGS) {\n    // Open file for reading. An exception occurs if the file does not exist.\n    FLAGS[FLAGS[\"r\"] = O_RDONLY] = \"r\";\n    // Open file for reading and writing. An exception occurs if the file does not exist.\n    FLAGS[FLAGS[\"r+\"] = O_RDWR] = \"r+\";\n    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.\n    FLAGS[FLAGS[\"rs\"] = O_RDONLY | O_SYNC] = \"rs\";\n    FLAGS[FLAGS[\"sr\"] = FLAGS.rs] = \"sr\";\n    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.\n    FLAGS[FLAGS[\"rs+\"] = O_RDWR | O_SYNC] = \"rs+\";\n    FLAGS[FLAGS[\"sr+\"] = FLAGS[\"rs+\"]] = \"sr+\";\n    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n    FLAGS[FLAGS[\"w\"] = O_WRONLY | O_CREAT | O_TRUNC] = \"w\";\n    // Like 'w' but fails if path exists.\n    FLAGS[FLAGS[\"wx\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \"wx\";\n    FLAGS[FLAGS[\"xw\"] = FLAGS.wx] = \"xw\";\n    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n    FLAGS[FLAGS[\"w+\"] = O_RDWR | O_CREAT | O_TRUNC] = \"w+\";\n    // Like 'w+' but fails if path exists.\n    FLAGS[FLAGS[\"wx+\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \"wx+\";\n    FLAGS[FLAGS[\"xw+\"] = FLAGS[\"wx+\"]] = \"xw+\";\n    // Open file for appending. The file is created if it does not exist.\n    FLAGS[FLAGS[\"a\"] = O_WRONLY | O_APPEND | O_CREAT] = \"a\";\n    // Like 'a' but fails if path exists.\n    FLAGS[FLAGS[\"ax\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \"ax\";\n    FLAGS[FLAGS[\"xa\"] = FLAGS.ax] = \"xa\";\n    // Open file for reading and appending. The file is created if it does not exist.\n    FLAGS[FLAGS[\"a+\"] = O_RDWR | O_APPEND | O_CREAT] = \"a+\";\n    // Like 'a+' but fails if path exists.\n    FLAGS[FLAGS[\"ax+\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \"ax+\";\n    FLAGS[FLAGS[\"xa+\"] = FLAGS[\"ax+\"]] = \"xa+\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nfunction flagsToNumber(flags) {\n    if (typeof flags === \"number\")\n        return flags;\n    if (typeof flags === \"string\") {\n        const flagsNum = FLAGS[flags];\n        if (typeof flagsNum !== \"undefined\")\n            return flagsNum;\n    }\n    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));\n    throw new errors.TypeError(\"ERR_INVALID_OPT_VALUE\", \"flags\", flags);\n}\nexports.flagsToNumber = flagsToNumber;\n// ---------------------------------------- Options\nfunction getOptions(defaults, options) {\n    let opts;\n    if (!options)\n        return defaults;\n    else {\n        const tipeof = typeof options;\n        switch (tipeof) {\n            case \"string\":\n                opts = Object.assign({}, defaults, { encoding: options });\n                break;\n            case \"object\":\n                opts = Object.assign({}, defaults, options);\n                break;\n            default:\n                throw TypeError(ERRSTR_OPTS(tipeof));\n        }\n    }\n    if (opts.encoding !== \"buffer\")\n        (0, encoding_1.assertEncoding)(opts.encoding);\n    return opts;\n}\nfunction optsGenerator(defaults) {\n    return (options) => getOptions(defaults, options);\n}\nfunction validateCallback(callback) {\n    if (typeof callback !== \"function\")\n        throw TypeError(ERRSTR.CB);\n    return callback;\n}\nfunction optsAndCbGenerator(getOpts) {\n    return (options, callback) => typeof options === \"function\"\n        ? [getOpts(), options]\n        : [getOpts(options), validateCallback(callback)];\n}\nconst optsDefaults = {\n    encoding: \"utf8\",\n};\nconst getDefaultOpts = optsGenerator(optsDefaults);\nconst getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);\nconst readFileOptsDefaults = {\n    flag: \"r\",\n};\nconst getReadFileOptions = optsGenerator(readFileOptsDefaults);\nconst writeFileDefaults = {\n    encoding: \"utf8\",\n    mode: 438 /* MODE.DEFAULT */,\n    flag: FLAGS[FLAGS.w],\n};\nconst getWriteFileOptions = optsGenerator(writeFileDefaults);\nconst appendFileDefaults = {\n    encoding: \"utf8\",\n    mode: 438 /* MODE.DEFAULT */,\n    flag: FLAGS[FLAGS.a],\n};\nconst getAppendFileOpts = optsGenerator(appendFileDefaults);\nconst getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);\nconst realpathDefaults = optsDefaults;\nconst getRealpathOptions = optsGenerator(realpathDefaults);\nconst getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);\nconst mkdirDefaults = {\n    mode: 511 /* MODE.DIR */,\n    recursive: false,\n};\nconst getMkdirOptions = (options) => {\n    if (typeof options === \"number\")\n        return Object.assign({}, mkdirDefaults, { mode: options });\n    return Object.assign({}, mkdirDefaults, options);\n};\nconst rmdirDefaults = {\n    recursive: false,\n};\nconst getRmdirOptions = (options) => {\n    return Object.assign({}, rmdirDefaults, options);\n};\nconst getRmOpts = optsGenerator(optsDefaults);\nconst getRmOptsAndCb = optsAndCbGenerator(getRmOpts);\nconst readdirDefaults = {\n    encoding: \"utf8\",\n    withFileTypes: false,\n};\nconst getReaddirOptions = optsGenerator(readdirDefaults);\nconst getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);\nconst statDefaults = {\n    bigint: false,\n};\nconst getStatOptions = (options = {}) => Object.assign({}, statDefaults, options);\nconst getStatOptsAndCb = (options, callback) => typeof options === \"function\"\n    ? [getStatOptions(), options]\n    : [getStatOptions(options), validateCallback(callback)];\n// ---------------------------------------- Utility functions\nfunction getPathFromURLPosix(url) {\n    if (url.hostname !== \"\") {\n        throw new errors.TypeError(\"ERR_INVALID_FILE_URL_HOST\", process_1.default.platform);\n    }\n    const pathname = url.pathname;\n    for (let n = 0; n < pathname.length; n++) {\n        if (pathname[n] === \"%\") {\n            const third = pathname.codePointAt(n + 2) | 0x20;\n            if (pathname[n + 1] === \"2\" && third === 102) {\n                throw new errors.TypeError(\"ERR_INVALID_FILE_URL_PATH\", \"must not include encoded / characters\");\n            }\n        }\n    }\n    return decodeURIComponent(pathname);\n}\nfunction pathToFilename(path) {\n    if (typeof path !== \"string\" && !buffer_1.Buffer.isBuffer(path)) {\n        try {\n            if (!(path instanceof (__webpack_require__(/*! url */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/native-url/index.js\").URL)))\n                throw new TypeError(ERRSTR.PATH_STR);\n        }\n        catch (err) {\n            throw new TypeError(ERRSTR.PATH_STR);\n        }\n        path = getPathFromURLPosix(path);\n    }\n    const pathString = String(path);\n    nullCheck(pathString);\n    // return slash(pathString);\n    return pathString;\n}\nexports.pathToFilename = pathToFilename;\nlet resolve = (filename, base = process_1.default.cwd()) => resolveCrossPlatform(base, filename);\nif (isWin) {\n    const _resolve = resolve;\n    const { unixify } = __webpack_require__(/*! fs-monkey/lib/correctPath */ \"(pages-dir-browser)/./node_modules/fs-monkey/lib/correctPath.js\");\n    resolve = (filename, base) => unixify(_resolve(filename, base));\n}\nfunction filenameToSteps(filename, base) {\n    const fullPath = resolve(filename, base);\n    const fullPathSansSlash = fullPath.substr(1);\n    if (!fullPathSansSlash)\n        return [];\n    return fullPathSansSlash.split(sep);\n}\nexports.filenameToSteps = filenameToSteps;\nfunction pathToSteps(path) {\n    return filenameToSteps(pathToFilename(path));\n}\nexports.pathToSteps = pathToSteps;\nfunction dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {\n    if (buffer_1.Buffer.isBuffer(data))\n        return data.toString(encoding);\n    else if (data instanceof Uint8Array)\n        return (0, buffer_1.bufferFrom)(data).toString(encoding);\n    else\n        return String(data);\n}\nexports.dataToStr = dataToStr;\nfunction dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {\n    if (buffer_1.Buffer.isBuffer(data)) {\n        return data;\n    }\n    else if (data instanceof Uint8Array) {\n        return (0, buffer_1.bufferFrom)(data);\n    }\n    else {\n        // This \"encoding as ...\" is a little bit of a cheat.\n        return (0, buffer_1.bufferFrom)(String(data), encoding);\n    }\n}\nexports.dataToBuffer = dataToBuffer;\nfunction bufferToEncoding(buffer, encoding) {\n    if (!encoding || encoding === \"buffer\")\n        return buffer;\n    else\n        return buffer.toString(encoding);\n}\nexports.bufferToEncoding = bufferToEncoding;\nfunction nullCheck(path, callback) {\n    if ((\"\" + path).indexOf(\"\\u0000\") !== -1) {\n        const er = new Error(\"Path must be a string without null bytes\");\n        er.code = ENOENT;\n        if (typeof callback !== \"function\")\n            throw er;\n        process_1.default.nextTick(callback, er);\n        return false;\n    }\n    return true;\n}\nfunction _modeToNumber(mode, def) {\n    if (typeof mode === \"number\")\n        return mode;\n    if (typeof mode === \"string\")\n        return parseInt(mode, 8);\n    if (def)\n        return modeToNumber(def);\n    return undefined;\n}\nfunction modeToNumber(mode, def) {\n    const result = _modeToNumber(mode, def);\n    if (typeof result !== \"number\" || isNaN(result))\n        throw new TypeError(ERRSTR.MODE_INT);\n    return result;\n}\nfunction isFd(path) {\n    return path >>> 0 === path;\n}\nfunction validateFd(fd) {\n    if (!isFd(fd))\n        throw TypeError(ERRSTR.FD);\n}\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n    // tslint:disable-next-line triple-equals\n    if (typeof time === \"string\" && +time == time) {\n        return +time;\n    }\n    if (time instanceof Date) {\n        return time.getTime() / 1000;\n    }\n    if (isFinite(time)) {\n        if (time < 0) {\n            return Date.now() / 1000;\n        }\n        return time;\n    }\n    throw new Error(\"Cannot parse time: \" + time);\n}\nexports.toUnixTimestamp = toUnixTimestamp;\nfunction validateUid(uid) {\n    if (typeof uid !== \"number\")\n        throw TypeError(ERRSTR.UID);\n}\nfunction validateGid(gid) {\n    if (typeof gid !== \"number\")\n        throw TypeError(ERRSTR.GID);\n}\nfunction flattenJSON(nestedJSON) {\n    const flatJSON = {};\n    function flatten(pathPrefix, node) {\n        for (const path in node) {\n            const contentOrNode = node[path];\n            const joinedPath = join(pathPrefix, path);\n            if (typeof contentOrNode === \"string\") {\n                flatJSON[joinedPath] = contentOrNode;\n            }\n            else if (typeof contentOrNode === \"object\" &&\n                contentOrNode !== null &&\n                Object.keys(contentOrNode).length > 0) {\n                // empty directories need an explicit entry and therefore get handled in `else`, non-empty ones are implicitly considered\n                flatten(joinedPath, contentOrNode);\n            }\n            else {\n                // without this branch null, empty-object or non-object entries would not be handled in the same way\n                // by both fromJSON() and fromNestedJSON()\n                flatJSON[joinedPath] = null;\n            }\n        }\n    }\n    flatten(\"\", nestedJSON);\n    return flatJSON;\n}\n/**\n * `Volume` represents a file system.\n */\nclass Volume {\n    constructor(props = {}) {\n        // I-node number counter.\n        this.ino = 0;\n        // A mapping for i-node numbers to i-nodes (`Node`);\n        this.inodes = {};\n        // List of released i-node numbers, for reuse.\n        this.releasedInos = [];\n        // A mapping for file descriptors to `File`s.\n        this.fds = {};\n        // A list of reusable (opened and closed) file descriptors, that should be\n        // used first before creating a new file descriptor.\n        this.releasedFds = [];\n        // Max number of open files.\n        this.maxFiles = 10000;\n        // Current number of open files.\n        this.openFiles = 0;\n        this.promisesApi = (0, promises_1.default)(this);\n        this.statWatchers = {};\n        this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);\n        const root = this.createLink();\n        root.setNode(this.createNode(true));\n        const self = this; // tslint:disable-line no-this-assignment\n        this.StatWatcher = class extends StatWatcher {\n            constructor() {\n                super(self);\n            }\n        };\n        const _ReadStream = FsReadStream;\n        this.ReadStream = class extends _ReadStream {\n            constructor(...args) {\n                super(self, ...args);\n            }\n        };\n        const _WriteStream = FsWriteStream;\n        this.WriteStream = class extends _WriteStream {\n            constructor(...args) {\n                super(self, ...args);\n            }\n        };\n        this.FSWatcher = class extends FSWatcher {\n            constructor() {\n                super(self);\n            }\n        };\n        // root.setChild('.', root);\n        // root.getNode().nlink++;\n        // root.setChild('..', root);\n        // root.getNode().nlink++;\n        this.root = root;\n    }\n    static fromJSON(json, cwd) {\n        const vol = new Volume();\n        vol.fromJSON(json, cwd);\n        return vol;\n    }\n    static fromNestedJSON(json, cwd) {\n        const vol = new Volume();\n        vol.fromNestedJSON(json, cwd);\n        return vol;\n    }\n    get promises() {\n        if (this.promisesApi === null)\n            throw new Error(\"Promise is not supported in this environment.\");\n        return this.promisesApi;\n    }\n    createLink(parent, name, isDirectory = false, perm) {\n        if (!parent) {\n            return new this.props.Link(this, null, \"\");\n        }\n        if (!name) {\n            throw new Error(\"createLink: name cannot be empty\");\n        }\n        return parent.createChild(name, this.createNode(isDirectory, perm));\n    }\n    deleteLink(link) {\n        const parent = link.parent;\n        if (parent) {\n            parent.deleteChild(link);\n            return true;\n        }\n        return false;\n    }\n    newInoNumber() {\n        const releasedFd = this.releasedInos.pop();\n        if (releasedFd)\n            return releasedFd;\n        else {\n            this.ino = (this.ino + 1) % 0xffffffff;\n            return this.ino;\n        }\n    }\n    newFdNumber() {\n        const releasedFd = this.releasedFds.pop();\n        return typeof releasedFd === \"number\" ? releasedFd : Volume.fd--;\n    }\n    createNode(isDirectory = false, perm) {\n        const node = new this.props.Node(this.newInoNumber(), perm);\n        if (isDirectory)\n            node.setIsDirectory();\n        this.inodes[node.ino] = node;\n        return node;\n    }\n    getNode(ino) {\n        return this.inodes[ino];\n    }\n    deleteNode(node) {\n        node.del();\n        delete this.inodes[node.ino];\n        this.releasedInos.push(node.ino);\n    }\n    // Generates 6 character long random string, used by `mkdtemp`.\n    genRndStr() {\n        const str = (Math.random() + 1).toString(36).substr(2, 6);\n        if (str.length === 6)\n            return str;\n        else\n            return this.genRndStr();\n    }\n    // Returns a `Link` (hard link) referenced by path \"split\" into steps.\n    getLink(steps) {\n        return this.root.walk(steps);\n    }\n    // Just link `getLink`, but throws a correct user error, if link to found.\n    getLinkOrThrow(filename, funcName) {\n        const steps = filenameToSteps(filename);\n        const link = this.getLink(steps);\n        if (!link)\n            throw createError(ENOENT, funcName, filename);\n        return link;\n    }\n    // Just like `getLink`, but also dereference/resolves symbolic links.\n    getResolvedLink(filenameOrSteps) {\n        let steps = typeof filenameOrSteps === \"string\"\n            ? filenameToSteps(filenameOrSteps)\n            : filenameOrSteps;\n        let link = this.root;\n        let i = 0;\n        while (i < steps.length) {\n            const step = steps[i];\n            link = link.getChild(step);\n            if (!link)\n                return null;\n            const node = link.getNode();\n            if (node.isSymlink()) {\n                steps = node.symlink.concat(steps.slice(i + 1));\n                link = this.root;\n                i = 0;\n                continue;\n            }\n            i++;\n        }\n        return link;\n    }\n    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.\n    getResolvedLinkOrThrow(filename, funcName) {\n        const link = this.getResolvedLink(filename);\n        if (!link)\n            throw createError(ENOENT, funcName, filename);\n        return link;\n    }\n    resolveSymlinks(link) {\n        // let node: Node = link.getNode();\n        // while(link && node.isSymlink()) {\n        //     link = this.getLink(node.symlink);\n        //     if(!link) return null;\n        //     node = link.getNode();\n        // }\n        // return link;\n        return this.getResolvedLink(link.steps.slice(1));\n    }\n    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.\n    getLinkAsDirOrThrow(filename, funcName) {\n        const link = this.getLinkOrThrow(filename, funcName);\n        if (!link.getNode().isDirectory())\n            throw createError(ENOTDIR, funcName, filename);\n        return link;\n    }\n    // Get the immediate parent directory of the link.\n    getLinkParent(steps) {\n        return this.root.walk(steps, steps.length - 1);\n    }\n    getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {\n        const steps = filenameOrSteps instanceof Array\n            ? filenameOrSteps\n            : filenameToSteps(filenameOrSteps);\n        const link = this.getLinkParent(steps);\n        if (!link)\n            throw createError(ENOENT, funcName, sep + steps.join(sep));\n        if (!link.getNode().isDirectory())\n            throw createError(ENOTDIR, funcName, sep + steps.join(sep));\n        return link;\n    }\n    getFileByFd(fd) {\n        return this.fds[String(fd)];\n    }\n    getFileByFdOrThrow(fd, funcName) {\n        if (!isFd(fd))\n            throw TypeError(ERRSTR.FD);\n        const file = this.getFileByFd(fd);\n        if (!file)\n            throw createError(EBADF, funcName);\n        return file;\n    }\n    /**\n     * @todo This is not used anymore. Remove.\n     */\n    /*\n    private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {\n      if (typeof id === 'number') {\n        const file = this.getFileByFd(id);\n        if (!file) throw Error('File nto found');\n        return file.node;\n      } else {\n        const steps = pathToSteps(id as PathLike);\n        let link = this.getLink(steps);\n        if (link) return link.getNode();\n  \n        // Try creating a node if not found.\n        if (flags & O_CREAT) {\n          const dirLink = this.getLinkParent(steps);\n          if (dirLink) {\n            const name = steps[steps.length - 1];\n            link = this.createLink(dirLink, name, false, perm);\n            return link.getNode();\n          }\n        }\n  \n        throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));\n      }\n    }\n    */\n    wrapAsync(method, args, callback) {\n        validateCallback(callback);\n        (0, setImmediate_1.default)(() => {\n            let result;\n            try {\n                result = method.apply(this, args);\n            }\n            catch (err) {\n                callback(err);\n                return;\n            }\n            callback(null, result);\n        });\n    }\n    _toJSON(link = this.root, json = {}, path) {\n        let isEmpty = true;\n        let children = link.children;\n        if (link.getNode().isFile()) {\n            children = { [link.getName()]: link.parent.getChild(link.getName()) };\n            link = link.parent;\n        }\n        for (const name in children) {\n            isEmpty = false;\n            const child = link.getChild(name);\n            if (!child) {\n                throw new Error(\"_toJSON: unexpected undefined\");\n            }\n            const node = child.getNode();\n            if (node.isFile()) {\n                let filename = child.getPath();\n                if (path)\n                    filename = relative(path, filename);\n                json[filename] = node.getString();\n            }\n            else if (node.isDirectory()) {\n                this._toJSON(child, json, path);\n            }\n        }\n        let dirPath = link.getPath();\n        if (path)\n            dirPath = relative(path, dirPath);\n        if (dirPath && isEmpty) {\n            json[dirPath] = null;\n        }\n        return json;\n    }\n    toJSON(paths, json = {}, isRelative = false) {\n        const links = [];\n        if (paths) {\n            if (!(paths instanceof Array))\n                paths = [paths];\n            for (const path of paths) {\n                const filename = pathToFilename(path);\n                const link = this.getResolvedLink(filename);\n                if (!link)\n                    continue;\n                links.push(link);\n            }\n        }\n        else {\n            links.push(this.root);\n        }\n        if (!links.length)\n            return json;\n        for (const link of links)\n            this._toJSON(link, json, isRelative ? link.getPath() : \"\");\n        return json;\n    }\n    fromJSON(json, cwd = process_1.default.cwd()) {\n        for (let filename in json) {\n            const data = json[filename];\n            filename = resolve(filename, cwd);\n            if (typeof data === \"string\") {\n                const dir = dirname(filename);\n                this.mkdirpBase(dir, 511 /* MODE.DIR */);\n                this.writeFileSync(filename, data);\n            }\n            else {\n                this.mkdirpBase(filename, 511 /* MODE.DIR */);\n            }\n        }\n    }\n    fromNestedJSON(json, cwd) {\n        this.fromJSON(flattenJSON(json), cwd);\n    }\n    reset() {\n        this.ino = 0;\n        this.inodes = {};\n        this.releasedInos = [];\n        this.fds = {};\n        this.releasedFds = [];\n        this.openFiles = 0;\n        this.root = this.createLink();\n        this.root.setNode(this.createNode(true));\n    }\n    // Legacy interface\n    mountSync(mountpoint, json) {\n        this.fromJSON(json, mountpoint);\n    }\n    openLink(link, flagsNum, resolveSymlinks = true) {\n        if (this.openFiles >= this.maxFiles) {\n            // Too many open files.\n            throw createError(EMFILE, \"open\", link.getPath());\n        }\n        // Resolve symlinks.\n        let realLink = link;\n        if (resolveSymlinks)\n            realLink = this.resolveSymlinks(link);\n        if (!realLink)\n            throw createError(ENOENT, \"open\", link.getPath());\n        const node = realLink.getNode();\n        // Check whether node is a directory\n        if (node.isDirectory()) {\n            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)\n                throw createError(EISDIR, \"open\", link.getPath());\n        }\n        else {\n            if (flagsNum & O_DIRECTORY)\n                throw createError(ENOTDIR, \"open\", link.getPath());\n        }\n        // Check node permissions\n        if (!(flagsNum & O_WRONLY)) {\n            if (!node.canRead()) {\n                throw createError(EACCES, \"open\", link.getPath());\n            }\n        }\n        if (flagsNum & O_RDWR) {\n        }\n        const file = new this.props.File(link, node, flagsNum, this.newFdNumber());\n        this.fds[file.fd] = file;\n        this.openFiles++;\n        if (flagsNum & O_TRUNC)\n            file.truncate();\n        return file;\n    }\n    openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {\n        const steps = filenameToSteps(filename);\n        let link = resolveSymlinks\n            ? this.getResolvedLink(steps)\n            : this.getLink(steps);\n        if (link && flagsNum & O_EXCL)\n            throw createError(EEXIST, \"open\", filename);\n        // Try creating a new file, if it does not exist.\n        if (!link && flagsNum & O_CREAT) {\n            // const dirLink: Link = this.getLinkParent(steps);\n            const dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));\n            // if(!dirLink) throw createError(ENOENT, 'open', filename);\n            if (!dirLink)\n                throw createError(ENOENT, \"open\", sep + steps.join(sep));\n            if (flagsNum & O_CREAT && typeof modeNum === \"number\") {\n                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);\n            }\n        }\n        if (link)\n            return this.openLink(link, flagsNum, resolveSymlinks);\n        throw createError(ENOENT, \"open\", filename);\n    }\n    openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {\n        const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);\n        if (!file)\n            throw createError(ENOENT, \"open\", filename);\n        return file.fd;\n    }\n    openSync(path, flags, mode = 438 /* MODE.DEFAULT */) {\n        // Validate (1) mode; (2) path; (3) flags - in that order.\n        const modeNum = modeToNumber(mode);\n        const fileName = pathToFilename(path);\n        const flagsNum = flagsToNumber(flags);\n        return this.openBase(fileName, flagsNum, modeNum);\n    }\n    open(path, flags, a, b) {\n        let mode = a;\n        let callback = b;\n        if (typeof a === \"function\") {\n            mode = 438 /* MODE.DEFAULT */;\n            callback = a;\n        }\n        mode = mode || 438 /* MODE.DEFAULT */;\n        const modeNum = modeToNumber(mode);\n        const fileName = pathToFilename(path);\n        const flagsNum = flagsToNumber(flags);\n        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);\n    }\n    closeFile(file) {\n        if (!this.fds[file.fd])\n            return;\n        this.openFiles--;\n        delete this.fds[file.fd];\n        this.releasedFds.push(file.fd);\n    }\n    closeSync(fd) {\n        validateFd(fd);\n        const file = this.getFileByFdOrThrow(fd, \"close\");\n        this.closeFile(file);\n    }\n    close(fd, callback) {\n        validateFd(fd);\n        this.wrapAsync(this.closeSync, [fd], callback);\n    }\n    openFileOrGetById(id, flagsNum, modeNum) {\n        if (typeof id === \"number\") {\n            const file = this.fds[id];\n            if (!file)\n                throw createError(ENOENT);\n            return file;\n        }\n        else {\n            return this.openFile(pathToFilename(id), flagsNum, modeNum);\n        }\n    }\n    readBase(fd, buffer, offset, length, position) {\n        const file = this.getFileByFdOrThrow(fd);\n        return file.read(buffer, Number(offset), Number(length), position);\n    }\n    readSync(fd, buffer, offset, length, position) {\n        validateFd(fd);\n        return this.readBase(fd, buffer, offset, length, position);\n    }\n    read(fd, buffer, offset, length, position, callback) {\n        validateCallback(callback);\n        // This `if` branch is from Node.js\n        if (length === 0) {\n            return process_1.default.nextTick(() => {\n                if (callback)\n                    callback(null, 0, buffer);\n            });\n        }\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.readBase(fd, buffer, offset, length, position);\n                callback(null, bytes, buffer);\n            }\n            catch (err) {\n                callback(err);\n            }\n        });\n    }\n    readFileBase(id, flagsNum, encoding) {\n        let result;\n        const isUserFd = typeof id === \"number\";\n        const userOwnsFd = isUserFd && isFd(id);\n        let fd;\n        if (userOwnsFd)\n            fd = id;\n        else {\n            const filename = pathToFilename(id);\n            const steps = filenameToSteps(filename);\n            const link = this.getResolvedLink(steps);\n            if (link) {\n                const node = link.getNode();\n                if (node.isDirectory())\n                    throw createError(EISDIR, \"open\", link.getPath());\n            }\n            fd = this.openSync(id, flagsNum);\n        }\n        try {\n            result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);\n        }\n        finally {\n            if (!userOwnsFd) {\n                this.closeSync(fd);\n            }\n        }\n        return result;\n    }\n    readFileSync(file, options) {\n        const opts = getReadFileOptions(options);\n        const flagsNum = flagsToNumber(opts.flag);\n        return this.readFileBase(file, flagsNum, opts.encoding);\n    }\n    readFile(id, a, b) {\n        const [opts, callback] = optsAndCbGenerator(getReadFileOptions)(a, b);\n        const flagsNum = flagsToNumber(opts.flag);\n        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);\n    }\n    writeBase(fd, buf, offset, length, position) {\n        const file = this.getFileByFdOrThrow(fd, \"write\");\n        return file.write(buf, offset, length, position);\n    }\n    writeSync(fd, a, b, c, d) {\n        validateFd(fd);\n        let encoding;\n        let offset;\n        let length;\n        let position;\n        const isBuffer = typeof a !== \"string\";\n        if (isBuffer) {\n            offset = (b || 0) | 0;\n            length = c;\n            position = d;\n        }\n        else {\n            position = b;\n            encoding = c;\n        }\n        const buf = dataToBuffer(a, encoding);\n        if (isBuffer) {\n            if (typeof length === \"undefined\") {\n                length = buf.length;\n            }\n        }\n        else {\n            offset = 0;\n            length = buf.length;\n        }\n        return this.writeBase(fd, buf, offset, length, position);\n    }\n    write(fd, a, b, c, d, e) {\n        validateFd(fd);\n        let offset;\n        let length;\n        let position;\n        let encoding;\n        let callback;\n        const tipa = typeof a;\n        const tipb = typeof b;\n        const tipc = typeof c;\n        const tipd = typeof d;\n        if (tipa !== \"string\") {\n            if (tipb === \"function\") {\n                callback = b;\n            }\n            else if (tipc === \"function\") {\n                offset = b | 0;\n                callback = c;\n            }\n            else if (tipd === \"function\") {\n                offset = b | 0;\n                length = c;\n                callback = d;\n            }\n            else {\n                offset = b | 0;\n                length = c;\n                position = d;\n                callback = e;\n            }\n        }\n        else {\n            if (tipb === \"function\") {\n                callback = b;\n            }\n            else if (tipc === \"function\") {\n                position = b;\n                callback = c;\n            }\n            else if (tipd === \"function\") {\n                position = b;\n                encoding = c;\n                callback = d;\n            }\n        }\n        const buf = dataToBuffer(a, encoding);\n        if (tipa !== \"string\") {\n            if (typeof length === \"undefined\")\n                length = buf.length;\n        }\n        else {\n            offset = 0;\n            length = buf.length;\n        }\n        const cb = validateCallback(callback);\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.writeBase(fd, buf, offset, length, position);\n                if (tipa !== \"string\") {\n                    cb(null, bytes, buf);\n                }\n                else {\n                    cb(null, bytes, a);\n                }\n            }\n            catch (err) {\n                cb(err);\n            }\n        });\n    }\n    writeFileBase(id, buf, flagsNum, modeNum) {\n        // console.log('writeFileBase', id, buf, flagsNum, modeNum);\n        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);\n        // node.setBuffer(buf);\n        const isUserFd = typeof id === \"number\";\n        let fd;\n        if (isUserFd)\n            fd = id;\n        else {\n            fd = this.openBase(pathToFilename(id), flagsNum, modeNum);\n            // fd = this.openSync(id as PathLike, flagsNum, modeNum);\n        }\n        let offset = 0;\n        let length = buf.length;\n        let position = flagsNum & O_APPEND ? undefined : 0;\n        try {\n            while (length > 0) {\n                const written = this.writeSync(fd, buf, offset, length, position);\n                offset += written;\n                length -= written;\n                if (position !== undefined)\n                    position += written;\n            }\n        }\n        finally {\n            if (!isUserFd)\n                this.closeSync(fd);\n        }\n    }\n    writeFileSync(id, data, options) {\n        const opts = getWriteFileOptions(options);\n        const flagsNum = flagsToNumber(opts.flag);\n        const modeNum = modeToNumber(opts.mode);\n        const buf = dataToBuffer(data, opts.encoding);\n        this.writeFileBase(id, buf, flagsNum, modeNum);\n    }\n    writeFile(id, data, a, b) {\n        let options = a;\n        let callback = b;\n        if (typeof a === \"function\") {\n            options = writeFileDefaults;\n            callback = a;\n        }\n        const cb = validateCallback(callback);\n        const opts = getWriteFileOptions(options);\n        const flagsNum = flagsToNumber(opts.flag);\n        const modeNum = modeToNumber(opts.mode);\n        const buf = dataToBuffer(data, opts.encoding);\n        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);\n    }\n    linkBase(filename1, filename2) {\n        const steps1 = filenameToSteps(filename1);\n        const link1 = this.getLink(steps1);\n        if (!link1)\n            throw createError(ENOENT, \"link\", filename1, filename2);\n        const steps2 = filenameToSteps(filename2);\n        // Check new link directory exists.\n        const dir2 = this.getLinkParent(steps2);\n        if (!dir2)\n            throw createError(ENOENT, \"link\", filename1, filename2);\n        const name = steps2[steps2.length - 1];\n        // Check if new file already exists.\n        if (dir2.getChild(name))\n            throw createError(EEXIST, \"link\", filename1, filename2);\n        const node = link1.getNode();\n        node.nlink++;\n        dir2.createChild(name, node);\n    }\n    copyFileBase(src, dest, flags) {\n        const buf = this.readFileSync(src);\n        if (flags & COPYFILE_EXCL) {\n            if (this.existsSync(dest)) {\n                throw createError(EEXIST, \"copyFile\", src, dest);\n            }\n        }\n        if (flags & COPYFILE_FICLONE_FORCE) {\n            throw createError(ENOSYS, \"copyFile\", src, dest);\n        }\n        this.writeFileBase(dest, buf, FLAGS.w, 438 /* MODE.DEFAULT */);\n    }\n    copyFileSync(src, dest, flags) {\n        const srcFilename = pathToFilename(src);\n        const destFilename = pathToFilename(dest);\n        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);\n    }\n    copyFile(src, dest, a, b) {\n        const srcFilename = pathToFilename(src);\n        const destFilename = pathToFilename(dest);\n        let flags;\n        let callback;\n        if (typeof a === \"function\") {\n            flags = 0;\n            callback = a;\n        }\n        else {\n            flags = a;\n            callback = b;\n        }\n        validateCallback(callback);\n        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);\n    }\n    linkSync(existingPath, newPath) {\n        const existingPathFilename = pathToFilename(existingPath);\n        const newPathFilename = pathToFilename(newPath);\n        this.linkBase(existingPathFilename, newPathFilename);\n    }\n    link(existingPath, newPath, callback) {\n        const existingPathFilename = pathToFilename(existingPath);\n        const newPathFilename = pathToFilename(newPath);\n        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);\n    }\n    unlinkBase(filename) {\n        const steps = filenameToSteps(filename);\n        const link = this.getLink(steps);\n        if (!link)\n            throw createError(ENOENT, \"unlink\", filename);\n        // TODO: Check if it is file, dir, other...\n        if (link.length)\n            throw Error(\"Dir not empty...\");\n        this.deleteLink(link);\n        const node = link.getNode();\n        node.nlink--;\n        // When all hard links to i-node are deleted, remove the i-node, too.\n        if (node.nlink <= 0) {\n            this.deleteNode(node);\n        }\n    }\n    unlinkSync(path) {\n        const filename = pathToFilename(path);\n        this.unlinkBase(filename);\n    }\n    unlink(path, callback) {\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.unlinkBase, [filename], callback);\n    }\n    symlinkBase(targetFilename, pathFilename) {\n        const pathSteps = filenameToSteps(pathFilename);\n        // Check if directory exists, where we about to create a symlink.\n        const dirLink = this.getLinkParent(pathSteps);\n        if (!dirLink)\n            throw createError(ENOENT, \"symlink\", targetFilename, pathFilename);\n        const name = pathSteps[pathSteps.length - 1];\n        // Check if new file already exists.\n        if (dirLink.getChild(name))\n            throw createError(EEXIST, \"symlink\", targetFilename, pathFilename);\n        // Create symlink.\n        const symlink = dirLink.createChild(name);\n        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));\n        return symlink;\n    }\n    // `type` argument works only on Windows.\n    symlinkSync(target, path, type) {\n        const targetFilename = pathToFilename(target);\n        const pathFilename = pathToFilename(path);\n        this.symlinkBase(targetFilename, pathFilename);\n    }\n    symlink(target, path, a, b) {\n        const callback = validateCallback(typeof a === \"function\" ? a : b);\n        const targetFilename = pathToFilename(target);\n        const pathFilename = pathToFilename(path);\n        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);\n    }\n    realpathBase(filename, encoding) {\n        const steps = filenameToSteps(filename);\n        const realLink = this.getResolvedLink(steps);\n        if (!realLink)\n            throw createError(ENOENT, \"realpath\", filename);\n        const path = realLink.getPath();\n        return (0, encoding_1.strToEncoding)(path ? path : \"/\", encoding);\n    }\n    realpathSync(path, options) {\n        return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);\n    }\n    realpath(path, a, b) {\n        const [opts, callback] = getRealpathOptsAndCb(a, b);\n        const pathFilename = pathToFilename(path);\n        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);\n    }\n    lstatBase(filename, bigint = false, throwIfNoEntry = false) {\n        const link = this.getLink(filenameToSteps(filename));\n        if (link) {\n            return Stats_1.default.build(link.getNode(), bigint);\n        }\n        else if (!throwIfNoEntry) {\n            return undefined;\n        }\n        else {\n            throw createError(ENOENT, \"lstat\", filename);\n        }\n    }\n    lstatSync(path, options) {\n        const { throwIfNoEntry = true, bigint = false } = getStatOptions(options);\n        return this.lstatBase(pathToFilename(path), bigint, throwIfNoEntry);\n    }\n    lstat(path, a, b) {\n        const [{ throwIfNoEntry = true, bigint = false }, callback] = getStatOptsAndCb(a, b);\n        this.wrapAsync(this.lstatBase, [pathToFilename(path), bigint, throwIfNoEntry], callback);\n    }\n    statBase(filename, bigint = false, throwIfNoEntry = true) {\n        const link = this.getResolvedLink(filenameToSteps(filename));\n        if (link) {\n            return Stats_1.default.build(link.getNode(), bigint);\n        }\n        else if (!throwIfNoEntry) {\n            return undefined;\n        }\n        else {\n            throw createError(ENOENT, \"stat\", filename);\n        }\n    }\n    statSync(path, options) {\n        const { bigint = true, throwIfNoEntry = true } = getStatOptions(options);\n        return this.statBase(pathToFilename(path), bigint, throwIfNoEntry);\n    }\n    stat(path, a, b) {\n        const [{ bigint = false, throwIfNoEntry = true }, callback] = getStatOptsAndCb(a, b);\n        this.wrapAsync(this.statBase, [pathToFilename(path), bigint, throwIfNoEntry], callback);\n    }\n    fstatBase(fd, bigint = false) {\n        const file = this.getFileByFd(fd);\n        if (!file)\n            throw createError(EBADF, \"fstat\");\n        return Stats_1.default.build(file.node, bigint);\n    }\n    fstatSync(fd, options) {\n        return this.fstatBase(fd, getStatOptions(options).bigint);\n    }\n    fstat(fd, a, b) {\n        const [opts, callback] = getStatOptsAndCb(a, b);\n        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);\n    }\n    renameBase(oldPathFilename, newPathFilename) {\n        const link = this.getLink(filenameToSteps(oldPathFilename));\n        if (!link)\n            throw createError(ENOENT, \"rename\", oldPathFilename, newPathFilename);\n        // TODO: Check if it is directory, if non-empty, we cannot move it, right?\n        const newPathSteps = filenameToSteps(newPathFilename);\n        // Check directory exists for the new location.\n        const newPathDirLink = this.getLinkParent(newPathSteps);\n        if (!newPathDirLink)\n            throw createError(ENOENT, \"rename\", oldPathFilename, newPathFilename);\n        // TODO: Also treat cases with directories and symbolic links.\n        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html\n        // Remove hard link from old folder.\n        const oldLinkParent = link.parent;\n        if (oldLinkParent) {\n            oldLinkParent.deleteChild(link);\n        }\n        // Rename should overwrite the new path, if that exists.\n        const name = newPathSteps[newPathSteps.length - 1];\n        link.name = name;\n        link.steps = [...newPathDirLink.steps, name];\n        newPathDirLink.setChild(link.getName(), link);\n    }\n    renameSync(oldPath, newPath) {\n        const oldPathFilename = pathToFilename(oldPath);\n        const newPathFilename = pathToFilename(newPath);\n        this.renameBase(oldPathFilename, newPathFilename);\n    }\n    rename(oldPath, newPath, callback) {\n        const oldPathFilename = pathToFilename(oldPath);\n        const newPathFilename = pathToFilename(newPath);\n        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);\n    }\n    existsBase(filename) {\n        return !!this.statBase(filename);\n    }\n    existsSync(path) {\n        try {\n            return this.existsBase(pathToFilename(path));\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    exists(path, callback) {\n        const filename = pathToFilename(path);\n        if (typeof callback !== \"function\")\n            throw Error(ERRSTR.CB);\n        (0, setImmediate_1.default)(() => {\n            try {\n                callback(this.existsBase(filename));\n            }\n            catch (err) {\n                callback(false);\n            }\n        });\n    }\n    accessBase(filename, mode) {\n        const link = this.getLinkOrThrow(filename, \"access\");\n        // TODO: Verify permissions\n    }\n    accessSync(path, mode = F_OK) {\n        const filename = pathToFilename(path);\n        mode = mode | 0;\n        this.accessBase(filename, mode);\n    }\n    access(path, a, b) {\n        let mode = F_OK;\n        let callback;\n        if (typeof a !== \"function\") {\n            mode = a | 0; // cast to number\n            callback = validateCallback(b);\n        }\n        else {\n            callback = a;\n        }\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.accessBase, [filename, mode], callback);\n    }\n    appendFileSync(id, data, options = appendFileDefaults) {\n        const opts = getAppendFileOpts(options);\n        // force append behavior when using a supplied file descriptor\n        if (!opts.flag || isFd(id))\n            opts.flag = \"a\";\n        this.writeFileSync(id, data, opts);\n    }\n    appendFile(id, data, a, b) {\n        const [opts, callback] = getAppendFileOptsAndCb(a, b);\n        // force append behavior when using a supplied file descriptor\n        if (!opts.flag || isFd(id))\n            opts.flag = \"a\";\n        this.writeFile(id, data, opts, callback);\n    }\n    readdirBase(filename, options) {\n        const steps = filenameToSteps(filename);\n        const link = this.getResolvedLink(steps);\n        if (!link)\n            throw createError(ENOENT, \"readdir\", filename);\n        const node = link.getNode();\n        if (!node.isDirectory())\n            throw createError(ENOTDIR, \"scandir\", filename);\n        if (options.withFileTypes) {\n            const list = [];\n            for (const name in link.children) {\n                const child = link.getChild(name);\n                if (!child) {\n                    continue;\n                }\n                list.push(Dirent_1.default.build(child, options.encoding));\n            }\n            if (!isWin && options.encoding !== \"buffer\")\n                list.sort((a, b) => {\n                    if (a.name < b.name)\n                        return -1;\n                    if (a.name > b.name)\n                        return 1;\n                    return 0;\n                });\n            return list;\n        }\n        const list = [];\n        for (const name in link.children) {\n            list.push((0, encoding_1.strToEncoding)(name, options.encoding));\n        }\n        if (!isWin && options.encoding !== \"buffer\")\n            list.sort();\n        return list;\n    }\n    readdirSync(path, options) {\n        const opts = getReaddirOptions(options);\n        const filename = pathToFilename(path);\n        return this.readdirBase(filename, opts);\n    }\n    readdir(path, a, b) {\n        const [options, callback] = getReaddirOptsAndCb(a, b);\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.readdirBase, [filename, options], callback);\n    }\n    readlinkBase(filename, encoding) {\n        const link = this.getLinkOrThrow(filename, \"readlink\");\n        const node = link.getNode();\n        if (!node.isSymlink())\n            throw createError(EINVAL, \"readlink\", filename);\n        const str = sep + node.symlink.join(sep);\n        return (0, encoding_1.strToEncoding)(str, encoding);\n    }\n    readlinkSync(path, options) {\n        const opts = getDefaultOpts(options);\n        const filename = pathToFilename(path);\n        return this.readlinkBase(filename, opts.encoding);\n    }\n    readlink(path, a, b) {\n        const [opts, callback] = getDefaultOptsAndCb(a, b);\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);\n    }\n    fsyncBase(fd) {\n        this.getFileByFdOrThrow(fd, \"fsync\");\n    }\n    fsyncSync(fd) {\n        this.fsyncBase(fd);\n    }\n    fsync(fd, callback) {\n        this.wrapAsync(this.fsyncBase, [fd], callback);\n    }\n    fdatasyncBase(fd) {\n        this.getFileByFdOrThrow(fd, \"fdatasync\");\n    }\n    fdatasyncSync(fd) {\n        this.fdatasyncBase(fd);\n    }\n    fdatasync(fd, callback) {\n        this.wrapAsync(this.fdatasyncBase, [fd], callback);\n    }\n    ftruncateBase(fd, len) {\n        const file = this.getFileByFdOrThrow(fd, \"ftruncate\");\n        file.truncate(len);\n    }\n    ftruncateSync(fd, len) {\n        this.ftruncateBase(fd, len);\n    }\n    ftruncate(fd, a, b) {\n        const len = typeof a === \"number\" ? a : 0;\n        const callback = validateCallback(typeof a === \"number\" ? b : a);\n        this.wrapAsync(this.ftruncateBase, [fd, len], callback);\n    }\n    truncateBase(path, len) {\n        const fd = this.openSync(path, \"r+\");\n        try {\n            this.ftruncateSync(fd, len);\n        }\n        finally {\n            this.closeSync(fd);\n        }\n    }\n    truncateSync(id, len) {\n        if (isFd(id))\n            return this.ftruncateSync(id, len);\n        this.truncateBase(id, len);\n    }\n    truncate(id, a, b) {\n        const len = typeof a === \"number\" ? a : 0;\n        const callback = validateCallback(typeof a === \"number\" ? b : a);\n        if (isFd(id))\n            return this.ftruncate(id, len, callback);\n        this.wrapAsync(this.truncateBase, [id, len], callback);\n    }\n    futimesBase(fd, atime, mtime) {\n        const file = this.getFileByFdOrThrow(fd, \"futimes\");\n        const node = file.node;\n        node.atime = new Date(atime * 1000);\n        node.mtime = new Date(mtime * 1000);\n    }\n    futimesSync(fd, atime, mtime) {\n        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));\n    }\n    futimes(fd, atime, mtime, callback) {\n        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);\n    }\n    utimesBase(filename, atime, mtime) {\n        const fd = this.openSync(filename, \"r\");\n        try {\n            this.futimesBase(fd, atime, mtime);\n        }\n        finally {\n            this.closeSync(fd);\n        }\n    }\n    utimesSync(path, atime, mtime) {\n        this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));\n    }\n    utimes(path, atime, mtime, callback) {\n        this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);\n    }\n    mkdirBase(filename, modeNum) {\n        const steps = filenameToSteps(filename);\n        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.\n        if (!steps.length) {\n            throw createError(EEXIST, \"mkdir\", filename);\n        }\n        const dir = this.getLinkParentAsDirOrThrow(filename, \"mkdir\");\n        // Check path already exists.\n        const name = steps[steps.length - 1];\n        if (dir.getChild(name))\n            throw createError(EEXIST, \"mkdir\", filename);\n        dir.createChild(name, this.createNode(true, modeNum));\n    }\n    /**\n     * Creates directory tree recursively.\n     * @param filename\n     * @param modeNum\n     */\n    mkdirpBase(filename, modeNum) {\n        const steps = filenameToSteps(filename);\n        let link = this.root;\n        for (let i = 0; i < steps.length; i++) {\n            const step = steps[i];\n            if (!link.getNode().isDirectory())\n                throw createError(ENOTDIR, \"mkdir\", link.getPath());\n            const child = link.getChild(step);\n            if (child) {\n                if (child.getNode().isDirectory())\n                    link = child;\n                else\n                    throw createError(ENOTDIR, \"mkdir\", child.getPath());\n            }\n            else {\n                link = link.createChild(step, this.createNode(true, modeNum));\n            }\n        }\n    }\n    mkdirSync(path, options) {\n        const opts = getMkdirOptions(options);\n        const modeNum = modeToNumber(opts.mode, 0o777);\n        const filename = pathToFilename(path);\n        if (opts.recursive)\n            this.mkdirpBase(filename, modeNum);\n        else\n            this.mkdirBase(filename, modeNum);\n    }\n    mkdir(path, a, b) {\n        const opts = getMkdirOptions(a);\n        const callback = validateCallback(typeof a === \"function\" ? a : b);\n        const modeNum = modeToNumber(opts.mode, 0o777);\n        const filename = pathToFilename(path);\n        if (opts.recursive)\n            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);\n        else\n            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);\n    }\n    // legacy interface\n    mkdirpSync(path, mode) {\n        this.mkdirSync(path, { mode, recursive: true });\n    }\n    mkdirp(path, a, b) {\n        const mode = typeof a === \"function\" ? undefined : a;\n        const callback = validateCallback(typeof a === \"function\" ? a : b);\n        this.mkdir(path, { mode, recursive: true }, callback);\n    }\n    mkdtempBase(prefix, encoding, retry = 5) {\n        const filename = prefix + this.genRndStr();\n        try {\n            this.mkdirBase(filename, 511 /* MODE.DIR */);\n            return (0, encoding_1.strToEncoding)(filename, encoding);\n        }\n        catch (err) {\n            if (err.code === EEXIST) {\n                if (retry > 1)\n                    return this.mkdtempBase(prefix, encoding, retry - 1);\n                else\n                    throw Error(\"Could not create temp dir.\");\n            }\n            else\n                throw err;\n        }\n    }\n    mkdtempSync(prefix, options) {\n        const { encoding } = getDefaultOpts(options);\n        if (!prefix || typeof prefix !== \"string\")\n            throw new TypeError(\"filename prefix is required\");\n        nullCheck(prefix);\n        return this.mkdtempBase(prefix, encoding);\n    }\n    mkdtemp(prefix, a, b) {\n        const [{ encoding }, callback] = getDefaultOptsAndCb(a, b);\n        if (!prefix || typeof prefix !== \"string\")\n            throw new TypeError(\"filename prefix is required\");\n        if (!nullCheck(prefix))\n            return;\n        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);\n    }\n    rmdirBase(filename, options) {\n        const opts = getRmdirOptions(options);\n        const link = this.getLinkAsDirOrThrow(filename, \"rmdir\");\n        // Check directory is empty.\n        if (link.length && !opts.recursive)\n            throw createError(ENOTEMPTY, \"rmdir\", filename);\n        this.deleteLink(link);\n    }\n    rmdirSync(path, options) {\n        this.rmdirBase(pathToFilename(path), options);\n    }\n    rmdir(path, a, b) {\n        const opts = getRmdirOptions(a);\n        const callback = validateCallback(typeof a === \"function\" ? a : b);\n        this.wrapAsync(this.rmdirBase, [pathToFilename(path), opts], callback);\n    }\n    rmBase(filename, options = {}) {\n        const link = this.getResolvedLink(filename);\n        if (!link) {\n            // \"stat\" is used to match Node's native error message.\n            if (!options.force)\n                throw createError(ENOENT, \"stat\", filename);\n            return;\n        }\n        if (link.getNode().isDirectory()) {\n            if (!options.recursive) {\n                throw createError(ERR_FS_EISDIR, \"rm\", filename);\n            }\n        }\n        this.deleteLink(link);\n    }\n    rmSync(path, options) {\n        this.rmBase(pathToFilename(path), options);\n    }\n    rm(path, a, b) {\n        const [opts, callback] = getRmOptsAndCb(a, b);\n        this.wrapAsync(this.rmBase, [pathToFilename(path), opts], callback);\n    }\n    fchmodBase(fd, modeNum) {\n        const file = this.getFileByFdOrThrow(fd, \"fchmod\");\n        file.chmod(modeNum);\n    }\n    fchmodSync(fd, mode) {\n        this.fchmodBase(fd, modeToNumber(mode));\n    }\n    fchmod(fd, mode, callback) {\n        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);\n    }\n    chmodBase(filename, modeNum) {\n        const fd = this.openSync(filename, \"r\");\n        try {\n            this.fchmodBase(fd, modeNum);\n        }\n        finally {\n            this.closeSync(fd);\n        }\n    }\n    chmodSync(path, mode) {\n        const modeNum = modeToNumber(mode);\n        const filename = pathToFilename(path);\n        this.chmodBase(filename, modeNum);\n    }\n    chmod(path, mode, callback) {\n        const modeNum = modeToNumber(mode);\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);\n    }\n    lchmodBase(filename, modeNum) {\n        const fd = this.openBase(filename, O_RDWR, 0, false);\n        try {\n            this.fchmodBase(fd, modeNum);\n        }\n        finally {\n            this.closeSync(fd);\n        }\n    }\n    lchmodSync(path, mode) {\n        const modeNum = modeToNumber(mode);\n        const filename = pathToFilename(path);\n        this.lchmodBase(filename, modeNum);\n    }\n    lchmod(path, mode, callback) {\n        const modeNum = modeToNumber(mode);\n        const filename = pathToFilename(path);\n        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);\n    }\n    fchownBase(fd, uid, gid) {\n        this.getFileByFdOrThrow(fd, \"fchown\").chown(uid, gid);\n    }\n    fchownSync(fd, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.fchownBase(fd, uid, gid);\n    }\n    fchown(fd, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);\n    }\n    chownBase(filename, uid, gid) {\n        const link = this.getResolvedLinkOrThrow(filename, \"chown\");\n        const node = link.getNode();\n        node.chown(uid, gid);\n        // if(node.isFile() || node.isSymlink()) {\n        //\n        // } else if(node.isDirectory()) {\n        //\n        // } else {\n        // TODO: What do we do here?\n        // }\n    }\n    chownSync(path, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.chownBase(pathToFilename(path), uid, gid);\n    }\n    chown(path, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);\n    }\n    lchownBase(filename, uid, gid) {\n        this.getLinkOrThrow(filename, \"lchown\").getNode().chown(uid, gid);\n    }\n    lchownSync(path, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.lchownBase(pathToFilename(path), uid, gid);\n    }\n    lchown(path, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);\n    }\n    watchFile(path, a, b) {\n        const filename = pathToFilename(path);\n        let options = a;\n        let listener = b;\n        if (typeof options === \"function\") {\n            listener = a;\n            options = null;\n        }\n        if (typeof listener !== \"function\") {\n            throw Error('\"watchFile()\" requires a listener function');\n        }\n        let interval = 5007;\n        let persistent = true;\n        if (options && typeof options === \"object\") {\n            if (typeof options.interval === \"number\")\n                interval = options.interval;\n            if (typeof options.persistent === \"boolean\")\n                persistent = options.persistent;\n        }\n        let watcher = this.statWatchers[filename];\n        if (!watcher) {\n            watcher = new this.StatWatcher();\n            watcher.start(filename, persistent, interval);\n            this.statWatchers[filename] = watcher;\n        }\n        watcher.addListener(\"change\", listener);\n        return watcher;\n    }\n    unwatchFile(path, listener) {\n        const filename = pathToFilename(path);\n        const watcher = this.statWatchers[filename];\n        if (!watcher)\n            return;\n        if (typeof listener === \"function\") {\n            watcher.removeListener(\"change\", listener);\n        }\n        else {\n            watcher.removeAllListeners(\"change\");\n        }\n        if (watcher.listenerCount(\"change\") === 0) {\n            watcher.stop();\n            delete this.statWatchers[filename];\n        }\n    }\n    createReadStream(path, options) {\n        return new this.ReadStream(path, options);\n    }\n    createWriteStream(path, options) {\n        return new this.WriteStream(path, options);\n    }\n    // watch(path: PathLike): FSWatcher;\n    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;\n    watch(path, options, listener) {\n        const filename = pathToFilename(path);\n        let givenOptions = options;\n        if (typeof options === \"function\") {\n            listener = options;\n            givenOptions = null;\n        }\n        // tslint:disable-next-line prefer-const\n        let { persistent, recursive, encoding } = getDefaultOpts(givenOptions);\n        if (persistent === undefined)\n            persistent = true;\n        if (recursive === undefined)\n            recursive = false;\n        const watcher = new this.FSWatcher();\n        watcher.start(filename, persistent, recursive, encoding);\n        if (listener) {\n            watcher.addListener(\"change\", listener);\n        }\n        return watcher;\n    }\n}\nexports.Volume = Volume;\n/**\n * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially\n * up, so here, in order not to conflict with them, we choose some big number and descrease\n * the file descriptor of every new opened file.\n * @type {number}\n * @todo This should not be static, right?\n */\nVolume.fd = 0x7fffffff;\nfunction emitStop(self) {\n    self.emit(\"stop\");\n}\nclass StatWatcher extends events_1.EventEmitter {\n    constructor(vol) {\n        super();\n        this.onInterval = () => {\n            try {\n                const stats = this.vol.statSync(this.filename);\n                if (this.hasChanged(stats)) {\n                    this.emit(\"change\", stats, this.prev);\n                    this.prev = stats;\n                }\n            }\n            finally {\n                this.loop();\n            }\n        };\n        this.vol = vol;\n    }\n    loop() {\n        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);\n    }\n    hasChanged(stats) {\n        // if(!this.prev) return false;\n        if (stats.mtimeMs > this.prev.mtimeMs)\n            return true;\n        if (stats.nlink !== this.prev.nlink)\n            return true;\n        return false;\n    }\n    start(path, persistent = true, interval = 5007) {\n        this.filename = pathToFilename(path);\n        this.setTimeout = persistent\n            ? setTimeout.bind(typeof globalThis !== \"undefined\" ? globalThis : __webpack_require__.g)\n            : setTimeoutUnref_1.default;\n        this.interval = interval;\n        this.prev = this.vol.statSync(this.filename);\n        this.loop();\n    }\n    stop() {\n        clearTimeout(this.timeoutRef);\n        process_1.default.nextTick(emitStop, this);\n    }\n}\nexports.StatWatcher = StatWatcher;\nvar pool;\nfunction allocNewPool(poolSize) {\n    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);\n    pool.used = 0;\n}\nutil.inherits(FsReadStream, stream_1.Readable);\nexports.ReadStream = FsReadStream;\nfunction FsReadStream(vol, path, options) {\n    if (!(this instanceof FsReadStream))\n        return new FsReadStream(vol, path, options);\n    this._vol = vol;\n    // a little bit bigger buffer and water marks by default\n    options = Object.assign({}, getOptions(options, {}));\n    if (options.highWaterMark === undefined)\n        options.highWaterMark = 64 * 1024;\n    stream_1.Readable.call(this, options);\n    this.path = pathToFilename(path);\n    this.fd = options.fd === undefined ? null : options.fd;\n    this.flags = options.flags === undefined ? \"r\" : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n    this.start = options.start;\n    this.end = options.end;\n    this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n    this.pos = undefined;\n    this.bytesRead = 0;\n    if (this.start !== undefined) {\n        if (typeof this.start !== \"number\") {\n            throw new TypeError('\"start\" option must be a Number');\n        }\n        if (this.end === undefined) {\n            this.end = Infinity;\n        }\n        else if (typeof this.end !== \"number\") {\n            throw new TypeError('\"end\" option must be a Number');\n        }\n        if (this.start > this.end) {\n            throw new Error('\"start\" option must be <= \"end\" option');\n        }\n        this.pos = this.start;\n    }\n    if (typeof this.fd !== \"number\")\n        this.open();\n    this.on(\"end\", function () {\n        if (this.autoClose) {\n            if (this.destroy)\n                this.destroy();\n        }\n    });\n}\nFsReadStream.prototype.open = function () {\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.open(this.path, this.flags, this.mode, (er, fd) => {\n        if (er) {\n            if (self.autoClose) {\n                if (self.destroy)\n                    self.destroy();\n            }\n            self.emit(\"error\", er);\n            return;\n        }\n        self.fd = fd;\n        self.emit(\"open\", fd);\n        // start the flow of data.\n        self.read();\n    });\n};\nFsReadStream.prototype._read = function (n) {\n    if (typeof this.fd !== \"number\") {\n        return this.once(\"open\", function () {\n            this._read(n);\n        });\n    }\n    if (this.destroyed)\n        return;\n    if (!pool || pool.length - pool.used < kMinPoolSpace) {\n        // discard the old pool.\n        allocNewPool(this._readableState.highWaterMark);\n    }\n    // Grab another reference to the pool in the case that while we're\n    // in the thread pool another read() finishes up the pool, and\n    // allocates a new one.\n    var thisPool = pool;\n    var toRead = Math.min(pool.length - pool.used, n);\n    var start = pool.used;\n    if (this.pos !== undefined)\n        toRead = Math.min(this.end - this.pos + 1, toRead);\n    // already read everything we were supposed to read!\n    // treat as EOF.\n    if (toRead <= 0)\n        return this.push(null);\n    // the actual read.\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n    // move the pool positions, and internal position for reading.\n    if (this.pos !== undefined)\n        this.pos += toRead;\n    pool.used += toRead;\n    function onread(er, bytesRead) {\n        if (er) {\n            if (self.autoClose && self.destroy) {\n                self.destroy();\n            }\n            self.emit(\"error\", er);\n        }\n        else {\n            var b = null;\n            if (bytesRead > 0) {\n                self.bytesRead += bytesRead;\n                b = thisPool.slice(start, start + bytesRead);\n            }\n            self.push(b);\n        }\n    }\n};\nFsReadStream.prototype._destroy = function (err, cb) {\n    this.close((err2) => {\n        cb(err || err2);\n    });\n};\nFsReadStream.prototype.close = function (cb) {\n    if (cb)\n        this.once(\"close\", cb);\n    if (this.closed || typeof this.fd !== \"number\") {\n        if (typeof this.fd !== \"number\") {\n            this.once(\"open\", closeOnOpen);\n            return;\n        }\n        return process_1.default.nextTick(() => this.emit(\"close\"));\n    }\n    // Since Node 18, there is only a getter for '.closed'.\n    // The first branch mimics other setters from Readable.\n    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/readable.js#L1243\n    if (typeof this._readableState?.closed === \"boolean\") {\n        this._readableState.closed = true;\n    }\n    else {\n        this.closed = true;\n    }\n    this._vol.close(this.fd, (er) => {\n        if (er)\n            this.emit(\"error\", er);\n        else\n            this.emit(\"close\");\n    });\n    this.fd = null;\n};\n// needed because as it will be called with arguments\n// that does not match this.close() signature\nfunction closeOnOpen(fd) {\n    this.close();\n}\nutil.inherits(FsWriteStream, stream_1.Writable);\nexports.WriteStream = FsWriteStream;\nfunction FsWriteStream(vol, path, options) {\n    if (!(this instanceof FsWriteStream))\n        return new FsWriteStream(vol, path, options);\n    this._vol = vol;\n    options = Object.assign({}, getOptions(options, {}));\n    stream_1.Writable.call(this, options);\n    this.path = pathToFilename(path);\n    this.fd = options.fd === undefined ? null : options.fd;\n    this.flags = options.flags === undefined ? \"w\" : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n    this.start = options.start;\n    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n    this.pos = undefined;\n    this.bytesWritten = 0;\n    if (this.start !== undefined) {\n        if (typeof this.start !== \"number\") {\n            throw new TypeError('\"start\" option must be a Number');\n        }\n        if (this.start < 0) {\n            throw new Error('\"start\" must be >= zero');\n        }\n        this.pos = this.start;\n    }\n    if (options.encoding)\n        this.setDefaultEncoding(options.encoding);\n    if (typeof this.fd !== \"number\")\n        this.open();\n    // dispose on finish.\n    this.once(\"finish\", function () {\n        if (this.autoClose) {\n            this.close();\n        }\n    });\n}\nFsWriteStream.prototype.open = function () {\n    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {\n        if (er) {\n            if (this.autoClose && this.destroy) {\n                this.destroy();\n            }\n            this.emit(\"error\", er);\n            return;\n        }\n        this.fd = fd;\n        this.emit(\"open\", fd);\n    }.bind(this));\n};\nFsWriteStream.prototype._write = function (data, encoding, cb) {\n    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))\n        return this.emit(\"error\", new Error(\"Invalid data\"));\n    if (typeof this.fd !== \"number\") {\n        return this.once(\"open\", function () {\n            this._write(data, encoding, cb);\n        });\n    }\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {\n        if (er) {\n            if (self.autoClose && self.destroy) {\n                self.destroy();\n            }\n            return cb(er);\n        }\n        self.bytesWritten += bytes;\n        cb();\n    });\n    if (this.pos !== undefined)\n        this.pos += data.length;\n};\nFsWriteStream.prototype._writev = function (data, cb) {\n    if (typeof this.fd !== \"number\") {\n        return this.once(\"open\", function () {\n            this._writev(data, cb);\n        });\n    }\n    const self = this; // tslint:disable-line no-this-assignment\n    const len = data.length;\n    const chunks = new Array(len);\n    var size = 0;\n    for (var i = 0; i < len; i++) {\n        var chunk = data[i].chunk;\n        chunks[i] = chunk;\n        size += chunk.length;\n    }\n    const buf = buffer_1.Buffer.concat(chunks);\n    this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {\n        if (er) {\n            if (self.destroy)\n                self.destroy();\n            return cb(er);\n        }\n        self.bytesWritten += bytes;\n        cb();\n    });\n    if (this.pos !== undefined)\n        this.pos += size;\n};\nFsWriteStream.prototype.close = function (cb) {\n    if (cb)\n        this.once(\"close\", cb);\n    if (this.closed || typeof this.fd !== \"number\") {\n        if (typeof this.fd !== \"number\") {\n            this.once(\"open\", closeOnOpen);\n            return;\n        }\n        return process_1.default.nextTick(() => this.emit(\"close\"));\n    }\n    // Since Node 18, there is only a getter for '.closed'.\n    // The first branch mimics other setters from Writable.\n    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/writable.js#L766\n    if (typeof this._writableState?.closed === \"boolean\") {\n        this._writableState.closed = true;\n    }\n    else {\n        this.closed = true;\n    }\n    this._vol.close(this.fd, (er) => {\n        if (er)\n            this.emit(\"error\", er);\n        else\n            this.emit(\"close\");\n    });\n    this.fd = null;\n};\nFsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;\n// There is no shutdown() for files.\nFsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;\n// ---------------------------------------- FSWatcher\nclass FSWatcher extends events_1.EventEmitter {\n    constructor(vol) {\n        super();\n        this._filename = \"\";\n        this._filenameEncoded = \"\";\n        // _persistent: boolean = true;\n        this._recursive = false;\n        this._encoding = encoding_1.ENCODING_UTF8;\n        this._onNodeChange = () => {\n            this._emit(\"change\");\n        };\n        this._onParentChild = (link) => {\n            if (link.getName() === this._getName()) {\n                this._emit(\"rename\");\n            }\n        };\n        this._emit = (type) => {\n            this.emit(\"change\", type, this._filenameEncoded);\n        };\n        this._persist = () => {\n            this._timer = setTimeout(this._persist, 1e6);\n        };\n        this._vol = vol;\n        // TODO: Emit \"error\" messages when watching.\n        // this._handle.onchange = function(status, eventType, filename) {\n        //     if (status < 0) {\n        //         self._handle.close();\n        //         const error = !filename ?\n        //             errnoException(status, 'Error watching file for changes:') :\n        //             errnoException(status, `Error watching file ${filename} for changes:`);\n        //         error.filename = filename;\n        //         self.emit('error', error);\n        //     } else {\n        //         self.emit('change', eventType, filename);\n        //     }\n        // };\n    }\n    _getName() {\n        return this._steps[this._steps.length - 1];\n    }\n    start(path, persistent = true, recursive = false, encoding = encoding_1.ENCODING_UTF8) {\n        this._filename = pathToFilename(path);\n        this._steps = filenameToSteps(this._filename);\n        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);\n        // this._persistent = persistent;\n        this._recursive = recursive;\n        this._encoding = encoding;\n        try {\n            this._link = this._vol.getLinkOrThrow(this._filename, \"FSWatcher\");\n        }\n        catch (err) {\n            const error = new Error(`watch ${this._filename} ${err.code}`);\n            error.code = err.code;\n            error.errno = err.code;\n            throw error;\n        }\n        this._link.getNode().on(\"change\", this._onNodeChange);\n        this._link.on(\"child:add\", this._onNodeChange);\n        this._link.on(\"child:delete\", this._onNodeChange);\n        const parent = this._link.parent;\n        if (parent) {\n            // parent.on('child:add', this._onParentChild);\n            parent.setMaxListeners(parent.getMaxListeners() + 1);\n            parent.on(\"child:delete\", this._onParentChild);\n        }\n        if (persistent)\n            this._persist();\n    }\n    close() {\n        clearTimeout(this._timer);\n        this._link.getNode().removeListener(\"change\", this._onNodeChange);\n        const parent = this._link.parent;\n        if (parent) {\n            // parent.removeListener('child:add', this._onParentChild);\n            parent.removeListener(\"child:delete\", this._onParentChild);\n        }\n    }\n}\nexports.FSWatcher = FSWatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY293YXNtL21lbWZzL2xpYi92b2x1bWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGFBQWE7QUFDelEsbUJBQW1CLG1CQUFPLENBQUMsNEZBQU07QUFDakMsZUFBZSxtQkFBTyxDQUFDLDRFQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLGtHQUFtQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsa0ZBQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsa0dBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLGdHQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFRO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFZO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDZEQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFZO0FBQ3ZDO0FBQ0EsUUFBUSxvSUFBb0k7QUFDNUksUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLFFBQVE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVDQUF1QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBTTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsRUFBRSxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAY293YXNtXFxtZW1mc1xcbGliXFx2b2x1bWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZTV2F0Y2hlciA9IGV4cG9ydHMuU3RhdFdhdGNoZXIgPSBleHBvcnRzLlZvbHVtZSA9IGV4cG9ydHMudG9Vbml4VGltZXN0YW1wID0gZXhwb3J0cy5idWZmZXJUb0VuY29kaW5nID0gZXhwb3J0cy5kYXRhVG9CdWZmZXIgPSBleHBvcnRzLmRhdGFUb1N0ciA9IGV4cG9ydHMucGF0aFRvU3RlcHMgPSBleHBvcnRzLmZpbGVuYW1lVG9TdGVwcyA9IGV4cG9ydHMucGF0aFRvRmlsZW5hbWUgPSBleHBvcnRzLmZsYWdzVG9OdW1iZXIgPSBleHBvcnRzLkZMQUdTID0gdm9pZCAwO1xuY29uc3QgcGF0aE1vZHVsZSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3Qgbm9kZV8xID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcbmNvbnN0IFN0YXRzXzEgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcbmNvbnN0IERpcmVudF8xID0gcmVxdWlyZShcIi4vRGlyZW50XCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9idWZmZXJcIik7XG5jb25zdCBzZXRJbW1lZGlhdGVfMSA9IHJlcXVpcmUoXCIuL3NldEltbWVkaWF0ZVwiKTtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NcIik7XG5jb25zdCBzZXRUaW1lb3V0VW5yZWZfMSA9IHJlcXVpcmUoXCIuL3NldFRpbWVvdXRVbnJlZlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvZXJyb3JzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgcHJvbWlzZXNfMSA9IHJlcXVpcmUoXCIuL3Byb21pc2VzXCIpO1xuY29uc3QgcmVzb2x2ZUNyb3NzUGxhdGZvcm0gPSBwYXRoTW9kdWxlLnJlc29sdmU7XG5jb25zdCB7IE9fUkRPTkxZLCBPX1dST05MWSwgT19SRFdSLCBPX0NSRUFULCBPX0VYQ0wsIE9fVFJVTkMsIE9fQVBQRU5ELCBPX1NZTkMsIE9fRElSRUNUT1JZLCBGX09LLCBDT1BZRklMRV9FWENMLCBDT1BZRklMRV9GSUNMT05FX0ZPUkNFLCB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuY29uc3QgeyBzZXAsIHJlbGF0aXZlLCBqb2luLCBkaXJuYW1lIH0gPSBwYXRoTW9kdWxlLnBvc2l4XG4gICAgPyBwYXRoTW9kdWxlLnBvc2l4XG4gICAgOiBwYXRoTW9kdWxlO1xuY29uc3QgaXNXaW4gPSBwcm9jZXNzXzEuZGVmYXVsdC5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuY29uc3Qga01pblBvb2xTcGFjZSA9IDEyODtcbi8vIGNvbnN0IGtNYXhMZW5ndGggPSByZXF1aXJlKCdidWZmZXInKS5rTWF4TGVuZ3RoO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFcnJvciBtZXNzYWdlc1xuLy8gVE9ETzogVXNlIGBpbnRlcm5hbC9lcnJvcnMuanNgIGluIHRoZSBmdXR1cmUuXG5jb25zdCBFUlJTVFIgPSB7XG4gICAgUEFUSF9TVFI6IFwicGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlclwiLFxuICAgIC8vIEZEOiAgICAgICAgICAgICAnZmlsZSBkZXNjcmlwdG9yIG11c3QgYmUgYSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcicsXG4gICAgRkQ6IFwiZmQgbXVzdCBiZSBhIGZpbGUgZGVzY3JpcHRvclwiLFxuICAgIE1PREVfSU5UOiBcIm1vZGUgbXVzdCBiZSBhbiBpbnRcIixcbiAgICBDQjogXCJjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgICBVSUQ6IFwidWlkIG11c3QgYmUgYW4gdW5zaWduZWQgaW50XCIsXG4gICAgR0lEOiBcImdpZCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludFwiLFxuICAgIExFTjogXCJsZW4gbXVzdCBiZSBhbiBpbnRlZ2VyXCIsXG4gICAgQVRJTUU6IFwiYXRpbWUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsXG4gICAgTVRJTUU6IFwibXRpbWUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsXG4gICAgUFJFRklYOiBcImZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZFwiLFxuICAgIEJVRkZFUjogXCJidWZmZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBCdWZmZXIgb3IgU3RhdGljQnVmZmVyXCIsXG4gICAgT0ZGU0VUOiBcIm9mZnNldCBtdXN0IGJlIGFuIGludGVnZXJcIixcbiAgICBMRU5HVEg6IFwibGVuZ3RoIG11c3QgYmUgYW4gaW50ZWdlclwiLFxuICAgIFBPU0lUSU9OOiBcInBvc2l0aW9uIG11c3QgYmUgYW4gaW50ZWdlclwiLFxufTtcbmNvbnN0IEVSUlNUUl9PUFRTID0gKHRpcGVvZikgPT4gYEV4cGVjdGVkIG9wdGlvbnMgdG8gYmUgZWl0aGVyIGFuIG9iamVjdCBvciBhIHN0cmluZywgYnV0IGdvdCAke3RpcGVvZn0gaW5zdGVhZGA7XG4vLyBjb25zdCBFUlJTVFJfRkxBRyA9IGZsYWcgPT4gYFVua25vd24gZmlsZSBvcGVuIGZsYWc6ICR7ZmxhZ31gO1xuY29uc3QgRU5PRU5UID0gXCJFTk9FTlRcIjtcbmNvbnN0IEVCQURGID0gXCJFQkFERlwiO1xuY29uc3QgRUlOVkFMID0gXCJFSU5WQUxcIjtcbmNvbnN0IEVQRVJNID0gXCJFUEVSTVwiO1xuY29uc3QgRVBST1RPID0gXCJFUFJPVE9cIjtcbmNvbnN0IEVFWElTVCA9IFwiRUVYSVNUXCI7XG5jb25zdCBFTk9URElSID0gXCJFTk9URElSXCI7XG5jb25zdCBFTUZJTEUgPSBcIkVNRklMRVwiO1xuY29uc3QgRUFDQ0VTID0gXCJFQUNDRVNcIjtcbmNvbnN0IEVJU0RJUiA9IFwiRUlTRElSXCI7XG5jb25zdCBFTk9URU1QVFkgPSBcIkVOT1RFTVBUWVwiO1xuY29uc3QgRU5PU1lTID0gXCJFTk9TWVNcIjtcbmNvbnN0IEVSUl9GU19FSVNESVIgPSBcIkVSUl9GU19FSVNESVJcIjtcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yQ29kZSwgZnVuYyA9IFwiXCIsIHBhdGggPSBcIlwiLCBwYXRoMiA9IFwiXCIpIHtcbiAgICBsZXQgcGF0aEZvcm1hdHRlZCA9IFwiXCI7XG4gICAgaWYgKHBhdGgpXG4gICAgICAgIHBhdGhGb3JtYXR0ZWQgPSBgICcke3BhdGh9J2A7XG4gICAgaWYgKHBhdGgyKVxuICAgICAgICBwYXRoRm9ybWF0dGVkICs9IGAgLT4gJyR7cGF0aDJ9J2A7XG4gICAgc3dpdGNoIChlcnJvckNvZGUpIHtcbiAgICAgICAgY2FzZSBFTk9FTlQ6XG4gICAgICAgICAgICByZXR1cm4gYEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVCQURGOlxuICAgICAgICAgICAgcmV0dXJuIGBFQkFERjogYmFkIGZpbGUgZGVzY3JpcHRvciwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVJTlZBTDpcbiAgICAgICAgICAgIHJldHVybiBgRUlOVkFMOiBpbnZhbGlkIGFyZ3VtZW50LCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRVBFUk06XG4gICAgICAgICAgICByZXR1cm4gYEVQRVJNOiBvcGVyYXRpb24gbm90IHBlcm1pdHRlZCwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVQUk9UTzpcbiAgICAgICAgICAgIHJldHVybiBgRVBST1RPOiBwcm90b2NvbCBlcnJvciwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVFWElTVDpcbiAgICAgICAgICAgIHJldHVybiBgRUVYSVNUOiBmaWxlIGFscmVhZHkgZXhpc3RzLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRU5PVERJUjpcbiAgICAgICAgICAgIHJldHVybiBgRU5PVERJUjogbm90IGEgZGlyZWN0b3J5LCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRUlTRElSOlxuICAgICAgICAgICAgcmV0dXJuIGBFSVNESVI6IGlsbGVnYWwgb3BlcmF0aW9uIG9uIGEgZGlyZWN0b3J5LCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRUFDQ0VTOlxuICAgICAgICAgICAgcmV0dXJuIGBFQUNDRVM6IHBlcm1pc3Npb24gZGVuaWVkLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRU5PVEVNUFRZOlxuICAgICAgICAgICAgcmV0dXJuIGBFTk9URU1QVFk6IGRpcmVjdG9yeSBub3QgZW1wdHksICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFTUZJTEU6XG4gICAgICAgICAgICByZXR1cm4gYEVNRklMRTogdG9vIG1hbnkgb3BlbiBmaWxlcywgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVOT1NZUzpcbiAgICAgICAgICAgIHJldHVybiBgRU5PU1lTOiBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQsICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFUlJfRlNfRUlTRElSOlxuICAgICAgICAgICAgcmV0dXJuIGBbRVJSX0ZTX0VJU0RJUl06IFBhdGggaXMgYSBkaXJlY3Rvcnk6ICR7ZnVuY30gcmV0dXJuZWQgRUlTRElSIChpcyBhIGRpcmVjdG9yeSkgJHtwYXRofWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCR7ZXJyb3JDb2RlfTogZXJyb3Igb2NjdXJyZWQsICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihlcnJvckNvZGUsIGZ1bmMgPSBcIlwiLCBwYXRoID0gXCJcIiwgcGF0aDIgPSBcIlwiLCBDb25zdHJ1Y3RvciA9IEVycm9yKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgQ29uc3RydWN0b3IoZm9ybWF0RXJyb3IoZXJyb3JDb2RlLCBmdW5jLCBwYXRoLCBwYXRoMikpO1xuICAgIGVycm9yLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGbGFnc1xuLy8gTGlzdCBvZiBmaWxlIGBmbGFnc2AgYXMgZGVmaW5lZCBieSBOb2RlLlxudmFyIEZMQUdTO1xuKGZ1bmN0aW9uIChGTEFHUykge1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcInJcIl0gPSBPX1JET05MWV0gPSBcInJcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcuIEFuIGV4Y2VwdGlvbiBvY2N1cnMgaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gICAgRkxBR1NbRkxBR1NbXCJyK1wiXSA9IE9fUkRXUl0gPSBcInIrXCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGluIHN5bmNocm9ub3VzIG1vZGUuIEluc3RydWN0cyB0aGUgb3BlcmF0aW5nIHN5c3RlbSB0byBieXBhc3MgdGhlIGxvY2FsIGZpbGUgc3lzdGVtIGNhY2hlLlxuICAgIEZMQUdTW0ZMQUdTW1wicnNcIl0gPSBPX1JET05MWSB8IE9fU1lOQ10gPSBcInJzXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzclwiXSA9IEZMQUdTLnJzXSA9IFwic3JcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcsIHRlbGxpbmcgdGhlIE9TIHRvIG9wZW4gaXQgc3luY2hyb25vdXNseS4gU2VlIG5vdGVzIGZvciAncnMnIGFib3V0IHVzaW5nIHRoaXMgd2l0aCBjYXV0aW9uLlxuICAgIEZMQUdTW0ZMQUdTW1wicnMrXCJdID0gT19SRFdSIHwgT19TWU5DXSA9IFwicnMrXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzcitcIl0gPSBGTEFHU1tcInJzK1wiXV0gPSBcInNyK1wiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3Igd3JpdGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCAoaWYgaXQgZG9lcyBub3QgZXhpc3QpIG9yIHRydW5jYXRlZCAoaWYgaXQgZXhpc3RzKS5cbiAgICBGTEFHU1tGTEFHU1tcIndcIl0gPSBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX1RSVU5DXSA9IFwid1wiO1xuICAgIC8vIExpa2UgJ3cnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcInd4XCJdID0gT19XUk9OTFkgfCBPX0NSRUFUIHwgT19UUlVOQyB8IE9fRVhDTF0gPSBcInd4XCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4d1wiXSA9IEZMQUdTLnd4XSA9IFwieHdcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gICAgRkxBR1NbRkxBR1NbXCJ3K1wiXSA9IE9fUkRXUiB8IE9fQ1JFQVQgfCBPX1RSVU5DXSA9IFwidytcIjtcbiAgICAvLyBMaWtlICd3KycgYnV0IGZhaWxzIGlmIHBhdGggZXhpc3RzLlxuICAgIEZMQUdTW0ZMQUdTW1wid3grXCJdID0gT19SRFdSIHwgT19DUkVBVCB8IE9fVFJVTkMgfCBPX0VYQ0xdID0gXCJ3eCtcIjtcbiAgICBGTEFHU1tGTEFHU1tcInh3K1wiXSA9IEZMQUdTW1wid3grXCJdXSA9IFwieHcrXCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciBhcHBlbmRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgRkxBR1NbRkxBR1NbXCJhXCJdID0gT19XUk9OTFkgfCBPX0FQUEVORCB8IE9fQ1JFQVRdID0gXCJhXCI7XG4gICAgLy8gTGlrZSAnYScgYnV0IGZhaWxzIGlmIHBhdGggZXhpc3RzLlxuICAgIEZMQUdTW0ZMQUdTW1wiYXhcIl0gPSBPX1dST05MWSB8IE9fQVBQRU5EIHwgT19DUkVBVCB8IE9fRVhDTF0gPSBcImF4XCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4YVwiXSA9IEZMQUdTLmF4XSA9IFwieGFcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcImErXCJdID0gT19SRFdSIHwgT19BUFBFTkQgfCBPX0NSRUFUXSA9IFwiYStcIjtcbiAgICAvLyBMaWtlICdhKycgYnV0IGZhaWxzIGlmIHBhdGggZXhpc3RzLlxuICAgIEZMQUdTW0ZMQUdTW1wiYXgrXCJdID0gT19SRFdSIHwgT19BUFBFTkQgfCBPX0NSRUFUIHwgT19FWENMXSA9IFwiYXgrXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4YStcIl0gPSBGTEFHU1tcImF4K1wiXV0gPSBcInhhK1wiO1xufSkoRkxBR1MgPSBleHBvcnRzLkZMQUdTIHx8IChleHBvcnRzLkZMQUdTID0ge30pKTtcbmZ1bmN0aW9uIGZsYWdzVG9OdW1iZXIoZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGZsYWdzID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBmbGFnc051bSA9IEZMQUdTW2ZsYWdzXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFnc051bSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBmbGFnc051bTtcbiAgICB9XG4gICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXRFcnJvcihFUlJTVFJfRkxBRyhmbGFncykpKTtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlR5cGVFcnJvcihcIkVSUl9JTlZBTElEX09QVF9WQUxVRVwiLCBcImZsYWdzXCIsIGZsYWdzKTtcbn1cbmV4cG9ydHMuZmxhZ3NUb051bWJlciA9IGZsYWdzVG9OdW1iZXI7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE9wdGlvbnNcbmZ1bmN0aW9uIGdldE9wdGlvbnMoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0cztcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGlwZW9mID0gdHlwZW9mIG9wdGlvbnM7XG4gICAgICAgIHN3aXRjaCAodGlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFJfT1BUUyh0aXBlb2YpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gXCJidWZmZXJcIilcbiAgICAgICAgKDAsIGVuY29kaW5nXzEuYXNzZXJ0RW5jb2RpbmcpKG9wdHMuZW5jb2RpbmcpO1xuICAgIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gb3B0c0dlbmVyYXRvcihkZWZhdWx0cykge1xuICAgIHJldHVybiAob3B0aW9ucykgPT4gZ2V0T3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSLkNCKTtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0T3B0cykge1xuICAgIHJldHVybiAob3B0aW9ucywgY2FsbGJhY2spID0+IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBbZ2V0T3B0cygpLCBvcHRpb25zXVxuICAgICAgICA6IFtnZXRPcHRzKG9wdGlvbnMpLCB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKV07XG59XG5jb25zdCBvcHRzRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxufTtcbmNvbnN0IGdldERlZmF1bHRPcHRzID0gb3B0c0dlbmVyYXRvcihvcHRzRGVmYXVsdHMpO1xuY29uc3QgZ2V0RGVmYXVsdE9wdHNBbmRDYiA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXREZWZhdWx0T3B0cyk7XG5jb25zdCByZWFkRmlsZU9wdHNEZWZhdWx0cyA9IHtcbiAgICBmbGFnOiBcInJcIixcbn07XG5jb25zdCBnZXRSZWFkRmlsZU9wdGlvbnMgPSBvcHRzR2VuZXJhdG9yKHJlYWRGaWxlT3B0c0RlZmF1bHRzKTtcbmNvbnN0IHdyaXRlRmlsZURlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiBcInV0ZjhcIixcbiAgICBtb2RlOiA0MzggLyogTU9ERS5ERUZBVUxUICovLFxuICAgIGZsYWc6IEZMQUdTW0ZMQUdTLnddLFxufTtcbmNvbnN0IGdldFdyaXRlRmlsZU9wdGlvbnMgPSBvcHRzR2VuZXJhdG9yKHdyaXRlRmlsZURlZmF1bHRzKTtcbmNvbnN0IGFwcGVuZEZpbGVEZWZhdWx0cyA9IHtcbiAgICBlbmNvZGluZzogXCJ1dGY4XCIsXG4gICAgbW9kZTogNDM4IC8qIE1PREUuREVGQVVMVCAqLyxcbiAgICBmbGFnOiBGTEFHU1tGTEFHUy5hXSxcbn07XG5jb25zdCBnZXRBcHBlbmRGaWxlT3B0cyA9IG9wdHNHZW5lcmF0b3IoYXBwZW5kRmlsZURlZmF1bHRzKTtcbmNvbnN0IGdldEFwcGVuZEZpbGVPcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0QXBwZW5kRmlsZU9wdHMpO1xuY29uc3QgcmVhbHBhdGhEZWZhdWx0cyA9IG9wdHNEZWZhdWx0cztcbmNvbnN0IGdldFJlYWxwYXRoT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3IocmVhbHBhdGhEZWZhdWx0cyk7XG5jb25zdCBnZXRSZWFscGF0aE9wdHNBbmRDYiA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXRSZWFscGF0aE9wdGlvbnMpO1xuY29uc3QgbWtkaXJEZWZhdWx0cyA9IHtcbiAgICBtb2RlOiA1MTEgLyogTU9ERS5ESVIgKi8sXG4gICAgcmVjdXJzaXZlOiBmYWxzZSxcbn07XG5jb25zdCBnZXRNa2Rpck9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1rZGlyRGVmYXVsdHMsIHsgbW9kZTogb3B0aW9ucyB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWtkaXJEZWZhdWx0cywgb3B0aW9ucyk7XG59O1xuY29uc3Qgcm1kaXJEZWZhdWx0cyA9IHtcbiAgICByZWN1cnNpdmU6IGZhbHNlLFxufTtcbmNvbnN0IGdldFJtZGlyT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJtZGlyRGVmYXVsdHMsIG9wdGlvbnMpO1xufTtcbmNvbnN0IGdldFJtT3B0cyA9IG9wdHNHZW5lcmF0b3Iob3B0c0RlZmF1bHRzKTtcbmNvbnN0IGdldFJtT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldFJtT3B0cyk7XG5jb25zdCByZWFkZGlyRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxufTtcbmNvbnN0IGdldFJlYWRkaXJPcHRpb25zID0gb3B0c0dlbmVyYXRvcihyZWFkZGlyRGVmYXVsdHMpO1xuY29uc3QgZ2V0UmVhZGRpck9wdHNBbmRDYiA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXRSZWFkZGlyT3B0aW9ucyk7XG5jb25zdCBzdGF0RGVmYXVsdHMgPSB7XG4gICAgYmlnaW50OiBmYWxzZSxcbn07XG5jb25zdCBnZXRTdGF0T3B0aW9ucyA9IChvcHRpb25zID0ge30pID0+IE9iamVjdC5hc3NpZ24oe30sIHN0YXREZWZhdWx0cywgb3B0aW9ucyk7XG5jb25zdCBnZXRTdGF0T3B0c0FuZENiID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiXG4gICAgPyBbZ2V0U3RhdE9wdGlvbnMoKSwgb3B0aW9uc11cbiAgICA6IFtnZXRTdGF0T3B0aW9ucyhvcHRpb25zKSwgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayldO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVdGlsaXR5IGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0UGF0aEZyb21VUkxQb3NpeCh1cmwpIHtcbiAgICBpZiAodXJsLmhvc3RuYW1lICE9PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVHlwZUVycm9yKFwiRVJSX0lOVkFMSURfRklMRV9VUkxfSE9TVFwiLCBwcm9jZXNzXzEuZGVmYXVsdC5wbGF0Zm9ybSk7XG4gICAgfVxuICAgIGNvbnN0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcGF0aG5hbWUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lW25dID09PSBcIiVcIikge1xuICAgICAgICAgICAgY29uc3QgdGhpcmQgPSBwYXRobmFtZS5jb2RlUG9pbnRBdChuICsgMikgfCAweDIwO1xuICAgICAgICAgICAgaWYgKHBhdGhuYW1lW24gKyAxXSA9PT0gXCIyXCIgJiYgdGhpcmQgPT09IDEwMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuVHlwZUVycm9yKFwiRVJSX0lOVkFMSURfRklMRV9VUkxfUEFUSFwiLCBcIm11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCAvIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBwYXRoVG9GaWxlbmFtZShwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSBcInN0cmluZ1wiICYmICFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIocGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiByZXF1aXJlKFwidXJsXCIpLlVSTCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJTVFIuUEFUSF9TVFIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSU1RSLlBBVEhfU1RSKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gZ2V0UGF0aEZyb21VUkxQb3NpeChwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IFN0cmluZyhwYXRoKTtcbiAgICBudWxsQ2hlY2socGF0aFN0cmluZyk7XG4gICAgLy8gcmV0dXJuIHNsYXNoKHBhdGhTdHJpbmcpO1xuICAgIHJldHVybiBwYXRoU3RyaW5nO1xufVxuZXhwb3J0cy5wYXRoVG9GaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lO1xubGV0IHJlc29sdmUgPSAoZmlsZW5hbWUsIGJhc2UgPSBwcm9jZXNzXzEuZGVmYXVsdC5jd2QoKSkgPT4gcmVzb2x2ZUNyb3NzUGxhdGZvcm0oYmFzZSwgZmlsZW5hbWUpO1xuaWYgKGlzV2luKSB7XG4gICAgY29uc3QgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIGNvbnN0IHsgdW5peGlmeSB9ID0gcmVxdWlyZShcImZzLW1vbmtleS9saWIvY29ycmVjdFBhdGhcIik7XG4gICAgcmVzb2x2ZSA9IChmaWxlbmFtZSwgYmFzZSkgPT4gdW5peGlmeShfcmVzb2x2ZShmaWxlbmFtZSwgYmFzZSkpO1xufVxuZnVuY3Rpb24gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lLCBiYXNlKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSByZXNvbHZlKGZpbGVuYW1lLCBiYXNlKTtcbiAgICBjb25zdCBmdWxsUGF0aFNhbnNTbGFzaCA9IGZ1bGxQYXRoLnN1YnN0cigxKTtcbiAgICBpZiAoIWZ1bGxQYXRoU2Fuc1NsYXNoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIGZ1bGxQYXRoU2Fuc1NsYXNoLnNwbGl0KHNlcCk7XG59XG5leHBvcnRzLmZpbGVuYW1lVG9TdGVwcyA9IGZpbGVuYW1lVG9TdGVwcztcbmZ1bmN0aW9uIHBhdGhUb1N0ZXBzKHBhdGgpIHtcbiAgICByZXR1cm4gZmlsZW5hbWVUb1N0ZXBzKHBhdGhUb0ZpbGVuYW1lKHBhdGgpKTtcbn1cbmV4cG9ydHMucGF0aFRvU3RlcHMgPSBwYXRoVG9TdGVwcztcbmZ1bmN0aW9uIGRhdGFUb1N0cihkYXRhLCBlbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGOCkge1xuICAgIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuICgwLCBidWZmZXJfMS5idWZmZXJGcm9tKShkYXRhKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gU3RyaW5nKGRhdGEpO1xufVxuZXhwb3J0cy5kYXRhVG9TdHIgPSBkYXRhVG9TdHI7XG5mdW5jdGlvbiBkYXRhVG9CdWZmZXIoZGF0YSwgZW5jb2RpbmcgPSBlbmNvZGluZ18xLkVOQ09ESU5HX1VURjgpIHtcbiAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckZyb20pKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBcImVuY29kaW5nIGFzIC4uLlwiIGlzIGEgbGl0dGxlIGJpdCBvZiBhIGNoZWF0LlxuICAgICAgICByZXR1cm4gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckZyb20pKFN0cmluZyhkYXRhKSwgZW5jb2RpbmcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGF0YVRvQnVmZmVyID0gZGF0YVRvQnVmZmVyO1xuZnVuY3Rpb24gYnVmZmVyVG9FbmNvZGluZyhidWZmZXIsIGVuY29kaW5nKSB7XG4gICAgaWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZyA9PT0gXCJidWZmZXJcIilcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpO1xufVxuZXhwb3J0cy5idWZmZXJUb0VuY29kaW5nID0gYnVmZmVyVG9FbmNvZGluZztcbmZ1bmN0aW9uIG51bGxDaGVjayhwYXRoLCBjYWxsYmFjaykge1xuICAgIGlmICgoXCJcIiArIHBhdGgpLmluZGV4T2YoXCJcXHUwMDAwXCIpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBlciA9IG5ldyBFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZyB3aXRob3V0IG51bGwgYnl0ZXNcIik7XG4gICAgICAgIGVyLmNvZGUgPSBFTk9FTlQ7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICBwcm9jZXNzXzEuZGVmYXVsdC5uZXh0VGljayhjYWxsYmFjaywgZXIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gX21vZGVUb051bWJlcihtb2RlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1vZGUsIDgpO1xuICAgIGlmIChkZWYpXG4gICAgICAgIHJldHVybiBtb2RlVG9OdW1iZXIoZGVmKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbW9kZVRvTnVtYmVyKG1vZGUsIGRlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9tb2RlVG9OdW1iZXIobW9kZSwgZGVmKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUlNUUi5NT0RFX0lOVCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRmQocGF0aCkge1xuICAgIHJldHVybiBwYXRoID4+PiAwID09PSBwYXRoO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVGZChmZCkge1xuICAgIGlmICghaXNGZChmZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuRkQpO1xufVxuLy8gY29udmVydHMgRGF0ZSBvciBudW1iZXIgdG8gYSBmcmFjdGlvbmFsIFVOSVggdGltZXN0YW1wXG5mdW5jdGlvbiB0b1VuaXhUaW1lc3RhbXAodGltZSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSB0cmlwbGUtZXF1YWxzXG4gICAgaWYgKHR5cGVvZiB0aW1lID09PSBcInN0cmluZ1wiICYmICt0aW1lID09IHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICt0aW1lO1xuICAgIH1cbiAgICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKHRpbWUpKSB7XG4gICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdGltZTogXCIgKyB0aW1lKTtcbn1cbmV4cG9ydHMudG9Vbml4VGltZXN0YW1wID0gdG9Vbml4VGltZXN0YW1wO1xuZnVuY3Rpb24gdmFsaWRhdGVVaWQodWlkKSB7XG4gICAgaWYgKHR5cGVvZiB1aWQgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuVUlEKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlR2lkKGdpZCkge1xuICAgIGlmICh0eXBlb2YgZ2lkICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSLkdJRCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuSlNPTihuZXN0ZWRKU09OKSB7XG4gICAgY29uc3QgZmxhdEpTT04gPSB7fTtcbiAgICBmdW5jdGlvbiBmbGF0dGVuKHBhdGhQcmVmaXgsIG5vZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIGluIG5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRPck5vZGUgPSBub2RlW3BhdGhdO1xuICAgICAgICAgICAgY29uc3Qgam9pbmVkUGF0aCA9IGpvaW4ocGF0aFByZWZpeCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRPck5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBmbGF0SlNPTltqb2luZWRQYXRoXSA9IGNvbnRlbnRPck5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGVudE9yTm9kZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGNvbnRlbnRPck5vZGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZW50T3JOb2RlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgZGlyZWN0b3JpZXMgbmVlZCBhbiBleHBsaWNpdCBlbnRyeSBhbmQgdGhlcmVmb3JlIGdldCBoYW5kbGVkIGluIGBlbHNlYCwgbm9uLWVtcHR5IG9uZXMgYXJlIGltcGxpY2l0bHkgY29uc2lkZXJlZFxuICAgICAgICAgICAgICAgIGZsYXR0ZW4oam9pbmVkUGF0aCwgY29udGVudE9yTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHRoaXMgYnJhbmNoIG51bGwsIGVtcHR5LW9iamVjdCBvciBub24tb2JqZWN0IGVudHJpZXMgd291bGQgbm90IGJlIGhhbmRsZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgICAgICAgLy8gYnkgYm90aCBmcm9tSlNPTigpIGFuZCBmcm9tTmVzdGVkSlNPTigpXG4gICAgICAgICAgICAgICAgZmxhdEpTT05bam9pbmVkUGF0aF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsYXR0ZW4oXCJcIiwgbmVzdGVkSlNPTik7XG4gICAgcmV0dXJuIGZsYXRKU09OO1xufVxuLyoqXG4gKiBgVm9sdW1lYCByZXByZXNlbnRzIGEgZmlsZSBzeXN0ZW0uXG4gKi9cbmNsYXNzIFZvbHVtZSB7XG4gICAgY29uc3RydWN0b3IocHJvcHMgPSB7fSkge1xuICAgICAgICAvLyBJLW5vZGUgbnVtYmVyIGNvdW50ZXIuXG4gICAgICAgIHRoaXMuaW5vID0gMDtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGZvciBpLW5vZGUgbnVtYmVycyB0byBpLW5vZGVzIChgTm9kZWApO1xuICAgICAgICB0aGlzLmlub2RlcyA9IHt9O1xuICAgICAgICAvLyBMaXN0IG9mIHJlbGVhc2VkIGktbm9kZSBudW1iZXJzLCBmb3IgcmV1c2UuXG4gICAgICAgIHRoaXMucmVsZWFzZWRJbm9zID0gW107XG4gICAgICAgIC8vIEEgbWFwcGluZyBmb3IgZmlsZSBkZXNjcmlwdG9ycyB0byBgRmlsZWBzLlxuICAgICAgICB0aGlzLmZkcyA9IHt9O1xuICAgICAgICAvLyBBIGxpc3Qgb2YgcmV1c2FibGUgKG9wZW5lZCBhbmQgY2xvc2VkKSBmaWxlIGRlc2NyaXB0b3JzLCB0aGF0IHNob3VsZCBiZVxuICAgICAgICAvLyB1c2VkIGZpcnN0IGJlZm9yZSBjcmVhdGluZyBhIG5ldyBmaWxlIGRlc2NyaXB0b3IuXG4gICAgICAgIHRoaXMucmVsZWFzZWRGZHMgPSBbXTtcbiAgICAgICAgLy8gTWF4IG51bWJlciBvZiBvcGVuIGZpbGVzLlxuICAgICAgICB0aGlzLm1heEZpbGVzID0gMTAwMDA7XG4gICAgICAgIC8vIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gZmlsZXMuXG4gICAgICAgIHRoaXMub3BlbkZpbGVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9taXNlc0FwaSA9ICgwLCBwcm9taXNlc18xLmRlZmF1bHQpKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRXYXRjaGVycyA9IHt9O1xuICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbih7IE5vZGU6IG5vZGVfMS5Ob2RlLCBMaW5rOiBub2RlXzEuTGluaywgRmlsZTogbm9kZV8xLkZpbGUgfSwgcHJvcHMpO1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5jcmVhdGVMaW5rKCk7XG4gICAgICAgIHJvb3Quc2V0Tm9kZSh0aGlzLmNyZWF0ZU5vZGUodHJ1ZSkpO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICAgICAgdGhpcy5TdGF0V2F0Y2hlciA9IGNsYXNzIGV4dGVuZHMgU3RhdFdhdGNoZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9SZWFkU3RyZWFtID0gRnNSZWFkU3RyZWFtO1xuICAgICAgICB0aGlzLlJlYWRTdHJlYW0gPSBjbGFzcyBleHRlbmRzIF9SZWFkU3RyZWFtIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihzZWxmLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX1dyaXRlU3RyZWFtID0gRnNXcml0ZVN0cmVhbTtcbiAgICAgICAgdGhpcy5Xcml0ZVN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgX1dyaXRlU3RyZWFtIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihzZWxmLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5GU1dhdGNoZXIgPSBjbGFzcyBleHRlbmRzIEZTV2F0Y2hlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gcm9vdC5zZXRDaGlsZCgnLicsIHJvb3QpO1xuICAgICAgICAvLyByb290LmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICAvLyByb290LnNldENoaWxkKCcuLicsIHJvb3QpO1xuICAgICAgICAvLyByb290LmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY3dkKSB7XG4gICAgICAgIGNvbnN0IHZvbCA9IG5ldyBWb2x1bWUoKTtcbiAgICAgICAgdm9sLmZyb21KU09OKGpzb24sIGN3ZCk7XG4gICAgICAgIHJldHVybiB2b2w7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTmVzdGVkSlNPTihqc29uLCBjd2QpIHtcbiAgICAgICAgY29uc3Qgdm9sID0gbmV3IFZvbHVtZSgpO1xuICAgICAgICB2b2wuZnJvbU5lc3RlZEpTT04oanNvbiwgY3dkKTtcbiAgICAgICAgcmV0dXJuIHZvbDtcbiAgICB9XG4gICAgZ2V0IHByb21pc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlc0FwaSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXNBcGk7XG4gICAgfVxuICAgIGNyZWF0ZUxpbmsocGFyZW50LCBuYW1lLCBpc0RpcmVjdG9yeSA9IGZhbHNlLCBwZXJtKSB7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMucHJvcHMuTGluayh0aGlzLCBudWxsLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUxpbms6IG5hbWUgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQuY3JlYXRlQ2hpbGQobmFtZSwgdGhpcy5jcmVhdGVOb2RlKGlzRGlyZWN0b3J5LCBwZXJtKSk7XG4gICAgfVxuICAgIGRlbGV0ZUxpbmsobGluaykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZXdJbm9OdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VkRmQgPSB0aGlzLnJlbGVhc2VkSW5vcy5wb3AoKTtcbiAgICAgICAgaWYgKHJlbGVhc2VkRmQpXG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZWRGZDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubyA9ICh0aGlzLmlubyArIDEpICUgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlubztcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdGZE51bWJlcigpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZWRGZCA9IHRoaXMucmVsZWFzZWRGZHMucG9wKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVsZWFzZWRGZCA9PT0gXCJudW1iZXJcIiA/IHJlbGVhc2VkRmQgOiBWb2x1bWUuZmQtLTtcbiAgICB9XG4gICAgY3JlYXRlTm9kZShpc0RpcmVjdG9yeSA9IGZhbHNlLCBwZXJtKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgdGhpcy5wcm9wcy5Ob2RlKHRoaXMubmV3SW5vTnVtYmVyKCksIHBlcm0pO1xuICAgICAgICBpZiAoaXNEaXJlY3RvcnkpXG4gICAgICAgICAgICBub2RlLnNldElzRGlyZWN0b3J5KCk7XG4gICAgICAgIHRoaXMuaW5vZGVzW25vZGUuaW5vXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXROb2RlKGlubykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm9kZXNbaW5vXTtcbiAgICB9XG4gICAgZGVsZXRlTm9kZShub2RlKSB7XG4gICAgICAgIG5vZGUuZGVsKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlub2Rlc1tub2RlLmlub107XG4gICAgICAgIHRoaXMucmVsZWFzZWRJbm9zLnB1c2gobm9kZS5pbm8pO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZXMgNiBjaGFyYWN0ZXIgbG9uZyByYW5kb20gc3RyaW5nLCB1c2VkIGJ5IGBta2R0ZW1wYC5cbiAgICBnZW5SbmRTdHIoKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IChNYXRoLnJhbmRvbSgpICsgMSkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA2KTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDYpXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5SbmRTdHIoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGBMaW5rYCAoaGFyZCBsaW5rKSByZWZlcmVuY2VkIGJ5IHBhdGggXCJzcGxpdFwiIGludG8gc3RlcHMuXG4gICAgZ2V0TGluayhzdGVwcykge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LndhbGsoc3RlcHMpO1xuICAgIH1cbiAgICAvLyBKdXN0IGxpbmsgYGdldExpbmtgLCBidXQgdGhyb3dzIGEgY29ycmVjdCB1c2VyIGVycm9yLCBpZiBsaW5rIHRvIGZvdW5kLlxuICAgIGdldExpbmtPclRocm93KGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmsoc3RlcHMpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIGZ1bmNOYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbiAgICAvLyBKdXN0IGxpa2UgYGdldExpbmtgLCBidXQgYWxzbyBkZXJlZmVyZW5jZS9yZXNvbHZlcyBzeW1ib2xpYyBsaW5rcy5cbiAgICBnZXRSZXNvbHZlZExpbmsoZmlsZW5hbWVPclN0ZXBzKSB7XG4gICAgICAgIGxldCBzdGVwcyA9IHR5cGVvZiBmaWxlbmFtZU9yU3RlcHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lT3JTdGVwcylcbiAgICAgICAgICAgIDogZmlsZW5hbWVPclN0ZXBzO1xuICAgICAgICBsZXQgbGluayA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgbGluayA9IGxpbmsuZ2V0Q2hpbGQoc3RlcCk7XG4gICAgICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1N5bWxpbmsoKSkge1xuICAgICAgICAgICAgICAgIHN0ZXBzID0gbm9kZS5zeW1saW5rLmNvbmNhdChzdGVwcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGxpbmsgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfVxuICAgIC8vIEp1c3QgbGlrZSBgZ2V0TGlua09yVGhyb3dgLCBidXQgYWxzbyBkZXJlZmVyZW5jZS9yZXNvbHZlcyBzeW1ib2xpYyBsaW5rcy5cbiAgICBnZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIGZ1bmNOYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbiAgICByZXNvbHZlU3ltbGlua3MobGluaykge1xuICAgICAgICAvLyBsZXQgbm9kZTogTm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAvLyB3aGlsZShsaW5rICYmIG5vZGUuaXNTeW1saW5rKCkpIHtcbiAgICAgICAgLy8gICAgIGxpbmsgPSB0aGlzLmdldExpbmsobm9kZS5zeW1saW5rKTtcbiAgICAgICAgLy8gICAgIGlmKCFsaW5rKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gICAgIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyByZXR1cm4gbGluaztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKGxpbmsuc3RlcHMuc2xpY2UoMSkpO1xuICAgIH1cbiAgICAvLyBKdXN0IGxpa2UgYGdldExpbmtPclRocm93YCwgYnV0IGFsc28gdmVyaWZpZXMgdGhhdCB0aGUgbGluayBpcyBhIGRpcmVjdG9yeS5cbiAgICBnZXRMaW5rQXNEaXJPclRocm93KGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgZnVuY05hbWUpO1xuICAgICAgICBpZiAoIWxpbmsuZ2V0Tm9kZSgpLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9URElSLCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBpbW1lZGlhdGUgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGUgbGluay5cbiAgICBnZXRMaW5rUGFyZW50KHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Qud2FsayhzdGVwcywgc3RlcHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGdldExpbmtQYXJlbnRBc0Rpck9yVGhyb3coZmlsZW5hbWVPclN0ZXBzLCBmdW5jTmFtZSkge1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lT3JTdGVwcyBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IGZpbGVuYW1lT3JTdGVwc1xuICAgICAgICAgICAgOiBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWVPclN0ZXBzKTtcbiAgICAgICAgY29uc3QgbGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgZnVuY05hbWUsIHNlcCArIHN0ZXBzLmpvaW4oc2VwKSk7XG4gICAgICAgIGlmICghbGluay5nZXROb2RlKCkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT1RESVIsIGZ1bmNOYW1lLCBzZXAgKyBzdGVwcy5qb2luKHNlcCkpO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9XG4gICAgZ2V0RmlsZUJ5RmQoZmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmRzW1N0cmluZyhmZCldO1xuICAgIH1cbiAgICBnZXRGaWxlQnlGZE9yVGhyb3coZmQsIGZ1bmNOYW1lKSB7XG4gICAgICAgIGlmICghaXNGZChmZCkpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSLkZEKTtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoZmQpO1xuICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFQkFERiwgZnVuY05hbWUpO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRvZG8gVGhpcyBpcyBub3QgdXNlZCBhbnltb3JlLiBSZW1vdmUuXG4gICAgICovXG4gICAgLypcbiAgICBwcml2YXRlIGdldE5vZGVCeUlkT3JDcmVhdGUoaWQ6IFRGaWxlSWQsIGZsYWdzOiBudW1iZXIsIHBlcm06IG51bWJlcik6IE5vZGUge1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoaWQpO1xuICAgICAgICBpZiAoIWZpbGUpIHRocm93IEVycm9yKCdGaWxlIG50byBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gZmlsZS5ub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBwYXRoVG9TdGVwcyhpZCBhcyBQYXRoTGlrZSk7XG4gICAgICAgIGxldCBsaW5rID0gdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKGxpbmspIHJldHVybiBsaW5rLmdldE5vZGUoKTtcbiAgXG4gICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5vZGUgaWYgbm90IGZvdW5kLlxuICAgICAgICBpZiAoZmxhZ3MgJiBPX0NSRUFUKSB7XG4gICAgICAgICAgY29uc3QgZGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgICAgaWYgKGRpckxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxpbmsgPSB0aGlzLmNyZWF0ZUxpbmsoZGlyTGluaywgbmFtZSwgZmFsc2UsIHBlcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCAnZ2V0Tm9kZUJ5SWRPckNyZWF0ZScsIHBhdGhUb0ZpbGVuYW1lKGlkKSk7XG4gICAgICB9XG4gICAgfVxuICAgICovXG4gICAgd3JhcEFzeW5jKG1ldGhvZCwgYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgICgwLCBzZXRJbW1lZGlhdGVfMS5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3RvSlNPTihsaW5rID0gdGhpcy5yb290LCBqc29uID0ge30sIHBhdGgpIHtcbiAgICAgICAgbGV0IGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBsaW5rLmNoaWxkcmVuO1xuICAgICAgICBpZiAobGluay5nZXROb2RlKCkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0geyBbbGluay5nZXROYW1lKCldOiBsaW5rLnBhcmVudC5nZXRDaGlsZChsaW5rLmdldE5hbWUoKSkgfTtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbGluay5nZXRDaGlsZChuYW1lKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdG9KU09OOiB1bmV4cGVjdGVkIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZC5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IGNoaWxkLmdldFBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZWxhdGl2ZShwYXRoLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAganNvbltmaWxlbmFtZV0gPSBub2RlLmdldFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9KU09OKGNoaWxkLCBqc29uLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyUGF0aCA9IGxpbmsuZ2V0UGF0aCgpO1xuICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgIGRpclBhdGggPSByZWxhdGl2ZShwYXRoLCBkaXJQYXRoKTtcbiAgICAgICAgaWYgKGRpclBhdGggJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAganNvbltkaXJQYXRoXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIHRvSlNPTihwYXRocywganNvbiA9IHt9LCBpc1JlbGF0aXZlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbGlua3MgPSBbXTtcbiAgICAgICAgaWYgKHBhdGhzKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRocyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgICBwYXRocyA9IFtwYXRoc107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlua3MucHVzaCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGlua3MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIGZvciAoY29uc3QgbGluayBvZiBsaW5rcylcbiAgICAgICAgICAgIHRoaXMuX3RvSlNPTihsaW5rLCBqc29uLCBpc1JlbGF0aXZlID8gbGluay5nZXRQYXRoKCkgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24sIGN3ZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmN3ZCgpKSB7XG4gICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIGpzb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBqc29uW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gcmVzb2x2ZShmaWxlbmFtZSwgY3dkKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IGRpcm5hbWUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShkaXIsIDUxMSAvKiBNT0RFLkRJUiAqLyk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUZpbGVTeW5jKGZpbGVuYW1lLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShmaWxlbmFtZSwgNTExIC8qIE1PREUuRElSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tTmVzdGVkSlNPTihqc29uLCBjd2QpIHtcbiAgICAgICAgdGhpcy5mcm9tSlNPTihmbGF0dGVuSlNPTihqc29uKSwgY3dkKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaW5vID0gMDtcbiAgICAgICAgdGhpcy5pbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZElub3MgPSBbXTtcbiAgICAgICAgdGhpcy5mZHMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcyA9IFtdO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcyA9IDA7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlTGluaygpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0Tm9kZSh0aGlzLmNyZWF0ZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgaW50ZXJmYWNlXG4gICAgbW91bnRTeW5jKG1vdW50cG9pbnQsIGpzb24pIHtcbiAgICAgICAgdGhpcy5mcm9tSlNPTihqc29uLCBtb3VudHBvaW50KTtcbiAgICB9XG4gICAgb3BlbkxpbmsobGluaywgZmxhZ3NOdW0sIHJlc29sdmVTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlbkZpbGVzID49IHRoaXMubWF4RmlsZXMpIHtcbiAgICAgICAgICAgIC8vIFRvbyBtYW55IG9wZW4gZmlsZXMuXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTUZJTEUsIFwib3BlblwiLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSBzeW1saW5rcy5cbiAgICAgICAgbGV0IHJlYWxMaW5rID0gbGluaztcbiAgICAgICAgaWYgKHJlc29sdmVTeW1saW5rcylcbiAgICAgICAgICAgIHJlYWxMaW5rID0gdGhpcy5yZXNvbHZlU3ltbGlua3MobGluayk7XG4gICAgICAgIGlmICghcmVhbExpbmspXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIFwib3BlblwiLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWFsTGluay5nZXROb2RlKCk7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgbm9kZSBpcyBhIGRpcmVjdG9yeVxuICAgICAgICBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzTnVtICYgKE9fUkRPTkxZIHwgT19SRFdSIHwgT19XUk9OTFkpKSAhPT0gT19SRE9OTFkpXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRUlTRElSLCBcIm9wZW5cIiwgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZsYWdzTnVtICYgT19ESVJFQ1RPUlkpXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PVERJUiwgXCJvcGVuXCIsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBub2RlIHBlcm1pc3Npb25zXG4gICAgICAgIGlmICghKGZsYWdzTnVtICYgT19XUk9OTFkpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY2FuUmVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRUFDQ0VTLCBcIm9wZW5cIiwgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFnc051bSAmIE9fUkRXUikge1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgdGhpcy5wcm9wcy5GaWxlKGxpbmssIG5vZGUsIGZsYWdzTnVtLCB0aGlzLm5ld0ZkTnVtYmVyKCkpO1xuICAgICAgICB0aGlzLmZkc1tmaWxlLmZkXSA9IGZpbGU7XG4gICAgICAgIHRoaXMub3BlbkZpbGVzKys7XG4gICAgICAgIGlmIChmbGFnc051bSAmIE9fVFJVTkMpXG4gICAgICAgICAgICBmaWxlLnRydW5jYXRlKCk7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICBvcGVuRmlsZShmaWxlbmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sIHJlc29sdmVTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICBsZXQgbGluayA9IHJlc29sdmVTeW1saW5rc1xuICAgICAgICAgICAgPyB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcylcbiAgICAgICAgICAgIDogdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKGxpbmsgJiYgZmxhZ3NOdW0gJiBPX0VYQ0wpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFRVhJU1QsIFwib3BlblwiLCBmaWxlbmFtZSk7XG4gICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5ldyBmaWxlLCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFsaW5rICYmIGZsYWdzTnVtICYgT19DUkVBVCkge1xuICAgICAgICAgICAgLy8gY29uc3QgZGlyTGluazogTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgICAgICBjb25zdCBkaXJMaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoc3RlcHMuc2xpY2UoMCwgc3RlcHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgLy8gaWYoIWRpckxpbmspIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAoIWRpckxpbmspXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcIm9wZW5cIiwgc2VwICsgc3RlcHMuam9pbihzZXApKTtcbiAgICAgICAgICAgIGlmIChmbGFnc051bSAmIE9fQ1JFQVQgJiYgdHlwZW9mIG1vZGVOdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gdGhpcy5jcmVhdGVMaW5rKGRpckxpbmssIHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdLCBmYWxzZSwgbW9kZU51bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmspXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuTGluayhsaW5rLCBmbGFnc051bSwgcmVzb2x2ZVN5bWxpbmtzKTtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcIm9wZW5cIiwgZmlsZW5hbWUpO1xuICAgIH1cbiAgICBvcGVuQmFzZShmaWxlbmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sIHJlc29sdmVTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMub3BlbkZpbGUoZmlsZW5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtLCByZXNvbHZlU3ltbGlua3MpO1xuICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIFwib3BlblwiLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBmaWxlLmZkO1xuICAgIH1cbiAgICBvcGVuU3luYyhwYXRoLCBmbGFncywgbW9kZSA9IDQzOCAvKiBNT0RFLkRFRkFVTFQgKi8pIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgKDEpIG1vZGU7ICgyKSBwYXRoOyAoMykgZmxhZ3MgLSBpbiB0aGF0IG9yZGVyLlxuICAgICAgICBjb25zdCBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBjb25zdCBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIoZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuQmFzZShmaWxlTmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgIH1cbiAgICBvcGVuKHBhdGgsIGZsYWdzLCBhLCBiKSB7XG4gICAgICAgIGxldCBtb2RlID0gYTtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gYjtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1vZGUgPSA0MzggLyogTU9ERS5ERUZBVUxUICovO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IDQzOCAvKiBNT0RFLkRFRkFVTFQgKi87XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIobW9kZSk7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGNvbnN0IGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihmbGFncyk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMub3BlbkJhc2UsIFtmaWxlTmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGNsb3NlRmlsZShmaWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5mZHNbZmlsZS5mZF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkZpbGVzLS07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZkc1tmaWxlLmZkXTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcy5wdXNoKGZpbGUuZmQpO1xuICAgIH1cbiAgICBjbG9zZVN5bmMoZmQpIHtcbiAgICAgICAgdmFsaWRhdGVGZChmZCk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgXCJjbG9zZVwiKTtcbiAgICAgICAgdGhpcy5jbG9zZUZpbGUoZmlsZSk7XG4gICAgfVxuICAgIGNsb3NlKGZkLCBjYWxsYmFjaykge1xuICAgICAgICB2YWxpZGF0ZUZkKGZkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jbG9zZVN5bmMsIFtmZF0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb3BlbkZpbGVPckdldEJ5SWQoaWQsIGZsYWdzTnVtLCBtb2RlTnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmZkc1tpZF07XG4gICAgICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkZpbGUocGF0aFRvRmlsZW5hbWUoaWQpLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEJhc2UoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCk7XG4gICAgICAgIHJldHVybiBmaWxlLnJlYWQoYnVmZmVyLCBOdW1iZXIob2Zmc2V0KSwgTnVtYmVyKGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmVhZFN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQmFzZShmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICByZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIC8vIFRoaXMgYGlmYCBicmFuY2ggaXMgZnJvbSBOb2RlLmpzXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzXzEuZGVmYXVsdC5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAwLCBidWZmZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHNldEltbWVkaWF0ZV8xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnJlYWRCYXNlKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnl0ZXMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlYWRGaWxlQmFzZShpZCwgZmxhZ3NOdW0sIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGlzVXNlckZkID0gdHlwZW9mIGlkID09PSBcIm51bWJlclwiO1xuICAgICAgICBjb25zdCB1c2VyT3duc0ZkID0gaXNVc2VyRmQgJiYgaXNGZChpZCk7XG4gICAgICAgIGxldCBmZDtcbiAgICAgICAgaWYgKHVzZXJPd25zRmQpXG4gICAgICAgICAgICBmZCA9IGlkO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzKTtcbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVJU0RJUiwgXCJvcGVuXCIsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZkID0gdGhpcy5vcGVuU3luYyhpZCwgZmxhZ3NOdW0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXJUb0VuY29kaW5nKHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkKS5nZXRCdWZmZXIoKSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCF1c2VyT3duc0ZkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWRGaWxlU3luYyhmaWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRSZWFkRmlsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihvcHRzLmZsYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmlsZUJhc2UoZmlsZSwgZmxhZ3NOdW0sIG9wdHMuZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZWFkRmlsZShpZCwgYSwgYikge1xuICAgICAgICBjb25zdCBbb3B0cywgY2FsbGJhY2tdID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldFJlYWRGaWxlT3B0aW9ucykoYSwgYik7XG4gICAgICAgIGNvbnN0IGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihvcHRzLmZsYWcpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlYWRGaWxlQmFzZSwgW2lkLCBmbGFnc051bSwgb3B0cy5lbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JpdGVCYXNlKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsIFwid3JpdGVcIik7XG4gICAgICAgIHJldHVybiBmaWxlLndyaXRlKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgd3JpdGVTeW5jKGZkLCBhLCBiLCBjLCBkKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICBsZXQgZW5jb2Rpbmc7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgICAgY29uc3QgaXNCdWZmZXIgPSB0eXBlb2YgYSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgaWYgKGlzQnVmZmVyKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAoYiB8fCAwKSB8IDA7XG4gICAgICAgICAgICBsZW5ndGggPSBjO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBiO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGFUb0J1ZmZlcihhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChpc0J1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCYXNlKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRlKGZkLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBsZXQgbGVuZ3RoO1xuICAgICAgICBsZXQgcG9zaXRpb247XG4gICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgICBjb25zdCB0aXBhID0gdHlwZW9mIGE7XG4gICAgICAgIGNvbnN0IHRpcGIgPSB0eXBlb2YgYjtcbiAgICAgICAgY29uc3QgdGlwYyA9IHR5cGVvZiBjO1xuICAgICAgICBjb25zdCB0aXBkID0gdHlwZW9mIGQ7XG4gICAgICAgIGlmICh0aXBhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodGlwYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYiB8IDA7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYiB8IDA7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBjO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGlwYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBiO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpcGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gYjtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGM7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGFUb0J1ZmZlcihhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmICh0aXBhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2IgPSB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgKDAsIHNldEltbWVkaWF0ZV8xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLndyaXRlQmFzZShmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0aXBhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGJ5dGVzLCBidWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgYnl0ZXMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JpdGVGaWxlQmFzZShpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnd3JpdGVGaWxlQmFzZScsIGlkLCBidWYsIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgLy8gY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5SWRPckNyZWF0ZShpZCwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgICAgICAvLyBub2RlLnNldEJ1ZmZlcihidWYpO1xuICAgICAgICBjb25zdCBpc1VzZXJGZCA9IHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgbGV0IGZkO1xuICAgICAgICBpZiAoaXNVc2VyRmQpXG4gICAgICAgICAgICBmZCA9IGlkO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZkID0gdGhpcy5vcGVuQmFzZShwYXRoVG9GaWxlbmFtZShpZCksIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgICAgIC8vIGZkID0gdGhpcy5vcGVuU3luYyhpZCBhcyBQYXRoTGlrZSwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gZmxhZ3NOdW0gJiBPX0FQUEVORCA/IHVuZGVmaW5lZCA6IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXR0ZW4gPSB0aGlzLndyaXRlU3luYyhmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB3cml0dGVuO1xuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSB3cml0dGVuO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB3cml0dGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCFpc1VzZXJGZClcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVGaWxlU3luYyhpZCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gZ2V0V3JpdGVGaWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmxhZ3NOdW0gPSBmbGFnc1RvTnVtYmVyKG9wdHMuZmxhZyk7XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIob3B0cy5tb2RlKTtcbiAgICAgICAgY29uc3QgYnVmID0gZGF0YVRvQnVmZmVyKGRhdGEsIG9wdHMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyaXRlRmlsZUJhc2UoaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgIH1cbiAgICB3cml0ZUZpbGUoaWQsIGRhdGEsIGEsIGIpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhO1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHdyaXRlRmlsZURlZmF1bHRzO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNiID0gdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRXcml0ZUZpbGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIob3B0cy5mbGFnKTtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9IG1vZGVUb051bWJlcihvcHRzLm1vZGUpO1xuICAgICAgICBjb25zdCBidWYgPSBkYXRhVG9CdWZmZXIoZGF0YSwgb3B0cy5lbmNvZGluZyk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMud3JpdGVGaWxlQmFzZSwgW2lkLCBidWYsIGZsYWdzTnVtLCBtb2RlTnVtXSwgY2IpO1xuICAgIH1cbiAgICBsaW5rQmFzZShmaWxlbmFtZTEsIGZpbGVuYW1lMikge1xuICAgICAgICBjb25zdCBzdGVwczEgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUxKTtcbiAgICAgICAgY29uc3QgbGluazEgPSB0aGlzLmdldExpbmsoc3RlcHMxKTtcbiAgICAgICAgaWYgKCFsaW5rMSlcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgXCJsaW5rXCIsIGZpbGVuYW1lMSwgZmlsZW5hbWUyKTtcbiAgICAgICAgY29uc3Qgc3RlcHMyID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lMik7XG4gICAgICAgIC8vIENoZWNrIG5ldyBsaW5rIGRpcmVjdG9yeSBleGlzdHMuXG4gICAgICAgIGNvbnN0IGRpcjIgPSB0aGlzLmdldExpbmtQYXJlbnQoc3RlcHMyKTtcbiAgICAgICAgaWYgKCFkaXIyKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcImxpbmtcIiwgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICBjb25zdCBuYW1lID0gc3RlcHMyW3N0ZXBzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbmV3IGZpbGUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGlmIChkaXIyLmdldENoaWxkKG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRUVYSVNULCBcImxpbmtcIiwgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICBjb25zdCBub2RlID0gbGluazEuZ2V0Tm9kZSgpO1xuICAgICAgICBub2RlLm5saW5rKys7XG4gICAgICAgIGRpcjIuY3JlYXRlQ2hpbGQobmFtZSwgbm9kZSk7XG4gICAgfVxuICAgIGNvcHlGaWxlQmFzZShzcmMsIGRlc3QsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmIChmbGFncyAmIENPUFlGSUxFX0VYQ0wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFRVhJU1QsIFwiY29weUZpbGVcIiwgc3JjLCBkZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiBDT1BZRklMRV9GSUNMT05FX0ZPUkNFKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9TWVMsIFwiY29weUZpbGVcIiwgc3JjLCBkZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlRmlsZUJhc2UoZGVzdCwgYnVmLCBGTEFHUy53LCA0MzggLyogTU9ERS5ERUZBVUxUICovKTtcbiAgICB9XG4gICAgY29weUZpbGVTeW5jKHNyYywgZGVzdCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgc3JjRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShzcmMpO1xuICAgICAgICBjb25zdCBkZXN0RmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShkZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZpbGVCYXNlKHNyY0ZpbGVuYW1lLCBkZXN0RmlsZW5hbWUsIChmbGFncyB8fCAwKSB8IDApO1xuICAgIH1cbiAgICBjb3B5RmlsZShzcmMsIGRlc3QsIGEsIGIpIHtcbiAgICAgICAgY29uc3Qgc3JjRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShzcmMpO1xuICAgICAgICBjb25zdCBkZXN0RmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShkZXN0KTtcbiAgICAgICAgbGV0IGZsYWdzO1xuICAgICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbGFncyA9IDA7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGFncyA9IGE7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuY29weUZpbGVCYXNlLCBbc3JjRmlsZW5hbWUsIGRlc3RGaWxlbmFtZSwgZmxhZ3NdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGxpbmtTeW5jKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKGV4aXN0aW5nUGF0aCk7XG4gICAgICAgIGNvbnN0IG5ld1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLmxpbmtCYXNlKGV4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgIH1cbiAgICBsaW5rKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShleGlzdGluZ1BhdGgpO1xuICAgICAgICBjb25zdCBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5saW5rQmFzZSwgW2V4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHVubGlua0Jhc2UoZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcInVubGlua1wiLCBmaWxlbmFtZSk7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIGl0IGlzIGZpbGUsIGRpciwgb3RoZXIuLi5cbiAgICAgICAgaWYgKGxpbmsubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEaXIgbm90IGVtcHR5Li4uXCIpO1xuICAgICAgICB0aGlzLmRlbGV0ZUxpbmsobGluayk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5ubGluay0tO1xuICAgICAgICAvLyBXaGVuIGFsbCBoYXJkIGxpbmtzIHRvIGktbm9kZSBhcmUgZGVsZXRlZCwgcmVtb3ZlIHRoZSBpLW5vZGUsIHRvby5cbiAgICAgICAgaWYgKG5vZGUubmxpbmsgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubGlua1N5bmMocGF0aCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLnVubGlua0Jhc2UoZmlsZW5hbWUpO1xuICAgIH1cbiAgICB1bmxpbmsocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy51bmxpbmtCYXNlLCBbZmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN5bWxpbmtCYXNlKHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgcGF0aFN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKHBhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIENoZWNrIGlmIGRpcmVjdG9yeSBleGlzdHMsIHdoZXJlIHdlIGFib3V0IHRvIGNyZWF0ZSBhIHN5bWxpbmsuXG4gICAgICAgIGNvbnN0IGRpckxpbmsgPSB0aGlzLmdldExpbmtQYXJlbnQocGF0aFN0ZXBzKTtcbiAgICAgICAgaWYgKCFkaXJMaW5rKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcInN5bWxpbmtcIiwgdGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXRoU3RlcHNbcGF0aFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBDaGVjayBpZiBuZXcgZmlsZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgaWYgKGRpckxpbmsuZ2V0Q2hpbGQobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFRVhJU1QsIFwic3ltbGlua1wiLCB0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gQ3JlYXRlIHN5bWxpbmsuXG4gICAgICAgIGNvbnN0IHN5bWxpbmsgPSBkaXJMaW5rLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICBzeW1saW5rLmdldE5vZGUoKS5tYWtlU3ltbGluayhmaWxlbmFtZVRvU3RlcHModGFyZ2V0RmlsZW5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHN5bWxpbms7XG4gICAgfVxuICAgIC8vIGB0eXBlYCBhcmd1bWVudCB3b3JrcyBvbmx5IG9uIFdpbmRvd3MuXG4gICAgc3ltbGlua1N5bmModGFyZ2V0LCBwYXRoLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgcGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMuc3ltbGlua0Jhc2UodGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZSk7XG4gICAgfVxuICAgIHN5bWxpbmsodGFyZ2V0LCBwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjayh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiID8gYSA6IGIpO1xuICAgICAgICBjb25zdCB0YXJnZXRGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IHBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnN5bWxpbmtCYXNlLCBbdGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmVhbHBhdGhCYXNlKGZpbGVuYW1lLCBlbmNvZGluZykge1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IHJlYWxMaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoc3RlcHMpO1xuICAgICAgICBpZiAoIXJlYWxMaW5rKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcInJlYWxwYXRoXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlYWxMaW5rLmdldFBhdGgoKTtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKHBhdGggPyBwYXRoIDogXCIvXCIsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmVhbHBhdGhTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHBhdGhCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCBnZXRSZWFscGF0aE9wdGlvbnMob3B0aW9ucykuZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZWFscGF0aChwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSBnZXRSZWFscGF0aE9wdHNBbmRDYihhLCBiKTtcbiAgICAgICAgY29uc3QgcGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhbHBhdGhCYXNlLCBbcGF0aEZpbGVuYW1lLCBvcHRzLmVuY29kaW5nXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBsc3RhdEJhc2UoZmlsZW5hbWUsIGJpZ2ludCA9IGZhbHNlLCB0aHJvd0lmTm9FbnRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmsoZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKSk7XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGxpbmsuZ2V0Tm9kZSgpLCBiaWdpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aHJvd0lmTm9FbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgXCJsc3RhdFwiLCBmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbHN0YXRTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0aHJvd0lmTm9FbnRyeSA9IHRydWUsIGJpZ2ludCA9IGZhbHNlIH0gPSBnZXRTdGF0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubHN0YXRCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCBiaWdpbnQsIHRocm93SWZOb0VudHJ5KTtcbiAgICB9XG4gICAgbHN0YXQocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBbeyB0aHJvd0lmTm9FbnRyeSA9IHRydWUsIGJpZ2ludCA9IGZhbHNlIH0sIGNhbGxiYWNrXSA9IGdldFN0YXRPcHRzQW5kQ2IoYSwgYik7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubHN0YXRCYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIGJpZ2ludCwgdGhyb3dJZk5vRW50cnldLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0YXRCYXNlKGZpbGVuYW1lLCBiaWdpbnQgPSBmYWxzZSwgdGhyb3dJZk5vRW50cnkgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpKTtcbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIHJldHVybiBTdGF0c18xLmRlZmF1bHQuYnVpbGQobGluay5nZXROb2RlKCksIGJpZ2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRocm93SWZOb0VudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCBcInN0YXRcIiwgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiaWdpbnQgPSB0cnVlLCB0aHJvd0lmTm9FbnRyeSA9IHRydWUgfSA9IGdldFN0YXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0QmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSwgYmlnaW50LCB0aHJvd0lmTm9FbnRyeSk7XG4gICAgfVxuICAgIHN0YXQocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBbeyBiaWdpbnQgPSBmYWxzZSwgdGhyb3dJZk5vRW50cnkgPSB0cnVlIH0sIGNhbGxiYWNrXSA9IGdldFN0YXRPcHRzQW5kQ2IoYSwgYik7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuc3RhdEJhc2UsIFtwYXRoVG9GaWxlbmFtZShwYXRoKSwgYmlnaW50LCB0aHJvd0lmTm9FbnRyeV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnN0YXRCYXNlKGZkLCBiaWdpbnQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZChmZCk7XG4gICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVCQURGLCBcImZzdGF0XCIpO1xuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGZpbGUubm9kZSwgYmlnaW50KTtcbiAgICB9XG4gICAgZnN0YXRTeW5jKGZkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZzdGF0QmFzZShmZCwgZ2V0U3RhdE9wdGlvbnMob3B0aW9ucykuYmlnaW50KTtcbiAgICB9XG4gICAgZnN0YXQoZmQsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgW29wdHMsIGNhbGxiYWNrXSA9IGdldFN0YXRPcHRzQW5kQ2IoYSwgYik7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnN0YXRCYXNlLCBbZmQsIG9wdHMuYmlnaW50XSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZW5hbWVCYXNlKG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmsoZmlsZW5hbWVUb1N0ZXBzKG9sZFBhdGhGaWxlbmFtZSkpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIFwicmVuYW1lXCIsIG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgaXQgaXMgZGlyZWN0b3J5LCBpZiBub24tZW1wdHksIHdlIGNhbm5vdCBtb3ZlIGl0LCByaWdodD9cbiAgICAgICAgY29uc3QgbmV3UGF0aFN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIENoZWNrIGRpcmVjdG9yeSBleGlzdHMgZm9yIHRoZSBuZXcgbG9jYXRpb24uXG4gICAgICAgIGNvbnN0IG5ld1BhdGhEaXJMaW5rID0gdGhpcy5nZXRMaW5rUGFyZW50KG5ld1BhdGhTdGVwcyk7XG4gICAgICAgIGlmICghbmV3UGF0aERpckxpbmspXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQsIFwicmVuYW1lXCIsIG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogQWxzbyB0cmVhdCBjYXNlcyB3aXRoIGRpcmVjdG9yaWVzIGFuZCBzeW1ib2xpYyBsaW5rcy5cbiAgICAgICAgLy8gVE9ETzogU2VlOiBodHRwOi8vbWFuNy5vcmcvbGludXgvbWFuLXBhZ2VzL21hbjIvcmVuYW1lLjIuaHRtbFxuICAgICAgICAvLyBSZW1vdmUgaGFyZCBsaW5rIGZyb20gb2xkIGZvbGRlci5cbiAgICAgICAgY29uc3Qgb2xkTGlua1BhcmVudCA9IGxpbmsucGFyZW50O1xuICAgICAgICBpZiAob2xkTGlua1BhcmVudCkge1xuICAgICAgICAgICAgb2xkTGlua1BhcmVudC5kZWxldGVDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5hbWUgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgbmV3IHBhdGgsIGlmIHRoYXQgZXhpc3RzLlxuICAgICAgICBjb25zdCBuYW1lID0gbmV3UGF0aFN0ZXBzW25ld1BhdGhTdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGluay5uYW1lID0gbmFtZTtcbiAgICAgICAgbGluay5zdGVwcyA9IFsuLi5uZXdQYXRoRGlyTGluay5zdGVwcywgbmFtZV07XG4gICAgICAgIG5ld1BhdGhEaXJMaW5rLnNldENoaWxkKGxpbmsuZ2V0TmFtZSgpLCBsaW5rKTtcbiAgICB9XG4gICAgcmVuYW1lU3luYyhvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICAgIGNvbnN0IG9sZFBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG9sZFBhdGgpO1xuICAgICAgICBjb25zdCBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy5yZW5hbWVCYXNlKG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICB9XG4gICAgcmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9sZFBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG9sZFBhdGgpO1xuICAgICAgICBjb25zdCBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZW5hbWVCYXNlLCBbb2xkUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGV4aXN0c0Jhc2UoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zdGF0QmFzZShmaWxlbmFtZSk7XG4gICAgfVxuICAgIGV4aXN0c1N5bmMocGF0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RzQmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXN0cyhwYXRoLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJTVFIuQ0IpO1xuICAgICAgICAoMCwgc2V0SW1tZWRpYXRlXzEuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLmV4aXN0c0Jhc2UoZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY2Nlc3NCYXNlKGZpbGVuYW1lLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCBcImFjY2Vzc1wiKTtcbiAgICAgICAgLy8gVE9ETzogVmVyaWZ5IHBlcm1pc3Npb25zXG4gICAgfVxuICAgIGFjY2Vzc1N5bmMocGF0aCwgbW9kZSA9IEZfT0spIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgbW9kZSA9IG1vZGUgfCAwO1xuICAgICAgICB0aGlzLmFjY2Vzc0Jhc2UoZmlsZW5hbWUsIG1vZGUpO1xuICAgIH1cbiAgICBhY2Nlc3MocGF0aCwgYSwgYikge1xuICAgICAgICBsZXQgbW9kZSA9IEZfT0s7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1vZGUgPSBhIHwgMDsgLy8gY2FzdCB0byBudW1iZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjayhiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmFjY2Vzc0Jhc2UsIFtmaWxlbmFtZSwgbW9kZV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYXBwZW5kRmlsZVN5bmMoaWQsIGRhdGEsIG9wdGlvbnMgPSBhcHBlbmRGaWxlRGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGdldEFwcGVuZEZpbGVPcHRzKG9wdGlvbnMpO1xuICAgICAgICAvLyBmb3JjZSBhcHBlbmQgYmVoYXZpb3Igd2hlbiB1c2luZyBhIHN1cHBsaWVkIGZpbGUgZGVzY3JpcHRvclxuICAgICAgICBpZiAoIW9wdHMuZmxhZyB8fCBpc0ZkKGlkKSlcbiAgICAgICAgICAgIG9wdHMuZmxhZyA9IFwiYVwiO1xuICAgICAgICB0aGlzLndyaXRlRmlsZVN5bmMoaWQsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgICBhcHBlbmRGaWxlKGlkLCBkYXRhLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSBnZXRBcHBlbmRGaWxlT3B0c0FuZENiKGEsIGIpO1xuICAgICAgICAvLyBmb3JjZSBhcHBlbmQgYmVoYXZpb3Igd2hlbiB1c2luZyBhIHN1cHBsaWVkIGZpbGUgZGVzY3JpcHRvclxuICAgICAgICBpZiAoIW9wdHMuZmxhZyB8fCBpc0ZkKGlkKSlcbiAgICAgICAgICAgIG9wdHMuZmxhZyA9IFwiYVwiO1xuICAgICAgICB0aGlzLndyaXRlRmlsZShpZCwgZGF0YSwgb3B0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZWFkZGlyQmFzZShmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcyk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgXCJyZWFkZGlyXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIW5vZGUuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT1RESVIsIFwic2NhbmRpclwiLCBmaWxlbmFtZSk7XG4gICAgICAgIGlmIChvcHRpb25zLndpdGhGaWxlVHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBsaW5rLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBsaW5rLmdldENoaWxkKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChEaXJlbnRfMS5kZWZhdWx0LmJ1aWxkKGNoaWxkLCBvcHRpb25zLmVuY29kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzV2luICYmIG9wdGlvbnMuZW5jb2RpbmcgIT09IFwiYnVmZmVyXCIpXG4gICAgICAgICAgICAgICAgbGlzdC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPiBiLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBsaW5rLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goKDAsIGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZykobmFtZSwgb3B0aW9ucy5lbmNvZGluZykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXaW4gJiYgb3B0aW9ucy5lbmNvZGluZyAhPT0gXCJidWZmZXJcIilcbiAgICAgICAgICAgIGxpc3Quc29ydCgpO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmVhZGRpclN5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gZ2V0UmVhZGRpck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRkaXJCYXNlKGZpbGVuYW1lLCBvcHRzKTtcbiAgICB9XG4gICAgcmVhZGRpcihwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRpb25zLCBjYWxsYmFja10gPSBnZXRSZWFkZGlyT3B0c0FuZENiKGEsIGIpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlYWRkaXJCYXNlLCBbZmlsZW5hbWUsIG9wdGlvbnNdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJlYWRsaW5rQmFzZShmaWxlbmFtZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsIFwicmVhZGxpbmtcIik7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlLmlzU3ltbGluaygpKVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRUlOVkFMLCBcInJlYWRsaW5rXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3Qgc3RyID0gc2VwICsgbm9kZS5zeW1saW5rLmpvaW4oc2VwKTtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKHN0ciwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZWFkbGlua1N5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gZ2V0RGVmYXVsdE9wdHMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRsaW5rQmFzZShmaWxlbmFtZSwgb3B0cy5lbmNvZGluZyk7XG4gICAgfVxuICAgIHJlYWRsaW5rKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgW29wdHMsIGNhbGxiYWNrXSA9IGdldERlZmF1bHRPcHRzQW5kQ2IoYSwgYik7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhZGxpbmtCYXNlLCBbZmlsZW5hbWUsIG9wdHMuZW5jb2RpbmddLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZzeW5jQmFzZShmZCkge1xuICAgICAgICB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgXCJmc3luY1wiKTtcbiAgICB9XG4gICAgZnN5bmNTeW5jKGZkKSB7XG4gICAgICAgIHRoaXMuZnN5bmNCYXNlKGZkKTtcbiAgICB9XG4gICAgZnN5bmMoZmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnN5bmNCYXNlLCBbZmRdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZkYXRhc3luY0Jhc2UoZmQpIHtcbiAgICAgICAgdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsIFwiZmRhdGFzeW5jXCIpO1xuICAgIH1cbiAgICBmZGF0YXN5bmNTeW5jKGZkKSB7XG4gICAgICAgIHRoaXMuZmRhdGFzeW5jQmFzZShmZCk7XG4gICAgfVxuICAgIGZkYXRhc3luYyhmZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mZGF0YXN5bmNCYXNlLCBbZmRdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZ0cnVuY2F0ZUJhc2UoZmQsIGxlbikge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsIFwiZnRydW5jYXRlXCIpO1xuICAgICAgICBmaWxlLnRydW5jYXRlKGxlbik7XG4gICAgfVxuICAgIGZ0cnVuY2F0ZVN5bmMoZmQsIGxlbikge1xuICAgICAgICB0aGlzLmZ0cnVuY2F0ZUJhc2UoZmQsIGxlbik7XG4gICAgfVxuICAgIGZ0cnVuY2F0ZShmZCwgYSwgYikge1xuICAgICAgICBjb25zdCBsZW4gPSB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiA/IGEgOiAwO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbGlkYXRlQ2FsbGJhY2sodHlwZW9mIGEgPT09IFwibnVtYmVyXCIgPyBiIDogYSk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnRydW5jYXRlQmFzZSwgW2ZkLCBsZW5dLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHRydW5jYXRlQmFzZShwYXRoLCBsZW4pIHtcbiAgICAgICAgY29uc3QgZmQgPSB0aGlzLm9wZW5TeW5jKHBhdGgsIFwicitcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZ0cnVuY2F0ZVN5bmMoZmQsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ1bmNhdGVTeW5jKGlkLCBsZW4pIHtcbiAgICAgICAgaWYgKGlzRmQoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnRydW5jYXRlU3luYyhpZCwgbGVuKTtcbiAgICAgICAgdGhpcy50cnVuY2F0ZUJhc2UoaWQsIGxlbik7XG4gICAgfVxuICAgIHRydW5jYXRlKGlkLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHR5cGVvZiBhID09PSBcIm51bWJlclwiID8gYSA6IDA7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjayh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiA/IGIgOiBhKTtcbiAgICAgICAgaWYgKGlzRmQoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnRydW5jYXRlKGlkLCBsZW4sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy50cnVuY2F0ZUJhc2UsIFtpZCwgbGVuXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmdXRpbWVzQmFzZShmZCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgXCJmdXRpbWVzXCIpO1xuICAgICAgICBjb25zdCBub2RlID0gZmlsZS5ub2RlO1xuICAgICAgICBub2RlLmF0aW1lID0gbmV3IERhdGUoYXRpbWUgKiAxMDAwKTtcbiAgICAgICAgbm9kZS5tdGltZSA9IG5ldyBEYXRlKG10aW1lICogMTAwMCk7XG4gICAgfVxuICAgIGZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgdGhpcy5mdXRpbWVzQmFzZShmZCwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKSk7XG4gICAgfVxuICAgIGZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mdXRpbWVzQmFzZSwgW2ZkLCB0b1VuaXhUaW1lc3RhbXAoYXRpbWUpLCB0b1VuaXhUaW1lc3RhbXAobXRpbWUpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICB1dGltZXNCYXNlKGZpbGVuYW1lLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgY29uc3QgZmQgPSB0aGlzLm9wZW5TeW5jKGZpbGVuYW1lLCBcInJcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZ1dGltZXNCYXNlKGZkLCBhdGltZSwgbXRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHV0aW1lc1N5bmMocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHRoaXMudXRpbWVzQmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKSk7XG4gICAgfVxuICAgIHV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMudXRpbWVzQmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCB0b1VuaXhUaW1lc3RhbXAoYXRpbWUpLCB0b1VuaXhUaW1lc3RhbXAobXRpbWUpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBta2RpckJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdXNlciB0cmllcyB0byBjcmVhdGUgcm9vdCBkaXIgYGZzLm1rZGlyU3luYygnLycpYC5cbiAgICAgICAgaWYgKCFzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVFWElTVCwgXCJta2RpclwiLCBmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlyID0gdGhpcy5nZXRMaW5rUGFyZW50QXNEaXJPclRocm93KGZpbGVuYW1lLCBcIm1rZGlyXCIpO1xuICAgICAgICAvLyBDaGVjayBwYXRoIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBjb25zdCBuYW1lID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkaXIuZ2V0Q2hpbGQobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFRVhJU1QsIFwibWtkaXJcIiwgZmlsZW5hbWUpO1xuICAgICAgICBkaXIuY3JlYXRlQ2hpbGQobmFtZSwgdGhpcy5jcmVhdGVOb2RlKHRydWUsIG1vZGVOdW0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBkaXJlY3RvcnkgdHJlZSByZWN1cnNpdmVseS5cbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gbW9kZU51bVxuICAgICAqL1xuICAgIG1rZGlycEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICBsZXQgbGluayA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgaWYgKCFsaW5rLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT1RESVIsIFwibWtkaXJcIiwgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBsaW5rLmdldENoaWxkKHN0ZXApO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9URElSLCBcIm1rZGlyXCIsIGNoaWxkLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gbGluay5jcmVhdGVDaGlsZChzdGVwLCB0aGlzLmNyZWF0ZU5vZGUodHJ1ZSwgbW9kZU51bSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1rZGlyU3luYyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRNa2Rpck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIob3B0cy5tb2RlLCAwbzc3Nyk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShmaWxlbmFtZSwgbW9kZU51bSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWtkaXJCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICB9XG4gICAgbWtkaXIocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBvcHRzID0gZ2V0TWtkaXJPcHRpb25zKGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbGlkYXRlQ2FsbGJhY2sodHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIiA/IGEgOiBiKTtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9IG1vZGVUb051bWJlcihvcHRzLm1vZGUsIDBvNzc3KTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKG9wdHMucmVjdXJzaXZlKVxuICAgICAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ta2RpcnBCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubWtkaXJCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vIGxlZ2FjeSBpbnRlcmZhY2VcbiAgICBta2RpcnBTeW5jKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgdGhpcy5ta2RpclN5bmMocGF0aCwgeyBtb2RlLCByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIG1rZGlycChwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiID8gdW5kZWZpbmVkIDogYTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWxpZGF0ZUNhbGxiYWNrKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgPyBhIDogYik7XG4gICAgICAgIHRoaXMubWtkaXIocGF0aCwgeyBtb2RlLCByZWN1cnNpdmU6IHRydWUgfSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBta2R0ZW1wQmFzZShwcmVmaXgsIGVuY29kaW5nLCByZXRyeSA9IDUpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwcmVmaXggKyB0aGlzLmdlblJuZFN0cigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ta2RpckJhc2UoZmlsZW5hbWUsIDUxMSAvKiBNT0RFLkRJUiAqLyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZykoZmlsZW5hbWUsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEVFWElTVCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeSA+IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1rZHRlbXBCYXNlKHByZWZpeCwgZW5jb2RpbmcsIHJldHJ5IC0gMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgdGVtcCBkaXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBta2R0ZW1wU3luYyhwcmVmaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBlbmNvZGluZyB9ID0gZ2V0RGVmYXVsdE9wdHMob3B0aW9ucyk7XG4gICAgICAgIGlmICghcHJlZml4IHx8IHR5cGVvZiBwcmVmaXggIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmlsZW5hbWUgcHJlZml4IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBudWxsQ2hlY2socHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWtkdGVtcEJhc2UocHJlZml4LCBlbmNvZGluZyk7XG4gICAgfVxuICAgIG1rZHRlbXAocHJlZml4LCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFt7IGVuY29kaW5nIH0sIGNhbGxiYWNrXSA9IGdldERlZmF1bHRPcHRzQW5kQ2IoYSwgYik7XG4gICAgICAgIGlmICghcHJlZml4IHx8IHR5cGVvZiBwcmVmaXggIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmlsZW5hbWUgcHJlZml4IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBpZiAoIW51bGxDaGVjayhwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLm1rZHRlbXBCYXNlLCBbcHJlZml4LCBlbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcm1kaXJCYXNlKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRSbWRpck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmtBc0Rpck9yVGhyb3coZmlsZW5hbWUsIFwicm1kaXJcIik7XG4gICAgICAgIC8vIENoZWNrIGRpcmVjdG9yeSBpcyBlbXB0eS5cbiAgICAgICAgaWYgKGxpbmsubGVuZ3RoICYmICFvcHRzLnJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT1RFTVBUWSwgXCJybWRpclwiLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlTGluayhsaW5rKTtcbiAgICB9XG4gICAgcm1kaXJTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ybWRpckJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBybWRpcihwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRSbWRpck9wdGlvbnMoYSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjayh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiID8gYSA6IGIpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJtZGlyQmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCBvcHRzXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBybUJhc2UoZmlsZW5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgIC8vIFwic3RhdFwiIGlzIHVzZWQgdG8gbWF0Y2ggTm9kZSdzIG5hdGl2ZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZvcmNlKVxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCwgXCJzdGF0XCIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluay5nZXROb2RlKCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVSUl9GU19FSVNESVIsIFwicm1cIiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZXRlTGluayhsaW5rKTtcbiAgICB9XG4gICAgcm1TeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ybUJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBybShwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSBnZXRSbU9wdHNBbmRDYihhLCBiKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ybUJhc2UsIFtwYXRoVG9GaWxlbmFtZShwYXRoKSwgb3B0c10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZmNobW9kQmFzZShmZCwgbW9kZU51bSkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsIFwiZmNobW9kXCIpO1xuICAgICAgICBmaWxlLmNobW9kKG1vZGVOdW0pO1xuICAgIH1cbiAgICBmY2htb2RTeW5jKGZkLCBtb2RlKSB7XG4gICAgICAgIHRoaXMuZmNobW9kQmFzZShmZCwgbW9kZVRvTnVtYmVyKG1vZGUpKTtcbiAgICB9XG4gICAgZmNobW9kKGZkLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZjaG1vZEJhc2UsIFtmZCwgbW9kZVRvTnVtYmVyKG1vZGUpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjaG1vZEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgY29uc3QgZmQgPSB0aGlzLm9wZW5TeW5jKGZpbGVuYW1lLCBcInJcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZjaG1vZEJhc2UoZmQsIG1vZGVOdW0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNobW9kU3luYyhwYXRoLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIobW9kZSk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMuY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICB9XG4gICAgY2htb2QocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jaG1vZEJhc2UsIFtmaWxlbmFtZSwgbW9kZU51bV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbGNobW9kQmFzZShmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICBjb25zdCBmZCA9IHRoaXMub3BlbkJhc2UoZmlsZW5hbWUsIE9fUkRXUiwgMCwgZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mY2htb2RCYXNlKGZkLCBtb2RlTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsY2htb2RTeW5jKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5sY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICB9XG4gICAgbGNobW9kKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIobW9kZSk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubGNobW9kQmFzZSwgW2ZpbGVuYW1lLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmY2hvd25CYXNlKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgXCJmY2hvd25cIikuY2hvd24odWlkLCBnaWQpO1xuICAgIH1cbiAgICBmY2hvd25TeW5jKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB2YWxpZGF0ZVVpZCh1aWQpO1xuICAgICAgICB2YWxpZGF0ZUdpZChnaWQpO1xuICAgICAgICB0aGlzLmZjaG93bkJhc2UoZmQsIHVpZCwgZ2lkKTtcbiAgICB9XG4gICAgZmNob3duKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mY2hvd25CYXNlLCBbZmQsIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjaG93bkJhc2UoZmlsZW5hbWUsIHVpZCwgZ2lkKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGlua09yVGhyb3coZmlsZW5hbWUsIFwiY2hvd25cIik7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5jaG93bih1aWQsIGdpZCk7XG4gICAgICAgIC8vIGlmKG5vZGUuaXNGaWxlKCkgfHwgbm9kZS5pc1N5bWxpbmsoKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyB9IGVsc2UgaWYobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IFdoYXQgZG8gd2UgZG8gaGVyZT9cbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICBjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy5jaG93bkJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIHVpZCwgZ2lkKTtcbiAgICB9XG4gICAgY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuY2hvd25CYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBsY2hvd25CYXNlKGZpbGVuYW1lLCB1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCBcImxjaG93blwiKS5nZXROb2RlKCkuY2hvd24odWlkLCBnaWQpO1xuICAgIH1cbiAgICBsY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMubGNob3duQmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSwgdWlkLCBnaWQpO1xuICAgIH1cbiAgICBsY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubGNob3duQmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCB1aWQsIGdpZF0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd2F0Y2hGaWxlKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhO1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBhO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignXCJ3YXRjaEZpbGUoKVwiIHJlcXVpcmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSA1MDA3O1xuICAgICAgICBsZXQgcGVyc2lzdGVudCA9IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBlcnNpc3RlbnQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHBlcnNpc3RlbnQgPSBvcHRpb25zLnBlcnNpc3RlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhdGNoZXIgPSB0aGlzLnN0YXRXYXRjaGVyc1tmaWxlbmFtZV07XG4gICAgICAgIGlmICghd2F0Y2hlcikge1xuICAgICAgICAgICAgd2F0Y2hlciA9IG5ldyB0aGlzLlN0YXRXYXRjaGVyKCk7XG4gICAgICAgICAgICB3YXRjaGVyLnN0YXJ0KGZpbGVuYW1lLCBwZXJzaXN0ZW50LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRXYXRjaGVyc1tmaWxlbmFtZV0gPSB3YXRjaGVyO1xuICAgICAgICB9XG4gICAgICAgIHdhdGNoZXIuYWRkTGlzdGVuZXIoXCJjaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gd2F0Y2hlcjtcbiAgICB9XG4gICAgdW53YXRjaEZpbGUocGF0aCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IHRoaXMuc3RhdFdhdGNoZXJzW2ZpbGVuYW1lXTtcbiAgICAgICAgaWYgKCF3YXRjaGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhdGNoZXIucmVtb3ZlTGlzdGVuZXIoXCJjaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2F0Y2hlci5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhdGNoZXIubGlzdGVuZXJDb3VudChcImNoYW5nZVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgd2F0Y2hlci5zdG9wKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHdhdGNoKHBhdGg6IFBhdGhMaWtlKTogRlNXYXRjaGVyO1xuICAgIC8vIHdhdGNoKHBhdGg6IFBhdGhMaWtlLCBvcHRpb25zPzogSVdhdGNoT3B0aW9ucyB8IHN0cmluZyk6IEZTV2F0Y2hlcjtcbiAgICB3YXRjaChwYXRoLCBvcHRpb25zLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBsZXQgZ2l2ZW5PcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0aW9ucztcbiAgICAgICAgICAgIGdpdmVuT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBsZXQgeyBwZXJzaXN0ZW50LCByZWN1cnNpdmUsIGVuY29kaW5nIH0gPSBnZXREZWZhdWx0T3B0cyhnaXZlbk9wdGlvbnMpO1xuICAgICAgICBpZiAocGVyc2lzdGVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGVyc2lzdGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWN1cnNpdmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB3YXRjaGVyID0gbmV3IHRoaXMuRlNXYXRjaGVyKCk7XG4gICAgICAgIHdhdGNoZXIuc3RhcnQoZmlsZW5hbWUsIHBlcnNpc3RlbnQsIHJlY3Vyc2l2ZSwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXIuYWRkTGlzdGVuZXIoXCJjaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyO1xuICAgIH1cbn1cbmV4cG9ydHMuVm9sdW1lID0gVm9sdW1lO1xuLyoqXG4gKiBHbG9iYWwgZmlsZSBkZXNjcmlwdG9yIGNvdW50ZXIuIFVOSVggZmlsZSBkZXNjcmlwdG9ycyBzdGFydCBmcm9tIDAgYW5kIGdvIHNlcXVlbnRpYWxseVxuICogdXAsIHNvIGhlcmUsIGluIG9yZGVyIG5vdCB0byBjb25mbGljdCB3aXRoIHRoZW0sIHdlIGNob29zZSBzb21lIGJpZyBudW1iZXIgYW5kIGRlc2NyZWFzZVxuICogdGhlIGZpbGUgZGVzY3JpcHRvciBvZiBldmVyeSBuZXcgb3BlbmVkIGZpbGUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHRvZG8gVGhpcyBzaG91bGQgbm90IGJlIHN0YXRpYywgcmlnaHQ/XG4gKi9cblZvbHVtZS5mZCA9IDB4N2ZmZmZmZmY7XG5mdW5jdGlvbiBlbWl0U3RvcChzZWxmKSB7XG4gICAgc2VsZi5lbWl0KFwic3RvcFwiKTtcbn1cbmNsYXNzIFN0YXRXYXRjaGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2b2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vbkludGVydmFsID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMudm9sLnN0YXRTeW5jKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZWQoc3RhdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBzdGF0cywgdGhpcy5wcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2ID0gc3RhdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudm9sID0gdm9sO1xuICAgIH1cbiAgICBsb29wKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRSZWYgPSB0aGlzLnNldFRpbWVvdXQodGhpcy5vbkludGVydmFsLCB0aGlzLmludGVydmFsKTtcbiAgICB9XG4gICAgaGFzQ2hhbmdlZChzdGF0cykge1xuICAgICAgICAvLyBpZighdGhpcy5wcmV2KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0cy5tdGltZU1zID4gdGhpcy5wcmV2Lm10aW1lTXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHN0YXRzLm5saW5rICE9PSB0aGlzLnByZXYubmxpbmspXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGFydChwYXRoLCBwZXJzaXN0ZW50ID0gdHJ1ZSwgaW50ZXJ2YWwgPSA1MDA3KSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0ID0gcGVyc2lzdGVudFxuICAgICAgICAgICAgPyBzZXRUaW1lb3V0LmJpbmQodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogZ2xvYmFsKVxuICAgICAgICAgICAgOiBzZXRUaW1lb3V0VW5yZWZfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMudm9sLnN0YXRTeW5jKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmxvb3AoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gICAgICAgIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKGVtaXRTdG9wLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLlN0YXRXYXRjaGVyID0gU3RhdFdhdGNoZXI7XG52YXIgcG9vbDtcbmZ1bmN0aW9uIGFsbG9jTmV3UG9vbChwb29sU2l6ZSkge1xuICAgIHBvb2wgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKHBvb2xTaXplKTtcbiAgICBwb29sLnVzZWQgPSAwO1xufVxudXRpbC5pbmhlcml0cyhGc1JlYWRTdHJlYW0sIHN0cmVhbV8xLlJlYWRhYmxlKTtcbmV4cG9ydHMuUmVhZFN0cmVhbSA9IEZzUmVhZFN0cmVhbTtcbmZ1bmN0aW9uIEZzUmVhZFN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRnNSZWFkU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGc1JlYWRTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKTtcbiAgICB0aGlzLl92b2wgPSB2b2w7XG4gICAgLy8gYSBsaXR0bGUgYml0IGJpZ2dlciBidWZmZXIgYW5kIHdhdGVyIG1hcmtzIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0T3B0aW9ucyhvcHRpb25zLCB7fSkpO1xuICAgIGlmIChvcHRpb25zLmhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5oaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0O1xuICAgIHN0cmVhbV8xLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgdGhpcy5mZCA9IG9wdGlvbnMuZmQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmZkO1xuICAgIHRoaXMuZmxhZ3MgPSBvcHRpb25zLmZsYWdzID09PSB1bmRlZmluZWQgPyBcInJcIiA6IG9wdGlvbnMuZmxhZ3M7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdGlvbnMubW9kZTtcbiAgICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kO1xuICAgIHRoaXMuYXV0b0Nsb3NlID0gb3B0aW9ucy5hdXRvQ2xvc2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmF1dG9DbG9zZTtcbiAgICB0aGlzLnBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDA7XG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RhcnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmVuZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIDw9IFwiZW5kXCIgb3B0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgIHRoaXMub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIChlciwgZmQpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZkID0gZmQ7XG4gICAgICAgIHNlbGYuZW1pdChcIm9wZW5cIiwgZmQpO1xuICAgICAgICAvLyBzdGFydCB0aGUgZmxvdyBvZiBkYXRhLlxuICAgICAgICBzZWxmLnJlYWQoKTtcbiAgICB9KTtcbn07XG5Gc1JlYWRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25jZShcIm9wZW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZChuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghcG9vbCB8fCBwb29sLmxlbmd0aCAtIHBvb2wudXNlZCA8IGtNaW5Qb29sU3BhY2UpIHtcbiAgICAgICAgLy8gZGlzY2FyZCB0aGUgb2xkIHBvb2wuXG4gICAgICAgIGFsbG9jTmV3UG9vbCh0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIH1cbiAgICAvLyBHcmFiIGFub3RoZXIgcmVmZXJlbmNlIHRvIHRoZSBwb29sIGluIHRoZSBjYXNlIHRoYXQgd2hpbGUgd2UncmVcbiAgICAvLyBpbiB0aGUgdGhyZWFkIHBvb2wgYW5vdGhlciByZWFkKCkgZmluaXNoZXMgdXAgdGhlIHBvb2wsIGFuZFxuICAgIC8vIGFsbG9jYXRlcyBhIG5ldyBvbmUuXG4gICAgdmFyIHRoaXNQb29sID0gcG9vbDtcbiAgICB2YXIgdG9SZWFkID0gTWF0aC5taW4ocG9vbC5sZW5ndGggLSBwb29sLnVzZWQsIG4pO1xuICAgIHZhciBzdGFydCA9IHBvb2wudXNlZDtcbiAgICBpZiAodGhpcy5wb3MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdG9SZWFkID0gTWF0aC5taW4odGhpcy5lbmQgLSB0aGlzLnBvcyArIDEsIHRvUmVhZCk7XG4gICAgLy8gYWxyZWFkeSByZWFkIGV2ZXJ5dGhpbmcgd2Ugd2VyZSBzdXBwb3NlZCB0byByZWFkIVxuICAgIC8vIHRyZWF0IGFzIEVPRi5cbiAgICBpZiAodG9SZWFkIDw9IDApXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2gobnVsbCk7XG4gICAgLy8gdGhlIGFjdHVhbCByZWFkLlxuICAgIHZhciBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICB0aGlzLl92b2wucmVhZCh0aGlzLmZkLCBwb29sLCBwb29sLnVzZWQsIHRvUmVhZCwgdGhpcy5wb3MsIG9ucmVhZCk7XG4gICAgLy8gbW92ZSB0aGUgcG9vbCBwb3NpdGlvbnMsIGFuZCBpbnRlcm5hbCBwb3NpdGlvbiBmb3IgcmVhZGluZy5cbiAgICBpZiAodGhpcy5wb3MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5wb3MgKz0gdG9SZWFkO1xuICAgIHBvb2wudXNlZCArPSB0b1JlYWQ7XG4gICAgZnVuY3Rpb24gb25yZWFkKGVyLCBieXRlc1JlYWQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UgJiYgc2VsZi5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYnl0ZXNSZWFkID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYnl0ZXNSZWFkICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICBiID0gdGhpc1Bvb2wuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXNSZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5Gc1JlYWRTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgICB0aGlzLmNsb3NlKChlcnIyKSA9PiB7XG4gICAgICAgIGNiKGVyciB8fCBlcnIyKTtcbiAgICB9KTtcbn07XG5Gc1JlYWRTdHJlYW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKVxuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBjYik7XG4gICAgaWYgKHRoaXMuY2xvc2VkIHx8IHR5cGVvZiB0aGlzLmZkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwib3BlblwiLCBjbG9zZU9uT3Blbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKCgpID0+IHRoaXMuZW1pdChcImNsb3NlXCIpKTtcbiAgICB9XG4gICAgLy8gU2luY2UgTm9kZSAxOCwgdGhlcmUgaXMgb25seSBhIGdldHRlciBmb3IgJy5jbG9zZWQnLlxuICAgIC8vIFRoZSBmaXJzdCBicmFuY2ggbWltaWNzIG90aGVyIHNldHRlcnMgZnJvbSBSZWFkYWJsZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE4LjAuMC9saWIvaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZS5qcyNMMTI0M1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcmVhZGFibGVTdGF0ZT8uY2xvc2VkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3ZvbC5jbG9zZSh0aGlzLmZkLCAoZXIpID0+IHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLmZkID0gbnVsbDtcbn07XG4vLyBuZWVkZWQgYmVjYXVzZSBhcyBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50c1xuLy8gdGhhdCBkb2VzIG5vdCBtYXRjaCB0aGlzLmNsb3NlKCkgc2lnbmF0dXJlXG5mdW5jdGlvbiBjbG9zZU9uT3BlbihmZCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbn1cbnV0aWwuaW5oZXJpdHMoRnNXcml0ZVN0cmVhbSwgc3RyZWFtXzEuV3JpdGFibGUpO1xuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IEZzV3JpdGVTdHJlYW07XG5mdW5jdGlvbiBGc1dyaXRlU3RyZWFtKHZvbCwgcGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGc1dyaXRlU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGc1dyaXRlU3RyZWFtKHZvbCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fdm9sID0gdm9sO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBnZXRPcHRpb25zKG9wdGlvbnMsIHt9KSk7XG4gICAgc3RyZWFtXzEuV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICB0aGlzLmZkID0gb3B0aW9ucy5mZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZmQ7XG4gICAgdGhpcy5mbGFncyA9IG9wdGlvbnMuZmxhZ3MgPT09IHVuZGVmaW5lZCA/IFwid1wiIDogb3B0aW9ucy5mbGFncztcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0aW9ucy5tb2RlO1xuICAgIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuYXV0b0Nsb3NlID0gb3B0aW9ucy5hdXRvQ2xvc2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuYXV0b0Nsb3NlO1xuICAgIHRoaXMucG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RhcnRcIiBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nKVxuICAgICAgICB0aGlzLnNldERlZmF1bHRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgIC8vIGRpc3Bvc2Ugb24gZmluaXNoLlxuICAgIHRoaXMub25jZShcImZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ZvbC5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlICYmIHRoaXMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmQgPSBmZDtcbiAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiLCBmZCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJ1ZmZlcl8xLkJ1ZmZlciB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGFcIikpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmNlKFwib3BlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShkYXRhLCBlbmNvZGluZywgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXRoaXMtYXNzaWdubWVudFxuICAgIHRoaXMuX3ZvbC53cml0ZSh0aGlzLmZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgdGhpcy5wb3MsIChlciwgYnl0ZXMpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UgJiYgc2VsZi5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBjYigpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnBvcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnBvcyArPSBkYXRhLmxlbmd0aDtcbn07XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2ID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uY2UoXCJvcGVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRldihkYXRhLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY2h1bmsgPSBkYXRhW2ldLmNodW5rO1xuICAgICAgICBjaHVua3NbaV0gPSBjaHVuaztcbiAgICAgICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICB0aGlzLl92b2wud3JpdGUodGhpcy5mZCwgYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzLnBvcywgKGVyLCBieXRlcykgPT4ge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBjYigpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnBvcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnBvcyArPSBzaXplO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKVxuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBjYik7XG4gICAgaWYgKHRoaXMuY2xvc2VkIHx8IHR5cGVvZiB0aGlzLmZkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwib3BlblwiLCBjbG9zZU9uT3Blbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKCgpID0+IHRoaXMuZW1pdChcImNsb3NlXCIpKTtcbiAgICB9XG4gICAgLy8gU2luY2UgTm9kZSAxOCwgdGhlcmUgaXMgb25seSBhIGdldHRlciBmb3IgJy5jbG9zZWQnLlxuICAgIC8vIFRoZSBmaXJzdCBicmFuY2ggbWltaWNzIG90aGVyIHNldHRlcnMgZnJvbSBXcml0YWJsZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE4LjAuMC9saWIvaW50ZXJuYWwvc3RyZWFtcy93cml0YWJsZS5qcyNMNzY2XG4gICAgaWYgKHR5cGVvZiB0aGlzLl93cml0YWJsZVN0YXRlPy5jbG9zZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdm9sLmNsb3NlKHRoaXMuZmQsIChlcikgPT4ge1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuZmQgPSBudWxsO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveTtcbi8vIFRoZXJlIGlzIG5vIHNodXRkb3duKCkgZm9yIGZpbGVzLlxuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveVNvb24gPSBGc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5lbmQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZTV2F0Y2hlclxuY2xhc3MgRlNXYXRjaGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2b2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9maWxlbmFtZUVuY29kZWQgPSBcIlwiO1xuICAgICAgICAvLyBfcGVyc2lzdGVudDogYm9vbGVhbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGODtcbiAgICAgICAgdGhpcy5fb25Ob2RlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25QYXJlbnRDaGlsZCA9IChsaW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAobGluay5nZXROYW1lKCkgPT09IHRoaXMuX2dldE5hbWUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJyZW5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VtaXQgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHR5cGUsIHRoaXMuX2ZpbGVuYW1lRW5jb2RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BlcnNpc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQodGhpcy5fcGVyc2lzdCwgMWU2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdm9sID0gdm9sO1xuICAgICAgICAvLyBUT0RPOiBFbWl0IFwiZXJyb3JcIiBtZXNzYWdlcyB3aGVuIHdhdGNoaW5nLlxuICAgICAgICAvLyB0aGlzLl9oYW5kbGUub25jaGFuZ2UgPSBmdW5jdGlvbihzdGF0dXMsIGV2ZW50VHlwZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgLy8gICAgIGlmIChzdGF0dXMgPCAwKSB7XG4gICAgICAgIC8vICAgICAgICAgc2VsZi5faGFuZGxlLmNsb3NlKCk7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgZXJyb3IgPSAhZmlsZW5hbWUgP1xuICAgICAgICAvLyAgICAgICAgICAgICBlcnJub0V4Y2VwdGlvbihzdGF0dXMsICdFcnJvciB3YXRjaGluZyBmaWxlIGZvciBjaGFuZ2VzOicpIDpcbiAgICAgICAgLy8gICAgICAgICAgICAgZXJybm9FeGNlcHRpb24oc3RhdHVzLCBgRXJyb3Igd2F0Y2hpbmcgZmlsZSAke2ZpbGVuYW1lfSBmb3IgY2hhbmdlczpgKTtcbiAgICAgICAgLy8gICAgICAgICBlcnJvci5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuZW1pdCgnY2hhbmdlJywgZXZlbnRUeXBlLCBmaWxlbmFtZSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH07XG4gICAgfVxuICAgIF9nZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHN0YXJ0KHBhdGgsIHBlcnNpc3RlbnQgPSB0cnVlLCByZWN1cnNpdmUgPSBmYWxzZSwgZW5jb2RpbmcgPSBlbmNvZGluZ18xLkVOQ09ESU5HX1VURjgpIHtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHModGhpcy5fZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLl9maWxlbmFtZUVuY29kZWQgPSAoMCwgZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKSh0aGlzLl9maWxlbmFtZSk7XG4gICAgICAgIC8vIHRoaXMuX3BlcnNpc3RlbnQgPSBwZXJzaXN0ZW50O1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmUgPSByZWN1cnNpdmU7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rID0gdGhpcy5fdm9sLmdldExpbmtPclRocm93KHRoaXMuX2ZpbGVuYW1lLCBcIkZTV2F0Y2hlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgd2F0Y2ggJHt0aGlzLl9maWxlbmFtZX0gJHtlcnIuY29kZX1gKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgIGVycm9yLmVycm5vID0gZXJyLmNvZGU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5rLmdldE5vZGUoKS5vbihcImNoYW5nZVwiLCB0aGlzLl9vbk5vZGVDaGFuZ2UpO1xuICAgICAgICB0aGlzLl9saW5rLm9uKFwiY2hpbGQ6YWRkXCIsIHRoaXMuX29uTm9kZUNoYW5nZSk7XG4gICAgICAgIHRoaXMuX2xpbmsub24oXCJjaGlsZDpkZWxldGVcIiwgdGhpcy5fb25Ob2RlQ2hhbmdlKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5vbignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQuc2V0TWF4TGlzdGVuZXJzKHBhcmVudC5nZXRNYXhMaXN0ZW5lcnMoKSArIDEpO1xuICAgICAgICAgICAgcGFyZW50Lm9uKFwiY2hpbGQ6ZGVsZXRlXCIsIHRoaXMuX29uUGFyZW50Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0ZW50KVxuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdCgpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgICAgdGhpcy5fbGluay5nZXROb2RlKCkucmVtb3ZlTGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5fb25Ob2RlQ2hhbmdlKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5yZW1vdmVMaXN0ZW5lcignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlTGlzdGVuZXIoXCJjaGlsZDpkZWxldGVcIiwgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZTV2F0Y2hlciA9IEZTV2F0Y2hlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/volume.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@wapython/unionfs/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ufs = exports.Union = void 0;\nvar union_1 = __webpack_require__(/*! ./union */ \"(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/union.js\");\nexports.Union = union_1.Union;\nexports.ufs = new union_1.Union();\nexports[\"default\"] = exports.ufs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FweXRob24vdW5pb25mcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLGFBQWE7QUFDM0IsY0FBYyxtQkFBTyxDQUFDLGtGQUFTO0FBQy9CLGFBQWE7QUFDYixXQUFXO0FBQ1gsa0JBQWUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAd2FweXRob25cXHVuaW9uZnNcXGxpYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVmcyA9IGV4cG9ydHMuVW5pb24gPSB2b2lkIDA7XG52YXIgdW5pb25fMSA9IHJlcXVpcmUoXCIuL3VuaW9uXCIpO1xuZXhwb3J0cy5VbmlvbiA9IHVuaW9uXzEuVW5pb247XG5leHBvcnRzLnVmcyA9IG5ldyB1bmlvbl8xLlVuaW9uKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnVmcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/union.js":
/*!*****************************************************!*\
  !*** ./node_modules/@wapython/unionfs/lib/union.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Union = void 0;\nvar stream_1 = __webpack_require__(/*! stream */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/stream-browserify/index.js\");\nvar _a = __webpack_require__(/*! fs-monkey/lib/util/lists */ \"(pages-dir-browser)/./node_modules/fs-monkey/lib/util/lists.js\"), fsAsyncMethods = _a.fsAsyncMethods, fsSyncMethods = _a.fsSyncMethods;\nvar SPECIAL_METHODS = new Set([\n    \"existsSync\",\n    \"readdir\",\n    \"readdirSync\",\n    \"createReadStream\",\n    \"createWriteStream\",\n    \"watch\",\n    \"watchFile\",\n    \"unwatchFile\",\n]);\nvar SPECIAL_ERRORS = new Set([\"ENOTDIR\", \"EEXIST\"]);\nvar createFSProxy = function (watchers) {\n    return new Proxy({}, {\n        get: function (_obj, property) {\n            var e_1, _a;\n            var funcCallers = [];\n            var prop;\n            try {\n                for (var watchers_1 = __values(watchers), watchers_1_1 = watchers_1.next(); !watchers_1_1.done; watchers_1_1 = watchers_1.next()) {\n                    var watcher = watchers_1_1.value;\n                    prop = watcher[property];\n                    // if we're a function we wrap it in a bigger caller;\n                    if (typeof prop === \"function\") {\n                        funcCallers.push([watcher, prop]);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (watchers_1_1 && !watchers_1_1.done && (_a = watchers_1.return)) _a.call(watchers_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (funcCallers.length) {\n                return function () {\n                    var e_2, _a;\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    try {\n                        for (var funcCallers_1 = __values(funcCallers), funcCallers_1_1 = funcCallers_1.next(); !funcCallers_1_1.done; funcCallers_1_1 = funcCallers_1.next()) {\n                            var _b = __read(funcCallers_1_1.value, 2), watcher = _b[0], func = _b[1];\n                            func.apply(watcher, args);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (funcCallers_1_1 && !funcCallers_1_1.done && (_a = funcCallers_1.return)) _a.call(funcCallers_1);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                };\n            }\n            else {\n                return prop;\n            }\n        },\n    });\n};\nvar fsPromisesMethods = [\n    \"access\",\n    \"copyFile\",\n    \"open\",\n    \"opendir\",\n    \"rename\",\n    \"truncate\",\n    \"rmdir\",\n    \"mkdir\",\n    \"readdir\",\n    \"readlink\",\n    \"symlink\",\n    \"lstat\",\n    \"stat\",\n    \"link\",\n    \"unlink\",\n    \"chmod\",\n    \"lchmod\",\n    \"lchown\",\n    \"chown\",\n    \"utimes\",\n    \"realpath\",\n    \"mkdtemp\",\n    \"writeFile\",\n    \"appendFile\",\n    \"readFile\",\n];\n/**\n * Union object represents a stack of filesystems\n */\nvar Union = /** @class */ (function () {\n    function Union() {\n        var e_3, _a, e_4, _b, e_5, _c, e_6, _d;\n        var _this = this;\n        this.fss = [];\n        this.ReadStream = stream_1.Readable;\n        this.WriteStream = stream_1.Writable;\n        this.promises = {};\n        this.unwatchFile = function () {\n            var e_7, _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        fs.unwatchFile.apply(fs, args);\n                    }\n                    catch (e) {\n                        // dunno what to do here...\n                    }\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        };\n        this.watch = function () {\n            var e_8, _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var watchers = [];\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        var watcher = fs.watch.apply(fs, args);\n                        watchers.push(watcher);\n                    }\n                    catch (e) {\n                        // dunno what to do here...\n                    }\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n            // return a proxy to call functions on these props\n            return createFSProxy(watchers);\n        };\n        this.watchFile = function () {\n            var e_9, _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        fs.watchFile.apply(fs, args);\n                    }\n                    catch (e) {\n                        // dunno what to do here...\n                    }\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        };\n        this.existsSync = function (path) {\n            var e_10, _a;\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        if (fs.existsSync(path)) {\n                            return true;\n                        }\n                    }\n                    catch (e) {\n                        // ignore\n                    }\n                }\n            }\n            catch (e_10_1) { e_10 = { error: e_10_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_10) throw e_10.error; }\n            }\n            return false;\n        };\n        this.readdir = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var lastarg = args.length - 1;\n            var cb = args[lastarg];\n            if (typeof cb !== \"function\") {\n                cb = null;\n                lastarg++;\n            }\n            var lastError = null;\n            var result = new Map();\n            var pathExists = false;\n            var iterate = function (i, error) {\n                if (i === void 0) { i = 0; }\n                if (error) {\n                    if (SPECIAL_ERRORS.has(error[\"code\"])) {\n                        // Immediately fail with this error.\n                        // see comment in readdirSync\n                        if (cb) {\n                            cb(error);\n                        }\n                        return;\n                    }\n                    error.prev = lastError;\n                    lastError = error;\n                }\n                // Already tried all file systems; return the last error if every attempt failed.\n                if (i >= _this.fss.length) {\n                    // last one\n                    if (cb) {\n                        if (pathExists) {\n                            cb(null, _this.sortedArrayFromReaddirResult(result));\n                        }\n                        else {\n                            cb(error || Error(\"No file systems attached.\"));\n                        }\n                    }\n                    return;\n                }\n                // Replace `callback` with our intermediate function.\n                args[lastarg] = function (err, resArg) {\n                    var e_11, _a;\n                    if (!err) {\n                        pathExists = true;\n                    }\n                    if (result.size === 0 && err) {\n                        return iterate(i + 1, err);\n                    }\n                    if (resArg) {\n                        try {\n                            for (var resArg_1 = __values(resArg), resArg_1_1 = resArg_1.next(); !resArg_1_1.done; resArg_1_1 = resArg_1.next()) {\n                                var res = resArg_1_1.value;\n                                result.set(_this.pathFromReaddirEntry(res), res);\n                            }\n                        }\n                        catch (e_11_1) { e_11 = { error: e_11_1 }; }\n                        finally {\n                            try {\n                                if (resArg_1_1 && !resArg_1_1.done && (_a = resArg_1.return)) _a.call(resArg_1);\n                            }\n                            finally { if (e_11) throw e_11.error; }\n                        }\n                    }\n                    if (i === _this.fss.length - 1) {\n                        return cb(null, _this.sortedArrayFromReaddirResult(result));\n                    }\n                    else {\n                        return iterate(i + 1, error);\n                    }\n                };\n                var j = _this.fss.length - i - 1;\n                var fs = _this.fss[j];\n                var func = fs.readdir;\n                if (!func)\n                    iterate(i + 1, Error(\"Method not supported: readdir\"));\n                else\n                    func.apply(fs, args);\n            };\n            iterate();\n        };\n        this.readdirSync = function () {\n            var e_12, _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var lastError = null;\n            var result = new Map();\n            var pathExists = false;\n            for (var i = _this.fss.length - 1; i >= 0; i--) {\n                var fs = _this.fss[i];\n                try {\n                    if (!fs.readdirSync)\n                        throw Error(\"Method not supported: \\\"readdirSync\\\" with args \\\"\".concat(args, \"\\\"\"));\n                    try {\n                        for (var _b = (e_12 = void 0, __values(fs.readdirSync.apply(fs, args))), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var res = _c.value;\n                            result.set(_this.pathFromReaddirEntry(res), res);\n                        }\n                    }\n                    catch (e_12_1) { e_12 = { error: e_12_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_12) throw e_12.error; }\n                    }\n                    pathExists = true;\n                }\n                catch (err) {\n                    if (SPECIAL_ERRORS.has(err.code)) {\n                        // The file *does* exist in this filesystem in the union, but an ENOTDIR or EEXIST error happened\n                        // (or anything in SPECIAL_ERRORS).\n                        // E.g., if you try to get a directory listing on a file one fs doesn't have the file and the\n                        // the other fs has the file, then the one that has it throws ENOTDIR, which is what this\n                        // function should throw.  I hit this problem when working the cpython unit tests\n                        // for Lib/test/test_exceptions.py, which check the error code when trying to get a directory\n                        // listing on a file.\n                        throw err;\n                    }\n                    err.prev = lastError;\n                    lastError = err;\n                    if (!i && !pathExists) {\n                        // Last one and the path didn't exist in any case above.\n                        // NOTE: In upstream this function has a bug when there's 2 filesystems with this.fss[1] having the\n                        // directory but it is empty and this.fss[0] not having the directory.  In that case checking the\n                        // size doesn't work to know if the directory exists.  In particular, the fix at\n                        // https://github.com/streamich/unionfs/pull/348 is incorrect.\n                        throw err;\n                    }\n                    else {\n                        // Ignore error...\n                        // continue;\n                    }\n                }\n            }\n            return _this.sortedArrayFromReaddirResult(result);\n        };\n        this.readdirPromise = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return __awaiter(_this, void 0, void 0, function () {\n                var lastError, result, i, fs, _a, _b, res, e_13_1, err_1;\n                var e_13, _c;\n                return __generator(this, function (_d) {\n                    switch (_d.label) {\n                        case 0:\n                            lastError = null;\n                            result = new Map();\n                            i = this.fss.length - 1;\n                            _d.label = 1;\n                        case 1:\n                            if (!(i >= 0)) return [3 /*break*/, 13];\n                            fs = this.fss[i];\n                            _d.label = 2;\n                        case 2:\n                            _d.trys.push([2, 11, , 12]);\n                            if (!fs.promises || !fs.promises.readdir)\n                                throw Error(\"Method not supported: \\\"readdirSync\\\" with args \\\"\".concat(args, \"\\\"\"));\n                            _d.label = 3;\n                        case 3:\n                            _d.trys.push([3, 8, 9, 10]);\n                            e_13 = void 0;\n                            return [4 /*yield*/, fs.promises.readdir.apply(fs, args)];\n                        case 4:\n                            _a = (__values.apply(void 0, [_d.sent()])), _b = _a.next();\n                            _d.label = 5;\n                        case 5:\n                            if (!!_b.done) return [3 /*break*/, 7];\n                            res = _b.value;\n                            result.set(this.pathFromReaddirEntry(res), res);\n                            _d.label = 6;\n                        case 6:\n                            _b = _a.next();\n                            return [3 /*break*/, 5];\n                        case 7: return [3 /*break*/, 10];\n                        case 8:\n                            e_13_1 = _d.sent();\n                            e_13 = { error: e_13_1 };\n                            return [3 /*break*/, 10];\n                        case 9:\n                            try {\n                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                            }\n                            finally { if (e_13) throw e_13.error; }\n                            return [7 /*endfinally*/];\n                        case 10: return [3 /*break*/, 12];\n                        case 11:\n                            err_1 = _d.sent();\n                            err_1.prev = lastError;\n                            lastError = err_1;\n                            if (result.size === 0 && !i) {\n                                // last one\n                                throw err_1;\n                            }\n                            else {\n                                // Ignore error...\n                                // continue;\n                            }\n                            return [3 /*break*/, 12];\n                        case 12:\n                            i--;\n                            return [3 /*break*/, 1];\n                        case 13: return [2 /*return*/, this.sortedArrayFromReaddirResult(result)];\n                    }\n                });\n            });\n        };\n        this.pathFromReaddirEntry = function (readdirEntry) {\n            if (readdirEntry instanceof Buffer || typeof readdirEntry === \"string\") {\n                return String(readdirEntry);\n            }\n            return readdirEntry.name;\n        };\n        this.sortedArrayFromReaddirResult = function (readdirResult) {\n            var e_14, _a;\n            var array = [];\n            try {\n                for (var _b = __values(Array.from(readdirResult.keys()).sort()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var key = _c.value;\n                    var value = readdirResult.get(key);\n                    if (value !== undefined)\n                        array.push(value);\n                }\n            }\n            catch (e_14_1) { e_14 = { error: e_14_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_14) throw e_14.error; }\n            }\n            return array;\n        };\n        this.createReadStream = function (path) {\n            var e_15, _a;\n            var lastError = null;\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        if (!fs.createReadStream)\n                            throw Error(\"Method not supported: \\\"createReadStream\\\"\");\n                        if (fs.existsSync && !fs.existsSync(path)) {\n                            throw new Error(\"file \\\"\".concat(path, \"\\\" does not exists\"));\n                        }\n                        var stream = fs.createReadStream(path);\n                        if (!stream) {\n                            throw new Error(\"no valid stream\");\n                        }\n                        _this.ReadStream = fs.ReadStream;\n                        return stream;\n                    }\n                    catch (err) {\n                        lastError = err;\n                    }\n                }\n            }\n            catch (e_15_1) { e_15 = { error: e_15_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_15) throw e_15.error; }\n            }\n            throw lastError;\n        };\n        this.createWriteStream = function (path) {\n            var e_16, _a;\n            var lastError = null;\n            try {\n                for (var _b = __values(_this.fss), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var fs = _c.value;\n                    try {\n                        if (!fs.createWriteStream)\n                            throw Error(\"Method not supported: \\\"createWriteStream\\\"\");\n                        fs.statSync(path); //we simply stat first to exit early for mocked fs'es\n                        //TODO which filesystem to write to?\n                        var stream = fs.createWriteStream(path);\n                        if (!stream) {\n                            throw new Error(\"no valid stream\");\n                        }\n                        _this.WriteStream = fs.WriteStream;\n                        return stream;\n                    }\n                    catch (err) {\n                        lastError = err;\n                    }\n                }\n            }\n            catch (e_16_1) { e_16 = { error: e_16_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_16) throw e_16.error; }\n            }\n            throw lastError;\n        };\n        var _loop_1 = function (method) {\n            if (!SPECIAL_METHODS.has(method)) {\n                // check we don't already have a property for this method\n                this_1[method] = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    return _this.syncMethod(method, args);\n                };\n            }\n        };\n        var this_1 = this;\n        try {\n            for (var fsSyncMethods_1 = __values(fsSyncMethods), fsSyncMethods_1_1 = fsSyncMethods_1.next(); !fsSyncMethods_1_1.done; fsSyncMethods_1_1 = fsSyncMethods_1.next()) {\n                var method = fsSyncMethods_1_1.value;\n                _loop_1(method);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (fsSyncMethods_1_1 && !fsSyncMethods_1_1.done && (_a = fsSyncMethods_1.return)) _a.call(fsSyncMethods_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        var _loop_2 = function (method) {\n            if (!SPECIAL_METHODS.has(method)) {\n                // check we don't already have a property for this method\n                this_2[method] = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    return _this.asyncMethod(method, args);\n                };\n            }\n        };\n        var this_2 = this;\n        try {\n            for (var fsAsyncMethods_1 = __values(fsAsyncMethods), fsAsyncMethods_1_1 = fsAsyncMethods_1.next(); !fsAsyncMethods_1_1.done; fsAsyncMethods_1_1 = fsAsyncMethods_1.next()) {\n                var method = fsAsyncMethods_1_1.value;\n                _loop_2(method);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (fsAsyncMethods_1_1 && !fsAsyncMethods_1_1.done && (_b = fsAsyncMethods_1.return)) _b.call(fsAsyncMethods_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        var _loop_3 = function (method) {\n            if (method === \"readdir\") {\n                this_3.promises[method] = this_3.readdirPromise;\n                return \"continue\";\n            }\n            this_3.promises[method] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return _this.promiseMethod(method, args);\n            };\n        };\n        var this_3 = this;\n        try {\n            for (var fsPromisesMethods_1 = __values(fsPromisesMethods), fsPromisesMethods_1_1 = fsPromisesMethods_1.next(); !fsPromisesMethods_1_1.done; fsPromisesMethods_1_1 = fsPromisesMethods_1.next()) {\n                var method = fsPromisesMethods_1_1.value;\n                _loop_3(method);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (fsPromisesMethods_1_1 && !fsPromisesMethods_1_1.done && (_c = fsPromisesMethods_1.return)) _c.call(fsPromisesMethods_1);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        try {\n            for (var _e = __values(SPECIAL_METHODS.values()), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var method = _f.value;\n                // bind special methods to support\n                // const { method } = ufs;\n                this[method] = this[method].bind(this);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_d = _e.return)) _d.call(_e);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n    }\n    /**\n     * Adds a filesystem to the list of filesystems in the union\n     * The new filesystem object is added as the last filesystem used\n     * when searching for a file.\n     *\n     * @param fs the filesystem interface to be added to the queue of FS's\n     * @returns this instance of a unionFS\n     */\n    Union.prototype.use = function (fs) {\n        this.fss.push(fs);\n        return this;\n    };\n    Union.prototype.syncMethod = function (method, args) {\n        var lastError = null;\n        for (var i = this.fss.length - 1; i >= 0; i--) {\n            var fs = this.fss[i];\n            try {\n                if (!fs[method])\n                    throw Error(\"Method not supported: \\\"\".concat(method, \"\\\" with args \\\"\").concat(args, \"\\\"\"));\n                return fs[method].apply(fs, args);\n            }\n            catch (err) {\n                if (SPECIAL_ERRORS.has(err[\"code\"])) { // see comment in readdirSync\n                    throw err;\n                }\n                err.prev = lastError;\n                lastError = err;\n                if (!i) {\n                    // last one\n                    throw err;\n                }\n                else {\n                    // Ignore error...\n                    // continue;\n                }\n            }\n        }\n    };\n    Union.prototype.asyncMethod = function (method, args) {\n        var _this = this;\n        var lastarg = args.length - 1;\n        var cb = args[lastarg];\n        if (typeof cb !== \"function\") {\n            cb = null;\n            lastarg++;\n        }\n        var lastError = null;\n        var iterate = function (i, err) {\n            if (i === void 0) { i = 0; }\n            if (err != null && SPECIAL_ERRORS.has(err === null || err === void 0 ? void 0 : err[\"code\"])) { // see comment in readdirSync\n                if (cb) {\n                    cb(err);\n                }\n                return;\n            }\n            if (err) {\n                err.prev = lastError;\n                lastError = err;\n            }\n            // Already tried all file systems, return the last error.\n            if (i >= _this.fss.length) {\n                // last one\n                if (cb)\n                    cb(err || Error(\"No file systems attached.\"));\n                return;\n            }\n            // Replace `callback` with our intermediate function.\n            args[lastarg] = function (err) {\n                if (err)\n                    return iterate(i + 1, err);\n                if (cb)\n                    cb.apply(cb, arguments);\n            };\n            var j = _this.fss.length - i - 1;\n            var fs = _this.fss[j];\n            var func = fs[method];\n            if (!func)\n                iterate(i + 1, Error(\"Method not supported: \" + method));\n            else\n                func.apply(fs, args);\n        };\n        iterate();\n    };\n    Union.prototype.promiseMethod = function (method, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var lastError, i, theFs, promises, err_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        lastError = null;\n                        i = this.fss.length - 1;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i >= 0)) return [3 /*break*/, 6];\n                        theFs = this.fss[i];\n                        promises = theFs.promises;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        if (!promises || !promises[method]) {\n                            throw Error(\"Promise of method not supported: \\\"\".concat(String(method), \"\\\" with args \\\"\").concat(args, \"\\\"\"));\n                        }\n                        return [4 /*yield*/, promises[method].apply(promises, args)];\n                    case 3: \n                    // return promises[method](...args);\n                    return [2 /*return*/, _a.sent()];\n                    case 4:\n                        err_2 = _a.sent();\n                        err_2.prev = lastError;\n                        lastError = err_2;\n                        if (!i) {\n                            // last one\n                            throw err_2;\n                        }\n                        else {\n                            // Ignore error...\n                            // continue;\n                        }\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i--;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Union;\n}());\nexports.Union = Union;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FweXRob24vdW5pb25mcy9saWIvdW5pb24uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsZ0dBQVE7QUFDL0IsU0FBUyxtQkFBTyxDQUFDLGdHQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAd2FweXRob25cXHVuaW9uZnNcXGxpYlxcdW5pb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmlvbiA9IHZvaWQgMDtcbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG52YXIgX2EgPSByZXF1aXJlKFwiZnMtbW9ua2V5L2xpYi91dGlsL2xpc3RzXCIpLCBmc0FzeW5jTWV0aG9kcyA9IF9hLmZzQXN5bmNNZXRob2RzLCBmc1N5bmNNZXRob2RzID0gX2EuZnNTeW5jTWV0aG9kcztcbnZhciBTUEVDSUFMX01FVEhPRFMgPSBuZXcgU2V0KFtcbiAgICBcImV4aXN0c1N5bmNcIixcbiAgICBcInJlYWRkaXJcIixcbiAgICBcInJlYWRkaXJTeW5jXCIsXG4gICAgXCJjcmVhdGVSZWFkU3RyZWFtXCIsXG4gICAgXCJjcmVhdGVXcml0ZVN0cmVhbVwiLFxuICAgIFwid2F0Y2hcIixcbiAgICBcIndhdGNoRmlsZVwiLFxuICAgIFwidW53YXRjaEZpbGVcIixcbl0pO1xudmFyIFNQRUNJQUxfRVJST1JTID0gbmV3IFNldChbXCJFTk9URElSXCIsIFwiRUVYSVNUXCJdKTtcbnZhciBjcmVhdGVGU1Byb3h5ID0gZnVuY3Rpb24gKHdhdGNoZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfb2JqLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB2YXIgZnVuY0NhbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcm9wO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3YXRjaGVyc18xID0gX192YWx1ZXMod2F0Y2hlcnMpLCB3YXRjaGVyc18xXzEgPSB3YXRjaGVyc18xLm5leHQoKTsgIXdhdGNoZXJzXzFfMS5kb25lOyB3YXRjaGVyc18xXzEgPSB3YXRjaGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2F0Y2hlciA9IHdhdGNoZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHdhdGNoZXJbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBhIGZ1bmN0aW9uIHdlIHdyYXAgaXQgaW4gYSBiaWdnZXIgY2FsbGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY0NhbGxlcnMucHVzaChbd2F0Y2hlciwgcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyc18xXzEgJiYgIXdhdGNoZXJzXzFfMS5kb25lICYmIChfYSA9IHdhdGNoZXJzXzEucmV0dXJuKSkgX2EuY2FsbCh3YXRjaGVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmNDYWxsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmdW5jQ2FsbGVyc18xID0gX192YWx1ZXMoZnVuY0NhbGxlcnMpLCBmdW5jQ2FsbGVyc18xXzEgPSBmdW5jQ2FsbGVyc18xLm5leHQoKTsgIWZ1bmNDYWxsZXJzXzFfMS5kb25lOyBmdW5jQ2FsbGVyc18xXzEgPSBmdW5jQ2FsbGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChmdW5jQ2FsbGVyc18xXzEudmFsdWUsIDIpLCB3YXRjaGVyID0gX2JbMF0sIGZ1bmMgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHdhdGNoZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY0NhbGxlcnNfMV8xICYmICFmdW5jQ2FsbGVyc18xXzEuZG9uZSAmJiAoX2EgPSBmdW5jQ2FsbGVyc18xLnJldHVybikpIF9hLmNhbGwoZnVuY0NhbGxlcnNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xudmFyIGZzUHJvbWlzZXNNZXRob2RzID0gW1xuICAgIFwiYWNjZXNzXCIsXG4gICAgXCJjb3B5RmlsZVwiLFxuICAgIFwib3BlblwiLFxuICAgIFwib3BlbmRpclwiLFxuICAgIFwicmVuYW1lXCIsXG4gICAgXCJ0cnVuY2F0ZVwiLFxuICAgIFwicm1kaXJcIixcbiAgICBcIm1rZGlyXCIsXG4gICAgXCJyZWFkZGlyXCIsXG4gICAgXCJyZWFkbGlua1wiLFxuICAgIFwic3ltbGlua1wiLFxuICAgIFwibHN0YXRcIixcbiAgICBcInN0YXRcIixcbiAgICBcImxpbmtcIixcbiAgICBcInVubGlua1wiLFxuICAgIFwiY2htb2RcIixcbiAgICBcImxjaG1vZFwiLFxuICAgIFwibGNob3duXCIsXG4gICAgXCJjaG93blwiLFxuICAgIFwidXRpbWVzXCIsXG4gICAgXCJyZWFscGF0aFwiLFxuICAgIFwibWtkdGVtcFwiLFxuICAgIFwid3JpdGVGaWxlXCIsXG4gICAgXCJhcHBlbmRGaWxlXCIsXG4gICAgXCJyZWFkRmlsZVwiLFxuXTtcbi8qKlxuICogVW5pb24gb2JqZWN0IHJlcHJlc2VudHMgYSBzdGFjayBvZiBmaWxlc3lzdGVtc1xuICovXG52YXIgVW5pb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5pb24oKSB7XG4gICAgICAgIHZhciBlXzMsIF9hLCBlXzQsIF9iLCBlXzUsIF9jLCBlXzYsIF9kO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZzcyA9IFtdO1xuICAgICAgICB0aGlzLlJlYWRTdHJlYW0gPSBzdHJlYW1fMS5SZWFkYWJsZTtcbiAgICAgICAgdGhpcy5Xcml0ZVN0cmVhbSA9IHN0cmVhbV8xLldyaXRhYmxlO1xuICAgICAgICB0aGlzLnByb21pc2VzID0ge307XG4gICAgICAgIHRoaXMudW53YXRjaEZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV83LCBfYTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5mc3MpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMudW53YXRjaEZpbGUuYXBwbHkoZnMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW5ubyB3aGF0IHRvIGRvIGhlcmUuLi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53YXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzgsIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdhdGNoZXJzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoX3RoaXMuZnNzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YXRjaGVyID0gZnMud2F0Y2guYXBwbHkoZnMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVubm8gd2hhdCB0byBkbyBoZXJlLi4uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gYSBwcm94eSB0byBjYWxsIGZ1bmN0aW9ucyBvbiB0aGVzZSBwcm9wc1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZTUHJveHkod2F0Y2hlcnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhdGNoRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzksIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKF90aGlzLmZzcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy53YXRjaEZpbGUuYXBwbHkoZnMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW5ubyB3aGF0IHRvIGRvIGhlcmUuLi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzlfMSkgeyBlXzkgPSB7IGVycm9yOiBlXzlfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leGlzdHNTeW5jID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBlXzEwLCBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5mc3MpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xMF8xKSB7IGVfMTAgPSB7IGVycm9yOiBlXzEwXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWFkZGlyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhc3RhcmcgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgY2IgPSBhcmdzW2xhc3RhcmddO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxhc3RhcmcrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHZhciBwYXRoRXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChpLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB2b2lkIDApIHsgaSA9IDA7IH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNQRUNJQUxfRVJST1JTLmhhcyhlcnJvcltcImNvZGVcIl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGVseSBmYWlsIHdpdGggdGhpcyBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBjb21tZW50IGluIHJlYWRkaXJTeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucHJldiA9IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgdHJpZWQgYWxsIGZpbGUgc3lzdGVtczsgcmV0dXJuIHRoZSBsYXN0IGVycm9yIGlmIGV2ZXJ5IGF0dGVtcHQgZmFpbGVkLlxuICAgICAgICAgICAgICAgIGlmIChpID49IF90aGlzLmZzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aEV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIF90aGlzLnNvcnRlZEFycmF5RnJvbVJlYWRkaXJSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihlcnJvciB8fCBFcnJvcihcIk5vIGZpbGUgc3lzdGVtcyBhdHRhY2hlZC5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBgY2FsbGJhY2tgIHdpdGggb3VyIGludGVybWVkaWF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBhcmdzW2xhc3RhcmddID0gZnVuY3Rpb24gKGVyciwgcmVzQXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlXzExLCBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSA9PT0gMCAmJiBlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlKGkgKyAxLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNBcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzQXJnXzEgPSBfX3ZhbHVlcyhyZXNBcmcpLCByZXNBcmdfMV8xID0gcmVzQXJnXzEubmV4dCgpOyAhcmVzQXJnXzFfMS5kb25lOyByZXNBcmdfMV8xID0gcmVzQXJnXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSByZXNBcmdfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KF90aGlzLnBhdGhGcm9tUmVhZGRpckVudHJ5KHJlcyksIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMTFfMSkgeyBlXzExID0geyBlcnJvcjogZV8xMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNBcmdfMV8xICYmICFyZXNBcmdfMV8xLmRvbmUgJiYgKF9hID0gcmVzQXJnXzEucmV0dXJuKSkgX2EuY2FsbChyZXNBcmdfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMSkgdGhyb3cgZV8xMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBfdGhpcy5mc3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIF90aGlzLnNvcnRlZEFycmF5RnJvbVJlYWRkaXJSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0ZShpICsgMSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IF90aGlzLmZzcy5sZW5ndGggLSBpIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZnMgPSBfdGhpcy5mc3Nbal07XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBmcy5yZWFkZGlyO1xuICAgICAgICAgICAgICAgIGlmICghZnVuYylcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZShpICsgMSwgRXJyb3IoXCJNZXRob2Qgbm90IHN1cHBvcnRlZDogcmVhZGRpclwiKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGZzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVhZGRpclN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV8xMiwgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB2YXIgcGF0aEV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IF90aGlzLmZzcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBmcyA9IF90aGlzLmZzc1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZzLnJlYWRkaXJTeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNZXRob2Qgbm90IHN1cHBvcnRlZDogXFxcInJlYWRkaXJTeW5jXFxcIiB3aXRoIGFyZ3MgXFxcIlwiLmNvbmNhdChhcmdzLCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAoZV8xMiA9IHZvaWQgMCwgX192YWx1ZXMoZnMucmVhZGRpclN5bmMuYXBwbHkoZnMsIGFyZ3MpKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChfdGhpcy5wYXRoRnJvbVJlYWRkaXJFbnRyeShyZXMpLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzEyXzEpIHsgZV8xMiA9IHsgZXJyb3I6IGVfMTJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTIpIHRocm93IGVfMTIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1BFQ0lBTF9FUlJPUlMuaGFzKGVyci5jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgKmRvZXMqIGV4aXN0IGluIHRoaXMgZmlsZXN5c3RlbSBpbiB0aGUgdW5pb24sIGJ1dCBhbiBFTk9URElSIG9yIEVFWElTVCBlcnJvciBoYXBwZW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG9yIGFueXRoaW5nIGluIFNQRUNJQUxfRVJST1JTKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4sIGlmIHlvdSB0cnkgdG8gZ2V0IGEgZGlyZWN0b3J5IGxpc3Rpbmcgb24gYSBmaWxlIG9uZSBmcyBkb2Vzbid0IGhhdmUgdGhlIGZpbGUgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG90aGVyIGZzIGhhcyB0aGUgZmlsZSwgdGhlbiB0aGUgb25lIHRoYXQgaGFzIGl0IHRocm93cyBFTk9URElSLCB3aGljaCBpcyB3aGF0IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHNob3VsZCB0aHJvdy4gIEkgaGl0IHRoaXMgcHJvYmxlbSB3aGVuIHdvcmtpbmcgdGhlIGNweXRob24gdW5pdCB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIExpYi90ZXN0L3Rlc3RfZXhjZXB0aW9ucy5weSwgd2hpY2ggY2hlY2sgdGhlIGVycm9yIGNvZGUgd2hlbiB0cnlpbmcgdG8gZ2V0IGEgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0aW5nIG9uIGEgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnIucHJldiA9IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWkgJiYgIXBhdGhFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3Qgb25lIGFuZCB0aGUgcGF0aCBkaWRuJ3QgZXhpc3QgaW4gYW55IGNhc2UgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBJbiB1cHN0cmVhbSB0aGlzIGZ1bmN0aW9uIGhhcyBhIGJ1ZyB3aGVuIHRoZXJlJ3MgMiBmaWxlc3lzdGVtcyB3aXRoIHRoaXMuZnNzWzFdIGhhdmluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yeSBidXQgaXQgaXMgZW1wdHkgYW5kIHRoaXMuZnNzWzBdIG5vdCBoYXZpbmcgdGhlIGRpcmVjdG9yeS4gIEluIHRoYXQgY2FzZSBjaGVja2luZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgZG9lc24ndCB3b3JrIHRvIGtub3cgaWYgdGhlIGRpcmVjdG9yeSBleGlzdHMuICBJbiBwYXJ0aWN1bGFyLCB0aGUgZml4IGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3RyZWFtaWNoL3VuaW9uZnMvcHVsbC8zNDggaXMgaW5jb3JyZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zb3J0ZWRBcnJheUZyb21SZWFkZGlyUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVhZGRpclByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0RXJyb3IsIHJlc3VsdCwgaSwgZnMsIF9hLCBfYiwgcmVzLCBlXzEzXzEsIGVycl8xO1xuICAgICAgICAgICAgICAgIHZhciBlXzEzLCBfYztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5mc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA+PSAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gdGhpcy5mc3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kLnRyeXMucHVzaChbMiwgMTEsICwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZzLnByb21pc2VzIHx8ICFmcy5wcm9taXNlcy5yZWFkZGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk1ldGhvZCBub3Qgc3VwcG9ydGVkOiBcXFwicmVhZGRpclN5bmNcXFwiIHdpdGggYXJncyBcXFwiXCIuY29uY2F0KGFyZ3MsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kLnRyeXMucHVzaChbMywgOCwgOSwgMTBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZzLnByb21pc2VzLnJlYWRkaXIuYXBwbHkoZnMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IChfX3ZhbHVlcy5hcHBseSh2b2lkIDAsIFtfZC5zZW50KCldKSksIF9iID0gX2EubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFfYi5kb25lKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfYi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHRoaXMucGF0aEZyb21SZWFkZGlyRW50cnkocmVzKSwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBfYS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEzXzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xMyA9IHsgZXJyb3I6IGVfMTNfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2IgJiYgIV9iLmRvbmUgJiYgKF9jID0gX2EucmV0dXJuKSkgX2MuY2FsbChfYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMykgdGhyb3cgZV8xMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xLnByZXYgPSBsYXN0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplID09PSAwICYmICFpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycl8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNvcnRlZEFycmF5RnJvbVJlYWRkaXJSZXN1bHQocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhdGhGcm9tUmVhZGRpckVudHJ5ID0gZnVuY3Rpb24gKHJlYWRkaXJFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHJlYWRkaXJFbnRyeSBpbnN0YW5jZW9mIEJ1ZmZlciB8fCB0eXBlb2YgcmVhZGRpckVudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhyZWFkZGlyRW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRkaXJFbnRyeS5uYW1lO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvcnRlZEFycmF5RnJvbVJlYWRkaXJSZXN1bHQgPSBmdW5jdGlvbiAocmVhZGRpclJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGVfMTQsIF9hO1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoQXJyYXkuZnJvbShyZWFkZGlyUmVzdWx0LmtleXMoKSkuc29ydCgpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRkaXJSZXN1bHQuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTRfMSkgeyBlXzE0ID0geyBlcnJvcjogZV8xNF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzE0KSB0aHJvdyBlXzE0LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgZV8xNSwgX2E7XG4gICAgICAgICAgICB2YXIgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5mc3MpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmcy5jcmVhdGVSZWFkU3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQ6IFxcXCJjcmVhdGVSZWFkU3RyZWFtXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jICYmICFmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsZSBcXFwiXCIuY29uY2F0KHBhdGgsIFwiXFxcIiBkb2VzIG5vdCBleGlzdHNcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHZhbGlkIHN0cmVhbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlJlYWRTdHJlYW0gPSBmcy5SZWFkU3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xNV8xKSB7IGVfMTUgPSB7IGVycm9yOiBlXzE1XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTUpIHRocm93IGVfMTUuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgZV8xNiwgX2E7XG4gICAgICAgICAgICB2YXIgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5mc3MpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk1ldGhvZCBub3Qgc3VwcG9ydGVkOiBcXFwiY3JlYXRlV3JpdGVTdHJlYW1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMuc3RhdFN5bmMocGF0aCk7IC8vd2Ugc2ltcGx5IHN0YXQgZmlyc3QgdG8gZXhpdCBlYXJseSBmb3IgbW9ja2VkIGZzJ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gd2hpY2ggZmlsZXN5c3RlbSB0byB3cml0ZSB0bz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdmFsaWQgc3RyZWFtXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTZfMSkgeyBlXzE2ID0geyBlcnJvcjogZV8xNl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzE2KSB0aHJvdyBlXzE2LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKCFTUEVDSUFMX01FVEhPRFMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSBwcm9wZXJ0eSBmb3IgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICB0aGlzXzFbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3luY01ldGhvZChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZnNTeW5jTWV0aG9kc18xID0gX192YWx1ZXMoZnNTeW5jTWV0aG9kcyksIGZzU3luY01ldGhvZHNfMV8xID0gZnNTeW5jTWV0aG9kc18xLm5leHQoKTsgIWZzU3luY01ldGhvZHNfMV8xLmRvbmU7IGZzU3luY01ldGhvZHNfMV8xID0gZnNTeW5jTWV0aG9kc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBmc1N5bmNNZXRob2RzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChmc1N5bmNNZXRob2RzXzFfMSAmJiAhZnNTeW5jTWV0aG9kc18xXzEuZG9uZSAmJiAoX2EgPSBmc1N5bmNNZXRob2RzXzEucmV0dXJuKSkgX2EuY2FsbChmc1N5bmNNZXRob2RzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKCFTUEVDSUFMX01FVEhPRFMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSBwcm9wZXJ0eSBmb3IgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICB0aGlzXzJbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXN5bmNNZXRob2QobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18yID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGZzQXN5bmNNZXRob2RzXzEgPSBfX3ZhbHVlcyhmc0FzeW5jTWV0aG9kcyksIGZzQXN5bmNNZXRob2RzXzFfMSA9IGZzQXN5bmNNZXRob2RzXzEubmV4dCgpOyAhZnNBc3luY01ldGhvZHNfMV8xLmRvbmU7IGZzQXN5bmNNZXRob2RzXzFfMSA9IGZzQXN5bmNNZXRob2RzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGZzQXN5bmNNZXRob2RzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChmc0FzeW5jTWV0aG9kc18xXzEgJiYgIWZzQXN5bmNNZXRob2RzXzFfMS5kb25lICYmIChfYiA9IGZzQXN5bmNNZXRob2RzXzEucmV0dXJuKSkgX2IuY2FsbChmc0FzeW5jTWV0aG9kc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmVhZGRpclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpc18zLnByb21pc2VzW21ldGhvZF0gPSB0aGlzXzMucmVhZGRpclByb21pc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNfMy5wcm9taXNlc1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZU1ldGhvZChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMyA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmc1Byb21pc2VzTWV0aG9kc18xID0gX192YWx1ZXMoZnNQcm9taXNlc01ldGhvZHMpLCBmc1Byb21pc2VzTWV0aG9kc18xXzEgPSBmc1Byb21pc2VzTWV0aG9kc18xLm5leHQoKTsgIWZzUHJvbWlzZXNNZXRob2RzXzFfMS5kb25lOyBmc1Byb21pc2VzTWV0aG9kc18xXzEgPSBmc1Byb21pc2VzTWV0aG9kc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBmc1Byb21pc2VzTWV0aG9kc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgX2xvb3BfMyhtZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZnNQcm9taXNlc01ldGhvZHNfMV8xICYmICFmc1Byb21pc2VzTWV0aG9kc18xXzEuZG9uZSAmJiAoX2MgPSBmc1Byb21pc2VzTWV0aG9kc18xLnJldHVybikpIF9jLmNhbGwoZnNQcm9taXNlc01ldGhvZHNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMoU1BFQ0lBTF9NRVRIT0RTLnZhbHVlcygpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBiaW5kIHNwZWNpYWwgbWV0aG9kcyB0byBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeyBtZXRob2QgfSA9IHVmcztcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0gPSB0aGlzW21ldGhvZF0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfZCA9IF9lLnJldHVybikpIF9kLmNhbGwoX2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmaWxlc3lzdGVtIHRvIHRoZSBsaXN0IG9mIGZpbGVzeXN0ZW1zIGluIHRoZSB1bmlvblxuICAgICAqIFRoZSBuZXcgZmlsZXN5c3RlbSBvYmplY3QgaXMgYWRkZWQgYXMgdGhlIGxhc3QgZmlsZXN5c3RlbSB1c2VkXG4gICAgICogd2hlbiBzZWFyY2hpbmcgZm9yIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcyB0aGUgZmlsZXN5c3RlbSBpbnRlcmZhY2UgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIG9mIEZTJ3NcbiAgICAgKiBAcmV0dXJucyB0aGlzIGluc3RhbmNlIG9mIGEgdW5pb25GU1xuICAgICAqL1xuICAgIFVuaW9uLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoZnMpIHtcbiAgICAgICAgdGhpcy5mc3MucHVzaChmcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVW5pb24ucHJvdG90eXBlLnN5bmNNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIHZhciBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5mc3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBmcyA9IHRoaXMuZnNzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZzW21ldGhvZF0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQ6IFxcXCJcIi5jb25jYXQobWV0aG9kLCBcIlxcXCIgd2l0aCBhcmdzIFxcXCJcIikuY29uY2F0KGFyZ3MsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZzW21ldGhvZF0uYXBwbHkoZnMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChTUEVDSUFMX0VSUk9SUy5oYXMoZXJyW1wiY29kZVwiXSkpIHsgLy8gc2VlIGNvbW1lbnQgaW4gcmVhZGRpclN5bmNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnIucHJldiA9IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvci4uLlxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuaW9uLnByb3RvdHlwZS5hc3luY01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxhc3RhcmcgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjYiA9IGFyZ3NbbGFzdGFyZ107XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICAgICAgbGFzdGFyZysrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChpLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChpID09PSB2b2lkIDApIHsgaSA9IDA7IH1cbiAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCAmJiBTUEVDSUFMX0VSUk9SUy5oYXMoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyW1wiY29kZVwiXSkpIHsgLy8gc2VlIGNvbW1lbnQgaW4gcmVhZGRpclN5bmNcbiAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGVyci5wcmV2ID0gbGFzdEVycm9yO1xuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFscmVhZHkgdHJpZWQgYWxsIGZpbGUgc3lzdGVtcywgcmV0dXJuIHRoZSBsYXN0IGVycm9yLlxuICAgICAgICAgICAgaWYgKGkgPj0gX3RoaXMuZnNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgICAgICBjYihlcnIgfHwgRXJyb3IoXCJObyBmaWxlIHN5c3RlbXMgYXR0YWNoZWQuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGBjYWxsYmFja2Agd2l0aCBvdXIgaW50ZXJtZWRpYXRlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgYXJnc1tsYXN0YXJnXSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0ZShpICsgMSwgZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KGNiLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBqID0gX3RoaXMuZnNzLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICAgICAgdmFyIGZzID0gX3RoaXMuZnNzW2pdO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmc1ttZXRob2RdO1xuICAgICAgICAgICAgaWYgKCFmdW5jKVxuICAgICAgICAgICAgICAgIGl0ZXJhdGUoaSArIDEsIEVycm9yKFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQ6IFwiICsgbWV0aG9kKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShmcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIFVuaW9uLnByb3RvdHlwZS5wcm9taXNlTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEVycm9yLCBpLCB0aGVGcywgcHJvbWlzZXMsIGVycl8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLmZzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpID49IDApKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUZzID0gdGhpcy5mc3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHRoZUZzLnByb21pc2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9taXNlcyB8fCAhcHJvbWlzZXNbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUHJvbWlzZSBvZiBtZXRob2Qgbm90IHN1cHBvcnRlZDogXFxcIlwiLmNvbmNhdChTdHJpbmcobWV0aG9kKSwgXCJcXFwiIHdpdGggYXJncyBcXFwiXCIpLmNvbmNhdChhcmdzLCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJvbWlzZXNbbWV0aG9kXS5hcHBseShwcm9taXNlcywgYXJncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IFxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcHJvbWlzZXNbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycl8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyXzIucHJldiA9IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycl8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvci4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5pb247XG59KCkpO1xuZXhwb3J0cy5VbmlvbiA9IFVuaW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/union.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar objectAssign = __webpack_require__(/*! object.assign/polyfill */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/object.assign/polyfill.js\")();\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (__webpack_require__.g.Buffer && typeof __webpack_require__.g.Buffer.isBuffer === 'function') {\n    return __webpack_require__.g.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"(pages-dir-browser)/./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof __webpack_require__.g.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHNIQUF3Qjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFNLGtCQUFrQixxQkFBTTtBQUNwQyxXQUFXLHFCQUFNO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsOERBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxhc3NlcnRcXGFzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QuYXNzaWduL3BvbHlmaWxsJykoKTtcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG4vLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cbi8vICAgICBub2RlLWFzc2VydCBoYXMgZXZvbHZlZCBhIGxvdCBzaW5jZSB0aGVuLCBib3RoIGluIEFQSSBhbmQgYmVoYXZpb3IuXG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/assert/assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/debug/node_modules/ms/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/debug/node_modules/ms/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxkZWJ1Z1xcbm9kZV9tb2R1bGVzXFxtc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/debug/node_modules/ms/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(pages-dir-browser)/./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLDZCQUE2QixPQUFPO0FBQzdELE1BQU0sT0FBTztBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcZGVidWdcXHNyY1xcYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/debug/src/browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(pages-dir-browser)/./node_modules/debug/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDZFQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcZGVidWdcXHNyY1xcY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/debug/src/common.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxldmVudHNcXGV2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/events/events.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/fs-monkey/lib/correctPath.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-monkey/lib/correctPath.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.correctPath = correctPath;\nexports.unixify = unixify;\nvar isWin = process.platform === 'win32';\nfunction removeTrailingSeparator(str) {\n  var i = str.length - 1;\n  if (i < 2) {\n    return str;\n  }\n  while (isSeparator(str, i)) {\n    i--;\n  }\n  return str.substr(0, i + 1);\n}\nfunction isSeparator(str, i) {\n  var _char = str[i];\n  return i > 0 && (_char === '/' || isWin && _char === '\\\\');\n}\nfunction normalizePath(str, stripTrailing) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  str = str.replace(/[\\\\\\/]+/g, '/');\n  if (stripTrailing !== false) {\n    str = removeTrailingSeparator(str);\n  }\n  return str;\n}\nfunction unixify(filepath) {\n  var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (isWin) {\n    filepath = normalizePath(filepath, stripTrailing);\n    return filepath.replace(/^([a-zA-Z]+:|\\.\\/)/, '');\n  }\n  return filepath;\n}\nfunction correctPath(filepath) {\n  return unixify(filepath.replace(/^\\\\\\\\\\?\\\\.:\\\\/, '\\\\'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcy1tb25rZXkvbGliL2NvcnJlY3RQYXRoLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcZnMtbW9ua2V5XFxsaWJcXGNvcnJlY3RQYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JyZWN0UGF0aCA9IGNvcnJlY3RQYXRoO1xuZXhwb3J0cy51bml4aWZ5ID0gdW5peGlmeTtcbnZhciBpc1dpbiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihzdHIpIHtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoIC0gMTtcbiAgaWYgKGkgPCAyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB3aGlsZSAoaXNTZXBhcmF0b3Ioc3RyLCBpKSkge1xuICAgIGktLTtcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpICsgMSk7XG59XG5mdW5jdGlvbiBpc1NlcGFyYXRvcihzdHIsIGkpIHtcbiAgdmFyIF9jaGFyID0gc3RyW2ldO1xuICByZXR1cm4gaSA+IDAgJiYgKF9jaGFyID09PSAnLycgfHwgaXNXaW4gJiYgX2NoYXIgPT09ICdcXFxcJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHN0ciwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcL10rL2csICcvJyk7XG4gIGlmIChzdHJpcFRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgIHN0ciA9IHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHVuaXhpZnkoZmlsZXBhdGgpIHtcbiAgdmFyIHN0cmlwVHJhaWxpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIGlmIChpc1dpbikge1xuICAgIGZpbGVwYXRoID0gbm9ybWFsaXplUGF0aChmaWxlcGF0aCwgc3RyaXBUcmFpbGluZyk7XG4gICAgcmV0dXJuIGZpbGVwYXRoLnJlcGxhY2UoL14oW2EtekEtWl0rOnxcXC5cXC8pLywgJycpO1xuICB9XG4gIHJldHVybiBmaWxlcGF0aDtcbn1cbmZ1bmN0aW9uIGNvcnJlY3RQYXRoKGZpbGVwYXRoKSB7XG4gIHJldHVybiB1bml4aWZ5KGZpbGVwYXRoLnJlcGxhY2UoL15cXFxcXFxcXFxcP1xcXFwuOlxcXFwvLCAnXFxcXCcpKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/fs-monkey/lib/correctPath.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/fs-monkey/lib/util/lists.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-monkey/lib/util/lists.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fsSyncMethods = exports.fsProps = exports.fsAsyncMethods = void 0;\nvar fsProps = exports.fsProps = ['constants', 'F_OK', 'R_OK', 'W_OK', 'X_OK', 'Stats'];\nvar fsSyncMethods = exports.fsSyncMethods = ['renameSync', 'ftruncateSync', 'truncateSync', 'chownSync', 'fchownSync', 'lchownSync', 'chmodSync', 'fchmodSync', 'lchmodSync', 'statSync', 'lstatSync', 'fstatSync', 'linkSync', 'symlinkSync', 'readlinkSync', 'realpathSync', 'unlinkSync', 'rmdirSync', 'mkdirSync', 'mkdirpSync', 'readdirSync', 'closeSync', 'openSync', 'utimesSync', 'futimesSync', 'fsyncSync', 'writeSync', 'readSync', 'readFileSync', 'writeFileSync', 'appendFileSync', 'existsSync', 'accessSync', 'fdatasyncSync', 'mkdtempSync', 'copyFileSync', 'rmSync', 'createReadStream', 'createWriteStream'];\nvar fsAsyncMethods = exports.fsAsyncMethods = ['rename', 'ftruncate', 'truncate', 'chown', 'fchown', 'lchown', 'chmod', 'fchmod', 'lchmod', 'stat', 'lstat', 'fstat', 'link', 'symlink', 'readlink', 'realpath', 'unlink', 'rmdir', 'mkdir', 'mkdirp', 'readdir', 'close', 'open', 'utimes', 'futimes', 'fsync', 'write', 'read', 'readFile', 'writeFile', 'appendFile', 'exists', 'access', 'fdatasync', 'mkdtemp', 'copyFile', 'rm', 'watchFile', 'unwatchFile', 'watch'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcy1tb25rZXkvbGliL3V0aWwvbGlzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCLEdBQUcsZUFBZSxHQUFHLHNCQUFzQjtBQUNoRSxjQUFjLGVBQWU7QUFDN0Isb0JBQW9CLHFCQUFxQjtBQUN6QyxxQkFBcUIsc0JBQXNCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcZnMtbW9ua2V5XFxsaWJcXHV0aWxcXGxpc3RzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mc1N5bmNNZXRob2RzID0gZXhwb3J0cy5mc1Byb3BzID0gZXhwb3J0cy5mc0FzeW5jTWV0aG9kcyA9IHZvaWQgMDtcbnZhciBmc1Byb3BzID0gZXhwb3J0cy5mc1Byb3BzID0gWydjb25zdGFudHMnLCAnRl9PSycsICdSX09LJywgJ1dfT0snLCAnWF9PSycsICdTdGF0cyddO1xudmFyIGZzU3luY01ldGhvZHMgPSBleHBvcnRzLmZzU3luY01ldGhvZHMgPSBbJ3JlbmFtZVN5bmMnLCAnZnRydW5jYXRlU3luYycsICd0cnVuY2F0ZVN5bmMnLCAnY2hvd25TeW5jJywgJ2ZjaG93blN5bmMnLCAnbGNob3duU3luYycsICdjaG1vZFN5bmMnLCAnZmNobW9kU3luYycsICdsY2htb2RTeW5jJywgJ3N0YXRTeW5jJywgJ2xzdGF0U3luYycsICdmc3RhdFN5bmMnLCAnbGlua1N5bmMnLCAnc3ltbGlua1N5bmMnLCAncmVhZGxpbmtTeW5jJywgJ3JlYWxwYXRoU3luYycsICd1bmxpbmtTeW5jJywgJ3JtZGlyU3luYycsICdta2RpclN5bmMnLCAnbWtkaXJwU3luYycsICdyZWFkZGlyU3luYycsICdjbG9zZVN5bmMnLCAnb3BlblN5bmMnLCAndXRpbWVzU3luYycsICdmdXRpbWVzU3luYycsICdmc3luY1N5bmMnLCAnd3JpdGVTeW5jJywgJ3JlYWRTeW5jJywgJ3JlYWRGaWxlU3luYycsICd3cml0ZUZpbGVTeW5jJywgJ2FwcGVuZEZpbGVTeW5jJywgJ2V4aXN0c1N5bmMnLCAnYWNjZXNzU3luYycsICdmZGF0YXN5bmNTeW5jJywgJ21rZHRlbXBTeW5jJywgJ2NvcHlGaWxlU3luYycsICdybVN5bmMnLCAnY3JlYXRlUmVhZFN0cmVhbScsICdjcmVhdGVXcml0ZVN0cmVhbSddO1xudmFyIGZzQXN5bmNNZXRob2RzID0gZXhwb3J0cy5mc0FzeW5jTWV0aG9kcyA9IFsncmVuYW1lJywgJ2Z0cnVuY2F0ZScsICd0cnVuY2F0ZScsICdjaG93bicsICdmY2hvd24nLCAnbGNob3duJywgJ2NobW9kJywgJ2ZjaG1vZCcsICdsY2htb2QnLCAnc3RhdCcsICdsc3RhdCcsICdmc3RhdCcsICdsaW5rJywgJ3N5bWxpbmsnLCAncmVhZGxpbmsnLCAncmVhbHBhdGgnLCAndW5saW5rJywgJ3JtZGlyJywgJ21rZGlyJywgJ21rZGlycCcsICdyZWFkZGlyJywgJ2Nsb3NlJywgJ29wZW4nLCAndXRpbWVzJywgJ2Z1dGltZXMnLCAnZnN5bmMnLCAnd3JpdGUnLCAncmVhZCcsICdyZWFkRmlsZScsICd3cml0ZUZpbGUnLCAnYXBwZW5kRmlsZScsICdleGlzdHMnLCAnYWNjZXNzJywgJ2ZkYXRhc3luYycsICdta2R0ZW1wJywgJ2NvcHlGaWxlJywgJ3JtJywgJ3dhdGNoRmlsZScsICd1bndhdGNoRmlsZScsICd3YXRjaCddOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/fs-monkey/lib/util/lists.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/polyfills/object.assign/polyfill.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object.assign/polyfill.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = function() {\n    return Object.assign;\n};\n\n//# sourceMappingURL=polyfill.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC5hc3NpZ24vcG9seWZpbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxidWlsZFxccG9seWZpbGxzXFxvYmplY3QuYXNzaWduXFxwb2x5ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ247XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/polyfills/object.assign/polyfill.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/native-url/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/native-url/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={452:function(e){\"use strict\";e.exports=__webpack_require__(/*! next/dist/compiled/querystring-es3 */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbmF0aXZlLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywwSEFBb0MsSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyxTQUFTLFlBQVksUUFBUSwrR0FBK0csY0FBYyw2QkFBNkIsc0JBQXNCLDRGQUE0Riw2S0FBNkssNkJBQTZCLGlMQUFpTCx5R0FBeUcsUUFBUSxzREFBc0QsdUdBQXVHLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLGdCQUFnQiw4S0FBOEssaUJBQWlCLGdHQUFnRyx3RkFBd0Ysa09BQWtPLGNBQWMsMkZBQTJGLDBFQUEwRSxJQUFJLDZEQUE2RCxJQUFJLGFBQWEsa0JBQWtCLHdGQUF3Riw0QkFBNEIsNkZBQTZGLDREQUE0RCx3S0FBd0ssMkZBQTJGLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQixvS0FBb0ssd0NBQXdDLG9EQUFvRCwwQkFBMEIsRUFBRSxxQkFBcUIsSUFBSSx3REFBd0QscUJBQXFCLHVFQUF1RSxZQUFZLFNBQVMsVUFBVSxHQUFHLHFiQUFxYixvREFBb0QsMkNBQTJDLGlDQUFpQyxLQUFLLCtEQUErRCxpQkFBaUIsU0FBUyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxuYXRpdmUtdXJsXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NDUyOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3F1ZXJ5c3RyaW5nLWVzM1wiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obyl7dmFyIGE9dFtvXTtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYS5leHBvcnRzfXZhciBzPXRbb109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2Vbb10ocyxzLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHRbb119cmV0dXJuIHMuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG89e307IWZ1bmN0aW9uKCl7dmFyIGU9bzt2YXIgdCxhPSh0PV9fbmNjd3Bja19yZXF1aXJlX18oNDUyKSkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImRlZmF1bHRcImluIHQ/dC5kZWZhdWx0OnQscz0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gcihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZChlKSk7dmFyIHQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBhPWUuYXV0aCxzPWUuaG9zdG5hbWUsbj1lLnByb3RvY29sfHxcIlwiLHA9ZS5wYXRobmFtZXx8XCJcIixjPWUuaGFzaHx8XCJcIixpPWUucXVlcnl8fFwiXCIsdT0hMTthPWE/ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD91PWErZS5ob3N0OnMmJih1PWErKH5zLmluZGV4T2YoXCI6XCIpP1wiW1wiK3MrXCJdXCI6cyksZS5wb3J0JiYodSs9XCI6XCIrZS5wb3J0KSksaSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihpPXQuZW5jb2RlKGkpKTt2YXIgZj1lLnNlYXJjaHx8aSYmXCI/XCIraXx8XCJcIjtyZXR1cm4gbiYmXCI6XCIhPT1uLnN1YnN0cigtMSkmJihuKz1cIjpcIiksZS5zbGFzaGVzfHwoIW58fG8udGVzdChuKSkmJiExIT09dT8odT1cIi8vXCIrKHV8fFwiXCIpLHAmJlwiL1wiIT09cFswXSYmKHA9XCIvXCIrcCkpOnV8fCh1PVwiXCIpLGMmJlwiI1wiIT09Y1swXSYmKGM9XCIjXCIrYyksZiYmXCI/XCIhPT1mWzBdJiYoZj1cIj9cIitmKSx7cHJvdG9jb2w6bixob3N0OnUscGF0aG5hbWU6cD1wLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpmPWYucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmN9fShlLGEscyk7cmV0dXJuXCJcIit0LnByb3RvY29sK3QuaG9zdCt0LnBhdGhuYW1lK3Quc2VhcmNoK3QuaGFzaH12YXIgbj1cImh0dHA6Ly9cIixwPVwidy53XCIsYz1uK3AsaT0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSx1PS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBoKGUsdCl7dmFyIG89XCJzdHJpbmdcIj09dHlwZW9mIGU/ZChlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/cihlKTplO3ZhciBhPWQodCkscz1cIlwiO28ucHJvdG9jb2wmJiFvLnNsYXNoZXMmJihzPW8ucHJvdG9jb2wsZT1lLnJlcGxhY2Uoby5wcm90b2NvbCxcIlwiKSxzKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxzJiZhLnByb3RvY29sJiYocz1cIlwiLGEuc2xhc2hlc3x8KHM9YS5wcm90b2NvbCx0PXQucmVwbGFjZShhLnByb3RvY29sLFwiXCIpKSk7dmFyIHA9ZS5tYXRjaChpKTtwJiYhYS5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKHM9cFsxXSsocFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYocz1zLnNsaWNlKDAsLTEpKSk7dmFyIGY9bmV3IFVSTChlLGMrXCIvXCIpLG09bmV3IFVSTCh0LGYpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHY9YS5wcm90b2NvbHx8by5wcm90b2NvbDtyZXR1cm4gdis9by5zbGFzaGVzfHxhLnNsYXNoZXM/XCIvL1wiOlwiXCIsIXMmJnY/bT1tLnJlcGxhY2Uobix2KTpzJiYobT1tLnJlcGxhY2UobixcIlwiKSksdS50ZXN0KG0pfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1tLnNsaWNlKC0xKXx8KG09bS5zbGljZSgwLC0xKSkscyYmKG09cysoXCIvXCI9PT1tWzBdP20uc3Vic3RyKDEpOm0pKSxtfWZ1bmN0aW9uIGwoKXt9bC5wcm90b3R5cGUucGFyc2U9ZCxsLnByb3RvdHlwZS5mb3JtYXQ9cixsLnByb3RvdHlwZS5yZXNvbHZlPWgsbC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1oO3ZhciBmPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sbT0vXiguKj8pKFsjP10uKikvLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLF89L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLGI9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUsdCxvKXtpZih2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09byYmKG89ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgcz0oZT1lLnRyaW0oKSkubWF0Y2gobSk7ZT1zP3NbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStzWzJdOmUucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSxiLnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIG49IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHYpLGk9Xy50ZXN0KGUpLHU9XCJcIjtuJiYoZi50ZXN0KG5bMV0pfHwodT1uWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK25bMl0rblszXSksblsyXXx8KGk9ITEsZi50ZXN0KG5bMV0pPyh1PW5bMV0sZT1cIlwiK25bM10pOmU9XCIvL1wiK25bM10pLDMhPT1uWzJdLmxlbmd0aCYmMSE9PW5bMl0ubGVuZ3RofHwodT1uWzFdLGU9XCIvXCIrblszXSkpO3ZhciBnLHk9KHM/c1sxXTplKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXi9dKyg6WzAtOV0rKSg/PVxcL3wkKS8pLHc9eSYmeVsxXSx4PW5ldyBsLEM9XCJcIixVPVwiXCI7dHJ5e2c9bmV3IFVSTChlKX1jYXRjaCh0KXtDPXQsdXx8b3x8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2c9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB4LnByb3RvY29sPXUseC5ocmVmPXUseH19eC5zbGFzaGVzPWkmJiFVLHguaG9zdD1nLmhvc3Q9PT1wP1wiXCI6Zy5ob3N0LHguaG9zdG5hbWU9Zy5ob3N0bmFtZT09PXA/XCJcIjpnLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHgucHJvdG9jb2w9Qz91fHxudWxsOmcucHJvdG9jb2wseC5zZWFyY2g9Zy5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHguaGFzaD1nLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBqPWUuc3BsaXQoXCIjXCIpOyF4LnNlYXJjaCYmfmpbMF0uaW5kZXhPZihcIj9cIikmJih4LnNlYXJjaD1cIj9cIikseC5oYXNofHxcIlwiIT09alsxXXx8KHguaGFzaD1cIiNcIikseC5xdWVyeT10P2EuZGVjb2RlKGcuc2VhcmNoLnN1YnN0cigxKSk6eC5zZWFyY2guc3Vic3RyKDEpLHgucGF0aG5hbWU9VSsobj9mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bJ158YF0vZywoZnVuY3Rpb24oZSl7cmV0dXJuXCIlXCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9KSkucmVwbGFjZSgvKCg/OiVbMC05QS1GXXsyfSkrKS9nLChmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpLnNwbGl0KFwiXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KCk7cmV0dXJuIHQ+MjU2fHwvXlthLXowLTldJC9pLnRlc3QoZSk/ZTpcIiVcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfSkpLmpvaW4oXCJcIil9Y2F0Y2goZSl7cmV0dXJuIHR9fSkpfShnLnBhdGhuYW1lKTpnLnBhdGhuYW1lKSxcImFib3V0OlwiPT09eC5wcm90b2NvbCYmXCJibGFua1wiPT09eC5wYXRobmFtZSYmKHgucHJvdG9jb2w9XCJcIix4LnBhdGhuYW1lPVwiXCIpLEMmJlwiL1wiIT09ZVswXSYmKHgucGF0aG5hbWU9eC5wYXRobmFtZS5zdWJzdHIoMSkpLHUmJiFmLnRlc3QodSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09eC5wYXRobmFtZSYmKHgucGF0aG5hbWU9XCJcIikseC5wYXRoPXgucGF0aG5hbWUreC5zZWFyY2gseC5hdXRoPVtnLnVzZXJuYW1lLGcucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx4LnBvcnQ9Zy5wb3J0LHcmJiF4Lmhvc3QuZW5kc1dpdGgodykmJih4Lmhvc3QrPXcseC5wb3J0PXcuc2xpY2UoMSkpLHguaHJlZj1VP1wiXCIreC5wYXRobmFtZSt4LnNlYXJjaCt4Lmhhc2g6cih4KTt2YXIgcT0vXihmaWxlKS8udGVzdCh4LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKChmdW5jdGlvbihlKXt+cS5pbmRleE9mKGUpfHwoeFtlXT14W2VdfHxudWxsKX0pKSx4fWUucGFyc2U9ZCxlLmZvcm1hdD1yLGUucmVzb2x2ZT1oLGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKGgoZSx0KSl9LGUuVXJsPWx9KCk7bW9kdWxlLmV4cG9ydHM9b30pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/native-url/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/querystring-es3/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsNkJBQTZCLGlEQUFpRCw0QkFBNEIsU0FBUyxTQUFTLFNBQVMsc0NBQXNDLFNBQVMsWUFBWSxhQUFhLFVBQVUsbUNBQW1DLFlBQVksZUFBZSxhQUFhLElBQUksWUFBWSxJQUFJLEtBQUssbURBQW1ELFNBQVMsZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksS0FBSyx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLGlCQUFpQixhQUFhLEtBQUssZUFBZSxVQUFVLGlDQUFpQyw2REFBNkQsaUJBQWlCLG1DQUFtQyxpQkFBaUIsc0JBQXNCLHNDQUFzQyxxQ0FBcUMsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsYUFBYSxZQUFZLHdCQUF3Qiw2QkFBNkIsa0RBQWtELFlBQVksNkJBQTZCLG1EQUFtRCxXQUFXLEtBQUssdURBQXVELFdBQVcsZUFBZSw4RkFBOEYsaUNBQWlDLDZEQUE2RCxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssa0JBQWtCLFNBQVMsK0JBQStCLFNBQVMsZ0JBQWdCLHVEQUF1RCxZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxRQUFRLDBDQUEwQyw4Q0FBOEMsR0FBRyxpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccXVlcnlzdHJpbmctZXMzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17ODE1OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGhhc093blByb3BlcnR5KGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWUuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCxvKXtuPW58fFwiJlwiO3Q9dHx8XCI9XCI7dmFyIGE9e307aWYodHlwZW9mIGUhPT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTApe3JldHVybiBhfXZhciBpPS9cXCsvZztlPWUuc3BsaXQobik7dmFyIHU9MWUzO2lmKG8mJnR5cGVvZiBvLm1heEtleXM9PT1cIm51bWJlclwiKXt1PW8ubWF4S2V5c312YXIgYz1lLmxlbmd0aDtpZih1PjAmJmM+dSl7Yz11fWZvcih2YXIgcD0wO3A8YzsrK3Ape3ZhciBmPWVbcF0ucmVwbGFjZShpLFwiJTIwXCIpLHM9Zi5pbmRleE9mKHQpLF8sbCx5LGQ7aWYocz49MCl7Xz1mLnN1YnN0cigwLHMpO2w9Zi5zdWJzdHIocysxKX1lbHNle189ZjtsPVwiXCJ9eT1kZWNvZGVVUklDb21wb25lbnQoXyk7ZD1kZWNvZGVVUklDb21wb25lbnQobCk7aWYoIWhhc093blByb3BlcnR5KGEseSkpe2FbeV09ZH1lbHNlIGlmKHIoYVt5XSkpe2FbeV0ucHVzaChkKX1lbHNle2FbeV09W2FbeV0sZF19fXJldHVybiBhfTt2YXIgcj1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IEFycmF5XVwifX0sNTc3OmZ1bmN0aW9uKGUpe3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gZTtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShlKT9lOlwiXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxvLGEpe3Q9dHx8XCImXCI7bz1vfHxcIj1cIjtpZihlPT09bnVsbCl7ZT11bmRlZmluZWR9aWYodHlwZW9mIGU9PT1cIm9iamVjdFwiKXtyZXR1cm4gbWFwKG4oZSksKGZ1bmN0aW9uKG4pe3ZhciBhPWVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobikpK287aWYocihlW25dKSl7cmV0dXJuIG1hcChlW25dLChmdW5jdGlvbihlKXtyZXR1cm4gYStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX0pKS5qb2luKHQpfWVsc2V7cmV0dXJuIGErZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShlW25dKSl9fSkpLmpvaW4odCl9aWYoIWEpcmV0dXJuXCJcIjtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShhKSkrbytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX07dmFyIHI9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn07ZnVuY3Rpb24gbWFwKGUscil7aWYoZS5tYXApcmV0dXJuIGUubWFwKHIpO3ZhciBuPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtuLnB1c2gocihlW3RdLHQpKX1yZXR1cm4gbn12YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHI9W107Zm9yKHZhciBuIGluIGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pKXIucHVzaChuKX1yZXR1cm4gcn19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciB0PXJbbl07aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgbz1yW25dPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW25dKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW25dfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPXt9OyFmdW5jdGlvbigpe3ZhciBlPW47ZS5kZWNvZGU9ZS5wYXJzZT1fX25jY3dwY2tfcmVxdWlyZV9fKDgxNSk7ZS5lbmNvZGU9ZS5zdHJpbmdpZnk9X19uY2N3cGNrX3JlcXVpcmVfXyg1NzcpfSgpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/stream-browserify/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/stream-browserify/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n(function(){var e={782:function(e){if(typeof Object.create===\"function\"){e.exports=function inherits(e,t){if(t){e.super_=t;e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:false,writable:true,configurable:true}})}}}else{e.exports=function inherits(e,t){if(t){e.super_=t;var TempCtor=function(){};TempCtor.prototype=t.prototype;e.prototype=new TempCtor;e.prototype.constructor=e}}}},646:function(e){\"use strict\";const t={};function createErrorType(e,r,n){if(!n){n=Error}function getMessage(e,t,n){if(typeof r===\"string\"){return r}else{return r(e,t,n)}}class NodeError extends n{constructor(e,t,r){super(getMessage(e,t,r))}}NodeError.prototype.name=n.name;NodeError.prototype.code=e;t[e]=NodeError}function oneOf(e,t){if(Array.isArray(e)){const r=e.length;e=e.map((e=>String(e)));if(r>2){return`one of ${t} ${e.slice(0,r-1).join(\", \")}, or `+e[r-1]}else if(r===2){return`one of ${t} ${e[0]} or ${e[1]}`}else{return`of ${t} ${e[0]}`}}else{return`of ${t} ${String(e)}`}}function startsWith(e,t,r){return e.substr(!r||r<0?0:+r,t.length)===t}function endsWith(e,t,r){if(r===undefined||r>e.length){r=e.length}return e.substring(r-t.length,r)===t}function includes(e,t,r){if(typeof r!==\"number\"){r=0}if(r+t.length>e.length){return false}else{return e.indexOf(t,r)!==-1}}createErrorType(\"ERR_INVALID_OPT_VALUE\",(function(e,t){return'The value \"'+t+'\" is invalid for option \"'+e+'\"'}),TypeError);createErrorType(\"ERR_INVALID_ARG_TYPE\",(function(e,t,r){let n;if(typeof t===\"string\"&&startsWith(t,\"not \")){n=\"must not be\";t=t.replace(/^not /,\"\")}else{n=\"must be\"}let i;if(endsWith(e,\" argument\")){i=`The ${e} ${n} ${oneOf(t,\"type\")}`}else{const r=includes(e,\".\")?\"property\":\"argument\";i=`The \"${e}\" ${r} ${n} ${oneOf(t,\"type\")}`}i+=`. Received type ${typeof r}`;return i}),TypeError);createErrorType(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\");createErrorType(\"ERR_METHOD_NOT_IMPLEMENTED\",(function(e){return\"The \"+e+\" method is not implemented\"}));createErrorType(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\");createErrorType(\"ERR_STREAM_DESTROYED\",(function(e){return\"Cannot call \"+e+\" after a stream was destroyed\"}));createErrorType(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\");createErrorType(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\");createErrorType(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\");createErrorType(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError);createErrorType(\"ERR_UNKNOWN_ENCODING\",(function(e){return\"Unknown encoding: \"+e}),TypeError);createErrorType(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\");e.exports.q=t},403:function(e,t,r){\"use strict\";var n=Object.keys||function(e){var t=[];for(var r in e){t.push(r)}return t};e.exports=Duplex;var i=r(709);var a=r(337);r(782)(Duplex,i);{var o=n(a.prototype);for(var s=0;s<o.length;s++){var f=o[s];if(!Duplex.prototype[f])Duplex.prototype[f]=a.prototype[f]}}function Duplex(e){if(!(this instanceof Duplex))return new Duplex(e);i.call(this,e);a.call(this,e);this.allowHalfOpen=true;if(e){if(e.readable===false)this.readable=false;if(e.writable===false)this.writable=false;if(e.allowHalfOpen===false){this.allowHalfOpen=false;this.once(\"end\",onend)}}}Object.defineProperty(Duplex.prototype,\"writableHighWaterMark\",{enumerable:false,get:function get(){return this._writableState.highWaterMark}});Object.defineProperty(Duplex.prototype,\"writableBuffer\",{enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer()}});Object.defineProperty(Duplex.prototype,\"writableLength\",{enumerable:false,get:function get(){return this._writableState.length}});function onend(){if(this._writableState.ended)return;process.nextTick(onEndNT,this)}function onEndNT(e){e.end()}Object.defineProperty(Duplex.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._readableState===undefined||this._writableState===undefined){return false}return this._readableState.destroyed&&this._writableState.destroyed},set:function set(e){if(this._readableState===undefined||this._writableState===undefined){return}this._readableState.destroyed=e;this._writableState.destroyed=e}})},889:function(e,t,r){\"use strict\";e.exports=PassThrough;var n=r(170);r(782)(PassThrough,n);function PassThrough(e){if(!(this instanceof PassThrough))return new PassThrough(e);n.call(this,e)}PassThrough.prototype._transform=function(e,t,r){r(null,e)}},709:function(e,t,r){\"use strict\";e.exports=Readable;var n;Readable.ReadableState=ReadableState;var i=r(361).EventEmitter;var a=function EElistenerCount(e,t){return e.listeners(t).length};var o=r(678);var s=r(300).Buffer;var f=__webpack_require__.g.Uint8Array||function(){};function _uint8ArrayToBuffer(e){return s.from(e)}function _isUint8Array(e){return s.isBuffer(e)||e instanceof f}var l=r(837);var u;if(l&&l.debuglog){u=l.debuglog(\"stream\")}else{u=function debug(){}}var d=r(379);var c=r(25);var h=r(776),p=h.getHighWaterMark;var b=r(646).q,g=b.ERR_INVALID_ARG_TYPE,y=b.ERR_STREAM_PUSH_AFTER_EOF,_=b.ERR_METHOD_NOT_IMPLEMENTED,v=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;var w;var m;var S;r(782)(Readable,o);var R=c.errorOrDestroy;var E=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];function prependListener(e,t,r){if(typeof e.prependListener===\"function\")return e.prependListener(t,r);if(!e._events||!e._events[t])e.on(t,r);else if(Array.isArray(e._events[t]))e._events[t].unshift(r);else e._events[t]=[r,e._events[t]]}function ReadableState(e,t,i){n=n||r(403);e=e||{};if(typeof i!==\"boolean\")i=t instanceof n;this.objectMode=!!e.objectMode;if(i)this.objectMode=this.objectMode||!!e.readableObjectMode;this.highWaterMark=p(this,e,\"readableHighWaterMark\",i);this.buffer=new d;this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.ended=false;this.endEmitted=false;this.reading=false;this.sync=true;this.needReadable=false;this.emittedReadable=false;this.readableListening=false;this.resumeScheduled=false;this.paused=true;this.emitClose=e.emitClose!==false;this.autoDestroy=!!e.autoDestroy;this.destroyed=false;this.defaultEncoding=e.defaultEncoding||\"utf8\";this.awaitDrain=0;this.readingMore=false;this.decoder=null;this.encoding=null;if(e.encoding){if(!w)w=r(704).s;this.decoder=new w(e.encoding);this.encoding=e.encoding}}function Readable(e){n=n||r(403);if(!(this instanceof Readable))return new Readable(e);var t=this instanceof n;this._readableState=new ReadableState(e,this,t);this.readable=true;if(e){if(typeof e.read===\"function\")this._read=e.read;if(typeof e.destroy===\"function\")this._destroy=e.destroy}o.call(this)}Object.defineProperty(Readable.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._readableState===undefined){return false}return this._readableState.destroyed},set:function set(e){if(!this._readableState){return}this._readableState.destroyed=e}});Readable.prototype.destroy=c.destroy;Readable.prototype._undestroy=c.undestroy;Readable.prototype._destroy=function(e,t){t(e)};Readable.prototype.push=function(e,t){var r=this._readableState;var n;if(!r.objectMode){if(typeof e===\"string\"){t=t||r.defaultEncoding;if(t!==r.encoding){e=s.from(e,t);t=\"\"}n=true}}else{n=true}return readableAddChunk(this,e,t,false,n)};Readable.prototype.unshift=function(e){return readableAddChunk(this,e,null,true,false)};function readableAddChunk(e,t,r,n,i){u(\"readableAddChunk\",t);var a=e._readableState;if(t===null){a.reading=false;onEofChunk(e,a)}else{var o;if(!i)o=chunkInvalid(a,t);if(o){R(e,o)}else if(a.objectMode||t&&t.length>0){if(typeof t!==\"string\"&&!a.objectMode&&Object.getPrototypeOf(t)!==s.prototype){t=_uint8ArrayToBuffer(t)}if(n){if(a.endEmitted)R(e,new v);else addChunk(e,a,t,true)}else if(a.ended){R(e,new y)}else if(a.destroyed){return false}else{a.reading=false;if(a.decoder&&!r){t=a.decoder.write(t);if(a.objectMode||t.length!==0)addChunk(e,a,t,false);else maybeReadMore(e,a)}else{addChunk(e,a,t,false)}}}else if(!n){a.reading=false;maybeReadMore(e,a)}}return!a.ended&&(a.length<a.highWaterMark||a.length===0)}function addChunk(e,t,r,n){if(t.flowing&&t.length===0&&!t.sync){t.awaitDrain=0;e.emit(\"data\",r)}else{t.length+=t.objectMode?1:r.length;if(n)t.buffer.unshift(r);else t.buffer.push(r);if(t.needReadable)emitReadable(e)}maybeReadMore(e,t)}function chunkInvalid(e,t){var r;if(!_isUint8Array(t)&&typeof t!==\"string\"&&t!==undefined&&!e.objectMode){r=new g(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],t)}return r}Readable.prototype.isPaused=function(){return this._readableState.flowing===false};Readable.prototype.setEncoding=function(e){if(!w)w=r(704).s;var t=new w(e);this._readableState.decoder=t;this._readableState.encoding=this._readableState.decoder.encoding;var n=this._readableState.buffer.head;var i=\"\";while(n!==null){i+=t.write(n.data);n=n.next}this._readableState.buffer.clear();if(i!==\"\")this._readableState.buffer.push(i);this._readableState.length=i.length;return this};var T=1073741824;function computeNewHighWaterMark(e){if(e>=T){e=T}else{e--;e|=e>>>1;e|=e>>>2;e|=e>>>4;e|=e>>>8;e|=e>>>16;e++}return e}function howMuchToRead(e,t){if(e<=0||t.length===0&&t.ended)return 0;if(t.objectMode)return 1;if(e!==e){if(t.flowing&&t.length)return t.buffer.head.data.length;else return t.length}if(e>t.highWaterMark)t.highWaterMark=computeNewHighWaterMark(e);if(e<=t.length)return e;if(!t.ended){t.needReadable=true;return 0}return t.length}Readable.prototype.read=function(e){u(\"read\",e);e=parseInt(e,10);var t=this._readableState;var r=e;if(e!==0)t.emittedReadable=false;if(e===0&&t.needReadable&&((t.highWaterMark!==0?t.length>=t.highWaterMark:t.length>0)||t.ended)){u(\"read: emitReadable\",t.length,t.ended);if(t.length===0&&t.ended)endReadable(this);else emitReadable(this);return null}e=howMuchToRead(e,t);if(e===0&&t.ended){if(t.length===0)endReadable(this);return null}var n=t.needReadable;u(\"need readable\",n);if(t.length===0||t.length-e<t.highWaterMark){n=true;u(\"length less than watermark\",n)}if(t.ended||t.reading){n=false;u(\"reading or ended\",n)}else if(n){u(\"do read\");t.reading=true;t.sync=true;if(t.length===0)t.needReadable=true;this._read(t.highWaterMark);t.sync=false;if(!t.reading)e=howMuchToRead(r,t)}var i;if(e>0)i=fromList(e,t);else i=null;if(i===null){t.needReadable=t.length<=t.highWaterMark;e=0}else{t.length-=e;t.awaitDrain=0}if(t.length===0){if(!t.ended)t.needReadable=true;if(r!==e&&t.ended)endReadable(this)}if(i!==null)this.emit(\"data\",i);return i};function onEofChunk(e,t){u(\"onEofChunk\");if(t.ended)return;if(t.decoder){var r=t.decoder.end();if(r&&r.length){t.buffer.push(r);t.length+=t.objectMode?1:r.length}}t.ended=true;if(t.sync){emitReadable(e)}else{t.needReadable=false;if(!t.emittedReadable){t.emittedReadable=true;emitReadable_(e)}}}function emitReadable(e){var t=e._readableState;u(\"emitReadable\",t.needReadable,t.emittedReadable);t.needReadable=false;if(!t.emittedReadable){u(\"emitReadable\",t.flowing);t.emittedReadable=true;process.nextTick(emitReadable_,e)}}function emitReadable_(e){var t=e._readableState;u(\"emitReadable_\",t.destroyed,t.length,t.ended);if(!t.destroyed&&(t.length||t.ended)){e.emit(\"readable\");t.emittedReadable=false}t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark;flow(e)}function maybeReadMore(e,t){if(!t.readingMore){t.readingMore=true;process.nextTick(maybeReadMore_,e,t)}}function maybeReadMore_(e,t){while(!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&t.length===0)){var r=t.length;u(\"maybeReadMore read 0\");e.read(0);if(r===t.length)break}t.readingMore=false}Readable.prototype._read=function(e){R(this,new _(\"_read()\"))};Readable.prototype.pipe=function(e,t){var r=this;var n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e);break}n.pipesCount+=1;u(\"pipe count=%d opts=%j\",n.pipesCount,t);var i=(!t||t.end!==false)&&e!==process.stdout&&e!==process.stderr;var o=i?onend:unpipe;if(n.endEmitted)process.nextTick(o);else r.once(\"end\",o);e.on(\"unpipe\",onunpipe);function onunpipe(e,t){u(\"onunpipe\");if(e===r){if(t&&t.hasUnpiped===false){t.hasUnpiped=true;cleanup()}}}function onend(){u(\"onend\");e.end()}var s=pipeOnDrain(r);e.on(\"drain\",s);var f=false;function cleanup(){u(\"cleanup\");e.removeListener(\"close\",onclose);e.removeListener(\"finish\",onfinish);e.removeListener(\"drain\",s);e.removeListener(\"error\",onerror);e.removeListener(\"unpipe\",onunpipe);r.removeListener(\"end\",onend);r.removeListener(\"end\",unpipe);r.removeListener(\"data\",ondata);f=true;if(n.awaitDrain&&(!e._writableState||e._writableState.needDrain))s()}r.on(\"data\",ondata);function ondata(t){u(\"ondata\");var i=e.write(t);u(\"dest.write\",i);if(i===false){if((n.pipesCount===1&&n.pipes===e||n.pipesCount>1&&indexOf(n.pipes,e)!==-1)&&!f){u(\"false write response, pause\",n.awaitDrain);n.awaitDrain++}r.pause()}}function onerror(t){u(\"onerror\",t);unpipe();e.removeListener(\"error\",onerror);if(a(e,\"error\")===0)R(e,t)}prependListener(e,\"error\",onerror);function onclose(){e.removeListener(\"finish\",onfinish);unpipe()}e.once(\"close\",onclose);function onfinish(){u(\"onfinish\");e.removeListener(\"close\",onclose);unpipe()}e.once(\"finish\",onfinish);function unpipe(){u(\"unpipe\");r.unpipe(e)}e.emit(\"pipe\",r);if(!n.flowing){u(\"pipe resume\");r.resume()}return e};function pipeOnDrain(e){return function pipeOnDrainFunctionResult(){var t=e._readableState;u(\"pipeOnDrain\",t.awaitDrain);if(t.awaitDrain)t.awaitDrain--;if(t.awaitDrain===0&&a(e,\"data\")){t.flowing=true;flow(e)}}}Readable.prototype.unpipe=function(e){var t=this._readableState;var r={hasUnpiped:false};if(t.pipesCount===0)return this;if(t.pipesCount===1){if(e&&e!==t.pipes)return this;if(!e)e=t.pipes;t.pipes=null;t.pipesCount=0;t.flowing=false;if(e)e.emit(\"unpipe\",this,r);return this}if(!e){var n=t.pipes;var i=t.pipesCount;t.pipes=null;t.pipesCount=0;t.flowing=false;for(var a=0;a<i;a++){n[a].emit(\"unpipe\",this,{hasUnpiped:false})}return this}var o=indexOf(t.pipes,e);if(o===-1)return this;t.pipes.splice(o,1);t.pipesCount-=1;if(t.pipesCount===1)t.pipes=t.pipes[0];e.emit(\"unpipe\",this,r);return this};Readable.prototype.on=function(e,t){var r=o.prototype.on.call(this,e,t);var n=this._readableState;if(e===\"data\"){n.readableListening=this.listenerCount(\"readable\")>0;if(n.flowing!==false)this.resume()}else if(e===\"readable\"){if(!n.endEmitted&&!n.readableListening){n.readableListening=n.needReadable=true;n.flowing=false;n.emittedReadable=false;u(\"on readable\",n.length,n.reading);if(n.length){emitReadable(this)}else if(!n.reading){process.nextTick(nReadingNextTick,this)}}}return r};Readable.prototype.addListener=Readable.prototype.on;Readable.prototype.removeListener=function(e,t){var r=o.prototype.removeListener.call(this,e,t);if(e===\"readable\"){process.nextTick(updateReadableListening,this)}return r};Readable.prototype.removeAllListeners=function(e){var t=o.prototype.removeAllListeners.apply(this,arguments);if(e===\"readable\"||e===undefined){process.nextTick(updateReadableListening,this)}return t};function updateReadableListening(e){var t=e._readableState;t.readableListening=e.listenerCount(\"readable\")>0;if(t.resumeScheduled&&!t.paused){t.flowing=true}else if(e.listenerCount(\"data\")>0){e.resume()}}function nReadingNextTick(e){u(\"readable nexttick read 0\");e.read(0)}Readable.prototype.resume=function(){var e=this._readableState;if(!e.flowing){u(\"resume\");e.flowing=!e.readableListening;resume(this,e)}e.paused=false;return this};function resume(e,t){if(!t.resumeScheduled){t.resumeScheduled=true;process.nextTick(resume_,e,t)}}function resume_(e,t){u(\"resume\",t.reading);if(!t.reading){e.read(0)}t.resumeScheduled=false;e.emit(\"resume\");flow(e);if(t.flowing&&!t.reading)e.read(0)}Readable.prototype.pause=function(){u(\"call pause flowing=%j\",this._readableState.flowing);if(this._readableState.flowing!==false){u(\"pause\");this._readableState.flowing=false;this.emit(\"pause\")}this._readableState.paused=true;return this};function flow(e){var t=e._readableState;u(\"flow\",t.flowing);while(t.flowing&&e.read()!==null){}}Readable.prototype.wrap=function(e){var t=this;var r=this._readableState;var n=false;e.on(\"end\",(function(){u(\"wrapped end\");if(r.decoder&&!r.ended){var e=r.decoder.end();if(e&&e.length)t.push(e)}t.push(null)}));e.on(\"data\",(function(i){u(\"wrapped data\");if(r.decoder)i=r.decoder.write(i);if(r.objectMode&&(i===null||i===undefined))return;else if(!r.objectMode&&(!i||!i.length))return;var a=t.push(i);if(!a){n=true;e.pause()}}));for(var i in e){if(this[i]===undefined&&typeof e[i]===\"function\"){this[i]=function methodWrap(t){return function methodWrapReturnFunction(){return e[t].apply(e,arguments)}}(i)}}for(var a=0;a<E.length;a++){e.on(E[a],this.emit.bind(this,E[a]))}this._read=function(t){u(\"wrapped _read\",t);if(n){n=false;e.resume()}};return this};if(typeof Symbol===\"function\"){Readable.prototype[Symbol.asyncIterator]=function(){if(m===undefined){m=r(871)}return m(this)}}Object.defineProperty(Readable.prototype,\"readableHighWaterMark\",{enumerable:false,get:function get(){return this._readableState.highWaterMark}});Object.defineProperty(Readable.prototype,\"readableBuffer\",{enumerable:false,get:function get(){return this._readableState&&this._readableState.buffer}});Object.defineProperty(Readable.prototype,\"readableFlowing\",{enumerable:false,get:function get(){return this._readableState.flowing},set:function set(e){if(this._readableState){this._readableState.flowing=e}}});Readable._fromList=fromList;Object.defineProperty(Readable.prototype,\"readableLength\",{enumerable:false,get:function get(){return this._readableState.length}});function fromList(e,t){if(t.length===0)return null;var r;if(t.objectMode)r=t.buffer.shift();else if(!e||e>=t.length){if(t.decoder)r=t.buffer.join(\"\");else if(t.buffer.length===1)r=t.buffer.first();else r=t.buffer.concat(t.length);t.buffer.clear()}else{r=t.buffer.consume(e,t.decoder)}return r}function endReadable(e){var t=e._readableState;u(\"endReadable\",t.endEmitted);if(!t.endEmitted){t.ended=true;process.nextTick(endReadableNT,t,e)}}function endReadableNT(e,t){u(\"endReadableNT\",e.endEmitted,e.length);if(!e.endEmitted&&e.length===0){e.endEmitted=true;t.readable=false;t.emit(\"end\");if(e.autoDestroy){var r=t._writableState;if(!r||r.autoDestroy&&r.finished){t.destroy()}}}}if(typeof Symbol===\"function\"){Readable.from=function(e,t){if(S===undefined){S=r(727)}return S(Readable,e,t)}}function indexOf(e,t){for(var r=0,n=e.length;r<n;r++){if(e[r]===t)return r}return-1}},170:function(e,t,r){\"use strict\";e.exports=Transform;var n=r(646).q,i=n.ERR_METHOD_NOT_IMPLEMENTED,a=n.ERR_MULTIPLE_CALLBACK,o=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,s=n.ERR_TRANSFORM_WITH_LENGTH_0;var f=r(403);r(782)(Transform,f);function afterTransform(e,t){var r=this._transformState;r.transforming=false;var n=r.writecb;if(n===null){return this.emit(\"error\",new a)}r.writechunk=null;r.writecb=null;if(t!=null)this.push(t);n(e);var i=this._readableState;i.reading=false;if(i.needReadable||i.length<i.highWaterMark){this._read(i.highWaterMark)}}function Transform(e){if(!(this instanceof Transform))return new Transform(e);f.call(this,e);this._transformState={afterTransform:afterTransform.bind(this),needTransform:false,transforming:false,writecb:null,writechunk:null,writeencoding:null};this._readableState.needReadable=true;this._readableState.sync=false;if(e){if(typeof e.transform===\"function\")this._transform=e.transform;if(typeof e.flush===\"function\")this._flush=e.flush}this.on(\"prefinish\",prefinish)}function prefinish(){var e=this;if(typeof this._flush===\"function\"&&!this._readableState.destroyed){this._flush((function(t,r){done(e,t,r)}))}else{done(this,null,null)}}Transform.prototype.push=function(e,t){this._transformState.needTransform=false;return f.prototype.push.call(this,e,t)};Transform.prototype._transform=function(e,t,r){r(new i(\"_transform()\"))};Transform.prototype._write=function(e,t,r){var n=this._transformState;n.writecb=r;n.writechunk=e;n.writeencoding=t;if(!n.transforming){var i=this._readableState;if(n.needTransform||i.needReadable||i.length<i.highWaterMark)this._read(i.highWaterMark)}};Transform.prototype._read=function(e){var t=this._transformState;if(t.writechunk!==null&&!t.transforming){t.transforming=true;this._transform(t.writechunk,t.writeencoding,t.afterTransform)}else{t.needTransform=true}};Transform.prototype._destroy=function(e,t){f.prototype._destroy.call(this,e,(function(e){t(e)}))};function done(e,t,r){if(t)return e.emit(\"error\",t);if(r!=null)e.push(r);if(e._writableState.length)throw new s;if(e._transformState.transforming)throw new o;return e.push(null)}},337:function(e,t,r){\"use strict\";e.exports=Writable;function WriteReq(e,t,r){this.chunk=e;this.encoding=t;this.callback=r;this.next=null}function CorkedRequest(e){var t=this;this.next=null;this.entry=null;this.finish=function(){onCorkedFinish(t,e)}}var n;Writable.WritableState=WritableState;var i={deprecate:r(769)};var a=r(678);var o=r(300).Buffer;var s=__webpack_require__.g.Uint8Array||function(){};function _uint8ArrayToBuffer(e){return o.from(e)}function _isUint8Array(e){return o.isBuffer(e)||e instanceof s}var f=r(25);var l=r(776),u=l.getHighWaterMark;var d=r(646).q,c=d.ERR_INVALID_ARG_TYPE,h=d.ERR_METHOD_NOT_IMPLEMENTED,p=d.ERR_MULTIPLE_CALLBACK,b=d.ERR_STREAM_CANNOT_PIPE,g=d.ERR_STREAM_DESTROYED,y=d.ERR_STREAM_NULL_VALUES,_=d.ERR_STREAM_WRITE_AFTER_END,v=d.ERR_UNKNOWN_ENCODING;var w=f.errorOrDestroy;r(782)(Writable,a);function nop(){}function WritableState(e,t,i){n=n||r(403);e=e||{};if(typeof i!==\"boolean\")i=t instanceof n;this.objectMode=!!e.objectMode;if(i)this.objectMode=this.objectMode||!!e.writableObjectMode;this.highWaterMark=u(this,e,\"writableHighWaterMark\",i);this.finalCalled=false;this.needDrain=false;this.ending=false;this.ended=false;this.finished=false;this.destroyed=false;var a=e.decodeStrings===false;this.decodeStrings=!a;this.defaultEncoding=e.defaultEncoding||\"utf8\";this.length=0;this.writing=false;this.corked=0;this.sync=true;this.bufferProcessing=false;this.onwrite=function(e){onwrite(t,e)};this.writecb=null;this.writelen=0;this.bufferedRequest=null;this.lastBufferedRequest=null;this.pendingcb=0;this.prefinished=false;this.errorEmitted=false;this.emitClose=e.emitClose!==false;this.autoDestroy=!!e.autoDestroy;this.bufferedRequestCount=0;this.corkedRequestsFree=new CorkedRequest(this)}WritableState.prototype.getBuffer=function getBuffer(){var e=this.bufferedRequest;var t=[];while(e){t.push(e);e=e.next}return t};(function(){try{Object.defineProperty(WritableState.prototype,\"buffer\",{get:i.deprecate((function writableStateBufferGetter(){return this.getBuffer()}),\"_writableState.buffer is deprecated. Use _writableState.getBuffer \"+\"instead.\",\"DEP0003\")})}catch(e){}})();var m;if(typeof Symbol===\"function\"&&Symbol.hasInstance&&typeof Function.prototype[Symbol.hasInstance]===\"function\"){m=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:function value(e){if(m.call(this,e))return true;if(this!==Writable)return false;return e&&e._writableState instanceof WritableState}})}else{m=function realHasInstance(e){return e instanceof this}}function Writable(e){n=n||r(403);var t=this instanceof n;if(!t&&!m.call(Writable,this))return new Writable(e);this._writableState=new WritableState(e,this,t);this.writable=true;if(e){if(typeof e.write===\"function\")this._write=e.write;if(typeof e.writev===\"function\")this._writev=e.writev;if(typeof e.destroy===\"function\")this._destroy=e.destroy;if(typeof e.final===\"function\")this._final=e.final}a.call(this)}Writable.prototype.pipe=function(){w(this,new b)};function writeAfterEnd(e,t){var r=new _;w(e,r);process.nextTick(t,r)}function validChunk(e,t,r,n){var i;if(r===null){i=new y}else if(typeof r!==\"string\"&&!t.objectMode){i=new c(\"chunk\",[\"string\",\"Buffer\"],r)}if(i){w(e,i);process.nextTick(n,i);return false}return true}Writable.prototype.write=function(e,t,r){var n=this._writableState;var i=false;var a=!n.objectMode&&_isUint8Array(e);if(a&&!o.isBuffer(e)){e=_uint8ArrayToBuffer(e)}if(typeof t===\"function\"){r=t;t=null}if(a)t=\"buffer\";else if(!t)t=n.defaultEncoding;if(typeof r!==\"function\")r=nop;if(n.ending)writeAfterEnd(this,r);else if(a||validChunk(this,n,e,r)){n.pendingcb++;i=writeOrBuffer(this,n,a,e,t,r)}return i};Writable.prototype.cork=function(){this._writableState.corked++};Writable.prototype.uncork=function(){var e=this._writableState;if(e.corked){e.corked--;if(!e.writing&&!e.corked&&!e.bufferProcessing&&e.bufferedRequest)clearBuffer(this,e)}};Writable.prototype.setDefaultEncoding=function setDefaultEncoding(e){if(typeof e===\"string\")e=e.toLowerCase();if(!([\"hex\",\"utf8\",\"utf-8\",\"ascii\",\"binary\",\"base64\",\"ucs2\",\"ucs-2\",\"utf16le\",\"utf-16le\",\"raw\"].indexOf((e+\"\").toLowerCase())>-1))throw new v(e);this._writableState.defaultEncoding=e;return this};Object.defineProperty(Writable.prototype,\"writableBuffer\",{enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer()}});function decodeChunk(e,t,r){if(!e.objectMode&&e.decodeStrings!==false&&typeof t===\"string\"){t=o.from(t,r)}return t}Object.defineProperty(Writable.prototype,\"writableHighWaterMark\",{enumerable:false,get:function get(){return this._writableState.highWaterMark}});function writeOrBuffer(e,t,r,n,i,a){if(!r){var o=decodeChunk(t,n,i);if(n!==o){r=true;i=\"buffer\";n=o}}var s=t.objectMode?1:n.length;t.length+=s;var f=t.length<t.highWaterMark;if(!f)t.needDrain=true;if(t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:a,next:null};if(l){l.next=t.lastBufferedRequest}else{t.bufferedRequest=t.lastBufferedRequest}t.bufferedRequestCount+=1}else{doWrite(e,t,false,s,n,i,a)}return f}function doWrite(e,t,r,n,i,a,o){t.writelen=n;t.writecb=o;t.writing=true;t.sync=true;if(t.destroyed)t.onwrite(new g(\"write\"));else if(r)e._writev(i,t.onwrite);else e._write(i,a,t.onwrite);t.sync=false}function onwriteError(e,t,r,n,i){--t.pendingcb;if(r){process.nextTick(i,n);process.nextTick(finishMaybe,e,t);e._writableState.errorEmitted=true;w(e,n)}else{i(n);e._writableState.errorEmitted=true;w(e,n);finishMaybe(e,t)}}function onwriteStateUpdate(e){e.writing=false;e.writecb=null;e.length-=e.writelen;e.writelen=0}function onwrite(e,t){var r=e._writableState;var n=r.sync;var i=r.writecb;if(typeof i!==\"function\")throw new p;onwriteStateUpdate(r);if(t)onwriteError(e,r,n,t,i);else{var a=needFinish(r)||e.destroyed;if(!a&&!r.corked&&!r.bufferProcessing&&r.bufferedRequest){clearBuffer(e,r)}if(n){process.nextTick(afterWrite,e,r,a,i)}else{afterWrite(e,r,a,i)}}}function afterWrite(e,t,r,n){if(!r)onwriteDrain(e,t);t.pendingcb--;n();finishMaybe(e,t)}function onwriteDrain(e,t){if(t.length===0&&t.needDrain){t.needDrain=false;e.emit(\"drain\")}}function clearBuffer(e,t){t.bufferProcessing=true;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount;var i=new Array(n);var a=t.corkedRequestsFree;a.entry=r;var o=0;var s=true;while(r){i[o]=r;if(!r.isBuf)s=false;r=r.next;o+=1}i.allBuffers=s;doWrite(e,t,true,t.length,i,\"\",a.finish);t.pendingcb++;t.lastBufferedRequest=null;if(a.next){t.corkedRequestsFree=a.next;a.next=null}else{t.corkedRequestsFree=new CorkedRequest(t)}t.bufferedRequestCount=0}else{while(r){var f=r.chunk;var l=r.encoding;var u=r.callback;var d=t.objectMode?1:f.length;doWrite(e,t,false,d,f,l,u);r=r.next;t.bufferedRequestCount--;if(t.writing){break}}if(r===null)t.lastBufferedRequest=null}t.bufferedRequest=r;t.bufferProcessing=false}Writable.prototype._write=function(e,t,r){r(new h(\"_write()\"))};Writable.prototype._writev=null;Writable.prototype.end=function(e,t,r){var n=this._writableState;if(typeof e===\"function\"){r=e;e=null;t=null}else if(typeof t===\"function\"){r=t;t=null}if(e!==null&&e!==undefined)this.write(e,t);if(n.corked){n.corked=1;this.uncork()}if(!n.ending)endWritable(this,n,r);return this};Object.defineProperty(Writable.prototype,\"writableLength\",{enumerable:false,get:function get(){return this._writableState.length}});function needFinish(e){return e.ending&&e.length===0&&e.bufferedRequest===null&&!e.finished&&!e.writing}function callFinal(e,t){e._final((function(r){t.pendingcb--;if(r){w(e,r)}t.prefinished=true;e.emit(\"prefinish\");finishMaybe(e,t)}))}function prefinish(e,t){if(!t.prefinished&&!t.finalCalled){if(typeof e._final===\"function\"&&!t.destroyed){t.pendingcb++;t.finalCalled=true;process.nextTick(callFinal,e,t)}else{t.prefinished=true;e.emit(\"prefinish\")}}}function finishMaybe(e,t){var r=needFinish(t);if(r){prefinish(e,t);if(t.pendingcb===0){t.finished=true;e.emit(\"finish\");if(t.autoDestroy){var n=e._readableState;if(!n||n.autoDestroy&&n.endEmitted){e.destroy()}}}}return r}function endWritable(e,t,r){t.ending=true;finishMaybe(e,t);if(r){if(t.finished)process.nextTick(r);else e.once(\"finish\",r)}t.ended=true;e.writable=false}function onCorkedFinish(e,t,r){var n=e.entry;e.entry=null;while(n){var i=n.callback;t.pendingcb--;i(r);n=n.next}t.corkedRequestsFree.next=e}Object.defineProperty(Writable.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._writableState===undefined){return false}return this._writableState.destroyed},set:function set(e){if(!this._writableState){return}this._writableState.destroyed=e}});Writable.prototype.destroy=f.destroy;Writable.prototype._undestroy=f.undestroy;Writable.prototype._destroy=function(e,t){t(e)}},871:function(e,t,r){\"use strict\";var n;function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}var i=r(698);var a=Symbol(\"lastResolve\");var o=Symbol(\"lastReject\");var s=Symbol(\"error\");var f=Symbol(\"ended\");var l=Symbol(\"lastPromise\");var u=Symbol(\"handlePromise\");var d=Symbol(\"stream\");function createIterResult(e,t){return{value:e,done:t}}function readAndResolve(e){var t=e[a];if(t!==null){var r=e[d].read();if(r!==null){e[l]=null;e[a]=null;e[o]=null;t(createIterResult(r,false))}}}function onReadable(e){process.nextTick(readAndResolve,e)}function wrapForNext(e,t){return function(r,n){e.then((function(){if(t[f]){r(createIterResult(undefined,true));return}t[u](r,n)}),n)}}var c=Object.getPrototypeOf((function(){}));var h=Object.setPrototypeOf((n={get stream(){return this[d]},next:function next(){var e=this;var t=this[s];if(t!==null){return Promise.reject(t)}if(this[f]){return Promise.resolve(createIterResult(undefined,true))}if(this[d].destroyed){return new Promise((function(t,r){process.nextTick((function(){if(e[s]){r(e[s])}else{t(createIterResult(undefined,true))}}))}))}var r=this[l];var n;if(r){n=new Promise(wrapForNext(r,this))}else{var i=this[d].read();if(i!==null){return Promise.resolve(createIterResult(i,false))}n=new Promise(this[u])}this[l]=n;return n}},_defineProperty(n,Symbol.asyncIterator,(function(){return this})),_defineProperty(n,\"return\",(function _return(){var e=this;return new Promise((function(t,r){e[d].destroy(null,(function(e){if(e){r(e);return}t(createIterResult(undefined,true))}))}))})),n),c);var p=function createReadableStreamAsyncIterator(e){var t;var r=Object.create(h,(t={},_defineProperty(t,d,{value:e,writable:true}),_defineProperty(t,a,{value:null,writable:true}),_defineProperty(t,o,{value:null,writable:true}),_defineProperty(t,s,{value:null,writable:true}),_defineProperty(t,f,{value:e._readableState.endEmitted,writable:true}),_defineProperty(t,u,{value:function value(e,t){var n=r[d].read();if(n){r[l]=null;r[a]=null;r[o]=null;e(createIterResult(n,false))}else{r[a]=e;r[o]=t}},writable:true}),t));r[l]=null;i(e,(function(e){if(e&&e.code!==\"ERR_STREAM_PREMATURE_CLOSE\"){var t=r[o];if(t!==null){r[l]=null;r[a]=null;r[o]=null;t(e)}r[s]=e;return}var n=r[a];if(n!==null){r[l]=null;r[a]=null;r[o]=null;n(createIterResult(undefined,true))}r[f]=true}));e.on(\"readable\",onReadable.bind(null,r));return r};e.exports=p},379:function(e,t,r){\"use strict\";function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);if(t)n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}));r.push.apply(r,n)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};if(t%2){ownKeys(Object(r),true).forEach((function(t){_defineProperty(e,t,r[t])}))}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(e,Object.getOwnPropertyDescriptors(r))}else{ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}}return e}function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}function _classCallCheck(e,t){if(!(e instanceof t)){throw new TypeError(\"Cannot call a class as a function\")}}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||false;n.configurable=true;if(\"value\"in n)n.writable=true;Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){if(t)_defineProperties(e.prototype,t);if(r)_defineProperties(e,r);return e}var n=r(300),i=n.Buffer;var a=r(837),o=a.inspect;var s=o&&o.custom||\"inspect\";function copyBuffer(e,t,r){i.prototype.copy.call(e,t,r)}e.exports=function(){function BufferList(){_classCallCheck(this,BufferList);this.head=null;this.tail=null;this.length=0}_createClass(BufferList,[{key:\"push\",value:function push(e){var t={data:e,next:null};if(this.length>0)this.tail.next=t;else this.head=t;this.tail=t;++this.length}},{key:\"unshift\",value:function unshift(e){var t={data:e,next:this.head};if(this.length===0)this.tail=t;this.head=t;++this.length}},{key:\"shift\",value:function shift(){if(this.length===0)return;var e=this.head.data;if(this.length===1)this.head=this.tail=null;else this.head=this.head.next;--this.length;return e}},{key:\"clear\",value:function clear(){this.head=this.tail=null;this.length=0}},{key:\"join\",value:function join(e){if(this.length===0)return\"\";var t=this.head;var r=\"\"+t.data;while(t=t.next){r+=e+t.data}return r}},{key:\"concat\",value:function concat(e){if(this.length===0)return i.alloc(0);var t=i.allocUnsafe(e>>>0);var r=this.head;var n=0;while(r){copyBuffer(r.data,t,n);n+=r.data.length;r=r.next}return t}},{key:\"consume\",value:function consume(e,t){var r;if(e<this.head.data.length){r=this.head.data.slice(0,e);this.head.data=this.head.data.slice(e)}else if(e===this.head.data.length){r=this.shift()}else{r=t?this._getString(e):this._getBuffer(e)}return r}},{key:\"first\",value:function first(){return this.head.data}},{key:\"_getString\",value:function _getString(e){var t=this.head;var r=1;var n=t.data;e-=n.length;while(t=t.next){var i=t.data;var a=e>i.length?i.length:e;if(a===i.length)n+=i;else n+=i.slice(0,e);e-=a;if(e===0){if(a===i.length){++r;if(t.next)this.head=t.next;else this.head=this.tail=null}else{this.head=t;t.data=i.slice(a)}break}++r}this.length-=r;return n}},{key:\"_getBuffer\",value:function _getBuffer(e){var t=i.allocUnsafe(e);var r=this.head;var n=1;r.data.copy(t);e-=r.data.length;while(r=r.next){var a=r.data;var o=e>a.length?a.length:e;a.copy(t,t.length-e,0,o);e-=o;if(e===0){if(o===a.length){++n;if(r.next)this.head=r.next;else this.head=this.tail=null}else{this.head=r;r.data=a.slice(o)}break}++n}this.length-=n;return t}},{key:s,value:function value(e,t){return o(this,_objectSpread({},t,{depth:0,customInspect:false}))}}]);return BufferList}()},25:function(e){\"use strict\";function destroy(e,t){var r=this;var n=this._readableState&&this._readableState.destroyed;var i=this._writableState&&this._writableState.destroyed;if(n||i){if(t){t(e)}else if(e){if(!this._writableState){process.nextTick(emitErrorNT,this,e)}else if(!this._writableState.errorEmitted){this._writableState.errorEmitted=true;process.nextTick(emitErrorNT,this,e)}}return this}if(this._readableState){this._readableState.destroyed=true}if(this._writableState){this._writableState.destroyed=true}this._destroy(e||null,(function(e){if(!t&&e){if(!r._writableState){process.nextTick(emitErrorAndCloseNT,r,e)}else if(!r._writableState.errorEmitted){r._writableState.errorEmitted=true;process.nextTick(emitErrorAndCloseNT,r,e)}else{process.nextTick(emitCloseNT,r)}}else if(t){process.nextTick(emitCloseNT,r);t(e)}else{process.nextTick(emitCloseNT,r)}}));return this}function emitErrorAndCloseNT(e,t){emitErrorNT(e,t);emitCloseNT(e)}function emitCloseNT(e){if(e._writableState&&!e._writableState.emitClose)return;if(e._readableState&&!e._readableState.emitClose)return;e.emit(\"close\")}function undestroy(){if(this._readableState){this._readableState.destroyed=false;this._readableState.reading=false;this._readableState.ended=false;this._readableState.endEmitted=false}if(this._writableState){this._writableState.destroyed=false;this._writableState.ended=false;this._writableState.ending=false;this._writableState.finalCalled=false;this._writableState.prefinished=false;this._writableState.finished=false;this._writableState.errorEmitted=false}}function emitErrorNT(e,t){e.emit(\"error\",t)}function errorOrDestroy(e,t){var r=e._readableState;var n=e._writableState;if(r&&r.autoDestroy||n&&n.autoDestroy)e.destroy(t);else e.emit(\"error\",t)}e.exports={destroy:destroy,undestroy:undestroy,errorOrDestroy:errorOrDestroy}},698:function(e,t,r){\"use strict\";var n=r(646).q.ERR_STREAM_PREMATURE_CLOSE;function once(e){var t=false;return function(){if(t)return;t=true;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++){n[i]=arguments[i]}e.apply(this,n)}}function noop(){}function isRequest(e){return e.setHeader&&typeof e.abort===\"function\"}function eos(e,t,r){if(typeof t===\"function\")return eos(e,null,t);if(!t)t={};r=once(r||noop);var i=t.readable||t.readable!==false&&e.readable;var a=t.writable||t.writable!==false&&e.writable;var o=function onlegacyfinish(){if(!e.writable)f()};var s=e._writableState&&e._writableState.finished;var f=function onfinish(){a=false;s=true;if(!i)r.call(e)};var l=e._readableState&&e._readableState.endEmitted;var u=function onend(){i=false;l=true;if(!a)r.call(e)};var d=function onerror(t){r.call(e,t)};var c=function onclose(){var t;if(i&&!l){if(!e._readableState||!e._readableState.ended)t=new n;return r.call(e,t)}if(a&&!s){if(!e._writableState||!e._writableState.ended)t=new n;return r.call(e,t)}};var h=function onrequest(){e.req.on(\"finish\",f)};if(isRequest(e)){e.on(\"complete\",f);e.on(\"abort\",c);if(e.req)h();else e.on(\"request\",h)}else if(a&&!e._writableState){e.on(\"end\",o);e.on(\"close\",o)}e.on(\"end\",u);e.on(\"finish\",f);if(t.error!==false)e.on(\"error\",d);e.on(\"close\",c);return function(){e.removeListener(\"complete\",f);e.removeListener(\"abort\",c);e.removeListener(\"request\",h);if(e.req)e.req.removeListener(\"finish\",f);e.removeListener(\"end\",o);e.removeListener(\"close\",o);e.removeListener(\"finish\",f);e.removeListener(\"end\",u);e.removeListener(\"error\",d);e.removeListener(\"close\",c)}}e.exports=eos},727:function(e,t,r){\"use strict\";function asyncGeneratorStep(e,t,r,n,i,a,o){try{var s=e[a](o);var f=s.value}catch(e){r(e);return}if(s.done){t(f)}else{Promise.resolve(f).then(n,i)}}function _asyncToGenerator(e){return function(){var t=this,r=arguments;return new Promise((function(n,i){var a=e.apply(t,r);function _next(e){asyncGeneratorStep(a,n,i,_next,_throw,\"next\",e)}function _throw(e){asyncGeneratorStep(a,n,i,_next,_throw,\"throw\",e)}_next(undefined)}))}}function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);if(t)n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}));r.push.apply(r,n)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};if(t%2){ownKeys(Object(r),true).forEach((function(t){_defineProperty(e,t,r[t])}))}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(e,Object.getOwnPropertyDescriptors(r))}else{ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}}return e}function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}var n=r(646).q.ERR_INVALID_ARG_TYPE;function from(e,t,r){var i;if(t&&typeof t.next===\"function\"){i=t}else if(t&&t[Symbol.asyncIterator])i=t[Symbol.asyncIterator]();else if(t&&t[Symbol.iterator])i=t[Symbol.iterator]();else throw new n(\"iterable\",[\"Iterable\"],t);var a=new e(_objectSpread({objectMode:true},r));var o=false;a._read=function(){if(!o){o=true;next()}};function next(){return _next2.apply(this,arguments)}function _next2(){_next2=_asyncToGenerator((function*(){try{var e=yield i.next(),t=e.value,r=e.done;if(r){a.push(null)}else if(a.push(yield t)){next()}else{o=false}}catch(e){a.destroy(e)}}));return _next2.apply(this,arguments)}return a}e.exports=from},442:function(e,t,r){\"use strict\";var n;function once(e){var t=false;return function(){if(t)return;t=true;e.apply(void 0,arguments)}}var i=r(646).q,a=i.ERR_MISSING_ARGS,o=i.ERR_STREAM_DESTROYED;function noop(e){if(e)throw e}function isRequest(e){return e.setHeader&&typeof e.abort===\"function\"}function destroyer(e,t,i,a){a=once(a);var s=false;e.on(\"close\",(function(){s=true}));if(n===undefined)n=r(698);n(e,{readable:t,writable:i},(function(e){if(e)return a(e);s=true;a()}));var f=false;return function(t){if(s)return;if(f)return;f=true;if(isRequest(e))return e.abort();if(typeof e.destroy===\"function\")return e.destroy();a(t||new o(\"pipe\"))}}function call(e){e()}function pipe(e,t){return e.pipe(t)}function popCallback(e){if(!e.length)return noop;if(typeof e[e.length-1]!==\"function\")return noop;return e.pop()}function pipeline(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++){t[r]=arguments[r]}var n=popCallback(t);if(Array.isArray(t[0]))t=t[0];if(t.length<2){throw new a(\"streams\")}var i;var o=t.map((function(e,r){var a=r<t.length-1;var s=r>0;return destroyer(e,a,s,(function(e){if(!i)i=e;if(e)o.forEach(call);if(a)return;o.forEach(call);n(i)}))}));return t.reduce(pipe)}e.exports=pipeline},776:function(e,t,r){\"use strict\";var n=r(646).q.ERR_INVALID_OPT_VALUE;function highWaterMarkFrom(e,t,r){return e.highWaterMark!=null?e.highWaterMark:t?e[r]:null}function getHighWaterMark(e,t,r,i){var a=highWaterMarkFrom(t,i,r);if(a!=null){if(!(isFinite(a)&&Math.floor(a)===a)||a<0){var o=i?r:\"highWaterMark\";throw new n(o,a)}return Math.floor(a)}return e.objectMode?16:16*1024}e.exports={getHighWaterMark:getHighWaterMark}},678:function(e,t,r){e.exports=r(781)},55:function(e,t,r){var n=r(300);var i=n.Buffer;function copyProps(e,t){for(var r in e){t[r]=e[r]}}if(i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow){e.exports=n}else{copyProps(n,t);t.Buffer=SafeBuffer}function SafeBuffer(e,t,r){return i(e,t,r)}SafeBuffer.prototype=Object.create(i.prototype);copyProps(i,SafeBuffer);SafeBuffer.from=function(e,t,r){if(typeof e===\"number\"){throw new TypeError(\"Argument must not be a number\")}return i(e,t,r)};SafeBuffer.alloc=function(e,t,r){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}var n=i(e);if(t!==undefined){if(typeof r===\"string\"){n.fill(t,r)}else{n.fill(t)}}else{n.fill(0)}return n};SafeBuffer.allocUnsafe=function(e){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}return i(e)};SafeBuffer.allocUnsafeSlow=function(e){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}return n.SlowBuffer(e)}},173:function(e,t,r){e.exports=Stream;var n=r(361).EventEmitter;var i=r(782);i(Stream,n);Stream.Readable=r(709);Stream.Writable=r(337);Stream.Duplex=r(403);Stream.Transform=r(170);Stream.PassThrough=r(889);Stream.finished=r(698);Stream.pipeline=r(442);Stream.Stream=Stream;function Stream(){n.call(this)}Stream.prototype.pipe=function(e,t){var r=this;function ondata(t){if(e.writable){if(false===e.write(t)&&r.pause){r.pause()}}}r.on(\"data\",ondata);function ondrain(){if(r.readable&&r.resume){r.resume()}}e.on(\"drain\",ondrain);if(!e._isStdio&&(!t||t.end!==false)){r.on(\"end\",onend);r.on(\"close\",onclose)}var i=false;function onend(){if(i)return;i=true;e.end()}function onclose(){if(i)return;i=true;if(typeof e.destroy===\"function\")e.destroy()}function onerror(e){cleanup();if(n.listenerCount(this,\"error\")===0){throw e}}r.on(\"error\",onerror);e.on(\"error\",onerror);function cleanup(){r.removeListener(\"data\",ondata);e.removeListener(\"drain\",ondrain);r.removeListener(\"end\",onend);r.removeListener(\"close\",onclose);r.removeListener(\"error\",onerror);e.removeListener(\"error\",onerror);r.removeListener(\"end\",cleanup);r.removeListener(\"close\",cleanup);e.removeListener(\"close\",cleanup)}r.on(\"end\",cleanup);r.on(\"close\",cleanup);e.on(\"close\",cleanup);e.emit(\"pipe\",r);return e}},704:function(e,t,r){\"use strict\";var n=r(55).Buffer;var i=n.isEncoding||function(e){e=\"\"+e;switch(e&&e.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return true;default:return false}};function _normalizeEncoding(e){if(!e)return\"utf8\";var t;while(true){switch(e){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return e;default:if(t)return;e=(\"\"+e).toLowerCase();t=true}}}function normalizeEncoding(e){var t=_normalizeEncoding(e);if(typeof t!==\"string\"&&(n.isEncoding===i||!i(e)))throw new Error(\"Unknown encoding: \"+e);return t||e}t.s=StringDecoder;function StringDecoder(e){this.encoding=normalizeEncoding(e);var t;switch(this.encoding){case\"utf16le\":this.text=utf16Text;this.end=utf16End;t=4;break;case\"utf8\":this.fillLast=utf8FillLast;t=4;break;case\"base64\":this.text=base64Text;this.end=base64End;t=3;break;default:this.write=simpleWrite;this.end=simpleEnd;return}this.lastNeed=0;this.lastTotal=0;this.lastChar=n.allocUnsafe(t)}StringDecoder.prototype.write=function(e){if(e.length===0)return\"\";var t;var r;if(this.lastNeed){t=this.fillLast(e);if(t===undefined)return\"\";r=this.lastNeed;this.lastNeed=0}else{r=0}if(r<e.length)return t?t+this.text(e,r):this.text(e,r);return t||\"\"};StringDecoder.prototype.end=utf8End;StringDecoder.prototype.text=utf8Text;StringDecoder.prototype.fillLast=function(e){if(this.lastNeed<=e.length){e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal)}e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length);this.lastNeed-=e.length};function utf8CheckByte(e){if(e<=127)return 0;else if(e>>5===6)return 2;else if(e>>4===14)return 3;else if(e>>3===30)return 4;return e>>6===2?-1:-2}function utf8CheckIncomplete(e,t,r){var n=t.length-1;if(n<r)return 0;var i=utf8CheckByte(t[n]);if(i>=0){if(i>0)e.lastNeed=i-1;return i}if(--n<r||i===-2)return 0;i=utf8CheckByte(t[n]);if(i>=0){if(i>0)e.lastNeed=i-2;return i}if(--n<r||i===-2)return 0;i=utf8CheckByte(t[n]);if(i>=0){if(i>0){if(i===2)i=0;else e.lastNeed=i-3}return i}return 0}function utf8CheckExtraBytes(e,t,r){if((t[0]&192)!==128){e.lastNeed=0;return\"\"}if(e.lastNeed>1&&t.length>1){if((t[1]&192)!==128){e.lastNeed=1;return\"\"}if(e.lastNeed>2&&t.length>2){if((t[2]&192)!==128){e.lastNeed=2;return\"\"}}}}function utf8FillLast(e){var t=this.lastTotal-this.lastNeed;var r=utf8CheckExtraBytes(this,e,t);if(r!==undefined)return r;if(this.lastNeed<=e.length){e.copy(this.lastChar,t,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal)}e.copy(this.lastChar,t,0,e.length);this.lastNeed-=e.length}function utf8Text(e,t){var r=utf8CheckIncomplete(this,e,t);if(!this.lastNeed)return e.toString(\"utf8\",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);e.copy(this.lastChar,0,n);return e.toString(\"utf8\",t,n)}function utf8End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed)return t+\"\";return t}function utf16Text(e,t){if((e.length-t)%2===0){var r=e.toString(\"utf16le\",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319){this.lastNeed=2;this.lastTotal=4;this.lastChar[0]=e[e.length-2];this.lastChar[1]=e[e.length-1];return r.slice(0,-1)}}return r}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=e[e.length-1];return e.toString(\"utf16le\",t,e.length-1)}function utf16End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString(\"utf16le\",0,r)}return t}function base64Text(e,t){var r=(e.length-t)%3;if(r===0)return e.toString(\"base64\",t);this.lastNeed=3-r;this.lastTotal=3;if(r===1){this.lastChar[0]=e[e.length-1]}else{this.lastChar[0]=e[e.length-2];this.lastChar[1]=e[e.length-1]}return e.toString(\"base64\",t,e.length-r)}function base64End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed)return t+this.lastChar.toString(\"base64\",0,3-this.lastNeed);return t}function simpleWrite(e){return e.toString(this.encoding)}function simpleEnd(e){return e&&e.length?this.write(e):\"\"}},769:function(e){e.exports=deprecate;function deprecate(e,t){if(config(\"noDeprecation\")){return e}var r=false;function deprecated(){if(!r){if(config(\"throwDeprecation\")){throw new Error(t)}else if(config(\"traceDeprecation\")){console.trace(t)}else{console.warn(t)}r=true}return e.apply(this,arguments)}return deprecated}function config(e){try{if(!__webpack_require__.g.localStorage)return false}catch(e){return false}var t=__webpack_require__.g.localStorage[e];if(null==t)return false;return String(t).toLowerCase()===\"true\"}},300:function(e){\"use strict\";e.exports=__webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")},361:function(e){\"use strict\";e.exports=__webpack_require__(/*! events */ \"(pages-dir-browser)/./node_modules/events/events.js\")},781:function(e){\"use strict\";e.exports=(__webpack_require__(/*! events */ \"(pages-dir-browser)/./node_modules/events/events.js\").EventEmitter)},837:function(e){\"use strict\";e.exports=__webpack_require__(/*! util */ \"(pages-dir-browser)/./node_modules/util/util.js\")}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var a=true;try{e[r](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(173);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLHNDQUFzQyxpQ0FBaUMsTUFBTSxXQUFXLHVDQUF1QyxhQUFhLDBEQUEwRCxJQUFJLEtBQUssaUNBQWlDLE1BQU0sV0FBVywwQkFBMEIsK0JBQStCLHlCQUF5Qiw2QkFBNkIsaUJBQWlCLGFBQWEsV0FBVyxnQ0FBZ0MsT0FBTyxRQUFRLDJCQUEyQix3QkFBd0IsU0FBUyxLQUFLLGlCQUFpQiwwQkFBMEIsbUJBQW1CLDBCQUEwQixnQ0FBZ0MsMkJBQTJCLGVBQWUsb0JBQW9CLHFCQUFxQixpQkFBaUIsd0JBQXdCLFFBQVEsZ0JBQWdCLEdBQUcsRUFBRSwwQkFBMEIsY0FBYyxlQUFlLGdCQUFnQixHQUFHLEVBQUUsTUFBTSxLQUFLLEtBQUssRUFBRSxLQUFLLFlBQVksR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLFlBQVksR0FBRyxFQUFFLFVBQVUsR0FBRywyQkFBMkIsMkNBQTJDLHlCQUF5Qiw4QkFBOEIsV0FBVyxxQ0FBcUMseUJBQXlCLHdCQUF3QixJQUFJLHdCQUF3QixhQUFhLEtBQUssNEJBQTRCLHVEQUF1RCx3REFBd0QsYUFBYSx3REFBd0QsTUFBTSw4Q0FBOEMsZ0JBQWdCLHdCQUF3QixLQUFLLFlBQVksTUFBTSw0QkFBNEIsU0FBUyxHQUFHLEVBQUUsR0FBRyxFQUFFLGdCQUFnQixFQUFFLEtBQUssOENBQThDLFVBQVUsRUFBRSxJQUFJLEdBQUcsRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUUsc0JBQXNCLFNBQVMsRUFBRSxTQUFTLGFBQWEsdUVBQXVFLDBEQUEwRCw0Q0FBNEMsR0FBRyxnRUFBZ0Usb0RBQW9ELHVEQUF1RCxHQUFHLDBFQUEwRSxzRUFBc0UsZ0VBQWdFLDBGQUEwRixvREFBb0QsNkJBQTZCLGFBQWEseUZBQXlGLGNBQWMscUJB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SSxxQkFBTSwyQkFBMkIsU0FBUyxhQUFhLE1BQU0scUJBQU0saUJBQWlCLHdCQUF3Qix5Q0FBeUMsaUJBQWlCLGFBQWEsVUFBVSxtQkFBTyxDQUFDLGtFQUFRLEVBQUUsaUJBQWlCLGFBQWEsVUFBVSxtQkFBTyxDQUFDLG1FQUFRLEVBQUUsaUJBQWlCLGFBQWEsVUFBVSx1R0FBOEIsQ0FBQyxpQkFBaUIsYUFBYSxVQUFVLG1CQUFPLENBQUMsNkRBQU0sSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHN0cmVhbS1icm93c2VyaWZ5XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NzgyOmZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBPYmplY3QuY3JlYXRlPT09XCJmdW5jdGlvblwiKXtlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoZSx0KXtpZih0KXtlLnN1cGVyXz10O2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19fWVsc2V7ZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGUsdCl7aWYodCl7ZS5zdXBlcl89dDt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT10LnByb3RvdHlwZTtlLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZX19fX0sNjQ2OmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2NvbnN0IHQ9e307ZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGUscixuKXtpZighbil7bj1FcnJvcn1mdW5jdGlvbiBnZXRNZXNzYWdlKGUsdCxuKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3JldHVybiByfWVsc2V7cmV0dXJuIHIoZSx0LG4pfX1jbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcihnZXRNZXNzYWdlKGUsdCxyKSl9fU5vZGVFcnJvci5wcm90b3R5cGUubmFtZT1uLm5hbWU7Tm9kZUVycm9yLnByb3RvdHlwZS5jb2RlPWU7dFtlXT1Ob2RlRXJyb3J9ZnVuY3Rpb24gb25lT2YoZSx0KXtpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCByPWUubGVuZ3RoO2U9ZS5tYXAoKGU9PlN0cmluZyhlKSkpO2lmKHI+Mil7cmV0dXJuYG9uZSBvZiAke3R9ICR7ZS5zbGljZSgwLHItMSkuam9pbihcIiwgXCIpfSwgb3IgYCtlW3ItMV19ZWxzZSBpZihyPT09Mil7cmV0dXJuYG9uZSBvZiAke3R9ICR7ZVswXX0gb3IgJHtlWzFdfWB9ZWxzZXtyZXR1cm5gb2YgJHt0fSAke2VbMF19YH19ZWxzZXtyZXR1cm5gb2YgJHt0fSAke1N0cmluZyhlKX1gfX1mdW5jdGlvbiBzdGFydHNXaXRoKGUsdCxyKXtyZXR1cm4gZS5zdWJzdHIoIXJ8fHI8MD8wOityLHQubGVuZ3RoKT09PXR9ZnVuY3Rpb24gZW5kc1dpdGgoZSx0LHIpe2lmKHI9PT11bmRlZmluZWR8fHI+ZS5sZW5ndGgpe3I9ZS5sZW5ndGh9cmV0dXJuIGUuc3Vic3RyaW5nKHItdC5sZW5ndGgscik9PT10fWZ1bmN0aW9uIGluY2x1ZGVzKGUsdCxyKXtpZih0eXBlb2YgciE9PVwibnVtYmVyXCIpe3I9MH1pZihyK3QubGVuZ3RoPmUubGVuZ3RoKXtyZXR1cm4gZmFsc2V9ZWxzZXtyZXR1cm4gZS5pbmRleE9mKHQscikhPT0tMX19Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX0lOVkFMSURfT1BUX1ZBTFVFXCIsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuJ1RoZSB2YWx1ZSBcIicrdCsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJytlKydcIid9KSxUeXBlRXJyb3IpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsKGZ1bmN0aW9uKGUsdCxyKXtsZXQgbjtpZih0eXBlb2YgdD09PVwic3RyaW5nXCImJnN0YXJ0c1dpdGgodCxcIm5vdCBcIikpe249XCJtdXN0IG5vdCBiZVwiO3Q9dC5yZXBsYWNlKC9ebm90IC8sXCJcIil9ZWxzZXtuPVwibXVzdCBiZVwifWxldCBpO2lmKGVuZHNXaXRoKGUsXCIgYXJndW1lbnRcIikpe2k9YFRoZSAke2V9ICR7bn0gJHtvbmVPZih0LFwidHlwZVwiKX1gfWVsc2V7Y29uc3Qgcj1pbmNsdWRlcyhlLFwiLlwiKT9cInByb3BlcnR5XCI6XCJhcmd1bWVudFwiO2k9YFRoZSBcIiR7ZX1cIiAke3J9ICR7bn0gJHtvbmVPZih0LFwidHlwZVwiKX1gfWkrPWAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2Ygcn1gO3JldHVybiBpfSksVHlwZUVycm9yKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GXCIsXCJzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRlwiKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRFwiLChmdW5jdGlvbihlKXtyZXR1cm5cIlRoZSBcIitlK1wiIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWRcIn0pKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVwiLFwiUHJlbWF0dXJlIGNsb3NlXCIpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fREVTVFJPWUVEXCIsKGZ1bmN0aW9uKGUpe3JldHVyblwiQ2Fubm90IGNhbGwgXCIrZStcIiBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkXCJ9KSk7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX01VTFRJUExFX0NBTExCQUNLXCIsXCJDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXNcIik7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9DQU5OT1RfUElQRVwiLFwiQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZVwiKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORFwiLFwid3JpdGUgYWZ0ZXIgZW5kXCIpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fTlVMTF9WQUxVRVNcIixcIk1heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtXCIsVHlwZUVycm9yKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfVU5LTk9XTl9FTkNPRElOR1wiLChmdW5jdGlvbihlKXtyZXR1cm5cIlVua25vd24gZW5jb2Rpbmc6IFwiK2V9KSxUeXBlRXJyb3IpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlRcIixcInN0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50XCIpO2UuZXhwb3J0cy5xPXR9LDQwMzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgciBpbiBlKXt0LnB1c2gocil9cmV0dXJuIHR9O2UuZXhwb3J0cz1EdXBsZXg7dmFyIGk9cig3MDkpO3ZhciBhPXIoMzM3KTtyKDc4MikoRHVwbGV4LGkpO3t2YXIgbz1uKGEucHJvdG90eXBlKTtmb3IodmFyIHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGY9b1tzXTtpZighRHVwbGV4LnByb3RvdHlwZVtmXSlEdXBsZXgucHJvdG90eXBlW2ZdPWEucHJvdG90eXBlW2ZdfX1mdW5jdGlvbiBEdXBsZXgoZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlyZXR1cm4gbmV3IER1cGxleChlKTtpLmNhbGwodGhpcyxlKTthLmNhbGwodGhpcyxlKTt0aGlzLmFsbG93SGFsZk9wZW49dHJ1ZTtpZihlKXtpZihlLnJlYWRhYmxlPT09ZmFsc2UpdGhpcy5yZWFkYWJsZT1mYWxzZTtpZihlLndyaXRhYmxlPT09ZmFsc2UpdGhpcy53cml0YWJsZT1mYWxzZTtpZihlLmFsbG93SGFsZk9wZW49PT1mYWxzZSl7dGhpcy5hbGxvd0hhbGZPcGVuPWZhbHNlO3RoaXMub25jZShcImVuZFwiLG9uZW5kKX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsXCJ3cml0YWJsZUJ1ZmZlclwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSxcIndyaXRhYmxlTGVuZ3RoXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aH19KTtmdW5jdGlvbiBvbmVuZCgpe2lmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpcmV0dXJuO3Byb2Nlc3MubmV4dFRpY2sob25FbmROVCx0aGlzKX1mdW5jdGlvbiBvbkVuZE5UKGUpe2UuZW5kKCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYodGhpcy5fcmVhZGFibGVTdGF0ZT09PXVuZGVmaW5lZHx8dGhpcy5fd3JpdGFibGVTdGF0ZT09PXVuZGVmaW5lZCl7cmV0dXJuIGZhbHNlfXJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbiBzZXQoZSl7aWYodGhpcy5fcmVhZGFibGVTdGF0ZT09PXVuZGVmaW5lZHx8dGhpcy5fd3JpdGFibGVTdGF0ZT09PXVuZGVmaW5lZCl7cmV0dXJufXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPWU7dGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZX19KX0sODg5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9UGFzc1Rocm91Z2g7dmFyIG49cigxNzApO3IoNzgyKShQYXNzVGhyb3VnaCxuKTtmdW5jdGlvbiBQYXNzVGhyb3VnaChlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChlKTtuLmNhbGwodGhpcyxlKX1QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbihlLHQscil7cihudWxsLGUpfX0sNzA5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9UmVhZGFibGU7dmFyIG47UmVhZGFibGUuUmVhZGFibGVTdGF0ZT1SZWFkYWJsZVN0YXRlO3ZhciBpPXIoMzYxKS5FdmVudEVtaXR0ZXI7dmFyIGE9ZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGUsdCl7cmV0dXJuIGUubGlzdGVuZXJzKHQpLmxlbmd0aH07dmFyIG89cig2NzgpO3ZhciBzPXIoMzAwKS5CdWZmZXI7dmFyIGY9Z2xvYmFsLlVpbnQ4QXJyYXl8fGZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGUpe3JldHVybiBzLmZyb20oZSl9ZnVuY3Rpb24gX2lzVWludDhBcnJheShlKXtyZXR1cm4gcy5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIGZ9dmFyIGw9cig4MzcpO3ZhciB1O2lmKGwmJmwuZGVidWdsb2cpe3U9bC5kZWJ1Z2xvZyhcInN0cmVhbVwiKX1lbHNle3U9ZnVuY3Rpb24gZGVidWcoKXt9fXZhciBkPXIoMzc5KTt2YXIgYz1yKDI1KTt2YXIgaD1yKDc3NikscD1oLmdldEhpZ2hXYXRlck1hcms7dmFyIGI9cig2NDYpLnEsZz1iLkVSUl9JTlZBTElEX0FSR19UWVBFLHk9Yi5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLF89Yi5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCx2PWIuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDt2YXIgdzt2YXIgbTt2YXIgUztyKDc4MikoUmVhZGFibGUsbyk7dmFyIFI9Yy5lcnJvck9yRGVzdHJveTt2YXIgRT1bXCJlcnJvclwiLFwiY2xvc2VcIixcImRlc3Ryb3lcIixcInBhdXNlXCIsXCJyZXN1bWVcIl07ZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGUsdCxyKXtpZih0eXBlb2YgZS5wcmVwZW5kTGlzdGVuZXI9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIGUucHJlcGVuZExpc3RlbmVyKHQscik7aWYoIWUuX2V2ZW50c3x8IWUuX2V2ZW50c1t0XSllLm9uKHQscik7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUuX2V2ZW50c1t0XSkpZS5fZXZlbnRzW3RdLnVuc2hpZnQocik7ZWxzZSBlLl9ldmVudHNbdF09W3IsZS5fZXZlbnRzW3RdXX1mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKGUsdCxpKXtuPW58fHIoNDAzKTtlPWV8fHt9O2lmKHR5cGVvZiBpIT09XCJib29sZWFuXCIpaT10IGluc3RhbmNlb2Ygbjt0aGlzLm9iamVjdE1vZGU9ISFlLm9iamVjdE1vZGU7aWYoaSl0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIWUucmVhZGFibGVPYmplY3RNb2RlO3RoaXMuaGlnaFdhdGVyTWFyaz1wKHRoaXMsZSxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLGkpO3RoaXMuYnVmZmVyPW5ldyBkO3RoaXMubGVuZ3RoPTA7dGhpcy5waXBlcz1udWxsO3RoaXMucGlwZXNDb3VudD0wO3RoaXMuZmxvd2luZz1udWxsO3RoaXMuZW5kZWQ9ZmFsc2U7dGhpcy5lbmRFbWl0dGVkPWZhbHNlO3RoaXMucmVhZGluZz1mYWxzZTt0aGlzLnN5bmM9dHJ1ZTt0aGlzLm5lZWRSZWFkYWJsZT1mYWxzZTt0aGlzLmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTt0aGlzLnJlYWRhYmxlTGlzdGVuaW5nPWZhbHNlO3RoaXMucmVzdW1lU2NoZWR1bGVkPWZhbHNlO3RoaXMucGF1c2VkPXRydWU7dGhpcy5lbWl0Q2xvc2U9ZS5lbWl0Q2xvc2UhPT1mYWxzZTt0aGlzLmF1dG9EZXN0cm95PSEhZS5hdXRvRGVzdHJveTt0aGlzLmRlc3Ryb3llZD1mYWxzZTt0aGlzLmRlZmF1bHRFbmNvZGluZz1lLmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCI7dGhpcy5hd2FpdERyYWluPTA7dGhpcy5yZWFkaW5nTW9yZT1mYWxzZTt0aGlzLmRlY29kZXI9bnVsbDt0aGlzLmVuY29kaW5nPW51bGw7aWYoZS5lbmNvZGluZyl7aWYoIXcpdz1yKDcwNCkuczt0aGlzLmRlY29kZXI9bmV3IHcoZS5lbmNvZGluZyk7dGhpcy5lbmNvZGluZz1lLmVuY29kaW5nfX1mdW5jdGlvbiBSZWFkYWJsZShlKXtuPW58fHIoNDAzKTtpZighKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpcmV0dXJuIG5ldyBSZWFkYWJsZShlKTt2YXIgdD10aGlzIGluc3RhbmNlb2Ygbjt0aGlzLl9yZWFkYWJsZVN0YXRlPW5ldyBSZWFkYWJsZVN0YXRlKGUsdGhpcyx0KTt0aGlzLnJlYWRhYmxlPXRydWU7aWYoZSl7aWYodHlwZW9mIGUucmVhZD09PVwiZnVuY3Rpb25cIil0aGlzLl9yZWFkPWUucmVhZDtpZih0eXBlb2YgZS5kZXN0cm95PT09XCJmdW5jdGlvblwiKXRoaXMuX2Rlc3Ryb3k9ZS5kZXN0cm95fW8uY2FsbCh0aGlzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe2lmKHRoaXMuX3JlYWRhYmxlU3RhdGU9PT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbiBzZXQoZSl7aWYoIXRoaXMuX3JlYWRhYmxlU3RhdGUpe3JldHVybn10aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD1lfX0pO1JlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95PWMuZGVzdHJveTtSZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveT1jLnVuZGVzdHJveTtSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfTtSZWFkYWJsZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuX3JlYWRhYmxlU3RhdGU7dmFyIG47aWYoIXIub2JqZWN0TW9kZSl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXt0PXR8fHIuZGVmYXVsdEVuY29kaW5nO2lmKHQhPT1yLmVuY29kaW5nKXtlPXMuZnJvbShlLHQpO3Q9XCJcIn1uPXRydWV9fWVsc2V7bj10cnVlfXJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsZSx0LGZhbHNlLG4pfTtSZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLGUsbnVsbCx0cnVlLGZhbHNlKX07ZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhlLHQscixuLGkpe3UoXCJyZWFkYWJsZUFkZENodW5rXCIsdCk7dmFyIGE9ZS5fcmVhZGFibGVTdGF0ZTtpZih0PT09bnVsbCl7YS5yZWFkaW5nPWZhbHNlO29uRW9mQ2h1bmsoZSxhKX1lbHNle3ZhciBvO2lmKCFpKW89Y2h1bmtJbnZhbGlkKGEsdCk7aWYobyl7UihlLG8pfWVsc2UgaWYoYS5vYmplY3RNb2RlfHx0JiZ0Lmxlbmd0aD4wKXtpZih0eXBlb2YgdCE9PVwic3RyaW5nXCImJiFhLm9iamVjdE1vZGUmJk9iamVjdC5nZXRQcm90b3R5cGVPZih0KSE9PXMucHJvdG90eXBlKXt0PV91aW50OEFycmF5VG9CdWZmZXIodCl9aWYobil7aWYoYS5lbmRFbWl0dGVkKVIoZSxuZXcgdik7ZWxzZSBhZGRDaHVuayhlLGEsdCx0cnVlKX1lbHNlIGlmKGEuZW5kZWQpe1IoZSxuZXcgeSl9ZWxzZSBpZihhLmRlc3Ryb3llZCl7cmV0dXJuIGZhbHNlfWVsc2V7YS5yZWFkaW5nPWZhbHNlO2lmKGEuZGVjb2RlciYmIXIpe3Q9YS5kZWNvZGVyLndyaXRlKHQpO2lmKGEub2JqZWN0TW9kZXx8dC5sZW5ndGghPT0wKWFkZENodW5rKGUsYSx0LGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoZSxhKX1lbHNle2FkZENodW5rKGUsYSx0LGZhbHNlKX19fWVsc2UgaWYoIW4pe2EucmVhZGluZz1mYWxzZTttYXliZVJlYWRNb3JlKGUsYSl9fXJldHVybiFhLmVuZGVkJiYoYS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrfHxhLmxlbmd0aD09PTApfWZ1bmN0aW9uIGFkZENodW5rKGUsdCxyLG4pe2lmKHQuZmxvd2luZyYmdC5sZW5ndGg9PT0wJiYhdC5zeW5jKXt0LmF3YWl0RHJhaW49MDtlLmVtaXQoXCJkYXRhXCIscil9ZWxzZXt0Lmxlbmd0aCs9dC5vYmplY3RNb2RlPzE6ci5sZW5ndGg7aWYobil0LmJ1ZmZlci51bnNoaWZ0KHIpO2Vsc2UgdC5idWZmZXIucHVzaChyKTtpZih0Lm5lZWRSZWFkYWJsZSllbWl0UmVhZGFibGUoZSl9bWF5YmVSZWFkTW9yZShlLHQpfWZ1bmN0aW9uIGNodW5rSW52YWxpZChlLHQpe3ZhciByO2lmKCFfaXNVaW50OEFycmF5KHQpJiZ0eXBlb2YgdCE9PVwic3RyaW5nXCImJnQhPT11bmRlZmluZWQmJiFlLm9iamVjdE1vZGUpe3I9bmV3IGcoXCJjaHVua1wiLFtcInN0cmluZ1wiLFwiQnVmZmVyXCIsXCJVaW50OEFycmF5XCJdLHQpfXJldHVybiByfVJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9PT1mYWxzZX07UmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nPWZ1bmN0aW9uKGUpe2lmKCF3KXc9cig3MDQpLnM7dmFyIHQ9bmV3IHcoZSk7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyPXQ7dGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZz10aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7dmFyIG49dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDt2YXIgaT1cIlwiO3doaWxlKG4hPT1udWxsKXtpKz10LndyaXRlKG4uZGF0YSk7bj1uLm5leHR9dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtpZihpIT09XCJcIil0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGkpO3RoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoPWkubGVuZ3RoO3JldHVybiB0aGlzfTt2YXIgVD0xMDczNzQxODI0O2Z1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKGUpe2lmKGU+PVQpe2U9VH1lbHNle2UtLTtlfD1lPj4+MTtlfD1lPj4+MjtlfD1lPj4+NDtlfD1lPj4+ODtlfD1lPj4+MTY7ZSsrfXJldHVybiBlfWZ1bmN0aW9uIGhvd011Y2hUb1JlYWQoZSx0KXtpZihlPD0wfHx0Lmxlbmd0aD09PTAmJnQuZW5kZWQpcmV0dXJuIDA7aWYodC5vYmplY3RNb2RlKXJldHVybiAxO2lmKGUhPT1lKXtpZih0LmZsb3dpbmcmJnQubGVuZ3RoKXJldHVybiB0LmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHQubGVuZ3RofWlmKGU+dC5oaWdoV2F0ZXJNYXJrKXQuaGlnaFdhdGVyTWFyaz1jb21wdXRlTmV3SGlnaFdhdGVyTWFyayhlKTtpZihlPD10Lmxlbmd0aClyZXR1cm4gZTtpZighdC5lbmRlZCl7dC5uZWVkUmVhZGFibGU9dHJ1ZTtyZXR1cm4gMH1yZXR1cm4gdC5sZW5ndGh9UmVhZGFibGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oZSl7dShcInJlYWRcIixlKTtlPXBhcnNlSW50KGUsMTApO3ZhciB0PXRoaXMuX3JlYWRhYmxlU3RhdGU7dmFyIHI9ZTtpZihlIT09MCl0LmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTtpZihlPT09MCYmdC5uZWVkUmVhZGFibGUmJigodC5oaWdoV2F0ZXJNYXJrIT09MD90Lmxlbmd0aD49dC5oaWdoV2F0ZXJNYXJrOnQubGVuZ3RoPjApfHx0LmVuZGVkKSl7dShcInJlYWQ6IGVtaXRSZWFkYWJsZVwiLHQubGVuZ3RoLHQuZW5kZWQpO2lmKHQubGVuZ3RoPT09MCYmdC5lbmRlZCllbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtyZXR1cm4gbnVsbH1lPWhvd011Y2hUb1JlYWQoZSx0KTtpZihlPT09MCYmdC5lbmRlZCl7aWYodC5sZW5ndGg9PT0wKWVuZFJlYWRhYmxlKHRoaXMpO3JldHVybiBudWxsfXZhciBuPXQubmVlZFJlYWRhYmxlO3UoXCJuZWVkIHJlYWRhYmxlXCIsbik7aWYodC5sZW5ndGg9PT0wfHx0Lmxlbmd0aC1lPHQuaGlnaFdhdGVyTWFyayl7bj10cnVlO3UoXCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFya1wiLG4pfWlmKHQuZW5kZWR8fHQucmVhZGluZyl7bj1mYWxzZTt1KFwicmVhZGluZyBvciBlbmRlZFwiLG4pfWVsc2UgaWYobil7dShcImRvIHJlYWRcIik7dC5yZWFkaW5nPXRydWU7dC5zeW5jPXRydWU7aWYodC5sZW5ndGg9PT0wKXQubmVlZFJlYWRhYmxlPXRydWU7dGhpcy5fcmVhZCh0LmhpZ2hXYXRlck1hcmspO3Quc3luYz1mYWxzZTtpZighdC5yZWFkaW5nKWU9aG93TXVjaFRvUmVhZChyLHQpfXZhciBpO2lmKGU+MClpPWZyb21MaXN0KGUsdCk7ZWxzZSBpPW51bGw7aWYoaT09PW51bGwpe3QubmVlZFJlYWRhYmxlPXQubGVuZ3RoPD10LmhpZ2hXYXRlck1hcms7ZT0wfWVsc2V7dC5sZW5ndGgtPWU7dC5hd2FpdERyYWluPTB9aWYodC5sZW5ndGg9PT0wKXtpZighdC5lbmRlZCl0Lm5lZWRSZWFkYWJsZT10cnVlO2lmKHIhPT1lJiZ0LmVuZGVkKWVuZFJlYWRhYmxlKHRoaXMpfWlmKGkhPT1udWxsKXRoaXMuZW1pdChcImRhdGFcIixpKTtyZXR1cm4gaX07ZnVuY3Rpb24gb25Fb2ZDaHVuayhlLHQpe3UoXCJvbkVvZkNodW5rXCIpO2lmKHQuZW5kZWQpcmV0dXJuO2lmKHQuZGVjb2Rlcil7dmFyIHI9dC5kZWNvZGVyLmVuZCgpO2lmKHImJnIubGVuZ3RoKXt0LmJ1ZmZlci5wdXNoKHIpO3QubGVuZ3RoKz10Lm9iamVjdE1vZGU/MTpyLmxlbmd0aH19dC5lbmRlZD10cnVlO2lmKHQuc3luYyl7ZW1pdFJlYWRhYmxlKGUpfWVsc2V7dC5uZWVkUmVhZGFibGU9ZmFsc2U7aWYoIXQuZW1pdHRlZFJlYWRhYmxlKXt0LmVtaXR0ZWRSZWFkYWJsZT10cnVlO2VtaXRSZWFkYWJsZV8oZSl9fX1mdW5jdGlvbiBlbWl0UmVhZGFibGUoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZW1pdFJlYWRhYmxlXCIsdC5uZWVkUmVhZGFibGUsdC5lbWl0dGVkUmVhZGFibGUpO3QubmVlZFJlYWRhYmxlPWZhbHNlO2lmKCF0LmVtaXR0ZWRSZWFkYWJsZSl7dShcImVtaXRSZWFkYWJsZVwiLHQuZmxvd2luZyk7dC5lbWl0dGVkUmVhZGFibGU9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sZSl9fWZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZW1pdFJlYWRhYmxlX1wiLHQuZGVzdHJveWVkLHQubGVuZ3RoLHQuZW5kZWQpO2lmKCF0LmRlc3Ryb3llZCYmKHQubGVuZ3RofHx0LmVuZGVkKSl7ZS5lbWl0KFwicmVhZGFibGVcIik7dC5lbWl0dGVkUmVhZGFibGU9ZmFsc2V9dC5uZWVkUmVhZGFibGU9IXQuZmxvd2luZyYmIXQuZW5kZWQmJnQubGVuZ3RoPD10LmhpZ2hXYXRlck1hcms7ZmxvdyhlKX1mdW5jdGlvbiBtYXliZVJlYWRNb3JlKGUsdCl7aWYoIXQucmVhZGluZ01vcmUpe3QucmVhZGluZ01vcmU9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLGUsdCl9fWZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKGUsdCl7d2hpbGUoIXQucmVhZGluZyYmIXQuZW5kZWQmJih0Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcmt8fHQuZmxvd2luZyYmdC5sZW5ndGg9PT0wKSl7dmFyIHI9dC5sZW5ndGg7dShcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpO2UucmVhZCgwKTtpZihyPT09dC5sZW5ndGgpYnJlYWt9dC5yZWFkaW5nTW9yZT1mYWxzZX1SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oZSl7Uih0aGlzLG5ldyBfKFwiX3JlYWQoKVwiKSl9O1JlYWRhYmxlLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpczt2YXIgbj10aGlzLl9yZWFkYWJsZVN0YXRlO3N3aXRjaChuLnBpcGVzQ291bnQpe2Nhc2UgMDpuLnBpcGVzPWU7YnJlYWs7Y2FzZSAxOm4ucGlwZXM9W24ucGlwZXMsZV07YnJlYWs7ZGVmYXVsdDpuLnBpcGVzLnB1c2goZSk7YnJlYWt9bi5waXBlc0NvdW50Kz0xO3UoXCJwaXBlIGNvdW50PSVkIG9wdHM9JWpcIixuLnBpcGVzQ291bnQsdCk7dmFyIGk9KCF0fHx0LmVuZCE9PWZhbHNlKSYmZSE9PXByb2Nlc3Muc3Rkb3V0JiZlIT09cHJvY2Vzcy5zdGRlcnI7dmFyIG89aT9vbmVuZDp1bnBpcGU7aWYobi5lbmRFbWl0dGVkKXByb2Nlc3MubmV4dFRpY2sobyk7ZWxzZSByLm9uY2UoXCJlbmRcIixvKTtlLm9uKFwidW5waXBlXCIsb251bnBpcGUpO2Z1bmN0aW9uIG9udW5waXBlKGUsdCl7dShcIm9udW5waXBlXCIpO2lmKGU9PT1yKXtpZih0JiZ0Lmhhc1VucGlwZWQ9PT1mYWxzZSl7dC5oYXNVbnBpcGVkPXRydWU7Y2xlYW51cCgpfX19ZnVuY3Rpb24gb25lbmQoKXt1KFwib25lbmRcIik7ZS5lbmQoKX12YXIgcz1waXBlT25EcmFpbihyKTtlLm9uKFwiZHJhaW5cIixzKTt2YXIgZj1mYWxzZTtmdW5jdGlvbiBjbGVhbnVwKCl7dShcImNsZWFudXBcIik7ZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsb25jbG9zZSk7ZS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLG9uZmluaXNoKTtlLnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixzKTtlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixvbmVycm9yKTtlLnJlbW92ZUxpc3RlbmVyKFwidW5waXBlXCIsb251bnBpcGUpO3IucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixvbmVuZCk7ci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLHVucGlwZSk7ci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixvbmRhdGEpO2Y9dHJ1ZTtpZihuLmF3YWl0RHJhaW4mJighZS5fd3JpdGFibGVTdGF0ZXx8ZS5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKXMoKX1yLm9uKFwiZGF0YVwiLG9uZGF0YSk7ZnVuY3Rpb24gb25kYXRhKHQpe3UoXCJvbmRhdGFcIik7dmFyIGk9ZS53cml0ZSh0KTt1KFwiZGVzdC53cml0ZVwiLGkpO2lmKGk9PT1mYWxzZSl7aWYoKG4ucGlwZXNDb3VudD09PTEmJm4ucGlwZXM9PT1lfHxuLnBpcGVzQ291bnQ+MSYmaW5kZXhPZihuLnBpcGVzLGUpIT09LTEpJiYhZil7dShcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLG4uYXdhaXREcmFpbik7bi5hd2FpdERyYWluKyt9ci5wYXVzZSgpfX1mdW5jdGlvbiBvbmVycm9yKHQpe3UoXCJvbmVycm9yXCIsdCk7dW5waXBlKCk7ZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsb25lcnJvcik7aWYoYShlLFwiZXJyb3JcIik9PT0wKVIoZSx0KX1wcmVwZW5kTGlzdGVuZXIoZSxcImVycm9yXCIsb25lcnJvcik7ZnVuY3Rpb24gb25jbG9zZSgpe2UucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixvbmZpbmlzaCk7dW5waXBlKCl9ZS5vbmNlKFwiY2xvc2VcIixvbmNsb3NlKTtmdW5jdGlvbiBvbmZpbmlzaCgpe3UoXCJvbmZpbmlzaFwiKTtlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixvbmNsb3NlKTt1bnBpcGUoKX1lLm9uY2UoXCJmaW5pc2hcIixvbmZpbmlzaCk7ZnVuY3Rpb24gdW5waXBlKCl7dShcInVucGlwZVwiKTtyLnVucGlwZShlKX1lLmVtaXQoXCJwaXBlXCIscik7aWYoIW4uZmxvd2luZyl7dShcInBpcGUgcmVzdW1lXCIpO3IucmVzdW1lKCl9cmV0dXJuIGV9O2Z1bmN0aW9uIHBpcGVPbkRyYWluKGUpe3JldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwicGlwZU9uRHJhaW5cIix0LmF3YWl0RHJhaW4pO2lmKHQuYXdhaXREcmFpbil0LmF3YWl0RHJhaW4tLTtpZih0LmF3YWl0RHJhaW49PT0wJiZhKGUsXCJkYXRhXCIpKXt0LmZsb3dpbmc9dHJ1ZTtmbG93KGUpfX19UmVhZGFibGUucHJvdG90eXBlLnVucGlwZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlO3ZhciByPXtoYXNVbnBpcGVkOmZhbHNlfTtpZih0LnBpcGVzQ291bnQ9PT0wKXJldHVybiB0aGlzO2lmKHQucGlwZXNDb3VudD09PTEpe2lmKGUmJmUhPT10LnBpcGVzKXJldHVybiB0aGlzO2lmKCFlKWU9dC5waXBlczt0LnBpcGVzPW51bGw7dC5waXBlc0NvdW50PTA7dC5mbG93aW5nPWZhbHNlO2lmKGUpZS5lbWl0KFwidW5waXBlXCIsdGhpcyxyKTtyZXR1cm4gdGhpc31pZighZSl7dmFyIG49dC5waXBlczt2YXIgaT10LnBpcGVzQ291bnQ7dC5waXBlcz1udWxsO3QucGlwZXNDb3VudD0wO3QuZmxvd2luZz1mYWxzZTtmb3IodmFyIGE9MDthPGk7YSsrKXtuW2FdLmVtaXQoXCJ1bnBpcGVcIix0aGlzLHtoYXNVbnBpcGVkOmZhbHNlfSl9cmV0dXJuIHRoaXN9dmFyIG89aW5kZXhPZih0LnBpcGVzLGUpO2lmKG89PT0tMSlyZXR1cm4gdGhpczt0LnBpcGVzLnNwbGljZShvLDEpO3QucGlwZXNDb3VudC09MTtpZih0LnBpcGVzQ291bnQ9PT0xKXQucGlwZXM9dC5waXBlc1swXTtlLmVtaXQoXCJ1bnBpcGVcIix0aGlzLHIpO3JldHVybiB0aGlzfTtSZWFkYWJsZS5wcm90b3R5cGUub249ZnVuY3Rpb24oZSx0KXt2YXIgcj1vLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsZSx0KTt2YXIgbj10aGlzLl9yZWFkYWJsZVN0YXRlO2lmKGU9PT1cImRhdGFcIil7bi5yZWFkYWJsZUxpc3RlbmluZz10aGlzLmxpc3RlbmVyQ291bnQoXCJyZWFkYWJsZVwiKT4wO2lmKG4uZmxvd2luZyE9PWZhbHNlKXRoaXMucmVzdW1lKCl9ZWxzZSBpZihlPT09XCJyZWFkYWJsZVwiKXtpZighbi5lbmRFbWl0dGVkJiYhbi5yZWFkYWJsZUxpc3RlbmluZyl7bi5yZWFkYWJsZUxpc3RlbmluZz1uLm5lZWRSZWFkYWJsZT10cnVlO24uZmxvd2luZz1mYWxzZTtuLmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTt1KFwib24gcmVhZGFibGVcIixuLmxlbmd0aCxuLnJlYWRpbmcpO2lmKG4ubGVuZ3RoKXtlbWl0UmVhZGFibGUodGhpcyl9ZWxzZSBpZighbi5yZWFkaW5nKXtwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssdGhpcyl9fX1yZXR1cm4gcn07UmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyPVJlYWRhYmxlLnByb3RvdHlwZS5vbjtSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj1vLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsZSx0KTtpZihlPT09XCJyZWFkYWJsZVwiKXtwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLHRoaXMpfXJldHVybiByfTtSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0PW8ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoZT09PVwicmVhZGFibGVcInx8ZT09PXVuZGVmaW5lZCl7cHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyx0aGlzKX1yZXR1cm4gdH07ZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt0LnJlYWRhYmxlTGlzdGVuaW5nPWUubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpPjA7aWYodC5yZXN1bWVTY2hlZHVsZWQmJiF0LnBhdXNlZCl7dC5mbG93aW5nPXRydWV9ZWxzZSBpZihlLmxpc3RlbmVyQ291bnQoXCJkYXRhXCIpPjApe2UucmVzdW1lKCl9fWZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soZSl7dShcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKTtlLnJlYWQoMCl9UmVhZGFibGUucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3JlYWRhYmxlU3RhdGU7aWYoIWUuZmxvd2luZyl7dShcInJlc3VtZVwiKTtlLmZsb3dpbmc9IWUucmVhZGFibGVMaXN0ZW5pbmc7cmVzdW1lKHRoaXMsZSl9ZS5wYXVzZWQ9ZmFsc2U7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIHJlc3VtZShlLHQpe2lmKCF0LnJlc3VtZVNjaGVkdWxlZCl7dC5yZXN1bWVTY2hlZHVsZWQ9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sZSx0KX19ZnVuY3Rpb24gcmVzdW1lXyhlLHQpe3UoXCJyZXN1bWVcIix0LnJlYWRpbmcpO2lmKCF0LnJlYWRpbmcpe2UucmVhZCgwKX10LnJlc3VtZVNjaGVkdWxlZD1mYWxzZTtlLmVtaXQoXCJyZXN1bWVcIik7ZmxvdyhlKTtpZih0LmZsb3dpbmcmJiF0LnJlYWRpbmcpZS5yZWFkKDApfVJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3UoXCJjYWxsIHBhdXNlIGZsb3dpbmc9JWpcIix0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO2lmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyE9PWZhbHNlKXt1KFwicGF1c2VcIik7dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nPWZhbHNlO3RoaXMuZW1pdChcInBhdXNlXCIpfXRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkPXRydWU7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGZsb3coZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZmxvd1wiLHQuZmxvd2luZyk7d2hpbGUodC5mbG93aW5nJiZlLnJlYWQoKSE9PW51bGwpe319UmVhZGFibGUucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt2YXIgcj10aGlzLl9yZWFkYWJsZVN0YXRlO3ZhciBuPWZhbHNlO2Uub24oXCJlbmRcIiwoZnVuY3Rpb24oKXt1KFwid3JhcHBlZCBlbmRcIik7aWYoci5kZWNvZGVyJiYhci5lbmRlZCl7dmFyIGU9ci5kZWNvZGVyLmVuZCgpO2lmKGUmJmUubGVuZ3RoKXQucHVzaChlKX10LnB1c2gobnVsbCl9KSk7ZS5vbihcImRhdGFcIiwoZnVuY3Rpb24oaSl7dShcIndyYXBwZWQgZGF0YVwiKTtpZihyLmRlY29kZXIpaT1yLmRlY29kZXIud3JpdGUoaSk7aWYoci5vYmplY3RNb2RlJiYoaT09PW51bGx8fGk9PT11bmRlZmluZWQpKXJldHVybjtlbHNlIGlmKCFyLm9iamVjdE1vZGUmJighaXx8IWkubGVuZ3RoKSlyZXR1cm47dmFyIGE9dC5wdXNoKGkpO2lmKCFhKXtuPXRydWU7ZS5wYXVzZSgpfX0pKTtmb3IodmFyIGkgaW4gZSl7aWYodGhpc1tpXT09PXVuZGVmaW5lZCYmdHlwZW9mIGVbaV09PT1cImZ1bmN0aW9uXCIpe3RoaXNbaV09ZnVuY3Rpb24gbWV0aG9kV3JhcCh0KXtyZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCl7cmV0dXJuIGVbdF0uYXBwbHkoZSxhcmd1bWVudHMpfX0oaSl9fWZvcih2YXIgYT0wO2E8RS5sZW5ndGg7YSsrKXtlLm9uKEVbYV0sdGhpcy5lbWl0LmJpbmQodGhpcyxFW2FdKSl9dGhpcy5fcmVhZD1mdW5jdGlvbih0KXt1KFwid3JhcHBlZCBfcmVhZFwiLHQpO2lmKG4pe249ZmFsc2U7ZS5yZXN1bWUoKX19O3JldHVybiB0aGlzfTtpZih0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiKXtSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7aWYobT09PXVuZGVmaW5lZCl7bT1yKDg3MSl9cmV0dXJuIG0odGhpcyl9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLFwicmVhZGFibGVCdWZmZXJcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUZsb3dpbmdcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZ30sc2V0OmZ1bmN0aW9uIHNldChlKXtpZih0aGlzLl9yZWFkYWJsZVN0YXRlKXt0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9ZX19fSk7UmVhZGFibGUuX2Zyb21MaXN0PWZyb21MaXN0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGh9fSk7ZnVuY3Rpb24gZnJvbUxpc3QoZSx0KXtpZih0Lmxlbmd0aD09PTApcmV0dXJuIG51bGw7dmFyIHI7aWYodC5vYmplY3RNb2RlKXI9dC5idWZmZXIuc2hpZnQoKTtlbHNlIGlmKCFlfHxlPj10Lmxlbmd0aCl7aWYodC5kZWNvZGVyKXI9dC5idWZmZXIuam9pbihcIlwiKTtlbHNlIGlmKHQuYnVmZmVyLmxlbmd0aD09PTEpcj10LmJ1ZmZlci5maXJzdCgpO2Vsc2Ugcj10LmJ1ZmZlci5jb25jYXQodC5sZW5ndGgpO3QuYnVmZmVyLmNsZWFyKCl9ZWxzZXtyPXQuYnVmZmVyLmNvbnN1bWUoZSx0LmRlY29kZXIpfXJldHVybiByfWZ1bmN0aW9uIGVuZFJlYWRhYmxlKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7dShcImVuZFJlYWRhYmxlXCIsdC5lbmRFbWl0dGVkKTtpZighdC5lbmRFbWl0dGVkKXt0LmVuZGVkPXRydWU7cHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULHQsZSl9fWZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoZSx0KXt1KFwiZW5kUmVhZGFibGVOVFwiLGUuZW5kRW1pdHRlZCxlLmxlbmd0aCk7aWYoIWUuZW5kRW1pdHRlZCYmZS5sZW5ndGg9PT0wKXtlLmVuZEVtaXR0ZWQ9dHJ1ZTt0LnJlYWRhYmxlPWZhbHNlO3QuZW1pdChcImVuZFwiKTtpZihlLmF1dG9EZXN0cm95KXt2YXIgcj10Ll93cml0YWJsZVN0YXRlO2lmKCFyfHxyLmF1dG9EZXN0cm95JiZyLmZpbmlzaGVkKXt0LmRlc3Ryb3koKX19fX1pZih0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiKXtSZWFkYWJsZS5mcm9tPWZ1bmN0aW9uKGUsdCl7aWYoUz09PXVuZGVmaW5lZCl7Uz1yKDcyNyl9cmV0dXJuIFMoUmVhZGFibGUsZSx0KX19ZnVuY3Rpb24gaW5kZXhPZihlLHQpe2Zvcih2YXIgcj0wLG49ZS5sZW5ndGg7cjxuO3IrKyl7aWYoZVtyXT09PXQpcmV0dXJuIHJ9cmV0dXJuLTF9fSwxNzA6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1UcmFuc2Zvcm07dmFyIG49cig2NDYpLnEsaT1uLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELGE9bi5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssbz1uLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcscz1uLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDt2YXIgZj1yKDQwMyk7cig3ODIpKFRyYW5zZm9ybSxmKTtmdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlLHQpe3ZhciByPXRoaXMuX3RyYW5zZm9ybVN0YXRlO3IudHJhbnNmb3JtaW5nPWZhbHNlO3ZhciBuPXIud3JpdGVjYjtpZihuPT09bnVsbCl7cmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsbmV3IGEpfXIud3JpdGVjaHVuaz1udWxsO3Iud3JpdGVjYj1udWxsO2lmKHQhPW51bGwpdGhpcy5wdXNoKHQpO24oZSk7dmFyIGk9dGhpcy5fcmVhZGFibGVTdGF0ZTtpLnJlYWRpbmc9ZmFsc2U7aWYoaS5uZWVkUmVhZGFibGV8fGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFyayl7dGhpcy5fcmVhZChpLmhpZ2hXYXRlck1hcmspfX1mdW5jdGlvbiBUcmFuc2Zvcm0oZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlyZXR1cm4gbmV3IFRyYW5zZm9ybShlKTtmLmNhbGwodGhpcyxlKTt0aGlzLl90cmFuc2Zvcm1TdGF0ZT17YWZ0ZXJUcmFuc2Zvcm06YWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxuZWVkVHJhbnNmb3JtOmZhbHNlLHRyYW5zZm9ybWluZzpmYWxzZSx3cml0ZWNiOm51bGwsd3JpdGVjaHVuazpudWxsLHdyaXRlZW5jb2Rpbmc6bnVsbH07dGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGU9dHJ1ZTt0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmM9ZmFsc2U7aWYoZSl7aWYodHlwZW9mIGUudHJhbnNmb3JtPT09XCJmdW5jdGlvblwiKXRoaXMuX3RyYW5zZm9ybT1lLnRyYW5zZm9ybTtpZih0eXBlb2YgZS5mbHVzaD09PVwiZnVuY3Rpb25cIil0aGlzLl9mbHVzaD1lLmZsdXNofXRoaXMub24oXCJwcmVmaW5pc2hcIixwcmVmaW5pc2gpfWZ1bmN0aW9uIHByZWZpbmlzaCgpe3ZhciBlPXRoaXM7aWYodHlwZW9mIHRoaXMuX2ZsdXNoPT09XCJmdW5jdGlvblwiJiYhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpe3RoaXMuX2ZsdXNoKChmdW5jdGlvbih0LHIpe2RvbmUoZSx0LHIpfSkpfWVsc2V7ZG9uZSh0aGlzLG51bGwsbnVsbCl9fVRyYW5zZm9ybS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3RoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm09ZmFsc2U7cmV0dXJuIGYucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLGUsdCl9O1RyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbihlLHQscil7cihuZXcgaShcIl90cmFuc2Zvcm0oKVwiKSl9O1RyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtuLndyaXRlY2I9cjtuLndyaXRlY2h1bms9ZTtuLndyaXRlZW5jb2Rpbmc9dDtpZighbi50cmFuc2Zvcm1pbmcpe3ZhciBpPXRoaXMuX3JlYWRhYmxlU3RhdGU7aWYobi5uZWVkVHJhbnNmb3JtfHxpLm5lZWRSZWFkYWJsZXx8aS5sZW5ndGg8aS5oaWdoV2F0ZXJNYXJrKXRoaXMuX3JlYWQoaS5oaWdoV2F0ZXJNYXJrKX19O1RyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fdHJhbnNmb3JtU3RhdGU7aWYodC53cml0ZWNodW5rIT09bnVsbCYmIXQudHJhbnNmb3JtaW5nKXt0LnRyYW5zZm9ybWluZz10cnVlO3RoaXMuX3RyYW5zZm9ybSh0LndyaXRlY2h1bmssdC53cml0ZWVuY29kaW5nLHQuYWZ0ZXJUcmFuc2Zvcm0pfWVsc2V7dC5uZWVkVHJhbnNmb3JtPXRydWV9fTtUcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95PWZ1bmN0aW9uKGUsdCl7Zi5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLGUsKGZ1bmN0aW9uKGUpe3QoZSl9KSl9O2Z1bmN0aW9uIGRvbmUoZSx0LHIpe2lmKHQpcmV0dXJuIGUuZW1pdChcImVycm9yXCIsdCk7aWYociE9bnVsbCllLnB1c2gocik7aWYoZS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpdGhyb3cgbmV3IHM7aWYoZS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKXRocm93IG5ldyBvO3JldHVybiBlLnB1c2gobnVsbCl9fSwzMzc6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1Xcml0YWJsZTtmdW5jdGlvbiBXcml0ZVJlcShlLHQscil7dGhpcy5jaHVuaz1lO3RoaXMuZW5jb2Rpbmc9dDt0aGlzLmNhbGxiYWNrPXI7dGhpcy5uZXh0PW51bGx9ZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChlKXt2YXIgdD10aGlzO3RoaXMubmV4dD1udWxsO3RoaXMuZW50cnk9bnVsbDt0aGlzLmZpbmlzaD1mdW5jdGlvbigpe29uQ29ya2VkRmluaXNoKHQsZSl9fXZhciBuO1dyaXRhYmxlLldyaXRhYmxlU3RhdGU9V3JpdGFibGVTdGF0ZTt2YXIgaT17ZGVwcmVjYXRlOnIoNzY5KX07dmFyIGE9cig2NzgpO3ZhciBvPXIoMzAwKS5CdWZmZXI7dmFyIHM9Z2xvYmFsLlVpbnQ4QXJyYXl8fGZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGUpe3JldHVybiBvLmZyb20oZSl9ZnVuY3Rpb24gX2lzVWludDhBcnJheShlKXtyZXR1cm4gby5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIHN9dmFyIGY9cigyNSk7dmFyIGw9cig3NzYpLHU9bC5nZXRIaWdoV2F0ZXJNYXJrO3ZhciBkPXIoNjQ2KS5xLGM9ZC5FUlJfSU5WQUxJRF9BUkdfVFlQRSxoPWQuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQscD1kLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxiPWQuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxnPWQuRVJSX1NUUkVBTV9ERVNUUk9ZRUQseT1kLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXz1kLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELHY9ZC5FUlJfVU5LTk9XTl9FTkNPRElORzt2YXIgdz1mLmVycm9yT3JEZXN0cm95O3IoNzgyKShXcml0YWJsZSxhKTtmdW5jdGlvbiBub3AoKXt9ZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShlLHQsaSl7bj1ufHxyKDQwMyk7ZT1lfHx7fTtpZih0eXBlb2YgaSE9PVwiYm9vbGVhblwiKWk9dCBpbnN0YW5jZW9mIG47dGhpcy5vYmplY3RNb2RlPSEhZS5vYmplY3RNb2RlO2lmKGkpdGhpcy5vYmplY3RNb2RlPXRoaXMub2JqZWN0TW9kZXx8ISFlLndyaXRhYmxlT2JqZWN0TW9kZTt0aGlzLmhpZ2hXYXRlck1hcms9dSh0aGlzLGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIixpKTt0aGlzLmZpbmFsQ2FsbGVkPWZhbHNlO3RoaXMubmVlZERyYWluPWZhbHNlO3RoaXMuZW5kaW5nPWZhbHNlO3RoaXMuZW5kZWQ9ZmFsc2U7dGhpcy5maW5pc2hlZD1mYWxzZTt0aGlzLmRlc3Ryb3llZD1mYWxzZTt2YXIgYT1lLmRlY29kZVN0cmluZ3M9PT1mYWxzZTt0aGlzLmRlY29kZVN0cmluZ3M9IWE7dGhpcy5kZWZhdWx0RW5jb2Rpbmc9ZS5kZWZhdWx0RW5jb2Rpbmd8fFwidXRmOFwiO3RoaXMubGVuZ3RoPTA7dGhpcy53cml0aW5nPWZhbHNlO3RoaXMuY29ya2VkPTA7dGhpcy5zeW5jPXRydWU7dGhpcy5idWZmZXJQcm9jZXNzaW5nPWZhbHNlO3RoaXMub253cml0ZT1mdW5jdGlvbihlKXtvbndyaXRlKHQsZSl9O3RoaXMud3JpdGVjYj1udWxsO3RoaXMud3JpdGVsZW49MDt0aGlzLmJ1ZmZlcmVkUmVxdWVzdD1udWxsO3RoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdD1udWxsO3RoaXMucGVuZGluZ2NiPTA7dGhpcy5wcmVmaW5pc2hlZD1mYWxzZTt0aGlzLmVycm9yRW1pdHRlZD1mYWxzZTt0aGlzLmVtaXRDbG9zZT1lLmVtaXRDbG9zZSE9PWZhbHNlO3RoaXMuYXV0b0Rlc3Ryb3k9ISFlLmF1dG9EZXN0cm95O3RoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQ9MDt0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgQ29ya2VkUmVxdWVzdCh0aGlzKX1Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXI9ZnVuY3Rpb24gZ2V0QnVmZmVyKCl7dmFyIGU9dGhpcy5idWZmZXJlZFJlcXVlc3Q7dmFyIHQ9W107d2hpbGUoZSl7dC5wdXNoKGUpO2U9ZS5uZXh0fXJldHVybiB0fTsoZnVuY3Rpb24oKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLFwiYnVmZmVyXCIse2dldDppLmRlcHJlY2F0ZSgoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpe3JldHVybiB0aGlzLmdldEJ1ZmZlcigpfSksXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBcIitcImluc3RlYWQuXCIsXCJERVAwMDAzXCIpfSl9Y2F0Y2goZSl7fX0pKCk7dmFyIG07aWYodHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmU3ltYm9sLmhhc0luc3RhbmNlJiZ0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV09PT1cImZ1bmN0aW9uXCIpe209RnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYobS5jYWxsKHRoaXMsZSkpcmV0dXJuIHRydWU7aWYodGhpcyE9PVdyaXRhYmxlKXJldHVybiBmYWxzZTtyZXR1cm4gZSYmZS5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGV9fSl9ZWxzZXttPWZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHRoaXN9fWZ1bmN0aW9uIFdyaXRhYmxlKGUpe249bnx8cig0MDMpO3ZhciB0PXRoaXMgaW5zdGFuY2VvZiBuO2lmKCF0JiYhbS5jYWxsKFdyaXRhYmxlLHRoaXMpKXJldHVybiBuZXcgV3JpdGFibGUoZSk7dGhpcy5fd3JpdGFibGVTdGF0ZT1uZXcgV3JpdGFibGVTdGF0ZShlLHRoaXMsdCk7dGhpcy53cml0YWJsZT10cnVlO2lmKGUpe2lmKHR5cGVvZiBlLndyaXRlPT09XCJmdW5jdGlvblwiKXRoaXMuX3dyaXRlPWUud3JpdGU7aWYodHlwZW9mIGUud3JpdGV2PT09XCJmdW5jdGlvblwiKXRoaXMuX3dyaXRldj1lLndyaXRldjtpZih0eXBlb2YgZS5kZXN0cm95PT09XCJmdW5jdGlvblwiKXRoaXMuX2Rlc3Ryb3k9ZS5kZXN0cm95O2lmKHR5cGVvZiBlLmZpbmFsPT09XCJmdW5jdGlvblwiKXRoaXMuX2ZpbmFsPWUuZmluYWx9YS5jYWxsKHRoaXMpfVdyaXRhYmxlLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7dyh0aGlzLG5ldyBiKX07ZnVuY3Rpb24gd3JpdGVBZnRlckVuZChlLHQpe3ZhciByPW5ldyBfO3coZSxyKTtwcm9jZXNzLm5leHRUaWNrKHQscil9ZnVuY3Rpb24gdmFsaWRDaHVuayhlLHQscixuKXt2YXIgaTtpZihyPT09bnVsbCl7aT1uZXcgeX1lbHNlIGlmKHR5cGVvZiByIT09XCJzdHJpbmdcIiYmIXQub2JqZWN0TW9kZSl7aT1uZXcgYyhcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIl0scil9aWYoaSl7dyhlLGkpO3Byb2Nlc3MubmV4dFRpY2sobixpKTtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9V3JpdGFibGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLl93cml0YWJsZVN0YXRlO3ZhciBpPWZhbHNlO3ZhciBhPSFuLm9iamVjdE1vZGUmJl9pc1VpbnQ4QXJyYXkoZSk7aWYoYSYmIW8uaXNCdWZmZXIoZSkpe2U9X3VpbnQ4QXJyYXlUb0J1ZmZlcihlKX1pZih0eXBlb2YgdD09PVwiZnVuY3Rpb25cIil7cj10O3Q9bnVsbH1pZihhKXQ9XCJidWZmZXJcIjtlbHNlIGlmKCF0KXQ9bi5kZWZhdWx0RW5jb2Rpbmc7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpcj1ub3A7aWYobi5lbmRpbmcpd3JpdGVBZnRlckVuZCh0aGlzLHIpO2Vsc2UgaWYoYXx8dmFsaWRDaHVuayh0aGlzLG4sZSxyKSl7bi5wZW5kaW5nY2IrKztpPXdyaXRlT3JCdWZmZXIodGhpcyxuLGEsZSx0LHIpfXJldHVybiBpfTtXcml0YWJsZS5wcm90b3R5cGUuY29yaz1mdW5jdGlvbigpe3RoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKyt9O1dyaXRhYmxlLnByb3RvdHlwZS51bmNvcms9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl93cml0YWJsZVN0YXRlO2lmKGUuY29ya2VkKXtlLmNvcmtlZC0tO2lmKCFlLndyaXRpbmcmJiFlLmNvcmtlZCYmIWUuYnVmZmVyUHJvY2Vzc2luZyYmZS5idWZmZXJlZFJlcXVlc3QpY2xlYXJCdWZmZXIodGhpcyxlKX19O1dyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2Rpbmc9ZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGUpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIillPWUudG9Mb3dlckNhc2UoKTtpZighKFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigoZStcIlwiKS50b0xvd2VyQ2FzZSgpKT4tMSkpdGhyb3cgbmV3IHYoZSk7dGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2Rpbmc9ZTtyZXR1cm4gdGhpc307T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSxcIndyaXRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpfX0pO2Z1bmN0aW9uIGRlY29kZUNodW5rKGUsdCxyKXtpZighZS5vYmplY3RNb2RlJiZlLmRlY29kZVN0cmluZ3MhPT1mYWxzZSYmdHlwZW9mIHQ9PT1cInN0cmluZ1wiKXt0PW8uZnJvbSh0LHIpfXJldHVybiB0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KTtmdW5jdGlvbiB3cml0ZU9yQnVmZmVyKGUsdCxyLG4saSxhKXtpZighcil7dmFyIG89ZGVjb2RlQ2h1bmsodCxuLGkpO2lmKG4hPT1vKXtyPXRydWU7aT1cImJ1ZmZlclwiO249b319dmFyIHM9dC5vYmplY3RNb2RlPzE6bi5sZW5ndGg7dC5sZW5ndGgrPXM7dmFyIGY9dC5sZW5ndGg8dC5oaWdoV2F0ZXJNYXJrO2lmKCFmKXQubmVlZERyYWluPXRydWU7aWYodC53cml0aW5nfHx0LmNvcmtlZCl7dmFyIGw9dC5sYXN0QnVmZmVyZWRSZXF1ZXN0O3QubGFzdEJ1ZmZlcmVkUmVxdWVzdD17Y2h1bms6bixlbmNvZGluZzppLGlzQnVmOnIsY2FsbGJhY2s6YSxuZXh0Om51bGx9O2lmKGwpe2wubmV4dD10Lmxhc3RCdWZmZXJlZFJlcXVlc3R9ZWxzZXt0LmJ1ZmZlcmVkUmVxdWVzdD10Lmxhc3RCdWZmZXJlZFJlcXVlc3R9dC5idWZmZXJlZFJlcXVlc3RDb3VudCs9MX1lbHNle2RvV3JpdGUoZSx0LGZhbHNlLHMsbixpLGEpfXJldHVybiBmfWZ1bmN0aW9uIGRvV3JpdGUoZSx0LHIsbixpLGEsbyl7dC53cml0ZWxlbj1uO3Qud3JpdGVjYj1vO3Qud3JpdGluZz10cnVlO3Quc3luYz10cnVlO2lmKHQuZGVzdHJveWVkKXQub253cml0ZShuZXcgZyhcIndyaXRlXCIpKTtlbHNlIGlmKHIpZS5fd3JpdGV2KGksdC5vbndyaXRlKTtlbHNlIGUuX3dyaXRlKGksYSx0Lm9ud3JpdGUpO3Quc3luYz1mYWxzZX1mdW5jdGlvbiBvbndyaXRlRXJyb3IoZSx0LHIsbixpKXstLXQucGVuZGluZ2NiO2lmKHIpe3Byb2Nlc3MubmV4dFRpY2soaSxuKTtwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLGUsdCk7ZS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9dHJ1ZTt3KGUsbil9ZWxzZXtpKG4pO2UuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPXRydWU7dyhlLG4pO2ZpbmlzaE1heWJlKGUsdCl9fWZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShlKXtlLndyaXRpbmc9ZmFsc2U7ZS53cml0ZWNiPW51bGw7ZS5sZW5ndGgtPWUud3JpdGVsZW47ZS53cml0ZWxlbj0wfWZ1bmN0aW9uIG9ud3JpdGUoZSx0KXt2YXIgcj1lLl93cml0YWJsZVN0YXRlO3ZhciBuPXIuc3luYzt2YXIgaT1yLndyaXRlY2I7aWYodHlwZW9mIGkhPT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IHA7b253cml0ZVN0YXRlVXBkYXRlKHIpO2lmKHQpb253cml0ZUVycm9yKGUscixuLHQsaSk7ZWxzZXt2YXIgYT1uZWVkRmluaXNoKHIpfHxlLmRlc3Ryb3llZDtpZighYSYmIXIuY29ya2VkJiYhci5idWZmZXJQcm9jZXNzaW5nJiZyLmJ1ZmZlcmVkUmVxdWVzdCl7Y2xlYXJCdWZmZXIoZSxyKX1pZihuKXtwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsZSxyLGEsaSl9ZWxzZXthZnRlcldyaXRlKGUscixhLGkpfX19ZnVuY3Rpb24gYWZ0ZXJXcml0ZShlLHQscixuKXtpZighcilvbndyaXRlRHJhaW4oZSx0KTt0LnBlbmRpbmdjYi0tO24oKTtmaW5pc2hNYXliZShlLHQpfWZ1bmN0aW9uIG9ud3JpdGVEcmFpbihlLHQpe2lmKHQubGVuZ3RoPT09MCYmdC5uZWVkRHJhaW4pe3QubmVlZERyYWluPWZhbHNlO2UuZW1pdChcImRyYWluXCIpfX1mdW5jdGlvbiBjbGVhckJ1ZmZlcihlLHQpe3QuYnVmZmVyUHJvY2Vzc2luZz10cnVlO3ZhciByPXQuYnVmZmVyZWRSZXF1ZXN0O2lmKGUuX3dyaXRldiYmciYmci5uZXh0KXt2YXIgbj10LmJ1ZmZlcmVkUmVxdWVzdENvdW50O3ZhciBpPW5ldyBBcnJheShuKTt2YXIgYT10LmNvcmtlZFJlcXVlc3RzRnJlZTthLmVudHJ5PXI7dmFyIG89MDt2YXIgcz10cnVlO3doaWxlKHIpe2lbb109cjtpZighci5pc0J1ZilzPWZhbHNlO3I9ci5uZXh0O28rPTF9aS5hbGxCdWZmZXJzPXM7ZG9Xcml0ZShlLHQsdHJ1ZSx0Lmxlbmd0aCxpLFwiXCIsYS5maW5pc2gpO3QucGVuZGluZ2NiKys7dC5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGw7aWYoYS5uZXh0KXt0LmNvcmtlZFJlcXVlc3RzRnJlZT1hLm5leHQ7YS5uZXh0PW51bGx9ZWxzZXt0LmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgQ29ya2VkUmVxdWVzdCh0KX10LmJ1ZmZlcmVkUmVxdWVzdENvdW50PTB9ZWxzZXt3aGlsZShyKXt2YXIgZj1yLmNodW5rO3ZhciBsPXIuZW5jb2Rpbmc7dmFyIHU9ci5jYWxsYmFjazt2YXIgZD10Lm9iamVjdE1vZGU/MTpmLmxlbmd0aDtkb1dyaXRlKGUsdCxmYWxzZSxkLGYsbCx1KTtyPXIubmV4dDt0LmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07aWYodC53cml0aW5nKXticmVha319aWYocj09PW51bGwpdC5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGx9dC5idWZmZXJlZFJlcXVlc3Q9cjt0LmJ1ZmZlclByb2Nlc3Npbmc9ZmFsc2V9V3JpdGFibGUucHJvdG90eXBlLl93cml0ZT1mdW5jdGlvbihlLHQscil7cihuZXcgaChcIl93cml0ZSgpXCIpKX07V3JpdGFibGUucHJvdG90eXBlLl93cml0ZXY9bnVsbDtXcml0YWJsZS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLl93cml0YWJsZVN0YXRlO2lmKHR5cGVvZiBlPT09XCJmdW5jdGlvblwiKXtyPWU7ZT1udWxsO3Q9bnVsbH1lbHNlIGlmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiKXtyPXQ7dD1udWxsfWlmKGUhPT1udWxsJiZlIT09dW5kZWZpbmVkKXRoaXMud3JpdGUoZSx0KTtpZihuLmNvcmtlZCl7bi5jb3JrZWQ9MTt0aGlzLnVuY29yaygpfWlmKCFuLmVuZGluZyllbmRXcml0YWJsZSh0aGlzLG4scik7cmV0dXJuIHRoaXN9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsXCJ3cml0YWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGh9fSk7ZnVuY3Rpb24gbmVlZEZpbmlzaChlKXtyZXR1cm4gZS5lbmRpbmcmJmUubGVuZ3RoPT09MCYmZS5idWZmZXJlZFJlcXVlc3Q9PT1udWxsJiYhZS5maW5pc2hlZCYmIWUud3JpdGluZ31mdW5jdGlvbiBjYWxsRmluYWwoZSx0KXtlLl9maW5hbCgoZnVuY3Rpb24ocil7dC5wZW5kaW5nY2ItLTtpZihyKXt3KGUscil9dC5wcmVmaW5pc2hlZD10cnVlO2UuZW1pdChcInByZWZpbmlzaFwiKTtmaW5pc2hNYXliZShlLHQpfSkpfWZ1bmN0aW9uIHByZWZpbmlzaChlLHQpe2lmKCF0LnByZWZpbmlzaGVkJiYhdC5maW5hbENhbGxlZCl7aWYodHlwZW9mIGUuX2ZpbmFsPT09XCJmdW5jdGlvblwiJiYhdC5kZXN0cm95ZWQpe3QucGVuZGluZ2NiKys7dC5maW5hbENhbGxlZD10cnVlO3Byb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLGUsdCl9ZWxzZXt0LnByZWZpbmlzaGVkPXRydWU7ZS5lbWl0KFwicHJlZmluaXNoXCIpfX19ZnVuY3Rpb24gZmluaXNoTWF5YmUoZSx0KXt2YXIgcj1uZWVkRmluaXNoKHQpO2lmKHIpe3ByZWZpbmlzaChlLHQpO2lmKHQucGVuZGluZ2NiPT09MCl7dC5maW5pc2hlZD10cnVlO2UuZW1pdChcImZpbmlzaFwiKTtpZih0LmF1dG9EZXN0cm95KXt2YXIgbj1lLl9yZWFkYWJsZVN0YXRlO2lmKCFufHxuLmF1dG9EZXN0cm95JiZuLmVuZEVtaXR0ZWQpe2UuZGVzdHJveSgpfX19fXJldHVybiByfWZ1bmN0aW9uIGVuZFdyaXRhYmxlKGUsdCxyKXt0LmVuZGluZz10cnVlO2ZpbmlzaE1heWJlKGUsdCk7aWYocil7aWYodC5maW5pc2hlZClwcm9jZXNzLm5leHRUaWNrKHIpO2Vsc2UgZS5vbmNlKFwiZmluaXNoXCIscil9dC5lbmRlZD10cnVlO2Uud3JpdGFibGU9ZmFsc2V9ZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goZSx0LHIpe3ZhciBuPWUuZW50cnk7ZS5lbnRyeT1udWxsO3doaWxlKG4pe3ZhciBpPW4uY2FsbGJhY2s7dC5wZW5kaW5nY2ItLTtpKHIpO249bi5uZXh0fXQuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQ9ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe2lmKHRoaXMuX3dyaXRhYmxlU3RhdGU9PT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbiBzZXQoZSl7aWYoIXRoaXMuX3dyaXRhYmxlU3RhdGUpe3JldHVybn10aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1lfX0pO1dyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95PWYuZGVzdHJveTtXcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveT1mLnVuZGVzdHJveTtXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfX0sODcxOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbjtmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSx0LHIpe2lmKHQgaW4gZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsd3JpdGFibGU6dHJ1ZX0pfWVsc2V7ZVt0XT1yfXJldHVybiBlfXZhciBpPXIoNjk4KTt2YXIgYT1TeW1ib2woXCJsYXN0UmVzb2x2ZVwiKTt2YXIgbz1TeW1ib2woXCJsYXN0UmVqZWN0XCIpO3ZhciBzPVN5bWJvbChcImVycm9yXCIpO3ZhciBmPVN5bWJvbChcImVuZGVkXCIpO3ZhciBsPVN5bWJvbChcImxhc3RQcm9taXNlXCIpO3ZhciB1PVN5bWJvbChcImhhbmRsZVByb21pc2VcIik7dmFyIGQ9U3ltYm9sKFwic3RyZWFtXCIpO2Z1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQoZSx0KXtyZXR1cm57dmFsdWU6ZSxkb25lOnR9fWZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGUpe3ZhciB0PWVbYV07aWYodCE9PW51bGwpe3ZhciByPWVbZF0ucmVhZCgpO2lmKHIhPT1udWxsKXtlW2xdPW51bGw7ZVthXT1udWxsO2Vbb109bnVsbDt0KGNyZWF0ZUl0ZXJSZXN1bHQocixmYWxzZSkpfX19ZnVuY3Rpb24gb25SZWFkYWJsZShlKXtwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLGUpfWZ1bmN0aW9uIHdyYXBGb3JOZXh0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKHIsbil7ZS50aGVuKChmdW5jdGlvbigpe2lmKHRbZl0pe3IoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsdHJ1ZSkpO3JldHVybn10W3VdKHIsbil9KSxuKX19dmFyIGM9T2JqZWN0LmdldFByb3RvdHlwZU9mKChmdW5jdGlvbigpe30pKTt2YXIgaD1PYmplY3Quc2V0UHJvdG90eXBlT2YoKG49e2dldCBzdHJlYW0oKXtyZXR1cm4gdGhpc1tkXX0sbmV4dDpmdW5jdGlvbiBuZXh0KCl7dmFyIGU9dGhpczt2YXIgdD10aGlzW3NdO2lmKHQhPT1udWxsKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9aWYodGhpc1tmXSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCx0cnVlKSl9aWYodGhpc1tkXS5kZXN0cm95ZWQpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxyKXtwcm9jZXNzLm5leHRUaWNrKChmdW5jdGlvbigpe2lmKGVbc10pe3IoZVtzXSl9ZWxzZXt0KGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLHRydWUpKX19KSl9KSl9dmFyIHI9dGhpc1tsXTt2YXIgbjtpZihyKXtuPW5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KHIsdGhpcykpfWVsc2V7dmFyIGk9dGhpc1tkXS5yZWFkKCk7aWYoaSE9PW51bGwpe3JldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChpLGZhbHNlKSl9bj1uZXcgUHJvbWlzZSh0aGlzW3VdKX10aGlzW2xdPW47cmV0dXJuIG59fSxfZGVmaW5lUHJvcGVydHkobixTeW1ib2wuYXN5bmNJdGVyYXRvciwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxfZGVmaW5lUHJvcGVydHkobixcInJldHVyblwiLChmdW5jdGlvbiBfcmV0dXJuKCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7ZVtkXS5kZXN0cm95KG51bGwsKGZ1bmN0aW9uKGUpe2lmKGUpe3IoZSk7cmV0dXJufXQoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsdHJ1ZSkpfSkpfSkpfSkpLG4pLGMpO3ZhciBwPWZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihlKXt2YXIgdDt2YXIgcj1PYmplY3QuY3JlYXRlKGgsKHQ9e30sX2RlZmluZVByb3BlcnR5KHQsZCx7dmFsdWU6ZSx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsYSx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsbyx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQscyx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsZix7dmFsdWU6ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLHdyaXRhYmxlOnRydWV9KSxfZGVmaW5lUHJvcGVydHkodCx1LHt2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLHQpe3ZhciBuPXJbZF0ucmVhZCgpO2lmKG4pe3JbbF09bnVsbDtyW2FdPW51bGw7cltvXT1udWxsO2UoY3JlYXRlSXRlclJlc3VsdChuLGZhbHNlKSl9ZWxzZXtyW2FdPWU7cltvXT10fX0sd3JpdGFibGU6dHJ1ZX0pLHQpKTtyW2xdPW51bGw7aShlLChmdW5jdGlvbihlKXtpZihlJiZlLmNvZGUhPT1cIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIpe3ZhciB0PXJbb107aWYodCE9PW51bGwpe3JbbF09bnVsbDtyW2FdPW51bGw7cltvXT1udWxsO3QoZSl9cltzXT1lO3JldHVybn12YXIgbj1yW2FdO2lmKG4hPT1udWxsKXtyW2xdPW51bGw7clthXT1udWxsO3Jbb109bnVsbDtuKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLHRydWUpKX1yW2ZdPXRydWV9KSk7ZS5vbihcInJlYWRhYmxlXCIsb25SZWFkYWJsZS5iaW5kKG51bGwscikpO3JldHVybiByfTtlLmV4cG9ydHM9cH0sMzc5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvd25LZXlzKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtpZih0KW49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKTtyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XSE9bnVsbD9hcmd1bWVudHNbdF06e307aWYodCUyKXtvd25LZXlzKE9iamVjdChyKSx0cnVlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtfZGVmaW5lUHJvcGVydHkoZSx0LHJbdF0pfSkpfWVsc2UgaWYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpfWVsc2V7b3duS2V5cyhPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX19cmV0dXJuIGV9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsdCxyKXtpZih0IGluIGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHdyaXRhYmxlOnRydWV9KX1lbHNle2VbdF09cn1yZXR1cm4gZX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHxmYWxzZTtuLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIG4pbi53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSx0LHIpe2lmKHQpX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsdCk7aWYocilfZGVmaW5lUHJvcGVydGllcyhlLHIpO3JldHVybiBlfXZhciBuPXIoMzAwKSxpPW4uQnVmZmVyO3ZhciBhPXIoODM3KSxvPWEuaW5zcGVjdDt2YXIgcz1vJiZvLmN1c3RvbXx8XCJpbnNwZWN0XCI7ZnVuY3Rpb24gY29weUJ1ZmZlcihlLHQscil7aS5wcm90b3R5cGUuY29weS5jYWxsKGUsdCxyKX1lLmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCdWZmZXJMaXN0KCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQnVmZmVyTGlzdCk7dGhpcy5oZWFkPW51bGw7dGhpcy50YWlsPW51bGw7dGhpcy5sZW5ndGg9MH1fY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCxbe2tleTpcInB1c2hcIix2YWx1ZTpmdW5jdGlvbiBwdXNoKGUpe3ZhciB0PXtkYXRhOmUsbmV4dDpudWxsfTtpZih0aGlzLmxlbmd0aD4wKXRoaXMudGFpbC5uZXh0PXQ7ZWxzZSB0aGlzLmhlYWQ9dDt0aGlzLnRhaWw9dDsrK3RoaXMubGVuZ3RofX0se2tleTpcInVuc2hpZnRcIix2YWx1ZTpmdW5jdGlvbiB1bnNoaWZ0KGUpe3ZhciB0PXtkYXRhOmUsbmV4dDp0aGlzLmhlYWR9O2lmKHRoaXMubGVuZ3RoPT09MCl0aGlzLnRhaWw9dDt0aGlzLmhlYWQ9dDsrK3RoaXMubGVuZ3RofX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24gc2hpZnQoKXtpZih0aGlzLmxlbmd0aD09PTApcmV0dXJuO3ZhciBlPXRoaXMuaGVhZC5kYXRhO2lmKHRoaXMubGVuZ3RoPT09MSl0aGlzLmhlYWQ9dGhpcy50YWlsPW51bGw7ZWxzZSB0aGlzLmhlYWQ9dGhpcy5oZWFkLm5leHQ7LS10aGlzLmxlbmd0aDtyZXR1cm4gZX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uIGNsZWFyKCl7dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsO3RoaXMubGVuZ3RoPTB9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uIGpvaW4oZSl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7dmFyIHQ9dGhpcy5oZWFkO3ZhciByPVwiXCIrdC5kYXRhO3doaWxlKHQ9dC5uZXh0KXtyKz1lK3QuZGF0YX1yZXR1cm4gcn19LHtrZXk6XCJjb25jYXRcIix2YWx1ZTpmdW5jdGlvbiBjb25jYXQoZSl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybiBpLmFsbG9jKDApO3ZhciB0PWkuYWxsb2NVbnNhZmUoZT4+PjApO3ZhciByPXRoaXMuaGVhZDt2YXIgbj0wO3doaWxlKHIpe2NvcHlCdWZmZXIoci5kYXRhLHQsbik7bis9ci5kYXRhLmxlbmd0aDtyPXIubmV4dH1yZXR1cm4gdH19LHtrZXk6XCJjb25zdW1lXCIsdmFsdWU6ZnVuY3Rpb24gY29uc3VtZShlLHQpe3ZhciByO2lmKGU8dGhpcy5oZWFkLmRhdGEubGVuZ3RoKXtyPXRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsZSk7dGhpcy5oZWFkLmRhdGE9dGhpcy5oZWFkLmRhdGEuc2xpY2UoZSl9ZWxzZSBpZihlPT09dGhpcy5oZWFkLmRhdGEubGVuZ3RoKXtyPXRoaXMuc2hpZnQoKX1lbHNle3I9dD90aGlzLl9nZXRTdHJpbmcoZSk6dGhpcy5fZ2V0QnVmZmVyKGUpfXJldHVybiByfX0se2tleTpcImZpcnN0XCIsdmFsdWU6ZnVuY3Rpb24gZmlyc3QoKXtyZXR1cm4gdGhpcy5oZWFkLmRhdGF9fSx7a2V5OlwiX2dldFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uIF9nZXRTdHJpbmcoZSl7dmFyIHQ9dGhpcy5oZWFkO3ZhciByPTE7dmFyIG49dC5kYXRhO2UtPW4ubGVuZ3RoO3doaWxlKHQ9dC5uZXh0KXt2YXIgaT10LmRhdGE7dmFyIGE9ZT5pLmxlbmd0aD9pLmxlbmd0aDplO2lmKGE9PT1pLmxlbmd0aCluKz1pO2Vsc2Ugbis9aS5zbGljZSgwLGUpO2UtPWE7aWYoZT09PTApe2lmKGE9PT1pLmxlbmd0aCl7KytyO2lmKHQubmV4dCl0aGlzLmhlYWQ9dC5uZXh0O2Vsc2UgdGhpcy5oZWFkPXRoaXMudGFpbD1udWxsfWVsc2V7dGhpcy5oZWFkPXQ7dC5kYXRhPWkuc2xpY2UoYSl9YnJlYWt9KytyfXRoaXMubGVuZ3RoLT1yO3JldHVybiBufX0se2tleTpcIl9nZXRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbiBfZ2V0QnVmZmVyKGUpe3ZhciB0PWkuYWxsb2NVbnNhZmUoZSk7dmFyIHI9dGhpcy5oZWFkO3ZhciBuPTE7ci5kYXRhLmNvcHkodCk7ZS09ci5kYXRhLmxlbmd0aDt3aGlsZShyPXIubmV4dCl7dmFyIGE9ci5kYXRhO3ZhciBvPWU+YS5sZW5ndGg/YS5sZW5ndGg6ZTthLmNvcHkodCx0Lmxlbmd0aC1lLDAsbyk7ZS09bztpZihlPT09MCl7aWYobz09PWEubGVuZ3RoKXsrK247aWYoci5uZXh0KXRoaXMuaGVhZD1yLm5leHQ7ZWxzZSB0aGlzLmhlYWQ9dGhpcy50YWlsPW51bGx9ZWxzZXt0aGlzLmhlYWQ9cjtyLmRhdGE9YS5zbGljZShvKX1icmVha30rK259dGhpcy5sZW5ndGgtPW47cmV0dXJuIHR9fSx7a2V5OnMsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSx0KXtyZXR1cm4gbyh0aGlzLF9vYmplY3RTcHJlYWQoe30sdCx7ZGVwdGg6MCxjdXN0b21JbnNwZWN0OmZhbHNlfSkpfX1dKTtyZXR1cm4gQnVmZmVyTGlzdH0oKX0sMjU6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZGVzdHJveShlLHQpe3ZhciByPXRoaXM7dmFyIG49dGhpcy5fcmVhZGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7dmFyIGk9dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7aWYobnx8aSl7aWYodCl7dChlKX1lbHNlIGlmKGUpe2lmKCF0aGlzLl93cml0YWJsZVN0YXRlKXtwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULHRoaXMsZSl9ZWxzZSBpZighdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpe3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPXRydWU7cHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCx0aGlzLGUpfX1yZXR1cm4gdGhpc31pZih0aGlzLl9yZWFkYWJsZVN0YXRlKXt0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD10cnVlfWlmKHRoaXMuX3dyaXRhYmxlU3RhdGUpe3RoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPXRydWV9dGhpcy5fZGVzdHJveShlfHxudWxsLChmdW5jdGlvbihlKXtpZighdCYmZSl7aWYoIXIuX3dyaXRhYmxlU3RhdGUpe3Byb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCxyLGUpfWVsc2UgaWYoIXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKXtyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD10cnVlO3Byb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCxyLGUpfWVsc2V7cHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCxyKX19ZWxzZSBpZih0KXtwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULHIpO3QoZSl9ZWxzZXtwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULHIpfX0pKTtyZXR1cm4gdGhpc31mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKGUsdCl7ZW1pdEVycm9yTlQoZSx0KTtlbWl0Q2xvc2VOVChlKX1mdW5jdGlvbiBlbWl0Q2xvc2VOVChlKXtpZihlLl93cml0YWJsZVN0YXRlJiYhZS5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpcmV0dXJuO2lmKGUuX3JlYWRhYmxlU3RhdGUmJiFlLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSlyZXR1cm47ZS5lbWl0KFwiY2xvc2VcIil9ZnVuY3Rpb24gdW5kZXN0cm95KCl7aWYodGhpcy5fcmVhZGFibGVTdGF0ZSl7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZmFsc2U7dGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nPWZhbHNlO3RoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQ9ZmFsc2U7dGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkPWZhbHNlfWlmKHRoaXMuX3dyaXRhYmxlU3RhdGUpe3RoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPWZhbHNlO3RoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQ9ZmFsc2U7dGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmc9ZmFsc2U7dGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZD1mYWxzZTt0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkPWZhbHNlO3RoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ9ZmFsc2U7dGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ZmFsc2V9fWZ1bmN0aW9uIGVtaXRFcnJvck5UKGUsdCl7ZS5lbWl0KFwiZXJyb3JcIix0KX1mdW5jdGlvbiBlcnJvck9yRGVzdHJveShlLHQpe3ZhciByPWUuX3JlYWRhYmxlU3RhdGU7dmFyIG49ZS5fd3JpdGFibGVTdGF0ZTtpZihyJiZyLmF1dG9EZXN0cm95fHxuJiZuLmF1dG9EZXN0cm95KWUuZGVzdHJveSh0KTtlbHNlIGUuZW1pdChcImVycm9yXCIsdCl9ZS5leHBvcnRzPXtkZXN0cm95OmRlc3Ryb3ksdW5kZXN0cm95OnVuZGVzdHJveSxlcnJvck9yRGVzdHJveTplcnJvck9yRGVzdHJveX19LDY5ODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig2NDYpLnEuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7ZnVuY3Rpb24gb25jZShlKXt2YXIgdD1mYWxzZTtyZXR1cm4gZnVuY3Rpb24oKXtpZih0KXJldHVybjt0PXRydWU7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkociksaT0wO2k8cjtpKyspe25baV09YXJndW1lbnRzW2ldfWUuYXBwbHkodGhpcyxuKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBpc1JlcXVlc3QoZSl7cmV0dXJuIGUuc2V0SGVhZGVyJiZ0eXBlb2YgZS5hYm9ydD09PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBlb3MoZSx0LHIpe2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiKXJldHVybiBlb3MoZSxudWxsLHQpO2lmKCF0KXQ9e307cj1vbmNlKHJ8fG5vb3ApO3ZhciBpPXQucmVhZGFibGV8fHQucmVhZGFibGUhPT1mYWxzZSYmZS5yZWFkYWJsZTt2YXIgYT10LndyaXRhYmxlfHx0LndyaXRhYmxlIT09ZmFsc2UmJmUud3JpdGFibGU7dmFyIG89ZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKXtpZighZS53cml0YWJsZSlmKCl9O3ZhciBzPWUuX3dyaXRhYmxlU3RhdGUmJmUuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7dmFyIGY9ZnVuY3Rpb24gb25maW5pc2goKXthPWZhbHNlO3M9dHJ1ZTtpZighaSlyLmNhbGwoZSl9O3ZhciBsPWUuX3JlYWRhYmxlU3RhdGUmJmUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDt2YXIgdT1mdW5jdGlvbiBvbmVuZCgpe2k9ZmFsc2U7bD10cnVlO2lmKCFhKXIuY2FsbChlKX07dmFyIGQ9ZnVuY3Rpb24gb25lcnJvcih0KXtyLmNhbGwoZSx0KX07dmFyIGM9ZnVuY3Rpb24gb25jbG9zZSgpe3ZhciB0O2lmKGkmJiFsKXtpZighZS5fcmVhZGFibGVTdGF0ZXx8IWUuX3JlYWRhYmxlU3RhdGUuZW5kZWQpdD1uZXcgbjtyZXR1cm4gci5jYWxsKGUsdCl9aWYoYSYmIXMpe2lmKCFlLl93cml0YWJsZVN0YXRlfHwhZS5fd3JpdGFibGVTdGF0ZS5lbmRlZCl0PW5ldyBuO3JldHVybiByLmNhbGwoZSx0KX19O3ZhciBoPWZ1bmN0aW9uIG9ucmVxdWVzdCgpe2UucmVxLm9uKFwiZmluaXNoXCIsZil9O2lmKGlzUmVxdWVzdChlKSl7ZS5vbihcImNvbXBsZXRlXCIsZik7ZS5vbihcImFib3J0XCIsYyk7aWYoZS5yZXEpaCgpO2Vsc2UgZS5vbihcInJlcXVlc3RcIixoKX1lbHNlIGlmKGEmJiFlLl93cml0YWJsZVN0YXRlKXtlLm9uKFwiZW5kXCIsbyk7ZS5vbihcImNsb3NlXCIsbyl9ZS5vbihcImVuZFwiLHUpO2Uub24oXCJmaW5pc2hcIixmKTtpZih0LmVycm9yIT09ZmFsc2UpZS5vbihcImVycm9yXCIsZCk7ZS5vbihcImNsb3NlXCIsYyk7cmV0dXJuIGZ1bmN0aW9uKCl7ZS5yZW1vdmVMaXN0ZW5lcihcImNvbXBsZXRlXCIsZik7ZS5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsYyk7ZS5yZW1vdmVMaXN0ZW5lcihcInJlcXVlc3RcIixoKTtpZihlLnJlcSllLnJlcS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLGYpO2UucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixvKTtlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixvKTtlLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsZik7ZS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLHUpO2UucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGQpO2UucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGMpfX1lLmV4cG9ydHM9ZW9zfSw3Mjc6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChlLHQscixuLGksYSxvKXt0cnl7dmFyIHM9ZVthXShvKTt2YXIgZj1zLnZhbHVlfWNhdGNoKGUpe3IoZSk7cmV0dXJufWlmKHMuZG9uZSl7dChmKX1lbHNle1Byb21pc2UucmVzb2x2ZShmKS50aGVuKG4saSl9fWZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMscj1hcmd1bWVudHM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe3ZhciBhPWUuYXBwbHkodCxyKTtmdW5jdGlvbiBfbmV4dChlKXthc3luY0dlbmVyYXRvclN0ZXAoYSxuLGksX25leHQsX3Rocm93LFwibmV4dFwiLGUpfWZ1bmN0aW9uIF90aHJvdyhlKXthc3luY0dlbmVyYXRvclN0ZXAoYSxuLGksX25leHQsX3Rocm93LFwidGhyb3dcIixlKX1fbmV4dCh1bmRlZmluZWQpfSkpfX1mdW5jdGlvbiBvd25LZXlzKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtpZih0KW49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKTtyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XSE9bnVsbD9hcmd1bWVudHNbdF06e307aWYodCUyKXtvd25LZXlzKE9iamVjdChyKSx0cnVlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtfZGVmaW5lUHJvcGVydHkoZSx0LHJbdF0pfSkpfWVsc2UgaWYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpfWVsc2V7b3duS2V5cyhPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX19cmV0dXJuIGV9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsdCxyKXtpZih0IGluIGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHdyaXRhYmxlOnRydWV9KX1lbHNle2VbdF09cn1yZXR1cm4gZX12YXIgbj1yKDY0NikucS5FUlJfSU5WQUxJRF9BUkdfVFlQRTtmdW5jdGlvbiBmcm9tKGUsdCxyKXt2YXIgaTtpZih0JiZ0eXBlb2YgdC5uZXh0PT09XCJmdW5jdGlvblwiKXtpPXR9ZWxzZSBpZih0JiZ0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSlpPXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7ZWxzZSBpZih0JiZ0W1N5bWJvbC5pdGVyYXRvcl0paT10W1N5bWJvbC5pdGVyYXRvcl0oKTtlbHNlIHRocm93IG5ldyBuKFwiaXRlcmFibGVcIixbXCJJdGVyYWJsZVwiXSx0KTt2YXIgYT1uZXcgZShfb2JqZWN0U3ByZWFkKHtvYmplY3RNb2RlOnRydWV9LHIpKTt2YXIgbz1mYWxzZTthLl9yZWFkPWZ1bmN0aW9uKCl7aWYoIW8pe289dHJ1ZTtuZXh0KCl9fTtmdW5jdGlvbiBuZXh0KCl7cmV0dXJuIF9uZXh0Mi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gX25leHQyKCl7X25leHQyPV9hc3luY1RvR2VuZXJhdG9yKChmdW5jdGlvbiooKXt0cnl7dmFyIGU9eWllbGQgaS5uZXh0KCksdD1lLnZhbHVlLHI9ZS5kb25lO2lmKHIpe2EucHVzaChudWxsKX1lbHNlIGlmKGEucHVzaCh5aWVsZCB0KSl7bmV4dCgpfWVsc2V7bz1mYWxzZX19Y2F0Y2goZSl7YS5kZXN0cm95KGUpfX0pKTtyZXR1cm4gX25leHQyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gYX1lLmV4cG9ydHM9ZnJvbX0sNDQyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbjtmdW5jdGlvbiBvbmNlKGUpe3ZhciB0PWZhbHNlO3JldHVybiBmdW5jdGlvbigpe2lmKHQpcmV0dXJuO3Q9dHJ1ZTtlLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpfX12YXIgaT1yKDY0NikucSxhPWkuRVJSX01JU1NJTkdfQVJHUyxvPWkuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7ZnVuY3Rpb24gbm9vcChlKXtpZihlKXRocm93IGV9ZnVuY3Rpb24gaXNSZXF1ZXN0KGUpe3JldHVybiBlLnNldEhlYWRlciYmdHlwZW9mIGUuYWJvcnQ9PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gZGVzdHJveWVyKGUsdCxpLGEpe2E9b25jZShhKTt2YXIgcz1mYWxzZTtlLm9uKFwiY2xvc2VcIiwoZnVuY3Rpb24oKXtzPXRydWV9KSk7aWYobj09PXVuZGVmaW5lZCluPXIoNjk4KTtuKGUse3JlYWRhYmxlOnQsd3JpdGFibGU6aX0sKGZ1bmN0aW9uKGUpe2lmKGUpcmV0dXJuIGEoZSk7cz10cnVlO2EoKX0pKTt2YXIgZj1mYWxzZTtyZXR1cm4gZnVuY3Rpb24odCl7aWYocylyZXR1cm47aWYoZilyZXR1cm47Zj10cnVlO2lmKGlzUmVxdWVzdChlKSlyZXR1cm4gZS5hYm9ydCgpO2lmKHR5cGVvZiBlLmRlc3Ryb3k9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIGUuZGVzdHJveSgpO2EodHx8bmV3IG8oXCJwaXBlXCIpKX19ZnVuY3Rpb24gY2FsbChlKXtlKCl9ZnVuY3Rpb24gcGlwZShlLHQpe3JldHVybiBlLnBpcGUodCl9ZnVuY3Rpb24gcG9wQ2FsbGJhY2soZSl7aWYoIWUubGVuZ3RoKXJldHVybiBub29wO2lmKHR5cGVvZiBlW2UubGVuZ3RoLTFdIT09XCJmdW5jdGlvblwiKXJldHVybiBub29wO3JldHVybiBlLnBvcCgpfWZ1bmN0aW9uIHBpcGVsaW5lKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspe3Rbcl09YXJndW1lbnRzW3JdfXZhciBuPXBvcENhbGxiYWNrKHQpO2lmKEFycmF5LmlzQXJyYXkodFswXSkpdD10WzBdO2lmKHQubGVuZ3RoPDIpe3Rocm93IG5ldyBhKFwic3RyZWFtc1wiKX12YXIgaTt2YXIgbz10Lm1hcCgoZnVuY3Rpb24oZSxyKXt2YXIgYT1yPHQubGVuZ3RoLTE7dmFyIHM9cj4wO3JldHVybiBkZXN0cm95ZXIoZSxhLHMsKGZ1bmN0aW9uKGUpe2lmKCFpKWk9ZTtpZihlKW8uZm9yRWFjaChjYWxsKTtpZihhKXJldHVybjtvLmZvckVhY2goY2FsbCk7bihpKX0pKX0pKTtyZXR1cm4gdC5yZWR1Y2UocGlwZSl9ZS5leHBvcnRzPXBpcGVsaW5lfSw3NzY6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNjQ2KS5xLkVSUl9JTlZBTElEX09QVF9WQUxVRTtmdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShlLHQscil7cmV0dXJuIGUuaGlnaFdhdGVyTWFyayE9bnVsbD9lLmhpZ2hXYXRlck1hcms6dD9lW3JdOm51bGx9ZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhlLHQscixpKXt2YXIgYT1oaWdoV2F0ZXJNYXJrRnJvbSh0LGkscik7aWYoYSE9bnVsbCl7aWYoIShpc0Zpbml0ZShhKSYmTWF0aC5mbG9vcihhKT09PWEpfHxhPDApe3ZhciBvPWk/cjpcImhpZ2hXYXRlck1hcmtcIjt0aHJvdyBuZXcgbihvLGEpfXJldHVybiBNYXRoLmZsb29yKGEpfXJldHVybiBlLm9iamVjdE1vZGU/MTY6MTYqMTAyNH1lLmV4cG9ydHM9e2dldEhpZ2hXYXRlck1hcms6Z2V0SGlnaFdhdGVyTWFya319LDY3ODpmdW5jdGlvbihlLHQscil7ZS5leHBvcnRzPXIoNzgxKX0sNTU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMzAwKTt2YXIgaT1uLkJ1ZmZlcjtmdW5jdGlvbiBjb3B5UHJvcHMoZSx0KXtmb3IodmFyIHIgaW4gZSl7dFtyXT1lW3JdfX1pZihpLmZyb20mJmkuYWxsb2MmJmkuYWxsb2NVbnNhZmUmJmkuYWxsb2NVbnNhZmVTbG93KXtlLmV4cG9ydHM9bn1lbHNle2NvcHlQcm9wcyhuLHQpO3QuQnVmZmVyPVNhZmVCdWZmZXJ9ZnVuY3Rpb24gU2FmZUJ1ZmZlcihlLHQscil7cmV0dXJuIGkoZSx0LHIpfVNhZmVCdWZmZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpO2NvcHlQcm9wcyhpLFNhZmVCdWZmZXIpO1NhZmVCdWZmZXIuZnJvbT1mdW5jdGlvbihlLHQscil7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXJcIil9cmV0dXJuIGkoZSx0LHIpfTtTYWZlQnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUsdCxyKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpfXZhciBuPWkoZSk7aWYodCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtuLmZpbGwodCxyKX1lbHNle24uZmlsbCh0KX19ZWxzZXtuLmZpbGwoMCl9cmV0dXJuIG59O1NhZmVCdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKX1yZXR1cm4gaShlKX07U2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKX1yZXR1cm4gbi5TbG93QnVmZmVyKGUpfX0sMTczOmZ1bmN0aW9uKGUsdCxyKXtlLmV4cG9ydHM9U3RyZWFtO3ZhciBuPXIoMzYxKS5FdmVudEVtaXR0ZXI7dmFyIGk9cig3ODIpO2koU3RyZWFtLG4pO1N0cmVhbS5SZWFkYWJsZT1yKDcwOSk7U3RyZWFtLldyaXRhYmxlPXIoMzM3KTtTdHJlYW0uRHVwbGV4PXIoNDAzKTtTdHJlYW0uVHJhbnNmb3JtPXIoMTcwKTtTdHJlYW0uUGFzc1Rocm91Z2g9cig4ODkpO1N0cmVhbS5maW5pc2hlZD1yKDY5OCk7U3RyZWFtLnBpcGVsaW5lPXIoNDQyKTtTdHJlYW0uU3RyZWFtPVN0cmVhbTtmdW5jdGlvbiBTdHJlYW0oKXtuLmNhbGwodGhpcyl9U3RyZWFtLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztmdW5jdGlvbiBvbmRhdGEodCl7aWYoZS53cml0YWJsZSl7aWYoZmFsc2U9PT1lLndyaXRlKHQpJiZyLnBhdXNlKXtyLnBhdXNlKCl9fX1yLm9uKFwiZGF0YVwiLG9uZGF0YSk7ZnVuY3Rpb24gb25kcmFpbigpe2lmKHIucmVhZGFibGUmJnIucmVzdW1lKXtyLnJlc3VtZSgpfX1lLm9uKFwiZHJhaW5cIixvbmRyYWluKTtpZighZS5faXNTdGRpbyYmKCF0fHx0LmVuZCE9PWZhbHNlKSl7ci5vbihcImVuZFwiLG9uZW5kKTtyLm9uKFwiY2xvc2VcIixvbmNsb3NlKX12YXIgaT1mYWxzZTtmdW5jdGlvbiBvbmVuZCgpe2lmKGkpcmV0dXJuO2k9dHJ1ZTtlLmVuZCgpfWZ1bmN0aW9uIG9uY2xvc2UoKXtpZihpKXJldHVybjtpPXRydWU7aWYodHlwZW9mIGUuZGVzdHJveT09PVwiZnVuY3Rpb25cIillLmRlc3Ryb3koKX1mdW5jdGlvbiBvbmVycm9yKGUpe2NsZWFudXAoKTtpZihuLmxpc3RlbmVyQ291bnQodGhpcyxcImVycm9yXCIpPT09MCl7dGhyb3cgZX19ci5vbihcImVycm9yXCIsb25lcnJvcik7ZS5vbihcImVycm9yXCIsb25lcnJvcik7ZnVuY3Rpb24gY2xlYW51cCgpe3IucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsb25kYXRhKTtlLnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixvbmRyYWluKTtyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsb25lbmQpO3IucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLG9uY2xvc2UpO3IucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLG9uZXJyb3IpO2UucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLG9uZXJyb3IpO3IucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixjbGVhbnVwKTtyLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjbGVhbnVwKTtlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjbGVhbnVwKX1yLm9uKFwiZW5kXCIsY2xlYW51cCk7ci5vbihcImNsb3NlXCIsY2xlYW51cCk7ZS5vbihcImNsb3NlXCIsY2xlYW51cCk7ZS5lbWl0KFwicGlwZVwiLHIpO3JldHVybiBlfX0sNzA0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDU1KS5CdWZmZXI7dmFyIGk9bi5pc0VuY29kaW5nfHxmdW5jdGlvbihlKXtlPVwiXCIrZTtzd2l0Y2goZSYmZS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOmNhc2VcInJhd1wiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07ZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGUpe2lmKCFlKXJldHVyblwidXRmOFwiO3ZhciB0O3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm5cInV0ZjhcIjtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm5cInV0ZjE2bGVcIjtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm5cImxhdGluMVwiO2Nhc2VcImJhc2U2NFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwiaGV4XCI6cmV0dXJuIGU7ZGVmYXVsdDppZih0KXJldHVybjtlPShcIlwiK2UpLnRvTG93ZXJDYXNlKCk7dD10cnVlfX19ZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZSl7dmFyIHQ9X25vcm1hbGl6ZUVuY29kaW5nKGUpO2lmKHR5cGVvZiB0IT09XCJzdHJpbmdcIiYmKG4uaXNFbmNvZGluZz09PWl8fCFpKGUpKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtyZXR1cm4gdHx8ZX10LnM9U3RyaW5nRGVjb2RlcjtmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGUpe3RoaXMuZW5jb2Rpbmc9bm9ybWFsaXplRW5jb2RpbmcoZSk7dmFyIHQ7c3dpdGNoKHRoaXMuZW5jb2Rpbmcpe2Nhc2VcInV0ZjE2bGVcIjp0aGlzLnRleHQ9dXRmMTZUZXh0O3RoaXMuZW5kPXV0ZjE2RW5kO3Q9NDticmVhaztjYXNlXCJ1dGY4XCI6dGhpcy5maWxsTGFzdD11dGY4RmlsbExhc3Q7dD00O2JyZWFrO2Nhc2VcImJhc2U2NFwiOnRoaXMudGV4dD1iYXNlNjRUZXh0O3RoaXMuZW5kPWJhc2U2NEVuZDt0PTM7YnJlYWs7ZGVmYXVsdDp0aGlzLndyaXRlPXNpbXBsZVdyaXRlO3RoaXMuZW5kPXNpbXBsZUVuZDtyZXR1cm59dGhpcy5sYXN0TmVlZD0wO3RoaXMubGFzdFRvdGFsPTA7dGhpcy5sYXN0Q2hhcj1uLmFsbG9jVW5zYWZlKHQpfVN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIlwiO3ZhciB0O3ZhciByO2lmKHRoaXMubGFzdE5lZWQpe3Q9dGhpcy5maWxsTGFzdChlKTtpZih0PT09dW5kZWZpbmVkKXJldHVyblwiXCI7cj10aGlzLmxhc3ROZWVkO3RoaXMubGFzdE5lZWQ9MH1lbHNle3I9MH1pZihyPGUubGVuZ3RoKXJldHVybiB0P3QrdGhpcy50ZXh0KGUscik6dGhpcy50ZXh0KGUscik7cmV0dXJuIHR8fFwiXCJ9O1N0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZD11dGY4RW5kO1N0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQ9dXRmOFRleHQ7U3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24oZSl7aWYodGhpcy5sYXN0TmVlZDw9ZS5sZW5ndGgpe2UuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCx0aGlzLmxhc3ROZWVkKTtyZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLDAsdGhpcy5sYXN0VG90YWwpfWUuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCxlLmxlbmd0aCk7dGhpcy5sYXN0TmVlZC09ZS5sZW5ndGh9O2Z1bmN0aW9uIHV0ZjhDaGVja0J5dGUoZSl7aWYoZTw9MTI3KXJldHVybiAwO2Vsc2UgaWYoZT4+NT09PTYpcmV0dXJuIDI7ZWxzZSBpZihlPj40PT09MTQpcmV0dXJuIDM7ZWxzZSBpZihlPj4zPT09MzApcmV0dXJuIDQ7cmV0dXJuIGU+PjY9PT0yPy0xOi0yfWZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoZSx0LHIpe3ZhciBuPXQubGVuZ3RoLTE7aWYobjxyKXJldHVybiAwO3ZhciBpPXV0ZjhDaGVja0J5dGUodFtuXSk7aWYoaT49MCl7aWYoaT4wKWUubGFzdE5lZWQ9aS0xO3JldHVybiBpfWlmKC0tbjxyfHxpPT09LTIpcmV0dXJuIDA7aT11dGY4Q2hlY2tCeXRlKHRbbl0pO2lmKGk+PTApe2lmKGk+MCllLmxhc3ROZWVkPWktMjtyZXR1cm4gaX1pZigtLW48cnx8aT09PS0yKXJldHVybiAwO2k9dXRmOENoZWNrQnl0ZSh0W25dKTtpZihpPj0wKXtpZihpPjApe2lmKGk9PT0yKWk9MDtlbHNlIGUubGFzdE5lZWQ9aS0zfXJldHVybiBpfXJldHVybiAwfWZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoZSx0LHIpe2lmKCh0WzBdJjE5MikhPT0xMjgpe2UubGFzdE5lZWQ9MDtyZXR1cm5cIu+/vVwifWlmKGUubGFzdE5lZWQ+MSYmdC5sZW5ndGg+MSl7aWYoKHRbMV0mMTkyKSE9PTEyOCl7ZS5sYXN0TmVlZD0xO3JldHVyblwi77+9XCJ9aWYoZS5sYXN0TmVlZD4yJiZ0Lmxlbmd0aD4yKXtpZigodFsyXSYxOTIpIT09MTI4KXtlLmxhc3ROZWVkPTI7cmV0dXJuXCLvv71cIn19fX1mdW5jdGlvbiB1dGY4RmlsbExhc3QoZSl7dmFyIHQ9dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDt2YXIgcj11dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsZSx0KTtpZihyIT09dW5kZWZpbmVkKXJldHVybiByO2lmKHRoaXMubGFzdE5lZWQ8PWUubGVuZ3RoKXtlLmNvcHkodGhpcy5sYXN0Q2hhcix0LDAsdGhpcy5sYXN0TmVlZCk7cmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKX1lLmNvcHkodGhpcy5sYXN0Q2hhcix0LDAsZS5sZW5ndGgpO3RoaXMubGFzdE5lZWQtPWUubGVuZ3RofWZ1bmN0aW9uIHV0ZjhUZXh0KGUsdCl7dmFyIHI9dXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLGUsdCk7aWYoIXRoaXMubGFzdE5lZWQpcmV0dXJuIGUudG9TdHJpbmcoXCJ1dGY4XCIsdCk7dGhpcy5sYXN0VG90YWw9cjt2YXIgbj1lLmxlbmd0aC0oci10aGlzLmxhc3ROZWVkKTtlLmNvcHkodGhpcy5sYXN0Q2hhciwwLG4pO3JldHVybiBlLnRvU3RyaW5nKFwidXRmOFwiLHQsbil9ZnVuY3Rpb24gdXRmOEVuZChlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7aWYodGhpcy5sYXN0TmVlZClyZXR1cm4gdCtcIu+/vVwiO3JldHVybiB0fWZ1bmN0aW9uIHV0ZjE2VGV4dChlLHQpe2lmKChlLmxlbmd0aC10KSUyPT09MCl7dmFyIHI9ZS50b1N0cmluZyhcInV0ZjE2bGVcIix0KTtpZihyKXt2YXIgbj1yLmNoYXJDb2RlQXQoci5sZW5ndGgtMSk7aWYobj49NTUyOTYmJm48PTU2MzE5KXt0aGlzLmxhc3ROZWVkPTI7dGhpcy5sYXN0VG90YWw9NDt0aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMl07dGhpcy5sYXN0Q2hhclsxXT1lW2UubGVuZ3RoLTFdO3JldHVybiByLnNsaWNlKDAsLTEpfX1yZXR1cm4gcn10aGlzLmxhc3ROZWVkPTE7dGhpcy5sYXN0VG90YWw9Mjt0aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMV07cmV0dXJuIGUudG9TdHJpbmcoXCJ1dGYxNmxlXCIsdCxlLmxlbmd0aC0xKX1mdW5jdGlvbiB1dGYxNkVuZChlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7aWYodGhpcy5sYXN0TmVlZCl7dmFyIHI9dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDtyZXR1cm4gdCt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwidXRmMTZsZVwiLDAscil9cmV0dXJuIHR9ZnVuY3Rpb24gYmFzZTY0VGV4dChlLHQpe3ZhciByPShlLmxlbmd0aC10KSUzO2lmKHI9PT0wKXJldHVybiBlLnRvU3RyaW5nKFwiYmFzZTY0XCIsdCk7dGhpcy5sYXN0TmVlZD0zLXI7dGhpcy5sYXN0VG90YWw9MztpZihyPT09MSl7dGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTFdfWVsc2V7dGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTJdO3RoaXMubGFzdENoYXJbMV09ZVtlLmxlbmd0aC0xXX1yZXR1cm4gZS50b1N0cmluZyhcImJhc2U2NFwiLHQsZS5sZW5ndGgtcil9ZnVuY3Rpb24gYmFzZTY0RW5kKGUpe3ZhciB0PWUmJmUubGVuZ3RoP3RoaXMud3JpdGUoZSk6XCJcIjtpZih0aGlzLmxhc3ROZWVkKXJldHVybiB0K3RoaXMubGFzdENoYXIudG9TdHJpbmcoXCJiYXNlNjRcIiwwLDMtdGhpcy5sYXN0TmVlZCk7cmV0dXJuIHR9ZnVuY3Rpb24gc2ltcGxlV3JpdGUoZSl7cmV0dXJuIGUudG9TdHJpbmcodGhpcy5lbmNvZGluZyl9ZnVuY3Rpb24gc2ltcGxlRW5kKGUpe3JldHVybiBlJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCJ9fSw3Njk6ZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWRlcHJlY2F0ZTtmdW5jdGlvbiBkZXByZWNhdGUoZSx0KXtpZihjb25maWcoXCJub0RlcHJlY2F0aW9uXCIpKXtyZXR1cm4gZX12YXIgcj1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIXIpe2lmKGNvbmZpZyhcInRocm93RGVwcmVjYXRpb25cIikpe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKGNvbmZpZyhcInRyYWNlRGVwcmVjYXRpb25cIikpe2NvbnNvbGUudHJhY2UodCl9ZWxzZXtjb25zb2xlLndhcm4odCl9cj10cnVlfXJldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH1mdW5jdGlvbiBjb25maWcoZSl7dHJ5e2lmKCFnbG9iYWwubG9jYWxTdG9yYWdlKXJldHVybiBmYWxzZX1jYXRjaChlKXtyZXR1cm4gZmFsc2V9dmFyIHQ9Z2xvYmFsLmxvY2FsU3RvcmFnZVtlXTtpZihudWxsPT10KXJldHVybiBmYWxzZTtyZXR1cm4gU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCk9PT1cInRydWVcIn19LDMwMDpmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcImJ1ZmZlclwiKX0sMzYxOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwiZXZlbnRzXCIpfSw3ODE6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyfSw4Mzc6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIGE9dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTthPWZhbHNlfWZpbmFsbHl7aWYoYSlkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Myk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/stream-browserify/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/typedarray-to-buffer/index.js":
/*!****************************************************!*\
  !*** ./node_modules/typedarray-to-buffer/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/*! typedarray-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  return ArrayBuffer.isView(arr)\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back\n    // new Buffer, respecting the \"view\", i.e. byteOffset and byteLength\n    ? Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength)\n    // Pass through all other types to `Buffer.from`\n    : Buffer.from(arr)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXRvLWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNO0FBQ1o7QUFDQSxNQUFNLE1BQU07QUFDWiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHR5cGVkYXJyYXktdG8tYnVmZmVyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgdHlwZWRhcnJheS10by1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qKlxuICogQ29udmVydCBhIHR5cGVkIGFycmF5IHRvIGEgQnVmZmVyIHdpdGhvdXQgYSBjb3B5XG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgdHlwZWRhcnJheS10by1idWZmZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0eXBlZGFycmF5VG9CdWZmZXIgKGFycikge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycilcbiAgICAvLyBUbyBhdm9pZCBhIGNvcHksIHVzZSB0aGUgdHlwZWQgYXJyYXkncyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIHRvIGJhY2tcbiAgICAvLyBuZXcgQnVmZmVyLCByZXNwZWN0aW5nIHRoZSBcInZpZXdcIiwgaS5lLiBieXRlT2Zmc2V0IGFuZCBieXRlTGVuZ3RoXG4gICAgPyBCdWZmZXIuZnJvbShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpXG4gICAgLy8gUGFzcyB0aHJvdWdoIGFsbCBvdGhlciB0eXBlcyB0byBgQnVmZmVyLmZyb21gXG4gICAgOiBCdWZmZXIuZnJvbShhcnIpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/typedarray-to-buffer/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcdXRpbFxcbm9kZV9tb2R1bGVzXFxpbmhlcml0c1xcaW5oZXJpdHNfYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/util/node_modules/inherits/inherits_browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHV0aWxcXHN1cHBvcnRcXGlzQnVmZmVyQnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/util/support/isBufferBrowser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"(pages-dir-browser)/./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"(pages-dir-browser)/./node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxrQkFBa0IscUJBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxPQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQSxRQUFRLFNBQVMsT0FBTztBQUN4QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsc0lBQWdEOztBQUVoRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSwySUFBc0M7O0FBRXRDLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHV0aWxcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/util/util.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/constants.js":
/*!************************************************!*\
  !*** ./node_modules/wasi-js/dist/constants.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/*\n\nThis project is based from the Node implementation made by Gus Caplan\nhttps://github.com/devsnek/node-wasi\nHowever, JavaScript WASI is focused on:\n * Bringing WASI to the Browsers\n * Make easy to plug different filesystems\n * Provide a type-safe api using Typescript\n\n\nCopyright 2019 Gus Caplan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WASI_ENOMSG = exports.WASI_ENOMEM = exports.WASI_ENOLINK = exports.WASI_ENOLCK = exports.WASI_ENOEXEC = exports.WASI_ENOENT = exports.WASI_ENODEV = exports.WASI_ENOBUFS = exports.WASI_ENFILE = exports.WASI_ENETUNREACH = exports.WASI_ENETRESET = exports.WASI_ENETDOWN = exports.WASI_ENAMETOOLONG = exports.WASI_EMULTIHOP = exports.WASI_EMSGSIZE = exports.WASI_EMLINK = exports.WASI_EMFILE = exports.WASI_ELOOP = exports.WASI_EISDIR = exports.WASI_EISCONN = exports.WASI_EIO = exports.WASI_EINVAL = exports.WASI_EINTR = exports.WASI_EINPROGRESS = exports.WASI_EILSEQ = exports.WASI_EIDRM = exports.WASI_EHOSTUNREACH = exports.WASI_EFBIG = exports.WASI_EFAULT = exports.WASI_EEXIST = exports.WASI_EDQUOT = exports.WASI_EDOM = exports.WASI_EDESTADDRREQ = exports.WASI_EDEADLK = exports.WASI_ECONNRESET = exports.WASI_ECONNREFUSED = exports.WASI_ECONNABORTED = exports.WASI_ECHILD = exports.WASI_ECANCELED = exports.WASI_EBUSY = exports.WASI_EBADMSG = exports.WASI_EBADF = exports.WASI_EALREADY = exports.WASI_EAGAIN = exports.WASI_EAFNOSUPPORT = exports.WASI_EADDRNOTAVAIL = exports.WASI_EADDRINUSE = exports.WASI_EACCES = exports.WASI_E2BIG = exports.WASI_ESUCCESS = void 0;\nexports.WASI_SIGVTALRM = exports.WASI_SIGUSR2 = exports.WASI_SIGUSR1 = exports.WASI_SIGURG = exports.WASI_SIGTTOU = exports.WASI_SIGTTIN = exports.WASI_SIGTSTP = exports.WASI_SIGTRAP = exports.WASI_SIGTERM = exports.WASI_SIGSTOP = exports.WASI_SIGSEGV = exports.WASI_SIGQUIT = exports.WASI_SIGPIPE = exports.WASI_SIGKILL = exports.WASI_SIGINT = exports.WASI_SIGILL = exports.WASI_SIGHUP = exports.WASI_SIGFPE = exports.WASI_SIGCONT = exports.WASI_SIGCHLD = exports.WASI_SIGBUS = exports.WASI_SIGALRM = exports.WASI_SIGABRT = exports.WASI_ENOTCAPABLE = exports.WASI_EXDEV = exports.WASI_ETXTBSY = exports.WASI_ETIMEDOUT = exports.WASI_ESTALE = exports.WASI_ESRCH = exports.WASI_ESPIPE = exports.WASI_EROFS = exports.WASI_ERANGE = exports.WASI_EPROTOTYPE = exports.WASI_EPROTONOSUPPORT = exports.WASI_EPROTO = exports.WASI_EPIPE = exports.WASI_EPERM = exports.WASI_EOWNERDEAD = exports.WASI_EOVERFLOW = exports.WASI_ENXIO = exports.WASI_ENOTTY = exports.WASI_ENOTSUP = exports.WASI_ENOTSOCK = exports.WASI_ENOTRECOVERABLE = exports.WASI_ENOTEMPTY = exports.WASI_ENOTDIR = exports.WASI_ENOTCONN = exports.WASI_ENOSYS = exports.WASI_ENOSPC = exports.WASI_ENOPROTOOPT = void 0;\nexports.RIGHTS_REGULAR_FILE_BASE = exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL = exports.WASI_RIGHT_SOCK_SHUTDOWN = exports.WASI_RIGHT_POLL_FD_READWRITE = exports.WASI_RIGHT_PATH_UNLINK_FILE = exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = exports.WASI_RIGHT_PATH_SYMLINK = exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = exports.WASI_RIGHT_FD_FILESTAT_GET = exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = exports.WASI_RIGHT_PATH_FILESTAT_GET = exports.WASI_RIGHT_PATH_RENAME_TARGET = exports.WASI_RIGHT_PATH_RENAME_SOURCE = exports.WASI_RIGHT_PATH_READLINK = exports.WASI_RIGHT_FD_READDIR = exports.WASI_RIGHT_PATH_OPEN = exports.WASI_RIGHT_PATH_LINK_TARGET = exports.WASI_RIGHT_PATH_LINK_SOURCE = exports.WASI_RIGHT_PATH_CREATE_FILE = exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = exports.WASI_RIGHT_FD_ALLOCATE = exports.WASI_RIGHT_FD_ADVISE = exports.WASI_RIGHT_FD_WRITE = exports.WASI_RIGHT_FD_TELL = exports.WASI_RIGHT_FD_SYNC = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = exports.WASI_RIGHT_FD_SEEK = exports.WASI_RIGHT_FD_READ = exports.WASI_RIGHT_FD_DATASYNC = exports.WASI_FDFLAG_SYNC = exports.WASI_FDFLAG_RSYNC = exports.WASI_FDFLAG_NONBLOCK = exports.WASI_FDFLAG_DSYNC = exports.WASI_FDFLAG_APPEND = exports.WASI_FILETYPE_SYMBOLIC_LINK = exports.WASI_FILETYPE_SOCKET_STREAM = exports.WASI_FILETYPE_SOCKET_DGRAM = exports.WASI_FILETYPE_REGULAR_FILE = exports.WASI_FILETYPE_DIRECTORY = exports.WASI_FILETYPE_CHARACTER_DEVICE = exports.WASI_FILETYPE_BLOCK_DEVICE = exports.WASI_FILETYPE_UNKNOWN = exports.WASI_SIGXFSZ = exports.WASI_SIGXCPU = void 0;\nexports.SIGNAL_MAP = exports.ERROR_MAP = exports.WASI_WHENCE_END = exports.WASI_WHENCE_CUR = exports.WASI_WHENCE_SET = exports.WASI_STDERR_FILENO = exports.WASI_STDOUT_FILENO = exports.WASI_STDIN_FILENO = exports.WASI_DIRCOOKIE_START = exports.WASI_PREOPENTYPE_DIR = exports.WASI_O_TRUNC = exports.WASI_O_EXCL = exports.WASI_O_DIRECTORY = exports.WASI_O_CREAT = exports.WASI_FILESTAT_SET_MTIM_NOW = exports.WASI_FILESTAT_SET_MTIM = exports.WASI_FILESTAT_SET_ATIM_NOW = exports.WASI_FILESTAT_SET_ATIM = exports.WASI_EVENTTYPE_FD_WRITE = exports.WASI_EVENTTYPE_FD_READ = exports.WASI_EVENTTYPE_CLOCK = exports.WASI_CLOCK_THREAD_CPUTIME_ID = exports.WASI_CLOCK_PROCESS_CPUTIME_ID = exports.WASI_CLOCK_MONOTONIC = exports.WASI_CLOCK_REALTIME = exports.RIGHTS_TTY_INHERITING = exports.RIGHTS_TTY_BASE = exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_SOCKET_BASE = exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE = exports.RIGHTS_REGULAR_FILE_INHERITING = void 0;\nexports.WASI_ESUCCESS = 0;\nexports.WASI_E2BIG = 1;\nexports.WASI_EACCES = 2;\nexports.WASI_EADDRINUSE = 3;\nexports.WASI_EADDRNOTAVAIL = 4;\nexports.WASI_EAFNOSUPPORT = 5;\nexports.WASI_EAGAIN = 6;\nexports.WASI_EALREADY = 7;\nexports.WASI_EBADF = 8;\nexports.WASI_EBADMSG = 9;\nexports.WASI_EBUSY = 10;\nexports.WASI_ECANCELED = 11;\nexports.WASI_ECHILD = 12;\nexports.WASI_ECONNABORTED = 13;\nexports.WASI_ECONNREFUSED = 14;\nexports.WASI_ECONNRESET = 15;\nexports.WASI_EDEADLK = 16;\nexports.WASI_EDESTADDRREQ = 17;\nexports.WASI_EDOM = 18;\nexports.WASI_EDQUOT = 19;\nexports.WASI_EEXIST = 20;\nexports.WASI_EFAULT = 21;\nexports.WASI_EFBIG = 22;\nexports.WASI_EHOSTUNREACH = 23;\nexports.WASI_EIDRM = 24;\nexports.WASI_EILSEQ = 25;\nexports.WASI_EINPROGRESS = 26;\nexports.WASI_EINTR = 27;\nexports.WASI_EINVAL = 28;\nexports.WASI_EIO = 29;\nexports.WASI_EISCONN = 30;\nexports.WASI_EISDIR = 31;\nexports.WASI_ELOOP = 32;\nexports.WASI_EMFILE = 33;\nexports.WASI_EMLINK = 34;\nexports.WASI_EMSGSIZE = 35;\nexports.WASI_EMULTIHOP = 36;\nexports.WASI_ENAMETOOLONG = 37;\nexports.WASI_ENETDOWN = 38;\nexports.WASI_ENETRESET = 39;\nexports.WASI_ENETUNREACH = 40;\nexports.WASI_ENFILE = 41;\nexports.WASI_ENOBUFS = 42;\nexports.WASI_ENODEV = 43;\nexports.WASI_ENOENT = 44;\nexports.WASI_ENOEXEC = 45;\nexports.WASI_ENOLCK = 46;\nexports.WASI_ENOLINK = 47;\nexports.WASI_ENOMEM = 48;\nexports.WASI_ENOMSG = 49;\nexports.WASI_ENOPROTOOPT = 50;\nexports.WASI_ENOSPC = 51;\nexports.WASI_ENOSYS = 52;\nexports.WASI_ENOTCONN = 53;\nexports.WASI_ENOTDIR = 54;\nexports.WASI_ENOTEMPTY = 55;\nexports.WASI_ENOTRECOVERABLE = 56;\nexports.WASI_ENOTSOCK = 57;\nexports.WASI_ENOTSUP = 58;\nexports.WASI_ENOTTY = 59;\nexports.WASI_ENXIO = 60;\nexports.WASI_EOVERFLOW = 61;\nexports.WASI_EOWNERDEAD = 62;\nexports.WASI_EPERM = 63;\nexports.WASI_EPIPE = 64;\nexports.WASI_EPROTO = 65;\nexports.WASI_EPROTONOSUPPORT = 66;\nexports.WASI_EPROTOTYPE = 67;\nexports.WASI_ERANGE = 68;\nexports.WASI_EROFS = 69;\nexports.WASI_ESPIPE = 70;\nexports.WASI_ESRCH = 71;\nexports.WASI_ESTALE = 72;\nexports.WASI_ETIMEDOUT = 73;\nexports.WASI_ETXTBSY = 74;\nexports.WASI_EXDEV = 75;\nexports.WASI_ENOTCAPABLE = 76;\nexports.WASI_SIGABRT = 0;\nexports.WASI_SIGALRM = 1;\nexports.WASI_SIGBUS = 2;\nexports.WASI_SIGCHLD = 3;\nexports.WASI_SIGCONT = 4;\nexports.WASI_SIGFPE = 5;\nexports.WASI_SIGHUP = 6;\nexports.WASI_SIGILL = 7;\nexports.WASI_SIGINT = 8;\nexports.WASI_SIGKILL = 9;\nexports.WASI_SIGPIPE = 10;\nexports.WASI_SIGQUIT = 11;\nexports.WASI_SIGSEGV = 12;\nexports.WASI_SIGSTOP = 13;\nexports.WASI_SIGTERM = 14;\nexports.WASI_SIGTRAP = 15;\nexports.WASI_SIGTSTP = 16;\nexports.WASI_SIGTTIN = 17;\nexports.WASI_SIGTTOU = 18;\nexports.WASI_SIGURG = 19;\nexports.WASI_SIGUSR1 = 20;\nexports.WASI_SIGUSR2 = 21;\nexports.WASI_SIGVTALRM = 22;\nexports.WASI_SIGXCPU = 23;\nexports.WASI_SIGXFSZ = 24;\nexports.WASI_FILETYPE_UNKNOWN = 0;\nexports.WASI_FILETYPE_BLOCK_DEVICE = 1;\nexports.WASI_FILETYPE_CHARACTER_DEVICE = 2;\nexports.WASI_FILETYPE_DIRECTORY = 3;\nexports.WASI_FILETYPE_REGULAR_FILE = 4;\nexports.WASI_FILETYPE_SOCKET_DGRAM = 5;\nexports.WASI_FILETYPE_SOCKET_STREAM = 6;\nexports.WASI_FILETYPE_SYMBOLIC_LINK = 7;\nexports.WASI_FDFLAG_APPEND = 0x0001;\nexports.WASI_FDFLAG_DSYNC = 0x0002;\nexports.WASI_FDFLAG_NONBLOCK = 0x0004;\nexports.WASI_FDFLAG_RSYNC = 0x0008;\nexports.WASI_FDFLAG_SYNC = 0x0010;\nexports.WASI_RIGHT_FD_DATASYNC = BigInt(0x0000000000000001);\nexports.WASI_RIGHT_FD_READ = BigInt(0x0000000000000002);\nexports.WASI_RIGHT_FD_SEEK = BigInt(0x0000000000000004);\nexports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = BigInt(0x0000000000000008);\nexports.WASI_RIGHT_FD_SYNC = BigInt(0x0000000000000010);\nexports.WASI_RIGHT_FD_TELL = BigInt(0x0000000000000020);\nexports.WASI_RIGHT_FD_WRITE = BigInt(0x0000000000000040);\nexports.WASI_RIGHT_FD_ADVISE = BigInt(0x0000000000000080);\nexports.WASI_RIGHT_FD_ALLOCATE = BigInt(0x0000000000000100);\nexports.WASI_RIGHT_PATH_CREATE_DIRECTORY = BigInt(0x0000000000000200);\nexports.WASI_RIGHT_PATH_CREATE_FILE = BigInt(0x0000000000000400);\nexports.WASI_RIGHT_PATH_LINK_SOURCE = BigInt(0x0000000000000800);\nexports.WASI_RIGHT_PATH_LINK_TARGET = BigInt(0x0000000000001000);\nexports.WASI_RIGHT_PATH_OPEN = BigInt(0x0000000000002000);\nexports.WASI_RIGHT_FD_READDIR = BigInt(0x0000000000004000);\nexports.WASI_RIGHT_PATH_READLINK = BigInt(0x0000000000008000);\nexports.WASI_RIGHT_PATH_RENAME_SOURCE = BigInt(0x0000000000010000);\nexports.WASI_RIGHT_PATH_RENAME_TARGET = BigInt(0x0000000000020000);\nexports.WASI_RIGHT_PATH_FILESTAT_GET = BigInt(0x0000000000040000);\nexports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = BigInt(0x0000000000080000);\nexports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = BigInt(0x0000000000100000);\nexports.WASI_RIGHT_FD_FILESTAT_GET = BigInt(0x0000000000200000);\nexports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = BigInt(0x0000000000400000);\nexports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = BigInt(0x0000000000800000);\nexports.WASI_RIGHT_PATH_SYMLINK = BigInt(0x0000000001000000);\nexports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = BigInt(0x0000000002000000);\nexports.WASI_RIGHT_PATH_UNLINK_FILE = BigInt(0x0000000004000000);\nexports.WASI_RIGHT_POLL_FD_READWRITE = BigInt(0x0000000008000000);\nexports.WASI_RIGHT_SOCK_SHUTDOWN = BigInt(0x0000000010000000);\nexports.RIGHTS_ALL = exports.WASI_RIGHT_FD_DATASYNC |\n    exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_SEEK |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_TELL |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_FD_ALLOCATE |\n    exports.WASI_RIGHT_PATH_CREATE_DIRECTORY |\n    exports.WASI_RIGHT_PATH_CREATE_FILE |\n    exports.WASI_RIGHT_PATH_LINK_SOURCE |\n    exports.WASI_RIGHT_PATH_LINK_TARGET |\n    exports.WASI_RIGHT_PATH_OPEN |\n    exports.WASI_RIGHT_FD_READDIR |\n    exports.WASI_RIGHT_PATH_READLINK |\n    exports.WASI_RIGHT_PATH_RENAME_SOURCE |\n    exports.WASI_RIGHT_PATH_RENAME_TARGET |\n    exports.WASI_RIGHT_PATH_FILESTAT_GET |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_SYMLINK |\n    exports.WASI_RIGHT_PATH_UNLINK_FILE |\n    exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY |\n    exports.WASI_RIGHT_POLL_FD_READWRITE |\n    exports.WASI_RIGHT_SOCK_SHUTDOWN;\nexports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL;\nexports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_ALL;\nexports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_REGULAR_FILE_BASE = exports.WASI_RIGHT_FD_DATASYNC |\n    exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_SEEK |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_TELL |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_FD_ALLOCATE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_REGULAR_FILE_INHERITING = BigInt(0);\nexports.RIGHTS_DIRECTORY_BASE = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_PATH_CREATE_DIRECTORY |\n    exports.WASI_RIGHT_PATH_CREATE_FILE |\n    exports.WASI_RIGHT_PATH_LINK_SOURCE |\n    exports.WASI_RIGHT_PATH_LINK_TARGET |\n    exports.WASI_RIGHT_PATH_OPEN |\n    exports.WASI_RIGHT_FD_READDIR |\n    exports.WASI_RIGHT_PATH_READLINK |\n    exports.WASI_RIGHT_PATH_RENAME_SOURCE |\n    exports.WASI_RIGHT_PATH_RENAME_TARGET |\n    exports.WASI_RIGHT_PATH_FILESTAT_GET |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_PATH_SYMLINK |\n    exports.WASI_RIGHT_PATH_UNLINK_FILE |\n    exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE | exports.RIGHTS_REGULAR_FILE_BASE;\nexports.RIGHTS_SOCKET_BASE = exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_POLL_FD_READWRITE |\n    exports.WASI_RIGHT_SOCK_SHUTDOWN;\nexports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_TTY_BASE = exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_TTY_INHERITING = BigInt(0);\nexports.WASI_CLOCK_REALTIME = 0;\nexports.WASI_CLOCK_MONOTONIC = 1;\nexports.WASI_CLOCK_PROCESS_CPUTIME_ID = 2;\nexports.WASI_CLOCK_THREAD_CPUTIME_ID = 3;\nexports.WASI_EVENTTYPE_CLOCK = 0;\nexports.WASI_EVENTTYPE_FD_READ = 1;\nexports.WASI_EVENTTYPE_FD_WRITE = 2;\nexports.WASI_FILESTAT_SET_ATIM = 1 << 0;\nexports.WASI_FILESTAT_SET_ATIM_NOW = 1 << 1;\nexports.WASI_FILESTAT_SET_MTIM = 1 << 2;\nexports.WASI_FILESTAT_SET_MTIM_NOW = 1 << 3;\nexports.WASI_O_CREAT = 1 << 0;\nexports.WASI_O_DIRECTORY = 1 << 1;\nexports.WASI_O_EXCL = 1 << 2;\nexports.WASI_O_TRUNC = 1 << 3;\nexports.WASI_PREOPENTYPE_DIR = 0;\nexports.WASI_DIRCOOKIE_START = 0;\nexports.WASI_STDIN_FILENO = 0;\nexports.WASI_STDOUT_FILENO = 1;\nexports.WASI_STDERR_FILENO = 2;\nexports.WASI_WHENCE_SET = 0;\nexports.WASI_WHENCE_CUR = 1;\nexports.WASI_WHENCE_END = 2;\n// http://man7.org/linux/man-pages/man3/errno.3.html\nexports.ERROR_MAP = {\n    E2BIG: exports.WASI_E2BIG,\n    EACCES: exports.WASI_EACCES,\n    EADDRINUSE: exports.WASI_EADDRINUSE,\n    EADDRNOTAVAIL: exports.WASI_EADDRNOTAVAIL,\n    EAFNOSUPPORT: exports.WASI_EAFNOSUPPORT,\n    EALREADY: exports.WASI_EALREADY,\n    EAGAIN: exports.WASI_EAGAIN,\n    // EBADE: WASI_EBADE,\n    EBADF: exports.WASI_EBADF,\n    // EBADFD: WASI_EBADFD,\n    EBADMSG: exports.WASI_EBADMSG,\n    // EBADR: WASI_EBADR,\n    // EBADRQC: WASI_EBADRQC,\n    // EBADSLT: WASI_EBADSLT,\n    EBUSY: exports.WASI_EBUSY,\n    ECANCELED: exports.WASI_ECANCELED,\n    ECHILD: exports.WASI_ECHILD,\n    // ECHRNG: WASI_ECHRNG,\n    // ECOMM: WASI_ECOMM,\n    ECONNABORTED: exports.WASI_ECONNABORTED,\n    ECONNREFUSED: exports.WASI_ECONNREFUSED,\n    ECONNRESET: exports.WASI_ECONNRESET,\n    EDEADLOCK: exports.WASI_EDEADLK,\n    EDESTADDRREQ: exports.WASI_EDESTADDRREQ,\n    EDOM: exports.WASI_EDOM,\n    EDQUOT: exports.WASI_EDQUOT,\n    EEXIST: exports.WASI_EEXIST,\n    EFAULT: exports.WASI_EFAULT,\n    EFBIG: exports.WASI_EFBIG,\n    EHOSTDOWN: exports.WASI_EHOSTUNREACH,\n    EHOSTUNREACH: exports.WASI_EHOSTUNREACH,\n    // EHWPOISON: WASI_EHWPOISON,\n    EIDRM: exports.WASI_EIDRM,\n    EILSEQ: exports.WASI_EILSEQ,\n    EINPROGRESS: exports.WASI_EINPROGRESS,\n    EINTR: exports.WASI_EINTR,\n    EINVAL: exports.WASI_EINVAL,\n    EIO: exports.WASI_EIO,\n    EISCONN: exports.WASI_EISCONN,\n    EISDIR: exports.WASI_EISDIR,\n    ELOOP: exports.WASI_ELOOP,\n    EMFILE: exports.WASI_EMFILE,\n    EMLINK: exports.WASI_EMLINK,\n    EMSGSIZE: exports.WASI_EMSGSIZE,\n    EMULTIHOP: exports.WASI_EMULTIHOP,\n    ENAMETOOLONG: exports.WASI_ENAMETOOLONG,\n    ENETDOWN: exports.WASI_ENETDOWN,\n    ENETRESET: exports.WASI_ENETRESET,\n    ENETUNREACH: exports.WASI_ENETUNREACH,\n    ENFILE: exports.WASI_ENFILE,\n    ENOBUFS: exports.WASI_ENOBUFS,\n    ENODEV: exports.WASI_ENODEV,\n    ENOENT: exports.WASI_ENOENT,\n    ENOEXEC: exports.WASI_ENOEXEC,\n    ENOLCK: exports.WASI_ENOLCK,\n    ENOLINK: exports.WASI_ENOLINK,\n    ENOMEM: exports.WASI_ENOMEM,\n    ENOMSG: exports.WASI_ENOMSG,\n    ENOPROTOOPT: exports.WASI_ENOPROTOOPT,\n    ENOSPC: exports.WASI_ENOSPC,\n    ENOSYS: exports.WASI_ENOSYS,\n    ENOTCONN: exports.WASI_ENOTCONN,\n    ENOTDIR: exports.WASI_ENOTDIR,\n    ENOTEMPTY: exports.WASI_ENOTEMPTY,\n    ENOTRECOVERABLE: exports.WASI_ENOTRECOVERABLE,\n    ENOTSOCK: exports.WASI_ENOTSOCK,\n    ENOTTY: exports.WASI_ENOTTY,\n    ENXIO: exports.WASI_ENXIO,\n    EOVERFLOW: exports.WASI_EOVERFLOW,\n    EOWNERDEAD: exports.WASI_EOWNERDEAD,\n    EPERM: exports.WASI_EPERM,\n    EPIPE: exports.WASI_EPIPE,\n    EPROTO: exports.WASI_EPROTO,\n    EPROTONOSUPPORT: exports.WASI_EPROTONOSUPPORT,\n    EPROTOTYPE: exports.WASI_EPROTOTYPE,\n    ERANGE: exports.WASI_ERANGE,\n    EROFS: exports.WASI_EROFS,\n    ESPIPE: exports.WASI_ESPIPE,\n    ESRCH: exports.WASI_ESRCH,\n    ESTALE: exports.WASI_ESTALE,\n    ETIMEDOUT: exports.WASI_ETIMEDOUT,\n    ETXTBSY: exports.WASI_ETXTBSY,\n    EXDEV: exports.WASI_EXDEV\n};\nexports.SIGNAL_MAP = {\n    [exports.WASI_SIGHUP]: \"SIGHUP\",\n    [exports.WASI_SIGINT]: \"SIGINT\",\n    [exports.WASI_SIGQUIT]: \"SIGQUIT\",\n    [exports.WASI_SIGILL]: \"SIGILL\",\n    [exports.WASI_SIGTRAP]: \"SIGTRAP\",\n    [exports.WASI_SIGABRT]: \"SIGABRT\",\n    [exports.WASI_SIGBUS]: \"SIGBUS\",\n    [exports.WASI_SIGFPE]: \"SIGFPE\",\n    [exports.WASI_SIGKILL]: \"SIGKILL\",\n    [exports.WASI_SIGUSR1]: \"SIGUSR1\",\n    [exports.WASI_SIGSEGV]: \"SIGSEGV\",\n    [exports.WASI_SIGUSR2]: \"SIGUSR2\",\n    [exports.WASI_SIGPIPE]: \"SIGPIPE\",\n    [exports.WASI_SIGALRM]: \"SIGALRM\",\n    [exports.WASI_SIGTERM]: \"SIGTERM\",\n    [exports.WASI_SIGCHLD]: \"SIGCHLD\",\n    [exports.WASI_SIGCONT]: \"SIGCONT\",\n    [exports.WASI_SIGSTOP]: \"SIGSTOP\",\n    [exports.WASI_SIGTSTP]: \"SIGTSTP\",\n    [exports.WASI_SIGTTIN]: \"SIGTTIN\",\n    [exports.WASI_SIGTTOU]: \"SIGTTOU\",\n    [exports.WASI_SIGURG]: \"SIGURG\",\n    [exports.WASI_SIGXCPU]: \"SIGXCPU\",\n    [exports.WASI_SIGXFSZ]: \"SIGXFSZ\",\n    [exports.WASI_SIGVTALRM]: \"SIGVTALRM\"\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3QvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUI7QUFDanBDLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG1C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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFx3YXNpLWpzXFxkaXN0XFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuXG5UaGlzIHByb2plY3QgaXMgYmFzZWQgZnJvbSB0aGUgTm9kZSBpbXBsZW1lbnRhdGlvbiBtYWRlIGJ5IEd1cyBDYXBsYW5cbmh0dHBzOi8vZ2l0aHViLmNvbS9kZXZzbmVrL25vZGUtd2FzaVxuSG93ZXZlciwgSmF2YVNjcmlwdCBXQVNJIGlzIGZvY3VzZWQgb246XG4gKiBCcmluZ2luZyBXQVNJIHRvIHRoZSBCcm93c2Vyc1xuICogTWFrZSBlYXN5IHRvIHBsdWcgZGlmZmVyZW50IGZpbGVzeXN0ZW1zXG4gKiBQcm92aWRlIGEgdHlwZS1zYWZlIGFwaSB1c2luZyBUeXBlc2NyaXB0XG5cblxuQ29weXJpZ2h0IDIwMTkgR3VzIENhcGxhblxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbnJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG5JTiBUSEUgU09GVFdBUkUuXG5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XQVNJX0VOT01TRyA9IGV4cG9ydHMuV0FTSV9FTk9NRU0gPSBleHBvcnRzLldBU0lfRU5PTElOSyA9IGV4cG9ydHMuV0FTSV9FTk9MQ0sgPSBleHBvcnRzLldBU0lfRU5PRVhFQyA9IGV4cG9ydHMuV0FTSV9FTk9FTlQgPSBleHBvcnRzLldBU0lfRU5PREVWID0gZXhwb3J0cy5XQVNJX0VOT0JVRlMgPSBleHBvcnRzLldBU0lfRU5GSUxFID0gZXhwb3J0cy5XQVNJX0VORVRVTlJFQUNIID0gZXhwb3J0cy5XQVNJX0VORVRSRVNFVCA9IGV4cG9ydHMuV0FTSV9FTkVURE9XTiA9IGV4cG9ydHMuV0FTSV9FTkFNRVRPT0xPTkcgPSBleHBvcnRzLldBU0lfRU1VTFRJSE9QID0gZXhwb3J0cy5XQVNJX0VNU0dTSVpFID0gZXhwb3J0cy5XQVNJX0VNTElOSyA9IGV4cG9ydHMuV0FTSV9FTUZJTEUgPSBleHBvcnRzLldBU0lfRUxPT1AgPSBleHBvcnRzLldBU0lfRUlTRElSID0gZXhwb3J0cy5XQVNJX0VJU0NPTk4gPSBleHBvcnRzLldBU0lfRUlPID0gZXhwb3J0cy5XQVNJX0VJTlZBTCA9IGV4cG9ydHMuV0FTSV9FSU5UUiA9IGV4cG9ydHMuV0FTSV9FSU5QUk9HUkVTUyA9IGV4cG9ydHMuV0FTSV9FSUxTRVEgPSBleHBvcnRzLldBU0lfRUlEUk0gPSBleHBvcnRzLldBU0lfRUhPU1RVTlJFQUNIID0gZXhwb3J0cy5XQVNJX0VGQklHID0gZXhwb3J0cy5XQVNJX0VGQVVMVCA9IGV4cG9ydHMuV0FTSV9FRVhJU1QgPSBleHBvcnRzLldBU0lfRURRVU9UID0gZXhwb3J0cy5XQVNJX0VET00gPSBleHBvcnRzLldBU0lfRURFU1RBRERSUkVRID0gZXhwb3J0cy5XQVNJX0VERUFETEsgPSBleHBvcnRzLldBU0lfRUNPTk5SRVNFVCA9IGV4cG9ydHMuV0FTSV9FQ09OTlJFRlVTRUQgPSBleHBvcnRzLldBU0lfRUNPTk5BQk9SVEVEID0gZXhwb3J0cy5XQVNJX0VDSElMRCA9IGV4cG9ydHMuV0FTSV9FQ0FOQ0VMRUQgPSBleHBvcnRzLldBU0lfRUJVU1kgPSBleHBvcnRzLldBU0lfRUJBRE1TRyA9IGV4cG9ydHMuV0FTSV9FQkFERiA9IGV4cG9ydHMuV0FTSV9FQUxSRUFEWSA9IGV4cG9ydHMuV0FTSV9FQUdBSU4gPSBleHBvcnRzLldBU0lfRUFGTk9TVVBQT1JUID0gZXhwb3J0cy5XQVNJX0VBRERSTk9UQVZBSUwgPSBleHBvcnRzLldBU0lfRUFERFJJTlVTRSA9IGV4cG9ydHMuV0FTSV9FQUNDRVMgPSBleHBvcnRzLldBU0lfRTJCSUcgPSBleHBvcnRzLldBU0lfRVNVQ0NFU1MgPSB2b2lkIDA7XG5leHBvcnRzLldBU0lfU0lHVlRBTFJNID0gZXhwb3J0cy5XQVNJX1NJR1VTUjIgPSBleHBvcnRzLldBU0lfU0lHVVNSMSA9IGV4cG9ydHMuV0FTSV9TSUdVUkcgPSBleHBvcnRzLldBU0lfU0lHVFRPVSA9IGV4cG9ydHMuV0FTSV9TSUdUVElOID0gZXhwb3J0cy5XQVNJX1NJR1RTVFAgPSBleHBvcnRzLldBU0lfU0lHVFJBUCA9IGV4cG9ydHMuV0FTSV9TSUdURVJNID0gZXhwb3J0cy5XQVNJX1NJR1NUT1AgPSBleHBvcnRzLldBU0lfU0lHU0VHViA9IGV4cG9ydHMuV0FTSV9TSUdRVUlUID0gZXhwb3J0cy5XQVNJX1NJR1BJUEUgPSBleHBvcnRzLldBU0lfU0lHS0lMTCA9IGV4cG9ydHMuV0FTSV9TSUdJTlQgPSBleHBvcnRzLldBU0lfU0lHSUxMID0gZXhwb3J0cy5XQVNJX1NJR0hVUCA9IGV4cG9ydHMuV0FTSV9TSUdGUEUgPSBleHBvcnRzLldBU0lfU0lHQ09OVCA9IGV4cG9ydHMuV0FTSV9TSUdDSExEID0gZXhwb3J0cy5XQVNJX1NJR0JVUyA9IGV4cG9ydHMuV0FTSV9TSUdBTFJNID0gZXhwb3J0cy5XQVNJX1NJR0FCUlQgPSBleHBvcnRzLldBU0lfRU5PVENBUEFCTEUgPSBleHBvcnRzLldBU0lfRVhERVYgPSBleHBvcnRzLldBU0lfRVRYVEJTWSA9IGV4cG9ydHMuV0FTSV9FVElNRURPVVQgPSBleHBvcnRzLldBU0lfRVNUQUxFID0gZXhwb3J0cy5XQVNJX0VTUkNIID0gZXhwb3J0cy5XQVNJX0VTUElQRSA9IGV4cG9ydHMuV0FTSV9FUk9GUyA9IGV4cG9ydHMuV0FTSV9FUkFOR0UgPSBleHBvcnRzLldBU0lfRVBST1RPVFlQRSA9IGV4cG9ydHMuV0FTSV9FUFJPVE9OT1NVUFBPUlQgPSBleHBvcnRzLldBU0lfRVBST1RPID0gZXhwb3J0cy5XQVNJX0VQSVBFID0gZXhwb3J0cy5XQVNJX0VQRVJNID0gZXhwb3J0cy5XQVNJX0VPV05FUkRFQUQgPSBleHBvcnRzLldBU0lfRU9WRVJGTE9XID0gZXhwb3J0cy5XQVNJX0VOWElPID0gZXhwb3J0cy5XQVNJX0VOT1RUWSA9IGV4cG9ydHMuV0FTSV9FTk9UU1VQID0gZXhwb3J0cy5XQVNJX0VOT1RTT0NLID0gZXhwb3J0cy5XQVNJX0VOT1RSRUNPVkVSQUJMRSA9IGV4cG9ydHMuV0FTSV9FTk9URU1QVFkgPSBleHBvcnRzLldBU0lfRU5PVERJUiA9IGV4cG9ydHMuV0FTSV9FTk9UQ09OTiA9IGV4cG9ydHMuV0FTSV9FTk9TWVMgPSBleHBvcnRzLldBU0lfRU5PU1BDID0gZXhwb3J0cy5XQVNJX0VOT1BST1RPT1BUID0gdm9pZCAwO1xuZXhwb3J0cy5SSUdIVFNfUkVHVUxBUl9GSUxFX0JBU0UgPSBleHBvcnRzLlJJR0hUU19DSEFSQUNURVJfREVWSUNFX0lOSEVSSVRJTkcgPSBleHBvcnRzLlJJR0hUU19DSEFSQUNURVJfREVWSUNFX0JBU0UgPSBleHBvcnRzLlJJR0hUU19CTE9DS19ERVZJQ0VfSU5IRVJJVElORyA9IGV4cG9ydHMuUklHSFRTX0JMT0NLX0RFVklDRV9CQVNFID0gZXhwb3J0cy5SSUdIVFNfQUxMID0gZXhwb3J0cy5XQVNJX1JJR0hUX1NPQ0tfU0hVVERPV04gPSBleHBvcnRzLldBU0lfUklHSFRfUE9MTF9GRF9SRUFEV1JJVEUgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9VTkxJTktfRklMRSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTU9WRV9ESVJFQ1RPUlkgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9TWU1MSU5LID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9USU1FUyA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9TRVRfU0laRSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9HRVQgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9GSUxFU1RBVF9TRVRfVElNRVMgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9GSUxFU1RBVF9TRVRfU0laRSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX0dFVCA9IGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9UQVJHRVQgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9SRU5BTUVfU09VUkNFID0gZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfUkVBRExJTksgPSBleHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRERJUiA9IGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX09QRU4gPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9MSU5LX1RBUkdFVCA9IGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0xJTktfU09VUkNFID0gZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfQ1JFQVRFX0ZJTEUgPSBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRElSRUNUT1JZID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FMTE9DQVRFID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FEVklTRSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9XUklURSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9URUxMID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1NZTkMgPSBleHBvcnRzLldBU0lfUklHSFRfRkRfRkRTVEFUX1NFVF9GTEFHUyA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9TRUVLID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1JFQUQgPSBleHBvcnRzLldBU0lfUklHSFRfRkRfREFUQVNZTkMgPSBleHBvcnRzLldBU0lfRkRGTEFHX1NZTkMgPSBleHBvcnRzLldBU0lfRkRGTEFHX1JTWU5DID0gZXhwb3J0cy5XQVNJX0ZERkxBR19OT05CTE9DSyA9IGV4cG9ydHMuV0FTSV9GREZMQUdfRFNZTkMgPSBleHBvcnRzLldBU0lfRkRGTEFHX0FQUEVORCA9IGV4cG9ydHMuV0FTSV9GSUxFVFlQRV9TWU1CT0xJQ19MSU5LID0gZXhwb3J0cy5XQVNJX0ZJTEVUWVBFX1NPQ0tFVF9TVFJFQU0gPSBleHBvcnRzLldBU0lfRklMRVRZUEVfU09DS0VUX0RHUkFNID0gZXhwb3J0cy5XQVNJX0ZJTEVUWVBFX1JFR1VMQVJfRklMRSA9IGV4cG9ydHMuV0FTSV9GSUxFVFlQRV9ESVJFQ1RPUlkgPSBleHBvcnRzLldBU0lfRklMRVRZUEVfQ0hBUkFDVEVSX0RFVklDRSA9IGV4cG9ydHMuV0FTSV9GSUxFVFlQRV9CTE9DS19ERVZJQ0UgPSBleHBvcnRzLldBU0lfRklMRVRZUEVfVU5LTk9XTiA9IGV4cG9ydHMuV0FTSV9TSUdYRlNaID0gZXhwb3J0cy5XQVNJX1NJR1hDUFUgPSB2b2lkIDA7XG5leHBvcnRzLlNJR05BTF9NQVAgPSBleHBvcnRzLkVSUk9SX01BUCA9IGV4cG9ydHMuV0FTSV9XSEVOQ0VfRU5EID0gZXhwb3J0cy5XQVNJX1dIRU5DRV9DVVIgPSBleHBvcnRzLldBU0lfV0hFTkNFX1NFVCA9IGV4cG9ydHMuV0FTSV9TVERFUlJfRklMRU5PID0gZXhwb3J0cy5XQVNJX1NURE9VVF9GSUxFTk8gPSBleHBvcnRzLldBU0lfU1RESU5fRklMRU5PID0gZXhwb3J0cy5XQVNJX0RJUkNPT0tJRV9TVEFSVCA9IGV4cG9ydHMuV0FTSV9QUkVPUEVOVFlQRV9ESVIgPSBleHBvcnRzLldBU0lfT19UUlVOQyA9IGV4cG9ydHMuV0FTSV9PX0VYQ0wgPSBleHBvcnRzLldBU0lfT19ESVJFQ1RPUlkgPSBleHBvcnRzLldBU0lfT19DUkVBVCA9IGV4cG9ydHMuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTV9OT1cgPSBleHBvcnRzLldBU0lfRklMRVNUQVRfU0VUX01USU0gPSBleHBvcnRzLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XID0gZXhwb3J0cy5XQVNJX0ZJTEVTVEFUX1NFVF9BVElNID0gZXhwb3J0cy5XQVNJX0VWRU5UVFlQRV9GRF9XUklURSA9IGV4cG9ydHMuV0FTSV9FVkVOVFRZUEVfRkRfUkVBRCA9IGV4cG9ydHMuV0FTSV9FVkVOVFRZUEVfQ0xPQ0sgPSBleHBvcnRzLldBU0lfQ0xPQ0tfVEhSRUFEX0NQVVRJTUVfSUQgPSBleHBvcnRzLldBU0lfQ0xPQ0tfUFJPQ0VTU19DUFVUSU1FX0lEID0gZXhwb3J0cy5XQVNJX0NMT0NLX01PTk9UT05JQyA9IGV4cG9ydHMuV0FTSV9DTE9DS19SRUFMVElNRSA9IGV4cG9ydHMuUklHSFRTX1RUWV9JTkhFUklUSU5HID0gZXhwb3J0cy5SSUdIVFNfVFRZX0JBU0UgPSBleHBvcnRzLlJJR0hUU19TT0NLRVRfSU5IRVJJVElORyA9IGV4cG9ydHMuUklHSFRTX1NPQ0tFVF9CQVNFID0gZXhwb3J0cy5SSUdIVFNfRElSRUNUT1JZX0lOSEVSSVRJTkcgPSBleHBvcnRzLlJJR0hUU19ESVJFQ1RPUllfQkFTRSA9IGV4cG9ydHMuUklHSFRTX1JFR1VMQVJfRklMRV9JTkhFUklUSU5HID0gdm9pZCAwO1xuZXhwb3J0cy5XQVNJX0VTVUNDRVNTID0gMDtcbmV4cG9ydHMuV0FTSV9FMkJJRyA9IDE7XG5leHBvcnRzLldBU0lfRUFDQ0VTID0gMjtcbmV4cG9ydHMuV0FTSV9FQUREUklOVVNFID0gMztcbmV4cG9ydHMuV0FTSV9FQUREUk5PVEFWQUlMID0gNDtcbmV4cG9ydHMuV0FTSV9FQUZOT1NVUFBPUlQgPSA1O1xuZXhwb3J0cy5XQVNJX0VBR0FJTiA9IDY7XG5leHBvcnRzLldBU0lfRUFMUkVBRFkgPSA3O1xuZXhwb3J0cy5XQVNJX0VCQURGID0gODtcbmV4cG9ydHMuV0FTSV9FQkFETVNHID0gOTtcbmV4cG9ydHMuV0FTSV9FQlVTWSA9IDEwO1xuZXhwb3J0cy5XQVNJX0VDQU5DRUxFRCA9IDExO1xuZXhwb3J0cy5XQVNJX0VDSElMRCA9IDEyO1xuZXhwb3J0cy5XQVNJX0VDT05OQUJPUlRFRCA9IDEzO1xuZXhwb3J0cy5XQVNJX0VDT05OUkVGVVNFRCA9IDE0O1xuZXhwb3J0cy5XQVNJX0VDT05OUkVTRVQgPSAxNTtcbmV4cG9ydHMuV0FTSV9FREVBRExLID0gMTY7XG5leHBvcnRzLldBU0lfRURFU1RBRERSUkVRID0gMTc7XG5leHBvcnRzLldBU0lfRURPTSA9IDE4O1xuZXhwb3J0cy5XQVNJX0VEUVVPVCA9IDE5O1xuZXhwb3J0cy5XQVNJX0VFWElTVCA9IDIwO1xuZXhwb3J0cy5XQVNJX0VGQVVMVCA9IDIxO1xuZXhwb3J0cy5XQVNJX0VGQklHID0gMjI7XG5leHBvcnRzLldBU0lfRUhPU1RVTlJFQUNIID0gMjM7XG5leHBvcnRzLldBU0lfRUlEUk0gPSAyNDtcbmV4cG9ydHMuV0FTSV9FSUxTRVEgPSAyNTtcbmV4cG9ydHMuV0FTSV9FSU5QUk9HUkVTUyA9IDI2O1xuZXhwb3J0cy5XQVNJX0VJTlRSID0gMjc7XG5leHBvcnRzLldBU0lfRUlOVkFMID0gMjg7XG5leHBvcnRzLldBU0lfRUlPID0gMjk7XG5leHBvcnRzLldBU0lfRUlTQ09OTiA9IDMwO1xuZXhwb3J0cy5XQVNJX0VJU0RJUiA9IDMxO1xuZXhwb3J0cy5XQVNJX0VMT09QID0gMzI7XG5leHBvcnRzLldBU0lfRU1GSUxFID0gMzM7XG5leHBvcnRzLldBU0lfRU1MSU5LID0gMzQ7XG5leHBvcnRzLldBU0lfRU1TR1NJWkUgPSAzNTtcbmV4cG9ydHMuV0FTSV9FTVVMVElIT1AgPSAzNjtcbmV4cG9ydHMuV0FTSV9FTkFNRVRPT0xPTkcgPSAzNztcbmV4cG9ydHMuV0FTSV9FTkVURE9XTiA9IDM4O1xuZXhwb3J0cy5XQVNJX0VORVRSRVNFVCA9IDM5O1xuZXhwb3J0cy5XQVNJX0VORVRVTlJFQUNIID0gNDA7XG5leHBvcnRzLldBU0lfRU5GSUxFID0gNDE7XG5leHBvcnRzLldBU0lfRU5PQlVGUyA9IDQyO1xuZXhwb3J0cy5XQVNJX0VOT0RFViA9IDQzO1xuZXhwb3J0cy5XQVNJX0VOT0VOVCA9IDQ0O1xuZXhwb3J0cy5XQVNJX0VOT0VYRUMgPSA0NTtcbmV4cG9ydHMuV0FTSV9FTk9MQ0sgPSA0NjtcbmV4cG9ydHMuV0FTSV9FTk9MSU5LID0gNDc7XG5leHBvcnRzLldBU0lfRU5PTUVNID0gNDg7XG5leHBvcnRzLldBU0lfRU5PTVNHID0gNDk7XG5leHBvcnRzLldBU0lfRU5PUFJPVE9PUFQgPSA1MDtcbmV4cG9ydHMuV0FTSV9FTk9TUEMgPSA1MTtcbmV4cG9ydHMuV0FTSV9FTk9TWVMgPSA1MjtcbmV4cG9ydHMuV0FTSV9FTk9UQ09OTiA9IDUzO1xuZXhwb3J0cy5XQVNJX0VOT1RESVIgPSA1NDtcbmV4cG9ydHMuV0FTSV9FTk9URU1QVFkgPSA1NTtcbmV4cG9ydHMuV0FTSV9FTk9UUkVDT1ZFUkFCTEUgPSA1NjtcbmV4cG9ydHMuV0FTSV9FTk9UU09DSyA9IDU3O1xuZXhwb3J0cy5XQVNJX0VOT1RTVVAgPSA1ODtcbmV4cG9ydHMuV0FTSV9FTk9UVFkgPSA1OTtcbmV4cG9ydHMuV0FTSV9FTlhJTyA9IDYwO1xuZXhwb3J0cy5XQVNJX0VPVkVSRkxPVyA9IDYxO1xuZXhwb3J0cy5XQVNJX0VPV05FUkRFQUQgPSA2MjtcbmV4cG9ydHMuV0FTSV9FUEVSTSA9IDYzO1xuZXhwb3J0cy5XQVNJX0VQSVBFID0gNjQ7XG5leHBvcnRzLldBU0lfRVBST1RPID0gNjU7XG5leHBvcnRzLldBU0lfRVBST1RPTk9TVVBQT1JUID0gNjY7XG5leHBvcnRzLldBU0lfRVBST1RPVFlQRSA9IDY3O1xuZXhwb3J0cy5XQVNJX0VSQU5HRSA9IDY4O1xuZXhwb3J0cy5XQVNJX0VST0ZTID0gNjk7XG5leHBvcnRzLldBU0lfRVNQSVBFID0gNzA7XG5leHBvcnRzLldBU0lfRVNSQ0ggPSA3MTtcbmV4cG9ydHMuV0FTSV9FU1RBTEUgPSA3MjtcbmV4cG9ydHMuV0FTSV9FVElNRURPVVQgPSA3MztcbmV4cG9ydHMuV0FTSV9FVFhUQlNZID0gNzQ7XG5leHBvcnRzLldBU0lfRVhERVYgPSA3NTtcbmV4cG9ydHMuV0FTSV9FTk9UQ0FQQUJMRSA9IDc2O1xuZXhwb3J0cy5XQVNJX1NJR0FCUlQgPSAwO1xuZXhwb3J0cy5XQVNJX1NJR0FMUk0gPSAxO1xuZXhwb3J0cy5XQVNJX1NJR0JVUyA9IDI7XG5leHBvcnRzLldBU0lfU0lHQ0hMRCA9IDM7XG5leHBvcnRzLldBU0lfU0lHQ09OVCA9IDQ7XG5leHBvcnRzLldBU0lfU0lHRlBFID0gNTtcbmV4cG9ydHMuV0FTSV9TSUdIVVAgPSA2O1xuZXhwb3J0cy5XQVNJX1NJR0lMTCA9IDc7XG5leHBvcnRzLldBU0lfU0lHSU5UID0gODtcbmV4cG9ydHMuV0FTSV9TSUdLSUxMID0gOTtcbmV4cG9ydHMuV0FTSV9TSUdQSVBFID0gMTA7XG5leHBvcnRzLldBU0lfU0lHUVVJVCA9IDExO1xuZXhwb3J0cy5XQVNJX1NJR1NFR1YgPSAxMjtcbmV4cG9ydHMuV0FTSV9TSUdTVE9QID0gMTM7XG5leHBvcnRzLldBU0lfU0lHVEVSTSA9IDE0O1xuZXhwb3J0cy5XQVNJX1NJR1RSQVAgPSAxNTtcbmV4cG9ydHMuV0FTSV9TSUdUU1RQID0gMTY7XG5leHBvcnRzLldBU0lfU0lHVFRJTiA9IDE3O1xuZXhwb3J0cy5XQVNJX1NJR1RUT1UgPSAxODtcbmV4cG9ydHMuV0FTSV9TSUdVUkcgPSAxOTtcbmV4cG9ydHMuV0FTSV9TSUdVU1IxID0gMjA7XG5leHBvcnRzLldBU0lfU0lHVVNSMiA9IDIxO1xuZXhwb3J0cy5XQVNJX1NJR1ZUQUxSTSA9IDIyO1xuZXhwb3J0cy5XQVNJX1NJR1hDUFUgPSAyMztcbmV4cG9ydHMuV0FTSV9TSUdYRlNaID0gMjQ7XG5leHBvcnRzLldBU0lfRklMRVRZUEVfVU5LTk9XTiA9IDA7XG5leHBvcnRzLldBU0lfRklMRVRZUEVfQkxPQ0tfREVWSUNFID0gMTtcbmV4cG9ydHMuV0FTSV9GSUxFVFlQRV9DSEFSQUNURVJfREVWSUNFID0gMjtcbmV4cG9ydHMuV0FTSV9GSUxFVFlQRV9ESVJFQ1RPUlkgPSAzO1xuZXhwb3J0cy5XQVNJX0ZJTEVUWVBFX1JFR1VMQVJfRklMRSA9IDQ7XG5leHBvcnRzLldBU0lfRklMRVRZUEVfU09DS0VUX0RHUkFNID0gNTtcbmV4cG9ydHMuV0FTSV9GSUxFVFlQRV9TT0NLRVRfU1RSRUFNID0gNjtcbmV4cG9ydHMuV0FTSV9GSUxFVFlQRV9TWU1CT0xJQ19MSU5LID0gNztcbmV4cG9ydHMuV0FTSV9GREZMQUdfQVBQRU5EID0gMHgwMDAxO1xuZXhwb3J0cy5XQVNJX0ZERkxBR19EU1lOQyA9IDB4MDAwMjtcbmV4cG9ydHMuV0FTSV9GREZMQUdfTk9OQkxPQ0sgPSAweDAwMDQ7XG5leHBvcnRzLldBU0lfRkRGTEFHX1JTWU5DID0gMHgwMDA4O1xuZXhwb3J0cy5XQVNJX0ZERkxBR19TWU5DID0gMHgwMDEwO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0RBVEFTWU5DID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMDAwMSk7XG5leHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRCA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDAwMDIpO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1NFRUsgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDAwMDA0KTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GRFNUQVRfU0VUX0ZMQUdTID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMDAwOCk7XG5leHBvcnRzLldBU0lfUklHSFRfRkRfU1lOQyA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDAwMTApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1RFTEwgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDAwMDIwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9GRF9XUklURSA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDAwNDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FEVklTRSA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDAwODApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FMTE9DQVRFID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMDEwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRElSRUNUT1JZID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMDIwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRklMRSA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDA0MDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfTElOS19TT1VSQ0UgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDAwODAwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0xJTktfVEFSR0VUID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMTAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9PUEVOID0gQmlnSW50KDB4MDAwMDAwMDAwMDAwMjAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRERJUiA9IEJpZ0ludCgweDAwMDAwMDAwMDAwMDQwMDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfUkVBRExJTksgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDA4MDAwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9TT1VSQ0UgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDEwMDAwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9UQVJHRVQgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDIwMDAwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX0dFVCA9IEJpZ0ludCgweDAwMDAwMDAwMDAwNDAwMDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfRklMRVNUQVRfU0VUX1NJWkUgPSBCaWdJbnQoMHgwMDAwMDAwMDAwMDgwMDAwKTtcbmV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX1NFVF9USU1FUyA9IEJpZ0ludCgweDAwMDAwMDAwMDAxMDAwMDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX0dFVCA9IEJpZ0ludCgweDAwMDAwMDAwMDAyMDAwMDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9TSVpFID0gQmlnSW50KDB4MDAwMDAwMDAwMDQwMDAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfRkRfRklMRVNUQVRfU0VUX1RJTUVTID0gQmlnSW50KDB4MDAwMDAwMDAwMDgwMDAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9TWU1MSU5LID0gQmlnSW50KDB4MDAwMDAwMDAwMTAwMDAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9SRU1PVkVfRElSRUNUT1JZID0gQmlnSW50KDB4MDAwMDAwMDAwMjAwMDAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfUEFUSF9VTkxJTktfRklMRSA9IEJpZ0ludCgweDAwMDAwMDAwMDQwMDAwMDApO1xuZXhwb3J0cy5XQVNJX1JJR0hUX1BPTExfRkRfUkVBRFdSSVRFID0gQmlnSW50KDB4MDAwMDAwMDAwODAwMDAwMCk7XG5leHBvcnRzLldBU0lfUklHSFRfU09DS19TSFVURE9XTiA9IEJpZ0ludCgweDAwMDAwMDAwMTAwMDAwMDApO1xuZXhwb3J0cy5SSUdIVFNfQUxMID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0RBVEFTWU5DIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1NFRUsgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GRFNUQVRfU0VUX0ZMQUdTIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfU1lOQyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1RFTEwgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9XUklURSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FEVklTRSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0FMTE9DQVRFIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRElSRUNUT1JZIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRklMRSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfTElOS19TT1VSQ0UgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0xJTktfVEFSR0VUIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9PUEVOIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRERJUiB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfUkVBRExJTksgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9TT1VSQ0UgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9UQVJHRVQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX0dFVCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfRklMRVNUQVRfU0VUX1NJWkUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX1NFVF9USU1FUyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX0dFVCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9USU1FUyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9TSVpFIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9TWU1MSU5LIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9VTkxJTktfRklMRSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfUkVNT1ZFX0RJUkVDVE9SWSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BPTExfRkRfUkVBRFdSSVRFIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfU09DS19TSFVURE9XTjtcbmV4cG9ydHMuUklHSFRTX0JMT0NLX0RFVklDRV9CQVNFID0gZXhwb3J0cy5SSUdIVFNfQUxMO1xuZXhwb3J0cy5SSUdIVFNfQkxPQ0tfREVWSUNFX0lOSEVSSVRJTkcgPSBleHBvcnRzLlJJR0hUU19BTEw7XG5leHBvcnRzLlJJR0hUU19DSEFSQUNURVJfREVWSUNFX0JBU0UgPSBleHBvcnRzLlJJR0hUU19BTEw7XG5leHBvcnRzLlJJR0hUU19DSEFSQUNURVJfREVWSUNFX0lOSEVSSVRJTkcgPSBleHBvcnRzLlJJR0hUU19BTEw7XG5leHBvcnRzLlJJR0hUU19SRUdVTEFSX0ZJTEVfQkFTRSA9IGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1JFQUQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9TRUVLIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfRkRTVEFUX1NFVF9GTEFHUyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1NZTkMgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9URUxMIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfV1JJVEUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9BRFZJU0UgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9BTExPQ0FURSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX0dFVCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9TSVpFIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfRklMRVNUQVRfU0VUX1RJTUVTIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUE9MTF9GRF9SRUFEV1JJVEU7XG5leHBvcnRzLlJJR0hUU19SRUdVTEFSX0ZJTEVfSU5IRVJJVElORyA9IEJpZ0ludCgwKTtcbmV4cG9ydHMuUklHSFRTX0RJUkVDVE9SWV9CQVNFID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZEU1RBVF9TRVRfRkxBR1MgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9TWU5DIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfQURWSVNFIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRElSRUNUT1JZIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9DUkVBVEVfRklMRSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfTElOS19TT1VSQ0UgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0xJTktfVEFSR0VUIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfUEFUSF9PUEVOIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfUkVBRERJUiB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfUkVBRExJTksgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9TT1VSQ0UgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTkFNRV9UQVJHRVQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX0dFVCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfRklMRVNUQVRfU0VUX1NJWkUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX1NFVF9USU1FUyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX0dFVCB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX1NFVF9USU1FUyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfU1lNTElOSyB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1BBVEhfVU5MSU5LX0ZJTEUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QQVRIX1JFTU9WRV9ESVJFQ1RPUlkgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QT0xMX0ZEX1JFQURXUklURTtcbmV4cG9ydHMuUklHSFRTX0RJUkVDVE9SWV9JTkhFUklUSU5HID0gZXhwb3J0cy5SSUdIVFNfRElSRUNUT1JZX0JBU0UgfCBleHBvcnRzLlJJR0hUU19SRUdVTEFSX0ZJTEVfQkFTRTtcbmV4cG9ydHMuUklHSFRTX1NPQ0tFVF9CQVNFID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1JFQUQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GRFNUQVRfU0VUX0ZMQUdTIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfV1JJVEUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9HRVQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QT0xMX0ZEX1JFQURXUklURSB8XG4gICAgZXhwb3J0cy5XQVNJX1JJR0hUX1NPQ0tfU0hVVERPV047XG5leHBvcnRzLlJJR0hUU19TT0NLRVRfSU5IRVJJVElORyA9IGV4cG9ydHMuUklHSFRTX0FMTDtcbmV4cG9ydHMuUklHSFRTX1RUWV9CQVNFID0gZXhwb3J0cy5XQVNJX1JJR0hUX0ZEX1JFQUQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GRFNUQVRfU0VUX0ZMQUdTIHxcbiAgICBleHBvcnRzLldBU0lfUklHSFRfRkRfV1JJVEUgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9HRVQgfFxuICAgIGV4cG9ydHMuV0FTSV9SSUdIVF9QT0xMX0ZEX1JFQURXUklURTtcbmV4cG9ydHMuUklHSFRTX1RUWV9JTkhFUklUSU5HID0gQmlnSW50KDApO1xuZXhwb3J0cy5XQVNJX0NMT0NLX1JFQUxUSU1FID0gMDtcbmV4cG9ydHMuV0FTSV9DTE9DS19NT05PVE9OSUMgPSAxO1xuZXhwb3J0cy5XQVNJX0NMT0NLX1BST0NFU1NfQ1BVVElNRV9JRCA9IDI7XG5leHBvcnRzLldBU0lfQ0xPQ0tfVEhSRUFEX0NQVVRJTUVfSUQgPSAzO1xuZXhwb3J0cy5XQVNJX0VWRU5UVFlQRV9DTE9DSyA9IDA7XG5leHBvcnRzLldBU0lfRVZFTlRUWVBFX0ZEX1JFQUQgPSAxO1xuZXhwb3J0cy5XQVNJX0VWRU5UVFlQRV9GRF9XUklURSA9IDI7XG5leHBvcnRzLldBU0lfRklMRVNUQVRfU0VUX0FUSU0gPSAxIDw8IDA7XG5leHBvcnRzLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XID0gMSA8PCAxO1xuZXhwb3J0cy5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNID0gMSA8PCAyO1xuZXhwb3J0cy5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNX05PVyA9IDEgPDwgMztcbmV4cG9ydHMuV0FTSV9PX0NSRUFUID0gMSA8PCAwO1xuZXhwb3J0cy5XQVNJX09fRElSRUNUT1JZID0gMSA8PCAxO1xuZXhwb3J0cy5XQVNJX09fRVhDTCA9IDEgPDwgMjtcbmV4cG9ydHMuV0FTSV9PX1RSVU5DID0gMSA8PCAzO1xuZXhwb3J0cy5XQVNJX1BSRU9QRU5UWVBFX0RJUiA9IDA7XG5leHBvcnRzLldBU0lfRElSQ09PS0lFX1NUQVJUID0gMDtcbmV4cG9ydHMuV0FTSV9TVERJTl9GSUxFTk8gPSAwO1xuZXhwb3J0cy5XQVNJX1NURE9VVF9GSUxFTk8gPSAxO1xuZXhwb3J0cy5XQVNJX1NUREVSUl9GSUxFTk8gPSAyO1xuZXhwb3J0cy5XQVNJX1dIRU5DRV9TRVQgPSAwO1xuZXhwb3J0cy5XQVNJX1dIRU5DRV9DVVIgPSAxO1xuZXhwb3J0cy5XQVNJX1dIRU5DRV9FTkQgPSAyO1xuLy8gaHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4zL2Vycm5vLjMuaHRtbFxuZXhwb3J0cy5FUlJPUl9NQVAgPSB7XG4gICAgRTJCSUc6IGV4cG9ydHMuV0FTSV9FMkJJRyxcbiAgICBFQUNDRVM6IGV4cG9ydHMuV0FTSV9FQUNDRVMsXG4gICAgRUFERFJJTlVTRTogZXhwb3J0cy5XQVNJX0VBRERSSU5VU0UsXG4gICAgRUFERFJOT1RBVkFJTDogZXhwb3J0cy5XQVNJX0VBRERSTk9UQVZBSUwsXG4gICAgRUFGTk9TVVBQT1JUOiBleHBvcnRzLldBU0lfRUFGTk9TVVBQT1JULFxuICAgIEVBTFJFQURZOiBleHBvcnRzLldBU0lfRUFMUkVBRFksXG4gICAgRUFHQUlOOiBleHBvcnRzLldBU0lfRUFHQUlOLFxuICAgIC8vIEVCQURFOiBXQVNJX0VCQURFLFxuICAgIEVCQURGOiBleHBvcnRzLldBU0lfRUJBREYsXG4gICAgLy8gRUJBREZEOiBXQVNJX0VCQURGRCxcbiAgICBFQkFETVNHOiBleHBvcnRzLldBU0lfRUJBRE1TRyxcbiAgICAvLyBFQkFEUjogV0FTSV9FQkFEUixcbiAgICAvLyBFQkFEUlFDOiBXQVNJX0VCQURSUUMsXG4gICAgLy8gRUJBRFNMVDogV0FTSV9FQkFEU0xULFxuICAgIEVCVVNZOiBleHBvcnRzLldBU0lfRUJVU1ksXG4gICAgRUNBTkNFTEVEOiBleHBvcnRzLldBU0lfRUNBTkNFTEVELFxuICAgIEVDSElMRDogZXhwb3J0cy5XQVNJX0VDSElMRCxcbiAgICAvLyBFQ0hSTkc6IFdBU0lfRUNIUk5HLFxuICAgIC8vIEVDT01NOiBXQVNJX0VDT01NLFxuICAgIEVDT05OQUJPUlRFRDogZXhwb3J0cy5XQVNJX0VDT05OQUJPUlRFRCxcbiAgICBFQ09OTlJFRlVTRUQ6IGV4cG9ydHMuV0FTSV9FQ09OTlJFRlVTRUQsXG4gICAgRUNPTk5SRVNFVDogZXhwb3J0cy5XQVNJX0VDT05OUkVTRVQsXG4gICAgRURFQURMT0NLOiBleHBvcnRzLldBU0lfRURFQURMSyxcbiAgICBFREVTVEFERFJSRVE6IGV4cG9ydHMuV0FTSV9FREVTVEFERFJSRVEsXG4gICAgRURPTTogZXhwb3J0cy5XQVNJX0VET00sXG4gICAgRURRVU9UOiBleHBvcnRzLldBU0lfRURRVU9ULFxuICAgIEVFWElTVDogZXhwb3J0cy5XQVNJX0VFWElTVCxcbiAgICBFRkFVTFQ6IGV4cG9ydHMuV0FTSV9FRkFVTFQsXG4gICAgRUZCSUc6IGV4cG9ydHMuV0FTSV9FRkJJRyxcbiAgICBFSE9TVERPV046IGV4cG9ydHMuV0FTSV9FSE9TVFVOUkVBQ0gsXG4gICAgRUhPU1RVTlJFQUNIOiBleHBvcnRzLldBU0lfRUhPU1RVTlJFQUNILFxuICAgIC8vIEVIV1BPSVNPTjogV0FTSV9FSFdQT0lTT04sXG4gICAgRUlEUk06IGV4cG9ydHMuV0FTSV9FSURSTSxcbiAgICBFSUxTRVE6IGV4cG9ydHMuV0FTSV9FSUxTRVEsXG4gICAgRUlOUFJPR1JFU1M6IGV4cG9ydHMuV0FTSV9FSU5QUk9HUkVTUyxcbiAgICBFSU5UUjogZXhwb3J0cy5XQVNJX0VJTlRSLFxuICAgIEVJTlZBTDogZXhwb3J0cy5XQVNJX0VJTlZBTCxcbiAgICBFSU86IGV4cG9ydHMuV0FTSV9FSU8sXG4gICAgRUlTQ09OTjogZXhwb3J0cy5XQVNJX0VJU0NPTk4sXG4gICAgRUlTRElSOiBleHBvcnRzLldBU0lfRUlTRElSLFxuICAgIEVMT09QOiBleHBvcnRzLldBU0lfRUxPT1AsXG4gICAgRU1GSUxFOiBleHBvcnRzLldBU0lfRU1GSUxFLFxuICAgIEVNTElOSzogZXhwb3J0cy5XQVNJX0VNTElOSyxcbiAgICBFTVNHU0laRTogZXhwb3J0cy5XQVNJX0VNU0dTSVpFLFxuICAgIEVNVUxUSUhPUDogZXhwb3J0cy5XQVNJX0VNVUxUSUhPUCxcbiAgICBFTkFNRVRPT0xPTkc6IGV4cG9ydHMuV0FTSV9FTkFNRVRPT0xPTkcsXG4gICAgRU5FVERPV046IGV4cG9ydHMuV0FTSV9FTkVURE9XTixcbiAgICBFTkVUUkVTRVQ6IGV4cG9ydHMuV0FTSV9FTkVUUkVTRVQsXG4gICAgRU5FVFVOUkVBQ0g6IGV4cG9ydHMuV0FTSV9FTkVUVU5SRUFDSCxcbiAgICBFTkZJTEU6IGV4cG9ydHMuV0FTSV9FTkZJTEUsXG4gICAgRU5PQlVGUzogZXhwb3J0cy5XQVNJX0VOT0JVRlMsXG4gICAgRU5PREVWOiBleHBvcnRzLldBU0lfRU5PREVWLFxuICAgIEVOT0VOVDogZXhwb3J0cy5XQVNJX0VOT0VOVCxcbiAgICBFTk9FWEVDOiBleHBvcnRzLldBU0lfRU5PRVhFQyxcbiAgICBFTk9MQ0s6IGV4cG9ydHMuV0FTSV9FTk9MQ0ssXG4gICAgRU5PTElOSzogZXhwb3J0cy5XQVNJX0VOT0xJTkssXG4gICAgRU5PTUVNOiBleHBvcnRzLldBU0lfRU5PTUVNLFxuICAgIEVOT01TRzogZXhwb3J0cy5XQVNJX0VOT01TRyxcbiAgICBFTk9QUk9UT09QVDogZXhwb3J0cy5XQVNJX0VOT1BST1RPT1BULFxuICAgIEVOT1NQQzogZXhwb3J0cy5XQVNJX0VOT1NQQyxcbiAgICBFTk9TWVM6IGV4cG9ydHMuV0FTSV9FTk9TWVMsXG4gICAgRU5PVENPTk46IGV4cG9ydHMuV0FTSV9FTk9UQ09OTixcbiAgICBFTk9URElSOiBleHBvcnRzLldBU0lfRU5PVERJUixcbiAgICBFTk9URU1QVFk6IGV4cG9ydHMuV0FTSV9FTk9URU1QVFksXG4gICAgRU5PVFJFQ09WRVJBQkxFOiBleHBvcnRzLldBU0lfRU5PVFJFQ09WRVJBQkxFLFxuICAgIEVOT1RTT0NLOiBleHBvcnRzLldBU0lfRU5PVFNPQ0ssXG4gICAgRU5PVFRZOiBleHBvcnRzLldBU0lfRU5PVFRZLFxuICAgIEVOWElPOiBleHBvcnRzLldBU0lfRU5YSU8sXG4gICAgRU9WRVJGTE9XOiBleHBvcnRzLldBU0lfRU9WRVJGTE9XLFxuICAgIEVPV05FUkRFQUQ6IGV4cG9ydHMuV0FTSV9FT1dORVJERUFELFxuICAgIEVQRVJNOiBleHBvcnRzLldBU0lfRVBFUk0sXG4gICAgRVBJUEU6IGV4cG9ydHMuV0FTSV9FUElQRSxcbiAgICBFUFJPVE86IGV4cG9ydHMuV0FTSV9FUFJPVE8sXG4gICAgRVBST1RPTk9TVVBQT1JUOiBleHBvcnRzLldBU0lfRVBST1RPTk9TVVBQT1JULFxuICAgIEVQUk9UT1RZUEU6IGV4cG9ydHMuV0FTSV9FUFJPVE9UWVBFLFxuICAgIEVSQU5HRTogZXhwb3J0cy5XQVNJX0VSQU5HRSxcbiAgICBFUk9GUzogZXhwb3J0cy5XQVNJX0VST0ZTLFxuICAgIEVTUElQRTogZXhwb3J0cy5XQVNJX0VTUElQRSxcbiAgICBFU1JDSDogZXhwb3J0cy5XQVNJX0VTUkNILFxuICAgIEVTVEFMRTogZXhwb3J0cy5XQVNJX0VTVEFMRSxcbiAgICBFVElNRURPVVQ6IGV4cG9ydHMuV0FTSV9FVElNRURPVVQsXG4gICAgRVRYVEJTWTogZXhwb3J0cy5XQVNJX0VUWFRCU1ksXG4gICAgRVhERVY6IGV4cG9ydHMuV0FTSV9FWERFVlxufTtcbmV4cG9ydHMuU0lHTkFMX01BUCA9IHtcbiAgICBbZXhwb3J0cy5XQVNJX1NJR0hVUF06IFwiU0lHSFVQXCIsXG4gICAgW2V4cG9ydHMuV0FTSV9TSUdJTlRdOiBcIlNJR0lOVFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHUVVJVF06IFwiU0lHUVVJVFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHSUxMXTogXCJTSUdJTExcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR1RSQVBdOiBcIlNJR1RSQVBcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR0FCUlRdOiBcIlNJR0FCUlRcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR0JVU106IFwiU0lHQlVTXCIsXG4gICAgW2V4cG9ydHMuV0FTSV9TSUdGUEVdOiBcIlNJR0ZQRVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHS0lMTF06IFwiU0lHS0lMTFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVVNSMV06IFwiU0lHVVNSMVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHU0VHVl06IFwiU0lHU0VHVlwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVVNSMl06IFwiU0lHVVNSMlwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHUElQRV06IFwiU0lHUElQRVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHQUxSTV06IFwiU0lHQUxSTVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVEVSTV06IFwiU0lHVEVSTVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHQ0hMRF06IFwiU0lHQ0hMRFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHQ09OVF06IFwiU0lHQ09OVFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHU1RPUF06IFwiU0lHU1RPUFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVFNUUF06IFwiU0lHVFNUUFwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVFRJTl06IFwiU0lHVFRJTlwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVFRPVV06IFwiU0lHVFRPVVwiLFxuICAgIFtleHBvcnRzLldBU0lfU0lHVVJHXTogXCJTSUdVUkdcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR1hDUFVdOiBcIlNJR1hDUFVcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR1hGU1pdOiBcIlNJR1hGU1pcIixcbiAgICBbZXhwb3J0cy5XQVNJX1NJR1ZUQUxSTV06IFwiU0lHVlRBTFJNXCJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/constants.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/fs.js":
/*!*****************************************!*\
  !*** ./node_modules/wasi-js/dist/fs.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\nCreate a union filesystem as described by a FileSystemSpec[].\n\nThis code should not depend on anything that must run in node.js.\n\nNote that this is entirely synchronous code, e.g., the unzip code,\nand that's justified because our WASM interpreter will likely get\nrun in a different thread (a webworker) than the main thread, and\nthis code is needed to initialize it before anything else can happen.\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFileSystem = void 0;\nconst unzip_1 = __importDefault(__webpack_require__(/*! ./unzip */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/unzip.js\"));\nconst memfs_1 = __webpack_require__(/*! @cowasm/memfs */ \"(pages-dir-browser)/./node_modules/@cowasm/memfs/lib/index.js\");\nconst unionfs_1 = __webpack_require__(/*! @wapython/unionfs */ \"(pages-dir-browser)/./node_modules/@wapython/unionfs/lib/index.js\");\nfunction createFileSystem(specs, nativeFs) {\n    if (specs.length == 0) {\n        return memFs(); // empty memfs\n    }\n    if (specs.length == 1) {\n        // don't use unionfs:\n        return specToFs(specs[0], nativeFs) ?? memFs();\n    }\n    const ufs = new unionfs_1.Union();\n    const v = [];\n    for (const spec of specs) {\n        const fs = specToFs(spec, nativeFs);\n        if (fs != null) {\n            // e.g., native bindings may be null.\n            ufs.use(fs);\n            if (fs.waitUntilLoaded != null) {\n                v.push(fs.waitUntilLoaded.bind(fs));\n            }\n        }\n    }\n    const waitUntilLoaded = async () => {\n        for (const wait of v) {\n            await wait();\n        }\n    };\n    return { ...ufs, constants: memfs_1.fs.constants, waitUntilLoaded };\n}\nexports.createFileSystem = createFileSystem;\nfunction specToFs(spec, nativeFs) {\n    // All these \"as any\" are because really nothing quite implements FileSystem yet!\n    // See https://github.com/streamich/memfs/issues/735\n    if (spec.type == \"zip\") {\n        return zipFs(spec.data, spec.mountpoint);\n    }\n    else if (spec.type == \"zip-async\") {\n        return zipFsAsync(spec.getData, spec.mountpoint);\n    }\n    else if (spec.type == \"zipfile\") {\n        throw Error(`you must convert zipfile -- read ${spec.zipfile} into memory`);\n    }\n    else if (spec.type == \"zipurl\") {\n        throw Error(`you must convert zipurl -- read ${spec.zipurl} into memory`);\n    }\n    else if (spec.type == \"native\") {\n        // native = whatever is in bindings.\n        return nativeFs == null ? nativeFs : mapFlags(nativeFs);\n    }\n    else if (spec.type == \"mem\") {\n        return memFs(spec.contents);\n    }\n    else if (spec.type == \"dev\") {\n        return devFs();\n    }\n    throw Error(`unknown spec type - ${JSON.stringify(spec)}`);\n}\n// this is generic and would work in a browser:\nfunction devFs() {\n    const vol = memfs_1.Volume.fromJSON({\n        \"/dev/stdin\": \"\",\n        \"/dev/stdout\": \"\",\n        \"/dev/stderr\": \"\",\n    });\n    vol.releasedFds = [0, 1, 2];\n    const fdErr = vol.openSync(\"/dev/stderr\", \"w\");\n    const fdOut = vol.openSync(\"/dev/stdout\", \"w\");\n    const fdIn = vol.openSync(\"/dev/stdin\", \"r\");\n    if (fdErr != 2)\n        throw Error(`invalid handle for stderr: ${fdErr}`);\n    if (fdOut != 1)\n        throw Error(`invalid handle for stdout: ${fdOut}`);\n    if (fdIn != 0)\n        throw Error(`invalid handle for stdin: ${fdIn}`);\n    return (0, memfs_1.createFsFromVolume)(vol);\n}\nfunction zipFs(data, directory = \"/\") {\n    const fs = (0, memfs_1.createFsFromVolume)(new memfs_1.Volume());\n    fs.mkdirSync(directory, { recursive: true });\n    (0, unzip_1.default)({ data, fs, directory });\n    return fs;\n}\nfunction zipFsAsync(getData, directory = \"/\") {\n    const fs = (0, memfs_1.createFsFromVolume)(new memfs_1.Volume());\n    const load = async () => {\n        let data;\n        try {\n            data = await getData();\n        }\n        catch (err) {\n            console.warn(`FAILED to load async filesystem for '${directory}' - ${err}`);\n            throw err;\n        }\n        // NOTE: there is an async version of this, but it runs in another\n        // webworker and costs significant overhead, so not worth it.\n        (0, unzip_1.default)({ data, fs, directory });\n    };\n    const loadingPromise = load();\n    fs.waitUntilLoaded = () => loadingPromise;\n    return fs;\n}\nfunction memFs(contents) {\n    const vol = contents != null ? memfs_1.Volume.fromJSON(contents) : new memfs_1.Volume();\n    return (0, memfs_1.createFsFromVolume)(vol);\n}\nfunction mapFlags(nativeFs) {\n    function translate(flags) {\n        // We have to translate the flags from WASM/memfs/musl to native for this operating system.\n        // E.g., on MacOS many flags are completely different.  See big comment below.\n        let nativeFlags = 0;\n        for (const flag in memfs_1.fs.constants) {\n            // only flags starting with O_ are relevant for the open syscall.\n            if (flag.startsWith(\"O_\") && flags & memfs_1.fs.constants[flag]) {\n                nativeFlags |= nativeFs.constants[flag];\n            }\n        }\n        return nativeFlags;\n    }\n    // \"any\" because there's something weird involving a __promises__ namespace that I don't understand.\n    const open = async (path, flags, mode) => {\n        return await nativeFs.open(path, translate(flags), mode);\n    };\n    const openSync = (path, flags, mode) => {\n        return nativeFs.openSync(path, translate(flags), mode);\n    };\n    const promises = {\n        ...nativeFs.promises,\n        open: async (path, flags, mode) => {\n            return await nativeFs.promises.open(path, flags, mode);\n        },\n    };\n    return {\n        ...{ ...nativeFs, promises },\n        open,\n        openSync,\n        constants: memfs_1.fs.constants, // critical to ALWAYS use memfs constants for any filesystem.\n    };\n}\n/*\nComment about flags:\n\nA major subtle issue I hit is that unionfs combines filesystems, and\neach filesystem can define fs.constants differently! In particular,\nmemfs always hardcodes constants.O_EXCL to be 128.  However, on\nmacos native filesystem it is 2048, whereas on Linux native filesystem\nit is also 128.  We combine memfs and native for running python-wasm\nunder nodejs, since we want to use our Python install (that is in\ndist/python/python.zip and mounted using memfs) along with full access\nto the native filesystem.\n\nI think the only good solution to this is the following:\n- if native isn't part of the unionfs, nothing to do (since we only currently use native and memfs).\n- fs.constants should be memfs's constants since I think they match with what WebAssembly libc (via musl)\n  provides.\n- in the node api, the ONLY functions that take numeric flags are open and openSync.  That's convenient!\n- somehow figure out which filesystem (native or memfs for now) that a given open will go to, and\n  convert the flags if going to memfs.\n\nProbably the easiest way to accomplish all of the above is just use a proxy around native fs's\nopen* function.\n*/\n//# sourceMappingURL=fs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3QvZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsZ0NBQWdDLG1CQUFPLENBQUMseUVBQVM7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQWU7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQW1CO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0MsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLE1BQU0sSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcd2FzaS1qc1xcZGlzdFxcZnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuQ3JlYXRlIGEgdW5pb24gZmlsZXN5c3RlbSBhcyBkZXNjcmliZWQgYnkgYSBGaWxlU3lzdGVtU3BlY1tdLlxuXG5UaGlzIGNvZGUgc2hvdWxkIG5vdCBkZXBlbmQgb24gYW55dGhpbmcgdGhhdCBtdXN0IHJ1biBpbiBub2RlLmpzLlxuXG5Ob3RlIHRoYXQgdGhpcyBpcyBlbnRpcmVseSBzeW5jaHJvbm91cyBjb2RlLCBlLmcuLCB0aGUgdW56aXAgY29kZSxcbmFuZCB0aGF0J3MganVzdGlmaWVkIGJlY2F1c2Ugb3VyIFdBU00gaW50ZXJwcmV0ZXIgd2lsbCBsaWtlbHkgZ2V0XG5ydW4gaW4gYSBkaWZmZXJlbnQgdGhyZWFkIChhIHdlYndvcmtlcikgdGhhbiB0aGUgbWFpbiB0aHJlYWQsIGFuZFxudGhpcyBjb2RlIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGl0IGJlZm9yZSBhbnl0aGluZyBlbHNlIGNhbiBoYXBwZW4uXG4qL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGaWxlU3lzdGVtID0gdm9pZCAwO1xuY29uc3QgdW56aXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91bnppcFwiKSk7XG5jb25zdCBtZW1mc18xID0gcmVxdWlyZShcIkBjb3dhc20vbWVtZnNcIik7XG5jb25zdCB1bmlvbmZzXzEgPSByZXF1aXJlKFwiQHdhcHl0aG9uL3VuaW9uZnNcIik7XG5mdW5jdGlvbiBjcmVhdGVGaWxlU3lzdGVtKHNwZWNzLCBuYXRpdmVGcykge1xuICAgIGlmIChzcGVjcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gbWVtRnMoKTsgLy8gZW1wdHkgbWVtZnNcbiAgICB9XG4gICAgaWYgKHNwZWNzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIGRvbid0IHVzZSB1bmlvbmZzOlxuICAgICAgICByZXR1cm4gc3BlY1RvRnMoc3BlY3NbMF0sIG5hdGl2ZUZzKSA/PyBtZW1GcygpO1xuICAgIH1cbiAgICBjb25zdCB1ZnMgPSBuZXcgdW5pb25mc18xLlVuaW9uKCk7XG4gICAgY29uc3QgdiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICBjb25zdCBmcyA9IHNwZWNUb0ZzKHNwZWMsIG5hdGl2ZUZzKTtcbiAgICAgICAgaWYgKGZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGUuZy4sIG5hdGl2ZSBiaW5kaW5ncyBtYXkgYmUgbnVsbC5cbiAgICAgICAgICAgIHVmcy51c2UoZnMpO1xuICAgICAgICAgICAgaWYgKGZzLndhaXRVbnRpbExvYWRlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdi5wdXNoKGZzLndhaXRVbnRpbExvYWRlZC5iaW5kKGZzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FpdFVudGlsTG9hZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHdhaXQgb2Ygdikge1xuICAgICAgICAgICAgYXdhaXQgd2FpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyAuLi51ZnMsIGNvbnN0YW50czogbWVtZnNfMS5mcy5jb25zdGFudHMsIHdhaXRVbnRpbExvYWRlZCB9O1xufVxuZXhwb3J0cy5jcmVhdGVGaWxlU3lzdGVtID0gY3JlYXRlRmlsZVN5c3RlbTtcbmZ1bmN0aW9uIHNwZWNUb0ZzKHNwZWMsIG5hdGl2ZUZzKSB7XG4gICAgLy8gQWxsIHRoZXNlIFwiYXMgYW55XCIgYXJlIGJlY2F1c2UgcmVhbGx5IG5vdGhpbmcgcXVpdGUgaW1wbGVtZW50cyBGaWxlU3lzdGVtIHlldCFcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0cmVhbWljaC9tZW1mcy9pc3N1ZXMvNzM1XG4gICAgaWYgKHNwZWMudHlwZSA9PSBcInppcFwiKSB7XG4gICAgICAgIHJldHVybiB6aXBGcyhzcGVjLmRhdGEsIHNwZWMubW91bnRwb2ludCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNwZWMudHlwZSA9PSBcInppcC1hc3luY1wiKSB7XG4gICAgICAgIHJldHVybiB6aXBGc0FzeW5jKHNwZWMuZ2V0RGF0YSwgc3BlYy5tb3VudHBvaW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3BlYy50eXBlID09IFwiemlwZmlsZVwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGB5b3UgbXVzdCBjb252ZXJ0IHppcGZpbGUgLS0gcmVhZCAke3NwZWMuemlwZmlsZX0gaW50byBtZW1vcnlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3BlYy50eXBlID09IFwiemlwdXJsXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHlvdSBtdXN0IGNvbnZlcnQgemlwdXJsIC0tIHJlYWQgJHtzcGVjLnppcHVybH0gaW50byBtZW1vcnlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3BlYy50eXBlID09IFwibmF0aXZlXCIpIHtcbiAgICAgICAgLy8gbmF0aXZlID0gd2hhdGV2ZXIgaXMgaW4gYmluZGluZ3MuXG4gICAgICAgIHJldHVybiBuYXRpdmVGcyA9PSBudWxsID8gbmF0aXZlRnMgOiBtYXBGbGFncyhuYXRpdmVGcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNwZWMudHlwZSA9PSBcIm1lbVwiKSB7XG4gICAgICAgIHJldHVybiBtZW1GcyhzcGVjLmNvbnRlbnRzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3BlYy50eXBlID09IFwiZGV2XCIpIHtcbiAgICAgICAgcmV0dXJuIGRldkZzKCk7XG4gICAgfVxuICAgIHRocm93IEVycm9yKGB1bmtub3duIHNwZWMgdHlwZSAtICR7SlNPTi5zdHJpbmdpZnkoc3BlYyl9YCk7XG59XG4vLyB0aGlzIGlzIGdlbmVyaWMgYW5kIHdvdWxkIHdvcmsgaW4gYSBicm93c2VyOlxuZnVuY3Rpb24gZGV2RnMoKSB7XG4gICAgY29uc3Qgdm9sID0gbWVtZnNfMS5Wb2x1bWUuZnJvbUpTT04oe1xuICAgICAgICBcIi9kZXYvc3RkaW5cIjogXCJcIixcbiAgICAgICAgXCIvZGV2L3N0ZG91dFwiOiBcIlwiLFxuICAgICAgICBcIi9kZXYvc3RkZXJyXCI6IFwiXCIsXG4gICAgfSk7XG4gICAgdm9sLnJlbGVhc2VkRmRzID0gWzAsIDEsIDJdO1xuICAgIGNvbnN0IGZkRXJyID0gdm9sLm9wZW5TeW5jKFwiL2Rldi9zdGRlcnJcIiwgXCJ3XCIpO1xuICAgIGNvbnN0IGZkT3V0ID0gdm9sLm9wZW5TeW5jKFwiL2Rldi9zdGRvdXRcIiwgXCJ3XCIpO1xuICAgIGNvbnN0IGZkSW4gPSB2b2wub3BlblN5bmMoXCIvZGV2L3N0ZGluXCIsIFwiclwiKTtcbiAgICBpZiAoZmRFcnIgIT0gMilcbiAgICAgICAgdGhyb3cgRXJyb3IoYGludmFsaWQgaGFuZGxlIGZvciBzdGRlcnI6ICR7ZmRFcnJ9YCk7XG4gICAgaWYgKGZkT3V0ICE9IDEpXG4gICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkIGhhbmRsZSBmb3Igc3Rkb3V0OiAke2ZkT3V0fWApO1xuICAgIGlmIChmZEluICE9IDApXG4gICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW46ICR7ZmRJbn1gKTtcbiAgICByZXR1cm4gKDAsIG1lbWZzXzEuY3JlYXRlRnNGcm9tVm9sdW1lKSh2b2wpO1xufVxuZnVuY3Rpb24gemlwRnMoZGF0YSwgZGlyZWN0b3J5ID0gXCIvXCIpIHtcbiAgICBjb25zdCBmcyA9ICgwLCBtZW1mc18xLmNyZWF0ZUZzRnJvbVZvbHVtZSkobmV3IG1lbWZzXzEuVm9sdW1lKCkpO1xuICAgIGZzLm1rZGlyU3luYyhkaXJlY3RvcnksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICgwLCB1bnppcF8xLmRlZmF1bHQpKHsgZGF0YSwgZnMsIGRpcmVjdG9yeSB9KTtcbiAgICByZXR1cm4gZnM7XG59XG5mdW5jdGlvbiB6aXBGc0FzeW5jKGdldERhdGEsIGRpcmVjdG9yeSA9IFwiL1wiKSB7XG4gICAgY29uc3QgZnMgPSAoMCwgbWVtZnNfMS5jcmVhdGVGc0Zyb21Wb2x1bWUpKG5ldyBtZW1mc18xLlZvbHVtZSgpKTtcbiAgICBjb25zdCBsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBnZXREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBGQUlMRUQgdG8gbG9hZCBhc3luYyBmaWxlc3lzdGVtIGZvciAnJHtkaXJlY3Rvcnl9JyAtICR7ZXJyfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFuIGFzeW5jIHZlcnNpb24gb2YgdGhpcywgYnV0IGl0IHJ1bnMgaW4gYW5vdGhlclxuICAgICAgICAvLyB3ZWJ3b3JrZXIgYW5kIGNvc3RzIHNpZ25pZmljYW50IG92ZXJoZWFkLCBzbyBub3Qgd29ydGggaXQuXG4gICAgICAgICgwLCB1bnppcF8xLmRlZmF1bHQpKHsgZGF0YSwgZnMsIGRpcmVjdG9yeSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlID0gbG9hZCgpO1xuICAgIGZzLndhaXRVbnRpbExvYWRlZCA9ICgpID0+IGxvYWRpbmdQcm9taXNlO1xuICAgIHJldHVybiBmcztcbn1cbmZ1bmN0aW9uIG1lbUZzKGNvbnRlbnRzKSB7XG4gICAgY29uc3Qgdm9sID0gY29udGVudHMgIT0gbnVsbCA/IG1lbWZzXzEuVm9sdW1lLmZyb21KU09OKGNvbnRlbnRzKSA6IG5ldyBtZW1mc18xLlZvbHVtZSgpO1xuICAgIHJldHVybiAoMCwgbWVtZnNfMS5jcmVhdGVGc0Zyb21Wb2x1bWUpKHZvbCk7XG59XG5mdW5jdGlvbiBtYXBGbGFncyhuYXRpdmVGcykge1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShmbGFncykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHRyYW5zbGF0ZSB0aGUgZmxhZ3MgZnJvbSBXQVNNL21lbWZzL211c2wgdG8gbmF0aXZlIGZvciB0aGlzIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICAgIC8vIEUuZy4sIG9uIE1hY09TIG1hbnkgZmxhZ3MgYXJlIGNvbXBsZXRlbHkgZGlmZmVyZW50LiAgU2VlIGJpZyBjb21tZW50IGJlbG93LlxuICAgICAgICBsZXQgbmF0aXZlRmxhZ3MgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZsYWcgaW4gbWVtZnNfMS5mcy5jb25zdGFudHMpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgZmxhZ3Mgc3RhcnRpbmcgd2l0aCBPXyBhcmUgcmVsZXZhbnQgZm9yIHRoZSBvcGVuIHN5c2NhbGwuXG4gICAgICAgICAgICBpZiAoZmxhZy5zdGFydHNXaXRoKFwiT19cIikgJiYgZmxhZ3MgJiBtZW1mc18xLmZzLmNvbnN0YW50c1tmbGFnXSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZUZsYWdzIHw9IG5hdGl2ZUZzLmNvbnN0YW50c1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlRmxhZ3M7XG4gICAgfVxuICAgIC8vIFwiYW55XCIgYmVjYXVzZSB0aGVyZSdzIHNvbWV0aGluZyB3ZWlyZCBpbnZvbHZpbmcgYSBfX3Byb21pc2VzX18gbmFtZXNwYWNlIHRoYXQgSSBkb24ndCB1bmRlcnN0YW5kLlxuICAgIGNvbnN0IG9wZW4gPSBhc3luYyAocGF0aCwgZmxhZ3MsIG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5hdGl2ZUZzLm9wZW4ocGF0aCwgdHJhbnNsYXRlKGZsYWdzKSwgbW9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcGVuU3luYyA9IChwYXRoLCBmbGFncywgbW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmF0aXZlRnMub3BlblN5bmMocGF0aCwgdHJhbnNsYXRlKGZsYWdzKSwgbW9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IHtcbiAgICAgICAgLi4ubmF0aXZlRnMucHJvbWlzZXMsXG4gICAgICAgIG9wZW46IGFzeW5jIChwYXRoLCBmbGFncywgbW9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5hdGl2ZUZzLnByb21pc2VzLm9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ueyAuLi5uYXRpdmVGcywgcHJvbWlzZXMgfSxcbiAgICAgICAgb3BlbixcbiAgICAgICAgb3BlblN5bmMsXG4gICAgICAgIGNvbnN0YW50czogbWVtZnNfMS5mcy5jb25zdGFudHMsIC8vIGNyaXRpY2FsIHRvIEFMV0FZUyB1c2UgbWVtZnMgY29uc3RhbnRzIGZvciBhbnkgZmlsZXN5c3RlbS5cbiAgICB9O1xufVxuLypcbkNvbW1lbnQgYWJvdXQgZmxhZ3M6XG5cbkEgbWFqb3Igc3VidGxlIGlzc3VlIEkgaGl0IGlzIHRoYXQgdW5pb25mcyBjb21iaW5lcyBmaWxlc3lzdGVtcywgYW5kXG5lYWNoIGZpbGVzeXN0ZW0gY2FuIGRlZmluZSBmcy5jb25zdGFudHMgZGlmZmVyZW50bHkhIEluIHBhcnRpY3VsYXIsXG5tZW1mcyBhbHdheXMgaGFyZGNvZGVzIGNvbnN0YW50cy5PX0VYQ0wgdG8gYmUgMTI4LiAgSG93ZXZlciwgb25cbm1hY29zIG5hdGl2ZSBmaWxlc3lzdGVtIGl0IGlzIDIwNDgsIHdoZXJlYXMgb24gTGludXggbmF0aXZlIGZpbGVzeXN0ZW1cbml0IGlzIGFsc28gMTI4LiAgV2UgY29tYmluZSBtZW1mcyBhbmQgbmF0aXZlIGZvciBydW5uaW5nIHB5dGhvbi13YXNtXG51bmRlciBub2RlanMsIHNpbmNlIHdlIHdhbnQgdG8gdXNlIG91ciBQeXRob24gaW5zdGFsbCAodGhhdCBpcyBpblxuZGlzdC9weXRob24vcHl0aG9uLnppcCBhbmQgbW91bnRlZCB1c2luZyBtZW1mcykgYWxvbmcgd2l0aCBmdWxsIGFjY2Vzc1xudG8gdGhlIG5hdGl2ZSBmaWxlc3lzdGVtLlxuXG5JIHRoaW5rIHRoZSBvbmx5IGdvb2Qgc29sdXRpb24gdG8gdGhpcyBpcyB0aGUgZm9sbG93aW5nOlxuLSBpZiBuYXRpdmUgaXNuJ3QgcGFydCBvZiB0aGUgdW5pb25mcywgbm90aGluZyB0byBkbyAoc2luY2Ugd2Ugb25seSBjdXJyZW50bHkgdXNlIG5hdGl2ZSBhbmQgbWVtZnMpLlxuLSBmcy5jb25zdGFudHMgc2hvdWxkIGJlIG1lbWZzJ3MgY29uc3RhbnRzIHNpbmNlIEkgdGhpbmsgdGhleSBtYXRjaCB3aXRoIHdoYXQgV2ViQXNzZW1ibHkgbGliYyAodmlhIG11c2wpXG4gIHByb3ZpZGVzLlxuLSBpbiB0aGUgbm9kZSBhcGksIHRoZSBPTkxZIGZ1bmN0aW9ucyB0aGF0IHRha2UgbnVtZXJpYyBmbGFncyBhcmUgb3BlbiBhbmQgb3BlblN5bmMuICBUaGF0J3MgY29udmVuaWVudCFcbi0gc29tZWhvdyBmaWd1cmUgb3V0IHdoaWNoIGZpbGVzeXN0ZW0gKG5hdGl2ZSBvciBtZW1mcyBmb3Igbm93KSB0aGF0IGEgZ2l2ZW4gb3BlbiB3aWxsIGdvIHRvLCBhbmRcbiAgY29udmVydCB0aGUgZmxhZ3MgaWYgZ29pbmcgdG8gbWVtZnMuXG5cblByb2JhYmx5IHRoZSBlYXNpZXN0IHdheSB0byBhY2NvbXBsaXNoIGFsbCBvZiB0aGUgYWJvdmUgaXMganVzdCB1c2UgYSBwcm94eSBhcm91bmQgbmF0aXZlIGZzJ3Ncbm9wZW4qIGZ1bmN0aW9uLlxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/fs.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/wasi-js/dist/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.constants = exports.createFileSystem = exports.SOCKET_DEFAULT_RIGHTS = void 0;\nconst wasi_1 = __importStar(__webpack_require__(/*! ./wasi */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/wasi.js\"));\nObject.defineProperty(exports, \"SOCKET_DEFAULT_RIGHTS\", ({ enumerable: true, get: function () { return wasi_1.SOCKET_DEFAULT_RIGHTS; } }));\nexports[\"default\"] = wasi_1.default;\nvar fs_1 = __webpack_require__(/*! ./fs */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/fs.js\");\nObject.defineProperty(exports, \"createFileSystem\", ({ enumerable: true, get: function () { return fs_1.createFileSystem; } }));\nconst constants = __importStar(__webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/constants.js\"));\nexports.constants = constants;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QjtBQUM1RSw0QkFBNEIsbUJBQU8sQ0FBQyx1RUFBUTtBQUM1Qyx5REFBd0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDeEksa0JBQWU7QUFDZixXQUFXLG1CQUFPLENBQUMsbUVBQU07QUFDekIsb0RBQW1ELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQzVILCtCQUErQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3BELGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHdhc2ktanNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN0YW50cyA9IGV4cG9ydHMuY3JlYXRlRmlsZVN5c3RlbSA9IGV4cG9ydHMuU09DS0VUX0RFRkFVTFRfUklHSFRTID0gdm9pZCAwO1xuY29uc3Qgd2FzaV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhc2lcIikpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU09DS0VUX0RFRkFVTFRfUklHSFRTXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3YXNpXzEuU09DS0VUX0RFRkFVTFRfUklHSFRTOyB9IH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2FzaV8xLmRlZmF1bHQ7XG52YXIgZnNfMSA9IHJlcXVpcmUoXCIuL2ZzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlRmlsZVN5c3RlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnNfMS5jcmVhdGVGaWxlU3lzdGVtOyB9IH0pO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSk7XG5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/types.js":
/*!********************************************!*\
  !*** ./node_modules/wasi-js/dist/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WASIKillError = exports.WASIExitError = exports.WASIError = void 0;\nclass WASIError extends Error {\n    constructor(errno) {\n        super();\n        this.errno = errno;\n        Object.setPrototypeOf(this, WASIError.prototype);\n    }\n}\nexports.WASIError = WASIError;\nclass WASIExitError extends Error {\n    constructor(code) {\n        super(`WASI Exit error: ${code}`);\n        this.code = code;\n        Object.setPrototypeOf(this, WASIExitError.prototype);\n    }\n}\nexports.WASIExitError = WASIExitError;\nclass WASIKillError extends Error {\n    constructor(signal) {\n        super(`WASI Kill signal: ${signal}`);\n        this.signal = signal;\n        Object.setPrototypeOf(this, WASIKillError.prototype);\n    }\n}\nexports.WASIKillError = WASIKillError;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFx3YXNpLWpzXFxkaXN0XFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV0FTSUtpbGxFcnJvciA9IGV4cG9ydHMuV0FTSUV4aXRFcnJvciA9IGV4cG9ydHMuV0FTSUVycm9yID0gdm9pZCAwO1xuY2xhc3MgV0FTSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm5vKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJybm8gPSBlcnJubztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdBU0lFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuV0FTSUVycm9yID0gV0FTSUVycm9yO1xuY2xhc3MgV0FTSUV4aXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKGBXQVNJIEV4aXQgZXJyb3I6ICR7Y29kZX1gKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdBU0lFeGl0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLldBU0lFeGl0RXJyb3IgPSBXQVNJRXhpdEVycm9yO1xuY2xhc3MgV0FTSUtpbGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaWduYWwpIHtcbiAgICAgICAgc3VwZXIoYFdBU0kgS2lsbCBzaWduYWw6ICR7c2lnbmFsfWApO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdBU0lLaWxsRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLldBU0lLaWxsRXJyb3IgPSBXQVNJS2lsbEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/types.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/unzip.js":
/*!********************************************!*\
  !*** ./node_modules/wasi-js/dist/unzip.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst path_1 = __webpack_require__(/*! path */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fflate_1 = __webpack_require__(/*! fflate */ \"(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/index.cjs\");\nfunction unzip({ data, fs, directory }) {\n    // const t0 = new Date().valueOf();\n    if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n    }\n    if (!(data instanceof Uint8Array)) {\n        throw Error(\"impossible\"); // was converted above. this is for typescript.\n    }\n    const z = (0, fflate_1.unzipSync)(data);\n    for (const [relativePath, content] of Object.entries(z)) {\n        const outputFilename = (0, path_1.join)(directory, relativePath);\n        fs.mkdirSync((0, path_1.dirname)(outputFilename), { recursive: true });\n        if (outputFilename.endsWith('/')) {\n            // it is a directory, not a file.\n            continue;\n        }\n        fs.writeFileSync(outputFilename, content);\n        fs.chmodSync(outputFilename, 0o777);\n    }\n    //   console.log(\n    //     `extract ${data.length / 10 ** 6} MB in ${new Date().valueOf() - t0}ms`\n    //   );\n}\nexports[\"default\"] = unzip;\n//# sourceMappingURL=unzip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3QvdW56aXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDRGQUFNO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFRO0FBQ2pDLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsUUFBUSwwQkFBMEI7QUFDL0U7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFx3YXNpLWpzXFxkaXN0XFx1bnppcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZmZsYXRlXzEgPSByZXF1aXJlKFwiZmZsYXRlXCIpO1xuZnVuY3Rpb24gdW56aXAoeyBkYXRhLCBmcywgZGlyZWN0b3J5IH0pIHtcbiAgICAvLyBjb25zdCB0MCA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbXBvc3NpYmxlXCIpOyAvLyB3YXMgY29udmVydGVkIGFib3ZlLiB0aGlzIGlzIGZvciB0eXBlc2NyaXB0LlxuICAgIH1cbiAgICBjb25zdCB6ID0gKDAsIGZmbGF0ZV8xLnVuemlwU3luYykoZGF0YSk7XG4gICAgZm9yIChjb25zdCBbcmVsYXRpdmVQYXRoLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyh6KSkge1xuICAgICAgICBjb25zdCBvdXRwdXRGaWxlbmFtZSA9ICgwLCBwYXRoXzEuam9pbikoZGlyZWN0b3J5LCByZWxhdGl2ZVBhdGgpO1xuICAgICAgICBmcy5ta2RpclN5bmMoKDAsIHBhdGhfMS5kaXJuYW1lKShvdXRwdXRGaWxlbmFtZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICBpZiAob3V0cHV0RmlsZW5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgLy8gaXQgaXMgYSBkaXJlY3RvcnksIG5vdCBhIGZpbGUuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dEZpbGVuYW1lLCBjb250ZW50KTtcbiAgICAgICAgZnMuY2htb2RTeW5jKG91dHB1dEZpbGVuYW1lLCAwbzc3Nyk7XG4gICAgfVxuICAgIC8vICAgY29uc29sZS5sb2coXG4gICAgLy8gICAgIGBleHRyYWN0ICR7ZGF0YS5sZW5ndGggLyAxMCAqKiA2fSBNQiBpbiAke25ldyBEYXRlKCkudmFsdWVPZigpIC0gdDB9bXNgXG4gICAgLy8gICApO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdW56aXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnppcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/unzip.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/dist/wasi.js":
/*!*******************************************!*\
  !*** ./node_modules/wasi-js/dist/wasi.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n/* MIT licensed.  See README.md for copyright and history information.\n\nFor API docs about what these functions below are supposed to be, see\n\nhttps://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md\n\nand a TODO is copy/paste most of that as comments below.\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SOCKET_DEFAULT_RIGHTS = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(pages-dir-browser)/./node_modules/debug/src/browser.js\"));\nconst log = (0, debug_1.default)(\"wasi\");\nconst logOpen = (0, debug_1.default)(\"wasi:open\"); // just log opening files, which is useful\n// See the comment in packages/cpython/src/pyconfig.h\n// In particular, until we patch cpython itself, it's really\n// only safe to set this to 256.  TODO: we plan to patch\n// everything in cpython that falls back to 256 to instead\n// use the value 32768.\nconst SC_OPEN_MAX = 32768;\nconst types_1 = __webpack_require__(/*! ./types */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/types.js\");\nconst typedarray_to_buffer_1 = __importDefault(__webpack_require__(/*! typedarray-to-buffer */ \"(pages-dir-browser)/./node_modules/typedarray-to-buffer/index.js\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./node_modules/wasi-js/dist/constants.js\");\nconst STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |\n    constants_1.WASI_RIGHT_FD_READ |\n    constants_1.WASI_RIGHT_FD_SYNC |\n    constants_1.WASI_RIGHT_FD_ADVISE |\n    constants_1.WASI_RIGHT_FD_FILESTAT_GET |\n    constants_1.WASI_RIGHT_POLL_FD_READWRITE;\nconst STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |\n    constants_1.WASI_RIGHT_FD_WRITE |\n    constants_1.WASI_RIGHT_FD_SYNC |\n    constants_1.WASI_RIGHT_FD_ADVISE |\n    constants_1.WASI_RIGHT_FD_FILESTAT_GET |\n    constants_1.WASI_RIGHT_POLL_FD_READWRITE;\nconst STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;\n// I don't know what this *should* be, but I'm\n// adding things as they are expected/implemented.\nexports.SOCKET_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |\n    constants_1.WASI_RIGHT_FD_READ |\n    constants_1.WASI_RIGHT_FD_WRITE |\n    constants_1.WASI_RIGHT_FD_ADVISE |\n    constants_1.WASI_RIGHT_FD_FILESTAT_GET |\n    constants_1.WASI_RIGHT_POLL_FD_READWRITE |\n    constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\nconst msToNs = (ms) => {\n    const msInt = Math.trunc(ms);\n    const decimal = BigInt(Math.round((ms - msInt) * 1000000));\n    const ns = BigInt(msInt) * BigInt(1000000);\n    return ns + decimal;\n};\nconst nsToMs = (ns) => {\n    if (typeof ns === \"number\") {\n        ns = Math.trunc(ns);\n    }\n    const nsInt = BigInt(ns);\n    return Number(nsInt / BigInt(1000000));\n};\nconst wrap = (f) => (...args) => {\n    try {\n        return f(...args);\n    }\n    catch (err) {\n        // log(\"WASI error\", err);\n        // console.trace(err);\n        let e = err;\n        // This is to support unionfs, e.g., in fd_write if a pipe\n        // breaks, then unionfs raises \"Error: EBADF: bad file descriptor, write\",\n        // but the relevant error is \"prev: Error: EPIPE: broken pipe, write\", which it saves.\n        while (e.prev != null) {\n            e = e.prev;\n        }\n        // If it's an error from the fs\n        if (e?.code && typeof e?.code === \"string\") {\n            return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;\n        }\n        // If it's a WASI error, we return it directly\n        if (e instanceof types_1.WASIError) {\n            return e.errno;\n        }\n        // Otherwise we let the error bubble up\n        throw e;\n    }\n};\nconst stat = (wasi, fd) => {\n    const entry = wasi.FD_MAP.get(fd);\n    // console.log(\"stat\", { fd, entry, FD_MAP: wasi.FD_MAP });\n    // log(\"stat\", { fd, entry, FD_MAP: wasi.FD_MAP });\n    if (!entry) {\n        throw new types_1.WASIError(constants_1.WASI_EBADF);\n    }\n    if (entry.filetype === undefined) {\n        const stats = wasi.fstatSync(entry.real);\n        const { filetype, rightsBase, rightsInheriting } = translateFileAttributes(wasi, fd, stats);\n        entry.filetype = filetype;\n        if (!entry.rights) {\n            entry.rights = {\n                base: rightsBase,\n                inheriting: rightsInheriting,\n            };\n        }\n    }\n    return entry;\n};\nconst translateFileAttributes = (wasi, fd, stats) => {\n    switch (true) {\n        case stats.isBlockDevice():\n            return {\n                filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,\n                rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,\n                rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING,\n            };\n        case stats.isCharacterDevice(): {\n            const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n            if (fd !== undefined && wasi.bindings.isTTY(fd)) {\n                return {\n                    filetype,\n                    rightsBase: constants_1.RIGHTS_TTY_BASE,\n                    rightsInheriting: constants_1.RIGHTS_TTY_INHERITING,\n                };\n            }\n            return {\n                filetype,\n                rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,\n                rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING,\n            };\n        }\n        case stats.isDirectory():\n            return {\n                filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n                rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,\n                rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING,\n            };\n        case stats.isFIFO():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n                rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING,\n            };\n        case stats.isFile():\n            return {\n                filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,\n                rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,\n                rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING,\n            };\n        case stats.isSocket():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n                rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING,\n            };\n        case stats.isSymbolicLink():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,\n                rightsBase: BigInt(0),\n                rightsInheriting: BigInt(0),\n            };\n        default:\n            return {\n                filetype: constants_1.WASI_FILETYPE_UNKNOWN,\n                rightsBase: BigInt(0),\n                rightsInheriting: BigInt(0),\n            };\n    }\n};\n// const logToFile = (...args) => {\n//   require(\"fs\").appendFileSync(\n//     \"/tmp/wasi.log\",\n//     args.map((x) => `${x}`).join(\" \") + \"\\n\"\n//   );\n// };\nlet warnedAboutSleep = false;\nclass WASI {\n    constructor(wasiConfig) {\n        this.lastStdin = 0;\n        this.env = {};\n        this.sleep = wasiConfig.sleep;\n        this.getStdin = wasiConfig.getStdin;\n        this.sendStdout = wasiConfig.sendStdout;\n        this.sendStderr = wasiConfig.sendStderr;\n        // Destructure our wasiConfig\n        let preopens = {};\n        if (wasiConfig.preopens) {\n            preopens = wasiConfig.preopens;\n        }\n        if (wasiConfig && wasiConfig.env) {\n            this.env = wasiConfig.env;\n        }\n        let args = [];\n        if (wasiConfig && wasiConfig.args) {\n            args = wasiConfig.args;\n        }\n        // @ts-ignore\n        this.memory = undefined;\n        // @ts-ignore\n        this.view = undefined;\n        this.bindings = wasiConfig.bindings;\n        const fs = this.bindings.fs;\n        this.FD_MAP = new Map([\n            [\n                constants_1.WASI_STDIN_FILENO,\n                {\n                    real: 0,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDIN_DEFAULT_RIGHTS,\n                        inheriting: BigInt(0),\n                    },\n                    path: \"/dev/stdin\",\n                },\n            ],\n            [\n                constants_1.WASI_STDOUT_FILENO,\n                {\n                    real: 1,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDOUT_DEFAULT_RIGHTS,\n                        inheriting: BigInt(0),\n                    },\n                    path: \"/dev/stdout\",\n                },\n            ],\n            [\n                constants_1.WASI_STDERR_FILENO,\n                {\n                    real: 2,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDERR_DEFAULT_RIGHTS,\n                        inheriting: BigInt(0),\n                    },\n                    path: \"/dev/stderr\",\n                },\n            ],\n        ]);\n        const path = this.bindings.path;\n        for (const [k, v] of Object.entries(preopens)) {\n            const real = fs.openSync(v, fs.constants.O_RDONLY);\n            const newfd = this.getUnusedFileDescriptor();\n            this.FD_MAP.set(newfd, {\n                real,\n                filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n                // offset: BigInt(0),\n                rights: {\n                    base: constants_1.RIGHTS_DIRECTORY_BASE,\n                    inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING,\n                },\n                fakePath: k,\n                path: v,\n            });\n        }\n        const getiovs = (iovs, iovsLen) => {\n            // iovs* -> [iov, iov, ...]\n            // __wasi_ciovec_t {\n            //   void* buf,\n            //   size_t buf_len,\n            // }\n            this.refreshMemory();\n            const buffers = Array.from({ length: iovsLen }, (_, i) => {\n                const ptr = iovs + i * 8;\n                const buf = this.view.getUint32(ptr, true);\n                let bufLen = this.view.getUint32(ptr + 4, true);\n                // the mmap stuff in wasi tries to make this overwrite all\n                // allocated memory, so we cap it or things crash.\n                // TODO: maybe we need to allocate more memory?  I don't know!!\n                if (bufLen > this.memory.buffer.byteLength - buf) {\n                    //           console.log({\n                    //             buf,\n                    //             bufLen,\n                    //             total_memory: this.memory.buffer.byteLength,\n                    //           });\n                    log(\"getiovs: warning -- truncating buffer to fit in memory\");\n                    bufLen = Math.min(bufLen, Math.max(0, this.memory.buffer.byteLength - buf));\n                }\n                try {\n                    const buffer = new Uint8Array(this.memory.buffer, buf, bufLen);\n                    return (0, typedarray_to_buffer_1.default)(buffer);\n                }\n                catch (err) {\n                    // don't hide this\n                    console.warn(\"WASI.getiovs -- invalid buffer\", err);\n                    // but at least make it so we don't totally kill WASM, so we\n                    // get a traceback in the calling program (say python).\n                    // TODO: Right now this sort of thing happens with aggressive use of mmap,\n                    // but I plan to replace how mmap works with something that is viable.\n                    throw new types_1.WASIError(constants_1.WASI_EINVAL);\n                }\n            });\n            return buffers;\n        };\n        const CHECK_FD = (fd, rights) => {\n            // log(\"CHECK_FD\", { fd, rights });\n            const stats = stat(this, fd);\n            // log(\"CHECK_FD\", { stats });\n            if (rights !== BigInt(0) && (stats.rights.base & rights) === BigInt(0)) {\n                throw new types_1.WASIError(constants_1.WASI_EPERM);\n            }\n            return stats;\n        };\n        const CPUTIME_START = this.bindings.hrtime();\n        const now = (clockId) => {\n            switch (clockId) {\n                case constants_1.WASI_CLOCK_MONOTONIC:\n                    return this.bindings.hrtime();\n                case constants_1.WASI_CLOCK_REALTIME:\n                    return msToNs(Date.now());\n                case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n                case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: // TODO -- this assumes 1 thread\n                    return this.bindings.hrtime() - CPUTIME_START;\n                default:\n                    return null;\n            }\n        };\n        this.wasiImport = {\n            args_get: (argv, argvBuf) => {\n                this.refreshMemory();\n                let coffset = argv;\n                let offset = argvBuf;\n                args.forEach((a) => {\n                    this.view.setUint32(coffset, offset, true);\n                    coffset += 4;\n                    offset += Buffer.from(this.memory.buffer).write(`${a}\\0`, offset);\n                });\n                return constants_1.WASI_ESUCCESS;\n            },\n            args_sizes_get: (argc, argvBufSize) => {\n                this.refreshMemory();\n                this.view.setUint32(argc, args.length, true);\n                const size = args.reduce((acc, a) => acc + Buffer.byteLength(a) + 1, 0);\n                this.view.setUint32(argvBufSize, size, true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            environ_get: (environ, environBuf) => {\n                this.refreshMemory();\n                let coffset = environ;\n                let offset = environBuf;\n                Object.entries(this.env).forEach(([key, value]) => {\n                    this.view.setUint32(coffset, offset, true);\n                    coffset += 4;\n                    offset += Buffer.from(this.memory.buffer).write(`${key}=${value}\\0`, offset);\n                });\n                return constants_1.WASI_ESUCCESS;\n            },\n            environ_sizes_get: (environCount, environBufSize) => {\n                this.refreshMemory();\n                const envProcessed = Object.entries(this.env).map(([key, value]) => `${key}=${value}\\0`);\n                const size = envProcessed.reduce((acc, e) => acc + Buffer.byteLength(e), 0);\n                this.view.setUint32(environCount, envProcessed.length, true);\n                this.view.setUint32(environBufSize, size, true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            clock_res_get: (clockId, resolution) => {\n                let res;\n                switch (clockId) {\n                    case constants_1.WASI_CLOCK_MONOTONIC:\n                    case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n                    case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: {\n                        res = BigInt(1);\n                        break;\n                    }\n                    case constants_1.WASI_CLOCK_REALTIME: {\n                        res = BigInt(1000);\n                        break;\n                    }\n                }\n                if (!res) {\n                    throw Error(\"invalid clockId\");\n                }\n                this.view.setBigUint64(resolution, res);\n                return constants_1.WASI_ESUCCESS;\n            },\n            clock_time_get: (clockId, _precision, time) => {\n                this.refreshMemory();\n                const n = now(clockId);\n                if (n === null) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.view.setBigUint64(time, BigInt(n), true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            fd_advise: wrap((fd, _offset, _len, _advice) => {\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE);\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_allocate: wrap((fd, _offset, _len) => {\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE);\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_close: wrap((fd) => {\n                const stats = CHECK_FD(fd, BigInt(0));\n                fs.closeSync(stats.real);\n                this.FD_MAP.delete(fd);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_datasync: wrap((fd) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);\n                fs.fdatasyncSync(stats.real);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_fdstat_get: wrap((fd, bufPtr) => {\n                const stats = CHECK_FD(fd, BigInt(0));\n                // console.log(\"fd_fdstat_get\", fd, stats);\n                this.refreshMemory();\n                if (stats.filetype == null) {\n                    throw Error(\"stats.filetype must be set\");\n                }\n                this.view.setUint8(bufPtr, stats.filetype); // FILETYPE u8\n                this.view.setUint16(bufPtr + 2, 0, true); // FDFLAG u16\n                this.view.setUint16(bufPtr + 4, 0, true); // FDFLAG u16\n                this.view.setBigUint64(bufPtr + 8, BigInt(stats.rights.base), true); // u64\n                this.view.setBigUint64(bufPtr + 8 + 8, BigInt(stats.rights.inheriting), true); // u64\n                return constants_1.WASI_ESUCCESS;\n            }),\n            /*\n            fd_fdstat_set_flags\n      \n            Docs From upstream:\n            Adjust the flags associated with a file descriptor.\n            Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX.\n      \n            This could be supported via posix-node in general (when available)\n            for sockets and stdin/stdout/stderr and genuine files (but not\n            for memfs, obviously).  It's typically used by C programs for\n            locking files, but most importantly for us, for setting whether\n            reading from a fd is nonblocking (very important for stdin)\n            or should time out after a certain amount of time (e.g., very\n            important for a network socket).\n      \n            For now we implement this in a very small number of cases\n            and return \"Function not implemented\" otherwise.\n            */\n            fd_fdstat_set_flags: wrap((fd, flags) => {\n                // Are we allowed to set flags.  This more means: \"is it implemented?\".\n                // Right now we only set this flag for sockets (that's done in the\n                // external kernel module in src/wasm/posix/socket.ts).\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS);\n                if (this.wasiImport.sock_fcntlSetFlags(fd, flags) == 0) {\n                    return constants_1.WASI_ESUCCESS;\n                }\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_fdstat_set_rights: wrap((fd, fsRightsBase, fsRightsInheriting) => {\n                const stats = CHECK_FD(fd, BigInt(0));\n                const nrb = stats.rights.base | fsRightsBase;\n                if (nrb > stats.rights.base) {\n                    return constants_1.WASI_EPERM;\n                }\n                const nri = stats.rights.inheriting | fsRightsInheriting;\n                if (nri > stats.rights.inheriting) {\n                    return constants_1.WASI_EPERM;\n                }\n                stats.rights.base = fsRightsBase;\n                stats.rights.inheriting = fsRightsInheriting;\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_get: wrap((fd, bufPtr) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET);\n                const rstats = this.fstatSync(stats.real);\n                this.refreshMemory();\n                this.view.setBigUint64(bufPtr, BigInt(rstats.dev), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.ino), true);\n                bufPtr += 8;\n                if (stats.filetype == null) {\n                    throw Error(\"stats.filetype must be set\");\n                }\n                this.view.setUint8(bufPtr, stats.filetype);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.size), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_set_size: wrap((fd, stSize) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);\n                fs.ftruncateSync(stats.real, Number(stSize));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_set_times: wrap((fd, stAtim, stMtim, fstflags) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES);\n                const rstats = this.fstatSync(stats.real);\n                let atim = rstats.atime;\n                let mtim = rstats.mtime;\n                const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME));\n                const atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n                if ((fstflags & atimflags) === atimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n                if ((fstflags & mtimflags) === mtimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM) {\n                    atim = nsToMs(stAtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) ===\n                    constants_1.WASI_FILESTAT_SET_ATIM_NOW) {\n                    atim = n;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM) {\n                    mtim = nsToMs(stMtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) ===\n                    constants_1.WASI_FILESTAT_SET_MTIM_NOW) {\n                    mtim = n;\n                }\n                fs.futimesSync(stats.real, new Date(atim), new Date(mtim));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_prestat_get: wrap((fd, bufPtr) => {\n                const stats = CHECK_FD(fd, BigInt(0));\n                // log(\"fd_prestat_get\", { fd, stats });\n                this.refreshMemory();\n                this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR);\n                this.view.setUint32(bufPtr + 4, \n                // TODO: this is definitely completely wrong unless preopens=/.\n                // NOTE: when both paths are blank, we return \"\".  This is used by\n                // cPython on sockets.   It used to raise an error here.\n                Buffer.byteLength(stats.fakePath ?? stats.path ?? \"\"), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_prestat_dir_name: wrap((fd, pathPtr, pathLen) => {\n                const stats = CHECK_FD(fd, BigInt(0));\n                this.refreshMemory();\n                // NOTE: when both paths are blank, we return \"\".  This is used by\n                // cPython on sockets.  It used to raise an error here.\n                Buffer.from(this.memory.buffer).write(stats.fakePath ?? stats.path ?? \"\" /* TODO: wrong in general!? */, pathPtr, pathLen, \"utf8\");\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_pwrite: wrap((fd, iovs, iovsLen, offset, nwritten) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);\n                let written = 0;\n                getiovs(iovs, iovsLen).forEach((iov) => {\n                    let w = 0;\n                    while (w < iov.byteLength) {\n                        w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, Number(offset) + written + w);\n                    }\n                    written += w;\n                });\n                this.view.setUint32(nwritten, written, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_write: wrap((fd, iovs, iovsLen, nwritten) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE);\n                const IS_STDOUT = fd == constants_1.WASI_STDOUT_FILENO;\n                const IS_STDERR = fd == constants_1.WASI_STDERR_FILENO;\n                let written = 0;\n                getiovs(iovs, iovsLen).forEach((iov) => {\n                    //console.log(\"fd_write\", `\"${new TextDecoder().decode(iov)}\"`);\n                    if (iov.byteLength == 0)\n                        return;\n                    //             log(\n                    //               `writing to fd=${fd}: `,\n                    //               JSON.stringify(new TextDecoder().decode(iov)),\n                    //               JSON.stringify(iov)\n                    //             );\n                    if (IS_STDOUT && this.sendStdout != null) {\n                        this.sendStdout(iov);\n                        written += iov.byteLength;\n                    }\n                    else if (IS_STDERR && this.sendStderr != null) {\n                        this.sendStderr(iov);\n                        written += iov.byteLength;\n                    }\n                    else {\n                        // useful to be absolutely sure if wasi is writing something:\n                        // log(`write \"${new TextDecoder().decode(iov)}\" to ${fd})`);\n                        let w = 0;\n                        while (w < iov.byteLength) {\n                            // log(`write ${iov.byteLength} bytes to fd=${stats.real}`);\n                            const i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset ? Number(stats.offset) : null);\n                            // log(`just wrote i=${i} bytes`);\n                            if (stats.offset)\n                                stats.offset += BigInt(i);\n                            w += i;\n                        }\n                        //console.log(\"fd_write\", fd, \"  wrote \", w);\n                        written += w;\n                    }\n                });\n                this.view.setUint32(nwritten, written, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_pread: wrap((fd, iovs, iovsLen, offset, nread) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);\n                let read = 0;\n                outer: for (const iov of getiovs(iovs, iovsLen)) {\n                    let r = 0;\n                    while (r < iov.byteLength) {\n                        const length = iov.byteLength - r;\n                        const rr = fs.readSync(stats.real, iov, r, iov.byteLength - r, Number(offset) + read + r);\n                        r += rr;\n                        read += rr;\n                        // If we don't read anything, or we receive less than requested\n                        if (rr === 0 || rr < length) {\n                            break outer;\n                        }\n                    }\n                    read += r;\n                }\n                this.view.setUint32(nread, read, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_read: wrap((fd, iovs, iovsLen, nread) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ);\n                const IS_STDIN = fd == constants_1.WASI_STDIN_FILENO;\n                let read = 0;\n                //           logToFile(\n                //             `fd_read: ${IS_STDIN}, ${JSON.stringify(stats, (_, value) =>\n                //               typeof value === \"bigint\" ? value.toString() : value\n                //             )}, ${this.stdinBuffer?.length} ${this.stdinBuffer?.toString()}`\n                //           );\n                // console.log(\"fd_read\", fd, stats, IS_STDIN, this.getStdin != null);\n                outer: for (const iov of getiovs(iovs, iovsLen)) {\n                    let r = 0;\n                    while (r < iov.byteLength) {\n                        let length = iov.byteLength - r;\n                        let position = IS_STDIN || stats.offset === undefined\n                            ? null\n                            : Number(stats.offset);\n                        let rr = 0;\n                        if (IS_STDIN) {\n                            if (this.getStdin != null) {\n                                if (this.stdinBuffer == null) {\n                                    this.stdinBuffer = this.getStdin();\n                                }\n                                if (this.stdinBuffer != null) {\n                                    // just got stdin after waiting for it in poll_oneoff\n                                    // TODO: Do we need to limit length or iov will overflow?\n                                    //       Or will the below just work fine?  It might.\n                                    // Second remark -- we do not do anything special here to try to\n                                    // handle seeing EOF (ctrl+d) in the stream.  No matter what I try,\n                                    // doing something here (e.g., returning 0 bytes read) doesn't\n                                    // properly work with libedit.   So we leave it alone and let\n                                    // our slightly patched libedit handle control+d.\n                                    // In particular note to self -- **handling of control+d is done in libedit!**\n                                    rr = this.stdinBuffer.copy(iov);\n                                    if (rr == this.stdinBuffer.length) {\n                                        this.stdinBuffer = undefined;\n                                    }\n                                    else {\n                                        this.stdinBuffer = this.stdinBuffer.slice(rr);\n                                    }\n                                    if (rr > 0) {\n                                        // we read from stdin.\n                                        this.lastStdin = new Date().valueOf();\n                                    }\n                                }\n                            }\n                            else {\n                                // WARNING: might have to do something that burns 100% cpu... :-(\n                                // though this is useful for debugging situations.\n                                if (this.sleep == null && !warnedAboutSleep) {\n                                    warnedAboutSleep = true;\n                                    console.log(\"(cpu waiting for stdin: please define a way to sleep!) \");\n                                }\n                                //while (rr == 0) {\n                                try {\n                                    rr = fs.readSync(stats.real, // fd\n                                    iov, // buffer\n                                    r, // offset\n                                    length, // length\n                                    position // position\n                                    );\n                                }\n                                catch (_err) { }\n                                if (rr == 0) {\n                                    this.shortPause();\n                                }\n                                else {\n                                    this.lastStdin = new Date().valueOf();\n                                }\n                                //}\n                            }\n                        }\n                        else {\n                            rr = fs.readSync(stats.real, // fd\n                            iov, // buffer\n                            r, // offset\n                            length, // length\n                            position // position\n                            );\n                        }\n                        // TODO: I'm not sure which type of files should have an offset yet.\n                        // E.g., obviously a regular file should and obviously stdin (a character\n                        // device) and a pipe (which has type WASI_FILETYPE_SOCKET_STREAM) does not.\n                        if (stats.filetype == constants_1.WASI_FILETYPE_REGULAR_FILE) {\n                            stats.offset =\n                                (stats.offset ? stats.offset : BigInt(0)) + BigInt(rr);\n                        }\n                        r += rr;\n                        read += rr;\n                        // If we don't read anything, or we receive less than requested\n                        if (rr === 0 || rr < length) {\n                            break outer;\n                        }\n                    }\n                }\n                // console.log(\"fd_read: nread=\", read);\n                this.view.setUint32(nread, read, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_readdir: wrap((fd, bufPtr, bufLen, cookie, bufusedPtr) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);\n                // log(\"fd_readdir got stats = \", stats);\n                this.refreshMemory();\n                const entries = fs.readdirSync(stats.path, { withFileTypes: true });\n                const startPtr = bufPtr;\n                for (let i = Number(cookie); i < entries.length; i += 1) {\n                    const entry = entries[i];\n                    let nameLength = Buffer.byteLength(entry.name);\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    this.view.setBigUint64(bufPtr, BigInt(i + 1), true);\n                    bufPtr += 8;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    // We use lstat instead of stat, since stat fails on broken links.\n                    // Also, stat resolves the link giving the wrong inode!  On the other\n                    // hand, lstat works fine on non-links.  This is wrong in upstream,\n                    // which breaks testing test_compileall.py  in the python test suite,\n                    // due to doing os.scandir on a directory that contains a broken link.\n                    const rstats = fs.lstatSync(path.resolve(stats.path, entry.name));\n                    this.view.setBigUint64(bufPtr, BigInt(rstats.ino), true);\n                    bufPtr += 8;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    this.view.setUint32(bufPtr, nameLength, true);\n                    bufPtr += 4;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    let filetype;\n                    switch (true) {\n                        case rstats.isBlockDevice():\n                            filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;\n                            break;\n                        case rstats.isCharacterDevice():\n                            filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n                            break;\n                        case rstats.isDirectory():\n                            filetype = constants_1.WASI_FILETYPE_DIRECTORY;\n                            break;\n                        case rstats.isFIFO():\n                            filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                            break;\n                        case rstats.isFile():\n                            filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;\n                            break;\n                        case rstats.isSocket():\n                            filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                            break;\n                        case rstats.isSymbolicLink():\n                            filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;\n                            break;\n                        default:\n                            filetype = constants_1.WASI_FILETYPE_UNKNOWN;\n                            break;\n                    }\n                    this.view.setUint8(bufPtr, filetype);\n                    bufPtr += 1;\n                    bufPtr += 3; // padding\n                    if (bufPtr + nameLength >= startPtr + bufLen) {\n                        // It doesn't fit in the buffer\n                        break;\n                    }\n                    let memory_buffer = Buffer.from(this.memory.buffer);\n                    memory_buffer.write(entry.name, bufPtr);\n                    bufPtr += nameLength;\n                }\n                const bufused = bufPtr - startPtr;\n                this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_renumber: wrap((from, to) => {\n                CHECK_FD(from, BigInt(0));\n                CHECK_FD(to, BigInt(0));\n                fs.closeSync(this.FD_MAP.get(from).real);\n                this.FD_MAP.set(from, this.FD_MAP.get(to));\n                this.FD_MAP.delete(to);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_seek: wrap((fd, offset, whence, newOffsetPtr) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);\n                this.refreshMemory();\n                switch (whence) {\n                    case constants_1.WASI_WHENCE_CUR:\n                        stats.offset =\n                            (stats.offset ? stats.offset : BigInt(0)) + BigInt(offset);\n                        break;\n                    case constants_1.WASI_WHENCE_END:\n                        const { size } = this.fstatSync(stats.real);\n                        stats.offset = BigInt(size) + BigInt(offset);\n                        break;\n                    case constants_1.WASI_WHENCE_SET:\n                        stats.offset = BigInt(offset);\n                        break;\n                }\n                if (stats.offset == null) {\n                    throw Error(\"stats.offset must be defined\");\n                }\n                this.view.setBigUint64(newOffsetPtr, stats.offset, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_tell: wrap((fd, offsetPtr) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);\n                this.refreshMemory();\n                if (!stats.offset) {\n                    stats.offset = BigInt(0);\n                }\n                this.view.setBigUint64(offsetPtr, stats.offset, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_sync: wrap((fd) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);\n                fs.fsyncSync(stats.real);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_create_directory: wrap((fd, pathPtr, pathLen) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                fs.mkdirSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_filestat_get: wrap((fd, flags, pathPtr, pathLen, bufPtr) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                //console.log(\"path_filestat_get\", p);\n                let rstats;\n                if (flags) {\n                    rstats = fs.statSync(path.resolve(stats.path, p));\n                }\n                else {\n                    // there is exactly one flag implemented called \"__WASI_LOOKUPFLAGS_SYMLINK_FOLLOW\";\n                    // it's 1 and is used to follow links, i.e.,\n                    // implement lstat -- this is ignored in upstream.\n                    // See zig/lib/libc/wasi/libc-bottom-half/cloudlibc/src/libc/sys/stat/fstatat.c\n                    rstats = fs.lstatSync(path.resolve(stats.path, p));\n                }\n                //console.log(\"path_filestat_get got\", rstats)\n                // NOTE: the output is the filestat struct as documented here\n                // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#-filestat-record\n                // This does NOT even have a field for that.  This is considered an open bug in WASI:\n                //   https://github.com/WebAssembly/wasi-filesystem/issues/34\n                // That said, wasi does end up setting enough of st_mode so isdir works.\n                this.view.setBigUint64(bufPtr, BigInt(rstats.dev), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.ino), true);\n                bufPtr += 8;\n                this.view.setUint8(bufPtr, translateFileAttributes(this, undefined, rstats).filetype);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, BigInt(rstats.size), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);\n                bufPtr += 8;\n                this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_filestat_set_times: wrap((fd, _dirflags, pathPtr, pathLen, stAtim, stMtim, fstflags) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const rstats = this.fstatSync(stats.real);\n                let atim = rstats.atime;\n                let mtim = rstats.mtime;\n                const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME));\n                const atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n                if ((fstflags & atimflags) === atimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n                if ((fstflags & mtimflags) === mtimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM) {\n                    atim = nsToMs(stAtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) ===\n                    constants_1.WASI_FILESTAT_SET_ATIM_NOW) {\n                    atim = n;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM) {\n                    mtim = nsToMs(stMtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) ===\n                    constants_1.WASI_FILESTAT_SET_MTIM_NOW) {\n                    mtim = n;\n                }\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                fs.utimesSync(path.resolve(stats.path, p), new Date(atim), new Date(mtim));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_link: wrap((oldFd, _oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n                const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE);\n                const nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);\n                if (!ostats.path || !nstats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString();\n                const np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n                fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_open: wrap((dirfd, _dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fdPtr) => {\n                const stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);\n                fsRightsBase = BigInt(fsRightsBase);\n                fsRightsInheriting = BigInt(fsRightsInheriting);\n                const read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !==\n                    BigInt(0);\n                const write = (fsRightsBase &\n                    (constants_1.WASI_RIGHT_FD_DATASYNC |\n                        constants_1.WASI_RIGHT_FD_WRITE |\n                        constants_1.WASI_RIGHT_FD_ALLOCATE |\n                        constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !==\n                    BigInt(0);\n                let noflags;\n                if (write && read) {\n                    noflags = fs.constants.O_RDWR;\n                }\n                else if (read) {\n                    noflags = fs.constants.O_RDONLY;\n                }\n                else if (write) {\n                    noflags = fs.constants.O_WRONLY;\n                }\n                // fsRightsBase is needed here but perhaps we should do it in neededInheriting\n                let neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN;\n                let neededInheriting = fsRightsBase | fsRightsInheriting;\n                if ((oflags & constants_1.WASI_O_CREAT) !== 0) {\n                    noflags |= fs.constants.O_CREAT;\n                    neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;\n                }\n                if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0) {\n                    noflags |= fs.constants.O_DIRECTORY;\n                }\n                if ((oflags & constants_1.WASI_O_EXCL) !== 0) {\n                    noflags |= fs.constants.O_EXCL;\n                }\n                if ((oflags & constants_1.WASI_O_TRUNC) !== 0) {\n                    noflags |= fs.constants.O_TRUNC;\n                    neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;\n                }\n                // Convert file descriptor flags.\n                if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0) {\n                    noflags |= fs.constants.O_APPEND;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {\n                    if (fs.constants.O_DSYNC) {\n                        noflags |= fs.constants.O_DSYNC;\n                    }\n                    else {\n                        noflags |= fs.constants.O_SYNC;\n                    }\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0) {\n                    noflags |= fs.constants.O_NONBLOCK;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {\n                    if (fs.constants.O_RSYNC) {\n                        noflags |= fs.constants.O_RSYNC;\n                    }\n                    else {\n                        noflags |= fs.constants.O_SYNC;\n                    }\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0) {\n                    noflags |= fs.constants.O_SYNC;\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n                }\n                if (write &&\n                    (noflags & (fs.constants.O_APPEND | fs.constants.O_TRUNC)) === 0) {\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                if (p == \"dev/tty\") {\n                    // special case: \"the terminal\".\n                    // This is used, e.g., in the \"less\" program in open_tty in ttyin.c\n                    // It will work to make a new tty if using the native os, but when\n                    // using a worker thread or in browser, it's much simpler to just\n                    // return stdin, which works fine (I think).\n                    this.view.setUint32(fdPtr, constants_1.WASI_STDIN_FILENO, true);\n                    return constants_1.WASI_ESUCCESS;\n                }\n                logOpen(\"path_open\", p);\n                if (p.startsWith(\"proc/\")) {\n                    // Immediate error -- otherwise stuff will try to read from this,\n                    // which just isn't implemented, and will hang forever.\n                    // E.g., cython does.\n                    throw new types_1.WASIError(constants_1.WASI_EBADF);\n                }\n                const fullUnresolved = path.resolve(stats.path, p);\n                // I don't know why the original code blocked .., but that breaks\n                // applications (e.g., tar), and this seems like the wrong layer at which to\n                // be imposing security?\n                //           if (path.relative(stats.path, fullUnresolved).startsWith(\"..\")) {\n                //             return WASI_ENOTCAPABLE;\n                //           }\n                let full;\n                try {\n                    full = fs.realpathSync(fullUnresolved);\n                    //             if (path.relative(stats.path, full).startsWith(\"..\")) {\n                    //               return WASI_ENOTCAPABLE;\n                    //             }\n                }\n                catch (e) {\n                    if (e?.code === \"ENOENT\") {\n                        full = fullUnresolved;\n                    }\n                    else {\n                        // log(\"** openpath FAIL: p = \", p, e);\n                        throw e;\n                    }\n                }\n                /* check if the file is a directory (unless opening for write,\n                 * in which case the file may not exist and should be created) */\n                let isDirectory;\n                if (write) {\n                    try {\n                        isDirectory = fs.statSync(full).isDirectory();\n                    }\n                    catch (_err) {\n                        //console.log(_err)\n                    }\n                }\n                let realfd;\n                if (!write && isDirectory) {\n                    realfd = fs.openSync(full, fs.constants.O_RDONLY);\n                }\n                else {\n                    // console.log(`fs.openSync(\"${full}\", ${noflags})`);\n                    realfd = fs.openSync(full, noflags);\n                }\n                const newfd = this.getUnusedFileDescriptor();\n                // log(`** openpath got fd: p='${p}', fd=${newfd}`);\n                this.FD_MAP.set(newfd, {\n                    real: realfd,\n                    filetype: undefined,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: neededBase,\n                        inheriting: neededInheriting,\n                    },\n                    path: full,\n                });\n                // calling state here does some consistency checks\n                // and set the filetype entry in the record created above.\n                stat(this, newfd);\n                this.view.setUint32(fdPtr, newfd, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_readlink: wrap((fd, pathPtr, pathLen, buf, bufLen, bufused) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                const full = path.resolve(stats.path, p);\n                const r = fs.readlinkSync(full);\n                const used = Buffer.from(this.memory.buffer).write(r, buf, bufLen);\n                this.view.setUint32(bufused, used, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_remove_directory: wrap((fd, pathPtr, pathLen) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                fs.rmdirSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_rename: wrap((oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n                const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE);\n                const nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);\n                if (!ostats.path || !nstats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString();\n                const np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n                fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_symlink: wrap((oldPath, oldPathLen, fd, newPath, newPathLen) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString();\n                const np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n                fs.symlinkSync(op, path.resolve(stats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_unlink_file: wrap((fd, pathPtr, pathLen) => {\n                const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.refreshMemory();\n                const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n                fs.unlinkSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            // poll_oneoff: Concurrently poll for the occurrence of a set of events.\n            //\n            // TODO: this is NOT implemented properly yet in general.\n            // It does read all the data from sin, etc.\n            // correctly now, but it doesn't actually work correctly\n            // when there are multiple subscriptions.\n            // It works for:\n            //     - one timer\n            //     - one file descriptor corresponding to a socket and one timer,\n            //       which is what poll with 1 fd and a timeout create.\n            poll_oneoff: (sin, sout, nsubscriptions, neventsPtr) => {\n                let nevents = 0;\n                let name = \"\";\n                // May have to wait this long (this gets computed below in the WASI_EVENTTYPE_CLOCK case).\n                let waitTimeNs = BigInt(0);\n                let fd = -1;\n                let fd_type = \"read\";\n                let fd_timeout_ms = 0;\n                const startNs = BigInt(this.bindings.hrtime());\n                this.refreshMemory();\n                let last_sin = sin;\n                for (let i = 0; i < nsubscriptions; i += 1) {\n                    const userdata = this.view.getBigUint64(sin, true);\n                    sin += 8;\n                    const type = this.view.getUint8(sin);\n                    sin += 1;\n                    sin += 7; // padding\n                    if (log.enabled) {\n                        if (type == constants_1.WASI_EVENTTYPE_CLOCK) {\n                            name = \"poll_oneoff (type=WASI_EVENTTYPE_CLOCK): \";\n                        }\n                        else if (type == constants_1.WASI_EVENTTYPE_FD_READ) {\n                            name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_READ): \";\n                        }\n                        else {\n                            name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_WRITE): \";\n                        }\n                        log(name);\n                    }\n                    switch (type) {\n                        case constants_1.WASI_EVENTTYPE_CLOCK: {\n                            // see packages/zig/dist/lib/libc/include/wasm-wasi-musl/wasi/api.h\n                            // for exactly how these values are encoded.  I carefully looked\n                            // at that header and **this is definitely right**.  Same with the fd\n                            // in the other case below.\n                            const clockid = this.view.getUint32(sin, true);\n                            sin += 4;\n                            sin += 4; // padding\n                            const timeout = this.view.getBigUint64(sin, true);\n                            sin += 8;\n                            //const precision = this.view.getBigUint64(sin, true);\n                            sin += 8;\n                            const subclockflags = this.view.getUint16(sin, true);\n                            sin += 2;\n                            sin += 6; // padding\n                            const absolute = subclockflags === 1;\n                            if (log.enabled) {\n                                log(name, { clockid, timeout, absolute });\n                            }\n                            if (!absolute) {\n                                fd_timeout_ms = Number(timeout / BigInt(1000000));\n                            }\n                            let e = constants_1.WASI_ESUCCESS;\n                            const t = now(clockid);\n                            // logToFile(t, clockid, timeout, subclockflags, absolute);\n                            if (t == null) {\n                                e = constants_1.WASI_EINVAL;\n                            }\n                            else {\n                                const end = absolute ? timeout : t + timeout;\n                                const waitNs = end - t;\n                                if (waitNs > waitTimeNs) {\n                                    waitTimeNs = waitNs;\n                                }\n                            }\n                            this.view.setBigUint64(sout, userdata, true);\n                            sout += 8;\n                            this.view.setUint16(sout, e, true); // error\n                            sout += 2; // pad offset 2\n                            this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK);\n                            sout += 1; // pad offset 1\n                            sout += 5; // padding to 8\n                            nevents += 1;\n                            break;\n                        }\n                        case constants_1.WASI_EVENTTYPE_FD_READ:\n                        case constants_1.WASI_EVENTTYPE_FD_WRITE: {\n                            /*\n                            Look at\n                             lib/libc/wasi/libc-bottom-half/cloudlibc/src/libc/sys/select/pselect.c\n                            to see how poll_oneoff is actually used by wasi to implement pselect.\n                            It's also used in\n                             lib/libc/wasi/libc-bottom-half/cloudlibc/src/libc/poll/poll.c\n              \n                            \"If none of the selected descriptors are ready for the\n                            requested operation, the pselect() or select() function shall\n                            block until at least one of the requested operations becomes\n                            ready, until the timeout occurs, or until interrupted by a signal.\"\n                            Thus what is supposed to happen below is supposed\n                            to block until the fd is ready to read from or write\n                            to, etc.\n              \n                            For now at least if reading from stdin then we block for a short amount\n                            of time if getStdin defined; otherwise, we at least *pause* for a moment\n                            (to avoid cpu burn) if this.sleep is available.\n                            */\n                            fd = this.view.getUint32(sin, true);\n                            fd_type = type == constants_1.WASI_EVENTTYPE_FD_READ ? \"read\" : \"write\";\n                            sin += 4;\n                            log(name, \"fd =\", fd);\n                            sin += 28;\n                            this.view.setBigUint64(sout, userdata, true);\n                            sout += 8;\n                            this.view.setUint16(sout, constants_1.WASI_ENOSYS, true); // error\n                            sout += 2; // pad offset 2\n                            this.view.setUint8(sout, type);\n                            sout += 1; // pad offset 3\n                            sout += 5; // padding to 8\n                            nevents += 1;\n                            /*\n                            TODO: for now for stdin we are just doing a dumb hack.\n              \n                            We just do something really naive, which is \"pause for a little while\".\n                            It seems to work for every application I have so far, from Python to\n                            to ncurses, etc.  This also makes it easy to have non-blocking sleep\n                            in node.js at the terminal without a worker thread, which is very nice!\n              \n                            Before I had it block here via getStdin when available, but that does not work\n                            in general; in particular, it breaks ncurses completely. In\n                               ncurses/tty/tty_update.c\n                            the following call is assumed not to block, and if it does, then ncurses\n                            interaction becomes totally broken:\n              \n                               select(SP_PARM->_checkfd + 1, &fdset, NULL, NULL, &ktimeout)\n              \n                            */\n                            if (fd == constants_1.WASI_STDIN_FILENO && constants_1.WASI_EVENTTYPE_FD_READ == type) {\n                                this.shortPause();\n                            }\n                            break;\n                        }\n                        default:\n                            return constants_1.WASI_EINVAL;\n                    }\n                    // Consistency check that we consumed exactly the right amount\n                    // of the __wasi_subscription_t. See zig/lib/libc/include/wasm-wasi-musl/wasi/api.h\n                    if (sin - last_sin != 48) {\n                        console.warn(\"*** BUG in wasi-js in poll_oneoff \", {\n                            i,\n                            sin,\n                            last_sin,\n                            diff: sin - last_sin,\n                        });\n                    }\n                    last_sin = sin;\n                }\n                this.view.setUint32(neventsPtr, nevents, true);\n                if (nevents == 2 && fd >= 0) {\n                    const r = this.wasiImport.sock_pollSocket(fd, fd_type, fd_timeout_ms);\n                    if (r != constants_1.WASI_ENOSYS) {\n                        // special implementation from outside\n                        return r;\n                    }\n                    // fall back to below\n                }\n                // Account for the time it took to do everything above, which\n                // can be arbitrarily long:\n                if (waitTimeNs > 0) {\n                    waitTimeNs -= BigInt(this.bindings.hrtime()) - startNs;\n                    // logToFile(\"waitTimeNs\", waitTimeNs);\n                    if (waitTimeNs >= 1000000) {\n                        if (this.sleep == null && !warnedAboutSleep) {\n                            warnedAboutSleep = true;\n                            console.log(\"(100% cpu burning waiting for stdin: please define a way to sleep!) \");\n                        }\n                        if (this.sleep != null) {\n                            // We are running in a worker thread, and have *some way*\n                            // to synchronously pause execution of this thread.  Yeah!\n                            const ms = nsToMs(waitTimeNs);\n                            this.sleep(ms);\n                        }\n                        else {\n                            // Use **horrible** 100% block and 100% cpu\n                            // wait, which might sort of work, but is obviously\n                            // a wrong nightmare.  Unfortunately, this is the\n                            // only possible thing to do when not running in\n                            // a work thread.\n                            const end = BigInt(this.bindings.hrtime()) + waitTimeNs;\n                            while (BigInt(this.bindings.hrtime()) < end) {\n                                // burn your CPU!\n                            }\n                        }\n                    }\n                }\n                return constants_1.WASI_ESUCCESS;\n            },\n            proc_exit: (rval) => {\n                this.bindings.exit(rval);\n                return constants_1.WASI_ESUCCESS;\n            },\n            proc_raise: (sig) => {\n                if (!(sig in constants_1.SIGNAL_MAP)) {\n                    return constants_1.WASI_EINVAL;\n                }\n                this.bindings.kill(constants_1.SIGNAL_MAP[sig]);\n                return constants_1.WASI_ESUCCESS;\n            },\n            random_get: (bufPtr, bufLen) => {\n                this.refreshMemory();\n                this.bindings.randomFillSync(new Uint8Array(this.memory.buffer), bufPtr, bufLen);\n                return constants_1.WASI_ESUCCESS;\n                // NOTE: upstream had \"return WASI_ESUCCESS;\" here, which I thought was\n                // a major bug, since getrandom returns the *number of random bytes*.\n                // However, I think instead this was a bug in musl or libc or zig or something,\n                // which got fixed in version  0.10.0-dev.4161+dab5bb924, since with that\n                // release returning anything instead of success (=0) here actually\n                // (Before returning 0 made it so Python hung mysteriously on startup, which tooks\n                // me days of suffering to figure out. In particular, Python startup\n                // hangs at py_getrandom in bootstrap_hash.c.)\n                // return bufLen;\n            },\n            sched_yield() {\n                // Single threaded environment\n                // This is a no-op in JS\n                return constants_1.WASI_ESUCCESS;\n            },\n            // The client could overwrite these sock_*; that's what\n            // CoWasm does in injectFunctions in\n            //    packages/kernel/src/wasm/worker/posix-context.ts\n            sock_recv() {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_send() {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_shutdown() {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_fcntlSetFlags(_fd, _flags) {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_pollSocket(_fd, _eventtype, _timeout_ms) {\n                return constants_1.WASI_ENOSYS;\n            },\n        };\n        if (log.enabled) {\n            // Wrap each of the imports to show the calls via the debug logger.\n            // We ONLY do this if the logger is enabled, since it might\n            // be expensive.\n            Object.keys(this.wasiImport).forEach((key) => {\n                const prevImport = this.wasiImport[key];\n                this.wasiImport[key] = function (...args) {\n                    log(key, args);\n                    try {\n                        let result = prevImport(...args);\n                        log(\"result\", result);\n                        return result;\n                    }\n                    catch (e) {\n                        log(\"error: \", e);\n                        throw e;\n                    }\n                };\n            });\n        }\n    }\n    getState() {\n        return { env: this.env, FD_MAP: this.FD_MAP, bindings: this.bindings };\n    }\n    setState(state) {\n        this.env = state.env;\n        this.FD_MAP = state.FD_MAP;\n        this.bindings = state.bindings;\n    }\n    fstatSync(real_fd) {\n        if (real_fd <= 2) {\n            try {\n                return this.bindings.fs.fstatSync(real_fd);\n            }\n            catch (_) {\n                // In special case of stdin/stdout/stderr in some environments\n                // (e.g., windows under electron) some of the actual file descriptors\n                // aren't defined in the node process.  We thus fake it, since we\n                // are virtualizing these in our code anyways.\n                const now = new Date();\n                return {\n                    dev: 0,\n                    mode: 8592,\n                    nlink: 1,\n                    uid: 0,\n                    gid: 0,\n                    rdev: 0,\n                    blksize: 65536,\n                    ino: 0,\n                    size: 0,\n                    blocks: 0,\n                    atimeMs: now.valueOf(),\n                    mtimeMs: now.valueOf(),\n                    ctimeMs: now.valueOf(),\n                    birthtimeMs: 0,\n                    atime: new Date(),\n                    mtime: new Date(),\n                    ctime: new Date(),\n                    birthtime: new Date(0),\n                };\n            }\n        }\n        // general case\n        return this.bindings.fs.fstatSync(real_fd);\n    }\n    shortPause() {\n        if (this.sleep == null)\n            return;\n        const now = new Date().valueOf();\n        if (now - this.lastStdin > 2000) {\n            // We have *some way* to synchronously pause execution of\n            // this thread, so we sleep a little to avoid burning\n            // 100% cpu.  But not right after reading input, since\n            // otherwise typing feels laggy.\n            // We can probably get rid of this entirely with a proper\n            // wgetchar...\n            this.sleep(50);\n        }\n    }\n    // return an unused file descriptor.  It *will* be the smallest\n    // available file descriptor, except we don't use 0,1,2\n    getUnusedFileDescriptor(start = 3) {\n        let fd = start;\n        while (this.FD_MAP.has(fd)) {\n            fd += 1;\n        }\n        if (fd > SC_OPEN_MAX) {\n            throw Error(\"no available file descriptors\");\n        }\n        return fd;\n    }\n    refreshMemory() {\n        // @ts-ignore\n        if (!this.view || this.view.buffer.byteLength === 0) {\n            this.view = new DataView(this.memory.buffer);\n        }\n    }\n    setMemory(memory) {\n        this.memory = memory;\n    }\n    start(instance, memory) {\n        const exports = instance.exports;\n        if (exports === null || typeof exports !== \"object\") {\n            throw new Error(`instance.exports must be an Object. Received ${exports}.`);\n        }\n        if (memory == null) {\n            memory = exports.memory;\n            if (!(memory instanceof WebAssembly.Memory)) {\n                throw new Error(`instance.exports.memory must be a WebAssembly.Memory. Recceived ${memory}.`);\n            }\n        }\n        this.setMemory(memory);\n        if (exports._start) {\n            exports._start();\n        }\n    }\n    getImportNamespace(module) {\n        let namespace = null;\n        for (let imp of WebAssembly.Module.imports(module)) {\n            // We only check for the functions\n            if (imp.kind !== \"function\") {\n                continue;\n            }\n            // We allow functions in other namespaces other than wasi\n            if (!imp.module.startsWith(\"wasi_\")) {\n                continue;\n            }\n            if (!namespace) {\n                namespace = imp.module;\n            }\n            else {\n                if (namespace !== imp.module) {\n                    throw new Error(\"Multiple namespaces detected.\");\n                }\n            }\n        }\n        return namespace;\n    }\n    getImports(module) {\n        let namespace = this.getImportNamespace(module);\n        switch (namespace) {\n            case \"wasi_unstable\":\n                return {\n                    wasi_unstable: this.wasiImport,\n                };\n            case \"wasi_snapshot_preview1\":\n                return {\n                    wasi_snapshot_preview1: this.wasiImport,\n                };\n            default:\n                throw new Error(\"Can't detect a WASI namespace for the WebAssembly Module\");\n        }\n    }\n    initWasiFdInfo() {\n        // TODO: this is NOT used yet. It currently crashes.\n        if (this.env[\"WASI_FD_INFO\"] != null) {\n            // If the environment variable WASI_FD_INFO is set to the\n            // JSON version of a map from wasi fd's to real fd's, then\n            // we also initialize FD_MAP with that, assuming these\n            // are all inheritable file descriptors for ends of pipes.\n            // This is something added for\n            // python-wasm fork/exec support.\n            const fdInfo = JSON.parse(this.env[\"WASI_FD_INFO\"]);\n            for (const wasi_fd in fdInfo) {\n                console.log(wasi_fd);\n                const fd = parseInt(wasi_fd);\n                if (this.FD_MAP.has(fd)) {\n                    continue;\n                }\n                const real = fdInfo[wasi_fd];\n                try {\n                    // check the fd really exists\n                    this.fstatSync(real);\n                }\n                catch (_err) {\n                    console.log(\"discarding \", { wasi_fd, real });\n                    continue;\n                }\n                const file = {\n                    real,\n                    filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n                    rights: {\n                        base: STDIN_DEFAULT_RIGHTS,\n                        inheriting: BigInt(0),\n                    },\n                };\n                this.FD_MAP.set(fd, file);\n            }\n            console.log(\"after initWasiFdInfo: \", this.FD_MAP);\n            console.log(\"fdInfo = \", fdInfo);\n        }\n        else {\n            console.log(\"no WASI_FD_INFO\");\n        }\n    }\n}\nexports[\"default\"] = WASI;\n//# sourceMappingURL=wasi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL2Rpc3Qvd2FzaS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGdDQUFnQyxtQkFBTyxDQUFDLHNFQUFPO0FBQy9DO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFTO0FBQ2pDLCtDQUErQyxtQkFBTyxDQUFDLDhGQUFzQjtBQUM3RSxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0QscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakMsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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YTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxRQUFRO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLE9BQU87QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXHdhc2ktanNcXGRpc3RcXHdhc2kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBNSVQgbGljZW5zZWQuICBTZWUgUkVBRE1FLm1kIGZvciBjb3B5cmlnaHQgYW5kIGhpc3RvcnkgaW5mb3JtYXRpb24uXG5cbkZvciBBUEkgZG9jcyBhYm91dCB3aGF0IHRoZXNlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgc3VwcG9zZWQgdG8gYmUsIHNlZVxuXG5odHRwczovL2dpdGh1Yi5jb20vV2ViQXNzZW1ibHkvV0FTSS9ibG9iL21haW4vcGhhc2VzL3NuYXBzaG90L2RvY3MubWRcblxuYW5kIGEgVE9ETyBpcyBjb3B5L3Bhc3RlIG1vc3Qgb2YgdGhhdCBhcyBjb21tZW50cyBiZWxvdy5cbiovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNPQ0tFVF9ERUZBVUxUX1JJR0hUUyA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGxvZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwid2FzaVwiKTtcbmNvbnN0IGxvZ09wZW4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcIndhc2k6b3BlblwiKTsgLy8ganVzdCBsb2cgb3BlbmluZyBmaWxlcywgd2hpY2ggaXMgdXNlZnVsXG4vLyBTZWUgdGhlIGNvbW1lbnQgaW4gcGFja2FnZXMvY3B5dGhvbi9zcmMvcHljb25maWcuaFxuLy8gSW4gcGFydGljdWxhciwgdW50aWwgd2UgcGF0Y2ggY3B5dGhvbiBpdHNlbGYsIGl0J3MgcmVhbGx5XG4vLyBvbmx5IHNhZmUgdG8gc2V0IHRoaXMgdG8gMjU2LiAgVE9ETzogd2UgcGxhbiB0byBwYXRjaFxuLy8gZXZlcnl0aGluZyBpbiBjcHl0aG9uIHRoYXQgZmFsbHMgYmFjayB0byAyNTYgdG8gaW5zdGVhZFxuLy8gdXNlIHRoZSB2YWx1ZSAzMjc2OC5cbmNvbnN0IFNDX09QRU5fTUFYID0gMzI3Njg7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB0eXBlZGFycmF5X3RvX2J1ZmZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0eXBlZGFycmF5LXRvLWJ1ZmZlclwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFNURElOX0RFRkFVTFRfUklHSFRTID0gY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQyB8XG4gICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9SRUFEIHxcbiAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1NZTkMgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfQURWSVNFIHxcbiAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX0ZJTEVTVEFUX0dFVCB8XG4gICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QT0xMX0ZEX1JFQURXUklURTtcbmNvbnN0IFNURE9VVF9ERUZBVUxUX1JJR0hUUyA9IGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfREFUQVNZTkMgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfV1JJVEUgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfU1lOQyB8XG4gICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9BRFZJU0UgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfRklMRVNUQVRfR0VUIHxcbiAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BPTExfRkRfUkVBRFdSSVRFO1xuY29uc3QgU1RERVJSX0RFRkFVTFRfUklHSFRTID0gU1RET1VUX0RFRkFVTFRfUklHSFRTO1xuLy8gSSBkb24ndCBrbm93IHdoYXQgdGhpcyAqc2hvdWxkKiBiZSwgYnV0IEknbVxuLy8gYWRkaW5nIHRoaW5ncyBhcyB0aGV5IGFyZSBleHBlY3RlZC9pbXBsZW1lbnRlZC5cbmV4cG9ydHMuU09DS0VUX0RFRkFVTFRfUklHSFRTID0gY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQyB8XG4gICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9SRUFEIHxcbiAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1dSSVRFIHxcbiAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX0FEVklTRSB8XG4gICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9HRVQgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfUE9MTF9GRF9SRUFEV1JJVEUgfFxuICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfRkRTVEFUX1NFVF9GTEFHUztcbmNvbnN0IG1zVG9OcyA9IChtcykgPT4ge1xuICAgIGNvbnN0IG1zSW50ID0gTWF0aC50cnVuYyhtcyk7XG4gICAgY29uc3QgZGVjaW1hbCA9IEJpZ0ludChNYXRoLnJvdW5kKChtcyAtIG1zSW50KSAqIDEwMDAwMDApKTtcbiAgICBjb25zdCBucyA9IEJpZ0ludChtc0ludCkgKiBCaWdJbnQoMTAwMDAwMCk7XG4gICAgcmV0dXJuIG5zICsgZGVjaW1hbDtcbn07XG5jb25zdCBuc1RvTXMgPSAobnMpID0+IHtcbiAgICBpZiAodHlwZW9mIG5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5zID0gTWF0aC50cnVuYyhucyk7XG4gICAgfVxuICAgIGNvbnN0IG5zSW50ID0gQmlnSW50KG5zKTtcbiAgICByZXR1cm4gTnVtYmVyKG5zSW50IC8gQmlnSW50KDEwMDAwMDApKTtcbn07XG5jb25zdCB3cmFwID0gKGYpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gbG9nKFwiV0FTSSBlcnJvclwiLCBlcnIpO1xuICAgICAgICAvLyBjb25zb2xlLnRyYWNlKGVycik7XG4gICAgICAgIGxldCBlID0gZXJyO1xuICAgICAgICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgdW5pb25mcywgZS5nLiwgaW4gZmRfd3JpdGUgaWYgYSBwaXBlXG4gICAgICAgIC8vIGJyZWFrcywgdGhlbiB1bmlvbmZzIHJhaXNlcyBcIkVycm9yOiBFQkFERjogYmFkIGZpbGUgZGVzY3JpcHRvciwgd3JpdGVcIixcbiAgICAgICAgLy8gYnV0IHRoZSByZWxldmFudCBlcnJvciBpcyBcInByZXY6IEVycm9yOiBFUElQRTogYnJva2VuIHBpcGUsIHdyaXRlXCIsIHdoaWNoIGl0IHNhdmVzLlxuICAgICAgICB3aGlsZSAoZS5wcmV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGUgPSBlLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQncyBhbiBlcnJvciBmcm9tIHRoZSBmc1xuICAgICAgICBpZiAoZT8uY29kZSAmJiB0eXBlb2YgZT8uY29kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkVSUk9SX01BUFtlLmNvZGVdIHx8IGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGl0J3MgYSBXQVNJIGVycm9yLCB3ZSByZXR1cm4gaXQgZGlyZWN0bHlcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiB0eXBlc18xLldBU0lFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGxldCB0aGUgZXJyb3IgYnViYmxlIHVwXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmNvbnN0IHN0YXQgPSAod2FzaSwgZmQpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHdhc2kuRkRfTUFQLmdldChmZCk7XG4gICAgLy8gY29uc29sZS5sb2coXCJzdGF0XCIsIHsgZmQsIGVudHJ5LCBGRF9NQVA6IHdhc2kuRkRfTUFQIH0pO1xuICAgIC8vIGxvZyhcInN0YXRcIiwgeyBmZCwgZW50cnksIEZEX01BUDogd2FzaS5GRF9NQVAgfSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5XQVNJRXJyb3IoY29uc3RhbnRzXzEuV0FTSV9FQkFERik7XG4gICAgfVxuICAgIGlmIChlbnRyeS5maWxldHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gd2FzaS5mc3RhdFN5bmMoZW50cnkucmVhbCk7XG4gICAgICAgIGNvbnN0IHsgZmlsZXR5cGUsIHJpZ2h0c0Jhc2UsIHJpZ2h0c0luaGVyaXRpbmcgfSA9IHRyYW5zbGF0ZUZpbGVBdHRyaWJ1dGVzKHdhc2ksIGZkLCBzdGF0cyk7XG4gICAgICAgIGVudHJ5LmZpbGV0eXBlID0gZmlsZXR5cGU7XG4gICAgICAgIGlmICghZW50cnkucmlnaHRzKSB7XG4gICAgICAgICAgICBlbnRyeS5yaWdodHMgPSB7XG4gICAgICAgICAgICAgICAgYmFzZTogcmlnaHRzQmFzZSxcbiAgICAgICAgICAgICAgICBpbmhlcml0aW5nOiByaWdodHNJbmhlcml0aW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59O1xuY29uc3QgdHJhbnNsYXRlRmlsZUF0dHJpYnV0ZXMgPSAod2FzaSwgZmQsIHN0YXRzKSA9PiB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2Ugc3RhdHMuaXNCbG9ja0RldmljZSgpOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9CTE9DS19ERVZJQ0UsXG4gICAgICAgICAgICAgICAgcmlnaHRzQmFzZTogY29uc3RhbnRzXzEuUklHSFRTX0JMT0NLX0RFVklDRV9CQVNFLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0luaGVyaXRpbmc6IGNvbnN0YW50c18xLlJJR0hUU19CTE9DS19ERVZJQ0VfSU5IRVJJVElORyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2Ugc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKToge1xuICAgICAgICAgICAgY29uc3QgZmlsZXR5cGUgPSBjb25zdGFudHNfMS5XQVNJX0ZJTEVUWVBFX0NIQVJBQ1RFUl9ERVZJQ0U7XG4gICAgICAgICAgICBpZiAoZmQgIT09IHVuZGVmaW5lZCAmJiB3YXNpLmJpbmRpbmdzLmlzVFRZKGZkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0eXBlLFxuICAgICAgICAgICAgICAgICAgICByaWdodHNCYXNlOiBjb25zdGFudHNfMS5SSUdIVFNfVFRZX0JBU0UsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0c0luaGVyaXRpbmc6IGNvbnN0YW50c18xLlJJR0hUU19UVFlfSU5IRVJJVElORyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZSxcbiAgICAgICAgICAgICAgICByaWdodHNCYXNlOiBjb25zdGFudHNfMS5SSUdIVFNfQ0hBUkFDVEVSX0RFVklDRV9CQVNFLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0luaGVyaXRpbmc6IGNvbnN0YW50c18xLlJJR0hUU19DSEFSQUNURVJfREVWSUNFX0lOSEVSSVRJTkcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugc3RhdHMuaXNEaXJlY3RvcnkoKTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZXR5cGU6IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfRElSRUNUT1JZLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0Jhc2U6IGNvbnN0YW50c18xLlJJR0hUU19ESVJFQ1RPUllfQkFTRSxcbiAgICAgICAgICAgICAgICByaWdodHNJbmhlcml0aW5nOiBjb25zdGFudHNfMS5SSUdIVFNfRElSRUNUT1JZX0lOSEVSSVRJTkcsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIHN0YXRzLmlzRklGTygpOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9TT0NLRVRfU1RSRUFNLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0Jhc2U6IGNvbnN0YW50c18xLlJJR0hUU19TT0NLRVRfQkFTRSxcbiAgICAgICAgICAgICAgICByaWdodHNJbmhlcml0aW5nOiBjb25zdGFudHNfMS5SSUdIVFNfU09DS0VUX0lOSEVSSVRJTkcsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIHN0YXRzLmlzRmlsZSgpOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9SRUdVTEFSX0ZJTEUsXG4gICAgICAgICAgICAgICAgcmlnaHRzQmFzZTogY29uc3RhbnRzXzEuUklHSFRTX1JFR1VMQVJfRklMRV9CQVNFLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0luaGVyaXRpbmc6IGNvbnN0YW50c18xLlJJR0hUU19SRUdVTEFSX0ZJTEVfSU5IRVJJVElORyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2Ugc3RhdHMuaXNTb2NrZXQoKTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZXR5cGU6IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfU09DS0VUX1NUUkVBTSxcbiAgICAgICAgICAgICAgICByaWdodHNCYXNlOiBjb25zdGFudHNfMS5SSUdIVFNfU09DS0VUX0JBU0UsXG4gICAgICAgICAgICAgICAgcmlnaHRzSW5oZXJpdGluZzogY29uc3RhbnRzXzEuUklHSFRTX1NPQ0tFVF9JTkhFUklUSU5HLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBzdGF0cy5pc1N5bWJvbGljTGluaygpOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9TWU1CT0xJQ19MSU5LLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0Jhc2U6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICByaWdodHNJbmhlcml0aW5nOiBCaWdJbnQoMCksXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9VTktOT1dOLFxuICAgICAgICAgICAgICAgIHJpZ2h0c0Jhc2U6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICByaWdodHNJbmhlcml0aW5nOiBCaWdJbnQoMCksXG4gICAgICAgICAgICB9O1xuICAgIH1cbn07XG4vLyBjb25zdCBsb2dUb0ZpbGUgPSAoLi4uYXJncykgPT4ge1xuLy8gICByZXF1aXJlKFwiZnNcIikuYXBwZW5kRmlsZVN5bmMoXG4vLyAgICAgXCIvdG1wL3dhc2kubG9nXCIsXG4vLyAgICAgYXJncy5tYXAoKHgpID0+IGAke3h9YCkuam9pbihcIiBcIikgKyBcIlxcblwiXG4vLyAgICk7XG4vLyB9O1xubGV0IHdhcm5lZEFib3V0U2xlZXAgPSBmYWxzZTtcbmNsYXNzIFdBU0kge1xuICAgIGNvbnN0cnVjdG9yKHdhc2lDb25maWcpIHtcbiAgICAgICAgdGhpcy5sYXN0U3RkaW4gPSAwO1xuICAgICAgICB0aGlzLmVudiA9IHt9O1xuICAgICAgICB0aGlzLnNsZWVwID0gd2FzaUNvbmZpZy5zbGVlcDtcbiAgICAgICAgdGhpcy5nZXRTdGRpbiA9IHdhc2lDb25maWcuZ2V0U3RkaW47XG4gICAgICAgIHRoaXMuc2VuZFN0ZG91dCA9IHdhc2lDb25maWcuc2VuZFN0ZG91dDtcbiAgICAgICAgdGhpcy5zZW5kU3RkZXJyID0gd2FzaUNvbmZpZy5zZW5kU3RkZXJyO1xuICAgICAgICAvLyBEZXN0cnVjdHVyZSBvdXIgd2FzaUNvbmZpZ1xuICAgICAgICBsZXQgcHJlb3BlbnMgPSB7fTtcbiAgICAgICAgaWYgKHdhc2lDb25maWcucHJlb3BlbnMpIHtcbiAgICAgICAgICAgIHByZW9wZW5zID0gd2FzaUNvbmZpZy5wcmVvcGVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FzaUNvbmZpZyAmJiB3YXNpQ29uZmlnLmVudikge1xuICAgICAgICAgICAgdGhpcy5lbnYgPSB3YXNpQ29uZmlnLmVudjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBpZiAod2FzaUNvbmZpZyAmJiB3YXNpQ29uZmlnLmFyZ3MpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB3YXNpQ29uZmlnLmFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLm1lbW9yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB3YXNpQ29uZmlnLmJpbmRpbmdzO1xuICAgICAgICBjb25zdCBmcyA9IHRoaXMuYmluZGluZ3MuZnM7XG4gICAgICAgIHRoaXMuRkRfTUFQID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9TVERJTl9GSUxFTk8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWFsOiAwLFxuICAgICAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9DSEFSQUNURVJfREVWSUNFLFxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQ6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlOiBTVERJTl9ERUZBVUxUX1JJR0hUUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRpbmc6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvZGV2L3N0ZGluXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9TVERPVVRfRklMRU5PLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbDogMSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGU6IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfQ0hBUkFDVEVSX0RFVklDRSxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0OiBCaWdJbnQoMCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTogU1RET1VUX0RFRkFVTFRfUklHSFRTLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZzogQmlnSW50KDApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9kZXYvc3Rkb3V0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9TVERFUlJfRklMRU5PLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbDogMixcbiAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGU6IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfQ0hBUkFDVEVSX0RFVklDRSxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0OiBCaWdJbnQoMCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTogU1RERVJSX0RFRkFVTFRfUklHSFRTLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZzogQmlnSW50KDApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9kZXYvc3RkZXJyXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5iaW5kaW5ncy5wYXRoO1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhwcmVvcGVucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWwgPSBmcy5vcGVuU3luYyh2LCBmcy5jb25zdGFudHMuT19SRE9OTFkpO1xuICAgICAgICAgICAgY29uc3QgbmV3ZmQgPSB0aGlzLmdldFVudXNlZEZpbGVEZXNjcmlwdG9yKCk7XG4gICAgICAgICAgICB0aGlzLkZEX01BUC5zZXQobmV3ZmQsIHtcbiAgICAgICAgICAgICAgICByZWFsLFxuICAgICAgICAgICAgICAgIGZpbGV0eXBlOiBjb25zdGFudHNfMS5XQVNJX0ZJTEVUWVBFX0RJUkVDVE9SWSxcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQ6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICByaWdodHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogY29uc3RhbnRzXzEuUklHSFRTX0RJUkVDVE9SWV9CQVNFLFxuICAgICAgICAgICAgICAgICAgICBpbmhlcml0aW5nOiBjb25zdGFudHNfMS5SSUdIVFNfRElSRUNUT1JZX0lOSEVSSVRJTkcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWtlUGF0aDogayxcbiAgICAgICAgICAgICAgICBwYXRoOiB2LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2V0aW92cyA9IChpb3ZzLCBpb3ZzTGVuKSA9PiB7XG4gICAgICAgICAgICAvLyBpb3ZzKiAtPiBbaW92LCBpb3YsIC4uLl1cbiAgICAgICAgICAgIC8vIF9fd2FzaV9jaW92ZWNfdCB7XG4gICAgICAgICAgICAvLyAgIHZvaWQqIGJ1ZixcbiAgICAgICAgICAgIC8vICAgc2l6ZV90IGJ1Zl9sZW4sXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpb3ZzTGVuIH0sIChfLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHRyID0gaW92cyArIGkgKiA4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMudmlldy5nZXRVaW50MzIocHRyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgYnVmTGVuID0gdGhpcy52aWV3LmdldFVpbnQzMihwdHIgKyA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbW1hcCBzdHVmZiBpbiB3YXNpIHRyaWVzIHRvIG1ha2UgdGhpcyBvdmVyd3JpdGUgYWxsXG4gICAgICAgICAgICAgICAgLy8gYWxsb2NhdGVkIG1lbW9yeSwgc28gd2UgY2FwIGl0IG9yIHRoaW5ncyBjcmFzaC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSB3ZSBuZWVkIHRvIGFsbG9jYXRlIG1vcmUgbWVtb3J5PyAgSSBkb24ndCBrbm93ISFcbiAgICAgICAgICAgICAgICBpZiAoYnVmTGVuID4gdGhpcy5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGggLSBidWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIGNvbnNvbGUubG9nKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYnVmLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBidWZMZW4sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRvdGFsX21lbW9yeTogdGhpcy5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiZ2V0aW92czogd2FybmluZyAtLSB0cnVuY2F0aW5nIGJ1ZmZlciB0byBmaXQgaW4gbWVtb3J5XCIpO1xuICAgICAgICAgICAgICAgICAgICBidWZMZW4gPSBNYXRoLm1pbihidWZMZW4sIE1hdGgubWF4KDAsIHRoaXMubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoIC0gYnVmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlciwgYnVmLCBidWZMZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVkYXJyYXlfdG9fYnVmZmVyXzEuZGVmYXVsdCkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBoaWRlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV0FTSS5nZXRpb3ZzIC0tIGludmFsaWQgYnVmZmVyXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhdCBsZWFzdCBtYWtlIGl0IHNvIHdlIGRvbid0IHRvdGFsbHkga2lsbCBXQVNNLCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYSB0cmFjZWJhY2sgaW4gdGhlIGNhbGxpbmcgcHJvZ3JhbSAoc2F5IHB5dGhvbikuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdyB0aGlzIHNvcnQgb2YgdGhpbmcgaGFwcGVucyB3aXRoIGFnZ3Jlc3NpdmUgdXNlIG9mIG1tYXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBJIHBsYW4gdG8gcmVwbGFjZSBob3cgbW1hcCB3b3JrcyB3aXRoIHNvbWV0aGluZyB0aGF0IGlzIHZpYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuV0FTSUVycm9yKGNvbnN0YW50c18xLldBU0lfRUlOVkFMKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBDSEVDS19GRCA9IChmZCwgcmlnaHRzKSA9PiB7XG4gICAgICAgICAgICAvLyBsb2coXCJDSEVDS19GRFwiLCB7IGZkLCByaWdodHMgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHN0YXQodGhpcywgZmQpO1xuICAgICAgICAgICAgLy8gbG9nKFwiQ0hFQ0tfRkRcIiwgeyBzdGF0cyB9KTtcbiAgICAgICAgICAgIGlmIChyaWdodHMgIT09IEJpZ0ludCgwKSAmJiAoc3RhdHMucmlnaHRzLmJhc2UgJiByaWdodHMpID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5XQVNJRXJyb3IoY29uc3RhbnRzXzEuV0FTSV9FUEVSTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IENQVVRJTUVfU1RBUlQgPSB0aGlzLmJpbmRpbmdzLmhydGltZSgpO1xuICAgICAgICBjb25zdCBub3cgPSAoY2xvY2tJZCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjbG9ja0lkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5XQVNJX0NMT0NLX01PTk9UT05JQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3MuaHJ0aW1lKCk7XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5XQVNJX0NMT0NLX1JFQUxUSU1FOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNUb05zKERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuV0FTSV9DTE9DS19QUk9DRVNTX0NQVVRJTUVfSUQ6XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5XQVNJX0NMT0NLX1RIUkVBRF9DUFVUSU1FX0lEOiAvLyBUT0RPIC0tIHRoaXMgYXNzdW1lcyAxIHRocmVhZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5ocnRpbWUoKSAtIENQVVRJTUVfU1RBUlQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FzaUltcG9ydCA9IHtcbiAgICAgICAgICAgIGFyZ3NfZ2V0OiAoYXJndiwgYXJndkJ1ZikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGxldCBjb2Zmc2V0ID0gYXJndjtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gYXJndkJ1ZjtcbiAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihjb2Zmc2V0LCBvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIpLndyaXRlKGAke2F9XFwwYCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzX3NpemVzX2dldDogKGFyZ2MsIGFyZ3ZCdWZTaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTWVtb3J5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihhcmdjLCBhcmdzLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGFyZ3MucmVkdWNlKChhY2MsIGEpID0+IGFjYyArIEJ1ZmZlci5ieXRlTGVuZ3RoKGEpICsgMSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihhcmd2QnVmU2l6ZSwgc2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW52aXJvbl9nZXQ6IChlbnZpcm9uLCBlbnZpcm9uQnVmKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTWVtb3J5KCk7XG4gICAgICAgICAgICAgICAgbGV0IGNvZmZzZXQgPSBlbnZpcm9uO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBlbnZpcm9uQnVmO1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW52KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihjb2Zmc2V0LCBvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIpLndyaXRlKGAke2tleX09JHt2YWx1ZX1cXDBgLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudmlyb25fc2l6ZXNfZ2V0OiAoZW52aXJvbkNvdW50LCBlbnZpcm9uQnVmU2l6ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudlByb2Nlc3NlZCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuZW52KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke3ZhbHVlfVxcMGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBlbnZQcm9jZXNzZWQucmVkdWNlKChhY2MsIGUpID0+IGFjYyArIEJ1ZmZlci5ieXRlTGVuZ3RoKGUpLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKGVudmlyb25Db3VudCwgZW52UHJvY2Vzc2VkLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihlbnZpcm9uQnVmU2l6ZSwgc2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvY2tfcmVzX2dldDogKGNsb2NrSWQsIHJlc29sdXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2xvY2tJZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfQ0xPQ0tfTU9OT1RPTklDOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfQ0xPQ0tfUFJPQ0VTU19DUFVUSU1FX0lEOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfQ0xPQ0tfVEhSRUFEX0NQVVRJTUVfSUQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuV0FTSV9DTE9DS19SRUFMVElNRToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gQmlnSW50KDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGNsb2NrSWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQocmVzb2x1dGlvbiwgcmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9ja190aW1lX2dldDogKGNsb2NrSWQsIF9wcmVjaXNpb24sIHRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gbm93KGNsb2NrSWQpO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VJTlZBTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NCh0aW1lLCBCaWdJbnQobiksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZkX2FkdmlzZTogd3JhcCgoZmQsIF9vZmZzZXQsIF9sZW4sIF9hZHZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9BRFZJU0UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VOT1NZUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfYWxsb2NhdGU6IHdyYXAoKGZkLCBfb2Zmc2V0LCBfbGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfQUxMT0NBVEUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VOT1NZUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfY2xvc2U6IHdyYXAoKGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgQmlnSW50KDApKTtcbiAgICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoc3RhdHMucmVhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5GRF9NQVAuZGVsZXRlKGZkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfZGF0YXN5bmM6IHdyYXAoKGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQyk7XG4gICAgICAgICAgICAgICAgZnMuZmRhdGFzeW5jU3luYyhzdGF0cy5yZWFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfZmRzdGF0X2dldDogd3JhcCgoZmQsIGJ1ZlB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIEJpZ0ludCgwKSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJmZF9mZHN0YXRfZ2V0XCIsIGZkLCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTWVtb3J5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmZpbGV0eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJzdGF0cy5maWxldHlwZSBtdXN0IGJlIHNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQ4KGJ1ZlB0ciwgc3RhdHMuZmlsZXR5cGUpOyAvLyBGSUxFVFlQRSB1OFxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRVaW50MTYoYnVmUHRyICsgMiwgMCwgdHJ1ZSk7IC8vIEZERkxBRyB1MTZcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDE2KGJ1ZlB0ciArIDQsIDAsIHRydWUpOyAvLyBGREZMQUcgdTE2XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIgKyA4LCBCaWdJbnQoc3RhdHMucmlnaHRzLmJhc2UpLCB0cnVlKTsgLy8gdTY0XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIgKyA4ICsgOCwgQmlnSW50KHN0YXRzLnJpZ2h0cy5pbmhlcml0aW5nKSwgdHJ1ZSk7IC8vIHU2NFxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgZmRfZmRzdGF0X3NldF9mbGFnc1xuICAgICAgXG4gICAgICAgICAgICBEb2NzIEZyb20gdXBzdHJlYW06XG4gICAgICAgICAgICBBZGp1c3QgdGhlIGZsYWdzIGFzc29jaWF0ZWQgd2l0aCBhIGZpbGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAgIE5vdGU6IFRoaXMgaXMgc2ltaWxhciB0byBgZmNudGwoZmQsIEZfU0VURkwsIGZsYWdzKWAgaW4gUE9TSVguXG4gICAgICBcbiAgICAgICAgICAgIFRoaXMgY291bGQgYmUgc3VwcG9ydGVkIHZpYSBwb3NpeC1ub2RlIGluIGdlbmVyYWwgKHdoZW4gYXZhaWxhYmxlKVxuICAgICAgICAgICAgZm9yIHNvY2tldHMgYW5kIHN0ZGluL3N0ZG91dC9zdGRlcnIgYW5kIGdlbnVpbmUgZmlsZXMgKGJ1dCBub3RcbiAgICAgICAgICAgIGZvciBtZW1mcywgb2J2aW91c2x5KS4gIEl0J3MgdHlwaWNhbGx5IHVzZWQgYnkgQyBwcm9ncmFtcyBmb3JcbiAgICAgICAgICAgIGxvY2tpbmcgZmlsZXMsIGJ1dCBtb3N0IGltcG9ydGFudGx5IGZvciB1cywgZm9yIHNldHRpbmcgd2hldGhlclxuICAgICAgICAgICAgcmVhZGluZyBmcm9tIGEgZmQgaXMgbm9uYmxvY2tpbmcgKHZlcnkgaW1wb3J0YW50IGZvciBzdGRpbilcbiAgICAgICAgICAgIG9yIHNob3VsZCB0aW1lIG91dCBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGUuZy4sIHZlcnlcbiAgICAgICAgICAgIGltcG9ydGFudCBmb3IgYSBuZXR3b3JrIHNvY2tldCkuXG4gICAgICBcbiAgICAgICAgICAgIEZvciBub3cgd2UgaW1wbGVtZW50IHRoaXMgaW4gYSB2ZXJ5IHNtYWxsIG51bWJlciBvZiBjYXNlc1xuICAgICAgICAgICAgYW5kIHJldHVybiBcIkZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZFwiIG90aGVyd2lzZS5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBmZF9mZHN0YXRfc2V0X2ZsYWdzOiB3cmFwKChmZCwgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcmUgd2UgYWxsb3dlZCB0byBzZXQgZmxhZ3MuICBUaGlzIG1vcmUgbWVhbnM6IFwiaXMgaXQgaW1wbGVtZW50ZWQ/XCIuXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgbm93IHdlIG9ubHkgc2V0IHRoaXMgZmxhZyBmb3Igc29ja2V0cyAodGhhdCdzIGRvbmUgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZXh0ZXJuYWwga2VybmVsIG1vZHVsZSBpbiBzcmMvd2FzbS9wb3NpeC9zb2NrZXQudHMpLlxuICAgICAgICAgICAgICAgIENIRUNLX0ZEKGZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX0ZEU1RBVF9TRVRfRkxBR1MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndhc2lJbXBvcnQuc29ja19mY250bFNldEZsYWdzKGZkLCBmbGFncykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRU5PU1lTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmZF9mZHN0YXRfc2V0X3JpZ2h0czogd3JhcCgoZmQsIGZzUmlnaHRzQmFzZSwgZnNSaWdodHNJbmhlcml0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgQmlnSW50KDApKTtcbiAgICAgICAgICAgICAgICBjb25zdCBucmIgPSBzdGF0cy5yaWdodHMuYmFzZSB8IGZzUmlnaHRzQmFzZTtcbiAgICAgICAgICAgICAgICBpZiAobnJiID4gc3RhdHMucmlnaHRzLmJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVBFUk07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5yaSA9IHN0YXRzLnJpZ2h0cy5pbmhlcml0aW5nIHwgZnNSaWdodHNJbmhlcml0aW5nO1xuICAgICAgICAgICAgICAgIGlmIChucmkgPiBzdGF0cy5yaWdodHMuaW5oZXJpdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FUEVSTTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHMucmlnaHRzLmJhc2UgPSBmc1JpZ2h0c0Jhc2U7XG4gICAgICAgICAgICAgICAgc3RhdHMucmlnaHRzLmluaGVyaXRpbmcgPSBmc1JpZ2h0c0luaGVyaXRpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX2ZpbGVzdGF0X2dldDogd3JhcCgoZmQsIGJ1ZlB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfRklMRVNUQVRfR0VUKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3RhdHMgPSB0aGlzLmZzdGF0U3luYyhzdGF0cy5yZWFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgQmlnSW50KHJzdGF0cy5kZXYpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgQmlnSW50KHJzdGF0cy5pbm8pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHMuZmlsZXR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInN0YXRzLmZpbGV0eXBlIG11c3QgYmUgc2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDgoYnVmUHRyLCBzdGF0cy5maWxldHlwZSk7XG4gICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIsIEJpZ0ludChyc3RhdHMubmxpbmspLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgQmlnSW50KHJzdGF0cy5zaXplKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIsIG1zVG9Ocyhyc3RhdHMuYXRpbWVNcyksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJ1ZlB0ciArPSA4O1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoYnVmUHRyLCBtc1RvTnMocnN0YXRzLm10aW1lTXMpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgbXNUb05zKHJzdGF0cy5jdGltZU1zKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX2ZpbGVzdGF0X3NldF9zaXplOiB3cmFwKChmZCwgc3RTaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9TRVRfU0laRSk7XG4gICAgICAgICAgICAgICAgZnMuZnRydW5jYXRlU3luYyhzdGF0cy5yZWFsLCBOdW1iZXIoc3RTaXplKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX2ZpbGVzdGF0X3NldF90aW1lczogd3JhcCgoZmQsIHN0QXRpbSwgc3RNdGltLCBmc3RmbGFncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfRklMRVNUQVRfU0VUX1RJTUVTKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3RhdHMgPSB0aGlzLmZzdGF0U3luYyhzdGF0cy5yZWFsKTtcbiAgICAgICAgICAgICAgICBsZXQgYXRpbSA9IHJzdGF0cy5hdGltZTtcbiAgICAgICAgICAgICAgICBsZXQgbXRpbSA9IHJzdGF0cy5tdGltZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gbnNUb01zKG5vdyhjb25zdGFudHNfMS5XQVNJX0NMT0NLX1JFQUxUSU1FKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXRpbWZsYWdzID0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTSB8IGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XO1xuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBhdGltZmxhZ3MpID09PSBhdGltZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtdGltZmxhZ3MgPSBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNIHwgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTV9OT1c7XG4gICAgICAgICAgICAgICAgaWYgKChmc3RmbGFncyAmIG10aW1mbGFncykgPT09IG10aW1mbGFncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9BVElNKSA9PT0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTSkge1xuICAgICAgICAgICAgICAgICAgICBhdGltID0gbnNUb01zKHN0QXRpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmc3RmbGFncyAmIGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTV9OT1cpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRpbSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNKSA9PT0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTSkge1xuICAgICAgICAgICAgICAgICAgICBtdGltID0gbnNUb01zKHN0TXRpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmc3RmbGFncyAmIGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX01USU1fTk9XKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTV9OT1cpIHtcbiAgICAgICAgICAgICAgICAgICAgbXRpbSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZzLmZ1dGltZXNTeW5jKHN0YXRzLnJlYWwsIG5ldyBEYXRlKGF0aW0pLCBuZXcgRGF0ZShtdGltKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX3ByZXN0YXRfZ2V0OiB3cmFwKChmZCwgYnVmUHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgQmlnSW50KDApKTtcbiAgICAgICAgICAgICAgICAvLyBsb2coXCJmZF9wcmVzdGF0X2dldFwiLCB7IGZkLCBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDgoYnVmUHRyLCBjb25zdGFudHNfMS5XQVNJX1BSRU9QRU5UWVBFX0RJUik7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihidWZQdHIgKyA0LCBcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGRlZmluaXRlbHkgY29tcGxldGVseSB3cm9uZyB1bmxlc3MgcHJlb3BlbnM9Ly5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aGVuIGJvdGggcGF0aHMgYXJlIGJsYW5rLCB3ZSByZXR1cm4gXCJcIi4gIFRoaXMgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC8vIGNQeXRob24gb24gc29ja2V0cy4gICBJdCB1c2VkIHRvIHJhaXNlIGFuIGVycm9yIGhlcmUuXG4gICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoc3RhdHMuZmFrZVBhdGggPz8gc3RhdHMucGF0aCA/PyBcIlwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX3ByZXN0YXRfZGlyX25hbWU6IHdyYXAoKGZkLCBwYXRoUHRyLCBwYXRoTGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgQmlnSW50KDApKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aGVuIGJvdGggcGF0aHMgYXJlIGJsYW5rLCB3ZSByZXR1cm4gXCJcIi4gIFRoaXMgaXMgdXNlZCBieVxuICAgICAgICAgICAgICAgIC8vIGNQeXRob24gb24gc29ja2V0cy4gIEl0IHVzZWQgdG8gcmFpc2UgYW4gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIpLndyaXRlKHN0YXRzLmZha2VQYXRoID8/IHN0YXRzLnBhdGggPz8gXCJcIiAvKiBUT0RPOiB3cm9uZyBpbiBnZW5lcmFsIT8gKi8sIHBhdGhQdHIsIHBhdGhMZW4sIFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfcHdyaXRlOiB3cmFwKChmZCwgaW92cywgaW92c0xlbiwgb2Zmc2V0LCBud3JpdHRlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfV1JJVEUgfCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1NFRUspO1xuICAgICAgICAgICAgICAgIGxldCB3cml0dGVuID0gMDtcbiAgICAgICAgICAgICAgICBnZXRpb3ZzKGlvdnMsIGlvdnNMZW4pLmZvckVhY2goKGlvdikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh3IDwgaW92LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gZnMud3JpdGVTeW5jKHN0YXRzLnJlYWwsIGlvdiwgdywgaW92LmJ5dGVMZW5ndGggLSB3LCBOdW1iZXIob2Zmc2V0KSArIHdyaXR0ZW4gKyB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3cml0dGVuICs9IHc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihud3JpdHRlbiwgd3JpdHRlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX3dyaXRlOiB3cmFwKChmZCwgaW92cywgaW92c0xlbiwgbndyaXR0ZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IENIRUNLX0ZEKGZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1dSSVRFKTtcbiAgICAgICAgICAgICAgICBjb25zdCBJU19TVERPVVQgPSBmZCA9PSBjb25zdGFudHNfMS5XQVNJX1NURE9VVF9GSUxFTk87XG4gICAgICAgICAgICAgICAgY29uc3QgSVNfU1RERVJSID0gZmQgPT0gY29uc3RhbnRzXzEuV0FTSV9TVERFUlJfRklMRU5PO1xuICAgICAgICAgICAgICAgIGxldCB3cml0dGVuID0gMDtcbiAgICAgICAgICAgICAgICBnZXRpb3ZzKGlvdnMsIGlvdnNMZW4pLmZvckVhY2goKGlvdikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmRfd3JpdGVcIiwgYFwiJHtuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW92KX1cImApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW92LmJ5dGVMZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIGB3cml0aW5nIHRvIGZkPSR7ZmR9OiBgLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpb3YpKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShpb3YpXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChJU19TVERPVVQgJiYgdGhpcy5zZW5kU3Rkb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0ZG91dChpb3YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlbiArPSBpb3YuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChJU19TVERFUlIgJiYgdGhpcy5zZW5kU3RkZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0ZGVycihpb3YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlbiArPSBpb3YuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBiZSBhYnNvbHV0ZWx5IHN1cmUgaWYgd2FzaSBpcyB3cml0aW5nIHNvbWV0aGluZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZyhgd3JpdGUgXCIke25ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpb3YpfVwiIHRvICR7ZmR9KWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHcgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHcgPCBpb3YuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZyhgd3JpdGUgJHtpb3YuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gZmQ9JHtzdGF0cy5yZWFsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBmcy53cml0ZVN5bmMoc3RhdHMucmVhbCwgaW92LCB3LCBpb3YuYnl0ZUxlbmd0aCAtIHcsIHN0YXRzLm9mZnNldCA/IE51bWJlcihzdGF0cy5vZmZzZXQpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nKGBqdXN0IHdyb3RlIGk9JHtpfSBieXRlc2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm9mZnNldCArPSBCaWdJbnQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdyArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImZkX3dyaXRlXCIsIGZkLCBcIiAgd3JvdGUgXCIsIHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlbiArPSB3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihud3JpdHRlbiwgd3JpdHRlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX3ByZWFkOiB3cmFwKChmZCwgaW92cywgaW92c0xlbiwgb2Zmc2V0LCBucmVhZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfUkVBRCB8IGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfU0VFSyk7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWQgPSAwO1xuICAgICAgICAgICAgICAgIG91dGVyOiBmb3IgKGNvbnN0IGlvdiBvZiBnZXRpb3ZzKGlvdnMsIGlvdnNMZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIgPCBpb3YuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gaW92LmJ5dGVMZW5ndGggLSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnIgPSBmcy5yZWFkU3luYyhzdGF0cy5yZWFsLCBpb3YsIHIsIGlvdi5ieXRlTGVuZ3RoIC0gciwgTnVtYmVyKG9mZnNldCkgKyByZWFkICsgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByICs9IHJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCArPSBycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IHJlYWQgYW55dGhpbmcsIG9yIHdlIHJlY2VpdmUgbGVzcyB0aGFuIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJyID09PSAwIHx8IHJyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZCArPSByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKG5yZWFkLCByZWFkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfcmVhZDogd3JhcCgoZmQsIGlvdnMsIGlvdnNMZW4sIG5yZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9SRUFEKTtcbiAgICAgICAgICAgICAgICBjb25zdCBJU19TVERJTiA9IGZkID09IGNvbnN0YW50c18xLldBU0lfU1RESU5fRklMRU5PO1xuICAgICAgICAgICAgICAgIGxldCByZWFkID0gMDtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgbG9nVG9GaWxlKFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGBmZF9yZWFkOiAke0lTX1NURElOfSwgJHtKU09OLnN0cmluZ2lmeShzdGF0cywgKF8sIHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgKX0sICR7dGhpcy5zdGRpbkJ1ZmZlcj8ubGVuZ3RofSAke3RoaXMuc3RkaW5CdWZmZXI/LnRvU3RyaW5nKCl9YFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmRfcmVhZFwiLCBmZCwgc3RhdHMsIElTX1NURElOLCB0aGlzLmdldFN0ZGluICE9IG51bGwpO1xuICAgICAgICAgICAgICAgIG91dGVyOiBmb3IgKGNvbnN0IGlvdiBvZiBnZXRpb3ZzKGlvdnMsIGlvdnNMZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIgPCBpb3YuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGlvdi5ieXRlTGVuZ3RoIC0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IElTX1NURElOIHx8IHN0YXRzLm9mZnNldCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXIoc3RhdHMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSVNfU1RESU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRTdGRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0ZGluQnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RkaW5CdWZmZXIgPSB0aGlzLmdldFN0ZGluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RkaW5CdWZmZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBnb3Qgc3RkaW4gYWZ0ZXIgd2FpdGluZyBmb3IgaXQgaW4gcG9sbF9vbmVvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gbGltaXQgbGVuZ3RoIG9yIGlvdiB3aWxsIG92ZXJmbG93P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgT3Igd2lsbCB0aGUgYmVsb3cganVzdCB3b3JrIGZpbmU/ICBJdCBtaWdodC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZCByZW1hcmsgLS0gd2UgZG8gbm90IGRvIGFueXRoaW5nIHNwZWNpYWwgaGVyZSB0byB0cnkgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzZWVpbmcgRU9GIChjdHJsK2QpIGluIHRoZSBzdHJlYW0uICBObyBtYXR0ZXIgd2hhdCBJIHRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvaW5nIHNvbWV0aGluZyBoZXJlIChlLmcuLCByZXR1cm5pbmcgMCBieXRlcyByZWFkKSBkb2Vzbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJseSB3b3JrIHdpdGggbGliZWRpdC4gICBTbyB3ZSBsZWF2ZSBpdCBhbG9uZSBhbmQgbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgc2xpZ2h0bHkgcGF0Y2hlZCBsaWJlZGl0IGhhbmRsZSBjb250cm9sK2QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyIG5vdGUgdG8gc2VsZiAtLSAqKmhhbmRsaW5nIG9mIGNvbnRyb2wrZCBpcyBkb25lIGluIGxpYmVkaXQhKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyID0gdGhpcy5zdGRpbkJ1ZmZlci5jb3B5KGlvdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnIgPT0gdGhpcy5zdGRpbkJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZGluQnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGRpbkJ1ZmZlciA9IHRoaXMuc3RkaW5CdWZmZXIuc2xpY2UocnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlYWQgZnJvbSBzdGRpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RTdGRpbiA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXQVJOSU5HOiBtaWdodCBoYXZlIHRvIGRvIHNvbWV0aGluZyB0aGF0IGJ1cm5zIDEwMCUgY3B1Li4uIDotKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aG91Z2ggdGhpcyBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyBzaXR1YXRpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zbGVlcCA9PSBudWxsICYmICF3YXJuZWRBYm91dFNsZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuZWRBYm91dFNsZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiKGNwdSB3YWl0aW5nIGZvciBzdGRpbjogcGxlYXNlIGRlZmluZSBhIHdheSB0byBzbGVlcCEpIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3doaWxlIChyciA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByciA9IGZzLnJlYWRTeW5jKHN0YXRzLnJlYWwsIC8vIGZkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpb3YsIC8vIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciwgLy8gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgsIC8vIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLy8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG9ydFBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RTdGRpbiA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyID0gZnMucmVhZFN5bmMoc3RhdHMucmVhbCwgLy8gZmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpb3YsIC8vIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIsIC8vIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCwgLy8gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLy8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSSdtIG5vdCBzdXJlIHdoaWNoIHR5cGUgb2YgZmlsZXMgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4sIG9idmlvdXNseSBhIHJlZ3VsYXIgZmlsZSBzaG91bGQgYW5kIG9idmlvdXNseSBzdGRpbiAoYSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldmljZSkgYW5kIGEgcGlwZSAod2hpY2ggaGFzIHR5cGUgV0FTSV9GSUxFVFlQRV9TT0NLRVRfU1RSRUFNKSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5maWxldHlwZSA9PSBjb25zdGFudHNfMS5XQVNJX0ZJTEVUWVBFX1JFR1VMQVJfRklMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0cy5vZmZzZXQgPyBzdGF0cy5vZmZzZXQgOiBCaWdJbnQoMCkpICsgQmlnSW50KHJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkICs9IHJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgcmVhZCBhbnl0aGluZywgb3Igd2UgcmVjZWl2ZSBsZXNzIHRoYW4gcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnIgPT09IDAgfHwgcnIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImZkX3JlYWQ6IG5yZWFkPVwiLCByZWFkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKG5yZWFkLCByZWFkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmRfcmVhZGRpcjogd3JhcCgoZmQsIGJ1ZlB0ciwgYnVmTGVuLCBjb29raWUsIGJ1ZnVzZWRQdHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IENIRUNLX0ZEKGZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1JFQURESVIpO1xuICAgICAgICAgICAgICAgIC8vIGxvZyhcImZkX3JlYWRkaXIgZ290IHN0YXRzID0gXCIsIHN0YXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoc3RhdHMucGF0aCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHRyID0gYnVmUHRyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBOdW1iZXIoY29va2llKTsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmUHRyIC0gc3RhcnRQdHIgPiBidWZMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoYnVmUHRyLCBCaWdJbnQoaSArIDEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZQdHIgLSBzdGFydFB0ciA+IGJ1Zkxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIGxzdGF0IGluc3RlYWQgb2Ygc3RhdCwgc2luY2Ugc3RhdCBmYWlscyBvbiBicm9rZW4gbGlua3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHN0YXQgcmVzb2x2ZXMgdGhlIGxpbmsgZ2l2aW5nIHRoZSB3cm9uZyBpbm9kZSEgIE9uIHRoZSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kLCBsc3RhdCB3b3JrcyBmaW5lIG9uIG5vbi1saW5rcy4gIFRoaXMgaXMgd3JvbmcgaW4gdXBzdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGJyZWFrcyB0ZXN0aW5nIHRlc3RfY29tcGlsZWFsbC5weSAgaW4gdGhlIHB5dGhvbiB0ZXN0IHN1aXRlLFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gZG9pbmcgb3Muc2NhbmRpciBvbiBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGEgYnJva2VuIGxpbmsuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJzdGF0cyA9IGZzLmxzdGF0U3luYyhwYXRoLnJlc29sdmUoc3RhdHMucGF0aCwgZW50cnkubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgQmlnSW50KHJzdGF0cy5pbm8pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZQdHIgLSBzdGFydFB0ciA+IGJ1Zkxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihidWZQdHIsIG5hbWVMZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBidWZQdHIgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZlB0ciAtIHN0YXJ0UHRyID4gYnVmTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZXR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByc3RhdHMuaXNCbG9ja0RldmljZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0eXBlID0gY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9CTE9DS19ERVZJQ0U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHJzdGF0cy5pc0NoYXJhY3RlckRldmljZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0eXBlID0gY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9DSEFSQUNURVJfREVWSUNFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByc3RhdHMuaXNEaXJlY3RvcnkoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSA9IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfRElSRUNUT1JZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByc3RhdHMuaXNGSUZPKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGUgPSBjb25zdGFudHNfMS5XQVNJX0ZJTEVUWVBFX1NPQ0tFVF9TVFJFQU07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHJzdGF0cy5pc0ZpbGUoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSA9IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfUkVHVUxBUl9GSUxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByc3RhdHMuaXNTb2NrZXQoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSA9IGNvbnN0YW50c18xLldBU0lfRklMRVRZUEVfU09DS0VUX1NUUkVBTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcnN0YXRzLmlzU3ltYm9saWNMaW5rKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGUgPSBjb25zdGFudHNfMS5XQVNJX0ZJTEVUWVBFX1NZTUJPTElDX0xJTks7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0eXBlID0gY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9VTktOT1dOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRVaW50OChidWZQdHIsIGZpbGV0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmUHRyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZlB0ciArPSAzOyAvLyBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZQdHIgKyBuYW1lTGVuZ3RoID49IHN0YXJ0UHRyICsgYnVmTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBkb2Vzbid0IGZpdCBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWVtb3J5X2J1ZmZlciA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeV9idWZmZXIud3JpdGUoZW50cnkubmFtZSwgYnVmUHRyKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmUHRyICs9IG5hbWVMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZnVzZWQgPSBidWZQdHIgLSBzdGFydFB0cjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKGJ1ZnVzZWRQdHIsIE1hdGgubWluKGJ1ZnVzZWQsIGJ1ZkxlbiksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmZF9yZW51bWJlcjogd3JhcCgoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBDSEVDS19GRChmcm9tLCBCaWdJbnQoMCkpO1xuICAgICAgICAgICAgICAgIENIRUNLX0ZEKHRvLCBCaWdJbnQoMCkpO1xuICAgICAgICAgICAgICAgIGZzLmNsb3NlU3luYyh0aGlzLkZEX01BUC5nZXQoZnJvbSkucmVhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5GRF9NQVAuc2V0KGZyb20sIHRoaXMuRkRfTUFQLmdldCh0bykpO1xuICAgICAgICAgICAgICAgIHRoaXMuRkRfTUFQLmRlbGV0ZSh0byk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZkX3NlZWs6IHdyYXAoKGZkLCBvZmZzZXQsIHdoZW5jZSwgbmV3T2Zmc2V0UHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9TRUVLKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfV0hFTkNFX0NVUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRzLm9mZnNldCA/IHN0YXRzLm9mZnNldCA6IEJpZ0ludCgwKSkgKyBCaWdJbnQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfV0hFTkNFX0VORDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpcy5mc3RhdFN5bmMoc3RhdHMucmVhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5vZmZzZXQgPSBCaWdJbnQoc2l6ZSkgKyBCaWdJbnQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfV0hFTkNFX1NFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm9mZnNldCA9IEJpZ0ludChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0cy5vZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInN0YXRzLm9mZnNldCBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQobmV3T2Zmc2V0UHRyLCBzdGF0cy5vZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmZF90ZWxsOiB3cmFwKChmZCwgb2Zmc2V0UHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9URUxMKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5vZmZzZXQgPSBCaWdJbnQoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQob2Zmc2V0UHRyLCBzdGF0cy5vZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmZF9zeW5jOiB3cmFwKChmZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfU1lOQyk7XG4gICAgICAgICAgICAgICAgZnMuZnN5bmNTeW5jKHN0YXRzLnJlYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwYXRoX2NyZWF0ZV9kaXJlY3Rvcnk6IHdyYXAoKGZkLCBwYXRoUHRyLCBwYXRoTGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QQVRIX0NSRUFURV9ESVJFQ1RPUlkpO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdHMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIsIHBhdGhQdHIsIHBhdGhMZW4pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGgucmVzb2x2ZShzdGF0cy5wYXRoLCBwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfZmlsZXN0YXRfZ2V0OiB3cmFwKChmZCwgZmxhZ3MsIHBhdGhQdHIsIHBhdGhMZW4sIGJ1ZlB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfUEFUSF9GSUxFU1RBVF9HRVQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdHMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIsIHBhdGhQdHIsIHBhdGhMZW4pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInBhdGhfZmlsZXN0YXRfZ2V0XCIsIHApO1xuICAgICAgICAgICAgICAgIGxldCByc3RhdHM7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzdGF0cyA9IGZzLnN0YXRTeW5jKHBhdGgucmVzb2x2ZShzdGF0cy5wYXRoLCBwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBleGFjdGx5IG9uZSBmbGFnIGltcGxlbWVudGVkIGNhbGxlZCBcIl9fV0FTSV9MT09LVVBGTEFHU19TWU1MSU5LX0ZPTExPV1wiO1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIDEgYW5kIGlzIHVzZWQgdG8gZm9sbG93IGxpbmtzLCBpLmUuLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnQgbHN0YXQgLS0gdGhpcyBpcyBpZ25vcmVkIGluIHVwc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgemlnL2xpYi9saWJjL3dhc2kvbGliYy1ib3R0b20taGFsZi9jbG91ZGxpYmMvc3JjL2xpYmMvc3lzL3N0YXQvZnN0YXRhdC5jXG4gICAgICAgICAgICAgICAgICAgIHJzdGF0cyA9IGZzLmxzdGF0U3luYyhwYXRoLnJlc29sdmUoc3RhdHMucGF0aCwgcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicGF0aF9maWxlc3RhdF9nZXQgZ290XCIsIHJzdGF0cylcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgb3V0cHV0IGlzIHRoZSBmaWxlc3RhdCBzdHJ1Y3QgYXMgZG9jdW1lbnRlZCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L1dBU0kvYmxvYi9tYWluL3BoYXNlcy9zbmFwc2hvdC9kb2NzLm1kIy1maWxlc3RhdC1yZWNvcmRcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGRvZXMgTk9UIGV2ZW4gaGF2ZSBhIGZpZWxkIGZvciB0aGF0LiAgVGhpcyBpcyBjb25zaWRlcmVkIGFuIG9wZW4gYnVnIGluIFdBU0k6XG4gICAgICAgICAgICAgICAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vV2ViQXNzZW1ibHkvd2FzaS1maWxlc3lzdGVtL2lzc3Vlcy8zNFxuICAgICAgICAgICAgICAgIC8vIFRoYXQgc2FpZCwgd2FzaSBkb2VzIGVuZCB1cCBzZXR0aW5nIGVub3VnaCBvZiBzdF9tb2RlIHNvIGlzZGlyIHdvcmtzLlxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoYnVmUHRyLCBCaWdJbnQocnN0YXRzLmRldiksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJ1ZlB0ciArPSA4O1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoYnVmUHRyLCBCaWdJbnQocnN0YXRzLmlubyksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJ1ZlB0ciArPSA4O1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRVaW50OChidWZQdHIsIHRyYW5zbGF0ZUZpbGVBdHRyaWJ1dGVzKHRoaXMsIHVuZGVmaW5lZCwgcnN0YXRzKS5maWxldHlwZSk7XG4gICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIsIEJpZ0ludChyc3RhdHMubmxpbmspLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgQmlnSW50KHJzdGF0cy5zaXplKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnVmUHRyICs9IDg7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChidWZQdHIsIG1zVG9Ocyhyc3RhdHMuYXRpbWVNcyksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJ1ZlB0ciArPSA4O1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoYnVmUHRyLCBtc1RvTnMocnN0YXRzLm10aW1lTXMpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidWZQdHIgKz0gODtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KGJ1ZlB0ciwgbXNUb05zKHJzdGF0cy5jdGltZU1zKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfZmlsZXN0YXRfc2V0X3RpbWVzOiB3cmFwKChmZCwgX2RpcmZsYWdzLCBwYXRoUHRyLCBwYXRoTGVuLCBzdEF0aW0sIHN0TXRpbSwgZnN0ZmxhZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IENIRUNLX0ZEKGZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfRklMRVNUQVRfU0VUX1RJTUVTKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3RhdHMgPSB0aGlzLmZzdGF0U3luYyhzdGF0cy5yZWFsKTtcbiAgICAgICAgICAgICAgICBsZXQgYXRpbSA9IHJzdGF0cy5hdGltZTtcbiAgICAgICAgICAgICAgICBsZXQgbXRpbSA9IHJzdGF0cy5tdGltZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gbnNUb01zKG5vdyhjb25zdGFudHNfMS5XQVNJX0NMT0NLX1JFQUxUSU1FKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXRpbWZsYWdzID0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTSB8IGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XO1xuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBhdGltZmxhZ3MpID09PSBhdGltZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtdGltZmxhZ3MgPSBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNIHwgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTV9OT1c7XG4gICAgICAgICAgICAgICAgaWYgKChmc3RmbGFncyAmIG10aW1mbGFncykgPT09IG10aW1mbGFncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9BVElNKSA9PT0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTSkge1xuICAgICAgICAgICAgICAgICAgICBhdGltID0gbnNUb01zKHN0QXRpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmc3RmbGFncyAmIGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX0FUSU1fTk9XKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfQVRJTV9OT1cpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRpbSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnN0ZmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZJTEVTVEFUX1NFVF9NVElNKSA9PT0gY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTSkge1xuICAgICAgICAgICAgICAgICAgICBtdGltID0gbnNUb01zKHN0TXRpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmc3RmbGFncyAmIGNvbnN0YW50c18xLldBU0lfRklMRVNUQVRfU0VUX01USU1fTk9XKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9GSUxFU1RBVF9TRVRfTVRJTV9OT1cpIHtcbiAgICAgICAgICAgICAgICAgICAgbXRpbSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBCdWZmZXIuZnJvbSh0aGlzLm1lbW9yeS5idWZmZXIsIHBhdGhQdHIsIHBhdGhMZW4pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZnMudXRpbWVzU3luYyhwYXRoLnJlc29sdmUoc3RhdHMucGF0aCwgcCksIG5ldyBEYXRlKGF0aW0pLCBuZXcgRGF0ZShtdGltKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfbGluazogd3JhcCgob2xkRmQsIF9vbGRGbGFncywgb2xkUGF0aCwgb2xkUGF0aExlbiwgbmV3RmQsIG5ld1BhdGgsIG5ld1BhdGhMZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvc3RhdHMgPSBDSEVDS19GRChvbGRGZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QQVRIX0xJTktfU09VUkNFKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuc3RhdHMgPSBDSEVDS19GRChuZXdGZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QQVRIX0xJTktfVEFSR0VUKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9zdGF0cy5wYXRoIHx8ICFuc3RhdHMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBvbGRQYXRoLCBvbGRQYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5wID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBuZXdQYXRoLCBuZXdQYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGZzLmxpbmtTeW5jKHBhdGgucmVzb2x2ZShvc3RhdHMucGF0aCwgb3ApLCBwYXRoLnJlc29sdmUobnN0YXRzLnBhdGgsIG5wKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfb3Blbjogd3JhcCgoZGlyZmQsIF9kaXJmbGFncywgcGF0aFB0ciwgcGF0aExlbiwgb2ZsYWdzLCBmc1JpZ2h0c0Jhc2UsIGZzUmlnaHRzSW5oZXJpdGluZywgZnNGbGFncywgZmRQdHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IENIRUNLX0ZEKGRpcmZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfT1BFTik7XG4gICAgICAgICAgICAgICAgZnNSaWdodHNCYXNlID0gQmlnSW50KGZzUmlnaHRzQmFzZSk7XG4gICAgICAgICAgICAgICAgZnNSaWdodHNJbmhlcml0aW5nID0gQmlnSW50KGZzUmlnaHRzSW5oZXJpdGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZCA9IChmc1JpZ2h0c0Jhc2UgJiAoY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9SRUFEIHwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9SRUFERElSKSkgIT09XG4gICAgICAgICAgICAgICAgICAgIEJpZ0ludCgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZSA9IChmc1JpZ2h0c0Jhc2UgJlxuICAgICAgICAgICAgICAgICAgICAoY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQyB8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1dSSVRFIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50c18xLldBU0lfUklHSFRfRkRfQUxMT0NBVEUgfFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9GSUxFU1RBVF9TRVRfU0laRSkpICE9PVxuICAgICAgICAgICAgICAgICAgICBCaWdJbnQoMCk7XG4gICAgICAgICAgICAgICAgbGV0IG5vZmxhZ3M7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlICYmIHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9mbGFncyA9IGZzLmNvbnN0YW50cy5PX1JEV1I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9mbGFncyA9IGZzLmNvbnN0YW50cy5PX1JET05MWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9mbGFncyA9IGZzLmNvbnN0YW50cy5PX1dST05MWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZnNSaWdodHNCYXNlIGlzIG5lZWRlZCBoZXJlIGJ1dCBwZXJoYXBzIHdlIHNob3VsZCBkbyBpdCBpbiBuZWVkZWRJbmhlcml0aW5nXG4gICAgICAgICAgICAgICAgbGV0IG5lZWRlZEJhc2UgPSBmc1JpZ2h0c0Jhc2UgfCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfT1BFTjtcbiAgICAgICAgICAgICAgICBsZXQgbmVlZGVkSW5oZXJpdGluZyA9IGZzUmlnaHRzQmFzZSB8IGZzUmlnaHRzSW5oZXJpdGluZztcbiAgICAgICAgICAgICAgICBpZiAoKG9mbGFncyAmIGNvbnN0YW50c18xLldBU0lfT19DUkVBVCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9mbGFncyB8PSBmcy5jb25zdGFudHMuT19DUkVBVDtcbiAgICAgICAgICAgICAgICAgICAgbmVlZGVkQmFzZSB8PSBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfQ1JFQVRFX0ZJTEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob2ZsYWdzICYgY29uc3RhbnRzXzEuV0FTSV9PX0RJUkVDVE9SWSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9mbGFncyB8PSBmcy5jb25zdGFudHMuT19ESVJFQ1RPUlk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob2ZsYWdzICYgY29uc3RhbnRzXzEuV0FTSV9PX0VYQ0wpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fRVhDTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChvZmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX09fVFJVTkMpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fVFJVTkM7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRlZEJhc2UgfD0gY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QQVRIX0ZJTEVTVEFUX1NFVF9TSVpFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZpbGUgZGVzY3JpcHRvciBmbGFncy5cbiAgICAgICAgICAgICAgICBpZiAoKGZzRmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZERkxBR19BUFBFTkQpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fQVBQRU5EO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGZzRmxhZ3MgJiBjb25zdGFudHNfMS5XQVNJX0ZERkxBR19EU1lOQykgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmNvbnN0YW50cy5PX0RTWU5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2ZsYWdzIHw9IGZzLmNvbnN0YW50cy5PX0RTWU5DO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9mbGFncyB8PSBmcy5jb25zdGFudHMuT19TWU5DO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5lZWRlZEluaGVyaXRpbmcgfD0gY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9EQVRBU1lOQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChmc0ZsYWdzICYgY29uc3RhbnRzXzEuV0FTSV9GREZMQUdfTk9OQkxPQ0spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fTk9OQkxPQ0s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnNGbGFncyAmIGNvbnN0YW50c18xLldBU0lfRkRGTEFHX1JTWU5DKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnMuY29uc3RhbnRzLk9fUlNZTkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fUlNZTkM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2ZsYWdzIHw9IGZzLmNvbnN0YW50cy5PX1NZTkM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmVlZGVkSW5oZXJpdGluZyB8PSBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1NZTkM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZnNGbGFncyAmIGNvbnN0YW50c18xLldBU0lfRkRGTEFHX1NZTkMpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZmxhZ3MgfD0gZnMuY29uc3RhbnRzLk9fU1lOQztcbiAgICAgICAgICAgICAgICAgICAgbmVlZGVkSW5oZXJpdGluZyB8PSBjb25zdGFudHNfMS5XQVNJX1JJR0hUX0ZEX1NZTkM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3cml0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAobm9mbGFncyAmIChmcy5jb25zdGFudHMuT19BUFBFTkQgfCBmcy5jb25zdGFudHMuT19UUlVOQykpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRlZEluaGVyaXRpbmcgfD0gY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9GRF9TRUVLO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBwYXRoUHRyLCBwYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChwID09IFwiZGV2L3R0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogXCJ0aGUgdGVybWluYWxcIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkLCBlLmcuLCBpbiB0aGUgXCJsZXNzXCIgcHJvZ3JhbSBpbiBvcGVuX3R0eSBpbiB0dHlpbi5jXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHdpbGwgd29yayB0byBtYWtlIGEgbmV3IHR0eSBpZiB1c2luZyB0aGUgbmF0aXZlIG9zLCBidXQgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBhIHdvcmtlciB0aHJlYWQgb3IgaW4gYnJvd3NlciwgaXQncyBtdWNoIHNpbXBsZXIgdG8ganVzdFxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gc3RkaW4sIHdoaWNoIHdvcmtzIGZpbmUgKEkgdGhpbmspLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKGZkUHRyLCBjb25zdGFudHNfMS5XQVNJX1NURElOX0ZJTEVOTywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dPcGVuKFwicGF0aF9vcGVuXCIsIHApO1xuICAgICAgICAgICAgICAgIGlmIChwLnN0YXJ0c1dpdGgoXCJwcm9jL1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGUgZXJyb3IgLS0gb3RoZXJ3aXNlIHN0dWZmIHdpbGwgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBqdXN0IGlzbid0IGltcGxlbWVudGVkLCBhbmQgd2lsbCBoYW5nIGZvcmV2ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIEUuZy4sIGN5dGhvbiBkb2VzLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5XQVNJRXJyb3IoY29uc3RhbnRzXzEuV0FTSV9FQkFERik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxVbnJlc29sdmVkID0gcGF0aC5yZXNvbHZlKHN0YXRzLnBhdGgsIHApO1xuICAgICAgICAgICAgICAgIC8vIEkgZG9uJ3Qga25vdyB3aHkgdGhlIG9yaWdpbmFsIGNvZGUgYmxvY2tlZCAuLiwgYnV0IHRoYXQgYnJlYWtzXG4gICAgICAgICAgICAgICAgLy8gYXBwbGljYXRpb25zIChlLmcuLCB0YXIpLCBhbmQgdGhpcyBzZWVtcyBsaWtlIHRoZSB3cm9uZyBsYXllciBhdCB3aGljaCB0b1xuICAgICAgICAgICAgICAgIC8vIGJlIGltcG9zaW5nIHNlY3VyaXR5P1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBpZiAocGF0aC5yZWxhdGl2ZShzdGF0cy5wYXRoLCBmdWxsVW5yZXNvbHZlZCkuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIFdBU0lfRU5PVENBUEFCTEU7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmdWxsID0gZnMucmVhbHBhdGhTeW5jKGZ1bGxVbnJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaWYgKHBhdGgucmVsYXRpdmUoc3RhdHMucGF0aCwgZnVsbCkuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgcmV0dXJuIFdBU0lfRU5PVENBUEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGU/LmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGwgPSBmdWxsVW5yZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZyhcIioqIG9wZW5wYXRoIEZBSUw6IHAgPSBcIiwgcCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGNoZWNrIGlmIHRoZSBmaWxlIGlzIGEgZGlyZWN0b3J5ICh1bmxlc3Mgb3BlbmluZyBmb3Igd3JpdGUsXG4gICAgICAgICAgICAgICAgICogaW4gd2hpY2ggY2FzZSB0aGUgZmlsZSBtYXkgbm90IGV4aXN0IGFuZCBzaG91bGQgYmUgY3JlYXRlZCkgKi9cbiAgICAgICAgICAgICAgICBsZXQgaXNEaXJlY3Rvcnk7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RpcmVjdG9yeSA9IGZzLnN0YXRTeW5jKGZ1bGwpLmlzRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coX2VycilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVhbGZkO1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGUgJiYgaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbGZkID0gZnMub3BlblN5bmMoZnVsbCwgZnMuY29uc3RhbnRzLk9fUkRPTkxZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBmcy5vcGVuU3luYyhcIiR7ZnVsbH1cIiwgJHtub2ZsYWdzfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbGZkID0gZnMub3BlblN5bmMoZnVsbCwgbm9mbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld2ZkID0gdGhpcy5nZXRVbnVzZWRGaWxlRGVzY3JpcHRvcigpO1xuICAgICAgICAgICAgICAgIC8vIGxvZyhgKiogb3BlbnBhdGggZ290IGZkOiBwPScke3B9JywgZmQ9JHtuZXdmZH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLkZEX01BUC5zZXQobmV3ZmQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbDogcmVhbGZkLFxuICAgICAgICAgICAgICAgICAgICBmaWxldHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQ6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlOiBuZWVkZWRCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZzogbmVlZGVkSW5oZXJpdGluZyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIHN0YXRlIGhlcmUgZG9lcyBzb21lIGNvbnNpc3RlbmN5IGNoZWNrc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGhlIGZpbGV0eXBlIGVudHJ5IGluIHRoZSByZWNvcmQgY3JlYXRlZCBhYm92ZS5cbiAgICAgICAgICAgICAgICBzdGF0KHRoaXMsIG5ld2ZkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKGZkUHRyLCBuZXdmZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfcmVhZGxpbms6IHdyYXAoKGZkLCBwYXRoUHRyLCBwYXRoTGVuLCBidWYsIGJ1ZkxlbiwgYnVmdXNlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfUEFUSF9SRUFETElOSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VJTlZBTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTWVtb3J5KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlciwgcGF0aFB0ciwgcGF0aExlbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsID0gcGF0aC5yZXNvbHZlKHN0YXRzLnBhdGgsIHApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBmcy5yZWFkbGlua1N5bmMoZnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlZCA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlcikud3JpdGUociwgYnVmLCBidWZMZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRVaW50MzIoYnVmdXNlZCwgdXNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfcmVtb3ZlX2RpcmVjdG9yeTogd3JhcCgoZmQsIHBhdGhQdHIsIHBhdGhMZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IENIRUNLX0ZEKGZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfUkVNT1ZFX0RJUkVDVE9SWSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VJTlZBTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTWVtb3J5KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlciwgcGF0aFB0ciwgcGF0aExlbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBmcy5ybWRpclN5bmMocGF0aC5yZXNvbHZlKHN0YXRzLnBhdGgsIHApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGF0aF9yZW5hbWU6IHdyYXAoKG9sZEZkLCBvbGRQYXRoLCBvbGRQYXRoTGVuLCBuZXdGZCwgbmV3UGF0aCwgbmV3UGF0aExlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9zdGF0cyA9IENIRUNLX0ZEKG9sZEZkLCBjb25zdGFudHNfMS5XQVNJX1JJR0hUX1BBVEhfUkVOQU1FX1NPVVJDRSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnN0YXRzID0gQ0hFQ0tfRkQobmV3RmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfUEFUSF9SRU5BTUVfVEFSR0VUKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9zdGF0cy5wYXRoIHx8ICFuc3RhdHMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FSU5WQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBvbGRQYXRoLCBvbGRQYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5wID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBuZXdQYXRoLCBuZXdQYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGZzLnJlbmFtZVN5bmMocGF0aC5yZXNvbHZlKG9zdGF0cy5wYXRoLCBvcCksIHBhdGgucmVzb2x2ZShuc3RhdHMucGF0aCwgbnApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGF0aF9zeW1saW5rOiB3cmFwKChvbGRQYXRoLCBvbGRQYXRoTGVuLCBmZCwgbmV3UGF0aCwgbmV3UGF0aExlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gQ0hFQ0tfRkQoZmQsIGNvbnN0YW50c18xLldBU0lfUklHSFRfUEFUSF9TWU1MSU5LKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlciwgb2xkUGF0aCwgb2xkUGF0aExlbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBucCA9IEJ1ZmZlci5mcm9tKHRoaXMubWVtb3J5LmJ1ZmZlciwgbmV3UGF0aCwgbmV3UGF0aExlbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBmcy5zeW1saW5rU3luYyhvcCwgcGF0aC5yZXNvbHZlKHN0YXRzLnBhdGgsIG5wKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhdGhfdW5saW5rX2ZpbGU6IHdyYXAoKGZkLCBwYXRoUHRyLCBwYXRoTGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBDSEVDS19GRChmZCwgY29uc3RhbnRzXzEuV0FTSV9SSUdIVF9QQVRIX1VOTElOS19GSUxFKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gQnVmZmVyLmZyb20odGhpcy5tZW1vcnkuYnVmZmVyLCBwYXRoUHRyLCBwYXRoTGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMocGF0aC5yZXNvbHZlKHN0YXRzLnBhdGgsIHApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gcG9sbF9vbmVvZmY6IENvbmN1cnJlbnRseSBwb2xsIGZvciB0aGUgb2NjdXJyZW5jZSBvZiBhIHNldCBvZiBldmVudHMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBOT1QgaW1wbGVtZW50ZWQgcHJvcGVybHkgeWV0IGluIGdlbmVyYWwuXG4gICAgICAgICAgICAvLyBJdCBkb2VzIHJlYWQgYWxsIHRoZSBkYXRhIGZyb20gc2luLCBldGMuXG4gICAgICAgICAgICAvLyBjb3JyZWN0bHkgbm93LCBidXQgaXQgZG9lc24ndCBhY3R1YWxseSB3b3JrIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgIC8vIEl0IHdvcmtzIGZvcjpcbiAgICAgICAgICAgIC8vICAgICAtIG9uZSB0aW1lclxuICAgICAgICAgICAgLy8gICAgIC0gb25lIGZpbGUgZGVzY3JpcHRvciBjb3JyZXNwb25kaW5nIHRvIGEgc29ja2V0IGFuZCBvbmUgdGltZXIsXG4gICAgICAgICAgICAvLyAgICAgICB3aGljaCBpcyB3aGF0IHBvbGwgd2l0aCAxIGZkIGFuZCBhIHRpbWVvdXQgY3JlYXRlLlxuICAgICAgICAgICAgcG9sbF9vbmVvZmY6IChzaW4sIHNvdXQsIG5zdWJzY3JpcHRpb25zLCBuZXZlbnRzUHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ldmVudHMgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAvLyBNYXkgaGF2ZSB0byB3YWl0IHRoaXMgbG9uZyAodGhpcyBnZXRzIGNvbXB1dGVkIGJlbG93IGluIHRoZSBXQVNJX0VWRU5UVFlQRV9DTE9DSyBjYXNlKS5cbiAgICAgICAgICAgICAgICBsZXQgd2FpdFRpbWVOcyA9IEJpZ0ludCgwKTtcbiAgICAgICAgICAgICAgICBsZXQgZmQgPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgZmRfdHlwZSA9IFwicmVhZFwiO1xuICAgICAgICAgICAgICAgIGxldCBmZF90aW1lb3V0X21zID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE5zID0gQmlnSW50KHRoaXMuYmluZGluZ3MuaHJ0aW1lKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbW9yeSgpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0X3NpbiA9IHNpbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5zdWJzY3JpcHRpb25zOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlcmRhdGEgPSB0aGlzLnZpZXcuZ2V0QmlnVWludDY0KHNpbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNpbiArPSA4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy52aWV3LmdldFVpbnQ4KHNpbik7XG4gICAgICAgICAgICAgICAgICAgIHNpbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzaW4gKz0gNzsgLy8gcGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IGNvbnN0YW50c18xLldBU0lfRVZFTlRUWVBFX0NMT0NLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwicG9sbF9vbmVvZmYgKHR5cGU9V0FTSV9FVkVOVFRZUEVfQ0xPQ0spOiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gY29uc3RhbnRzXzEuV0FTSV9FVkVOVFRZUEVfRkRfUkVBRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcInBvbGxfb25lb2ZmICh0eXBlPVdBU0lfRVZFTlRUWVBFX0ZEX1JFQUQpOiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcInBvbGxfb25lb2ZmICh0eXBlPVdBU0lfRVZFTlRUWVBFX0ZEX1dSSVRFKTogXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLldBU0lfRVZFTlRUWVBFX0NMT0NLOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIHBhY2thZ2VzL3ppZy9kaXN0L2xpYi9saWJjL2luY2x1ZGUvd2FzbS13YXNpLW11c2wvd2FzaS9hcGkuaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBleGFjdGx5IGhvdyB0aGVzZSB2YWx1ZXMgYXJlIGVuY29kZWQuICBJIGNhcmVmdWxseSBsb29rZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGF0IGhlYWRlciBhbmQgKip0aGlzIGlzIGRlZmluaXRlbHkgcmlnaHQqKi4gIFNhbWUgd2l0aCB0aGUgZmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3RoZXIgY2FzZSBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9ja2lkID0gdGhpcy52aWV3LmdldFVpbnQzMihzaW4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiArPSA0OyAvLyBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMudmlldy5nZXRCaWdVaW50NjQoc2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW4gKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IHByZWNpc2lvbiA9IHRoaXMudmlldy5nZXRCaWdVaW50NjQoc2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW4gKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJjbG9ja2ZsYWdzID0gdGhpcy52aWV3LmdldFVpbnQxNihzaW4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiArPSA2OyAvLyBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBzdWJjbG9ja2ZsYWdzID09PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cobmFtZSwgeyBjbG9ja2lkLCB0aW1lb3V0LCBhYnNvbHV0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZF90aW1lb3V0X21zID0gTnVtYmVyKHRpbWVvdXQgLyBCaWdJbnQoMTAwMDAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG5vdyhjbG9ja2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2dUb0ZpbGUodCwgY2xvY2tpZCwgdGltZW91dCwgc3ViY2xvY2tmbGFncywgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gYWJzb2x1dGUgPyB0aW1lb3V0IDogdCArIHRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXROcyA9IGVuZCAtIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWl0TnMgPiB3YWl0VGltZU5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0VGltZU5zID0gd2FpdE5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoc291dCwgdXNlcmRhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXQgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDE2KHNvdXQsIGUsIHRydWUpOyAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXQgKz0gMjsgLy8gcGFkIG9mZnNldCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQ4KHNvdXQsIGNvbnN0YW50c18xLldBU0lfRVZFTlRUWVBFX0NMT0NLKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3V0ICs9IDE7IC8vIHBhZCBvZmZzZXQgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXQgKz0gNTsgLy8gcGFkZGluZyB0byA4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV2ZW50cyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5XQVNJX0VWRU5UVFlQRV9GRF9SRUFEOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5XQVNJX0VWRU5UVFlQRV9GRF9XUklURToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9vayBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvbGliYy93YXNpL2xpYmMtYm90dG9tLWhhbGYvY2xvdWRsaWJjL3NyYy9saWJjL3N5cy9zZWxlY3QvcHNlbGVjdC5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc2VlIGhvdyBwb2xsX29uZW9mZiBpcyBhY3R1YWxseSB1c2VkIGJ5IHdhc2kgdG8gaW1wbGVtZW50IHBzZWxlY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQncyBhbHNvIHVzZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL2xpYmMvd2FzaS9saWJjLWJvdHRvbS1oYWxmL2Nsb3VkbGliYy9zcmMvbGliYy9wb2xsL3BvbGwuY1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklmIG5vbmUgb2YgdGhlIHNlbGVjdGVkIGRlc2NyaXB0b3JzIGFyZSByZWFkeSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkIG9wZXJhdGlvbiwgdGhlIHBzZWxlY3QoKSBvciBzZWxlY3QoKSBmdW5jdGlvbiBzaGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrIHVudGlsIGF0IGxlYXN0IG9uZSBvZiB0aGUgcmVxdWVzdGVkIG9wZXJhdGlvbnMgYmVjb21lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5LCB1bnRpbCB0aGUgdGltZW91dCBvY2N1cnMsIG9yIHVudGlsIGludGVycnVwdGVkIGJ5IGEgc2lnbmFsLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGh1cyB3aGF0IGlzIHN1cHBvc2VkIHRvIGhhcHBlbiBiZWxvdyBpcyBzdXBwb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJsb2NrIHVudGlsIHRoZSBmZCBpcyByZWFkeSB0byByZWFkIGZyb20gb3Igd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bywgZXRjLlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3Igbm93IGF0IGxlYXN0IGlmIHJlYWRpbmcgZnJvbSBzdGRpbiB0aGVuIHdlIGJsb2NrIGZvciBhIHNob3J0IGFtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRpbWUgaWYgZ2V0U3RkaW4gZGVmaW5lZDsgb3RoZXJ3aXNlLCB3ZSBhdCBsZWFzdCAqcGF1c2UqIGZvciBhIG1vbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0byBhdm9pZCBjcHUgYnVybikgaWYgdGhpcy5zbGVlcCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZCA9IHRoaXMudmlldy5nZXRVaW50MzIoc2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZF90eXBlID0gdHlwZSA9PSBjb25zdGFudHNfMS5XQVNJX0VWRU5UVFlQRV9GRF9SRUFEID8gXCJyZWFkXCIgOiBcIndyaXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKG5hbWUsIFwiZmQgPVwiLCBmZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luICs9IDI4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRCaWdVaW50NjQoc291dCwgdXNlcmRhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXQgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0VWludDE2KHNvdXQsIGNvbnN0YW50c18xLldBU0lfRU5PU1lTLCB0cnVlKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3V0ICs9IDI7IC8vIHBhZCBvZmZzZXQgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRVaW50OChzb3V0LCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3V0ICs9IDE7IC8vIHBhZCBvZmZzZXQgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXQgKz0gNTsgLy8gcGFkZGluZyB0byA4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV2ZW50cyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVE9ETzogZm9yIG5vdyBmb3Igc3RkaW4gd2UgYXJlIGp1c3QgZG9pbmcgYSBkdW1iIGhhY2suXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlIGp1c3QgZG8gc29tZXRoaW5nIHJlYWxseSBuYWl2ZSwgd2hpY2ggaXMgXCJwYXVzZSBmb3IgYSBsaXR0bGUgd2hpbGVcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBzZWVtcyB0byB3b3JrIGZvciBldmVyeSBhcHBsaWNhdGlvbiBJIGhhdmUgc28gZmFyLCBmcm9tIFB5dGhvbiB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIG5jdXJzZXMsIGV0Yy4gIFRoaXMgYWxzbyBtYWtlcyBpdCBlYXN5IHRvIGhhdmUgbm9uLWJsb2NraW5nIHNsZWVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbm9kZS5qcyBhdCB0aGUgdGVybWluYWwgd2l0aG91dCBhIHdvcmtlciB0aHJlYWQsIHdoaWNoIGlzIHZlcnkgbmljZSFcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQmVmb3JlIEkgaGFkIGl0IGJsb2NrIGhlcmUgdmlhIGdldFN0ZGluIHdoZW4gYXZhaWxhYmxlLCBidXQgdGhhdCBkb2VzIG5vdCB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gZ2VuZXJhbDsgaW4gcGFydGljdWxhciwgaXQgYnJlYWtzIG5jdXJzZXMgY29tcGxldGVseS4gSW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuY3Vyc2VzL3R0eS90dHlfdXBkYXRlLmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZm9sbG93aW5nIGNhbGwgaXMgYXNzdW1lZCBub3QgdG8gYmxvY2ssIGFuZCBpZiBpdCBkb2VzLCB0aGVuIG5jdXJzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiBiZWNvbWVzIHRvdGFsbHkgYnJva2VuOlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QoU1BfUEFSTS0+X2NoZWNrZmQgKyAxLCAmZmRzZXQsIE5VTEwsIE5VTEwsICZrdGltZW91dClcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmQgPT0gY29uc3RhbnRzXzEuV0FTSV9TVERJTl9GSUxFTk8gJiYgY29uc3RhbnRzXzEuV0FTSV9FVkVOVFRZUEVfRkRfUkVBRCA9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvcnRQYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpc3RlbmN5IGNoZWNrIHRoYXQgd2UgY29uc3VtZWQgZXhhY3RseSB0aGUgcmlnaHQgYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBfX3dhc2lfc3Vic2NyaXB0aW9uX3QuIFNlZSB6aWcvbGliL2xpYmMvaW5jbHVkZS93YXNtLXdhc2ktbXVzbC93YXNpL2FwaS5oXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW4gLSBsYXN0X3NpbiAhPSA0OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiKioqIEJVRyBpbiB3YXNpLWpzIGluIHBvbGxfb25lb2ZmIFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9zaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZjogc2luIC0gbGFzdF9zaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0X3NpbiA9IHNpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihuZXZlbnRzUHRyLCBuZXZlbnRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV2ZW50cyA9PSAyICYmIGZkID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMud2FzaUltcG9ydC5zb2NrX3BvbGxTb2NrZXQoZmQsIGZkX3R5cGUsIGZkX3RpbWVvdXRfbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAociAhPSBjb25zdGFudHNfMS5XQVNJX0VOT1NZUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBpbXBsZW1lbnRhdGlvbiBmcm9tIG91dHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBiZWxvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgdGltZSBpdCB0b29rIHRvIGRvIGV2ZXJ5dGhpbmcgYWJvdmUsIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIGFyYml0cmFyaWx5IGxvbmc6XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRUaW1lTnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRUaW1lTnMgLT0gQmlnSW50KHRoaXMuYmluZGluZ3MuaHJ0aW1lKCkpIC0gc3RhcnROcztcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nVG9GaWxlKFwid2FpdFRpbWVOc1wiLCB3YWl0VGltZU5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhaXRUaW1lTnMgPj0gMTAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2xlZXAgPT0gbnVsbCAmJiAhd2FybmVkQWJvdXRTbGVlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5lZEFib3V0U2xlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiKDEwMCUgY3B1IGJ1cm5pbmcgd2FpdGluZyBmb3Igc3RkaW46IHBsZWFzZSBkZWZpbmUgYSB3YXkgdG8gc2xlZXAhKSBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zbGVlcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHJ1bm5pbmcgaW4gYSB3b3JrZXIgdGhyZWFkLCBhbmQgaGF2ZSAqc29tZSB3YXkqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3luY2hyb25vdXNseSBwYXVzZSBleGVjdXRpb24gb2YgdGhpcyB0aHJlYWQuICBZZWFoIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zID0gbnNUb01zKHdhaXRUaW1lTnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xlZXAobXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlICoqaG9ycmlibGUqKiAxMDAlIGJsb2NrIGFuZCAxMDAlIGNwdVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhaXQsIHdoaWNoIG1pZ2h0IHNvcnQgb2Ygd29yaywgYnV0IGlzIG9idmlvdXNseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgd3JvbmcgbmlnaHRtYXJlLiAgVW5mb3J0dW5hdGVseSwgdGhpcyBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHBvc3NpYmxlIHRoaW5nIHRvIGRvIHdoZW4gbm90IHJ1bm5pbmcgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHdvcmsgdGhyZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IEJpZ0ludCh0aGlzLmJpbmRpbmdzLmhydGltZSgpKSArIHdhaXRUaW1lTnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKEJpZ0ludCh0aGlzLmJpbmRpbmdzLmhydGltZSgpKSA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXJuIHlvdXIgQ1BVIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jX2V4aXQ6IChydmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5leGl0KHJ2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VTVUNDRVNTO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2NfcmFpc2U6IChzaWcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShzaWcgaW4gY29uc3RhbnRzXzEuU0lHTkFMX01BUCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRUlOVkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmtpbGwoY29uc3RhbnRzXzEuU0lHTkFMX01BUFtzaWddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYW5kb21fZ2V0OiAoYnVmUHRyLCBidWZMZW4pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW1vcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnJhbmRvbUZpbGxTeW5jKG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlciksIGJ1ZlB0ciwgYnVmTGVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FU1VDQ0VTUztcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB1cHN0cmVhbSBoYWQgXCJyZXR1cm4gV0FTSV9FU1VDQ0VTUztcIiBoZXJlLCB3aGljaCBJIHRob3VnaHQgd2FzXG4gICAgICAgICAgICAgICAgLy8gYSBtYWpvciBidWcsIHNpbmNlIGdldHJhbmRvbSByZXR1cm5zIHRoZSAqbnVtYmVyIG9mIHJhbmRvbSBieXRlcyouXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgSSB0aGluayBpbnN0ZWFkIHRoaXMgd2FzIGEgYnVnIGluIG11c2wgb3IgbGliYyBvciB6aWcgb3Igc29tZXRoaW5nLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGdvdCBmaXhlZCBpbiB2ZXJzaW9uICAwLjEwLjAtZGV2LjQxNjErZGFiNWJiOTI0LCBzaW5jZSB3aXRoIHRoYXRcbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlIHJldHVybmluZyBhbnl0aGluZyBpbnN0ZWFkIG9mIHN1Y2Nlc3MgKD0wKSBoZXJlIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgLy8gKEJlZm9yZSByZXR1cm5pbmcgMCBtYWRlIGl0IHNvIFB5dGhvbiBodW5nIG15c3RlcmlvdXNseSBvbiBzdGFydHVwLCB3aGljaCB0b29rc1xuICAgICAgICAgICAgICAgIC8vIG1lIGRheXMgb2Ygc3VmZmVyaW5nIHRvIGZpZ3VyZSBvdXQuIEluIHBhcnRpY3VsYXIsIFB5dGhvbiBzdGFydHVwXG4gICAgICAgICAgICAgICAgLy8gaGFuZ3MgYXQgcHlfZ2V0cmFuZG9tIGluIGJvb3RzdHJhcF9oYXNoLmMuKVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBidWZMZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NoZWRfeWllbGQoKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlIHRocmVhZGVkIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGluIEpTXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLldBU0lfRVNVQ0NFU1M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVGhlIGNsaWVudCBjb3VsZCBvdmVyd3JpdGUgdGhlc2Ugc29ja18qOyB0aGF0J3Mgd2hhdFxuICAgICAgICAgICAgLy8gQ29XYXNtIGRvZXMgaW4gaW5qZWN0RnVuY3Rpb25zIGluXG4gICAgICAgICAgICAvLyAgICBwYWNrYWdlcy9rZXJuZWwvc3JjL3dhc20vd29ya2VyL3Bvc2l4LWNvbnRleHQudHNcbiAgICAgICAgICAgIHNvY2tfcmVjdigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FTk9TWVM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ja19zZW5kKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VOT1NZUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb2NrX3NodXRkb3duKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5XQVNJX0VOT1NZUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb2NrX2ZjbnRsU2V0RmxhZ3MoX2ZkLCBfZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FTk9TWVM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ja19wb2xsU29ja2V0KF9mZCwgX2V2ZW50dHlwZSwgX3RpbWVvdXRfbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuV0FTSV9FTk9TWVM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAobG9nLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFdyYXAgZWFjaCBvZiB0aGUgaW1wb3J0cyB0byBzaG93IHRoZSBjYWxscyB2aWEgdGhlIGRlYnVnIGxvZ2dlci5cbiAgICAgICAgICAgIC8vIFdlIE9OTFkgZG8gdGhpcyBpZiB0aGUgbG9nZ2VyIGlzIGVuYWJsZWQsIHNpbmNlIGl0IG1pZ2h0XG4gICAgICAgICAgICAvLyBiZSBleHBlbnNpdmUuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLndhc2lJbXBvcnQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJbXBvcnQgPSB0aGlzLndhc2lJbXBvcnRba2V5XTtcbiAgICAgICAgICAgICAgICB0aGlzLndhc2lJbXBvcnRba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhrZXksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHByZXZJbXBvcnQoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcImVycm9yOiBcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4geyBlbnY6IHRoaXMuZW52LCBGRF9NQVA6IHRoaXMuRkRfTUFQLCBiaW5kaW5nczogdGhpcy5iaW5kaW5ncyB9O1xuICAgIH1cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLmVudiA9IHN0YXRlLmVudjtcbiAgICAgICAgdGhpcy5GRF9NQVAgPSBzdGF0ZS5GRF9NQVA7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBzdGF0ZS5iaW5kaW5ncztcbiAgICB9XG4gICAgZnN0YXRTeW5jKHJlYWxfZmQpIHtcbiAgICAgICAgaWYgKHJlYWxfZmQgPD0gMikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5mcy5mc3RhdFN5bmMocmVhbF9mZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNwZWNpYWwgY2FzZSBvZiBzdGRpbi9zdGRvdXQvc3RkZXJyIGluIHNvbWUgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4sIHdpbmRvd3MgdW5kZXIgZWxlY3Ryb24pIHNvbWUgb2YgdGhlIGFjdHVhbCBmaWxlIGRlc2NyaXB0b3JzXG4gICAgICAgICAgICAgICAgLy8gYXJlbid0IGRlZmluZWQgaW4gdGhlIG5vZGUgcHJvY2Vzcy4gIFdlIHRodXMgZmFrZSBpdCwgc2luY2Ugd2VcbiAgICAgICAgICAgICAgICAvLyBhcmUgdmlydHVhbGl6aW5nIHRoZXNlIGluIG91ciBjb2RlIGFueXdheXMuXG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZXY6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IDg1OTIsXG4gICAgICAgICAgICAgICAgICAgIG5saW5rOiAxLFxuICAgICAgICAgICAgICAgICAgICB1aWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGdpZDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmRldjogMCxcbiAgICAgICAgICAgICAgICAgICAgYmxrc2l6ZTogNjU1MzYsXG4gICAgICAgICAgICAgICAgICAgIGlubzogMCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzOiAwLFxuICAgICAgICAgICAgICAgICAgICBhdGltZU1zOiBub3cudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBtdGltZU1zOiBub3cudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBjdGltZU1zOiBub3cudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBiaXJ0aHRpbWVNczogMCxcbiAgICAgICAgICAgICAgICAgICAgYXRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIG10aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBjdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgYmlydGh0aW1lOiBuZXcgRGF0ZSgwKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYWwgY2FzZVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5mcy5mc3RhdFN5bmMocmVhbF9mZCk7XG4gICAgfVxuICAgIHNob3J0UGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNsZWVwID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5sYXN0U3RkaW4gPiAyMDAwKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlICpzb21lIHdheSogdG8gc3luY2hyb25vdXNseSBwYXVzZSBleGVjdXRpb24gb2ZcbiAgICAgICAgICAgIC8vIHRoaXMgdGhyZWFkLCBzbyB3ZSBzbGVlcCBhIGxpdHRsZSB0byBhdm9pZCBidXJuaW5nXG4gICAgICAgICAgICAvLyAxMDAlIGNwdS4gIEJ1dCBub3QgcmlnaHQgYWZ0ZXIgcmVhZGluZyBpbnB1dCwgc2luY2VcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0eXBpbmcgZmVlbHMgbGFnZ3kuXG4gICAgICAgICAgICAvLyBXZSBjYW4gcHJvYmFibHkgZ2V0IHJpZCBvZiB0aGlzIGVudGlyZWx5IHdpdGggYSBwcm9wZXJcbiAgICAgICAgICAgIC8vIHdnZXRjaGFyLi4uXG4gICAgICAgICAgICB0aGlzLnNsZWVwKDUwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gYW4gdW51c2VkIGZpbGUgZGVzY3JpcHRvci4gIEl0ICp3aWxsKiBiZSB0aGUgc21hbGxlc3RcbiAgICAvLyBhdmFpbGFibGUgZmlsZSBkZXNjcmlwdG9yLCBleGNlcHQgd2UgZG9uJ3QgdXNlIDAsMSwyXG4gICAgZ2V0VW51c2VkRmlsZURlc2NyaXB0b3Ioc3RhcnQgPSAzKSB7XG4gICAgICAgIGxldCBmZCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAodGhpcy5GRF9NQVAuaGFzKGZkKSkge1xuICAgICAgICAgICAgZmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmQgPiBTQ19PUEVOX01BWCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBhdmFpbGFibGUgZmlsZSBkZXNjcmlwdG9yc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmQ7XG4gICAgfVxuICAgIHJlZnJlc2hNZW1vcnkoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcgfHwgdGhpcy52aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRNZW1vcnkobWVtb3J5KSB7XG4gICAgICAgIHRoaXMubWVtb3J5ID0gbWVtb3J5O1xuICAgIH1cbiAgICBzdGFydChpbnN0YW5jZSwgbWVtb3J5KSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICBpZiAoZXhwb3J0cyA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwb3J0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnN0YW5jZS5leHBvcnRzIG11c3QgYmUgYW4gT2JqZWN0LiBSZWNlaXZlZCAke2V4cG9ydHN9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVtb3J5ID0gZXhwb3J0cy5tZW1vcnk7XG4gICAgICAgICAgICBpZiAoIShtZW1vcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5NZW1vcnkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnN0YW5jZS5leHBvcnRzLm1lbW9yeSBtdXN0IGJlIGEgV2ViQXNzZW1ibHkuTWVtb3J5LiBSZWNjZWl2ZWQgJHttZW1vcnl9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TWVtb3J5KG1lbW9yeSk7XG4gICAgICAgIGlmIChleHBvcnRzLl9zdGFydCkge1xuICAgICAgICAgICAgZXhwb3J0cy5fc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbXBvcnROYW1lc3BhY2UobW9kdWxlKSB7XG4gICAgICAgIGxldCBuYW1lc3BhY2UgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpbXAgb2YgV2ViQXNzZW1ibHkuTW9kdWxlLmltcG9ydHMobW9kdWxlKSkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBjaGVjayBmb3IgdGhlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKGltcC5raW5kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFsbG93IGZ1bmN0aW9ucyBpbiBvdGhlciBuYW1lc3BhY2VzIG90aGVyIHRoYW4gd2FzaVxuICAgICAgICAgICAgaWYgKCFpbXAubW9kdWxlLnN0YXJ0c1dpdGgoXCJ3YXNpX1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBpbXAubW9kdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gaW1wLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBuYW1lc3BhY2VzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0SW1wb3J0cyhtb2R1bGUpIHtcbiAgICAgICAgbGV0IG5hbWVzcGFjZSA9IHRoaXMuZ2V0SW1wb3J0TmFtZXNwYWNlKG1vZHVsZSk7XG4gICAgICAgIHN3aXRjaCAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBjYXNlIFwid2FzaV91bnN0YWJsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdhc2lfdW5zdGFibGU6IHRoaXMud2FzaUltcG9ydCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcIndhc2lfc25hcHNob3RfcHJldmlldzFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiB0aGlzLndhc2lJbXBvcnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZGV0ZWN0IGEgV0FTSSBuYW1lc3BhY2UgZm9yIHRoZSBXZWJBc3NlbWJseSBNb2R1bGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFdhc2lGZEluZm8oKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgTk9UIHVzZWQgeWV0LiBJdCBjdXJyZW50bHkgY3Jhc2hlcy5cbiAgICAgICAgaWYgKHRoaXMuZW52W1wiV0FTSV9GRF9JTkZPXCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBXQVNJX0ZEX0lORk8gaXMgc2V0IHRvIHRoZVxuICAgICAgICAgICAgLy8gSlNPTiB2ZXJzaW9uIG9mIGEgbWFwIGZyb20gd2FzaSBmZCdzIHRvIHJlYWwgZmQncywgdGhlblxuICAgICAgICAgICAgLy8gd2UgYWxzbyBpbml0aWFsaXplIEZEX01BUCB3aXRoIHRoYXQsIGFzc3VtaW5nIHRoZXNlXG4gICAgICAgICAgICAvLyBhcmUgYWxsIGluaGVyaXRhYmxlIGZpbGUgZGVzY3JpcHRvcnMgZm9yIGVuZHMgb2YgcGlwZXMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNvbWV0aGluZyBhZGRlZCBmb3JcbiAgICAgICAgICAgIC8vIHB5dGhvbi13YXNtIGZvcmsvZXhlYyBzdXBwb3J0LlxuICAgICAgICAgICAgY29uc3QgZmRJbmZvID0gSlNPTi5wYXJzZSh0aGlzLmVudltcIldBU0lfRkRfSU5GT1wiXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdhc2lfZmQgaW4gZmRJbmZvKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cod2FzaV9mZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmQgPSBwYXJzZUludCh3YXNpX2ZkKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5GRF9NQVAuaGFzKGZkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbCA9IGZkSW5mb1t3YXNpX2ZkXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgZmQgcmVhbGx5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZzdGF0U3luYyhyZWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaXNjYXJkaW5nIFwiLCB7IHdhc2lfZmQsIHJlYWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICAgICAgICAgICAgICByZWFsLFxuICAgICAgICAgICAgICAgICAgICBmaWxldHlwZTogY29uc3RhbnRzXzEuV0FTSV9GSUxFVFlQRV9TT0NLRVRfU1RSRUFNLFxuICAgICAgICAgICAgICAgICAgICByaWdodHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IFNURElOX0RFRkFVTFRfUklHSFRTLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZzogQmlnSW50KDApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5GRF9NQVAuc2V0KGZkLCBmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWZ0ZXIgaW5pdFdhc2lGZEluZm86IFwiLCB0aGlzLkZEX01BUCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImZkSW5mbyA9IFwiLCBmZEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBXQVNJX0ZEX0lORk9cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBXQVNJO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FzaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/dist/wasi.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/wasi-js/node_modules/fflate/lib/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar node_worker_1 = __webpack_require__(/*! ./node-worker.cjs */ \"(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/worker.cjs\");\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexports.FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return node_worker_1[\"default\"](ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexports.Deflate = Deflate;\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexports.AsyncDeflate = AsyncDeflate;\nfunction deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\nexports.deflate = deflate;\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nfunction deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\nexports.deflateSync = deflateSync;\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexports.Inflate = Inflate;\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexports.AsyncInflate = AsyncInflate;\nfunction inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\nexports.inflate = inflate;\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, out) {\n    return inflt(data, out);\n}\nexports.inflateSync = inflateSync;\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexports.Gzip = Gzip;\nexports.Compress = Gzip;\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexports.AsyncGzip = AsyncGzip;\nexports.AsyncCompress = AsyncGzip;\nfunction gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\nexports.gzip = gzip;\nexports.compress = gzip;\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nfunction gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\nexports.gzipSync = gzipSync;\nexports.compressSync = gzipSync;\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexports.Gunzip = Gunzip;\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexports.AsyncGunzip = AsyncGunzip;\nfunction gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\nexports.gunzip = gunzip;\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nfunction gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\nexports.gunzipSync = gunzipSync;\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexports.Zlib = Zlib;\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexports.AsyncZlib = AsyncZlib;\nfunction zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\nexports.zlib = zlib;\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nfunction zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\nexports.zlibSync = zlibSync;\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexports.Unzlib = Unzlib;\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexports.AsyncUnzlib = AsyncUnzlib;\nfunction unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\nexports.unzlib = unzlib;\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\nexports.unzlibSync = unzlibSync;\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexports.Decompress = Decompress;\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexports.AsyncDecompress = AsyncDecompress;\nfunction decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\nexports.decompress = decompress;\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\nexports.decompressSync = decompressSync;\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexports.DecodeUTF8 = DecodeUTF8;\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexports.EncodeUTF8 = EncodeUTF8;\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nfunction strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\nexports.strToU8 = strToU8;\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nfunction strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\nexports.strFromU8 = strFromU8;\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexports.ZipPassThrough = ZipPassThrough;\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexports.ZipDeflate = ZipDeflate;\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexports.AsyncZipDeflate = AsyncZipDeflate;\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexports.Zip = Zip;\nfunction zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\nexports.zip = zip;\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nfunction zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\nexports.zipSync = zipSync;\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexports.UnzipPassThrough = UnzipPassThrough;\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexports.UnzipInflate = UnzipInflate;\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexports.AsyncUnzipInflate = AsyncUnzipInflate;\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexports.Unzip = Unzip;\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nfunction unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\nexports.unzip = unzip;\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nfunction unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\nexports.unzipSync = unzipSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL25vZGVfbW9kdWxlcy9mZmxhdGUvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0dBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUUsc0VBQXNFLG9CQUFvQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2IsK0hBQStIO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcd2FzaS1qc1xcbm9kZV9tb2R1bGVzXFxmZmxhdGVcXGxpYlxcaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gREVGTEFURSBpcyBhIGNvbXBsZXggZm9ybWF0OyB0byByZWFkIHRoaXMgY29kZSwgeW91IHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGUgUkZDIGZpcnN0OlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5NTFcbi8vIFlvdSBtYXkgYWxzbyB3aXNoIHRvIHRha2UgYSBsb29rIGF0IHRoZSBndWlkZSBJIG1hZGUgYWJvdXQgdGhpcyBwcm9ncmFtOlxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAxYXJyb3d6LzI1M2YzMWViNWFiYzNkOTI3NWFiOTQzMDAzZmZlY2FkXG4vLyBTb21lIG9mIHRoZSBmb2xsb3dpbmcgY29kZSBpcyBzaW1pbGFyIHRvIHRoYXQgb2YgVVpJUC5qczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VWklQLmpzXG4vLyBIb3dldmVyLCB0aGUgdmFzdCBtYWpvcml0eSBvZiB0aGUgY29kZWJhc2UgaGFzIGRpdmVyZ2VkIGZyb20gVVpJUC5qcyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSBhbmQgcmVkdWNlIGJ1bmRsZSBzaXplLlxuLy8gU29tZXRpbWVzIDAgd2lsbCBhcHBlYXIgd2hlcmUgLTEgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZS4gVGhpcyBpcyBiZWNhdXNlIHVzaW5nIGEgdWludFxuLy8gaXMgYmV0dGVyIGZvciBtZW1vcnkgaW4gbW9zdCBlbmdpbmVzIChJICp0aGluayopLlxudmFyIG5vZGVfd29ya2VyXzEgPSByZXF1aXJlKFwiLi9ub2RlLXdvcmtlci5janNcIik7XG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdLCByZXZmZCA9IF9iWzFdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAoY2RbaV0pXG4gICAgICAgICAgICArK2xbY2RbaV0gLSAxXTtcbiAgICB9XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwICsgNykgLyA4KSB8IDA7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHZhciBuID0gbmV3ICh2LkJZVEVTX1BFUl9FTEVNRU5UID09IDIgPyB1MTYgOiB2LkJZVEVTX1BFUl9FTEVNRU5UID09IDQgPyB1MzIgOiB1OCkoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbi8qKlxuICogQ29kZXMgZm9yIGVycm9ycyBnZW5lcmF0ZWQgd2l0aGluIHRoaXMgbGlicmFyeVxuICovXG5leHBvcnRzLkZsYXRlRXJyb3JDb2RlID0ge1xuICAgIFVuZXhwZWN0ZWRFT0Y6IDAsXG4gICAgSW52YWxpZEJsb2NrVHlwZTogMSxcbiAgICBJbnZhbGlkTGVuZ3RoTGl0ZXJhbDogMixcbiAgICBJbnZhbGlkRGlzdGFuY2U6IDMsXG4gICAgU3RyZWFtRmluaXNoZWQ6IDQsXG4gICAgTm9TdHJlYW1IYW5kbGVyOiA1LFxuICAgIEludmFsaWRIZWFkZXI6IDYsXG4gICAgTm9DYWxsYmFjazogNyxcbiAgICBJbnZhbGlkVVRGODogOCxcbiAgICBFeHRyYUZpZWxkVG9vTG9uZzogOSxcbiAgICBJbnZhbGlkRGF0ZTogMTAsXG4gICAgRmlsZW5hbWVUb29Mb25nOiAxMSxcbiAgICBTdHJlYW1GaW5pc2hpbmc6IDEyLFxuICAgIEludmFsaWRaaXBEYXRhOiAxMyxcbiAgICBVbmtub3duQ29tcHJlc3Npb25NZXRob2Q6IDE0XG59O1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAndW5leHBlY3RlZCBFT0YnLFxuICAgICdpbnZhbGlkIGJsb2NrIHR5cGUnLFxuICAgICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJyxcbiAgICAnaW52YWxpZCBkaXN0YW5jZScsXG4gICAgJ3N0cmVhbSBmaW5pc2hlZCcsXG4gICAgJ25vIHN0cmVhbSBoYW5kbGVyJyxcbiAgICAsXG4gICAgJ25vIGNhbGxiYWNrJyxcbiAgICAnaW52YWxpZCBVVEYtOCBkYXRhJyxcbiAgICAnZXh0cmEgZmllbGQgdG9vIGxvbmcnLFxuICAgICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknLFxuICAgICdmaWxlbmFtZSB0b28gbG9uZycsXG4gICAgJ3N0cmVhbSBmaW5pc2hpbmcnLFxuICAgICdpbnZhbGlkIHppcCBkYXRhJ1xuICAgIC8vIGRldGVybWluZWQgYnkgdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2Rcbl07XG47XG52YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlLCBlcnIpO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBidWYsIHN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGg7XG4gICAgaWYgKCFzbCB8fCAoc3QgJiYgc3QuZiAmJiAhc3QubCkpXG4gICAgICAgIHJldHVybiBidWYgfHwgbmV3IHU4KDApO1xuICAgIC8vIGhhdmUgdG8gZXN0aW1hdGUgc2l6ZVxuICAgIHZhciBub0J1ZiA9ICFidWYgfHwgc3Q7XG4gICAgLy8gbm8gc3RhdGVcbiAgICB2YXIgbm9TdCA9ICFzdCB8fCBzdC5pO1xuICAgIGlmICghc3QpXG4gICAgICAgIHN0ID0ge307XG4gICAgLy8gQXNzdW1lcyByb3VnaGx5IDMzJSBjb21wcmVzc2lvbiByYXRpbyBhdmVyYWdlXG4gICAgaWYgKCFidWYpXG4gICAgICAgIGJ1ZiA9IG5ldyB1OChzbCAqIDMpO1xuICAgIC8vIGVuc3VyZSBidWZmZXIgY2FuIGZpdCBhdCBsZWFzdCBsIGVsZW1lbnRzXG4gICAgdmFyIGNidWYgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgYmwgPSBidWYubGVuZ3RoO1xuICAgICAgICAvLyBuZWVkIHRvIGluY3JlYXNlIHNpemUgdG8gZml0XG4gICAgICAgIGlmIChsID4gYmwpIHtcbiAgICAgICAgICAgIC8vIERvdWJsZSBvciBzZXQgdG8gbmVjZXNzYXJ5LCB3aGljaGV2ZXIgaXMgZ3JlYXRlclxuICAgICAgICAgICAgdmFyIG5idWYgPSBuZXcgdTgoTWF0aC5tYXgoYmwgKiAyLCBsKSk7XG4gICAgICAgICAgICBuYnVmLnNldChidWYpO1xuICAgICAgICAgICAgYnVmID0gbmJ1ZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gIGxhc3QgY2h1bmsgICAgICAgICBiaXRwb3MgICAgICAgICAgIGJ5dGVzXG4gICAgdmFyIGZpbmFsID0gc3QuZiB8fCAwLCBwb3MgPSBzdC5wIHx8IDAsIGJ0ID0gc3QuYiB8fCAwLCBsbSA9IHN0LmwsIGRtID0gc3QuZCwgbGJ0ID0gc3QubSwgZGJ0ID0gc3QubjtcbiAgICAvLyB0b3RhbCBiaXRzXG4gICAgdmFyIHRidHMgPSBzbCAqIDg7XG4gICAgZG8ge1xuICAgICAgICBpZiAoIWxtKSB7XG4gICAgICAgICAgICAvLyBCRklOQUwgLSB0aGlzIGlzIG9ubHkgMSB3aGVuIGxhc3QgY2h1bmsgaXMgbmV4dFxuICAgICAgICAgICAgZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogOCwgc3QuZiA9IGZpbmFsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gIGxpdGVyYWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1xuICAgICAgICAgICAgICAgIHZhciBoTGl0ID0gYml0cyhkYXQsIHBvcywgMzEpICsgMjU3LCBoY0xlbiA9IGJpdHMoZGF0LCBwb3MgKyAxMCwgMTUpICsgNDtcbiAgICAgICAgICAgICAgICB2YXIgdGwgPSBoTGl0ICsgYml0cyhkYXQsIHBvcyArIDUsIDMxKSArIDE7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE0O1xuICAgICAgICAgICAgICAgIC8vIGxlbmd0aCtkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGxkdCA9IG5ldyB1OCh0bCk7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdHJlZVxuICAgICAgICAgICAgICAgIHZhciBjbHQgPSBuZXcgdTgoMTkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW5kZXggbWFwIHRvIGdldCByZWFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgY2x0W2NsaW1baV1dID0gYml0cyhkYXQsIHBvcyArIGkgKiAzLCA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGhjTGVuICogMztcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgYml0c1xuICAgICAgICAgICAgICAgIHZhciBjbGIgPSBtYXgoY2x0KSwgY2xibXNrID0gKDEgPDwgY2xiKSAtIDE7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIG1hcFxuICAgICAgICAgICAgICAgIHZhciBjbG0gPSBoTWFwKGNsdCwgY2xiLCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRsOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNsbVtiaXRzKGRhdCwgcG9zLCBjbGJtc2spXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyByZWFkXG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSByICYgMTU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHIgPj4+IDQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRvIGNvcHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvcHkgICBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAwLCBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09IDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgMyksIHBvcyArPSAyLCBjID0gbGR0W2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCA3KSwgcG9zICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAxMSArIGJpdHMoZGF0LCBwb3MsIDEyNyksIHBvcyArPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgbGVuZ3RoIHRyZWUgICAgICAgICAgICAgICAgIGRpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSBsZHQuc3ViYXJyYXkoMCwgaExpdCksIGR0ID0gbGR0LnN1YmFycmF5KGhMaXQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBsZW5ndGggYml0c1xuICAgICAgICAgICAgICAgIGxidCA9IG1heChsdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGRpc3QgYml0c1xuICAgICAgICAgICAgICAgIGRidCA9IG1heChkdCk7XG4gICAgICAgICAgICAgICAgbG0gPSBoTWFwKGx0LCBsYnQsIDEpO1xuICAgICAgICAgICAgICAgIGRtID0gaE1hcChkdCwgZGJ0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlcnIoMSk7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBidWZmZXIgY2FuIGhvbGQgdGhpcyArIHRoZSBsYXJnZXN0IHBvc3NpYmxlIGFkZGl0aW9uXG4gICAgICAgIC8vIE1heGltdW0gY2h1bmsgc2l6ZSAocHJhY3RpY2FsbHksIHRoZW9yZXRpY2FsbHkgaW5maW5pdGUpIGlzIDJeMTc7XG4gICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICB2YXIgbG1zID0gKDEgPDwgbGJ0KSAtIDEsIGRtcyA9ICgxIDw8IGRidCkgLSAxO1xuICAgICAgICB2YXIgbHBvcyA9IHBvcztcbiAgICAgICAgZm9yICg7OyBscG9zID0gcG9zKSB7XG4gICAgICAgICAgICAvLyBiaXRzIHJlYWQsIGNvZGVcbiAgICAgICAgICAgIHZhciBjID0gbG1bYml0czE2KGRhdCwgcG9zKSAmIGxtc10sIHN5bSA9IGMgPj4+IDQ7XG4gICAgICAgICAgICBwb3MgKz0gYyAmIDE1O1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIGVycigyKTtcbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgYnVmW2J0KytdID0gc3ltO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICBlcnIoMyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKCgxIDw8IGIpIC0gMSksIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgaWYgKGxtKVxuICAgICAgICAgICAgZmluYWwgPSAxLCBzdC5tID0gbGJ0LCBzdC5kID0gZG0sIHN0Lm4gPSBkYnQ7XG4gICAgfSB3aGlsZSAoIWZpbmFsKTtcbiAgICByZXR1cm4gYnQgPT0gYnVmLmxlbmd0aCA/IGJ1ZiA6IHNsYyhidWYsIDAsIGJ0KTtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzID0gZnVuY3Rpb24gKGQsIHAsIHYpIHtcbiAgICB2IDw8PSBwICYgNztcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+PiA4O1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzICg+OCkgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0czE2ID0gZnVuY3Rpb24gKGQsIHAsIHYpIHtcbiAgICB2IDw8PSBwICYgNztcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+PiA4O1xuICAgIGRbbyArIDJdIHw9IHYgPj4+IDE2O1xufTtcbi8vIGNyZWF0ZXMgY29kZSBsZW5ndGhzIGZyb20gYSBmcmVxdWVuY3kgdGFibGVcbnZhciBoVHJlZSA9IGZ1bmN0aW9uIChkLCBtYikge1xuICAgIC8vIE5lZWQgZXh0cmEgaW5mbyB0byBtYWtlIGEgdHJlZVxuICAgIHZhciB0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChkW2ldKVxuICAgICAgICAgICAgdC5wdXNoKHsgczogaSwgZjogZFtpXSB9KTtcbiAgICB9XG4gICAgdmFyIHMgPSB0Lmxlbmd0aDtcbiAgICB2YXIgdDIgPSB0LnNsaWNlKCk7XG4gICAgaWYgKCFzKVxuICAgICAgICByZXR1cm4gW2V0LCAwXTtcbiAgICBpZiAocyA9PSAxKSB7XG4gICAgICAgIHZhciB2ID0gbmV3IHU4KHRbMF0ucyArIDEpO1xuICAgICAgICB2W3RbMF0uc10gPSAxO1xuICAgICAgICByZXR1cm4gW3YsIDFdO1xuICAgIH1cbiAgICB0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZiAtIGIuZjsgfSk7XG4gICAgLy8gYWZ0ZXIgaTIgcmVhY2hlcyBsYXN0IGluZCwgd2lsbCBiZSBzdG9wcGVkXG4gICAgLy8gZnJlcSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBsYXJnZXN0IHBvc3NpYmxlIG51bWJlciBvZiBzeW1ib2xzXG4gICAgdC5wdXNoKHsgczogLTEsIGY6IDI1MDAxIH0pO1xuICAgIHZhciBsID0gdFswXSwgciA9IHRbMV0sIGkwID0gMCwgaTEgPSAxLCBpMiA9IDI7XG4gICAgdFswXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIC8vIGVmZmljaWVudCBhbGdvcml0aG0gZnJvbSBVWklQLmpzXG4gICAgLy8gaTAgaXMgbG9va2JlaGluZCwgaTIgaXMgbG9va2FoZWFkIC0gYWZ0ZXIgcHJvY2Vzc2luZyB0d28gbG93LWZyZXFcbiAgICAvLyBzeW1ib2xzIHRoYXQgY29tYmluZWQgaGF2ZSBoaWdoIGZyZXEsIHdpbGwgc3RhcnQgcHJvY2Vzc2luZyBpMiAoaGlnaC1mcmVxLFxuICAgIC8vIG5vbi1jb21wb3NpdGUpIHN5bWJvbHMgaW5zdGVhZFxuICAgIC8vIHNlZSBodHRwczovL3JlZGRpdC5jb20vci9waG90b3BlYS9jb21tZW50cy9pa2VraHQvdXppcGpzX3F1ZXN0aW9ucy9cbiAgICB3aGlsZSAoaTEgIT0gcyAtIDEpIHtcbiAgICAgICAgbCA9IHRbdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHIgPSB0W2kwICE9IGkxICYmIHRbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICB0W2kxKytdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgfVxuICAgIHZhciBtYXhTeW0gPSB0MlswXS5zO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgKytpKSB7XG4gICAgICAgIGlmICh0MltpXS5zID4gbWF4U3ltKVxuICAgICAgICAgICAgbWF4U3ltID0gdDJbaV0ucztcbiAgICB9XG4gICAgLy8gY29kZSBsZW5ndGhzXG4gICAgdmFyIHRyID0gbmV3IHUxNihtYXhTeW0gKyAxKTtcbiAgICAvLyBtYXggYml0cyBpbiB0cmVlXG4gICAgdmFyIG1idCA9IGxuKHRbaTEgLSAxXSwgdHIsIDApO1xuICAgIGlmIChtYnQgPiBtYikge1xuICAgICAgICAvLyBtb3JlIGFsZ29yaXRobXMgZnJvbSBVWklQLmpzXG4gICAgICAgIC8vIFRPRE86IGZpbmQgb3V0IGhvdyB0aGlzIGNvZGUgd29ya3MgKGRlYnQpXG4gICAgICAgIC8vICBpbmQgICAgZGVidFxuICAgICAgICB2YXIgaSA9IDAsIGR0ID0gMDtcbiAgICAgICAgLy8gICAgbGVmdCAgICAgICAgICAgIGNvc3RcbiAgICAgICAgdmFyIGxmdCA9IG1idCAtIG1iLCBjc3QgPSAxIDw8IGxmdDtcbiAgICAgICAgdDIuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gdHJbYi5zXSAtIHRyW2Euc10gfHwgYS5mIC0gYi5mOyB9KTtcbiAgICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpMl8xID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8xXSA+IG1iKSB7XG4gICAgICAgICAgICAgICAgZHQgKz0gY3N0IC0gKDEgPDwgKG1idCAtIHRyW2kyXzFdKSk7XG4gICAgICAgICAgICAgICAgdHJbaTJfMV0gPSBtYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkdCA+Pj49IGxmdDtcbiAgICAgICAgd2hpbGUgKGR0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGkyXzIgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzJdIDwgbWIpXG4gICAgICAgICAgICAgICAgZHQgLT0gMSA8PCAobWIgLSB0cltpMl8yXSsrIC0gMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpID49IDAgJiYgZHQ7IC0taSkge1xuICAgICAgICAgICAgdmFyIGkyXzMgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzNdID09IG1iKSB7XG4gICAgICAgICAgICAgICAgLS10cltpMl8zXTtcbiAgICAgICAgICAgICAgICArK2R0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1idCA9IG1iO1xuICAgIH1cbiAgICByZXR1cm4gW25ldyB1OCh0ciksIG1idF07XG59O1xuLy8gZ2V0IHRoZSBtYXggbGVuZ3RoIGFuZCBhc3NpZ24gbGVuZ3RoIGNvZGVzXG52YXIgbG4gPSBmdW5jdGlvbiAobiwgbCwgZCkge1xuICAgIHJldHVybiBuLnMgPT0gLTFcbiAgICAgICAgPyBNYXRoLm1heChsbihuLmwsIGwsIGQgKyAxKSwgbG4obi5yLCBsLCBkICsgMSkpXG4gICAgICAgIDogKGxbbi5zXSA9IGQpO1xufTtcbi8vIGxlbmd0aCBjb2RlcyBnZW5lcmF0aW9uXG52YXIgbGMgPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBzID0gYy5sZW5ndGg7XG4gICAgLy8gTm90ZSB0aGF0IHRoZSBzZW1pY29sb24gd2FzIGludGVudGlvbmFsXG4gICAgd2hpbGUgKHMgJiYgIWNbLS1zXSlcbiAgICAgICAgO1xuICAgIHZhciBjbCA9IG5ldyB1MTYoKytzKTtcbiAgICAvLyAgaW5kICAgICAgbnVtICAgICAgICAgc3RyZWFrXG4gICAgdmFyIGNsaSA9IDAsIGNsbiA9IGNbMF0sIGNscyA9IDE7XG4gICAgdmFyIHcgPSBmdW5jdGlvbiAodikgeyBjbFtjbGkrK10gPSB2OyB9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHM7ICsraSkge1xuICAgICAgICBpZiAoY1tpXSA9PSBjbG4gJiYgaSAhPSBzKVxuICAgICAgICAgICAgKytjbHM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjbG4gJiYgY2xzID4gMikge1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiAxMzg7IGNscyAtPSAxMzgpXG4gICAgICAgICAgICAgICAgICAgIHcoMzI3NTQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHcoY2xzID4gMTAgPyAoKGNscyAtIDExKSA8PCA1KSB8IDI4NjkwIDogKChjbHMgLSAzKSA8PCA1KSB8IDEyMzA1KTtcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbHMgPiAzKSB7XG4gICAgICAgICAgICAgICAgdyhjbG4pLCAtLWNscztcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gNjsgY2xzIC09IDYpXG4gICAgICAgICAgICAgICAgICAgIHcoODMwNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpXG4gICAgICAgICAgICAgICAgICAgIHcoKChjbHMgLSAzKSA8PCA1KSB8IDgyMDgpLCBjbHMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNscy0tKVxuICAgICAgICAgICAgICAgIHcoY2xuKTtcbiAgICAgICAgICAgIGNscyA9IDE7XG4gICAgICAgICAgICBjbG4gPSBjW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbY2wuc3ViYXJyYXkoMCwgY2xpKSwgc107XG59O1xuLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2Ygb3V0cHV0IGZyb20gdHJlZSwgY29kZSBsZW5ndGhzXG52YXIgY2xlbiA9IGZ1bmN0aW9uIChjZiwgY2wpIHtcbiAgICB2YXIgbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbC5sZW5ndGg7ICsraSlcbiAgICAgICAgbCArPSBjZltpXSAqIGNsW2ldO1xuICAgIHJldHVybiBsO1xufTtcbi8vIHdyaXRlcyBhIGZpeGVkIGJsb2NrXG4vLyByZXR1cm5zIHRoZSBuZXcgYml0IHBvc1xudmFyIHdmYmxrID0gZnVuY3Rpb24gKG91dCwgcG9zLCBkYXQpIHtcbiAgICAvLyBubyBuZWVkIHRvIHdyaXRlIDAwIGFzIHR5cGU6IFR5cGVkQXJyYXkgZGVmYXVsdHMgdG8gMFxuICAgIHZhciBzID0gZGF0Lmxlbmd0aDtcbiAgICB2YXIgbyA9IHNoZnQocG9zICsgMik7XG4gICAgb3V0W29dID0gcyAmIDI1NTtcbiAgICBvdXRbbyArIDFdID0gcyA+Pj4gODtcbiAgICBvdXRbbyArIDJdID0gb3V0W29dIF4gMjU1O1xuICAgIG91dFtvICsgM10gPSBvdXRbbyArIDFdIF4gMjU1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgKytpKVxuICAgICAgICBvdXRbbyArIGkgKyA0XSA9IGRhdFtpXTtcbiAgICByZXR1cm4gKG8gKyA0ICsgcykgKiA4O1xufTtcbi8vIHdyaXRlcyBhIGJsb2NrXG52YXIgd2JsayA9IGZ1bmN0aW9uIChkYXQsIG91dCwgZmluYWwsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgYmwsIHApIHtcbiAgICB3Yml0cyhvdXQsIHArKywgZmluYWwpO1xuICAgICsrbGZbMjU2XTtcbiAgICB2YXIgX2EgPSBoVHJlZShsZiwgMTUpLCBkbHQgPSBfYVswXSwgbWxiID0gX2FbMV07XG4gICAgdmFyIF9iID0gaFRyZWUoZGYsIDE1KSwgZGR0ID0gX2JbMF0sIG1kYiA9IF9iWzFdO1xuICAgIHZhciBfYyA9IGxjKGRsdCksIGxjbHQgPSBfY1swXSwgbmxjID0gX2NbMV07XG4gICAgdmFyIF9kID0gbGMoZGR0KSwgbGNkdCA9IF9kWzBdLCBuZGMgPSBfZFsxXTtcbiAgICB2YXIgbGNmcmVxID0gbmV3IHUxNigxOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2x0Lmxlbmd0aDsgKytpKVxuICAgICAgICBsY2ZyZXFbbGNsdFtpXSAmIDMxXSsrO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNkdC5sZW5ndGg7ICsraSlcbiAgICAgICAgbGNmcmVxW2xjZHRbaV0gJiAzMV0rKztcbiAgICB2YXIgX2UgPSBoVHJlZShsY2ZyZXEsIDcpLCBsY3QgPSBfZVswXSwgbWxjYiA9IF9lWzFdO1xuICAgIHZhciBubGNjID0gMTk7XG4gICAgZm9yICg7IG5sY2MgPiA0ICYmICFsY3RbY2xpbVtubGNjIC0gMV1dOyAtLW5sY2MpXG4gICAgICAgIDtcbiAgICB2YXIgZmxlbiA9IChibCArIDUpIDw8IDM7XG4gICAgdmFyIGZ0bGVuID0gY2xlbihsZiwgZmx0KSArIGNsZW4oZGYsIGZkdCkgKyBlYjtcbiAgICB2YXIgZHRsZW4gPSBjbGVuKGxmLCBkbHQpICsgY2xlbihkZiwgZGR0KSArIGViICsgMTQgKyAzICogbmxjYyArIGNsZW4obGNmcmVxLCBsY3QpICsgKDIgKiBsY2ZyZXFbMTZdICsgMyAqIGxjZnJlcVsxN10gKyA3ICogbGNmcmVxWzE4XSk7XG4gICAgaWYgKGZsZW4gPD0gZnRsZW4gJiYgZmxlbiA8PSBkdGxlbilcbiAgICAgICAgcmV0dXJuIHdmYmxrKG91dCwgcCwgZGF0LnN1YmFycmF5KGJzLCBicyArIGJsKSk7XG4gICAgdmFyIGxtLCBsbCwgZG0sIGRsO1xuICAgIHdiaXRzKG91dCwgcCwgMSArIChkdGxlbiA8IGZ0bGVuKSksIHAgKz0gMjtcbiAgICBpZiAoZHRsZW4gPCBmdGxlbikge1xuICAgICAgICBsbSA9IGhNYXAoZGx0LCBtbGIsIDApLCBsbCA9IGRsdCwgZG0gPSBoTWFwKGRkdCwgbWRiLCAwKSwgZGwgPSBkZHQ7XG4gICAgICAgIHZhciBsbG0gPSBoTWFwKGxjdCwgbWxjYiwgMCk7XG4gICAgICAgIHdiaXRzKG91dCwgcCwgbmxjIC0gMjU3KTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgNSwgbmRjIC0gMSk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDEwLCBubGNjIC0gNCk7XG4gICAgICAgIHAgKz0gMTQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmxjYzsgKytpKVxuICAgICAgICAgICAgd2JpdHMob3V0LCBwICsgMyAqIGksIGxjdFtjbGltW2ldXSk7XG4gICAgICAgIHAgKz0gMyAqIG5sY2M7XG4gICAgICAgIHZhciBsY3RzID0gW2xjbHQsIGxjZHRdO1xuICAgICAgICBmb3IgKHZhciBpdCA9IDA7IGl0IDwgMjsgKytpdCkge1xuICAgICAgICAgICAgdmFyIGNsY3QgPSBsY3RzW2l0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjbGN0W2ldICYgMzE7XG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCBsbG1bbGVuXSksIHAgKz0gbGN0W2xlbl07XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDE1KVxuICAgICAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChjbGN0W2ldID4+PiA1KSAmIDEyNyksIHAgKz0gY2xjdFtpXSA+Pj4gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxtID0gZmxtLCBsbCA9IGZsdCwgZG0gPSBmZG0sIGRsID0gZmR0O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpOyArK2kpIHtcbiAgICAgICAgaWYgKHN5bXNbaV0gPiAyNTUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAoc3ltc1tpXSA+Pj4gMTgpICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bbGVuICsgMjU3XSksIHAgKz0gbGxbbGVuICsgMjU3XTtcbiAgICAgICAgICAgIGlmIChsZW4gPiA3KVxuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKHN5bXNbaV0gPj4+IDIzKSAmIDMxKSwgcCArPSBmbGViW2xlbl07XG4gICAgICAgICAgICB2YXIgZHN0ID0gc3ltc1tpXSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGRtW2RzdF0pLCBwICs9IGRsW2RzdF07XG4gICAgICAgICAgICBpZiAoZHN0ID4gMylcbiAgICAgICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgKHN5bXNbaV0gPj4+IDUpICYgODE5MSksIHAgKz0gZmRlYltkc3RdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW3N5bXNbaV1dKSwgcCArPSBsbFtzeW1zW2ldXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3Yml0czE2KG91dCwgcCwgbG1bMjU2XSk7XG4gICAgcmV0dXJuIHAgKyBsbFsyNTZdO1xufTtcbi8vIGRlZmxhdGUgb3B0aW9ucyAobmljZSA8PCAxMykgfCBjaGFpblxudmFyIGRlbyA9IC8qI19fUFVSRV9fKi8gbmV3IHUzMihbNjU1NDAsIDEzMTA4MCwgMTMxMDg4LCAxMzExMDQsIDI2MjE3NiwgMTA0ODcwNCwgMTA0ODgzMiwgMjExNDU2MCwgMjExNzYzMl0pO1xuLy8gZW1wdHlcbnZhciBldCA9IC8qI19fUFVSRV9fKi8gbmV3IHU4KDApO1xuLy8gY29tcHJlc3NlcyBkYXRhIGludG8gYSByYXcgREVGTEFURSBidWZmZXJcbnZhciBkZmx0ID0gZnVuY3Rpb24gKGRhdCwgbHZsLCBwbHZsLCBwcmUsIHBvc3QsIGxzdCkge1xuICAgIHZhciBzID0gZGF0Lmxlbmd0aDtcbiAgICB2YXIgbyA9IG5ldyB1OChwcmUgKyBzICsgNSAqICgxICsgTWF0aC5jZWlsKHMgLyA3MDAwKSkgKyBwb3N0KTtcbiAgICAvLyB3cml0aW5nIHRvIHRoaXMgd3JpdGVzIHRvIHRoZSBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIHcgPSBvLnN1YmFycmF5KHByZSwgby5sZW5ndGggLSBwb3N0KTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBpZiAoIWx2bCB8fCBzIDwgOCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzOyBpICs9IDY1NTM1KSB7XG4gICAgICAgICAgICAvLyBlbmRcbiAgICAgICAgICAgIHZhciBlID0gaSArIDY1NTM1O1xuICAgICAgICAgICAgaWYgKGUgPj0gcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZpbmFsIGJsb2NrXG4gICAgICAgICAgICAgICAgd1twb3MgPj4gM10gPSBsc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MgKyAxLCBkYXQuc3ViYXJyYXkoaSwgZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+Pj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyB1MzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggIGwvbGluZCAgd2FpdGR4ICBiaXRwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSAwLCBsaSA9IDAsIHdpID0gMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVvcHQgd2hlbiBpID4gcyAtIDMgLSBhdCBlbmQsIGRlb3B0IGFjY2VwdGFibGVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIHJlbSA+IDQyMykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IChpbW9kIC0gcGltb2QpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IChpIC0gZGlmICsgaiArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gKHRpIC0gcHRpICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSAoaW1vZCAtIHBpbW9kICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgVWludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgbmVlZGluZyB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICBpZiAoIWxzdCAmJiBwb3MgJiA3KVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIC0zMDY2NzQ5MTIpIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFsZGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aCB8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPSBsOykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oaSArIDI2NTUsIGwpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtICs9IG4gKz0gZFtpXTtcbiAgICAgICAgICAgICAgICBuID0gKG4gJiA2NTUzNSkgKyAxNSAqIChuID4+IDE2KSwgbSA9IChtICYgNjU1MzUpICsgMTUgKiAobSA+PiAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gbiwgYiA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEgJT0gNjU1MjEsIGIgJT0gNjU1MjE7XG4gICAgICAgICAgICByZXR1cm4gKGEgJiAyNTUpIDw8IDI0IHwgKGEgPj4+IDgpIDw8IDE2IHwgKGIgJiAyNTUpIDw8IDggfCAoYiA+Pj4gOCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbjtcbi8vIGRlZmxhdGUgd2l0aCBvcHRzXG52YXIgZG9wdCA9IGZ1bmN0aW9uIChkYXQsIG9wdCwgcHJlLCBwb3N0LCBzdCkge1xuICAgIHJldHVybiBkZmx0KGRhdCwgb3B0LmxldmVsID09IG51bGwgPyA2IDogb3B0LmxldmVsLCBvcHQubWVtID09IG51bGwgPyBNYXRoLmNlaWwoTWF0aC5tYXgoOCwgTWF0aC5taW4oMTMsIE1hdGgubG9nKGRhdC5sZW5ndGgpKSkgKiAxLjUpIDogKDEyICsgb3B0Lm1lbSksIHByZSwgcG9zdCwgIXN0KTtcbn07XG4vLyBXYWxtYXJ0IG9iamVjdCBzcHJlYWRcbnZhciBtcmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgayBpbiBhKVxuICAgICAgICBvW2tdID0gYVtrXTtcbiAgICBmb3IgKHZhciBrIGluIGIpXG4gICAgICAgIG9ba10gPSBiW2tdO1xuICAgIHJldHVybiBvO1xufTtcbi8vIHdvcmtlciBjbG9uZVxuLy8gVGhpcyBpcyBwb3NzaWJseSB0aGUgY3Jhemllc3QgcGFydCBvZiB0aGUgZW50aXJlIGNvZGViYXNlLCBkZXNwaXRlIGhvdyBzaW1wbGUgaXQgbWF5IHNlZW0uXG4vLyBUaGUgb25seSBwYXJhbWV0ZXIgdG8gdGhpcyBmdW5jdGlvbiBpcyBhIGNsb3N1cmUgdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHZhcmlhYmxlcyBvdXRzaWRlIG9mIHRoZSBmdW5jdGlvbiBzY29wZS5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSB0byBmaWd1cmUgb3V0IHRoZSB2YXJpYWJsZSBuYW1lcyB1c2VkIGluIHRoZSBjbG9zdXJlIGFzIHN0cmluZ3MgYmVjYXVzZSB0aGF0IGlzIGNydWNpYWwgZm9yIHdvcmtlcml6YXRpb24uXG4vLyBXZSB3aWxsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBvZiB0cnVlIHZhcmlhYmxlIG5hbWUgdG8gdmFsdWUgKGJhc2ljYWxseSwgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYSBKUyBvYmplY3QpLlxuLy8gVGhlIHJlYXNvbiB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgbmFtZXMgaXMgbWluaWZpZXJzIG1hbmdsaW5nIHRoZSB0b3BsZXZlbCBzY29wZS5cbi8vIFRoaXMgdG9vayBtZSB0aHJlZSB3ZWVrcyB0byBmaWd1cmUgb3V0IGhvdyB0byBkby5cbnZhciB3Y2xuID0gZnVuY3Rpb24gKGZuLCBmblN0ciwgdGQpIHtcbiAgICB2YXIgZHQgPSBmbigpO1xuICAgIHZhciBzdCA9IGZuLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtzID0gc3Quc2xpY2Uoc3QuaW5kZXhPZignWycpICsgMSwgc3QubGFzdEluZGV4T2YoJ10nKSkucmVwbGFjZSgvXFxzKy9nLCAnJykuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2ID0gZHRbaV0sIGsgPSBrc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnPSc7XG4gICAgICAgICAgICB2YXIgc3RfMSA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh2LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBnbG9iYWwgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmIChzdF8xLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BJbmQgPSBzdF8xLmluZGV4T2YoJyAnLCA4KSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzEuc2xpY2Uoc3BJbmQsIHN0XzEuaW5kZXhPZignKCcsIHNwSW5kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHYucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICcucHJvdG90eXBlLicgKyB0ICsgJz0nICsgdi5wcm90b3R5cGVbdF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZFtrXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBbZm5TdHIsIHRkXTtcbn07XG52YXIgY2ggPSBbXTtcbi8vIGNsb25lIGJ1ZnNcbnZhciBjYmZzID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgdGwgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIHYpIHtcbiAgICAgICAgaWYgKHZba10uYnVmZmVyKSB7XG4gICAgICAgICAgICB0bC5wdXNoKCh2W2tdID0gbmV3IHZba10uY29uc3RydWN0b3IodltrXSkpLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBfYSA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSksIGZuU3RyID0gX2FbMF0sIHRkXzEgPSBfYVsxXTtcbiAgICAgICAgY2hbaWRdID0gd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF1bMV0pO1xuICAgIHJldHVybiBub2RlX3dvcmtlcl8xW1wiZGVmYXVsdFwiXShjaFtpZF1bMF0gKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGVjLCBoTWFwLCBtYXgsIGJpdHMsIGJpdHMxNiwgc2hmdCwgc2xjLCBlcnIsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBndThdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHZdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgdThcbnZhciBndTggPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSk7IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTsgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHN0cm0ub25kYXRhKGVycig0LCAwLCAxKSwgbnVsbCwgISFmKTtcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICBlcnIoNiwgJ2ludmFsaWQgZ3ppcCBkYXRhJyk7XG4gICAgdmFyIGZsZyA9IGRbM107XG4gICAgdmFyIHN0ID0gMTA7XG4gICAgaWYgKGZsZyAmIDQpXG4gICAgICAgIHN0ICs9IGRbMTBdIHwgKGRbMTFdIDw8IDgpICsgMjtcbiAgICBmb3IgKHZhciB6cyA9IChmbGcgPj4gMyAmIDEpICsgKGZsZyA+PiA0ICYgMSk7IHpzID4gMDsgenMgLT0gIWRbc3QrK10pXG4gICAgICAgIDtcbiAgICByZXR1cm4gc3QgKyAoZmxnICYgMik7XG59O1xuLy8gZ3ppcCBsZW5ndGhcbnZhciBnemwgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuICgoZFtsIC0gNF0gfCBkW2wgLSAzXSA8PCA4IHwgZFtsIC0gMl0gPDwgMTYpIHwgKGRbbCAtIDFdIDw8IDI0KSkgPj4+IDA7XG59O1xuLy8gZ3ppcCBoZWFkZXIgbGVuZ3RoXG52YXIgZ3pobCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiAxMCArICgoby5maWxlbmFtZSAmJiAoby5maWxlbmFtZS5sZW5ndGggKyAxKSkgfHwgMCk7IH07XG4vLyB6bGliIGhlYWRlclxudmFyIHpsaCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGx2ID0gby5sZXZlbCwgZmwgPSBsdiA9PSAwID8gMCA6IGx2IDwgNiA/IDEgOiBsdiA9PSA5ID8gMyA6IDI7XG4gICAgY1swXSA9IDEyMCwgY1sxXSA9IChmbCA8PCA2KSB8IChmbCA/ICgzMiAtIDIgKiBmbCkgOiAxKTtcbn07XG4vLyB6bGliIHZhbGlkXG52YXIgemx2ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoKGRbMF0gJiAxNSkgIT0gOCB8fCAoZFswXSA+Pj4gNCkgPiA3IHx8ICgoZFswXSA8PCA4IHwgZFsxXSkgJSAzMSkpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCB6bGliIGRhdGEnKTtcbiAgICBpZiAoZFsxXSAmIDMyKVxuICAgICAgICBlcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhOiBwcmVzZXQgZGljdGlvbmFyaWVzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5mdW5jdGlvbiBBc3luY0NtcFN0cm0ob3B0cywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vLyB6bGliIGZvb3RlcjogLTQgdG8gLTAgaXMgQWRsZXIzMlxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsICFmKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICB0aGlzLmQgPSBmaW5hbDtcbiAgICAgICAgdGhpcy5wKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0RlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBEZWZsYXRlKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDYpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNEZWZsYXRlO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNEZWZsYXRlID0gQXN5bmNEZWZsYXRlO1xuZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGRlZmxhdGVTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMCwgY2IpO1xufVxuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggREVGTEFURSB3aXRob3V0IGFueSB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWZsYXRlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gZG9wdChkYXRhLCBvcHRzIHx8IHt9LCAwLCAwKTtcbn1cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBkZWZsYXRlU3luYztcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluZmxhdGlvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBpbmZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5zID0ge307XG4gICAgICAgIHRoaXMucCA9IG5ldyB1OCgwKTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIHZhciBsID0gdGhpcy5wLmxlbmd0aDtcbiAgICAgICAgdmFyIG4gPSBuZXcgdTgobCArIGMubGVuZ3RoKTtcbiAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoYywgbCksIHRoaXMucCA9IG47XG4gICAgfTtcbiAgICBJbmZsYXRlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZCA9IHRoaXMucy5pID0gZmluYWwgfHwgZmFsc2U7XG4gICAgICAgIHZhciBidHMgPSB0aGlzLnMuYjtcbiAgICAgICAgdmFyIGR0ID0gaW5mbHQodGhpcy5wLCB0aGlzLm8sIHRoaXMucyk7XG4gICAgICAgIHRoaXMub25kYXRhKHNsYyhkdCwgYnRzLCB0aGlzLnMuYiksIHRoaXMuZCk7XG4gICAgICAgIHRoaXMubyA9IHNsYyhkdCwgdGhpcy5zLmIgLSAzMjc2OCksIHRoaXMucy5iID0gdGhpcy5vLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wID0gc2xjKHRoaXMucCwgKHRoaXMucy5wIC8gOCkgfCAwKSwgdGhpcy5zLnAgJj0gNztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGluZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgZmluYWwgY2h1bmtcbiAgICAgKi9cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmUoY2h1bmspLCB0aGlzLmMoZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0luZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNyk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0luZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY0luZmxhdGUgPSBBc3luY0luZmxhdGU7XG5mdW5jdGlvbiBpbmZsYXRlKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoaW5mbGF0ZVN5bmMoZXYuZGF0YVswXSwgZ3U4KGV2LmRhdGFbMV0pKSk7IH0sIDEsIGNiKTtcbn1cbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG4vKipcbiAqIEV4cGFuZHMgREVGTEFURSBkYXRhIHdpdGggbm8gd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLCBvdXQpO1xufVxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuLy8gYmVmb3JlIHlvdSB5ZWxsIGF0IG1lIGZvciBub3QganVzdCB1c2luZyBleHRlbmRzLCBteSByZWFzb24gaXMgdGhhdCBUUyBpbmhlcml0YW5jZSBpcyBoYXJkIHRvIHdvcmtlcml6ZS5cbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEd6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3ppcChvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBjcmMoKTtcbiAgICAgICAgdGhpcy5sID0gMDtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1pJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIEd6aXAucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdGhpcy5sICs9IGMubGVuZ3RoO1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiBnemhsKHRoaXMubyksIGYgJiYgOCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgZ3poKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gOCwgdGhpcy5jLmQoKSksIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmwpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgcmV0dXJuIEd6aXA7XG59KCkpO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuQ29tcHJlc3MgPSBHemlwO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0d6aXAob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBnemUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIEd6aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHemlwKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDgpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHemlwO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNHemlwID0gQXN5bmNHemlwO1xuZXhwb3J0cy5Bc3luY0NvbXByZXNzID0gQXN5bmNHemlwO1xuZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICBnemUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihnemlwU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDIsIGNiKTtcbn1cbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5leHBvcnRzLmNvbXByZXNzID0gZ3ppcDtcbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggR1pJUFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ3ppcHBlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGd6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYyA9IGNyYygpLCBsID0gZGF0YS5sZW5ndGg7XG4gICAgYy5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBnemhsKG9wdHMpLCA4KSwgcyA9IGQubGVuZ3RoO1xuICAgIHJldHVybiBnemgoZCwgb3B0cyksIHdieXRlcyhkLCBzIC0gOCwgYy5kKCkpLCB3Ynl0ZXMoZCwgcyAtIDQsIGwpLCBkO1xufVxuZXhwb3J0cy5nemlwU3luYyA9IGd6aXBTeW5jO1xuZXhwb3J0cy5jb21wcmVzc1N5bmMgPSBnemlwU3luYztcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBHVU5aSVAgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHdW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1VOWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd1bnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnAubGVuZ3RoID4gMyA/IGd6cyh0aGlzLnApIDogNDtcbiAgICAgICAgICAgIGlmIChzID49IHRoaXMucC5sZW5ndGggJiYgIWZpbmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheShzKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgOClcbiAgICAgICAgICAgICAgICBlcnIoNiwgJ2ludmFsaWQgZ3ppcCBkYXRhJyk7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMCwgLTgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFRTIGZyb20gdXNpbmcgdGhlIGNsb3N1cmUgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHdvcmtlcml6YXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmMuY2FsbCh0aGlzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gR3VuemlwO1xufSgpKTtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNHdW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZ3V6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgR3VuemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHdW56aXAoKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA5KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jR3VuemlwO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNHdW56aXAgPSBBc3luY0d1bnppcDtcbmZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgZ3V6ZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d1bnppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3VuemlwU3luYyhldi5kYXRhWzBdKSk7IH0sIDMsIGNiKTtcbn1cbmV4cG9ydHMuZ3VuemlwID0gZ3VuemlwO1xuLyoqXG4gKiBFeHBhbmRzIEdaSVAgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gR1pJUCBhbHJlYWR5IGVuY29kZXMgdGhlIG91dHB1dCBzaXplLCBzbyBwcm92aWRpbmcgdGhpcyBkb2Vzbid0IHNhdmUgbWVtb3J5LlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoZ3pzKGRhdGEpLCAtOCksIG91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSk7XG59XG5leHBvcnRzLmd1bnppcFN5bmMgPSBndW56aXBTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGFkbGVyKCk7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBabGliLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5jLnAoYyk7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIDIsIGYgJiYgNCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgemxoKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gNCwgdGhpcy5jLmQoKSk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gWmxpYjtcbn0oKSk7XG5leHBvcnRzLlpsaWIgPSBabGliO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY1psaWIob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICB6bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIFpsaWJdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBabGliKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jWmxpYjtcbn0oKSk7XG5leHBvcnRzLkFzeW5jWmxpYiA9IEFzeW5jWmxpYjtcbmZ1bmN0aW9uIHpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgemxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoemxpYlN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCA0LCBjYik7XG59XG5leHBvcnRzLnpsaWIgPSB6bGliO1xuLyoqXG4gKiBDb21wcmVzcyBkYXRhIHdpdGggWmxpYlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgemxpYi1jb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gemxpYlN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbmV4cG9ydHMuemxpYlN5bmMgPSB6bGliU3luYztcbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCAyICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMiksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgZXJyKDYsICdpbnZhbGlkIHpsaWIgZGF0YScpO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnRzLlVuemxpYiA9IFVuemxpYjtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgVW56bGliKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1VuemxpYiA9IEFzeW5jVW56bGliO1xuZnVuY3Rpb24gdW56bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG5leHBvcnRzLnVuemxpYiA9IHVuemxpYjtcbi8qKlxuICogRXhwYW5kcyBabGliIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdCgoemx2KGRhdGEpLCBkYXRhLnN1YmFycmF5KDIsIC00KSksIG91dCk7XG59XG5leHBvcnRzLnVuemxpYlN5bmMgPSB1bnpsaWJTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEd1bnppcDtcbiAgICAgICAgdGhpcy5JID0gSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKCF0aGlzLnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBjaHVuaztcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7IF90aGlzXzEub25kYXRhLmFwcGx5KF90aGlzXzEsIGFyZ3VtZW50cyk7IH07XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gKHRoaXMucFswXSA9PSAzMSAmJiB0aGlzLnBbMV0gPT0gMTM5ICYmIHRoaXMucFsyXSA9PSA4KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkcoY2IpXG4gICAgICAgICAgICAgICAgICAgIDogKCh0aGlzLnBbMF0gJiAxNSkgIT0gOCB8fCAodGhpcy5wWzBdID4+IDQpID4gNyB8fCAoKHRoaXMucFswXSA8PCA4IHwgdGhpcy5wWzFdKSAlIDMxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuSShjYilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRoaXMuWihjYik7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnB1c2godGhpcy5wLCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnMucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0cy5EZWNvbXByZXNzID0gRGVjb21wcmVzcztcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlY29tcHJlc3NlZFxuICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0RlY29tcHJlc3MoY2IpIHtcbiAgICAgICAgdGhpcy5HID0gQXN5bmNHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEFzeW5jSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gQXN5bmNVbnpsaWI7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY0RlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnRzLkFzeW5jRGVjb21wcmVzcyA9IEFzeW5jRGVjb21wcmVzcztcbmZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbmV4cG9ydHMuZGVjb21wcmVzcyA9IGRlY29tcHJlc3M7XG4vKipcbiAqIEV4cGFuZHMgY29tcHJlc3NlZCBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkYXRhLCBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZm9ybWF0XG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXBTeW5jKGRhdGEsIG91dClcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG91dCk7XG59XG5leHBvcnRzLmRlY29tcHJlc3NTeW5jID0gZGVjb21wcmVzc1N5bmM7XG4vLyBmbGF0dGVuIGEgZGlyZWN0b3J5IHN0cnVjdHVyZVxudmFyIGZsdG4gPSBmdW5jdGlvbiAoZCwgcCwgdCwgbykge1xuICAgIGZvciAodmFyIGsgaW4gZCkge1xuICAgICAgICB2YXIgdmFsID0gZFtrXSwgbiA9IHAgKyBrLCBvcCA9IG87XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICBvcCA9IG1yZyhvLCB2YWxbMV0pLCB2YWwgPSB2YWxbMF07XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiB1OClcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsLCBvcF07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdFtuICs9ICcvJ10gPSBbbmV3IHU4KDApLCBvcF07XG4gICAgICAgICAgICBmbHRuKHZhbCwgbiwgdCwgbyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gdGV4dCBlbmNvZGVyXG52YXIgdGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuLy8gZGVjb2RlIFVURjhcbnZhciBkdXRmOCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgZm9yICh2YXIgciA9ICcnLCBpID0gMDs7KSB7XG4gICAgICAgIHZhciBjID0gZFtpKytdO1xuICAgICAgICB2YXIgZWIgPSAoYyA+IDEyNykgKyAoYyA+IDIyMykgKyAoYyA+IDIzOSk7XG4gICAgICAgIGlmIChpICsgZWIgPiBkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbciwgc2xjKGQsIGkgLSAxKV07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGZpbmFsID0gISFmaW5hbDtcbiAgICAgICAgaWYgKHRoaXMudCkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSksIGZpbmFsKTtcbiAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnQuZGVjb2RlKCkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdmFyIGRhdCA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgZGF0LnNldCh0aGlzLnApO1xuICAgICAgICBkYXQuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgY2ggPSBfYVswXSwgbnAgPSBfYVsxXTtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAobnAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVycig4KTtcbiAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wID0gbnA7XG4gICAgICAgIHRoaXMub25kYXRhKGNoLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb2RlVVRGODtcbn0oKSk7XG5leHBvcnRzLkRlY29kZVVURjggPSBEZWNvZGVVVEY4O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydHMuRW5jb2RlVVRGOCA9IEVuY29kZVVURjg7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5mdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuZXhwb3J0cy5zdHJUb1U4ID0gc3RyVG9VODtcbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gZGF0IFRoZSBkYXRhIHRvIGRlY29kZSB0byBzdHJpbmdcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGVuY29kaW5nIHRvIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVVRGLTgvTGF0aW4tMSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpXG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgb3V0ID0gX2FbMF0sIGV4dCA9IF9hWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIGVycig4KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG5leHBvcnRzLnN0ckZyb21VOCA9IHN0ckZyb21VODtcbjtcbi8vIGRlZmxhdGUgYml0IGZsYWdcbnZhciBkYmYgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbCA9PSAxID8gMyA6IGwgPCA2ID8gMiA6IGwgPT0gOSA/IDEgOiAwOyB9O1xuLy8gc2tpcCBsb2NhbCB6aXAgaGVhZGVyXG52YXIgc2x6aCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiICsgMzAgKyBiMihkLCBiICsgMjYpICsgYjIoZCwgYiArIDI4KTsgfTtcbi8vIHJlYWQgemlwIGhlYWRlclxudmFyIHpoID0gZnVuY3Rpb24gKGQsIGIsIHopIHtcbiAgICB2YXIgZm5sID0gYjIoZCwgYiArIDI4KSwgZm4gPSBzdHJGcm9tVTgoZC5zdWJhcnJheShiICsgNDYsIGIgKyA0NiArIGZubCksICEoYjIoZCwgYiArIDgpICYgMjA0OCkpLCBlcyA9IGIgKyA0NiArIGZubCwgYnMgPSBiNChkLCBiICsgMjApO1xuICAgIHZhciBfYSA9IHogJiYgYnMgPT0gNDI5NDk2NzI5NSA/IHo2NGUoZCwgZXMpIDogW2JzLCBiNChkLCBiICsgMjQpLCBiNChkLCBiICsgNDIpXSwgc2MgPSBfYVswXSwgc3UgPSBfYVsxXSwgb2ZmID0gX2FbMl07XG4gICAgcmV0dXJuIFtiMihkLCBiICsgMTApLCBzYywgc3UsIGZuLCBlcyArIGIyKGQsIGIgKyAzMCkgKyBiMihkLCBiICsgMzIpLCBvZmZdO1xufTtcbi8vIHJlYWQgemlwNjQgZXh0cmEgZmllbGRcbnZhciB6NjRlID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKDsgYjIoZCwgYikgIT0gMTsgYiArPSA0ICsgYjIoZCwgYiArIDIpKVxuICAgICAgICA7XG4gICAgcmV0dXJuIFtiOChkLCBiICsgMTIpLCBiOChkLCBiICsgNCksIGI4KGQsIGIgKyAyMCldO1xufTtcbi8vIGV4dHJhIGZpZWxkIGxlbmd0aFxudmFyIGV4ZmwgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgbGUgPSAwO1xuICAgIGlmIChleCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGV4W2tdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgZXJyKDkpO1xuICAgICAgICAgICAgbGUgKz0gbCArIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlO1xufTtcbi8vIHdyaXRlIHppcCBoZWFkZXJcbnZhciB3emggPSBmdW5jdGlvbiAoZCwgYiwgZiwgZm4sIHUsIGMsIGNlLCBjbykge1xuICAgIHZhciBmbCA9IGZuLmxlbmd0aCwgZXggPSBmLmV4dHJhLCBjb2wgPSBjbyAmJiBjby5sZW5ndGg7XG4gICAgdmFyIGV4bCA9IGV4ZmwoZXgpO1xuICAgIHdieXRlcyhkLCBiLCBjZSAhPSBudWxsID8gMHgyMDE0QjUwIDogMHg0MDM0QjUwKSwgYiArPSA0O1xuICAgIGlmIChjZSAhPSBudWxsKVxuICAgICAgICBkW2IrK10gPSAyMCwgZFtiKytdID0gZi5vcztcbiAgICBkW2JdID0gMjAsIGIgKz0gMjsgLy8gc3BlYyBjb21wbGlhbmNlPyB3aGF0J3MgdGhhdD9cbiAgICBkW2IrK10gPSAoZi5mbGFnIDw8IDEpIHwgKGMgPCAwICYmIDgpLCBkW2IrK10gPSB1ICYmIDg7XG4gICAgZFtiKytdID0gZi5jb21wcmVzc2lvbiAmIDI1NSwgZFtiKytdID0gZi5jb21wcmVzc2lvbiA+PiA4O1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKGYubXRpbWUgPT0gbnVsbCA/IERhdGUubm93KCkgOiBmLm10aW1lKSwgeSA9IGR0LmdldEZ1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGlmICh5IDwgMCB8fCB5ID4gMTE5KVxuICAgICAgICBlcnIoMTApO1xuICAgIHdieXRlcyhkLCBiLCAoeSA8PCAyNSkgfCAoKGR0LmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAoZHQuZ2V0RGF0ZSgpIDw8IDE2KSB8IChkdC5nZXRIb3VycygpIDw8IDExKSB8IChkdC5nZXRNaW51dGVzKCkgPDwgNSkgfCAoZHQuZ2V0U2Vjb25kcygpID4+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSAtMSkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgZi5jcmMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDQsIGMgPCAwID8gLWMgLSAyIDogYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICB0aGlzLmMucChjaHVuayk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbClcbiAgICAgICAgICAgIHRoaXMuY3JjID0gdGhpcy5jLmQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0cy5aaXBQYXNzVGhyb3VnaCA9IFppcFBhc3NUaHJvdWdoO1xuLy8gSSBkb24ndCBleHRlbmQgYmVjYXVzZSBUeXBlU2NyaXB0IGV4dGVuc2lvbiBhZGRzIDFrQiBvZiBydW50aW1lIGJsb2F0XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciB1c2luZyBBc3luY1ppcERlZmxhdGVcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xudmFyIFppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgfVxuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydHMuWmlwRGVmbGF0ZSA9IFppcERlZmxhdGU7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1ppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IEFzeW5jRGVmbGF0ZShvcHRzLCBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmQudGVybWluYXRlO1xuICAgIH1cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1ppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1ppcERlZmxhdGUgPSBBc3luY1ppcERlZmxhdGU7XG4vLyBUT0RPOiBCZXR0ZXIgdHJlZSBzaGFraW5nXG4vKipcbiAqIEEgemlwcGFibGUgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gaW5jcmVtZW50YWxseSBiZSBhZGRlZFxuICovXG52YXIgWmlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgWklQIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgZm9yIHRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAgICAgKiAgICAgICAgICAgaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMudSA9IFtdO1xuICAgICAgICB0aGlzLmQgPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZmlsZSB0byB0aGUgWklQIGFyY2hpdmVcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSBzdHJlYW0gdG8gYWRkXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIC8vIGZpbmlzaGluZyBvciBmaW5pc2hlZFxuICAgICAgICBpZiAodGhpcy5kICYgMilcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGVycig0ICsgKHRoaXMuZCAmIDEpICogOCwgMCwgMSksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IHN0clRvVTgoZmlsZS5maWxlbmFtZSksIGZsXzEgPSBmLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb20gPSBmaWxlLmNvbW1lbnQsIG8gPSBjb20gJiYgc3RyVG9VOChjb20pO1xuICAgICAgICAgICAgdmFyIHUgPSBmbF8xICE9IGZpbGUuZmlsZW5hbWUubGVuZ3RoIHx8IChvICYmIChjb20ubGVuZ3RoICE9IG8ubGVuZ3RoKSk7XG4gICAgICAgICAgICB2YXIgaGxfMSA9IGZsXzEgKyBleGZsKGZpbGUuZXh0cmEpICsgMzA7XG4gICAgICAgICAgICBpZiAoZmxfMSA+IDY1NTM1KVxuICAgICAgICAgICAgICAgIHRoaXMub25kYXRhKGVycigxMSwgMCwgMSksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBuZXcgdTgoaGxfMSk7XG4gICAgICAgICAgICB3emgoaGVhZGVyLCAwLCBmaWxlLCBmLCB1LCAtMSk7XG4gICAgICAgICAgICB2YXIgY2hrc18xID0gW2hlYWRlcl07XG4gICAgICAgICAgICB2YXIgcEFsbF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hrc18yID0gY2hrc18xOyBfaSA8IGNoa3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoayA9IGNoa3NfMltfaV07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGtzXzEgPSBbXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHJfMSA9IHRoaXMuZDtcbiAgICAgICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgICAgICB2YXIgaW5kXzEgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHVmXzEgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICAgICAgdTogdSxcbiAgICAgICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcEFsbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXNfMS51W2luZF8xICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54dC5yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cl8xID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjbF8xID0gMDtcbiAgICAgICAgICAgIGZpbGUub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsXzEgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2hrc18xLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGQgPSBuZXcgdTgoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA0LCBmaWxlLmNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDgsIGNsXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAxMiwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoa3NfMS5wdXNoKGRkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEuYyA9IGNsXzEsIHVmXzEuYiA9IGhsXzEgKyBjbF8xICsgMTYsIHVmXzEuY3JjID0gZmlsZS5jcmMsIHVmXzEuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cl8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEucigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJfMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBBbGxfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnUucHVzaCh1Zl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgZmlsZXMgYW5kIHByZXBhcmVzIHRvIGVtaXQgdGhlIGZpbmFsIGNodW5rcy5cbiAgICAgKiBUaGlzICptdXN0KiBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGFsbCBkZXNpcmVkIGZpbGVzIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgICogWklQIGZpbGUgdG8gd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMikge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZXJyKDQgKyAodGhpcy5kICYgMSkgKiA4LCAwLCAxKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRoaXMuZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnUucHVzaCh7XG4gICAgICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfdGhpc18xLmQgJiAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS51LnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kID0gMztcbiAgICB9O1xuICAgIFppcC5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ0ID0gMCwgbCA9IDAsIHRsID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgdGwgKz0gNDYgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKSArIChmLm8gPyBmLm8ubGVuZ3RoIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IG5ldyB1OCh0bCArIDIyKTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMudTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2NbX2JdO1xuICAgICAgICAgICAgd3poKG91dCwgYnQsIGYsIGYuZiwgZi51LCAtZi5jIC0gMiwgbCwgZi5vKTtcbiAgICAgICAgICAgIGJ0ICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApLCBsICs9IGYuYjtcbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBidCwgdGhpcy51Lmxlbmd0aCwgdGwsIGwpO1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBvdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gdGVybWluYXRlIGFueSBpbnRlcm5hbCB3b3JrZXJzIHVzZWQgYnkgdGhlIHN0cmVhbS4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIGFkZCgpIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgZi50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIHJldHVybiBaaXA7XG59KCkpO1xuZXhwb3J0cy5aaXAgPSBaaXA7XG5mdW5jdGlvbiB6aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICB2YXIgciA9IHt9O1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBrID0gT2JqZWN0LmtleXMocik7XG4gICAgdmFyIGxmdCA9IGsubGVuZ3RoLCBvID0gMCwgdG90ID0gMDtcbiAgICB2YXIgc2xmdCA9IGxmdCwgZmlsZXMgPSBuZXcgQXJyYXkobGZ0KTtcbiAgICB2YXIgdGVybSA9IFtdO1xuICAgIHZhciB0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0ZXJtW2ldKCk7XG4gICAgfTtcbiAgICB2YXIgY2JkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgbXQoZnVuY3Rpb24gKCkgeyBjYihhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBtdChmdW5jdGlvbiAoKSB7IGNiZCA9IGNiOyB9KTtcbiAgICB2YXIgY2JmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgICAgICB0b3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBmLmMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIHRvdCwgZiwgZi5mLCBmLnUsIGwpO1xuICAgICAgICAgICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gdG90ICsgYmFkZDtcbiAgICAgICAgICAgICAgICBvdXQuc2V0KGYuYywgbG9jKTtcbiAgICAgICAgICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgbCwgdG90LCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCksIHRvdCA9IGxvYyArIGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYmQoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICAgICAgY2JkKG51bGwsIG91dCk7XG4gICAgfTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2JmKCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZm4gPSBrW2ldO1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjID0gY3JjKCksIHNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYmQoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZpbGVzW2ldID0gbXJnKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JjOiBjLmQoKSxcbiAgICAgICAgICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgICAgICAgICAgbTogbSxcbiAgICAgICAgICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbyArPSAzMCArIHMgKyBleGwgKyBsO1xuICAgICAgICAgICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAocyA+IDY1NTM1KVxuICAgICAgICAgICAgY2JsKGVycigxMSwgMCwgMSksIG51bGwpO1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9uKVxuICAgICAgICAgICAgY2JsKG51bGwsIGZpbGUpO1xuICAgICAgICBlbHNlIGlmIChzaXplIDwgMTYwMDAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNibChudWxsLCBkZWZsYXRlU3luYyhmaWxlLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNibChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXJtLnB1c2goZGVmbGF0ZShmaWxlLCBwLCBjYmwpKTtcbiAgICB9O1xuICAgIC8vIENhbm5vdCB1c2UgbGZ0IGJlY2F1c2UgaXQgY2FuIGRlY3JlYXNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGZ0OyArK2kpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRBbGw7XG59XG5leHBvcnRzLnppcCA9IHppcDtcbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZnVuY3Rpb24gemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIHIgPSB7fTtcbiAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICBmbHRuKGRhdGEsICcnLCByLCBvcHRzKTtcbiAgICB2YXIgbyA9IDA7XG4gICAgdmFyIHRvdCA9IDA7XG4gICAgZm9yICh2YXIgZm4gaW4gcikge1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHAubGV2ZWwgPT0gMCA/IDAgOiA4O1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICBpZiAocyA+IDY1NTM1KVxuICAgICAgICAgICAgZXJyKDExKTtcbiAgICAgICAgdmFyIGQgPSBjb21wcmVzc2lvbiA/IGRlZmxhdGVTeW5jKGZpbGUsIHApIDogZmlsZSwgbCA9IGQubGVuZ3RoO1xuICAgICAgICB2YXIgYyA9IGNyYygpO1xuICAgICAgICBjLnAoZmlsZSk7XG4gICAgICAgIGZpbGVzLnB1c2gobXJnKHAsIHtcbiAgICAgICAgICAgIHNpemU6IGZpbGUubGVuZ3RoLFxuICAgICAgICAgICAgY3JjOiBjLmQoKSxcbiAgICAgICAgICAgIGM6IGQsXG4gICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgbTogbSxcbiAgICAgICAgICAgIHU6IHMgIT0gZm4ubGVuZ3RoIHx8IChtICYmIChjb20ubGVuZ3RoICE9IG1zKSksXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uXG4gICAgICAgIH0pKTtcbiAgICAgICAgbyArPSAzMCArIHMgKyBleGwgKyBsO1xuICAgICAgICB0b3QgKz0gNzYgKyAyICogKHMgKyBleGwpICsgKG1zIHx8IDApICsgbDtcbiAgICB9XG4gICAgdmFyIG91dCA9IG5ldyB1OCh0b3QgKyAyMiksIG9lID0gbywgY2RsID0gdG90IC0gbztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmID0gZmlsZXNbaV07XG4gICAgICAgIHd6aChvdXQsIGYubywgZiwgZi5mLCBmLnUsIGYuYy5sZW5ndGgpO1xuICAgICAgICB2YXIgYmFkZCA9IDMwICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSk7XG4gICAgICAgIG91dC5zZXQoZi5jLCBmLm8gKyBiYWRkKTtcbiAgICAgICAgd3poKG91dCwgbywgZiwgZi5mLCBmLnUsIGYuYy5sZW5ndGgsIGYubywgZi5tKSwgbyArPSAxNiArIGJhZGQgKyAoZi5tID8gZi5tLmxlbmd0aCA6IDApO1xuICAgIH1cbiAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnppcFN5bmMgPSB6aXBTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydHMuVW56aXBQYXNzVGhyb3VnaCA9IFVuemlwUGFzc1Rocm91Z2g7XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIEFzeW5jWmlwSW5mbGF0ZSBmb3JcbiAqIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqL1xudmFyIFVuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56aXBJbmZsYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIFVuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnRzLlVuemlwSW5mbGF0ZSA9IFVuemlwSW5mbGF0ZTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56aXBJbmZsYXRlKF8sIHN6KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHN6IDwgMzIwMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgSW5mbGF0ZShmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgQXN5bmNJbmZsYXRlKGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuaS50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXN5bmNVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaS50ZXJtaW5hdGUpXG4gICAgICAgICAgICBkYXRhID0gc2xjKGRhdGEsIDApO1xuICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBBc3luY1VuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIEFzeW5jVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNVbnppcEluZmxhdGUgPSBBc3luY1VuemlwSW5mbGF0ZTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY18xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLm9uZGF0YShudWxsLCBldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0ciA9IF90aGlzXzEub1tjbXBfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEub25kYXRhKGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzEsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzQgPSBjaGtzXzM7IF9pIDwgY2hrc180Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzRbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzXzEua1swXSA9PSBjaGtzXzMgJiYgX3RoaXNfMS5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICBlcnIoMTMpO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZGVjb2RlciB3aXRoIHRoZSBzdHJlYW0sIGFsbG93aW5nIGZvciBmaWxlcyBjb21wcmVzc2VkIHdpdGhcbiAgICAgKiB0aGUgY29tcHJlc3Npb24gdHlwZSBwcm92aWRlZCB0byBiZSBleHBhbmRlZCBjb3JyZWN0bHlcbiAgICAgKiBAcGFyYW0gZGVjb2RlciBUaGUgZGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWNvZGVyKSB7XG4gICAgICAgIHRoaXMub1tkZWNvZGVyLmNvbXByZXNzaW9uXSA9IGRlY29kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gVW56aXA7XG59KCkpO1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xudmFyIG10ID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IHR5cGVvZiBzZXRUaW1lb3V0ID09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogZnVuY3Rpb24gKGZuKSB7IGZuKCk7IH07XG5mdW5jdGlvbiB1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBjYmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBtdChmdW5jdGlvbiAoKSB7IGNiKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIG10KGZ1bmN0aW9uICgpIHsgY2JkID0gY2I7IH0pO1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYmQoZXJyKDEzLCAwLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdEFsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgdmFyIGxmdCA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAobGZ0KSB7XG4gICAgICAgIHZhciBjID0gbGZ0O1xuICAgICAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1IHx8IGMgPT0gNjU1MzU7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICB2YXIgemUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICAgICAgeiA9IGI0KGRhdGEsIHplKSA9PSAweDYwNjRCNTA7XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCB6ZSArIDMyKTtcbiAgICAgICAgICAgICAgICBvID0gYjQoZGF0YSwgemUgKyA0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsdHIgPSBvcHRzICYmIG9wdHMuZmlsdGVyO1xuICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICAgICAgbyA9IG5vO1xuICAgICAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICBjYmQoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYmQobnVsbCwgZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZsdHIgfHwgZmx0cih7XG4gICAgICAgICAgICAgICAgbmFtZTogZm4sXG4gICAgICAgICAgICAgICAgc2l6ZTogc2MsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTaXplOiBzdSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY18xXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGlmICghY18xKVxuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNfMSA9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsID0gZGF0YS5zdWJhcnJheShiLCBiICsgc2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2MgPCAzMjAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKG51bGwsIGluZmxhdGVTeW5jKGluZmwsIG5ldyB1OChzdSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2JsKGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18xLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMyhpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGNiZChudWxsLCB7fSk7XG4gICAgcmV0dXJuIHRBbGw7XG59XG5leHBvcnRzLnVuemlwID0gdW56aXA7XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmUuIFByZWZlciB1c2luZyBgdW56aXBgIGZvciBiZXR0ZXJcbiAqIHBlcmZvcm1hbmNlIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gb3B0cyBUaGUgWklQIGV4dHJhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICovXG5mdW5jdGlvbiB1bnppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KVxuICAgICAgICAgICAgZXJyKDEzKTtcbiAgICB9XG4gICAgO1xuICAgIHZhciBjID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghYylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICB2YXIgeiA9IG8gPT0gNDI5NDk2NzI5NSB8fCBjID09IDY1NTM1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIHZhciB6ZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIHogPSBiNChkYXRhLCB6ZSkgPT0gMHg2MDY0QjUwO1xuICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgYyA9IGI0KGRhdGEsIHplICsgMzIpO1xuICAgICAgICAgICAgbyA9IGI0KGRhdGEsIHplICsgNDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmbHRyID0gb3B0cyAmJiBvcHRzLmZpbHRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18yID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIGlmICghZmx0ciB8fCBmbHRyKHtcbiAgICAgICAgICAgIG5hbWU6IGZuLFxuICAgICAgICAgICAgc2l6ZTogc2MsXG4gICAgICAgICAgICBvcmlnaW5hbFNpemU6IHN1LFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGNfMlxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKCFjXzIpXG4gICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gc2xjKGRhdGEsIGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBpbmZsYXRlU3luYyhkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyksIG5ldyB1OChzdSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZXM7XG59XG5leHBvcnRzLnVuemlwU3luYyA9IHVuemlwU3luYztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/index.cjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/worker.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/wasi-js/node_modules/fflate/lib/worker.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar ch2 = {};\nexports[\"default\"] = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93YXNpLWpzL25vZGVfbW9kdWxlcy9mZmxhdGUvbGliL3dvcmtlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGNBQWMscUNBQXFDLFVBQVUsYUFBYSwrQkFBK0IsRUFBRTtBQUMzRyxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFx3YXNpLWpzXFxub2RlX21vZHVsZXNcXGZmbGF0ZVxcbGliXFx3b3JrZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNoMiA9IHt9O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKGMsIGlkLCBtc2csIHRyYW5zZmVyLCBjYikge1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihjaDJbaWRdIHx8IChjaDJbaWRdID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXG4gICAgICAgIGMgKyAnO2FkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGUpe2U9ZS5lcnJvcjtwb3N0TWVzc2FnZSh7JGUkOltlLm1lc3NhZ2UsZS5jb2RlLGUuc3RhY2tdfSl9KSdcbiAgICBdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pKSkpO1xuICAgIHcub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGQgPSBlLmRhdGEsIGVkID0gZC4kZSQ7XG4gICAgICAgIGlmIChlZCkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihlZFswXSk7XG4gICAgICAgICAgICBlcnJbJ2NvZGUnXSA9IGVkWzFdO1xuICAgICAgICAgICAgZXJyLnN0YWNrID0gZWRbMl07XG4gICAgICAgICAgICBjYihlcnIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNiKG51bGwsIGQpO1xuICAgIH07XG4gICAgdy5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICByZXR1cm4gdztcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/wasi-js/node_modules/fflate/lib/worker.cjs\n"));

/***/ })

}]);