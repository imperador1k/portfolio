"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_components_apps_Messenger_index_tsx"],{

/***/ "(pages-dir-browser)/./components/apps/Messenger/ChatLog.tsx":
/*!***********************************************!*\
  !*** ./components/apps/Messenger/ChatLog.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var components_apps_Messenger_ChatProfile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/ChatProfile */ \"(pages-dir-browser)/./components/apps/Messenger/ChatProfile.tsx\");\n/* harmony import */ var components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/Icons */ \"(pages-dir-browser)/./components/apps/Messenger/Icons.tsx\");\n/* harmony import */ var components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/apps/Messenger/MessageContext */ \"(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledChatLog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/apps/Messenger/StyledChatLog */ \"(pages-dir-browser)/./components/apps/Messenger/StyledChatLog.ts\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\nconst SanitizedContent = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_apps_Messenger_SanitizedContent_tsx\", \"high\").then(__webpack_require__.bind(__webpack_require__, /*! components/apps/Messenger/SanitizedContent */ \"(pages-dir-browser)/./components/apps/Messenger/SanitizedContent.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"components\\\\apps\\\\Messenger\\\\ChatLog.tsx -> \" + \"components/apps/Messenger/SanitizedContent\"\n        ]\n    }\n});\n_c = SanitizedContent;\nconst ChatLog = ({ recipientPublicKey })=>{\n    _s();\n    const { publicKey } = (0,components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_5__.useMessageContext)();\n    const { allEventsReceived, messages } = (0,components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_5__.useMessages)(recipientPublicKey);\n    const [decryptedContent, setDecryptedContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const decryptMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatLog.useCallback[decryptMessages]\": ()=>[\n                ...messages\n            ].reverse().forEach({\n                \"ChatLog.useCallback[decryptMessages]\": ([, eventGroup])=>[\n                        ...eventGroup\n                    ].reverse().forEach({\n                        \"ChatLog.useCallback[decryptMessages]\": ({ content, id })=>(0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.decryptMessage)(id, content, recipientPublicKey).then({\n                                \"ChatLog.useCallback[decryptMessages]\": (message)=>setDecryptedContent({\n                                        \"ChatLog.useCallback[decryptMessages]\": (currentDecryptedContent)=>({\n                                                ...currentDecryptedContent,\n                                                [id]: message || false\n                                            })\n                                    }[\"ChatLog.useCallback[decryptMessages]\"])\n                            }[\"ChatLog.useCallback[decryptMessages]\"])\n                    }[\"ChatLog.useCallback[decryptMessages]\"])\n            }[\"ChatLog.useCallback[decryptMessages]\"])\n    }[\"ChatLog.useCallback[decryptMessages]\"], [\n        messages,\n        recipientPublicKey\n    ]);\n    const listRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isUnknownKey = recipientPublicKey === components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_7__.UNKNOWN_PUBLIC_KEY;\n    const { picture, userName } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__.useNostrProfile)(isUnknownKey ? \"\" : recipientPublicKey);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatLog.useEffect\": ()=>{\n            if (messages) {\n                decryptMessages();\n                listRef.current?.scrollTo(0, listRef.current.scrollHeight);\n            }\n        }\n    }[\"ChatLog.useEffect\"], [\n        decryptMessages,\n        messages\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledChatLog__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n        ref: listRef,\n        children: !isUnknownKey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_ChatProfile__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                    publicKey: recipientPublicKey\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                    lineNumber: 66,\n                    columnNumber: 11\n                }, undefined),\n                messages.map(([timestamp, eventGroup], gropupIndex)=>eventGroup.map(({ created_at, id, pubkey, content }, messageIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: (0,utils_functions__WEBPACK_IMPORTED_MODULE_10__.clsx)({\n                                \"cant-decrypt\": decryptedContent[id] === false,\n                                received: publicKey !== pubkey,\n                                sent: publicKey === pubkey\n                            }),\n                            \"data-timestamp\": messageIndex === 0 ? timestamp : undefined,\n                            title: (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.prettyChatTimestamp)(created_at),\n                            children: [\n                                publicKey !== pubkey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"avatar\",\n                                    children: picture ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        alt: userName,\n                                        decoding: \"async\",\n                                        src: picture\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                        lineNumber: 83,\n                                        columnNumber: 25\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_4__.Avatar, {}, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                        lineNumber: 85,\n                                        columnNumber: 25\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                    lineNumber: 81,\n                                    columnNumber: 21\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SanitizedContent, {\n                                    content: decryptedContent[id] || content,\n                                    decrypted: typeof decryptedContent[id] === \"string\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                    lineNumber: 89,\n                                    columnNumber: 19\n                                }, undefined),\n                                publicKey === pubkey && gropupIndex === messages.length - 1 && messageIndex === eventGroup.length - 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"status\",\n                                    title: allEventsReceived ? \"Sent\" : \"Sending\",\n                                    children: allEventsReceived ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_4__.CheckFullCircle, {}, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                        lineNumber: 101,\n                                        columnNumber: 27\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_4__.CheckCircle, {}, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                        lineNumber: 103,\n                                        columnNumber: 27\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                                    lineNumber: 96,\n                                    columnNumber: 23\n                                }, undefined)\n                            ]\n                        }, id, true, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n                            lineNumber: 70,\n                            columnNumber: 17\n                        }, undefined)))\n            ]\n        }, void 0, true)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatLog.tsx\",\n        lineNumber: 63,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ChatLog, \"B4ZsVOjp7be5fcB0BYrqMcrLYHo=\", false, function() {\n    return [\n        components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_5__.useMessageContext,\n        components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_5__.useMessages,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__.useNostrProfile\n    ];\n});\n_c1 = ChatLog;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ChatLog));\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"SanitizedContent\");\n$RefreshReg$(_c1, \"ChatLog\");\n$RefreshReg$(_c2, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvQ2hhdExvZy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDcEM7QUFDNkI7QUFLdkI7QUFJUztBQUNrQjtBQUNLO0FBSTVCO0FBQ3FCO0FBRTNCO0FBRXZDLE1BQU1rQixtQkFBbUJiLG1EQUFPQSxDQUM5QixJQUFNLGdTQUFvRDs7Ozs7OztLQUR0RGE7QUFJTixNQUFNQyxVQUE4QyxDQUFDLEVBQ25EQyxrQkFBa0IsRUFDbkI7O0lBQ0MsTUFBTSxFQUFFQyxTQUFTLEVBQUUsR0FBR1gsMkZBQWlCQTtJQUN2QyxNQUFNLEVBQUVZLGlCQUFpQixFQUFFQyxRQUFRLEVBQUUsR0FBR1oscUZBQVdBLENBQUNTO0lBQ3BELE1BQU0sQ0FBQ0ksa0JBQWtCQyxvQkFBb0IsR0FBR3JCLCtDQUFRQSxDQUN0RCxDQUFDO0lBRUgsTUFBTXNCLGtCQUFrQnpCLGtEQUFXQTtnREFDakMsSUFDRTttQkFBSXNCO2FBQVMsQ0FBQ0ksT0FBTyxHQUFHQyxPQUFPO3dEQUFDLENBQUMsR0FBR0MsV0FBVyxHQUM3QzsyQkFBSUE7cUJBQVcsQ0FBQ0YsT0FBTyxHQUFHQyxPQUFPO2dFQUFDLENBQUMsRUFBRUUsT0FBTyxFQUFFQyxFQUFFLEVBQUUsR0FDaERqQixtRkFBY0EsQ0FBQ2lCLElBQUlELFNBQVNWLG9CQUFvQlksSUFBSTt3RUFBQyxDQUFDQyxVQUNwRFI7Z0ZBQW9CLENBQUNTLDBCQUE2QjtnREFDaEQsR0FBR0EsdUJBQXVCO2dEQUMxQixDQUFDSCxHQUFHLEVBQUVFLFdBQVc7NENBQ25COzs7OzsrQ0FJUjtRQUFDVjtRQUFVSDtLQUFtQjtJQUVoQyxNQUFNZSxVQUFVaEMsNkNBQU1BLENBQW1CO0lBQ3pDLE1BQU1pQyxlQUFlaEIsdUJBQXVCUCxtRkFBa0JBO0lBQzlELE1BQU0sRUFBRXdCLE9BQU8sRUFBRUMsUUFBUSxFQUFFLEdBQUd0QixnRkFBZUEsQ0FDM0NvQixlQUFlLEtBQUtoQjtJQUd0QmxCLGdEQUFTQTs2QkFBQztZQUNSLElBQUlxQixVQUFVO2dCQUNaRztnQkFDQVMsUUFBUUksT0FBTyxFQUFFQyxTQUFTLEdBQUdMLFFBQVFJLE9BQU8sQ0FBQ0UsWUFBWTtZQUMzRDtRQUNGOzRCQUFHO1FBQUNmO1FBQWlCSDtLQUFTO0lBRTlCLHFCQUNFLDhEQUFDWCwrRUFBYUE7UUFBQzhCLEtBQUtQO2tCQUNqQixDQUFDQyw4QkFDQTs7OEJBQ0UsOERBQUM5Qiw2RUFBV0E7b0JBQUNlLFdBQVdEOzs7Ozs7Z0JBQ3ZCRyxTQUFTb0IsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsV0FBV2YsV0FBVyxFQUFFZ0IsY0FDdENoQixXQUFXYyxHQUFHLENBQ1osQ0FBQyxFQUFFRyxVQUFVLEVBQUVmLEVBQUUsRUFBRWdCLE1BQU0sRUFBRWpCLE9BQU8sRUFBRSxFQUFFa0IsNkJBQ3BDLDhEQUFDQzs0QkFFQ0MsV0FBV2pDLHNEQUFJQSxDQUFDO2dDQUNkLGdCQUFnQk8sZ0JBQWdCLENBQUNPLEdBQUcsS0FBSztnQ0FDekNvQixVQUFVOUIsY0FBYzBCO2dDQUN4QkssTUFBTS9CLGNBQWMwQjs0QkFDdEI7NEJBQ0FNLGtCQUFnQkwsaUJBQWlCLElBQUlKLFlBQVlVOzRCQUNqREMsT0FBT3hDLHdGQUFtQkEsQ0FBQytCOztnQ0FFMUJ6QixjQUFjMEIsd0JBQ2IsOERBQUNTO29DQUFJTixXQUFVOzhDQUNaYix3QkFDQyw4REFBQ29CO3dDQUFJQyxLQUFLcEI7d0NBQVVxQixVQUFTO3dDQUFRQyxLQUFLdkI7Ozs7O2tFQUUxQyw4REFBQzlCLG1FQUFNQTs7Ozs7Ozs7Ozs4Q0FJYiw4REFBQ1c7b0NBQ0NZLFNBQVNOLGdCQUFnQixDQUFDTyxHQUFHLElBQUlEO29DQUNqQytCLFdBQVcsT0FBT3JDLGdCQUFnQixDQUFDTyxHQUFHLEtBQUs7Ozs7OztnQ0FFNUNWLGNBQWMwQixVQUNiRixnQkFBZ0J0QixTQUFTdUMsTUFBTSxHQUFHLEtBQ2xDZCxpQkFBaUJuQixXQUFXaUMsTUFBTSxHQUFHLG1CQUNuQyw4REFBQ047b0NBQ0NOLFdBQVU7b0NBQ1ZLLE9BQU9qQyxvQkFBb0IsU0FBUzs4Q0FFbkNBLGtDQUNDLDhEQUFDYiw0RUFBZUE7Ozs7a0VBRWhCLDhEQUFDRCx3RUFBV0E7Ozs7Ozs7Ozs7OzJCQWhDZnVCOzs7Ozs7Ozs7Ozs7QUE0Q3ZCO0dBeEZNWjs7UUFHa0JULHVGQUFpQkE7UUFDQ0MsaUZBQVdBO1FBb0JyQkssNEVBQWVBOzs7TUF4QnpDRztBQTBGTixvRkFBZW5CLDJDQUFJQSxDQUFDbUIsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXENoYXRMb2cudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lbW8sIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IGR5bmFtaWMgZnJvbSBcIm5leHQvZHluYW1pY1wiO1xyXG5pbXBvcnQgQ2hhdFByb2ZpbGUgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvQ2hhdFByb2ZpbGVcIjtcclxuaW1wb3J0IHtcclxuICBBdmF0YXIsXHJcbiAgQ2hlY2tDaXJjbGUsXHJcbiAgQ2hlY2tGdWxsQ2lyY2xlLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL0ljb25zXCI7XHJcbmltcG9ydCB7XHJcbiAgdXNlTWVzc2FnZUNvbnRleHQsXHJcbiAgdXNlTWVzc2FnZXMsXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvTWVzc2FnZUNvbnRleHRcIjtcclxuaW1wb3J0IFN0eWxlZENoYXRMb2cgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ2hhdExvZ1wiO1xyXG5pbXBvcnQgeyBVTktOT1dOX1BVQkxJQ19LRVkgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9jb25zdGFudHNcIjtcclxuaW1wb3J0IHtcclxuICBkZWNyeXB0TWVzc2FnZSxcclxuICBwcmV0dHlDaGF0VGltZXN0YW1wLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQgeyB1c2VOb3N0clByb2ZpbGUgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9ob29rc1wiO1xyXG5pbXBvcnQgeyB0eXBlIERlY3J5cHRlZENvbnRlbnQgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci90eXBlc1wiO1xyXG5pbXBvcnQgeyBjbHN4IH0gZnJvbSBcInV0aWxzL2Z1bmN0aW9uc1wiO1xyXG5cclxuY29uc3QgU2FuaXRpemVkQ29udGVudCA9IGR5bmFtaWMoXHJcbiAgKCkgPT4gaW1wb3J0KFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9TYW5pdGl6ZWRDb250ZW50XCIpXHJcbik7XHJcblxyXG5jb25zdCBDaGF0TG9nOiBGQzx7IHJlY2lwaWVudFB1YmxpY0tleTogc3RyaW5nIH0+ID0gKHtcclxuICByZWNpcGllbnRQdWJsaWNLZXksXHJcbn0pID0+IHtcclxuICBjb25zdCB7IHB1YmxpY0tleSB9ID0gdXNlTWVzc2FnZUNvbnRleHQoKTtcclxuICBjb25zdCB7IGFsbEV2ZW50c1JlY2VpdmVkLCBtZXNzYWdlcyB9ID0gdXNlTWVzc2FnZXMocmVjaXBpZW50UHVibGljS2V5KTtcclxuICBjb25zdCBbZGVjcnlwdGVkQ29udGVudCwgc2V0RGVjcnlwdGVkQ29udGVudF0gPSB1c2VTdGF0ZTxEZWNyeXB0ZWRDb250ZW50PihcclxuICAgIHt9XHJcbiAgKTtcclxuICBjb25zdCBkZWNyeXB0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcclxuICAgICgpID0+XHJcbiAgICAgIFsuLi5tZXNzYWdlc10ucmV2ZXJzZSgpLmZvckVhY2goKFssIGV2ZW50R3JvdXBdKSA9PlxyXG4gICAgICAgIFsuLi5ldmVudEdyb3VwXS5yZXZlcnNlKCkuZm9yRWFjaCgoeyBjb250ZW50LCBpZCB9KSA9PlxyXG4gICAgICAgICAgZGVjcnlwdE1lc3NhZ2UoaWQsIGNvbnRlbnQsIHJlY2lwaWVudFB1YmxpY0tleSkudGhlbigobWVzc2FnZSkgPT5cclxuICAgICAgICAgICAgc2V0RGVjcnlwdGVkQ29udGVudCgoY3VycmVudERlY3J5cHRlZENvbnRlbnQpID0+ICh7XHJcbiAgICAgICAgICAgICAgLi4uY3VycmVudERlY3J5cHRlZENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgW2lkXTogbWVzc2FnZSB8fCBmYWxzZSxcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApLFxyXG4gICAgW21lc3NhZ2VzLCByZWNpcGllbnRQdWJsaWNLZXldXHJcbiAgKTtcclxuICBjb25zdCBsaXN0UmVmID0gdXNlUmVmPEhUTUxPTGlzdEVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IGlzVW5rbm93bktleSA9IHJlY2lwaWVudFB1YmxpY0tleSA9PT0gVU5LTk9XTl9QVUJMSUNfS0VZO1xyXG4gIGNvbnN0IHsgcGljdHVyZSwgdXNlck5hbWUgfSA9IHVzZU5vc3RyUHJvZmlsZShcclxuICAgIGlzVW5rbm93bktleSA/IFwiXCIgOiByZWNpcGllbnRQdWJsaWNLZXlcclxuICApO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG1lc3NhZ2VzKSB7XHJcbiAgICAgIGRlY3J5cHRNZXNzYWdlcygpO1xyXG4gICAgICBsaXN0UmVmLmN1cnJlbnQ/LnNjcm9sbFRvKDAsIGxpc3RSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQpO1xyXG4gICAgfVxyXG4gIH0sIFtkZWNyeXB0TWVzc2FnZXMsIG1lc3NhZ2VzXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVkQ2hhdExvZyByZWY9e2xpc3RSZWZ9PlxyXG4gICAgICB7IWlzVW5rbm93bktleSAmJiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgIDxDaGF0UHJvZmlsZSBwdWJsaWNLZXk9e3JlY2lwaWVudFB1YmxpY0tleX0gLz5cclxuICAgICAgICAgIHttZXNzYWdlcy5tYXAoKFt0aW1lc3RhbXAsIGV2ZW50R3JvdXBdLCBncm9wdXBJbmRleCkgPT5cclxuICAgICAgICAgICAgZXZlbnRHcm91cC5tYXAoXHJcbiAgICAgICAgICAgICAgKHsgY3JlYXRlZF9hdCwgaWQsIHB1YmtleSwgY29udGVudCB9LCBtZXNzYWdlSW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgIDxsaVxyXG4gICAgICAgICAgICAgICAgICBrZXk9e2lkfVxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nsc3goe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiY2FudC1kZWNyeXB0XCI6IGRlY3J5cHRlZENvbnRlbnRbaWRdID09PSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcHVibGljS2V5ICE9PSBwdWJrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgc2VudDogcHVibGljS2V5ID09PSBwdWJrZXksXHJcbiAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgICBkYXRhLXRpbWVzdGFtcD17bWVzc2FnZUluZGV4ID09PSAwID8gdGltZXN0YW1wIDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgICAgICB0aXRsZT17cHJldHR5Q2hhdFRpbWVzdGFtcChjcmVhdGVkX2F0KX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAge3B1YmxpY0tleSAhPT0gcHVia2V5ICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImF2YXRhclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAge3BpY3R1cmUgPyAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgYWx0PXt1c2VyTmFtZX0gZGVjb2Rpbmc9XCJhc3luY1wiIHNyYz17cGljdHVyZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxBdmF0YXIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgIDxTYW5pdGl6ZWRDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17ZGVjcnlwdGVkQ29udGVudFtpZF0gfHwgY29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ZWQ9e3R5cGVvZiBkZWNyeXB0ZWRDb250ZW50W2lkXSA9PT0gXCJzdHJpbmdcIn1cclxuICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAge3B1YmxpY0tleSA9PT0gcHVia2V5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvcHVwSW5kZXggPT09IG1lc3NhZ2VzLmxlbmd0aCAtIDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSW5kZXggPT09IGV2ZW50R3JvdXAubGVuZ3RoIC0gMSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInN0YXR1c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXthbGxFdmVudHNSZWNlaXZlZCA/IFwiU2VudFwiIDogXCJTZW5kaW5nXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHthbGxFdmVudHNSZWNlaXZlZCA/IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tGdWxsQ2lyY2xlIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrQ2lyY2xlIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPC8+XHJcbiAgICAgICl9XHJcbiAgICA8L1N0eWxlZENoYXRMb2c+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1lbW8oQ2hhdExvZyk7XHJcbiJdLCJuYW1lcyI6WyJtZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImR5bmFtaWMiLCJDaGF0UHJvZmlsZSIsIkF2YXRhciIsIkNoZWNrQ2lyY2xlIiwiQ2hlY2tGdWxsQ2lyY2xlIiwidXNlTWVzc2FnZUNvbnRleHQiLCJ1c2VNZXNzYWdlcyIsIlN0eWxlZENoYXRMb2ciLCJVTktOT1dOX1BVQkxJQ19LRVkiLCJkZWNyeXB0TWVzc2FnZSIsInByZXR0eUNoYXRUaW1lc3RhbXAiLCJ1c2VOb3N0clByb2ZpbGUiLCJjbHN4IiwiU2FuaXRpemVkQ29udGVudCIsIkNoYXRMb2ciLCJyZWNpcGllbnRQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJhbGxFdmVudHNSZWNlaXZlZCIsIm1lc3NhZ2VzIiwiZGVjcnlwdGVkQ29udGVudCIsInNldERlY3J5cHRlZENvbnRlbnQiLCJkZWNyeXB0TWVzc2FnZXMiLCJyZXZlcnNlIiwiZm9yRWFjaCIsImV2ZW50R3JvdXAiLCJjb250ZW50IiwiaWQiLCJ0aGVuIiwibWVzc2FnZSIsImN1cnJlbnREZWNyeXB0ZWRDb250ZW50IiwibGlzdFJlZiIsImlzVW5rbm93bktleSIsInBpY3R1cmUiLCJ1c2VyTmFtZSIsImN1cnJlbnQiLCJzY3JvbGxUbyIsInNjcm9sbEhlaWdodCIsInJlZiIsIm1hcCIsInRpbWVzdGFtcCIsImdyb3B1cEluZGV4IiwiY3JlYXRlZF9hdCIsInB1YmtleSIsIm1lc3NhZ2VJbmRleCIsImxpIiwiY2xhc3NOYW1lIiwicmVjZWl2ZWQiLCJzZW50IiwiZGF0YS10aW1lc3RhbXAiLCJ1bmRlZmluZWQiLCJ0aXRsZSIsImRpdiIsImltZyIsImFsdCIsImRlY29kaW5nIiwic3JjIiwiZGVjcnlwdGVkIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/ChatLog.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/ChatProfile.tsx":
/*!***************************************************!*\
  !*** ./components/apps/Messenger/ChatProfile.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/Profile */ \"(pages-dir-browser)/./components/apps/Messenger/Profile.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledChatProfile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/StyledChatProfile */ \"(pages-dir-browser)/./components/apps/Messenger/StyledChatProfile.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n/* harmony import */ var hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hooks/useIsVisible */ \"(pages-dir-browser)/./hooks/useIsVisible.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst ChatProfile = ({ publicKey })=>{\n    _s();\n    const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isVisible = (0,hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_5__.useIsVisible)(elementRef);\n    const { about, nip05, picture, userName } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrProfile)(publicKey, isVisible);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledChatProfile__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        ref: elementRef,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            nip05: nip05,\n            picture: picture,\n            pubkey: publicKey,\n            userName: userName,\n            children: [\n                about && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"about\",\n                    children: about\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n                    lineNumber: 23,\n                    columnNumber: 19\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"encryption\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            children: \"\\uD83D\\uDD10 End-to-end encrypted\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n                            lineNumber: 25,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            children: \"Messages are secured with AES256-CBC encryption.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n            lineNumber: 17,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ChatProfile.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ChatProfile, \"jlspy9eMk4mHr/iVxFsCdva3bLE=\", false, function() {\n    return [\n        hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_5__.useIsVisible,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrProfile\n    ];\n});\n_c = ChatProfile;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ChatProfile));\nvar _c, _c1;\n$RefreshReg$(_c, \"ChatProfile\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvQ2hhdFByb2ZpbGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ21CO0FBQ29CO0FBQ1Y7QUFDaEI7QUFFbEQsTUFBTU0sY0FBeUMsQ0FBQyxFQUFFQyxTQUFTLEVBQUU7O0lBQzNELE1BQU1DLGFBQWFQLDZDQUFNQSxDQUF1QjtJQUNoRCxNQUFNUSxZQUFZSixnRUFBWUEsQ0FBQ0c7SUFDL0IsTUFBTSxFQUFFRSxLQUFLLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR1QsZ0ZBQWVBLENBQ3pERyxXQUNBRTtJQUdGLHFCQUNFLDhEQUFDTixtRkFBaUJBO1FBQUNXLEtBQUtOO2tCQUN0Qiw0RUFBQ04seUVBQU9BO1lBQ05TLE9BQU9BO1lBQ1BDLFNBQVNBO1lBQ1RHLFFBQVFSO1lBQ1JNLFVBQVVBOztnQkFFVEgsdUJBQVMsOERBQUNNO29CQUFJQyxXQUFVOzhCQUFTUDs7Ozs7OzhCQUNsQyw4REFBQ007b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDQztzQ0FBSzs7Ozs7O3NDQUNOLDhEQUFDQTtzQ0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLaEI7R0F4Qk1aOztRQUVjRCw0REFBWUE7UUFDY0QsNEVBQWVBOzs7S0FIdkRFO0FBMEJOLG9GQUFlTiwyQ0FBSUEsQ0FBQ00sWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXENoYXRQcm9maWxlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IFByb2ZpbGUgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvUHJvZmlsZVwiO1xyXG5pbXBvcnQgU3R5bGVkQ2hhdFByb2ZpbGUgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ2hhdFByb2ZpbGVcIjtcclxuaW1wb3J0IHsgdXNlTm9zdHJQcm9maWxlIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlSXNWaXNpYmxlIH0gZnJvbSBcImhvb2tzL3VzZUlzVmlzaWJsZVwiO1xyXG5cclxuY29uc3QgQ2hhdFByb2ZpbGU6IEZDPHsgcHVibGljS2V5OiBzdHJpbmcgfT4gPSAoeyBwdWJsaWNLZXkgfSkgPT4ge1xyXG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWY8SFRNTExJRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGlzVmlzaWJsZSA9IHVzZUlzVmlzaWJsZShlbGVtZW50UmVmKTtcclxuICBjb25zdCB7IGFib3V0LCBuaXAwNSwgcGljdHVyZSwgdXNlck5hbWUgfSA9IHVzZU5vc3RyUHJvZmlsZShcclxuICAgIHB1YmxpY0tleSxcclxuICAgIGlzVmlzaWJsZVxyXG4gICk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVkQ2hhdFByb2ZpbGUgcmVmPXtlbGVtZW50UmVmfT5cclxuICAgICAgPFByb2ZpbGVcclxuICAgICAgICBuaXAwNT17bmlwMDV9XHJcbiAgICAgICAgcGljdHVyZT17cGljdHVyZX1cclxuICAgICAgICBwdWJrZXk9e3B1YmxpY0tleX1cclxuICAgICAgICB1c2VyTmFtZT17dXNlck5hbWV9XHJcbiAgICAgID5cclxuICAgICAgICB7YWJvdXQgJiYgPGRpdiBjbGFzc05hbWU9XCJhYm91dFwiPnthYm91dH08L2Rpdj59XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbmNyeXB0aW9uXCI+XHJcbiAgICAgICAgICA8c3Bhbj7wn5SQIEVuZC10by1lbmQgZW5jcnlwdGVkPC9zcGFuPlxyXG4gICAgICAgICAgPHNwYW4+TWVzc2FnZXMgYXJlIHNlY3VyZWQgd2l0aCBBRVMyNTYtQ0JDIGVuY3J5cHRpb24uPC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L1Byb2ZpbGU+XHJcbiAgICA8L1N0eWxlZENoYXRQcm9maWxlPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW1vKENoYXRQcm9maWxlKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJ1c2VSZWYiLCJQcm9maWxlIiwiU3R5bGVkQ2hhdFByb2ZpbGUiLCJ1c2VOb3N0clByb2ZpbGUiLCJ1c2VJc1Zpc2libGUiLCJDaGF0UHJvZmlsZSIsInB1YmxpY0tleSIsImVsZW1lbnRSZWYiLCJpc1Zpc2libGUiLCJhYm91dCIsIm5pcDA1IiwicGljdHVyZSIsInVzZXJOYW1lIiwicmVmIiwicHVia2V5IiwiZGl2IiwiY2xhc3NOYW1lIiwic3BhbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/ChatProfile.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/Contact.tsx":
/*!***********************************************!*\
  !*** ./components/apps/Messenger/Contact.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/Profile */ \"(pages-dir-browser)/./components/apps/Messenger/Profile.tsx\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n/* harmony import */ var contexts_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! contexts/menu */ \"(pages-dir-browser)/./contexts/menu/index.tsx\");\n/* harmony import */ var styles_common_Button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! styles/common/Button */ \"(pages-dir-browser)/./styles/common/Button.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! hooks/useIsVisible */ \"(pages-dir-browser)/./hooks/useIsVisible.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst Contact = ({ lastEvent, onClick, pubkey, publicKey, unreadEvent })=>{\n    _s();\n    const { content = \"\", created_at = 0, id, pubkey: eventPubkey } = lastEvent || {};\n    const [decryptedContent, setDecryptedContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [timeStamp, setTimeStamp] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isVisible = (0,hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_8__.useIsVisible)(elementRef);\n    const { nip05, picture, userName } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrProfile)(pubkey, isVisible);\n    const unreadClass = unreadEvent ? \"unread\" : undefined;\n    const { contextMenu } = (0,contexts_menu__WEBPACK_IMPORTED_MODULE_5__.useMenu)();\n    const { onContextMenuCapture } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"Contact.useMemo\": ()=>contextMenu?.({\n                \"Contact.useMemo\": ()=>[\n                        {\n                            action: onClick,\n                            icon: \"ðŸ”\",\n                            label: \"Start end-to-end encrypted chat\"\n                        },\n                        utils_constants__WEBPACK_IMPORTED_MODULE_7__.MENU_SEPERATOR,\n                        ...(0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.copyKeyMenuItems)(pubkey)\n                    ]\n            }[\"Contact.useMemo\"])\n    }[\"Contact.useMemo\"], [\n        contextMenu,\n        onClick,\n        pubkey\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Contact.useEffect\": ()=>{\n            if (content && isVisible) {\n                (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.decryptMessage)(id, content, pubkey).then({\n                    \"Contact.useEffect\": (message)=>message && setDecryptedContent(message)\n                }[\"Contact.useEffect\"]);\n            }\n        }\n    }[\"Contact.useEffect\"], [\n        content,\n        id,\n        isVisible,\n        pubkey\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Contact.useEffect\": ()=>{\n            let interval = 0;\n            if (created_at) {\n                setTimeStamp((0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.shortTimeStamp)(created_at));\n                interval = window.setInterval({\n                    \"Contact.useEffect\": ()=>setTimeStamp((0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.shortTimeStamp)(created_at))\n                }[\"Contact.useEffect\"], utils_constants__WEBPACK_IMPORTED_MODULE_7__.MILLISECONDS_IN_MINUTE);\n            }\n            return ({\n                \"Contact.useEffect\": ()=>window.clearInterval(interval)\n            })[\"Contact.useEffect\"];\n        }\n    }[\"Contact.useEffect\"], [\n        created_at\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n        ref: elementRef,\n        className: unreadClass,\n        onContextMenuCapture: onContextMenuCapture,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(styles_common_Button__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n            onClick: onClick,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                nip05: nip05,\n                picture: picture,\n                pubkey: pubkey,\n                userName: userName,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: unreadClass,\n                            children: [\n                                eventPubkey === publicKey ? \"You: \" : \"\",\n                                decryptedContent || content\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n                            lineNumber: 94,\n                            columnNumber: 13\n                        }, undefined),\n                        timeStamp ? \"Â·\" : \"\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: timeStamp\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n                            lineNumber: 99,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n                    lineNumber: 93,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n                lineNumber: 87,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n            lineNumber: 86,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Contact.tsx\",\n        lineNumber: 81,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Contact, \"fR+1ohKHlWNTl2piGdoT899JbIM=\", false, function() {\n    return [\n        hooks_useIsVisible__WEBPACK_IMPORTED_MODULE_8__.useIsVisible,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrProfile,\n        contexts_menu__WEBPACK_IMPORTED_MODULE_5__.useMenu\n    ];\n});\n_c = Contact;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(Contact));\nvar _c, _c1;\n$RefreshReg$(_c, \"Contact\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvQ29udGFjdC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFFWDtBQUtYO0FBQ3FCO0FBQzFCO0FBQ0U7QUFDK0I7QUFDdkI7QUFVbEQsTUFBTWUsVUFBNEIsQ0FBQyxFQUNqQ0MsU0FBUyxFQUNUQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsU0FBUyxFQUNUQyxXQUFXLEVBQ1o7O0lBQ0MsTUFBTSxFQUNKQyxVQUFVLEVBQUUsRUFDWkMsYUFBYSxDQUFDLEVBQ2RDLEVBQUUsRUFDRkwsUUFBUU0sV0FBVyxFQUNwQixHQUFHUixhQUFhLENBQUM7SUFDbEIsTUFBTSxDQUFDUyxrQkFBa0JDLG9CQUFvQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDekQsTUFBTSxDQUFDdUIsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTXlCLGFBQWExQiw2Q0FBTUEsQ0FBdUI7SUFDaEQsTUFBTTJCLFlBQVloQixnRUFBWUEsQ0FBQ2U7SUFDL0IsTUFBTSxFQUFFRSxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFLEdBQUd4QixnRkFBZUEsQ0FBQ1MsUUFBUVk7SUFDN0QsTUFBTUksY0FBY2QsY0FBYyxXQUFXZTtJQUM3QyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHMUIsc0RBQU9BO0lBQy9CLE1BQU0sRUFBRTJCLG9CQUFvQixFQUFFLEdBQUduQyw4Q0FBT0E7MkJBQ3RDLElBQ0VrQzttQ0FBYyxJQUFNO3dCQUNsQjs0QkFDRUUsUUFBUXJCOzRCQUNSc0IsTUFBTTs0QkFDTkMsT0FBTzt3QkFDVDt3QkFDQTVCLDJEQUFjQTsyQkFDWE4scUZBQWdCQSxDQUFDWTtxQkFDckI7OzBCQUNIO1FBQUNrQjtRQUFhbkI7UUFBU0M7S0FBTztJQUdoQ2pCLGdEQUFTQTs2QkFBQztZQUNSLElBQUlvQixXQUFXUyxXQUFXO2dCQUN4QnZCLG1GQUFjQSxDQUFDZ0IsSUFBSUYsU0FBU0gsUUFBUXVCLElBQUk7eUNBQ3RDLENBQUNDLFVBQVlBLFdBQVdoQixvQkFBb0JnQjs7WUFFaEQ7UUFDRjs0QkFBRztRQUFDckI7UUFBU0U7UUFBSU87UUFBV1o7S0FBTztJQUVuQ2pCLGdEQUFTQTs2QkFBQztZQUNSLElBQUkwQyxXQUFXO1lBRWYsSUFBSXJCLFlBQVk7Z0JBQ2RNLGFBQWFwQixtRkFBY0EsQ0FBQ2M7Z0JBRTVCcUIsV0FBV0MsT0FBT0MsV0FBVzt5Q0FDM0IsSUFBTWpCLGFBQWFwQixtRkFBY0EsQ0FBQ2M7d0NBQ2xDVCxtRUFBc0JBO1lBRTFCO1lBRUE7cUNBQU8sSUFBTStCLE9BQU9FLGFBQWEsQ0FBQ0g7O1FBQ3BDOzRCQUFHO1FBQUNyQjtLQUFXO0lBRWYscUJBQ0UsOERBQUN5QjtRQUNDQyxLQUFLbkI7UUFDTG9CLFdBQVdmO1FBQ1hHLHNCQUFzQkE7a0JBRXRCLDRFQUFDMUIsNERBQU1BO1lBQUNNLFNBQVNBO3NCQUNmLDRFQUFDWix5RUFBT0E7Z0JBQ04wQixPQUFPQTtnQkFDUEMsU0FBU0E7Z0JBQ1RkLFFBQVFBO2dCQUNSZSxVQUFVQTswQkFFViw0RUFBQ2lCOztzQ0FDQyw4REFBQ0E7NEJBQUlELFdBQVdmOztnQ0FDYlYsZ0JBQWdCTCxZQUFZLFVBQVU7Z0NBQ3RDTSxvQkFBb0JKOzs7Ozs7O3dCQUV0Qk0sWUFBWSxNQUFNO3NDQUNuQiw4REFBQ3VCO3NDQUFLdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1sQjtHQWxGTVo7O1FBZ0JjRCw0REFBWUE7UUFDT0wsNEVBQWVBO1FBRTVCQyxrREFBT0E7OztLQW5CM0JLO0FBb0ZOLG9GQUFlZiwyQ0FBSUEsQ0FBQ2UsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXENvbnRhY3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lbW8sIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB0eXBlIEV2ZW50IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XHJcbmltcG9ydCBQcm9maWxlIGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL1Byb2ZpbGVcIjtcclxuaW1wb3J0IHtcclxuICBjb3B5S2V5TWVudUl0ZW1zLFxyXG4gIGRlY3J5cHRNZXNzYWdlLFxyXG4gIHNob3J0VGltZVN0YW1wLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQgeyB1c2VOb3N0clByb2ZpbGUgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZW51IH0gZnJvbSBcImNvbnRleHRzL21lbnVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwic3R5bGVzL2NvbW1vbi9CdXR0b25cIjtcclxuaW1wb3J0IHsgTUVOVV9TRVBFUkFUT1IsIE1JTExJU0VDT05EU19JTl9NSU5VVEUgfSBmcm9tIFwidXRpbHMvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IHVzZUlzVmlzaWJsZSB9IGZyb20gXCJob29rcy91c2VJc1Zpc2libGVcIjtcclxuXHJcbnR5cGUgQ29udGFjdFByb3BzID0ge1xyXG4gIGxhc3RFdmVudDogRXZlbnQ7XHJcbiAgb25DbGljazogKCkgPT4gdm9pZDtcclxuICBwdWJrZXk6IHN0cmluZztcclxuICBwdWJsaWNLZXk6IHN0cmluZztcclxuICB1bnJlYWRFdmVudDogYm9vbGVhbjtcclxufTtcclxuXHJcbmNvbnN0IENvbnRhY3Q6IEZDPENvbnRhY3RQcm9wcz4gPSAoe1xyXG4gIGxhc3RFdmVudCxcclxuICBvbkNsaWNrLFxyXG4gIHB1YmtleSxcclxuICBwdWJsaWNLZXksXHJcbiAgdW5yZWFkRXZlbnQsXHJcbn0pID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBjb250ZW50ID0gXCJcIixcclxuICAgIGNyZWF0ZWRfYXQgPSAwLFxyXG4gICAgaWQsXHJcbiAgICBwdWJrZXk6IGV2ZW50UHVia2V5LFxyXG4gIH0gPSBsYXN0RXZlbnQgfHwge307XHJcbiAgY29uc3QgW2RlY3J5cHRlZENvbnRlbnQsIHNldERlY3J5cHRlZENvbnRlbnRdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgW3RpbWVTdGFtcCwgc2V0VGltZVN0YW1wXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWY8SFRNTExJRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGlzVmlzaWJsZSA9IHVzZUlzVmlzaWJsZShlbGVtZW50UmVmKTtcclxuICBjb25zdCB7IG5pcDA1LCBwaWN0dXJlLCB1c2VyTmFtZSB9ID0gdXNlTm9zdHJQcm9maWxlKHB1YmtleSwgaXNWaXNpYmxlKTtcclxuICBjb25zdCB1bnJlYWRDbGFzcyA9IHVucmVhZEV2ZW50ID8gXCJ1bnJlYWRcIiA6IHVuZGVmaW5lZDtcclxuICBjb25zdCB7IGNvbnRleHRNZW51IH0gPSB1c2VNZW51KCk7XHJcbiAgY29uc3QgeyBvbkNvbnRleHRNZW51Q2FwdHVyZSB9ID0gdXNlTWVtbyhcclxuICAgICgpID0+XHJcbiAgICAgIGNvbnRleHRNZW51Py4oKCkgPT4gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGFjdGlvbjogb25DbGljayxcclxuICAgICAgICAgIGljb246IFwi8J+UkFwiLFxyXG4gICAgICAgICAgbGFiZWw6IFwiU3RhcnQgZW5kLXRvLWVuZCBlbmNyeXB0ZWQgY2hhdFwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTUVOVV9TRVBFUkFUT1IsXHJcbiAgICAgICAgLi4uY29weUtleU1lbnVJdGVtcyhwdWJrZXkpLFxyXG4gICAgICBdKSxcclxuICAgIFtjb250ZXh0TWVudSwgb25DbGljaywgcHVia2V5XVxyXG4gICk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoY29udGVudCAmJiBpc1Zpc2libGUpIHtcclxuICAgICAgZGVjcnlwdE1lc3NhZ2UoaWQsIGNvbnRlbnQsIHB1YmtleSkudGhlbihcclxuICAgICAgICAobWVzc2FnZSkgPT4gbWVzc2FnZSAmJiBzZXREZWNyeXB0ZWRDb250ZW50KG1lc3NhZ2UpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSwgW2NvbnRlbnQsIGlkLCBpc1Zpc2libGUsIHB1YmtleV0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbGV0IGludGVydmFsID0gMDtcclxuXHJcbiAgICBpZiAoY3JlYXRlZF9hdCkge1xyXG4gICAgICBzZXRUaW1lU3RhbXAoc2hvcnRUaW1lU3RhbXAoY3JlYXRlZF9hdCkpO1xyXG5cclxuICAgICAgaW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXHJcbiAgICAgICAgKCkgPT4gc2V0VGltZVN0YW1wKHNob3J0VGltZVN0YW1wKGNyZWF0ZWRfYXQpKSxcclxuICAgICAgICBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsKTtcclxuICB9LCBbY3JlYXRlZF9hdF0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGxpXHJcbiAgICAgIHJlZj17ZWxlbWVudFJlZn1cclxuICAgICAgY2xhc3NOYW1lPXt1bnJlYWRDbGFzc31cclxuICAgICAgb25Db250ZXh0TWVudUNhcHR1cmU9e29uQ29udGV4dE1lbnVDYXB0dXJlfVxyXG4gICAgPlxyXG4gICAgICA8QnV0dG9uIG9uQ2xpY2s9e29uQ2xpY2t9PlxyXG4gICAgICAgIDxQcm9maWxlXHJcbiAgICAgICAgICBuaXAwNT17bmlwMDV9XHJcbiAgICAgICAgICBwaWN0dXJlPXtwaWN0dXJlfVxyXG4gICAgICAgICAgcHVia2V5PXtwdWJrZXl9XHJcbiAgICAgICAgICB1c2VyTmFtZT17dXNlck5hbWV9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3VucmVhZENsYXNzfT5cclxuICAgICAgICAgICAgICB7ZXZlbnRQdWJrZXkgPT09IHB1YmxpY0tleSA/IFwiWW91OiBcIiA6IFwiXCJ9XHJcbiAgICAgICAgICAgICAge2RlY3J5cHRlZENvbnRlbnQgfHwgY29udGVudH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHt0aW1lU3RhbXAgPyBcIsK3XCIgOiBcIlwifVxyXG4gICAgICAgICAgICA8ZGl2Pnt0aW1lU3RhbXB9PC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L1Byb2ZpbGU+XHJcbiAgICAgIDwvQnV0dG9uPlxyXG4gICAgPC9saT5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWVtbyhDb250YWN0KTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJQcm9maWxlIiwiY29weUtleU1lbnVJdGVtcyIsImRlY3J5cHRNZXNzYWdlIiwic2hvcnRUaW1lU3RhbXAiLCJ1c2VOb3N0clByb2ZpbGUiLCJ1c2VNZW51IiwiQnV0dG9uIiwiTUVOVV9TRVBFUkFUT1IiLCJNSUxMSVNFQ09ORFNfSU5fTUlOVVRFIiwidXNlSXNWaXNpYmxlIiwiQ29udGFjdCIsImxhc3RFdmVudCIsIm9uQ2xpY2siLCJwdWJrZXkiLCJwdWJsaWNLZXkiLCJ1bnJlYWRFdmVudCIsImNvbnRlbnQiLCJjcmVhdGVkX2F0IiwiaWQiLCJldmVudFB1YmtleSIsImRlY3J5cHRlZENvbnRlbnQiLCJzZXREZWNyeXB0ZWRDb250ZW50IiwidGltZVN0YW1wIiwic2V0VGltZVN0YW1wIiwiZWxlbWVudFJlZiIsImlzVmlzaWJsZSIsIm5pcDA1IiwicGljdHVyZSIsInVzZXJOYW1lIiwidW5yZWFkQ2xhc3MiLCJ1bmRlZmluZWQiLCJjb250ZXh0TWVudSIsIm9uQ29udGV4dE1lbnVDYXB0dXJlIiwiYWN0aW9uIiwiaWNvbiIsImxhYmVsIiwidGhlbiIsIm1lc3NhZ2UiLCJpbnRlcnZhbCIsIndpbmRvdyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImxpIiwicmVmIiwiY2xhc3NOYW1lIiwiZGl2Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/Contact.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/GetMoreMessages.tsx":
/*!*******************************************************!*\
  !*** ./components/apps/Messenger/GetMoreMessages.tsx ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/HistoryContext */ \"(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledGetMoreMessages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/StyledGetMoreMessages */ \"(pages-dir-browser)/./components/apps/Messenger/StyledGetMoreMessages.ts\");\n/* harmony import */ var styles_common_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styles/common/Button */ \"(pages-dir-browser)/./styles/common/Button.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst TimeScaleLabel = {\n    day: \"Retrieve last 7 days of messages\",\n    month: \"Retrieve last 90 days of messages\",\n    trimester: \"Retrieve all messages\",\n    week: \"Retrieve last 30 days of messages\"\n};\nconst GetMoreMessages = ({ setSince })=>{\n    _s();\n    const { timeScale, setTimeScale } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext)();\n    const [disabled, setDisabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    if (timeScale === \"infinite\") return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n    const updateTimeScale = (since, scale)=>{\n        setSince(since);\n        setTimeScale(scale);\n        setDisabled(true);\n        setTimeout(()=>setDisabled(false), utils_constants__WEBPACK_IMPORTED_MODULE_5__.MILLISECONDS_IN_SECOND);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledGetMoreMessages__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(styles_common_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n            disabled: disabled,\n            onClick: ()=>{\n                switch(timeScale){\n                    case \"day\":\n                        updateTimeScale(utils_constants__WEBPACK_IMPORTED_MODULE_5__.MILLISECONDS_IN_DAY * 7, \"week\");\n                        break;\n                    case \"week\":\n                        updateTimeScale(utils_constants__WEBPACK_IMPORTED_MODULE_5__.MILLISECONDS_IN_DAY * 30, \"month\");\n                        break;\n                    case \"month\":\n                        updateTimeScale(utils_constants__WEBPACK_IMPORTED_MODULE_5__.MILLISECONDS_IN_DAY * 90, \"trimester\");\n                        break;\n                    default:\n                        updateTimeScale(0, \"infinite\");\n                        break;\n                }\n            },\n            children: TimeScaleLabel[timeScale]\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\GetMoreMessages.tsx\",\n            lineNumber: 35,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\GetMoreMessages.tsx\",\n        lineNumber: 34,\n        columnNumber: 5\n    }, undefined);\n};\n_s(GetMoreMessages, \"iMTjRcjeEgxIemEV+5Nnz89L0cY=\", false, function() {\n    return [\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext\n    ];\n});\n_c = GetMoreMessages;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GetMoreMessages));\nvar _c, _c1;\n$RefreshReg$(_c, \"GetMoreMessages\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvR2V0TW9yZU1lc3NhZ2VzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1QztBQUlXO0FBQ2tDO0FBQzFDO0FBQ29DO0FBRTlFLE1BQU1PLGlCQUFxRDtJQUN6REMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsTUFBTTtBQUNSO0FBRUEsTUFBTUMsa0JBRUQsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ2hCLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR2IsMkZBQWlCQTtJQUNyRCxNQUFNLENBQUNjLFVBQVVDLFlBQVksR0FBR2hCLCtDQUFRQSxDQUFVO0lBRWxELHlEQUF5RDtJQUN6RCxJQUFJYSxjQUFjLFlBQVkscUJBQU87SUFFckMsTUFBTUksa0JBQWtCLENBQUNDLE9BQWVDO1FBQ3RDUCxTQUFTTTtRQUNUSixhQUFhSztRQUNiSCxZQUFZO1FBQ1pJLFdBQVcsSUFBTUosWUFBWSxRQUFRWCxtRUFBc0JBO0lBQzdEO0lBRUEscUJBQ0UsOERBQUNILHVGQUFxQkE7a0JBQ3BCLDRFQUFDQyw0REFBTUE7WUFDTFksVUFBVUE7WUFDVk0sU0FBUztnQkFDUCxPQUFRUjtvQkFDTixLQUFLO3dCQUNISSxnQkFBZ0JiLGdFQUFtQkEsR0FBRyxHQUFHO3dCQUN6QztvQkFDRixLQUFLO3dCQUNIYSxnQkFBZ0JiLGdFQUFtQkEsR0FBRyxJQUFJO3dCQUMxQztvQkFDRixLQUFLO3dCQUNIYSxnQkFBZ0JiLGdFQUFtQkEsR0FBRyxJQUFJO3dCQUMxQztvQkFDRjt3QkFDRWEsZ0JBQWdCLEdBQUc7d0JBQ25CO2dCQUNKO1lBQ0Y7c0JBRUNYLGNBQWMsQ0FBQ08sVUFBVTs7Ozs7Ozs7Ozs7QUFJbEM7R0F6Q01GOztRQUdnQ1YsdUZBQWlCQTs7O0tBSGpEVTtBQTJDTixvRkFBZVosMkNBQUlBLENBQUNZLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXEdldE1vcmVNZXNzYWdlcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHtcclxuICB0eXBlIFRpbWVTY2FsZSxcclxuICB1c2VIaXN0b3J5Q29udGV4dCxcclxufSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9IaXN0b3J5Q29udGV4dFwiO1xyXG5pbXBvcnQgU3R5bGVkR2V0TW9yZU1lc3NhZ2VzIGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL1N0eWxlZEdldE1vcmVNZXNzYWdlc1wiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCJzdHlsZXMvY29tbW9uL0J1dHRvblwiO1xyXG5pbXBvcnQgeyBNSUxMSVNFQ09ORFNfSU5fREFZLCBNSUxMSVNFQ09ORFNfSU5fU0VDT05EIH0gZnJvbSBcInV0aWxzL2NvbnN0YW50c1wiO1xyXG5cclxuY29uc3QgVGltZVNjYWxlTGFiZWw6IFBhcnRpYWw8UmVjb3JkPFRpbWVTY2FsZSwgc3RyaW5nPj4gPSB7XHJcbiAgZGF5OiBcIlJldHJpZXZlIGxhc3QgNyBkYXlzIG9mIG1lc3NhZ2VzXCIsXHJcbiAgbW9udGg6IFwiUmV0cmlldmUgbGFzdCA5MCBkYXlzIG9mIG1lc3NhZ2VzXCIsXHJcbiAgdHJpbWVzdGVyOiBcIlJldHJpZXZlIGFsbCBtZXNzYWdlc1wiLFxyXG4gIHdlZWs6IFwiUmV0cmlldmUgbGFzdCAzMCBkYXlzIG9mIG1lc3NhZ2VzXCIsXHJcbn07XHJcblxyXG5jb25zdCBHZXRNb3JlTWVzc2FnZXM6IEZDPHtcclxuICBzZXRTaW5jZTogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248bnVtYmVyPj47XHJcbn0+ID0gKHsgc2V0U2luY2UgfSkgPT4ge1xyXG4gIGNvbnN0IHsgdGltZVNjYWxlLCBzZXRUaW1lU2NhbGUgfSA9IHVzZUhpc3RvcnlDb250ZXh0KCk7XHJcbiAgY29uc3QgW2Rpc2FibGVkLCBzZXREaXNhYmxlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtbm8tdXNlbGVzcy1mcmFnbWVudFxyXG4gIGlmICh0aW1lU2NhbGUgPT09IFwiaW5maW5pdGVcIikgcmV0dXJuIDw+PC8+O1xyXG5cclxuICBjb25zdCB1cGRhdGVUaW1lU2NhbGUgPSAoc2luY2U6IG51bWJlciwgc2NhbGU6IFRpbWVTY2FsZSk6IHZvaWQgPT4ge1xyXG4gICAgc2V0U2luY2Uoc2luY2UpO1xyXG4gICAgc2V0VGltZVNjYWxlKHNjYWxlKTtcclxuICAgIHNldERpc2FibGVkKHRydWUpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBzZXREaXNhYmxlZChmYWxzZSksIE1JTExJU0VDT05EU19JTl9TRUNPTkQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVkR2V0TW9yZU1lc3NhZ2VzPlxyXG4gICAgICA8QnV0dG9uXHJcbiAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHtcclxuICAgICAgICAgIHN3aXRjaCAodGltZVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgICB1cGRhdGVUaW1lU2NhbGUoTUlMTElTRUNPTkRTX0lOX0RBWSAqIDcsIFwid2Vla1wiKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIndlZWtcIjpcclxuICAgICAgICAgICAgICB1cGRhdGVUaW1lU2NhbGUoTUlMTElTRUNPTkRTX0lOX0RBWSAqIDMwLCBcIm1vbnRoXCIpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICAgICAgICB1cGRhdGVUaW1lU2NhbGUoTUlMTElTRUNPTkRTX0lOX0RBWSAqIDkwLCBcInRyaW1lc3RlclwiKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICB1cGRhdGVUaW1lU2NhbGUoMCwgXCJpbmZpbml0ZVwiKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9fVxyXG4gICAgICA+XHJcbiAgICAgICAge1RpbWVTY2FsZUxhYmVsW3RpbWVTY2FsZV19XHJcbiAgICAgIDwvQnV0dG9uPlxyXG4gICAgPC9TdHlsZWRHZXRNb3JlTWVzc2FnZXM+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1lbW8oR2V0TW9yZU1lc3NhZ2VzKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJ1c2VTdGF0ZSIsInVzZUhpc3RvcnlDb250ZXh0IiwiU3R5bGVkR2V0TW9yZU1lc3NhZ2VzIiwiQnV0dG9uIiwiTUlMTElTRUNPTkRTX0lOX0RBWSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJUaW1lU2NhbGVMYWJlbCIsImRheSIsIm1vbnRoIiwidHJpbWVzdGVyIiwid2VlayIsIkdldE1vcmVNZXNzYWdlcyIsInNldFNpbmNlIiwidGltZVNjYWxlIiwic2V0VGltZVNjYWxlIiwiZGlzYWJsZWQiLCJzZXREaXNhYmxlZCIsInVwZGF0ZVRpbWVTY2FsZSIsInNpbmNlIiwic2NhbGUiLCJzZXRUaW1lb3V0Iiwib25DbGljayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/GetMoreMessages.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx":
/*!******************************************************!*\
  !*** ./components/apps/Messenger/HistoryContext.tsx ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryProvider: () => (/* binding */ HistoryProvider),\n/* harmony export */   useHistoryContext: () => (/* binding */ useHistoryContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var contexts_fileSystem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! contexts/fileSystem */ \"(pages-dir-browser)/./contexts/fileSystem/index.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst HistoryContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\n_c = HistoryContext;\nconst useHistoryContext = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(HistoryContext);\n};\n_s(useHistoryContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst HistoryProvider = /*#__PURE__*/ _s1((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c1 = _s1(({ children })=>{\n    _s1();\n    const { readFile, writeFile } = (0,contexts_fileSystem__WEBPACK_IMPORTED_MODULE_3__.useFileSystem)();\n    const [timeScale, setTimeScale] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"day\");\n    const [seenEventIds, setSeenEventIds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [outgoingEvents, setOutgoingEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [profiles, setProfiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HistoryProvider.useEffect\": ()=>{\n            if (!readFile || initialized.current) return;\n            initialized.current = true;\n            readFile(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_2__.SEEN_EVENT_IDS_PATH).then({\n                \"HistoryProvider.useEffect\": (eventIds)=>{\n                    if (eventIds) {\n                        try {\n                            setSeenEventIds(JSON.parse(eventIds.toString()));\n                        } catch  {\n                        // Ignore failure to read seen events\n                        }\n                    }\n                }\n            }[\"HistoryProvider.useEffect\"]);\n        }\n    }[\"HistoryProvider.useEffect\"], [\n        readFile\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HistoryProvider.useEffect\": ()=>{\n            if (!writeFile || !initialized.current) return;\n            writeFile(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_2__.SEEN_EVENT_IDS_PATH, JSON.stringify(seenEventIds), true);\n        }\n    }[\"HistoryProvider.useEffect\"], [\n        seenEventIds,\n        writeFile\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(HistoryContext, {\n        value: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n            \"HistoryProvider.useMemo\": ()=>({\n                    outgoingEvents,\n                    profiles,\n                    seenEventIds,\n                    setOutgoingEvents,\n                    setProfiles,\n                    setSeenEventIds,\n                    setTimeScale,\n                    timeScale\n                })\n        }[\"HistoryProvider.useMemo\"], [\n            outgoingEvents,\n            profiles,\n            seenEventIds,\n            timeScale\n        ]),\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\HistoryContext.tsx\",\n        lineNumber: 65,\n        columnNumber: 5\n    }, undefined);\n}, \"/T9kwr5Aada08TR742AA/sFM/wE=\", false, function() {\n    return [\n        contexts_fileSystem__WEBPACK_IMPORTED_MODULE_3__.useFileSystem\n    ];\n})), \"/T9kwr5Aada08TR742AA/sFM/wE=\", false, function() {\n    return [\n        contexts_fileSystem__WEBPACK_IMPORTED_MODULE_3__.useFileSystem\n    ];\n});\n_c2 = HistoryProvider;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"HistoryContext\");\n$RefreshReg$(_c1, \"HistoryProvider$memo\");\n$RefreshReg$(_c2, \"HistoryProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSGlzdG9yeUNvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFRZTtBQUUyRDtBQUV0QjtBQWlCcEQsTUFBTVMsK0JBQWlCVCxvREFBYUEsQ0FBQyxDQUFDO0tBQWhDUztBQUVDLE1BQU1DLG9CQUFvQjs7SUFBZVIsT0FBQUEsaURBQVVBLENBQUNPO0FBQWMsRUFBRTtHQUE5REM7QUFFTixNQUFNQyxnQ0FBa0JWLElBQUFBLDJDQUFJQSxXQUFLLENBQUMsRUFBRVcsUUFBUSxFQUFFOztJQUNuRCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdOLGtFQUFhQTtJQUM3QyxNQUFNLENBQUNPLFdBQVdDLGFBQWEsR0FBR1YsK0NBQVFBLENBQVk7SUFDdEQsTUFBTSxDQUFDVyxjQUFjQyxnQkFBZ0IsR0FBR1osK0NBQVFBLENBQVcsRUFBRTtJQUM3RCxNQUFNLENBQUNhLGdCQUFnQkMsa0JBQWtCLEdBQUdkLCtDQUFRQSxDQUFVLEVBQUU7SUFDaEUsTUFBTSxDQUFDZSxVQUFVQyxZQUFZLEdBQUdoQiwrQ0FBUUEsQ0FBVyxDQUFDO0lBQ3BELE1BQU1pQixjQUFjbEIsNkNBQU1BLENBQUM7SUFFM0JGLGdEQUFTQTtxQ0FBQztZQUNSLElBQUksQ0FBQ1UsWUFBWVUsWUFBWUMsT0FBTyxFQUFFO1lBRXRDRCxZQUFZQyxPQUFPLEdBQUc7WUFFdEJYLFNBQVNOLG9GQUFtQkEsRUFBRWtCLElBQUk7NkNBQUMsQ0FBQ0M7b0JBQ2xDLElBQUlBLFVBQVU7d0JBQ1osSUFBSTs0QkFDRlIsZ0JBQWdCUyxLQUFLQyxLQUFLLENBQUNGLFNBQVNHLFFBQVE7d0JBQzlDLEVBQUUsT0FBTTt3QkFDTixxQ0FBcUM7d0JBQ3ZDO29CQUNGO2dCQUNGOztRQUNGO29DQUFHO1FBQUNoQjtLQUFTO0lBRWJWLGdEQUFTQTtxQ0FBQztZQUNSLElBQUksQ0FBQ1csYUFBYSxDQUFDUyxZQUFZQyxPQUFPLEVBQUU7WUFFeENWLFVBQVVQLG9GQUFtQkEsRUFBRW9CLEtBQUtHLFNBQVMsQ0FBQ2IsZUFBZTtRQUMvRDtvQ0FBRztRQUFDQTtRQUFjSDtLQUFVO0lBRTVCLHFCQUNFLDhEQUFDTDtRQUNDc0IsT0FBTzNCLDhDQUFPQTt1Q0FDWixJQUFPO29CQUNMZTtvQkFDQUU7b0JBQ0FKO29CQUNBRztvQkFDQUU7b0JBQ0FKO29CQUNBRjtvQkFDQUQ7Z0JBQ0Y7c0NBQ0E7WUFBQ0k7WUFBZ0JFO1lBQVVKO1lBQWNGO1NBQVU7a0JBR3BESDs7Ozs7O0FBR1A7O1FBaERrQ0osOERBQWFBOzs7O1FBQWJBLDhEQUFhQTs7R0FnRDVDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXGNvbXBvbmVudHNcXGFwcHNcXE1lc3NlbmdlclxcSGlzdG9yeUNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgY3JlYXRlQ29udGV4dCxcclxuICBtZW1vLFxyXG4gIHVzZUNvbnRleHQsXHJcbiAgdXNlRWZmZWN0LFxyXG4gIHVzZU1lbW8sXHJcbiAgdXNlUmVmLFxyXG4gIHVzZVN0YXRlLFxyXG59IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB0eXBlIEV2ZW50IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XHJcbmltcG9ydCB7IFNFRU5fRVZFTlRfSURTX1BBVEggfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgdHlwZSBOb3N0clByb2ZpbGUgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci90eXBlc1wiO1xyXG5pbXBvcnQgeyB1c2VGaWxlU3lzdGVtIH0gZnJvbSBcImNvbnRleHRzL2ZpbGVTeXN0ZW1cIjtcclxuXHJcbnR5cGUgUHJvZmlsZXMgPSBSZWNvcmQ8c3RyaW5nLCBOb3N0clByb2ZpbGU+O1xyXG5cclxuZXhwb3J0IHR5cGUgVGltZVNjYWxlID0gXCJkYXlcIiB8IFwid2Vla1wiIHwgXCJtb250aFwiIHwgXCJ0cmltZXN0ZXJcIiB8IFwiaW5maW5pdGVcIjtcclxuXHJcbnR5cGUgSGlzdG9yeSA9IHtcclxuICBvdXRnb2luZ0V2ZW50czogRXZlbnRbXTtcclxuICBwcm9maWxlczogUHJvZmlsZXM7XHJcbiAgc2VlbkV2ZW50SWRzOiBzdHJpbmdbXTtcclxuICBzZXRPdXRnb2luZ0V2ZW50czogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248RXZlbnRbXT4+O1xyXG4gIHNldFByb2ZpbGVzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxQcm9maWxlcz4+O1xyXG4gIHNldFNlZW5FdmVudElkczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nW10+PjtcclxuICBzZXRUaW1lU2NhbGU6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFRpbWVTY2FsZT4+O1xyXG4gIHRpbWVTY2FsZTogVGltZVNjYWxlO1xyXG59O1xyXG5cclxuY29uc3QgSGlzdG9yeUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9IGFzIEhpc3RvcnkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUhpc3RvcnlDb250ZXh0ID0gKCk6IEhpc3RvcnkgPT4gdXNlQ29udGV4dChIaXN0b3J5Q29udGV4dCk7XHJcblxyXG5leHBvcnQgY29uc3QgSGlzdG9yeVByb3ZpZGVyID0gbWVtbzxGQz4oKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSB9ID0gdXNlRmlsZVN5c3RlbSgpO1xyXG4gIGNvbnN0IFt0aW1lU2NhbGUsIHNldFRpbWVTY2FsZV0gPSB1c2VTdGF0ZTxUaW1lU2NhbGU+KFwiZGF5XCIpO1xyXG4gIGNvbnN0IFtzZWVuRXZlbnRJZHMsIHNldFNlZW5FdmVudElkc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xyXG4gIGNvbnN0IFtvdXRnb2luZ0V2ZW50cywgc2V0T3V0Z29pbmdFdmVudHNdID0gdXNlU3RhdGU8RXZlbnRbXT4oW10pO1xyXG4gIGNvbnN0IFtwcm9maWxlcywgc2V0UHJvZmlsZXNdID0gdXNlU3RhdGU8UHJvZmlsZXM+KHt9KTtcclxuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXJlYWRGaWxlIHx8IGluaXRpYWxpemVkLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICByZWFkRmlsZShTRUVOX0VWRU5UX0lEU19QQVRIKS50aGVuKChldmVudElkcykgPT4ge1xyXG4gICAgICBpZiAoZXZlbnRJZHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgc2V0U2VlbkV2ZW50SWRzKEpTT04ucGFyc2UoZXZlbnRJZHMudG9TdHJpbmcoKSkgYXMgc3RyaW5nW10pO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgLy8gSWdub3JlIGZhaWx1cmUgdG8gcmVhZCBzZWVuIGV2ZW50c1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgW3JlYWRGaWxlXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXdyaXRlRmlsZSB8fCAhaW5pdGlhbGl6ZWQuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIHdyaXRlRmlsZShTRUVOX0VWRU5UX0lEU19QQVRILCBKU09OLnN0cmluZ2lmeShzZWVuRXZlbnRJZHMpLCB0cnVlKTtcclxuICB9LCBbc2VlbkV2ZW50SWRzLCB3cml0ZUZpbGVdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxIaXN0b3J5Q29udGV4dFxyXG4gICAgICB2YWx1ZT17dXNlTWVtbyhcclxuICAgICAgICAoKSA9PiAoe1xyXG4gICAgICAgICAgb3V0Z29pbmdFdmVudHMsXHJcbiAgICAgICAgICBwcm9maWxlcyxcclxuICAgICAgICAgIHNlZW5FdmVudElkcyxcclxuICAgICAgICAgIHNldE91dGdvaW5nRXZlbnRzLFxyXG4gICAgICAgICAgc2V0UHJvZmlsZXMsXHJcbiAgICAgICAgICBzZXRTZWVuRXZlbnRJZHMsXHJcbiAgICAgICAgICBzZXRUaW1lU2NhbGUsXHJcbiAgICAgICAgICB0aW1lU2NhbGUsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgW291dGdvaW5nRXZlbnRzLCBwcm9maWxlcywgc2VlbkV2ZW50SWRzLCB0aW1lU2NhbGVdXHJcbiAgICAgICl9XHJcbiAgICA+XHJcbiAgICAgIHtjaGlsZHJlbn1cclxuICAgIDwvSGlzdG9yeUNvbnRleHQ+XHJcbiAgKTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwibWVtbyIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJTRUVOX0VWRU5UX0lEU19QQVRIIiwidXNlRmlsZVN5c3RlbSIsIkhpc3RvcnlDb250ZXh0IiwidXNlSGlzdG9yeUNvbnRleHQiLCJIaXN0b3J5UHJvdmlkZXIiLCJjaGlsZHJlbiIsInJlYWRGaWxlIiwid3JpdGVGaWxlIiwidGltZVNjYWxlIiwic2V0VGltZVNjYWxlIiwic2VlbkV2ZW50SWRzIiwic2V0U2VlbkV2ZW50SWRzIiwib3V0Z29pbmdFdmVudHMiLCJzZXRPdXRnb2luZ0V2ZW50cyIsInByb2ZpbGVzIiwic2V0UHJvZmlsZXMiLCJpbml0aWFsaXplZCIsImN1cnJlbnQiLCJ0aGVuIiwiZXZlbnRJZHMiLCJKU09OIiwicGFyc2UiLCJ0b1N0cmluZyIsInN0cmluZ2lmeSIsInZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/Icons.tsx":
/*!*********************************************!*\
  !*** ./components/apps/Messenger/Icons.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Avatar: () => (/* binding */ Avatar),\n/* harmony export */   Back: () => (/* binding */ Back),\n/* harmony export */   CheckCircle: () => (/* binding */ CheckCircle),\n/* harmony export */   CheckFullCircle: () => (/* binding */ CheckFullCircle),\n/* harmony export */   Send: () => (/* binding */ Send),\n/* harmony export */   Verified: () => (/* binding */ Verified),\n/* harmony export */   Write: () => (/* binding */ Write)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst Avatar = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        style: {\n            backgroundColor: \"#cacdd2\"\n        },\n        viewBox: \"0 0 512 512\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"M256 281.602c-151.55 0-204.8 76.796-204.8 128v76.796h409.6v-76.796c0-51.204-53.25-128-204.8-128ZM371.2 140.8c0 63.622-51.575 115.2-115.2 115.2s-115.2-51.578-115.2-115.2c0-63.624 51.575-115.198 115.2-115.198S371.2 77.176 371.2 140.8Zm0 0\",\n            fill: \"#fff\",\n            transform: \"translate(0, 50)\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n            lineNumber: 9,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 4,\n        columnNumber: 3\n    }, undefined));\n_c1 = Avatar;\nconst Write = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c2 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"0 0 24 24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                d: \"M21.1 2.9c-1.1-1.1-3-1.1-4.2 0l-8.1 7.9c-.7.7-1.2 1.6-1.4 2.6L7 15.6c-.1.3 0 .7.3.9.2.2.4.3.7.3h.2l2.2-.4c1-.2 1.9-.7 2.6-1.4l8.1-8c.6-.5.9-1.3.9-2.1s-.3-1.5-.9-2zm-9.4 10.6c-.4.4-1 .7-1.6.8l-.8.2.2-.7c.1-.6.4-1.1.9-1.6l6.2-6.1L18 7.4l-6.3 6.1zm8-7.9-.4.4-1.4-1.3.4-.4c.2-.2.5-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.6 0 .2 0 .5-.3.7z\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n                lineNumber: 19,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                d: \"M20 9.9c-.6 0-1 .4-1 1V16c0 1.7-1.3 3-3 3H8c-1.7 0-3-1.3-3-3V8c0-1.7 1.3-3 3-3h5c.6 0 1-.4 1-1s-.4-1-1-1H8C5.2 3 3 5.2 3 8v8c0 2.8 2.2 5 5 5h8c2.8 0 5-2.2 5-5v-5.1c0-.5-.4-1-1-1z\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n                lineNumber: 20,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 18,\n        columnNumber: 3\n    }, undefined));\n_c3 = Write;\nconst Send = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c4 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"0 0 24 24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m16.692 12.474-13.186.786c-.314 0-.47.157-.47.314l-1.884 6.441c-.314.786-.162 1.875.627 2.505.631.47 1.727.58 2.355.323l17.58-8.798c.942-.47 1.413-1.413 1.256-2.356a2.496 2.496 0 0 0-1.255-1.571L4.134 1.163c-.785-.263-1.727-.157-2.355.315-.784.628-.941 1.57-.627 2.513l1.883 6.441c0 .157.314.314.471.314l13.186.786s.47 0 .47.471-.47.471-.47.471Z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n            lineNumber: 26,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 25,\n        columnNumber: 3\n    }, undefined));\n_c5 = Send;\nconst Back = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c6 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"0 0 512 512\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"M244 400 100 256l144-144M120 256h292\",\n            style: {\n                fill: \"none\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeWidth: \"50px\"\n            }\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n            lineNumber: 32,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 31,\n        columnNumber: 3\n    }, undefined));\n_c7 = Back;\nconst Verified = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c8 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"-4 0 27 19\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                d: \"M7.844 17.563c1.039 1.046 2.031 1.039 3.078 0l1.172-1.172c.11-.11.203-.141.344-.141h1.656c1.476 0 2.18-.703 2.18-2.18v-1.656c0-.14.038-.242.14-.344l1.172-1.18c1.047-1.038 1.039-2.03 0-3.07l-1.172-1.172a.454.454 0 0 1-.14-.343V4.648c0-1.476-.704-2.18-2.18-2.18h-1.656a.443.443 0 0 1-.344-.14l-1.172-1.172C9.875.11 8.882.11 7.844 1.164L6.672 2.328a.443.443 0 0 1-.344.14H4.672c-1.477 0-2.18.688-2.18 2.18v1.657c0 .14-.039.242-.14.343L1.18 7.82c-1.047 1.04-1.04 2.032 0 3.07l1.172 1.18c.101.102.14.203.14.344v1.656c0 1.477.703 2.18 2.18 2.18h1.656c.14 0 .234.031.344.14l1.172 1.172Z\",\n                style: {\n                    stroke: \"currentColor\",\n                    strokeWidth: \"3px\"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n                lineNumber: 47,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                d: \"M7.844 17.563c1.039 1.046 2.031 1.039 3.078 0l1.172-1.172c.11-.11.203-.141.344-.141h1.656c1.476 0 2.18-.703 2.18-2.18v-1.656c0-.14.038-.242.14-.344l1.172-1.18c1.047-1.038 1.039-2.03 0-3.07l-1.172-1.172a.454.454 0 0 1-.14-.343V4.648c0-1.476-.704-2.18-2.18-2.18h-1.656a.443.443 0 0 1-.344-.14l-1.172-1.172C9.875.11 8.882.11 7.844 1.164L6.672 2.328a.443.443 0 0 1-.344.14H4.672c-1.477 0-2.18.688-2.18 2.18v1.657c0 .14-.039.242-.14.343L1.18 7.82c-1.047 1.04-1.04 2.032 0 3.07l1.172 1.18c.101.102.14.203.14.344v1.656c0 1.477.703 2.18 2.18 2.18h1.656c.14 0 .234.031.344.14l1.172 1.172Zm.242-4.204a.883.883 0 0 1-.664-.28l-2.5-2.798a.778.778 0 0 1-.203-.531c0-.469.336-.805.82-.805.266 0 .461.086.633.274l1.883 2.101 3.765-5.375c.188-.265.39-.375.703-.375.485 0 .829.336.829.79a.936.936 0 0 1-.18.515l-4.383 6.148a.831.831 0 0 1-.703.336Z\",\n                fill: \"#0095f6\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n                lineNumber: 54,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 46,\n        columnNumber: 3\n    }, undefined));\n_c9 = Verified;\nconst CheckCircle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c10 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"0 0 32 32\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m23.297 9.297 1.406 1.406L13 22.406l-5.703-5.703 1.406-1.406L13 19.594zM16 0q2.203 0 4.25.57t3.828 1.609 3.242 2.5 2.5 3.242 1.609 3.828.57 4.25-.57 4.25-1.609 3.828-2.5 3.242-3.242 2.5-3.828 1.609-4.25.57-4.25-.57-3.828-1.609-3.242-2.5-2.5-3.242-1.609-3.82-.57-4.258q0-2.203.57-4.25T2.18 7.921t2.5-3.242 3.242-2.5T11.742.57 16 0zm0 30q1.922 0 3.711-.5t3.344-1.414 2.836-2.195 2.195-2.836 1.414-3.336T30 16q0-1.922-.5-3.711t-1.414-3.344-2.195-2.836-2.836-2.195T19.711 2.5 16 2t-3.711.5-3.344 1.414-2.836 2.195-2.195 2.836T2.5 12.289 2 16t.5 3.711 1.414 3.344 2.195 2.836 2.836 2.195 3.336 1.414T16 30z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n            lineNumber: 63,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 62,\n        columnNumber: 3\n    }, undefined));\n_c11 = CheckCircle;\nconst CheckFullCircle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c12 = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        viewBox: \"0 0 32 32\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"M16 0q2.203 0 4.25.57t3.82 1.617 3.234 2.508 2.508 3.234 1.617 3.82.57 4.25-.57 4.25-1.617 3.82-2.508 3.234-3.234 2.508-3.82 1.617-4.25.57-4.25-.57-3.82-1.617-3.234-2.508-2.508-3.234-1.617-3.82-.57-4.25.57-4.25 1.617-3.82 2.508-3.234T7.93 2.187 11.75.57 16 0zm9.422 10.703-2.125-2.125L13 18.875l-4.297-4.297-2.125 2.125L13 23.125z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n            lineNumber: 69,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Icons.tsx\",\n        lineNumber: 68,\n        columnNumber: 3\n    }, undefined));\n_c13 = CheckFullCircle;\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13;\n$RefreshReg$(_c, \"Avatar$memo\");\n$RefreshReg$(_c1, \"Avatar\");\n$RefreshReg$(_c2, \"Write$memo\");\n$RefreshReg$(_c3, \"Write\");\n$RefreshReg$(_c4, \"Send$memo\");\n$RefreshReg$(_c5, \"Send\");\n$RefreshReg$(_c6, \"Back$memo\");\n$RefreshReg$(_c7, \"Back\");\n$RefreshReg$(_c8, \"Verified$memo\");\n$RefreshReg$(_c9, \"Verified\");\n$RefreshReg$(_c10, \"CheckCircle$memo\");\n$RefreshReg$(_c11, \"CheckCircle\");\n$RefreshReg$(_c12, \"CheckFullCircle$memo\");\n$RefreshReg$(_c13, \"CheckFullCircle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSWNvbnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUV0QixNQUFNQyx1QkFBU0QsMkNBQUlBLE1BQUMsa0JBQ3pCLDhEQUFDRTtRQUNDQyxPQUFPO1lBQUVDLGlCQUFpQjtRQUFVO1FBQ3BDQyxTQUFRO1FBQ1JDLE9BQU07a0JBRU4sNEVBQUNDO1lBQ0NDLEdBQUU7WUFDRkMsTUFBSztZQUNMQyxXQUFVOzs7Ozs7Ozs7O21CQUdiOztBQUVJLE1BQU1DLHNCQUFRWCwyQ0FBSUEsT0FBQyxrQkFDeEIsOERBQUNFO1FBQUlHLFNBQVE7UUFBWUMsT0FBTTs7MEJBQzdCLDhEQUFDQztnQkFBS0MsR0FBRTs7Ozs7OzBCQUNSLDhEQUFDRDtnQkFBS0MsR0FBRTs7Ozs7Ozs7Ozs7bUJBRVQ7O0FBRUksTUFBTUkscUJBQU9aLDJDQUFJQSxPQUFDLGtCQUN2Qiw4REFBQ0U7UUFBSUcsU0FBUTtRQUFZQyxPQUFNO2tCQUM3Qiw0RUFBQ0M7WUFBS0MsR0FBRTs7Ozs7Ozs7OzttQkFFVDs7QUFFSSxNQUFNSyxxQkFBT2IsMkNBQUlBLE9BQUMsa0JBQ3ZCLDhEQUFDRTtRQUFJRyxTQUFRO1FBQWNDLE9BQU07a0JBQy9CLDRFQUFDQztZQUNDQyxHQUFFO1lBQ0ZMLE9BQU87Z0JBQ0xNLE1BQU07Z0JBQ05LLFFBQVE7Z0JBQ1JDLGVBQWU7Z0JBQ2ZDLGdCQUFnQjtnQkFDaEJDLGFBQWE7WUFDZjs7Ozs7Ozs7OzttQkFHSDs7QUFFSSxNQUFNQyx5QkFBV2xCLDJDQUFJQSxPQUFDLGtCQUMzQiw4REFBQ0U7UUFBSUcsU0FBUTtRQUFhQyxPQUFNOzswQkFDOUIsOERBQUNDO2dCQUNDQyxHQUFFO2dCQUNGTCxPQUFPO29CQUNMVyxRQUFRO29CQUNSRyxhQUFhO2dCQUNmOzs7Ozs7MEJBRUYsOERBQUNWO2dCQUNDQyxHQUFFO2dCQUNGQyxNQUFLOzs7Ozs7Ozs7OzttQkFHUjs7QUFFSSxNQUFNVSw0QkFBY25CLDJDQUFJQSxRQUFDLGtCQUM5Qiw4REFBQ0U7UUFBSUcsU0FBUTtRQUFZQyxPQUFNO2tCQUM3Qiw0RUFBQ0M7WUFBS0MsR0FBRTs7Ozs7Ozs7OzttQkFFVDs7QUFFSSxNQUFNWSxnQ0FBa0JwQiwyQ0FBSUEsUUFBQyxrQkFDbEMsOERBQUNFO1FBQUlHLFNBQVE7UUFBWUMsT0FBTTtrQkFDN0IsNEVBQUNDO1lBQUtDLEdBQUU7Ozs7Ozs7Ozs7bUJBRVQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxJY29ucy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEF2YXRhciA9IG1lbW8oKCkgPT4gKFxyXG4gIDxzdmdcclxuICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogXCIjY2FjZGQyXCIgfX1cclxuICAgIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiXHJcbiAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICA+XHJcbiAgICA8cGF0aFxyXG4gICAgICBkPVwiTTI1NiAyODEuNjAyYy0xNTEuNTUgMC0yMDQuOCA3Ni43OTYtMjA0LjggMTI4djc2Ljc5Nmg0MDkuNnYtNzYuNzk2YzAtNTEuMjA0LTUzLjI1LTEyOC0yMDQuOC0xMjhaTTM3MS4yIDE0MC44YzAgNjMuNjIyLTUxLjU3NSAxMTUuMi0xMTUuMiAxMTUuMnMtMTE1LjItNTEuNTc4LTExNS4yLTExNS4yYzAtNjMuNjI0IDUxLjU3NS0xMTUuMTk4IDExNS4yLTExNS4xOThTMzcxLjIgNzcuMTc2IDM3MS4yIDE0MC44Wm0wIDBcIlxyXG4gICAgICBmaWxsPVwiI2ZmZlwiXHJcbiAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLCA1MClcIlxyXG4gICAgLz5cclxuICA8L3N2Zz5cclxuKSk7XHJcblxyXG5leHBvcnQgY29uc3QgV3JpdGUgPSBtZW1vKCgpID0+IChcclxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICA8cGF0aCBkPVwiTTIxLjEgMi45Yy0xLjEtMS4xLTMtMS4xLTQuMiAwbC04LjEgNy45Yy0uNy43LTEuMiAxLjYtMS40IDIuNkw3IDE1LjZjLS4xLjMgMCAuNy4zLjkuMi4yLjQuMy43LjNoLjJsMi4yLS40YzEtLjIgMS45LS43IDIuNi0xLjRsOC4xLThjLjYtLjUuOS0xLjMuOS0yLjFzLS4zLTEuNS0uOS0yem0tOS40IDEwLjZjLS40LjQtMSAuNy0xLjYuOGwtLjguMi4yLS43Yy4xLS42LjQtMS4xLjktMS42bDYuMi02LjFMMTggNy40bC02LjMgNi4xem04LTcuOS0uNC40LTEuNC0xLjMuNC0uNGMuMi0uMi41LS4zLjctLjMuMyAwIC41LjEuNy4zLjIuMi4zLjQuMy42IDAgLjIgMCAuNS0uMy43elwiIC8+XHJcbiAgICA8cGF0aCBkPVwiTTIwIDkuOWMtLjYgMC0xIC40LTEgMVYxNmMwIDEuNy0xLjMgMy0zIDNIOGMtMS43IDAtMy0xLjMtMy0zVjhjMC0xLjcgMS4zLTMgMy0zaDVjLjYgMCAxLS40IDEtMXMtLjQtMS0xLTFIOEM1LjIgMyAzIDUuMiAzIDh2OGMwIDIuOCAyLjIgNSA1IDVoOGMyLjggMCA1LTIuMiA1LTV2LTUuMWMwLS41LS40LTEtMS0xelwiIC8+XHJcbiAgPC9zdmc+XHJcbikpO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNlbmQgPSBtZW1vKCgpID0+IChcclxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICA8cGF0aCBkPVwibTE2LjY5MiAxMi40NzQtMTMuMTg2Ljc4NmMtLjMxNCAwLS40Ny4xNTctLjQ3LjMxNGwtMS44ODQgNi40NDFjLS4zMTQuNzg2LS4xNjIgMS44NzUuNjI3IDIuNTA1LjYzMS40NyAxLjcyNy41OCAyLjM1NS4zMjNsMTcuNTgtOC43OThjLjk0Mi0uNDcgMS40MTMtMS40MTMgMS4yNTYtMi4zNTZhMi40OTYgMi40OTYgMCAwIDAtMS4yNTUtMS41NzFMNC4xMzQgMS4xNjNjLS43ODUtLjI2My0xLjcyNy0uMTU3LTIuMzU1LjMxNS0uNzg0LjYyOC0uOTQxIDEuNTctLjYyNyAyLjUxM2wxLjg4MyA2LjQ0MWMwIC4xNTcuMzE0LjMxNC40NzEuMzE0bDEzLjE4Ni43ODZzLjQ3IDAgLjQ3LjQ3MS0uNDcuNDcxLS40Ny40NzFaXCIgLz5cclxuICA8L3N2Zz5cclxuKSk7XHJcblxyXG5leHBvcnQgY29uc3QgQmFjayA9IG1lbW8oKCkgPT4gKFxyXG4gIDxzdmcgdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxyXG4gICAgPHBhdGhcclxuICAgICAgZD1cIk0yNDQgNDAwIDEwMCAyNTZsMTQ0LTE0NE0xMjAgMjU2aDI5MlwiXHJcbiAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjUwcHhcIixcclxuICAgICAgfX1cclxuICAgIC8+XHJcbiAgPC9zdmc+XHJcbikpO1xyXG5cclxuZXhwb3J0IGNvbnN0IFZlcmlmaWVkID0gbWVtbygoKSA9PiAoXHJcbiAgPHN2ZyB2aWV3Qm94PVwiLTQgMCAyNyAxOVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgIDxwYXRoXHJcbiAgICAgIGQ9XCJNNy44NDQgMTcuNTYzYzEuMDM5IDEuMDQ2IDIuMDMxIDEuMDM5IDMuMDc4IDBsMS4xNzItMS4xNzJjLjExLS4xMS4yMDMtLjE0MS4zNDQtLjE0MWgxLjY1NmMxLjQ3NiAwIDIuMTgtLjcwMyAyLjE4LTIuMTh2LTEuNjU2YzAtLjE0LjAzOC0uMjQyLjE0LS4zNDRsMS4xNzItMS4xOGMxLjA0Ny0xLjAzOCAxLjAzOS0yLjAzIDAtMy4wN2wtMS4xNzItMS4xNzJhLjQ1NC40NTQgMCAwIDEtLjE0LS4zNDNWNC42NDhjMC0xLjQ3Ni0uNzA0LTIuMTgtMi4xOC0yLjE4aC0xLjY1NmEuNDQzLjQ0MyAwIDAgMS0uMzQ0LS4xNGwtMS4xNzItMS4xNzJDOS44NzUuMTEgOC44ODIuMTEgNy44NDQgMS4xNjRMNi42NzIgMi4zMjhhLjQ0My40NDMgMCAwIDEtLjM0NC4xNEg0LjY3MmMtMS40NzcgMC0yLjE4LjY4OC0yLjE4IDIuMTh2MS42NTdjMCAuMTQtLjAzOS4yNDItLjE0LjM0M0wxLjE4IDcuODJjLTEuMDQ3IDEuMDQtMS4wNCAyLjAzMiAwIDMuMDdsMS4xNzIgMS4xOGMuMTAxLjEwMi4xNC4yMDMuMTQuMzQ0djEuNjU2YzAgMS40NzcuNzAzIDIuMTggMi4xOCAyLjE4aDEuNjU2Yy4xNCAwIC4yMzQuMDMxLjM0NC4xNGwxLjE3MiAxLjE3MlpcIlxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcclxuICAgICAgICBzdHJva2VXaWR0aDogXCIzcHhcIixcclxuICAgICAgfX1cclxuICAgIC8+XHJcbiAgICA8cGF0aFxyXG4gICAgICBkPVwiTTcuODQ0IDE3LjU2M2MxLjAzOSAxLjA0NiAyLjAzMSAxLjAzOSAzLjA3OCAwbDEuMTcyLTEuMTcyYy4xMS0uMTEuMjAzLS4xNDEuMzQ0LS4xNDFoMS42NTZjMS40NzYgMCAyLjE4LS43MDMgMi4xOC0yLjE4di0xLjY1NmMwLS4xNC4wMzgtLjI0Mi4xNC0uMzQ0bDEuMTcyLTEuMThjMS4wNDctMS4wMzggMS4wMzktMi4wMyAwLTMuMDdsLTEuMTcyLTEuMTcyYS40NTQuNDU0IDAgMCAxLS4xNC0uMzQzVjQuNjQ4YzAtMS40NzYtLjcwNC0yLjE4LTIuMTgtMi4xOGgtMS42NTZhLjQ0My40NDMgMCAwIDEtLjM0NC0uMTRsLTEuMTcyLTEuMTcyQzkuODc1LjExIDguODgyLjExIDcuODQ0IDEuMTY0TDYuNjcyIDIuMzI4YS40NDMuNDQzIDAgMCAxLS4zNDQuMTRINC42NzJjLTEuNDc3IDAtMi4xOC42ODgtMi4xOCAyLjE4djEuNjU3YzAgLjE0LS4wMzkuMjQyLS4xNC4zNDNMMS4xOCA3LjgyYy0xLjA0NyAxLjA0LTEuMDQgMi4wMzIgMCAzLjA3bDEuMTcyIDEuMThjLjEwMS4xMDIuMTQuMjAzLjE0LjM0NHYxLjY1NmMwIDEuNDc3LjcwMyAyLjE4IDIuMTggMi4xOGgxLjY1NmMuMTQgMCAuMjM0LjAzMS4zNDQuMTRsMS4xNzIgMS4xNzJabS4yNDItNC4yMDRhLjg4My44ODMgMCAwIDEtLjY2NC0uMjhsLTIuNS0yLjc5OGEuNzc4Ljc3OCAwIDAgMS0uMjAzLS41MzFjMC0uNDY5LjMzNi0uODA1LjgyLS44MDUuMjY2IDAgLjQ2MS4wODYuNjMzLjI3NGwxLjg4MyAyLjEwMSAzLjc2NS01LjM3NWMuMTg4LS4yNjUuMzktLjM3NS43MDMtLjM3NS40ODUgMCAuODI5LjMzNi44MjkuNzlhLjkzNi45MzYgMCAwIDEtLjE4LjUxNWwtNC4zODMgNi4xNDhhLjgzMS44MzEgMCAwIDEtLjcwMy4zMzZaXCJcclxuICAgICAgZmlsbD1cIiMwMDk1ZjZcIlxyXG4gICAgLz5cclxuICA8L3N2Zz5cclxuKSk7XHJcblxyXG5leHBvcnQgY29uc3QgQ2hlY2tDaXJjbGUgPSBtZW1vKCgpID0+IChcclxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICA8cGF0aCBkPVwibTIzLjI5NyA5LjI5NyAxLjQwNiAxLjQwNkwxMyAyMi40MDZsLTUuNzAzLTUuNzAzIDEuNDA2LTEuNDA2TDEzIDE5LjU5NHpNMTYgMHEyLjIwMyAwIDQuMjUuNTd0My44MjggMS42MDkgMy4yNDIgMi41IDIuNSAzLjI0MiAxLjYwOSAzLjgyOC41NyA0LjI1LS41NyA0LjI1LTEuNjA5IDMuODI4LTIuNSAzLjI0Mi0zLjI0MiAyLjUtMy44MjggMS42MDktNC4yNS41Ny00LjI1LS41Ny0zLjgyOC0xLjYwOS0zLjI0Mi0yLjUtMi41LTMuMjQyLTEuNjA5LTMuODItLjU3LTQuMjU4cTAtMi4yMDMuNTctNC4yNVQyLjE4IDcuOTIxdDIuNS0zLjI0MiAzLjI0Mi0yLjVUMTEuNzQyLjU3IDE2IDB6bTAgMzBxMS45MjIgMCAzLjcxMS0uNXQzLjM0NC0xLjQxNCAyLjgzNi0yLjE5NSAyLjE5NS0yLjgzNiAxLjQxNC0zLjMzNlQzMCAxNnEwLTEuOTIyLS41LTMuNzExdC0xLjQxNC0zLjM0NC0yLjE5NS0yLjgzNi0yLjgzNi0yLjE5NVQxOS43MTEgMi41IDE2IDJ0LTMuNzExLjUtMy4zNDQgMS40MTQtMi44MzYgMi4xOTUtMi4xOTUgMi44MzZUMi41IDEyLjI4OSAyIDE2dC41IDMuNzExIDEuNDE0IDMuMzQ0IDIuMTk1IDIuODM2IDIuODM2IDIuMTk1IDMuMzM2IDEuNDE0VDE2IDMwelwiIC8+XHJcbiAgPC9zdmc+XHJcbikpO1xyXG5cclxuZXhwb3J0IGNvbnN0IENoZWNrRnVsbENpcmNsZSA9IG1lbW8oKCkgPT4gKFxyXG4gIDxzdmcgdmlld0JveD1cIjAgMCAzMiAzMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgIDxwYXRoIGQ9XCJNMTYgMHEyLjIwMyAwIDQuMjUuNTd0My44MiAxLjYxNyAzLjIzNCAyLjUwOCAyLjUwOCAzLjIzNCAxLjYxNyAzLjgyLjU3IDQuMjUtLjU3IDQuMjUtMS42MTcgMy44Mi0yLjUwOCAzLjIzNC0zLjIzNCAyLjUwOC0zLjgyIDEuNjE3LTQuMjUuNTctNC4yNS0uNTctMy44Mi0xLjYxNy0zLjIzNC0yLjUwOC0yLjUwOC0zLjIzNC0xLjYxNy0zLjgyLS41Ny00LjI1LjU3LTQuMjUgMS42MTctMy44MiAyLjUwOC0zLjIzNFQ3LjkzIDIuMTg3IDExLjc1LjU3IDE2IDB6bTkuNDIyIDEwLjcwMy0yLjEyNS0yLjEyNUwxMyAxOC44NzVsLTQuMjk3LTQuMjk3LTIuMTI1IDIuMTI1TDEzIDIzLjEyNXpcIiAvPlxyXG4gIDwvc3ZnPlxyXG4pKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJBdmF0YXIiLCJzdmciLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsInZpZXdCb3giLCJ4bWxucyIsInBhdGgiLCJkIiwiZmlsbCIsInRyYW5zZm9ybSIsIldyaXRlIiwiU2VuZCIsIkJhY2siLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VXaWR0aCIsIlZlcmlmaWVkIiwiQ2hlY2tDaXJjbGUiLCJDaGVja0Z1bGxDaXJjbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/Icons.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx":
/*!******************************************************!*\
  !*** ./components/apps/Messenger/MessageContext.tsx ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageProvider: () => (/* binding */ MessageProvider),\n/* harmony export */   useMessageContext: () => (/* binding */ useMessageContext),\n/* harmony export */   useMessages: () => (/* binding */ useMessages)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/HistoryContext */ \"(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\nconst MessageContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    events: [],\n    publicKey: \"\",\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    sendingEvent: ()=>{}\n});\n_c = MessageContext;\nconst useMessageContext = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MessageContext);\n};\n_s(useMessageContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst useMessages = (recipientPublicKey)=>{\n    _s1();\n    const { outgoingEvents } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext)();\n    const { events, publicKey } = useMessageContext();\n    const chatEvents = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrEvents)((0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.getMessages)(publicKey, recipientPublicKey));\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useMessages.useEffect\": ()=>{\n            const filteredEvents = [\n                ...chatEvents,\n                ...events.filter({\n                    \"useMessages.useEffect.filteredEvents\": ({ pubkey, tags })=>{\n                        const isSender = pubkey === recipientPublicKey;\n                        const isRecipient = (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.getKeyFromTags)(tags) === recipientPublicKey;\n                        return recipientPublicKey === publicKey ? isSender && isRecipient : isSender || isRecipient;\n                    }\n                }[\"useMessages.useEffect.filteredEvents\"])\n            ].filter({\n                \"useMessages.useEffect.filteredEvents\": (event, index, currentEvents)=>currentEvents.findIndex({\n                        \"useMessages.useEffect.filteredEvents\": ({ id })=>id === event.id\n                    }[\"useMessages.useEffect.filteredEvents\"]) === index\n            }[\"useMessages.useEffect.filteredEvents\"]);\n            const currentMessages = (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.groupChatEvents)(filteredEvents);\n            if (currentMessages.length !== messages.length || filteredEvents.length !== messages.reduce({\n                \"useMessages.useEffect\": (allMessages, [, moreMessages])=>[\n                        ...allMessages,\n                        ...moreMessages\n                    ]\n            }[\"useMessages.useEffect\"], []).length) {\n                setMessages(currentMessages);\n            }\n        }\n    }[\"useMessages.useEffect\"], [\n        chatEvents,\n        events,\n        messages,\n        publicKey,\n        recipientPublicKey\n    ]);\n    return {\n        allEventsReceived: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n            \"useMessages.useMemo\": ()=>!outgoingEvents.some({\n                    \"useMessages.useMemo\": ({ tags })=>(0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.getKeyFromTags)(tags) === recipientPublicKey\n                }[\"useMessages.useMemo\"])\n        }[\"useMessages.useMemo\"], [\n            outgoingEvents,\n            recipientPublicKey\n        ]),\n        messages\n    };\n};\n_s1(useMessages, \"uu3Zudq4G4s2ZxFDy/s1PQYgKJU=\", false, function() {\n    return [\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext,\n        useMessageContext,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrEvents\n    ];\n});\nconst MessageProvider = /*#__PURE__*/ _s2((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c1 = _s2(({ children, publicKey, since })=>{\n    _s2();\n    const chatEvents = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrEvents)((0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_3__.getMessages)(publicKey, \"\", since));\n    const { outgoingEvents, setOutgoingEvents } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext)();\n    const sendingEvent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MessageProvider.useCallback[sendingEvent]\": (event)=>setOutgoingEvents({\n                \"MessageProvider.useCallback[sendingEvent]\": (currentOutgoingEvents)=>[\n                        ...currentOutgoingEvents,\n                        event\n                    ]\n            }[\"MessageProvider.useCallback[sendingEvent]\"])\n    }[\"MessageProvider.useCallback[sendingEvent]\"], [\n        setOutgoingEvents\n    ]);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(chatEvents);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MessageProvider.useEffect\": ()=>{\n            const currentEvents = [\n                ...chatEvents,\n                ...outgoingEvents.filter({\n                    \"MessageProvider.useEffect\": (event)=>!chatEvents.some({\n                            \"MessageProvider.useEffect\": ({ id })=>id === event.id\n                        }[\"MessageProvider.useEffect\"])\n                }[\"MessageProvider.useEffect\"])\n            ];\n            if (currentEvents.length !== events.length) setEvents(currentEvents);\n        }\n    }[\"MessageProvider.useEffect\"], [\n        chatEvents,\n        events,\n        outgoingEvents\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MessageProvider.useEffect\": ()=>{\n            outgoingEvents.forEach({\n                \"MessageProvider.useEffect\": (message)=>{\n                    if (chatEvents.some({\n                        \"MessageProvider.useEffect\": ({ id })=>id === message.id\n                    }[\"MessageProvider.useEffect\"])) {\n                        setOutgoingEvents({\n                            \"MessageProvider.useEffect\": (currentOutgoingEvents)=>currentOutgoingEvents.filter({\n                                    \"MessageProvider.useEffect\": ({ id })=>id !== message.id\n                                }[\"MessageProvider.useEffect\"])\n                        }[\"MessageProvider.useEffect\"]);\n                    }\n                }\n            }[\"MessageProvider.useEffect\"]);\n        }\n    }[\"MessageProvider.useEffect\"], [\n        chatEvents,\n        outgoingEvents,\n        setOutgoingEvents\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MessageContext, {\n        value: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n            \"MessageProvider.useMemo\": ()=>({\n                    events,\n                    publicKey,\n                    sendingEvent\n                })\n        }[\"MessageProvider.useMemo\"], [\n            events,\n            publicKey,\n            sendingEvent\n        ]),\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\MessageContext.tsx\",\n        lineNumber: 129,\n        columnNumber: 7\n    }, undefined);\n}, \"4vZpNb5r09Xe50tqpgS3tO3g3ns=\", false, function() {\n    return [\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrEvents,\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext\n    ];\n})), \"4vZpNb5r09Xe50tqpgS3tO3g3ns=\", false, function() {\n    return [\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNostrEvents,\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext\n    ];\n});\n_c2 = MessageProvider;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"MessageContext\");\n$RefreshReg$(_c1, \"MessageProvider$memo\");\n$RefreshReg$(_c2, \"MessageProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvTWVzc2FnZUNvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQVFlO0FBRThEO0FBS2hDO0FBQ29CO0FBY2pFLE1BQU1ZLCtCQUFpQlosb0RBQWFBLENBQUM7SUFDbkNhLFFBQVEsRUFBRTtJQUNWQyxXQUFXO0lBQ1gsZ0VBQWdFO0lBQ2hFQyxjQUFjLEtBQU87QUFDdkI7S0FMTUg7QUFPQyxNQUFNSSxvQkFBb0I7O0lBQy9CYixPQUFBQSxpREFBVUEsQ0FBQ1M7QUFBYyxFQUFFO0dBRGhCSTtBQUdOLE1BQU1DLGNBQWMsQ0FBQ0M7O0lBQzFCLE1BQU0sRUFBRUMsY0FBYyxFQUFFLEdBQUdaLDJGQUFpQkE7SUFDNUMsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRTtJQUM5QixNQUFNSSxhQUFhVCwrRUFBY0EsQ0FBQ0YsZ0ZBQVdBLENBQUNLLFdBQVdJO0lBQ3pELE1BQU0sQ0FBQ0csVUFBVUMsWUFBWSxHQUFHaEIsK0NBQVFBLENBQWEsRUFBRTtJQUV2REYsZ0RBQVNBO2lDQUFDO1lBQ1IsTUFBTW1CLGlCQUFpQjttQkFDbEJIO21CQUNBUCxPQUFPVyxNQUFNOzREQUFDLENBQUMsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUU7d0JBQ2hDLE1BQU1DLFdBQVdGLFdBQVdQO3dCQUM1QixNQUFNVSxjQUFjcEIsbUZBQWNBLENBQUNrQixVQUFVUjt3QkFFN0MsT0FBT0EsdUJBQXVCSixZQUMxQmEsWUFBWUMsY0FDWkQsWUFBWUM7b0JBQ2xCOzthQUNELENBQUNKLE1BQU07d0RBQ04sQ0FBQ0ssT0FBT0MsT0FBT0MsZ0JBQ2JBLGNBQWNDLFNBQVM7Z0VBQUMsQ0FBQyxFQUFFQyxFQUFFLEVBQUUsR0FBS0EsT0FBT0osTUFBTUksRUFBRTttRUFBTUg7O1lBRTdELE1BQU1JLGtCQUFrQnhCLG9GQUFlQSxDQUFDYTtZQUV4QyxJQUNFVyxnQkFBZ0JDLE1BQU0sS0FBS2QsU0FBU2MsTUFBTSxJQUMxQ1osZUFBZVksTUFBTSxLQUNuQmQsU0FBU2UsTUFBTTt5Q0FDYixDQUFDQyxhQUFhLEdBQUdDLGFBQWEsR0FBSzsyQkFBSUQ7MkJBQWdCQztxQkFBYTt3Q0FDcEUsRUFBRSxFQUNGSCxNQUFNLEVBQ1Y7Z0JBQ0FiLFlBQVlZO1lBQ2Q7UUFDRjtnQ0FBRztRQUFDZDtRQUFZUDtRQUFRUTtRQUFVUDtRQUFXSTtLQUFtQjtJQUVoRSxPQUFPO1FBQ0xxQixtQkFBbUJsQyw4Q0FBT0E7bUNBQ3hCLElBQ0UsQ0FBQ2MsZUFBZXFCLElBQUk7MkNBQ2xCLENBQUMsRUFBRWQsSUFBSSxFQUFFLEdBQUtsQixtRkFBY0EsQ0FBQ2tCLFVBQVVSOztrQ0FFM0M7WUFBQ0M7WUFBZ0JEO1NBQW1CO1FBRXRDRztJQUNGO0FBQ0YsRUFBRTtJQTdDV0o7O1FBQ2dCVix1RkFBaUJBO1FBQ2RTO1FBQ1hMLDJFQUFjQTs7O0FBaUQ1QixNQUFNOEIsZ0NBQWtCeEMsSUFBQUEsMkNBQUlBLFdBQ2pDLENBQUMsRUFBRXlDLFFBQVEsRUFBRTVCLFNBQVMsRUFBRTZCLEtBQUssRUFBRTs7SUFDN0IsTUFBTXZCLGFBQWFULCtFQUFjQSxDQUFDRixnRkFBV0EsQ0FBQ0ssV0FBVyxJQUFJNkI7SUFDN0QsTUFBTSxFQUFFeEIsY0FBYyxFQUFFeUIsaUJBQWlCLEVBQUUsR0FBR3JDLDJGQUFpQkE7SUFDL0QsTUFBTVEsZUFBZWIsa0RBQVdBO3FEQUM5QixDQUFDMkIsUUFDQ2U7NkRBQWtCLENBQUNDLHdCQUEwQjsyQkFDeENBO3dCQUNIaEI7cUJBQ0Q7O29EQUNIO1FBQUNlO0tBQWtCO0lBRXJCLE1BQU0sQ0FBQy9CLFFBQVFpQyxVQUFVLEdBQUd4QywrQ0FBUUEsQ0FBVWM7SUFFOUNoQixnREFBU0E7cUNBQUM7WUFDUixNQUFNMkIsZ0JBQWdCO21CQUNqQlg7bUJBQ0FELGVBQWVLLE1BQU07aURBQ3RCLENBQUNLLFFBQVUsQ0FBQ1QsV0FBV29CLElBQUk7eURBQUMsQ0FBQyxFQUFFUCxFQUFFLEVBQUUsR0FBS0EsT0FBT0osTUFBTUksRUFBRTs7O2FBRTFEO1lBRUQsSUFBSUYsY0FBY0ksTUFBTSxLQUFLdEIsT0FBT3NCLE1BQU0sRUFBRVcsVUFBVWY7UUFDeEQ7b0NBQUc7UUFBQ1g7UUFBWVA7UUFBUU07S0FBZTtJQUV2Q2YsZ0RBQVNBO3FDQUFDO1lBQ1JlLGVBQWU0QixPQUFPOzZDQUFDLENBQUNDO29CQUN0QixJQUFJNUIsV0FBV29CLElBQUk7cURBQUMsQ0FBQyxFQUFFUCxFQUFFLEVBQUUsR0FBS0EsT0FBT2UsUUFBUWYsRUFBRTtxREFBRzt3QkFDbERXO3lEQUFrQixDQUFDQyx3QkFDakJBLHNCQUFzQnJCLE1BQU07aUVBQUMsQ0FBQyxFQUFFUyxFQUFFLEVBQUUsR0FBS0EsT0FBT2UsUUFBUWYsRUFBRTs7O29CQUU5RDtnQkFDRjs7UUFDRjtvQ0FBRztRQUFDYjtRQUFZRDtRQUFnQnlCO0tBQWtCO0lBRWxELHFCQUNFLDhEQUFDaEM7UUFDQ3FDLE9BQU81Qyw4Q0FBT0E7dUNBQ1osSUFBTztvQkFDTFE7b0JBQ0FDO29CQUNBQztnQkFDRjtzQ0FDQTtZQUFDRjtZQUFRQztZQUFXQztTQUFhO2tCQUdsQzJCOzs7Ozs7QUFHUDs7UUEvQ3FCL0IsMkVBQWNBO1FBQ2FKLHVGQUFpQkE7Ozs7UUFENUNJLDJFQUFjQTtRQUNhSix1RkFBaUJBOztHQStDakUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxNZXNzYWdlQ29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBjcmVhdGVDb250ZXh0LFxyXG4gIG1lbW8sXHJcbiAgdXNlQ2FsbGJhY2ssXHJcbiAgdXNlQ29udGV4dCxcclxuICB1c2VFZmZlY3QsXHJcbiAgdXNlTWVtbyxcclxuICB1c2VTdGF0ZSxcclxufSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdHlwZSBFdmVudCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xyXG5pbXBvcnQgeyB1c2VIaXN0b3J5Q29udGV4dCB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL0hpc3RvcnlDb250ZXh0XCI7XHJcbmltcG9ydCB7XHJcbiAgZ2V0S2V5RnJvbVRhZ3MsXHJcbiAgZ2V0TWVzc2FnZXMsXHJcbiAgZ3JvdXBDaGF0RXZlbnRzLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQgeyB1c2VOb3N0ckV2ZW50cyB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2hvb2tzXCI7XHJcbmltcG9ydCB7IHR5cGUgQ2hhdEV2ZW50cyB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL3R5cGVzXCI7XHJcblxyXG50eXBlIE1lc3NhZ2VEYXRhID0ge1xyXG4gIGFsbEV2ZW50c1JlY2VpdmVkOiBib29sZWFuO1xyXG4gIG1lc3NhZ2VzOiBDaGF0RXZlbnRzO1xyXG59O1xyXG5cclxudHlwZSBNZXNzYWdlc1N0YXRlID0ge1xyXG4gIGV2ZW50czogRXZlbnRbXTtcclxuICBwdWJsaWNLZXk6IHN0cmluZztcclxuICBzZW5kaW5nRXZlbnQ6IChldmVudDogRXZlbnQpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5jb25zdCBNZXNzYWdlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xyXG4gIGV2ZW50czogW10sXHJcbiAgcHVibGljS2V5OiBcIlwiLFxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cclxuICBzZW5kaW5nRXZlbnQ6ICgpID0+IHt9LFxyXG59IGFzIE1lc3NhZ2VzU3RhdGUpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZU1lc3NhZ2VDb250ZXh0ID0gKCk6IE1lc3NhZ2VzU3RhdGUgPT5cclxuICB1c2VDb250ZXh0KE1lc3NhZ2VDb250ZXh0KTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VNZXNzYWdlcyA9IChyZWNpcGllbnRQdWJsaWNLZXk6IHN0cmluZyk6IE1lc3NhZ2VEYXRhID0+IHtcclxuICBjb25zdCB7IG91dGdvaW5nRXZlbnRzIH0gPSB1c2VIaXN0b3J5Q29udGV4dCgpO1xyXG4gIGNvbnN0IHsgZXZlbnRzLCBwdWJsaWNLZXkgfSA9IHVzZU1lc3NhZ2VDb250ZXh0KCk7XHJcbiAgY29uc3QgY2hhdEV2ZW50cyA9IHVzZU5vc3RyRXZlbnRzKGdldE1lc3NhZ2VzKHB1YmxpY0tleSwgcmVjaXBpZW50UHVibGljS2V5KSk7XHJcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxDaGF0RXZlbnRzPihbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IFtcclxuICAgICAgLi4uY2hhdEV2ZW50cyxcclxuICAgICAgLi4uZXZlbnRzLmZpbHRlcigoeyBwdWJrZXksIHRhZ3MgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzU2VuZGVyID0gcHVia2V5ID09PSByZWNpcGllbnRQdWJsaWNLZXk7XHJcbiAgICAgICAgY29uc3QgaXNSZWNpcGllbnQgPSBnZXRLZXlGcm9tVGFncyh0YWdzKSA9PT0gcmVjaXBpZW50UHVibGljS2V5O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVjaXBpZW50UHVibGljS2V5ID09PSBwdWJsaWNLZXlcclxuICAgICAgICAgID8gaXNTZW5kZXIgJiYgaXNSZWNpcGllbnRcclxuICAgICAgICAgIDogaXNTZW5kZXIgfHwgaXNSZWNpcGllbnQ7XHJcbiAgICAgIH0pLFxyXG4gICAgXS5maWx0ZXIoXHJcbiAgICAgIChldmVudCwgaW5kZXgsIGN1cnJlbnRFdmVudHMpID0+XHJcbiAgICAgICAgY3VycmVudEV2ZW50cy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gaWQgPT09IGV2ZW50LmlkKSA9PT0gaW5kZXhcclxuICAgICk7XHJcbiAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBncm91cENoYXRFdmVudHMoZmlsdGVyZWRFdmVudHMpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgY3VycmVudE1lc3NhZ2VzLmxlbmd0aCAhPT0gbWVzc2FnZXMubGVuZ3RoIHx8XHJcbiAgICAgIGZpbHRlcmVkRXZlbnRzLmxlbmd0aCAhPT1cclxuICAgICAgICBtZXNzYWdlcy5yZWR1Y2U8RXZlbnRbXT4oXHJcbiAgICAgICAgICAoYWxsTWVzc2FnZXMsIFssIG1vcmVNZXNzYWdlc10pID0+IFsuLi5hbGxNZXNzYWdlcywgLi4ubW9yZU1lc3NhZ2VzXSxcclxuICAgICAgICAgIFtdXHJcbiAgICAgICAgKS5sZW5ndGhcclxuICAgICkge1xyXG4gICAgICBzZXRNZXNzYWdlcyhjdXJyZW50TWVzc2FnZXMpO1xyXG4gICAgfVxyXG4gIH0sIFtjaGF0RXZlbnRzLCBldmVudHMsIG1lc3NhZ2VzLCBwdWJsaWNLZXksIHJlY2lwaWVudFB1YmxpY0tleV0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYWxsRXZlbnRzUmVjZWl2ZWQ6IHVzZU1lbW8oXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgIW91dGdvaW5nRXZlbnRzLnNvbWUoXHJcbiAgICAgICAgICAoeyB0YWdzIH0pID0+IGdldEtleUZyb21UYWdzKHRhZ3MpID09PSByZWNpcGllbnRQdWJsaWNLZXlcclxuICAgICAgICApLFxyXG4gICAgICBbb3V0Z29pbmdFdmVudHMsIHJlY2lwaWVudFB1YmxpY0tleV1cclxuICAgICksXHJcbiAgICBtZXNzYWdlcyxcclxuICB9O1xyXG59O1xyXG5cclxudHlwZSBNZXNzYWdlUHJvdmlkZXJQcm9wcyA9IHtcclxuICBwdWJsaWNLZXk6IHN0cmluZztcclxuICBzaW5jZT86IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBNZXNzYWdlUHJvdmlkZXIgPSBtZW1vPEZDPE1lc3NhZ2VQcm92aWRlclByb3BzPj4oXHJcbiAgKHsgY2hpbGRyZW4sIHB1YmxpY0tleSwgc2luY2UgfSkgPT4ge1xyXG4gICAgY29uc3QgY2hhdEV2ZW50cyA9IHVzZU5vc3RyRXZlbnRzKGdldE1lc3NhZ2VzKHB1YmxpY0tleSwgXCJcIiwgc2luY2UpKTtcclxuICAgIGNvbnN0IHsgb3V0Z29pbmdFdmVudHMsIHNldE91dGdvaW5nRXZlbnRzIH0gPSB1c2VIaXN0b3J5Q29udGV4dCgpO1xyXG4gICAgY29uc3Qgc2VuZGluZ0V2ZW50ID0gdXNlQ2FsbGJhY2soXHJcbiAgICAgIChldmVudDogRXZlbnQpID0+XHJcbiAgICAgICAgc2V0T3V0Z29pbmdFdmVudHMoKGN1cnJlbnRPdXRnb2luZ0V2ZW50cykgPT4gW1xyXG4gICAgICAgICAgLi4uY3VycmVudE91dGdvaW5nRXZlbnRzLFxyXG4gICAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgXSksXHJcbiAgICAgIFtzZXRPdXRnb2luZ0V2ZW50c11cclxuICAgICk7XHJcbiAgICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGU8RXZlbnRbXT4oY2hhdEV2ZW50cyk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgY3VycmVudEV2ZW50cyA9IFtcclxuICAgICAgICAuLi5jaGF0RXZlbnRzLFxyXG4gICAgICAgIC4uLm91dGdvaW5nRXZlbnRzLmZpbHRlcihcclxuICAgICAgICAgIChldmVudCkgPT4gIWNoYXRFdmVudHMuc29tZSgoeyBpZCB9KSA9PiBpZCA9PT0gZXZlbnQuaWQpXHJcbiAgICAgICAgKSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50RXZlbnRzLmxlbmd0aCAhPT0gZXZlbnRzLmxlbmd0aCkgc2V0RXZlbnRzKGN1cnJlbnRFdmVudHMpO1xyXG4gICAgfSwgW2NoYXRFdmVudHMsIGV2ZW50cywgb3V0Z29pbmdFdmVudHNdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBvdXRnb2luZ0V2ZW50cy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYXRFdmVudHMuc29tZSgoeyBpZCB9KSA9PiBpZCA9PT0gbWVzc2FnZS5pZCkpIHtcclxuICAgICAgICAgIHNldE91dGdvaW5nRXZlbnRzKChjdXJyZW50T3V0Z29pbmdFdmVudHMpID0+XHJcbiAgICAgICAgICAgIGN1cnJlbnRPdXRnb2luZ0V2ZW50cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IG1lc3NhZ2UuaWQpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9LCBbY2hhdEV2ZW50cywgb3V0Z29pbmdFdmVudHMsIHNldE91dGdvaW5nRXZlbnRzXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPE1lc3NhZ2VDb250ZXh0XHJcbiAgICAgICAgdmFsdWU9e3VzZU1lbW8oXHJcbiAgICAgICAgICAoKSA9PiAoe1xyXG4gICAgICAgICAgICBldmVudHMsXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICAgICAgc2VuZGluZ0V2ZW50LFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICBbZXZlbnRzLCBwdWJsaWNLZXksIHNlbmRpbmdFdmVudF1cclxuICAgICAgICApfVxyXG4gICAgICA+XHJcbiAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICA8L01lc3NhZ2VDb250ZXh0PlxyXG4gICAgKTtcclxuICB9XHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwibWVtbyIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZUhpc3RvcnlDb250ZXh0IiwiZ2V0S2V5RnJvbVRhZ3MiLCJnZXRNZXNzYWdlcyIsImdyb3VwQ2hhdEV2ZW50cyIsInVzZU5vc3RyRXZlbnRzIiwiTWVzc2FnZUNvbnRleHQiLCJldmVudHMiLCJwdWJsaWNLZXkiLCJzZW5kaW5nRXZlbnQiLCJ1c2VNZXNzYWdlQ29udGV4dCIsInVzZU1lc3NhZ2VzIiwicmVjaXBpZW50UHVibGljS2V5Iiwib3V0Z29pbmdFdmVudHMiLCJjaGF0RXZlbnRzIiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImZpbHRlcmVkRXZlbnRzIiwiZmlsdGVyIiwicHVia2V5IiwidGFncyIsImlzU2VuZGVyIiwiaXNSZWNpcGllbnQiLCJldmVudCIsImluZGV4IiwiY3VycmVudEV2ZW50cyIsImZpbmRJbmRleCIsImlkIiwiY3VycmVudE1lc3NhZ2VzIiwibGVuZ3RoIiwicmVkdWNlIiwiYWxsTWVzc2FnZXMiLCJtb3JlTWVzc2FnZXMiLCJhbGxFdmVudHNSZWNlaXZlZCIsInNvbWUiLCJNZXNzYWdlUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNpbmNlIiwic2V0T3V0Z29pbmdFdmVudHMiLCJjdXJyZW50T3V0Z29pbmdFdmVudHMiLCJzZXRFdmVudHMiLCJmb3JFYWNoIiwibWVzc2FnZSIsInZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx":
/*!****************************************************!*\
  !*** ./components/apps/Messenger/NostrContext.tsx ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NostrProvider: () => (/* binding */ NostrProvider),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nostr-tools */ \"(pages-dir-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n/* eslint-disable @typescript-eslint/no-empty-function */ const NostrContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({\n    connectToRelays: ()=>{},\n    connectedRelays: [],\n    publish: ()=>{}\n});\n_c = NostrContext;\n/* eslint-enable @typescript-eslint/no-empty-function */ const useNostr = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(NostrContext);\n};\n_s(useNostr, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst NostrProviderFC = ({ children, relayUrls })=>{\n    _s1();\n    const [connectedRelays, setConnectedRelays] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [knownRelays, setKnownRelays] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const disconnectToRelays = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"NostrProviderFC.useCallback[disconnectToRelays]\": (urls)=>{\n            if (urls.length === 0) return;\n            setConnectedRelays({\n                \"NostrProviderFC.useCallback[disconnectToRelays]\": (currentConnectedRelays)=>{\n                    const newConnectedRelays = {\n                        ...currentConnectedRelays\n                    };\n                    urls.forEach({\n                        \"NostrProviderFC.useCallback[disconnectToRelays]\": (url)=>{\n                            newConnectedRelays[url]?.close();\n                            delete newConnectedRelays[url];\n                        }\n                    }[\"NostrProviderFC.useCallback[disconnectToRelays]\"]);\n                    return newConnectedRelays;\n                }\n            }[\"NostrProviderFC.useCallback[disconnectToRelays]\"]);\n        }\n    }[\"NostrProviderFC.useCallback[disconnectToRelays]\"], []);\n    const connectToRelays = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"NostrProviderFC.useCallback[connectToRelays]\": (urls)=>urls.forEach({\n                \"NostrProviderFC.useCallback[connectToRelays]\": (url)=>{\n                    if (connectedRelays[url]) return;\n                    const relay = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_1__.relayInit)(url);\n                    relay.on(\"connect\", {\n                        \"NostrProviderFC.useCallback[connectToRelays]\": ()=>setConnectedRelays({\n                                \"NostrProviderFC.useCallback[connectToRelays]\": (currentConnectedRelays)=>({\n                                        ...currentConnectedRelays,\n                                        [url]: relay\n                                    })\n                            }[\"NostrProviderFC.useCallback[connectToRelays]\"])\n                    }[\"NostrProviderFC.useCallback[connectToRelays]\"]);\n                    relay.on(\"disconnect\", {\n                        \"NostrProviderFC.useCallback[connectToRelays]\": ()=>setConnectedRelays({\n                                \"NostrProviderFC.useCallback[connectToRelays]\": ({ [url]: _previouslyConnectedRelay, ...newConnectedRelays })=>newConnectedRelays\n                            }[\"NostrProviderFC.useCallback[connectToRelays]\"])\n                    }[\"NostrProviderFC.useCallback[connectToRelays]\"]);\n                    relay.on(\"error\", console.error);\n                    relay.connect();\n                }\n            }[\"NostrProviderFC.useCallback[connectToRelays]\"])\n    }[\"NostrProviderFC.useCallback[connectToRelays]\"], [\n        connectedRelays\n    ]);\n    const publish = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"NostrProviderFC.useCallback[publish]\": (event)=>Object.values(connectedRelays).forEach({\n                \"NostrProviderFC.useCallback[publish]\": (relay)=>relay.publish(event)\n            }[\"NostrProviderFC.useCallback[publish]\"])\n    }[\"NostrProviderFC.useCallback[publish]\"], [\n        connectedRelays\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"NostrProviderFC.useEffect\": ()=>{\n            if (relayUrls.length === knownRelays.length && relayUrls.every({\n                \"NostrProviderFC.useEffect\": (url)=>knownRelays.includes(url)\n            }[\"NostrProviderFC.useEffect\"])) {\n                return;\n            }\n            disconnectToRelays(knownRelays.filter({\n                \"NostrProviderFC.useEffect\": (url)=>!relayUrls.includes(url)\n            }[\"NostrProviderFC.useEffect\"]));\n            connectToRelays(relayUrls);\n            setKnownRelays(relayUrls);\n        }\n    }[\"NostrProviderFC.useEffect\"], [\n        connectToRelays,\n        disconnectToRelays,\n        knownRelays,\n        relayUrls\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrContext, {\n        value: (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)({\n            \"NostrProviderFC.useMemo\": ()=>({\n                    connectToRelays,\n                    connectedRelays: Object.values(connectedRelays),\n                    publish\n                })\n        }[\"NostrProviderFC.useMemo\"], [\n            connectToRelays,\n            connectedRelays,\n            publish\n        ]),\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\NostrContext.tsx\",\n        lineNumber: 95,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(NostrProviderFC, \"QNhOn7RCkmWY6g5httibzqCPLm0=\");\n_c1 = NostrProviderFC;\nconst NostrProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(NostrProviderFC);\n_c2 = NostrProvider;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"NostrContext\");\n$RefreshReg$(_c1, \"NostrProviderFC\");\n$RefreshReg$(_c2, \"NostrProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvTm9zdHJDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOEU7QUFTL0Q7QUFRZix1REFBdUQsR0FDdkQsTUFBTVEsNkJBQWVQLG9EQUFhQSxDQUFtQjtJQUNuRFEsaUJBQWlCLEtBQU87SUFDeEJDLGlCQUFpQixFQUFFO0lBQ25CQyxTQUFTLEtBQU87QUFDbEI7S0FKTUg7QUFLTixzREFBc0QsR0FFL0MsTUFBTUksV0FBVzs7SUFBd0JSLE9BQUFBLGlEQUFVQSxDQUFDSTtBQUFZLEVBQUU7R0FBNURJO0FBRWIsTUFBTUMsa0JBQStDLENBQUMsRUFDcERDLFFBQVEsRUFDUkMsU0FBUyxFQUNWOztJQUNDLE1BQU0sQ0FBQ0wsaUJBQWlCTSxtQkFBbUIsR0FBR1QsK0NBQVFBLENBQ3BELENBQUM7SUFFSCxNQUFNLENBQUNVLGFBQWFDLGVBQWUsR0FBR1gsK0NBQVFBLENBQVcsRUFBRTtJQUMzRCxNQUFNWSxxQkFBcUJoQixrREFBV0E7MkRBQUMsQ0FBQ2lCO1lBQ3RDLElBQUlBLEtBQUtDLE1BQU0sS0FBSyxHQUFHO1lBRXZCTDttRUFBbUIsQ0FBQ007b0JBQ2xCLE1BQU1DLHFCQUFxQjt3QkFBRSxHQUFHRCxzQkFBc0I7b0JBQUM7b0JBRXZERixLQUFLSSxPQUFPOzJFQUFDLENBQUNDOzRCQUNaRixrQkFBa0IsQ0FBQ0UsSUFBSSxFQUFFQzs0QkFDekIsT0FBT0gsa0JBQWtCLENBQUNFLElBQUk7d0JBQ2hDOztvQkFFQSxPQUFPRjtnQkFDVDs7UUFDRjswREFBRyxFQUFFO0lBQ0wsTUFBTWQsa0JBQWtCTixrREFBV0E7d0RBQ2pDLENBQUNpQixPQUNDQSxLQUFLSSxPQUFPO2dFQUFDLENBQUNDO29CQUNaLElBQUlmLGVBQWUsQ0FBQ2UsSUFBSSxFQUFFO29CQUUxQixNQUFNRSxRQUFRM0Isc0RBQVNBLENBQUN5QjtvQkFFeEJFLE1BQU1DLEVBQUUsQ0FBQzt3RUFBVyxJQUNsQlo7Z0ZBQW1CLENBQUNNLHlCQUE0Qjt3Q0FDOUMsR0FBR0Esc0JBQXNCO3dDQUN6QixDQUFDRyxJQUFJLEVBQUVFO29DQUNUOzs7b0JBRUZBLE1BQU1DLEVBQUUsQ0FBQzt3RUFBYyxJQUNyQlo7Z0ZBQ0UsQ0FBQyxFQUFFLENBQUNTLElBQUksRUFBRUkseUJBQXlCLEVBQUUsR0FBR04sb0JBQW9CLEdBQzFEQTs7O29CQUdOSSxNQUFNQyxFQUFFLENBQUMsU0FBU0UsUUFBUUMsS0FBSztvQkFDL0JKLE1BQU1LLE9BQU87Z0JBQ2Y7O3VEQUNGO1FBQUN0QjtLQUFnQjtJQUVuQixNQUFNQyxVQUFVUixrREFBV0E7Z0RBQ3pCLENBQUM4QixRQUNDQyxPQUFPQyxNQUFNLENBQUN6QixpQkFBaUJjLE9BQU87d0RBQUMsQ0FBQ0csUUFBVUEsTUFBTWhCLE9BQU8sQ0FBQ3NCOzsrQ0FDbEU7UUFBQ3ZCO0tBQWdCO0lBR25CTCxnREFBU0E7cUNBQUM7WUFDUixJQUNFVSxVQUFVTSxNQUFNLEtBQUtKLFlBQVlJLE1BQU0sSUFDdkNOLFVBQVVxQixLQUFLOzZDQUFDLENBQUNYLE1BQVFSLFlBQVlvQixRQUFRLENBQUNaOzZDQUM5QztnQkFDQTtZQUNGO1lBRUFOLG1CQUFtQkYsWUFBWXFCLE1BQU07NkNBQUMsQ0FBQ2IsTUFBUSxDQUFDVixVQUFVc0IsUUFBUSxDQUFDWjs7WUFDbkVoQixnQkFBZ0JNO1lBRWhCRyxlQUFlSDtRQUNqQjtvQ0FBRztRQUFDTjtRQUFpQlU7UUFBb0JGO1FBQWFGO0tBQVU7SUFFaEUscUJBQ0UsOERBQUNQO1FBQ0MrQixPQUFPakMsOENBQU9BO3VDQUNaLElBQU87b0JBQ0xHO29CQUNBQyxpQkFBaUJ3QixPQUFPQyxNQUFNLENBQUN6QjtvQkFDL0JDO2dCQUNGO3NDQUNBO1lBQUNGO1lBQWlCQztZQUFpQkM7U0FBUTtrQkFHNUNHOzs7Ozs7QUFHUDtJQWhGTUQ7TUFBQUE7QUFrRkMsTUFBTTJCLDhCQUFnQnRDLDJDQUFJQSxDQUFDVyxpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxOb3N0ckNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgRXZlbnQgYXMgTm9zdHJFdmVudCwgdHlwZSBSZWxheSwgcmVsYXlJbml0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlQ29udGV4dCxcclxuICBtZW1vLFxyXG4gIHVzZUNhbGxiYWNrLFxyXG4gIHVzZUNvbnRleHQsXHJcbiAgdXNlRWZmZWN0LFxyXG4gIHVzZU1lbW8sXHJcbiAgdXNlU3RhdGUsXHJcbn0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5pbnRlcmZhY2UgTm9zdHJDb250ZXh0VHlwZSB7XHJcbiAgY29ubmVjdFRvUmVsYXlzOiAodXJsczogc3RyaW5nW10pID0+IHZvaWQ7XHJcbiAgY29ubmVjdGVkUmVsYXlzOiBSZWxheVtdO1xyXG4gIHB1Ymxpc2g6IChldmVudDogTm9zdHJFdmVudCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXHJcbmNvbnN0IE5vc3RyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Tm9zdHJDb250ZXh0VHlwZT4oe1xyXG4gIGNvbm5lY3RUb1JlbGF5czogKCkgPT4ge30sXHJcbiAgY29ubmVjdGVkUmVsYXlzOiBbXSxcclxuICBwdWJsaXNoOiAoKSA9PiB7fSxcclxufSk7XHJcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXHJcblxyXG5leHBvcnQgY29uc3QgdXNlTm9zdHIgPSAoKTogTm9zdHJDb250ZXh0VHlwZSA9PiB1c2VDb250ZXh0KE5vc3RyQ29udGV4dCk7XHJcblxyXG5jb25zdCBOb3N0clByb3ZpZGVyRkM6IEZDPHsgcmVsYXlVcmxzOiBzdHJpbmdbXSB9PiA9ICh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgcmVsYXlVcmxzLFxyXG59KSA9PiB7XHJcbiAgY29uc3QgW2Nvbm5lY3RlZFJlbGF5cywgc2V0Q29ubmVjdGVkUmVsYXlzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIFJlbGF5Pj4oXHJcbiAgICB7fVxyXG4gICk7XHJcbiAgY29uc3QgW2tub3duUmVsYXlzLCBzZXRLbm93blJlbGF5c10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xyXG4gIGNvbnN0IGRpc2Nvbm5lY3RUb1JlbGF5cyA9IHVzZUNhbGxiYWNrKCh1cmxzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgaWYgKHVybHMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgc2V0Q29ubmVjdGVkUmVsYXlzKChjdXJyZW50Q29ubmVjdGVkUmVsYXlzKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5ld0Nvbm5lY3RlZFJlbGF5cyA9IHsgLi4uY3VycmVudENvbm5lY3RlZFJlbGF5cyB9O1xyXG5cclxuICAgICAgdXJscy5mb3JFYWNoKCh1cmwpID0+IHtcclxuICAgICAgICBuZXdDb25uZWN0ZWRSZWxheXNbdXJsXT8uY2xvc2UoKTtcclxuICAgICAgICBkZWxldGUgbmV3Q29ubmVjdGVkUmVsYXlzW3VybF07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG5ld0Nvbm5lY3RlZFJlbGF5cztcclxuICAgIH0pO1xyXG4gIH0sIFtdKTtcclxuICBjb25zdCBjb25uZWN0VG9SZWxheXMgPSB1c2VDYWxsYmFjayhcclxuICAgICh1cmxzOiBzdHJpbmdbXSkgPT5cclxuICAgICAgdXJscy5mb3JFYWNoKCh1cmwpID0+IHtcclxuICAgICAgICBpZiAoY29ubmVjdGVkUmVsYXlzW3VybF0pIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgcmVsYXkgPSByZWxheUluaXQodXJsKTtcclxuXHJcbiAgICAgICAgcmVsYXkub24oXCJjb25uZWN0XCIsICgpID0+XHJcbiAgICAgICAgICBzZXRDb25uZWN0ZWRSZWxheXMoKGN1cnJlbnRDb25uZWN0ZWRSZWxheXMpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLmN1cnJlbnRDb25uZWN0ZWRSZWxheXMsXHJcbiAgICAgICAgICAgIFt1cmxdOiByZWxheSxcclxuICAgICAgICAgIH0pKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmVsYXkub24oXCJkaXNjb25uZWN0XCIsICgpID0+XHJcbiAgICAgICAgICBzZXRDb25uZWN0ZWRSZWxheXMoXHJcbiAgICAgICAgICAgICh7IFt1cmxdOiBfcHJldmlvdXNseUNvbm5lY3RlZFJlbGF5LCAuLi5uZXdDb25uZWN0ZWRSZWxheXMgfSkgPT5cclxuICAgICAgICAgICAgICBuZXdDb25uZWN0ZWRSZWxheXNcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIHJlbGF5Lm9uKFwiZXJyb3JcIiwgY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xyXG4gICAgICB9KSxcclxuICAgIFtjb25uZWN0ZWRSZWxheXNdXHJcbiAgKTtcclxuICBjb25zdCBwdWJsaXNoID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoZXZlbnQ6IE5vc3RyRXZlbnQpID0+XHJcbiAgICAgIE9iamVjdC52YWx1ZXMoY29ubmVjdGVkUmVsYXlzKS5mb3JFYWNoKChyZWxheSkgPT4gcmVsYXkucHVibGlzaChldmVudCkpLFxyXG4gICAgW2Nvbm5lY3RlZFJlbGF5c11cclxuICApO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICByZWxheVVybHMubGVuZ3RoID09PSBrbm93blJlbGF5cy5sZW5ndGggJiZcclxuICAgICAgcmVsYXlVcmxzLmV2ZXJ5KCh1cmwpID0+IGtub3duUmVsYXlzLmluY2x1ZGVzKHVybCkpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2Nvbm5lY3RUb1JlbGF5cyhrbm93blJlbGF5cy5maWx0ZXIoKHVybCkgPT4gIXJlbGF5VXJscy5pbmNsdWRlcyh1cmwpKSk7XHJcbiAgICBjb25uZWN0VG9SZWxheXMocmVsYXlVcmxzKTtcclxuXHJcbiAgICBzZXRLbm93blJlbGF5cyhyZWxheVVybHMpO1xyXG4gIH0sIFtjb25uZWN0VG9SZWxheXMsIGRpc2Nvbm5lY3RUb1JlbGF5cywga25vd25SZWxheXMsIHJlbGF5VXJsc10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPE5vc3RyQ29udGV4dFxyXG4gICAgICB2YWx1ZT17dXNlTWVtbyhcclxuICAgICAgICAoKSA9PiAoe1xyXG4gICAgICAgICAgY29ubmVjdFRvUmVsYXlzLFxyXG4gICAgICAgICAgY29ubmVjdGVkUmVsYXlzOiBPYmplY3QudmFsdWVzKGNvbm5lY3RlZFJlbGF5cyksXHJcbiAgICAgICAgICBwdWJsaXNoLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIFtjb25uZWN0VG9SZWxheXMsIGNvbm5lY3RlZFJlbGF5cywgcHVibGlzaF1cclxuICAgICAgKX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9Ob3N0ckNvbnRleHQ+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBOb3N0clByb3ZpZGVyID0gbWVtbyhOb3N0clByb3ZpZGVyRkMpO1xyXG4iXSwibmFtZXMiOlsicmVsYXlJbml0IiwiY3JlYXRlQ29udGV4dCIsIm1lbW8iLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlU3RhdGUiLCJOb3N0ckNvbnRleHQiLCJjb25uZWN0VG9SZWxheXMiLCJjb25uZWN0ZWRSZWxheXMiLCJwdWJsaXNoIiwidXNlTm9zdHIiLCJOb3N0clByb3ZpZGVyRkMiLCJjaGlsZHJlbiIsInJlbGF5VXJscyIsInNldENvbm5lY3RlZFJlbGF5cyIsImtub3duUmVsYXlzIiwic2V0S25vd25SZWxheXMiLCJkaXNjb25uZWN0VG9SZWxheXMiLCJ1cmxzIiwibGVuZ3RoIiwiY3VycmVudENvbm5lY3RlZFJlbGF5cyIsIm5ld0Nvbm5lY3RlZFJlbGF5cyIsImZvckVhY2giLCJ1cmwiLCJjbG9zZSIsInJlbGF5Iiwib24iLCJfcHJldmlvdXNseUNvbm5lY3RlZFJlbGF5IiwiY29uc29sZSIsImVycm9yIiwiY29ubmVjdCIsImV2ZW50IiwiT2JqZWN0IiwidmFsdWVzIiwiZXZlcnkiLCJpbmNsdWRlcyIsImZpbHRlciIsInZhbHVlIiwiTm9zdHJQcm92aWRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/Profile.tsx":
/*!***********************************************!*\
  !*** ./components/apps/Messenger/Profile.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/Icons */ \"(pages-dir-browser)/./components/apps/Messenger/Icons.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledProfile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/StyledProfile */ \"(pages-dir-browser)/./components/apps/Messenger/StyledProfile.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Profile = ({ children, nip05, onMouseDown, picture, pubkey, userName = \"Unknown\" })=>{\n    _s();\n    const verifiedDomain = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNip05Domain)(nip05, pubkey);\n    const [loadedImage, setLoadedImage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledProfile__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        $clickable: Boolean(onMouseDown),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                onMouseDown: onMouseDown,\n                children: [\n                    picture && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        alt: userName,\n                        onLoad: ()=>setLoadedImage(picture),\n                        src: picture,\n                        style: loadedImage === picture ? {} : {\n                            position: \"absolute\",\n                            visibility: \"hidden\"\n                        }\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 11\n                    }, undefined),\n                    (!picture || loadedImage !== picture) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_2__.Avatar, {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                        lineNumber: 41,\n                        columnNumber: 51\n                    }, undefined),\n                    verifiedDomain && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"verified\",\n                        title: verifiedDomain,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_2__.Verified, {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                            lineNumber: 44,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                        lineNumber: 43,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                lineNumber: 28,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"figcaption\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        children: userName\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                        lineNumber: 49,\n                        columnNumber: 9\n                    }, undefined),\n                    children\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n                lineNumber: 48,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\Profile.tsx\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Profile, \"HnyYzLwrOOuRMgZLM3hxultrcFs=\", false, function() {\n    return [\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_4__.useNip05Domain\n    ];\n});\n_c = Profile;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(Profile));\nvar _c, _c1;\n$RefreshReg$(_c, \"Profile\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvUHJvZmlsZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1QztBQUM0QjtBQUNDO0FBQ0g7QUFVakUsTUFBTU0sVUFBNEIsQ0FBQyxFQUNqQ0MsUUFBUSxFQUNSQyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxNQUFNLEVBQ05DLFdBQVcsU0FBUyxFQUNyQjs7SUFDQyxNQUFNQyxpQkFBaUJSLCtFQUFjQSxDQUFDRyxPQUFPRztJQUM3QyxNQUFNLENBQUNHLGFBQWFDLGVBQWUsR0FBR2QsK0NBQVFBLENBQUM7SUFFL0MscUJBQ0UsOERBQUNHLCtFQUFhQTtRQUFDWSxZQUFZQyxRQUFRUjs7MEJBRWpDLDhEQUFDUztnQkFBSVQsYUFBYUE7O29CQUNmQyx5QkFDQyw4REFBQ1M7d0JBQ0NDLEtBQUtSO3dCQUNMUyxRQUFRLElBQU1OLGVBQWVMO3dCQUM3QlksS0FBS1o7d0JBQ0xhLE9BQ0VULGdCQUFnQkosVUFDWixDQUFDLElBQ0Q7NEJBQUVjLFVBQVU7NEJBQVlDLFlBQVk7d0JBQVM7Ozs7OztvQkFJckQsRUFBQ2YsV0FBV0ksZ0JBQWdCSixPQUFNLG1CQUFNLDhEQUFDUixtRUFBTUE7Ozs7O29CQUNoRFcsZ0NBQ0MsOERBQUNLO3dCQUFJUSxXQUFVO3dCQUFXQyxPQUFPZDtrQ0FDL0IsNEVBQUNWLHFFQUFRQTs7Ozs7Ozs7Ozs7Ozs7OzswQkFJZiw4REFBQ3lCOztrQ0FDQyw4REFBQ0M7a0NBQU1qQjs7Ozs7O29CQUNOTDs7Ozs7Ozs7Ozs7OztBQUlUO0dBeENNRDs7UUFRbUJELDJFQUFjQTs7O0tBUmpDQztBQTBDTixvRkFBZU4sMkNBQUlBLENBQUNNLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxQcm9maWxlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBBdmF0YXIsIFZlcmlmaWVkIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSWNvbnNcIjtcclxuaW1wb3J0IFN0eWxlZFByb2ZpbGUgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkUHJvZmlsZVwiO1xyXG5pbXBvcnQgeyB1c2VOaXAwNURvbWFpbiB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2hvb2tzXCI7XHJcblxyXG50eXBlIFByb2ZpbGVQcm9wcyA9IHtcclxuICBuaXAwNT86IHN0cmluZztcclxuICBvbk1vdXNlRG93bj86ICgpID0+IHZvaWQ7XHJcbiAgcGljdHVyZT86IHN0cmluZztcclxuICBwdWJrZXk/OiBzdHJpbmc7XHJcbiAgdXNlck5hbWU/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBQcm9maWxlOiBGQzxQcm9maWxlUHJvcHM+ID0gKHtcclxuICBjaGlsZHJlbixcclxuICBuaXAwNSxcclxuICBvbk1vdXNlRG93bixcclxuICBwaWN0dXJlLFxyXG4gIHB1YmtleSxcclxuICB1c2VyTmFtZSA9IFwiVW5rbm93blwiLFxyXG59KSA9PiB7XHJcbiAgY29uc3QgdmVyaWZpZWREb21haW4gPSB1c2VOaXAwNURvbWFpbihuaXAwNSwgcHVia2V5KTtcclxuICBjb25zdCBbbG9hZGVkSW1hZ2UsIHNldExvYWRlZEltYWdlXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZFByb2ZpbGUgJGNsaWNrYWJsZT17Qm9vbGVhbihvbk1vdXNlRG93bil9PlxyXG4gICAgICB7LyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9ucyAqL31cclxuICAgICAgPGRpdiBvbk1vdXNlRG93bj17b25Nb3VzZURvd259PlxyXG4gICAgICAgIHtwaWN0dXJlICYmIChcclxuICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgYWx0PXt1c2VyTmFtZX1cclxuICAgICAgICAgICAgb25Mb2FkPXsoKSA9PiBzZXRMb2FkZWRJbWFnZShwaWN0dXJlKX1cclxuICAgICAgICAgICAgc3JjPXtwaWN0dXJlfVxyXG4gICAgICAgICAgICBzdHlsZT17XHJcbiAgICAgICAgICAgICAgbG9hZGVkSW1hZ2UgPT09IHBpY3R1cmVcclxuICAgICAgICAgICAgICAgID8ge31cclxuICAgICAgICAgICAgICAgIDogeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApfVxyXG4gICAgICAgIHsoIXBpY3R1cmUgfHwgbG9hZGVkSW1hZ2UgIT09IHBpY3R1cmUpICYmIDxBdmF0YXIgLz59XHJcbiAgICAgICAge3ZlcmlmaWVkRG9tYWluICYmIChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidmVyaWZpZWRcIiB0aXRsZT17dmVyaWZpZWREb21haW59PlxyXG4gICAgICAgICAgICA8VmVyaWZpZWQgLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZmlnY2FwdGlvbj5cclxuICAgICAgICA8c3Bhbj57dXNlck5hbWV9PC9zcGFuPlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9maWdjYXB0aW9uPlxyXG4gICAgPC9TdHlsZWRQcm9maWxlPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW1vKFByb2ZpbGUpO1xyXG4iXSwibmFtZXMiOlsibWVtbyIsInVzZVN0YXRlIiwiQXZhdGFyIiwiVmVyaWZpZWQiLCJTdHlsZWRQcm9maWxlIiwidXNlTmlwMDVEb21haW4iLCJQcm9maWxlIiwiY2hpbGRyZW4iLCJuaXAwNSIsIm9uTW91c2VEb3duIiwicGljdHVyZSIsInB1YmtleSIsInVzZXJOYW1lIiwidmVyaWZpZWREb21haW4iLCJsb2FkZWRJbWFnZSIsInNldExvYWRlZEltYWdlIiwiJGNsaWNrYWJsZSIsIkJvb2xlYW4iLCJkaXYiLCJpbWciLCJhbHQiLCJvbkxvYWQiLCJzcmMiLCJzdHlsZSIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImNsYXNzTmFtZSIsInRpdGxlIiwiZmlnY2FwdGlvbiIsInNwYW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/Profile.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/ProfileBanner.tsx":
/*!*****************************************************!*\
  !*** ./components/apps/Messenger/ProfileBanner.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/HistoryContext */ \"(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\");\n/* harmony import */ var components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/Icons */ \"(pages-dir-browser)/./components/apps/Messenger/Icons.tsx\");\n/* harmony import */ var components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/NostrContext */ \"(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx\");\n/* harmony import */ var components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/apps/Messenger/Profile */ \"(pages-dir-browser)/./components/apps/Messenger/Profile.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledProfileBanner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/apps/Messenger/StyledProfileBanner */ \"(pages-dir-browser)/./components/apps/Messenger/StyledProfileBanner.ts\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n/* harmony import */ var contexts_menu__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! contexts/menu */ \"(pages-dir-browser)/./contexts/menu/index.tsx\");\n/* harmony import */ var styles_common_Button__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! styles/common/Button */ \"(pages-dir-browser)/./styles/common/Button.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst GRADIENT = \"linear-gradient(rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.5))\";\nconst STYLING = \"center center / cover no-repeat local border-box border-box #000\";\nconst ProfileBanner = ({ goHome, hideReadMessages, newChat, publicKey, relayUrls, selectedRecipientKey, setHideReadMessages })=>{\n    _s();\n    const pubkey = selectedRecipientKey === components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_7__.UNKNOWN_PUBLIC_KEY ? \"\" : selectedRecipientKey || publicKey;\n    const { banner, data, nip05, picture, userName = \"New message\" } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__.useNostrProfile)(pubkey);\n    const { connectToRelays, connectedRelays } = (0,components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr)();\n    const connectedRelayData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ProfileBanner.useMemo[connectedRelayData]\": ()=>Object.fromEntries(connectedRelays.map({\n                \"ProfileBanner.useMemo[connectedRelayData]\": ({ url, status })=>[\n                        url,\n                        status\n                    ]\n            }[\"ProfileBanner.useMemo[connectedRelayData]\"]))\n    }[\"ProfileBanner.useMemo[connectedRelayData]\"], [\n        connectedRelays\n    ]);\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ProfileBanner.useMemo[style]\": ()=>banner ? {\n                background: `${GRADIENT}, url(${banner}) ${STYLING}`\n            } : {}\n    }[\"ProfileBanner.useMemo[style]\"], [\n        banner\n    ]);\n    const { contextMenu } = (0,contexts_menu__WEBPACK_IMPORTED_MODULE_10__.useMenu)();\n    const { publish } = (0,components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr)();\n    const { setProfiles } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext)();\n    const updateProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ProfileBanner.useCallback[updateProfile]\": async (newProfile)=>{\n            if (Object.values(newProfile).filter(Boolean).length === 0) return;\n            try {\n                const content = data ? Object.assign(data, newProfile) : newProfile;\n                const event = await (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.createProfileEvent)(content);\n                publish(event);\n                setProfiles({\n                    \"ProfileBanner.useCallback[updateProfile]\": (currentProfiles)=>({\n                            ...currentProfiles,\n                            [pubkey]: (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.dataToProfile)(publicKey, content)\n                        })\n                }[\"ProfileBanner.useCallback[updateProfile]\"]);\n            } catch  {\n            // Ignore errors publishing profile data\n            }\n        }\n    }[\"ProfileBanner.useCallback[updateProfile]\"], [\n        data,\n        pubkey,\n        publicKey,\n        publish,\n        setProfiles\n    ]);\n    const { onContextMenuCapture } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ProfileBanner.useMemo\": ()=>/* eslint-disable no-alert */ contextMenu?.({\n                \"ProfileBanner.useMemo\": ()=>[\n                        ...(0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.copyKeyMenuItems)(selectedRecipientKey || pubkey, (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.getPrivateKey)()),\n                        ...pubkey && !selectedRecipientKey ? [\n                            utils_constants__WEBPACK_IMPORTED_MODULE_12__.MENU_SEPERATOR,\n                            {\n                                action: {\n                                    \"ProfileBanner.useMemo\": ()=>updateProfile({\n                                            username: prompt(\"Username\") || \"\"\n                                        })\n                                }[\"ProfileBanner.useMemo\"],\n                                label: \"Edit Username\"\n                            },\n                            utils_constants__WEBPACK_IMPORTED_MODULE_12__.MENU_SEPERATOR,\n                            {\n                                action: {\n                                    \"ProfileBanner.useMemo\": ()=>updateProfile({\n                                            picture: prompt(\"Picture URL\") || \"\"\n                                        })\n                                }[\"ProfileBanner.useMemo\"],\n                                label: \"Edit Picture\"\n                            },\n                            {\n                                action: {\n                                    \"ProfileBanner.useMemo\": ()=>updateProfile({\n                                            banner: prompt(\"Banner URL\") || \"\"\n                                        })\n                                }[\"ProfileBanner.useMemo\"],\n                                label: \"Edit Banner\"\n                            },\n                            utils_constants__WEBPACK_IMPORTED_MODULE_12__.MENU_SEPERATOR,\n                            {\n                                action: {\n                                    \"ProfileBanner.useMemo\": ()=>setHideReadMessages(!hideReadMessages)\n                                }[\"ProfileBanner.useMemo\"],\n                                label: `${hideReadMessages ? \"Show\" : \"Hide\"} Read Messages`\n                            }\n                        ] : []\n                    ]\n            }[\"ProfileBanner.useMemo\"])\n    }[\"ProfileBanner.useMemo\"], /* eslint-enable no-alert */ [\n        contextMenu,\n        hideReadMessages,\n        pubkey,\n        selectedRecipientKey,\n        setHideReadMessages,\n        updateProfile\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledProfileBanner__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n        onContextMenuCapture: utils_functions__WEBPACK_IMPORTED_MODULE_13__.haltEvent,\n        style: style,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(styles_common_Button__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                onClick: selectedRecipientKey ? goHome : newChat,\n                children: selectedRecipientKey ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_3__.Back, {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                    lineNumber: 137,\n                    columnNumber: 33\n                }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_3__.Write, {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                    lineNumber: 137,\n                    columnNumber: 44\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                lineNumber: 136,\n                columnNumber: 7\n            }, undefined),\n            !selectedRecipientKey && connectedRelays.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relays\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                    children: (0,utils_functions__WEBPACK_IMPORTED_MODULE_13__.toSorted)(relayUrls).map((relayUrl)=>// eslint-disable-next-line jsx-a11y/click-events-have-key-events\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            onClick: connectedRelayData[relayUrl] ? undefined : ()=>connectToRelays([\n                                    relayUrl\n                                ]),\n                            title: relayUrl,\n                            children: (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_8__.getWebSocketStatusIcon)(connectedRelayData[relayUrl])\n                        }, relayUrl, false, {\n                            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                            lineNumber: 144,\n                            columnNumber: 15\n                        }, undefined))\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                    lineNumber: 141,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                lineNumber: 140,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Profile__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                nip05: nip05,\n                onMouseDown: onContextMenuCapture,\n                picture: picture,\n                pubkey: pubkey,\n                userName: userName\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n                lineNumber: 159,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\ProfileBanner.tsx\",\n        lineNumber: 135,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ProfileBanner, \"QcpdlE8MSioPy7Gr621kDRMpYW0=\", false, function() {\n    return [\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_9__.useNostrProfile,\n        components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr,\n        contexts_menu__WEBPACK_IMPORTED_MODULE_10__.useMenu,\n        components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr,\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_2__.useHistoryContext\n    ];\n});\n_c = ProfileBanner;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ProfileBanner));\nvar _c, _c1;\n$RefreshReg$(_c, \"ProfileBanner\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvUHJvZmlsZUJhbm5lci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUMwQjtBQUNmO0FBQ0k7QUFDVjtBQUN3QjtBQUNQO0FBTzVCO0FBQ3FCO0FBRTFCO0FBQ0U7QUFDTztBQUNLO0FBRXRELE1BQU1xQixXQUFXO0FBQ2pCLE1BQU1DLFVBQ0o7QUFZRixNQUFNQyxnQkFBd0MsQ0FBQyxFQUM3Q0MsTUFBTSxFQUNOQyxnQkFBZ0IsRUFDaEJDLE9BQU8sRUFDUEMsU0FBUyxFQUNUQyxTQUFTLEVBQ1RDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ3BCOztJQUNDLE1BQU1DLFNBQ0pGLHlCQUF5QnBCLG1GQUFrQkEsR0FDdkMsS0FDQW9CLHdCQUF3QkY7SUFDOUIsTUFBTSxFQUNKSyxNQUFNLEVBQ05DLElBQUksRUFDSkMsS0FBSyxFQUNMQyxPQUFPLEVBQ1BDLFdBQVcsYUFBYSxFQUN6QixHQUFHckIsZ0ZBQWVBLENBQUNnQjtJQUNwQixNQUFNLEVBQUVNLGVBQWUsRUFBRUMsZUFBZSxFQUFFLEdBQUdoQyxnRkFBUUE7SUFDckQsTUFBTWlDLHFCQUFxQnJDLDhDQUFPQTtxREFDaEMsSUFDRXNDLE9BQU9DLFdBQVcsQ0FDaEJILGdCQUFnQkksR0FBRzs2REFBQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxFQUFFLEdBQUs7d0JBQUNEO3dCQUFLQztxQkFBTzs7b0RBRTFEO1FBQUNOO0tBQWdCO0lBRW5CLE1BQU1PLFFBQVEzQyw4Q0FBT0E7d0NBQ25CLElBQ0U4QixTQUFTO2dCQUFFYyxZQUFZLEdBQUd6QixTQUFTLE1BQU0sRUFBRVcsT0FBTyxFQUFFLEVBQUVWLFNBQVM7WUFBQyxJQUFJLENBQUM7dUNBQ3ZFO1FBQUNVO0tBQU87SUFFVixNQUFNLEVBQUVlLFdBQVcsRUFBRSxHQUFHL0IsdURBQU9BO0lBQy9CLE1BQU0sRUFBRWdDLE9BQU8sRUFBRSxHQUFHMUMsZ0ZBQVFBO0lBQzVCLE1BQU0sRUFBRTJDLFdBQVcsRUFBRSxHQUFHOUMsMkZBQWlCQTtJQUN6QyxNQUFNK0MsZ0JBQWdCakQsa0RBQVdBO29EQUMvQixPQUFPa0Q7WUFDTCxJQUFJWCxPQUFPWSxNQUFNLENBQUNELFlBQVlFLE1BQU0sQ0FBQ0MsU0FBU0MsTUFBTSxLQUFLLEdBQUc7WUFFNUQsSUFBSTtnQkFDRixNQUFNQyxVQUFVdkIsT0FBT08sT0FBT2lCLE1BQU0sQ0FBQ3hCLE1BQU1rQixjQUFjQTtnQkFDekQsTUFBTU8sUUFBUSxNQUFNL0MsdUZBQWtCQSxDQUFDNkM7Z0JBRXZDUixRQUFRVTtnQkFDUlQ7Z0VBQVksQ0FBQ1Usa0JBQXFCOzRCQUNoQyxHQUFHQSxlQUFlOzRCQUNsQixDQUFDNUIsT0FBTyxFQUFFbkIsa0ZBQWFBLENBQUNlLFdBQVc2Qjt3QkFDckM7O1lBQ0YsRUFBRSxPQUFNO1lBQ04sd0NBQXdDO1lBQzFDO1FBQ0Y7bURBQ0E7UUFBQ3ZCO1FBQU1GO1FBQVFKO1FBQVdxQjtRQUFTQztLQUFZO0lBRWpELE1BQU0sRUFBRVcsb0JBQW9CLEVBQUUsR0FBRzFELDhDQUFPQTtpQ0FDdEMsSUFDRSwyQkFBMkIsR0FDM0I2Qzt5Q0FBYyxJQUFNOzJCQUNmckMscUZBQWdCQSxDQUFDbUIsd0JBQXdCRSxRQUFRbEIsa0ZBQWFBOzJCQUM3RGtCLFVBQVUsQ0FBQ0YsdUJBQ1g7NEJBQ0VYLDREQUFjQTs0QkFDZDtnQ0FDRTJDLE1BQU07NkRBQUUsSUFDTlgsY0FBYzs0Q0FBRVksVUFBVUMsT0FBTyxlQUFlO3dDQUFHOztnQ0FDckRDLE9BQU87NEJBQ1Q7NEJBQ0E5Qyw0REFBY0E7NEJBQ2Q7Z0NBQ0UyQyxNQUFNOzZEQUFFLElBQ05YLGNBQWM7NENBQUVmLFNBQVM0QixPQUFPLGtCQUFrQjt3Q0FBRzs7Z0NBQ3ZEQyxPQUFPOzRCQUNUOzRCQUNBO2dDQUNFSCxNQUFNOzZEQUFFLElBQ05YLGNBQWM7NENBQUVsQixRQUFRK0IsT0FBTyxpQkFBaUI7d0NBQUc7O2dDQUNyREMsT0FBTzs0QkFDVDs0QkFDQTlDLDREQUFjQTs0QkFDZDtnQ0FDRTJDLE1BQU07NkRBQUUsSUFBTS9CLG9CQUFvQixDQUFDTDs7Z0NBQ25DdUMsT0FBTyxHQUFHdkMsbUJBQW1CLFNBQVMsT0FBTyxjQUFjLENBQUM7NEJBQzlEO3lCQUNELEdBQ0QsRUFBRTtxQkFDUDs7Z0NBQ0gsMEJBQTBCLEdBQzFCO1FBQ0VzQjtRQUNBdEI7UUFDQU07UUFDQUY7UUFDQUM7UUFDQW9CO0tBQ0Q7SUFHSCxxQkFDRSw4REFBQzFDLHFGQUFtQkE7UUFBQ29ELHNCQUFzQnpDLHVEQUFTQTtRQUFFMEIsT0FBT0E7OzBCQUMzRCw4REFBQzVCLDZEQUFNQTtnQkFBQ2dELFNBQVNwQyx1QkFBdUJMLFNBQVNFOzBCQUM5Q0cscUNBQXVCLDhEQUFDekIsaUVBQUlBOzs7OzhDQUFNLDhEQUFDQyxrRUFBS0E7Ozs7Ozs7Ozs7WUFFMUMsQ0FBQ3dCLHdCQUF3QlMsZ0JBQWdCaUIsTUFBTSxHQUFHLG1CQUNqRCw4REFBQ1c7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNDOzhCQUNFaEQsMERBQVFBLENBQUNRLFdBQVdjLEdBQUcsQ0FBQyxDQUFDMkIsV0FDeEIsaUVBQWlFO3NDQUNqRSw4REFBQ0M7NEJBRUNMLFNBQ0UxQixrQkFBa0IsQ0FBQzhCLFNBQVMsR0FDeEJFLFlBQ0EsSUFBTWxDLGdCQUFnQjtvQ0FBQ2dDO2lDQUFTOzRCQUV0Q0csT0FBT0g7c0NBRU52RCwyRkFBc0JBLENBQUN5QixrQkFBa0IsQ0FBQzhCLFNBQVM7MkJBUi9DQTs7Ozs7Ozs7Ozs7Ozs7OzBCQWNmLDhEQUFDOUQseUVBQU9BO2dCQUNOMkIsT0FBT0E7Z0JBQ1B1QyxhQUFhYjtnQkFDYnpCLFNBQVNBO2dCQUNUSixRQUFRQTtnQkFDUkssVUFBVUE7Ozs7Ozs7Ozs7OztBQUlsQjtHQXBJTWI7O1FBbUJBUiw0RUFBZUE7UUFDMEJULDRFQUFRQTtRQWE3QlUsbURBQU9BO1FBQ1hWLDRFQUFRQTtRQUNKSCx1RkFBaUJBOzs7S0FuQ3JDb0I7QUFzSU4sb0ZBQWV2QiwyQ0FBSUEsQ0FBQ3VCLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxQcm9maWxlQmFubmVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VIaXN0b3J5Q29udGV4dCB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL0hpc3RvcnlDb250ZXh0XCI7XHJcbmltcG9ydCB7IEJhY2ssIFdyaXRlIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSWNvbnNcIjtcclxuaW1wb3J0IHsgdXNlTm9zdHIgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9Ob3N0ckNvbnRleHRcIjtcclxuaW1wb3J0IFByb2ZpbGUgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvUHJvZmlsZVwiO1xyXG5pbXBvcnQgU3R5bGVkUHJvZmlsZUJhbm5lciBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9TdHlsZWRQcm9maWxlQmFubmVyXCI7XHJcbmltcG9ydCB7IFVOS05PV05fUFVCTElDX0tFWSB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQge1xyXG4gIGNvcHlLZXlNZW51SXRlbXMsXHJcbiAgY3JlYXRlUHJvZmlsZUV2ZW50LFxyXG4gIGRhdGFUb1Byb2ZpbGUsXHJcbiAgZ2V0UHJpdmF0ZUtleSxcclxuICBnZXRXZWJTb2NrZXRTdGF0dXNJY29uLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQgeyB1c2VOb3N0clByb2ZpbGUgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9ob29rc1wiO1xyXG5pbXBvcnQgeyB0eXBlIFByb2ZpbGVEYXRhIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvdHlwZXNcIjtcclxuaW1wb3J0IHsgdXNlTWVudSB9IGZyb20gXCJjb250ZXh0cy9tZW51XCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcInN0eWxlcy9jb21tb24vQnV0dG9uXCI7XHJcbmltcG9ydCB7IE1FTlVfU0VQRVJBVE9SIH0gZnJvbSBcInV0aWxzL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyBoYWx0RXZlbnQsIHRvU29ydGVkIH0gZnJvbSBcInV0aWxzL2Z1bmN0aW9uc1wiO1xyXG5cclxuY29uc3QgR1JBRElFTlQgPSBcImxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMTApLCByZ2JhKDAsIDAsIDAsIDAuNSkpXCI7XHJcbmNvbnN0IFNUWUxJTkcgPVxyXG4gIFwiY2VudGVyIGNlbnRlciAvIGNvdmVyIG5vLXJlcGVhdCBsb2NhbCBib3JkZXItYm94IGJvcmRlci1ib3ggIzAwMFwiO1xyXG5cclxudHlwZSBQcm9maWxlQmFubmVyUHJvcHMgPSB7XHJcbiAgZ29Ib21lOiAoKSA9PiB2b2lkO1xyXG4gIGhpZGVSZWFkTWVzc2FnZXM6IGJvb2xlYW47XHJcbiAgbmV3Q2hhdDogKCkgPT4gdm9pZDtcclxuICBwdWJsaWNLZXk6IHN0cmluZztcclxuICByZWxheVVybHM6IHN0cmluZ1tdO1xyXG4gIHNlbGVjdGVkUmVjaXBpZW50S2V5OiBzdHJpbmc7XHJcbiAgc2V0SGlkZVJlYWRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+O1xyXG59O1xyXG5cclxuY29uc3QgUHJvZmlsZUJhbm5lcjogRkM8UHJvZmlsZUJhbm5lclByb3BzPiA9ICh7XHJcbiAgZ29Ib21lLFxyXG4gIGhpZGVSZWFkTWVzc2FnZXMsXHJcbiAgbmV3Q2hhdCxcclxuICBwdWJsaWNLZXksXHJcbiAgcmVsYXlVcmxzLFxyXG4gIHNlbGVjdGVkUmVjaXBpZW50S2V5LFxyXG4gIHNldEhpZGVSZWFkTWVzc2FnZXMsXHJcbn0pID0+IHtcclxuICBjb25zdCBwdWJrZXkgPVxyXG4gICAgc2VsZWN0ZWRSZWNpcGllbnRLZXkgPT09IFVOS05PV05fUFVCTElDX0tFWVxyXG4gICAgICA/IFwiXCJcclxuICAgICAgOiBzZWxlY3RlZFJlY2lwaWVudEtleSB8fCBwdWJsaWNLZXk7XHJcbiAgY29uc3Qge1xyXG4gICAgYmFubmVyLFxyXG4gICAgZGF0YSxcclxuICAgIG5pcDA1LFxyXG4gICAgcGljdHVyZSxcclxuICAgIHVzZXJOYW1lID0gXCJOZXcgbWVzc2FnZVwiLFxyXG4gIH0gPSB1c2VOb3N0clByb2ZpbGUocHVia2V5KTtcclxuICBjb25zdCB7IGNvbm5lY3RUb1JlbGF5cywgY29ubmVjdGVkUmVsYXlzIH0gPSB1c2VOb3N0cigpO1xyXG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5RGF0YSA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PlxyXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAgICAgY29ubmVjdGVkUmVsYXlzLm1hcCgoeyB1cmwsIHN0YXR1cyB9KSA9PiBbdXJsLCBzdGF0dXNdKVxyXG4gICAgICApLFxyXG4gICAgW2Nvbm5lY3RlZFJlbGF5c11cclxuICApO1xyXG4gIGNvbnN0IHN0eWxlID0gdXNlTWVtbyhcclxuICAgICgpID0+XHJcbiAgICAgIGJhbm5lciA/IHsgYmFja2dyb3VuZDogYCR7R1JBRElFTlR9LCB1cmwoJHtiYW5uZXJ9KSAke1NUWUxJTkd9YCB9IDoge30sXHJcbiAgICBbYmFubmVyXVxyXG4gICk7XHJcbiAgY29uc3QgeyBjb250ZXh0TWVudSB9ID0gdXNlTWVudSgpO1xyXG4gIGNvbnN0IHsgcHVibGlzaCB9ID0gdXNlTm9zdHIoKTtcclxuICBjb25zdCB7IHNldFByb2ZpbGVzIH0gPSB1c2VIaXN0b3J5Q29udGV4dCgpO1xyXG4gIGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChuZXdQcm9maWxlOiBQYXJ0aWFsPFByb2ZpbGVEYXRhPikgPT4ge1xyXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhuZXdQcm9maWxlKS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkYXRhID8gT2JqZWN0LmFzc2lnbihkYXRhLCBuZXdQcm9maWxlKSA6IG5ld1Byb2ZpbGU7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCBjcmVhdGVQcm9maWxlRXZlbnQoY29udGVudCk7XHJcblxyXG4gICAgICAgIHB1Ymxpc2goZXZlbnQpO1xyXG4gICAgICAgIHNldFByb2ZpbGVzKChjdXJyZW50UHJvZmlsZXMpID0+ICh7XHJcbiAgICAgICAgICAuLi5jdXJyZW50UHJvZmlsZXMsXHJcbiAgICAgICAgICBbcHVia2V5XTogZGF0YVRvUHJvZmlsZShwdWJsaWNLZXksIGNvbnRlbnQpLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgLy8gSWdub3JlIGVycm9ycyBwdWJsaXNoaW5nIHByb2ZpbGUgZGF0YVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2RhdGEsIHB1YmtleSwgcHVibGljS2V5LCBwdWJsaXNoLCBzZXRQcm9maWxlc11cclxuICApO1xyXG4gIGNvbnN0IHsgb25Db250ZXh0TWVudUNhcHR1cmUgfSA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PlxyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1hbGVydCAqL1xyXG4gICAgICBjb250ZXh0TWVudT8uKCgpID0+IFtcclxuICAgICAgICAuLi5jb3B5S2V5TWVudUl0ZW1zKHNlbGVjdGVkUmVjaXBpZW50S2V5IHx8IHB1YmtleSwgZ2V0UHJpdmF0ZUtleSgpKSxcclxuICAgICAgICAuLi4ocHVia2V5ICYmICFzZWxlY3RlZFJlY2lwaWVudEtleVxyXG4gICAgICAgICAgPyBbXHJcbiAgICAgICAgICAgICAgTUVOVV9TRVBFUkFUT1IsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PlxyXG4gICAgICAgICAgICAgICAgICB1cGRhdGVQcm9maWxlKHsgdXNlcm5hbWU6IHByb21wdChcIlVzZXJuYW1lXCIpIHx8IFwiXCIgfSksXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJFZGl0IFVzZXJuYW1lXCIsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBNRU5VX1NFUEVSQVRPUixcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+XHJcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVByb2ZpbGUoeyBwaWN0dXJlOiBwcm9tcHQoXCJQaWN0dXJlIFVSTFwiKSB8fCBcIlwiIH0pLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiRWRpdCBQaWN0dXJlXCIsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+XHJcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVByb2ZpbGUoeyBiYW5uZXI6IHByb21wdChcIkJhbm5lciBVUkxcIikgfHwgXCJcIiB9KSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBcIkVkaXQgQmFubmVyXCIsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBNRU5VX1NFUEVSQVRPUixcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHNldEhpZGVSZWFkTWVzc2FnZXMoIWhpZGVSZWFkTWVzc2FnZXMpLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGAke2hpZGVSZWFkTWVzc2FnZXMgPyBcIlNob3dcIiA6IFwiSGlkZVwifSBSZWFkIE1lc3NhZ2VzYCxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICA6IFtdKSxcclxuICAgICAgXSksXHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWFsZXJ0ICovXHJcbiAgICBbXHJcbiAgICAgIGNvbnRleHRNZW51LFxyXG4gICAgICBoaWRlUmVhZE1lc3NhZ2VzLFxyXG4gICAgICBwdWJrZXksXHJcbiAgICAgIHNlbGVjdGVkUmVjaXBpZW50S2V5LFxyXG4gICAgICBzZXRIaWRlUmVhZE1lc3NhZ2VzLFxyXG4gICAgICB1cGRhdGVQcm9maWxlLFxyXG4gICAgXVxyXG4gICk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVkUHJvZmlsZUJhbm5lciBvbkNvbnRleHRNZW51Q2FwdHVyZT17aGFsdEV2ZW50fSBzdHlsZT17c3R5bGV9PlxyXG4gICAgICA8QnV0dG9uIG9uQ2xpY2s9e3NlbGVjdGVkUmVjaXBpZW50S2V5ID8gZ29Ib21lIDogbmV3Q2hhdH0+XHJcbiAgICAgICAge3NlbGVjdGVkUmVjaXBpZW50S2V5ID8gPEJhY2sgLz4gOiA8V3JpdGUgLz59XHJcbiAgICAgIDwvQnV0dG9uPlxyXG4gICAgICB7IXNlbGVjdGVkUmVjaXBpZW50S2V5ICYmIGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwICYmIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF5c1wiPlxyXG4gICAgICAgICAgPG9sPlxyXG4gICAgICAgICAgICB7dG9Tb3J0ZWQocmVsYXlVcmxzKS5tYXAoKHJlbGF5VXJsKSA9PiAoXHJcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHNcclxuICAgICAgICAgICAgICA8bGlcclxuICAgICAgICAgICAgICAgIGtleT17cmVsYXlVcmx9XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtcclxuICAgICAgICAgICAgICAgICAgY29ubmVjdGVkUmVsYXlEYXRhW3JlbGF5VXJsXVxyXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgOiAoKSA9PiBjb25uZWN0VG9SZWxheXMoW3JlbGF5VXJsXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpdGxlPXtyZWxheVVybH1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7Z2V0V2ViU29ja2V0U3RhdHVzSWNvbihjb25uZWN0ZWRSZWxheURhdGFbcmVsYXlVcmxdKX1cclxuICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICApKX1cclxuICAgICAgICAgIDwvb2w+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcbiAgICAgIDxQcm9maWxlXHJcbiAgICAgICAgbmlwMDU9e25pcDA1fVxyXG4gICAgICAgIG9uTW91c2VEb3duPXtvbkNvbnRleHRNZW51Q2FwdHVyZX1cclxuICAgICAgICBwaWN0dXJlPXtwaWN0dXJlfVxyXG4gICAgICAgIHB1YmtleT17cHVia2V5fVxyXG4gICAgICAgIHVzZXJOYW1lPXt1c2VyTmFtZX1cclxuICAgICAgLz5cclxuICAgIDwvU3R5bGVkUHJvZmlsZUJhbm5lcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWVtbyhQcm9maWxlQmFubmVyKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VIaXN0b3J5Q29udGV4dCIsIkJhY2siLCJXcml0ZSIsInVzZU5vc3RyIiwiUHJvZmlsZSIsIlN0eWxlZFByb2ZpbGVCYW5uZXIiLCJVTktOT1dOX1BVQkxJQ19LRVkiLCJjb3B5S2V5TWVudUl0ZW1zIiwiY3JlYXRlUHJvZmlsZUV2ZW50IiwiZGF0YVRvUHJvZmlsZSIsImdldFByaXZhdGVLZXkiLCJnZXRXZWJTb2NrZXRTdGF0dXNJY29uIiwidXNlTm9zdHJQcm9maWxlIiwidXNlTWVudSIsIkJ1dHRvbiIsIk1FTlVfU0VQRVJBVE9SIiwiaGFsdEV2ZW50IiwidG9Tb3J0ZWQiLCJHUkFESUVOVCIsIlNUWUxJTkciLCJQcm9maWxlQmFubmVyIiwiZ29Ib21lIiwiaGlkZVJlYWRNZXNzYWdlcyIsIm5ld0NoYXQiLCJwdWJsaWNLZXkiLCJyZWxheVVybHMiLCJzZWxlY3RlZFJlY2lwaWVudEtleSIsInNldEhpZGVSZWFkTWVzc2FnZXMiLCJwdWJrZXkiLCJiYW5uZXIiLCJkYXRhIiwibmlwMDUiLCJwaWN0dXJlIiwidXNlck5hbWUiLCJjb25uZWN0VG9SZWxheXMiLCJjb25uZWN0ZWRSZWxheXMiLCJjb25uZWN0ZWRSZWxheURhdGEiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsIm1hcCIsInVybCIsInN0YXR1cyIsInN0eWxlIiwiYmFja2dyb3VuZCIsImNvbnRleHRNZW51IiwicHVibGlzaCIsInNldFByb2ZpbGVzIiwidXBkYXRlUHJvZmlsZSIsIm5ld1Byb2ZpbGUiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwiY29udGVudCIsImFzc2lnbiIsImV2ZW50IiwiY3VycmVudFByb2ZpbGVzIiwib25Db250ZXh0TWVudUNhcHR1cmUiLCJhY3Rpb24iLCJ1c2VybmFtZSIsInByb21wdCIsImxhYmVsIiwib25DbGljayIsImRpdiIsImNsYXNzTmFtZSIsIm9sIiwicmVsYXlVcmwiLCJsaSIsInVuZGVmaW5lZCIsInRpdGxlIiwib25Nb3VzZURvd24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/ProfileBanner.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/SendMessage.tsx":
/*!***************************************************!*\
  !*** ./components/apps/Messenger/SendMessage.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/Icons */ \"(pages-dir-browser)/./components/apps/Messenger/Icons.tsx\");\n/* harmony import */ var components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/MessageContext */ \"(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx\");\n/* harmony import */ var components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/NostrContext */ \"(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledSendMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/apps/Messenger/StyledSendMessage */ \"(pages-dir-browser)/./components/apps/Messenger/StyledSendMessage.ts\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var styles_common_Button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! styles/common/Button */ \"(pages-dir-browser)/./styles/common/Button.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst SendMessage = ({ recipientPublicKey })=>{\n    _s();\n    const { sendingEvent } = (0,components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_3__.useMessageContext)();\n    const { publish } = (0,components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr)();\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canSend, setCanSend] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const isUnknownKey = recipientPublicKey === components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_6__.UNKNOWN_PUBLIC_KEY;\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"SendMessage.useCallback[sendMessage]\": async (message)=>{\n            const event = await (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_7__.createMessageEvent)(message, recipientPublicKey);\n            sendingEvent(event);\n            try {\n                publish(event);\n            } catch  {\n            // Ignore error during publish\n            }\n            if (inputRef.current?.value) inputRef.current.value = \"\";\n            setCanSend(false);\n        }\n    }[\"SendMessage.useCallback[sendMessage]\"], [\n        publish,\n        recipientPublicKey,\n        sendingEvent\n    ]);\n    const updateHeight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"SendMessage.useCallback[updateHeight]\": ()=>{\n            if (inputRef.current) {\n                inputRef.current.style.height = \"0px\";\n                inputRef.current.style.height = `${Math.max(35, inputRef.current.scrollHeight + 4)}px`;\n            }\n        }\n    }[\"SendMessage.useCallback[updateHeight]\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledSendMessage__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                ref: inputRef,\n                disabled: isUnknownKey,\n                onChange: ()=>{\n                    setCanSend(Boolean(inputRef.current?.value));\n                    updateHeight();\n                },\n                onKeyDown: async (event)=>{\n                    const { key, shiftKey } = event;\n                    const message = inputRef.current?.value.trim();\n                    if (message && key === \"Enter\" && !shiftKey) {\n                        event.preventDefault();\n                        await sendMessage(message);\n                    } else setCanSend(Boolean(message));\n                    updateHeight();\n                },\n                placeholder: \"Type a message...\",\n                autoFocus: true\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\SendMessage.tsx\",\n                lineNumber: 49,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(styles_common_Button__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                disabled: isUnknownKey || !canSend,\n                onClick: ()=>inputRef.current?.value && sendMessage(inputRef.current.value),\n                onContextMenuCapture: utils_functions__WEBPACK_IMPORTED_MODULE_9__.haltEvent,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Icons__WEBPACK_IMPORTED_MODULE_2__.Send, {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\SendMessage.tsx\",\n                    lineNumber: 77,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\SendMessage.tsx\",\n                lineNumber: 70,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\SendMessage.tsx\",\n        lineNumber: 48,\n        columnNumber: 5\n    }, undefined);\n};\n_s(SendMessage, \"7Kw7ZKO2QdzvKpE/fYfbNSXvvxE=\", false, function() {\n    return [\n        components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_3__.useMessageContext,\n        components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_4__.useNostr\n    ];\n});\n_c = SendMessage;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(SendMessage));\nvar _c, _c1;\n$RefreshReg$(_c, \"SendMessage\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU2VuZE1lc3NhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RDtBQUNMO0FBQ3NCO0FBQ1g7QUFDVTtBQUNIO0FBQ0E7QUFDL0I7QUFDRTtBQUU1QyxNQUFNWSxjQUFrRCxDQUFDLEVBQ3ZEQyxrQkFBa0IsRUFDbkI7O0lBQ0MsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR1QsMkZBQWlCQTtJQUMxQyxNQUFNLEVBQUVVLE9BQU8sRUFBRSxHQUFHVCxnRkFBUUE7SUFDNUIsTUFBTVUsV0FBV2QsNkNBQU1BLENBQXNCO0lBQzdDLE1BQU0sQ0FBQ2UsU0FBU0MsV0FBVyxHQUFHZiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNZ0IsZUFBZU4sdUJBQXVCTCxtRkFBa0JBO0lBQzlELE1BQU1ZLGNBQWNuQixrREFBV0E7Z0RBQzdCLE9BQU9vQjtZQUNMLE1BQU1DLFFBQVEsTUFBTWIsdUZBQWtCQSxDQUFDWSxTQUFTUjtZQUVoREMsYUFBYVE7WUFFYixJQUFJO2dCQUNGUCxRQUFRTztZQUNWLEVBQUUsT0FBTTtZQUNOLDhCQUE4QjtZQUNoQztZQUVBLElBQUlOLFNBQVNPLE9BQU8sRUFBRUMsT0FBT1IsU0FBU08sT0FBTyxDQUFDQyxLQUFLLEdBQUc7WUFFdEROLFdBQVc7UUFDYjsrQ0FDQTtRQUFDSDtRQUFTRjtRQUFvQkM7S0FBYTtJQUU3QyxNQUFNVyxlQUFleEIsa0RBQVdBO2lEQUFDO1lBQy9CLElBQUllLFNBQVNPLE9BQU8sRUFBRTtnQkFDcEJQLFNBQVNPLE9BQU8sQ0FBQ0csS0FBSyxDQUFDQyxNQUFNLEdBQUc7Z0JBQ2hDWCxTQUFTTyxPQUFPLENBQUNHLEtBQUssQ0FBQ0MsTUFBTSxHQUFHLEdBQUdDLEtBQUtDLEdBQUcsQ0FDekMsSUFDQWIsU0FBU08sT0FBTyxDQUFDTyxZQUFZLEdBQUcsR0FDaEMsRUFBRSxDQUFDO1lBQ1A7UUFDRjtnREFBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUN2QixtRkFBaUJBOzswQkFDaEIsOERBQUN3QjtnQkFDQ0MsS0FBS2hCO2dCQUNMaUIsVUFBVWQ7Z0JBQ1ZlLFVBQVU7b0JBQ1JoQixXQUFXaUIsUUFBUW5CLFNBQVNPLE9BQU8sRUFBRUM7b0JBQ3JDQztnQkFDRjtnQkFDQVcsV0FBVyxPQUFPZDtvQkFDaEIsTUFBTSxFQUFFZSxHQUFHLEVBQUVDLFFBQVEsRUFBRSxHQUFHaEI7b0JBQzFCLE1BQU1ELFVBQVVMLFNBQVNPLE9BQU8sRUFBRUMsTUFBTWU7b0JBRXhDLElBQUlsQixXQUFXZ0IsUUFBUSxXQUFXLENBQUNDLFVBQVU7d0JBQzNDaEIsTUFBTWtCLGNBQWM7d0JBQ3BCLE1BQU1wQixZQUFZQztvQkFDcEIsT0FBT0gsV0FBV2lCLFFBQVFkO29CQUUxQkk7Z0JBQ0Y7Z0JBQ0FnQixhQUFZO2dCQUNaQyxTQUFTOzs7Ozs7MEJBRVgsOERBQUNoQyw0REFBTUE7Z0JBQ0x1QixVQUFVZCxnQkFBZ0IsQ0FBQ0Y7Z0JBQzNCMEIsU0FBUyxJQUNQM0IsU0FBU08sT0FBTyxFQUFFQyxTQUFTSixZQUFZSixTQUFTTyxPQUFPLENBQUNDLEtBQUs7Z0JBRS9Eb0Isc0JBQXNCakMsc0RBQVNBOzBCQUUvQiw0RUFBQ1AsaUVBQUlBOzs7Ozs7Ozs7Ozs7Ozs7O0FBSWI7R0F0RU1ROztRQUdxQlAsdUZBQWlCQTtRQUN0QkMsNEVBQVFBOzs7S0FKeEJNO0FBd0VOLG9GQUFlWiwyQ0FBSUEsQ0FBQ1ksWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFNlbmRNZXNzYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBTZW5kIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSWNvbnNcIjtcclxuaW1wb3J0IHsgdXNlTWVzc2FnZUNvbnRleHQgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9NZXNzYWdlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyB1c2VOb3N0ciB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL05vc3RyQ29udGV4dFwiO1xyXG5pbXBvcnQgU3R5bGVkU2VuZE1lc3NhZ2UgZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkU2VuZE1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgVU5LTk9XTl9QVUJMSUNfS0VZIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IGNyZWF0ZU1lc3NhZ2VFdmVudCB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCJzdHlsZXMvY29tbW9uL0J1dHRvblwiO1xyXG5pbXBvcnQgeyBoYWx0RXZlbnQgfSBmcm9tIFwidXRpbHMvZnVuY3Rpb25zXCI7XHJcblxyXG5jb25zdCBTZW5kTWVzc2FnZTogRkM8eyByZWNpcGllbnRQdWJsaWNLZXk6IHN0cmluZyB9PiA9ICh7XHJcbiAgcmVjaXBpZW50UHVibGljS2V5LFxyXG59KSA9PiB7XHJcbiAgY29uc3QgeyBzZW5kaW5nRXZlbnQgfSA9IHVzZU1lc3NhZ2VDb250ZXh0KCk7XHJcbiAgY29uc3QgeyBwdWJsaXNoIH0gPSB1c2VOb3N0cigpO1xyXG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmPEhUTUxUZXh0QXJlYUVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IFtjYW5TZW5kLCBzZXRDYW5TZW5kXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBpc1Vua25vd25LZXkgPSByZWNpcGllbnRQdWJsaWNLZXkgPT09IFVOS05PV05fUFVCTElDX0tFWTtcclxuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNyZWF0ZU1lc3NhZ2VFdmVudChtZXNzYWdlLCByZWNpcGllbnRQdWJsaWNLZXkpO1xyXG5cclxuICAgICAgc2VuZGluZ0V2ZW50KGV2ZW50KTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcHVibGlzaChldmVudCk7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIC8vIElnbm9yZSBlcnJvciBkdXJpbmcgcHVibGlzaFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaW5wdXRSZWYuY3VycmVudD8udmFsdWUpIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBcIlwiO1xyXG5cclxuICAgICAgc2V0Q2FuU2VuZChmYWxzZSk7XHJcbiAgICB9LFxyXG4gICAgW3B1Ymxpc2gsIHJlY2lwaWVudFB1YmxpY0tleSwgc2VuZGluZ0V2ZW50XVxyXG4gICk7XHJcbiAgY29uc3QgdXBkYXRlSGVpZ2h0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGlucHV0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgaW5wdXRSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBcIjBweFwiO1xyXG4gICAgICBpbnB1dFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IGAke01hdGgubWF4KFxyXG4gICAgICAgIDM1LFxyXG4gICAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0ICsgNFxyXG4gICAgICApfXB4YDtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVkU2VuZE1lc3NhZ2U+XHJcbiAgICAgIDx0ZXh0YXJlYVxyXG4gICAgICAgIHJlZj17aW5wdXRSZWZ9XHJcbiAgICAgICAgZGlzYWJsZWQ9e2lzVW5rbm93bktleX1cclxuICAgICAgICBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgc2V0Q2FuU2VuZChCb29sZWFuKGlucHV0UmVmLmN1cnJlbnQ/LnZhbHVlKSk7XHJcbiAgICAgICAgICB1cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICB9fVxyXG4gICAgICAgIG9uS2V5RG93bj17YXN5bmMgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB7IGtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlucHV0UmVmLmN1cnJlbnQ/LnZhbHVlLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICBpZiAobWVzc2FnZSAmJiBrZXkgPT09IFwiRW50ZXJcIiAmJiAhc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgYXdhaXQgc2VuZE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICB9IGVsc2Ugc2V0Q2FuU2VuZChCb29sZWFuKG1lc3NhZ2UpKTtcclxuXHJcbiAgICAgICAgICB1cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICB9fVxyXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSBhIG1lc3NhZ2UuLi5cIlxyXG4gICAgICAgIGF1dG9Gb2N1c1xyXG4gICAgICAvPlxyXG4gICAgICA8QnV0dG9uXHJcbiAgICAgICAgZGlzYWJsZWQ9e2lzVW5rbm93bktleSB8fCAhY2FuU2VuZH1cclxuICAgICAgICBvbkNsaWNrPXsoKSA9PlxyXG4gICAgICAgICAgaW5wdXRSZWYuY3VycmVudD8udmFsdWUgJiYgc2VuZE1lc3NhZ2UoaW5wdXRSZWYuY3VycmVudC52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgb25Db250ZXh0TWVudUNhcHR1cmU9e2hhbHRFdmVudH1cclxuICAgICAgPlxyXG4gICAgICAgIDxTZW5kIC8+XHJcbiAgICAgIDwvQnV0dG9uPlxyXG4gICAgPC9TdHlsZWRTZW5kTWVzc2FnZT5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWVtbyhTZW5kTWVzc2FnZSk7XHJcbiJdLCJuYW1lcyI6WyJtZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlNlbmQiLCJ1c2VNZXNzYWdlQ29udGV4dCIsInVzZU5vc3RyIiwiU3R5bGVkU2VuZE1lc3NhZ2UiLCJVTktOT1dOX1BVQkxJQ19LRVkiLCJjcmVhdGVNZXNzYWdlRXZlbnQiLCJCdXR0b24iLCJoYWx0RXZlbnQiLCJTZW5kTWVzc2FnZSIsInJlY2lwaWVudFB1YmxpY0tleSIsInNlbmRpbmdFdmVudCIsInB1Ymxpc2giLCJpbnB1dFJlZiIsImNhblNlbmQiLCJzZXRDYW5TZW5kIiwiaXNVbmtub3duS2V5Iiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwiZXZlbnQiLCJjdXJyZW50IiwidmFsdWUiLCJ1cGRhdGVIZWlnaHQiLCJzdHlsZSIsImhlaWdodCIsIk1hdGgiLCJtYXgiLCJzY3JvbGxIZWlnaHQiLCJ0ZXh0YXJlYSIsInJlZiIsImRpc2FibGVkIiwib25DaGFuZ2UiLCJCb29sZWFuIiwib25LZXlEb3duIiwia2V5Iiwic2hpZnRLZXkiLCJ0cmltIiwicHJldmVudERlZmF1bHQiLCJwbGFjZWhvbGRlciIsImF1dG9Gb2N1cyIsIm9uQ2xpY2siLCJvbkNvbnRleHRNZW51Q2FwdHVyZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/SendMessage.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledChatContainer.ts":
/*!**********************************************************!*\
  !*** ./components/apps/Messenger/StyledChatContainer.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! motion/react */ \"(pages-dir-browser)/./node_modules/motion/dist/es/react.mjs\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\n\nconst StyledChatContainer = (0,styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(motion_react__WEBPACK_IMPORTED_MODULE_1__.m.div).withConfig({\n    componentId: \"sc-1a4b29b4-0\"\n})([\n    `\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledChatContainer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ2hhdENvbnRhaW5lci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDSjtBQUV2QyxNQUFNRyxzQkFBc0JELDZEQUFNQSxDQUFDRCwyQ0FBTUEsQ0FBQ0csR0FBRzs7O0lBQUU7Ozs7QUFJL0M7O0FBRUEsaUVBQWVELG1CQUFtQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZENoYXRDb250YWluZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbSBhcyBtb3Rpb24gfSBmcm9tIFwibW90aW9uL3JlYWN0XCI7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5jb25zdCBTdHlsZWRDaGF0Q29udGFpbmVyID0gc3R5bGVkKG1vdGlvbi5kaXYpYFxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbmA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWRDaGF0Q29udGFpbmVyO1xyXG4iXSwibmFtZXMiOlsibSIsIm1vdGlvbiIsInN0eWxlZCIsIlN0eWxlZENoYXRDb250YWluZXIiLCJkaXYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledChatContainer.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledChatLog.ts":
/*!****************************************************!*\
  !*** ./components/apps/Messenger/StyledChatLog.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styles/common/ScrollBars */ \"(pages-dir-browser)/./styles/common/ScrollBars.ts\");\n\n\nconst StyledChatLog = styled_components__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ol.withConfig({\n    componentId: \"sc-884be69-0\"\n})([\n    `\n  `,\n    `\n  height: 100%;\n  overflow-x: auto;\n  scrollbar-gutter: auto;\n\n  li:not(:first-child) {\n    border-radius: 15px;\n    color: #fff;\n    list-style: none;\n    margin: 12px;\n    padding: 10px 12px;\n    position: relative;\n\n    .status {\n      bottom: -4px;\n      position: absolute;\n      right: -15px;\n\n      svg {\n        fill: #ced7e0;\n        height: 12px;\n        width: 12px;\n      }\n    }\n\n    &.sent {\n      background-color: #0084ff;\n      margin-left: 65px;\n      margin-right: 20px;\n    }\n\n    &.received {\n      background-color: #3e4042;\n      margin-left: 40px;\n      margin-right: 50px;\n    }\n\n    &[data-timestamp] {\n      margin-top: 50px;\n\n      &:nth-child(2) {\n        margin-top: 30px;\n      }\n\n      &::before {\n        color: #8b8d92;\n        content: attr(data-timestamp);\n        font-size: 11px;\n        font-weight: 600;\n        left: 0;\n        position: absolute;\n        text-align: center;\n        top: -28px;\n        width: 100%;\n      }\n\n      &.sent {\n        &::before {\n          margin-left: -65px;\n          margin-right: -12px;\n          width: calc(100% + 65px + 12px);\n        }\n      }\n\n      &.received {\n        &::before {\n          margin-left: -40px;\n          margin-right: -50px;\n          width: calc(100% + 90px);\n        }\n      }\n    }\n\n    div {\n      cursor: auto;\n      overflow: hidden;\n      overflow-wrap: break-word;\n      user-select: text;\n\n      img {\n        border-radius: 5px;\n        margin: 6px 0;\n        object-fit: unset;\n        width: 100%;\n      }\n\n      &.avatar {\n        bottom: -24px;\n        left: -30px;\n        position: absolute;\n\n        img,\n        svg {\n          aspect-ratio: 1/1;\n          border-radius: 50%;\n          bottom: 5px;\n          height: 22px;\n          margin: 15px 0;\n          max-height: 22px;\n          max-width: 22px;\n          min-height: 22px;\n          min-width: 22px;\n          position: relative;\n          width: 22px;\n        }\n      }\n    }\n\n    &.cant-decrypt {\n      background-color: #910000;\n      position: relative;\n\n      &::after {\n        content: \"ðŸ”\";\n        font-size: 12px;\n        left: 6px;\n        margin-left: 0 !important;\n        position: absolute;\n        text-align: right;\n        top: -4px;\n        width: 100% !important;\n      }\n    }\n  }\n`\n], (0,styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledChatLog);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ2hhdExvZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUM7QUFDVztBQUVsRCxNQUFNRSxnQkFBZ0JGLDREQUFTOzs7SUFBQztFQUM5QjtJQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEhqQjtHQTVISUMsb0VBQVVBO0FBOEhkLGlFQUFlQyxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXGNvbXBvbmVudHNcXGFwcHNcXE1lc3NlbmdlclxcU3R5bGVkQ2hhdExvZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5pbXBvcnQgU2Nyb2xsQmFycyBmcm9tIFwic3R5bGVzL2NvbW1vbi9TY3JvbGxCYXJzXCI7XHJcblxyXG5jb25zdCBTdHlsZWRDaGF0TG9nID0gc3R5bGVkLm9sYFxyXG4gICR7U2Nyb2xsQmFycygpfVxyXG4gIGhlaWdodDogMTAwJTtcclxuICBvdmVyZmxvdy14OiBhdXRvO1xyXG4gIHNjcm9sbGJhci1ndXR0ZXI6IGF1dG87XHJcblxyXG4gIGxpOm5vdCg6Zmlyc3QtY2hpbGQpIHtcclxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XHJcbiAgICBjb2xvcjogI2ZmZjtcclxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XHJcbiAgICBtYXJnaW46IDEycHg7XHJcbiAgICBwYWRkaW5nOiAxMHB4IDEycHg7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcblxyXG4gICAgLnN0YXR1cyB7XHJcbiAgICAgIGJvdHRvbTogLTRweDtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICByaWdodDogLTE1cHg7XHJcblxyXG4gICAgICBzdmcge1xyXG4gICAgICAgIGZpbGw6ICNjZWQ3ZTA7XHJcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xyXG4gICAgICAgIHdpZHRoOiAxMnB4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgJi5zZW50IHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwODRmZjtcclxuICAgICAgbWFyZ2luLWxlZnQ6IDY1cHg7XHJcbiAgICAgIG1hcmdpbi1yaWdodDogMjBweDtcclxuICAgIH1cclxuXHJcbiAgICAmLnJlY2VpdmVkIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzNlNDA0MjtcclxuICAgICAgbWFyZ2luLWxlZnQ6IDQwcHg7XHJcbiAgICAgIG1hcmdpbi1yaWdodDogNTBweDtcclxuICAgIH1cclxuXHJcbiAgICAmW2RhdGEtdGltZXN0YW1wXSB7XHJcbiAgICAgIG1hcmdpbi10b3A6IDUwcHg7XHJcblxyXG4gICAgICAmOm50aC1jaGlsZCgyKSB7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMzBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgJjo6YmVmb3JlIHtcclxuICAgICAgICBjb2xvcjogIzhiOGQ5MjtcclxuICAgICAgICBjb250ZW50OiBhdHRyKGRhdGEtdGltZXN0YW1wKTtcclxuICAgICAgICBmb250LXNpemU6IDExcHg7XHJcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcclxuICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgICAgdG9wOiAtMjhweDtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJi5zZW50IHtcclxuICAgICAgICAmOjpiZWZvcmUge1xyXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC02NXB4O1xyXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtMTJweDtcclxuICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgKyA2NXB4ICsgMTJweCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAmLnJlY2VpdmVkIHtcclxuICAgICAgICAmOjpiZWZvcmUge1xyXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC00MHB4O1xyXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNTBweDtcclxuICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgKyA5MHB4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkaXYge1xyXG4gICAgICBjdXJzb3I6IGF1dG87XHJcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XHJcbiAgICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xyXG5cclxuICAgICAgaW1nIHtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiA1cHg7XHJcbiAgICAgICAgbWFyZ2luOiA2cHggMDtcclxuICAgICAgICBvYmplY3QtZml0OiB1bnNldDtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJi5hdmF0YXIge1xyXG4gICAgICAgIGJvdHRvbTogLTI0cHg7XHJcbiAgICAgICAgbGVmdDogLTMwcHg7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG5cclxuICAgICAgICBpbWcsXHJcbiAgICAgICAgc3ZnIHtcclxuICAgICAgICAgIGFzcGVjdC1yYXRpbzogMS8xO1xyXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgICAgICAgYm90dG9tOiA1cHg7XHJcbiAgICAgICAgICBoZWlnaHQ6IDIycHg7XHJcbiAgICAgICAgICBtYXJnaW46IDE1cHggMDtcclxuICAgICAgICAgIG1heC1oZWlnaHQ6IDIycHg7XHJcbiAgICAgICAgICBtYXgtd2lkdGg6IDIycHg7XHJcbiAgICAgICAgICBtaW4taGVpZ2h0OiAyMnB4O1xyXG4gICAgICAgICAgbWluLXdpZHRoOiAyMnB4O1xyXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgICAgd2lkdGg6IDIycHg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgJi5jYW50LWRlY3J5cHQge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTEwMDAwO1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcblxyXG4gICAgICAmOjphZnRlciB7XHJcbiAgICAgICAgY29udGVudDogXCLwn5SQXCI7XHJcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgICAgIGxlZnQ6IDZweDtcclxuICAgICAgICBtYXJnaW4tbGVmdDogMCAhaW1wb3J0YW50O1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcclxuICAgICAgICB0b3A6IC00cHg7XHJcbiAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZENoYXRMb2c7XHJcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJTY3JvbGxCYXJzIiwiU3R5bGVkQ2hhdExvZyIsIm9sIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledChatLog.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledChatProfile.ts":
/*!********************************************************!*\
  !*** ./components/apps/Messenger/StyledChatProfile.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledChatProfile = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].li.withConfig({\n    componentId: \"sc-7f09ec54-0\"\n})([\n    `\n  figure {\n    display: flex;\n    flex-direction: column;\n    place-items: center;\n\n    img,\n    svg {\n      aspect-ratio: 1/1;\n      border: 2px solid #fff;\n      border-radius: 50%;\n      height: 72px;\n      margin: 16px 0 8px;\n      max-height: 72px;\n      max-width: 72px;\n      min-height: 72px;\n      min-width: 72px;\n      width: 72px;\n    }\n\n    div.verified {\n      svg {\n        bottom: -4px !important;\n        height: 30px !important;\n        left: -6px !important;\n        max-height: 30px !important;\n        max-width: 30px !important;\n        min-height: 30px !important;\n        min-width: 30px !important;\n        width: 30px !important;\n      }\n    }\n\n    figcaption {\n      color: #fff;\n      display: flex;\n      flex-direction: column;\n      font-size: 17px;\n      font-weight: 600;\n      padding-bottom: 10px;\n      place-items: center;\n      text-align: center;\n\n      div.about {\n        color: rgb(255 255 255 / 55%);\n        font-size: 10px;\n        font-weight: 400;\n        overflow-wrap: break-word;\n        padding-top: 5px;\n        width: 60%;\n      }\n\n      div.encryption {\n        background-color: rgb(255 255 255 / 15%);\n        border-radius: 8px;\n        display: flex;\n        flex-direction: column;\n        font-size: 12px;\n        font-weight: 600;\n        gap: 2px;\n        margin: 10px;\n        padding: 10px 20px;\n\n        span:last-child {\n          font-weight: 100;\n        }\n      }\n    }\n  }\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledChatProfile);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ2hhdFByb2ZpbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFFdkMsTUFBTUMsb0JBQW9CRCw0REFBUzs7O0lBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFFcEM7O0FBRUEsaUVBQWVDLGlCQUFpQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZENoYXRQcm9maWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5jb25zdCBTdHlsZWRDaGF0UHJvZmlsZSA9IHN0eWxlZC5saWBcclxuICBmaWd1cmUge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICBwbGFjZS1pdGVtczogY2VudGVyO1xyXG5cclxuICAgIGltZyxcclxuICAgIHN2ZyB7XHJcbiAgICAgIGFzcGVjdC1yYXRpbzogMS8xO1xyXG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xyXG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICAgIGhlaWdodDogNzJweDtcclxuICAgICAgbWFyZ2luOiAxNnB4IDAgOHB4O1xyXG4gICAgICBtYXgtaGVpZ2h0OiA3MnB4O1xyXG4gICAgICBtYXgtd2lkdGg6IDcycHg7XHJcbiAgICAgIG1pbi1oZWlnaHQ6IDcycHg7XHJcbiAgICAgIG1pbi13aWR0aDogNzJweDtcclxuICAgICAgd2lkdGg6IDcycHg7XHJcbiAgICB9XHJcblxyXG4gICAgZGl2LnZlcmlmaWVkIHtcclxuICAgICAgc3ZnIHtcclxuICAgICAgICBib3R0b206IC00cHggIWltcG9ydGFudDtcclxuICAgICAgICBoZWlnaHQ6IDMwcHggIWltcG9ydGFudDtcclxuICAgICAgICBsZWZ0OiAtNnB4ICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgbWF4LWhlaWdodDogMzBweCAhaW1wb3J0YW50O1xyXG4gICAgICAgIG1heC13aWR0aDogMzBweCAhaW1wb3J0YW50O1xyXG4gICAgICAgIG1pbi1oZWlnaHQ6IDMwcHggIWltcG9ydGFudDtcclxuICAgICAgICBtaW4td2lkdGg6IDMwcHggIWltcG9ydGFudDtcclxuICAgICAgICB3aWR0aDogMzBweCAhaW1wb3J0YW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmlnY2FwdGlvbiB7XHJcbiAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICBmb250LXNpemU6IDE3cHg7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XHJcbiAgICAgIHBhZGRpbmctYm90dG9tOiAxMHB4O1xyXG4gICAgICBwbGFjZS1pdGVtczogY2VudGVyO1xyXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblxyXG4gICAgICBkaXYuYWJvdXQge1xyXG4gICAgICAgIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyA1NSUpO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTBweDtcclxuICAgICAgICBmb250LXdlaWdodDogNDAwO1xyXG4gICAgICAgIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XHJcbiAgICAgICAgcGFkZGluZy10b3A6IDVweDtcclxuICAgICAgICB3aWR0aDogNjAlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXYuZW5jcnlwdGlvbiB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gMTUlKTtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xyXG4gICAgICAgIGdhcDogMnB4O1xyXG4gICAgICAgIG1hcmdpbjogMTBweDtcclxuICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XHJcblxyXG4gICAgICAgIHNwYW46bGFzdC1jaGlsZCB7XHJcbiAgICAgICAgICBmb250LXdlaWdodDogMTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZENoYXRQcm9maWxlO1xyXG4iXSwibmFtZXMiOlsic3R5bGVkIiwiU3R5bGVkQ2hhdFByb2ZpbGUiLCJsaSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledChatProfile.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledContacts.ts":
/*!*****************************************************!*\
  !*** ./components/apps/Messenger/StyledContacts.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! motion/react */ \"(pages-dir-browser)/./node_modules/motion/dist/es/react.mjs\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styles/common/ScrollBars */ \"(pages-dir-browser)/./styles/common/ScrollBars.ts\");\n\n\n\nconst StyledContacts = (0,styled_components__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(motion_react__WEBPACK_IMPORTED_MODULE_2__.m.ol).withConfig({\n    componentId: \"sc-e4f2b9de-0\"\n})([\n    `\n  `,\n    `\n  background-color: #242526;\n  height: 100%;\n  overflow-y: auto;\n  position: absolute;\n  scrollbar-gutter: auto;\n  top: 0;\n  width: 100%;\n\n  li {\n    border-radius: 10px;\n    color: #fff;\n    cursor: pointer;\n    margin: 8px;\n    padding: 8px;\n    position: relative;\n\n    button {\n      cursor: pointer;\n    }\n\n    &:hover {\n      background-color: #3a3b3c;\n    }\n\n    &:focus,\n    &.selected {\n      background-color: rgb(45 136 255 / 20%);\n    }\n\n    figure {\n      cursor: pointer;\n      display: flex;\n      gap: 12px;\n      width: calc(100% - 15px);\n\n      div {\n        cursor: pointer;\n      }\n\n      img,\n      svg {\n        aspect-ratio: 1/1;\n        border-radius: 50%;\n        cursor: pointer;\n        height: 56px;\n        max-height: 56px;\n        max-width: 56px;\n        min-height: 56px;\n        min-width: 56px;\n        pointer-events: none;\n        width: 56px;\n      }\n\n      figcaption {\n        cursor: pointer;\n        display: flex;\n        flex-direction: column;\n        gap: 3px;\n        justify-content: center;\n        overflow: hidden;\n        place-items: flex-start;\n\n        > span {\n          color: #e4e6eb;\n          cursor: pointer;\n          font-size: 17px;\n          font-weight: 600;\n        }\n\n        > div {\n          color: #b0b3b8;\n          cursor: pointer;\n          display: flex;\n          font-size: 14px;\n          gap: 3px;\n          width: 100%;\n\n          div:first-child {\n            cursor: pointer;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            white-space: nowrap;\n\n            &.unread {\n              color: #fff;\n              font-weight: 600;\n            }\n          }\n\n          div:last-child {\n            color: #8b8d92;\n            cursor: pointer;\n            padding-right: 10px;\n          }\n        }\n      }\n    }\n\n    &.unread::after {\n      background-color: rgb(46 137 255);\n      border-radius: 50%;\n      content: \"\";\n      cursor: pointer;\n      height: 10px;\n      pointer-events: none;\n      position: absolute;\n      right: 8px;\n      top: calc(50% - 5px);\n      width: 10px;\n    }\n  }\n`\n], (0,styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledContacts);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkQ29udGFjdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyQztBQUNKO0FBQ1c7QUFFbEQsTUFBTUksaUJBQWlCRiw2REFBTUEsQ0FBQ0QsMkNBQU1BLENBQUNJLEVBQUU7OztJQUFFO0VBQ3ZDO0lBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnSGpCO0dBaEhJRixvRUFBVUE7QUFrSGQsaUVBQWVDLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxTdHlsZWRDb250YWN0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtIGFzIG1vdGlvbiB9IGZyb20gXCJtb3Rpb24vcmVhY3RcIjtcclxuaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuaW1wb3J0IFNjcm9sbEJhcnMgZnJvbSBcInN0eWxlcy9jb21tb24vU2Nyb2xsQmFyc1wiO1xyXG5cclxuY29uc3QgU3R5bGVkQ29udGFjdHMgPSBzdHlsZWQobW90aW9uLm9sKWBcclxuICAke1Njcm9sbEJhcnMoKX1cclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNTI2O1xyXG4gIGhlaWdodDogMTAwJTtcclxuICBvdmVyZmxvdy15OiBhdXRvO1xyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICBzY3JvbGxiYXItZ3V0dGVyOiBhdXRvO1xyXG4gIHRvcDogMDtcclxuICB3aWR0aDogMTAwJTtcclxuXHJcbiAgbGkge1xyXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgbWFyZ2luOiA4cHg7XHJcbiAgICBwYWRkaW5nOiA4cHg7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcblxyXG4gICAgYnV0dG9uIHtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgfVxyXG5cclxuICAgICY6aG92ZXIge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2EzYjNjO1xyXG4gICAgfVxyXG5cclxuICAgICY6Zm9jdXMsXHJcbiAgICAmLnNlbGVjdGVkIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDQ1IDEzNiAyNTUgLyAyMCUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpZ3VyZSB7XHJcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgZ2FwOiAxMnB4O1xyXG4gICAgICB3aWR0aDogY2FsYygxMDAlIC0gMTVweCk7XHJcblxyXG4gICAgICBkaXYge1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW1nLFxyXG4gICAgICBzdmcge1xyXG4gICAgICAgIGFzcGVjdC1yYXRpbzogMS8xO1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgaGVpZ2h0OiA1NnB4O1xyXG4gICAgICAgIG1heC1oZWlnaHQ6IDU2cHg7XHJcbiAgICAgICAgbWF4LXdpZHRoOiA1NnB4O1xyXG4gICAgICAgIG1pbi1oZWlnaHQ6IDU2cHg7XHJcbiAgICAgICAgbWluLXdpZHRoOiA1NnB4O1xyXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgIHdpZHRoOiA1NnB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmaWdjYXB0aW9uIHtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICAgIGdhcDogM3B4O1xyXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgcGxhY2UtaXRlbXM6IGZsZXgtc3RhcnQ7XHJcblxyXG4gICAgICAgID4gc3BhbiB7XHJcbiAgICAgICAgICBjb2xvcjogI2U0ZTZlYjtcclxuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcclxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICA+IGRpdiB7XHJcbiAgICAgICAgICBjb2xvcjogI2IwYjNiODtcclxuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICAgICAgICBnYXA6IDNweDtcclxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xyXG5cclxuICAgICAgICAgIGRpdjpmaXJzdC1jaGlsZCB7XHJcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XHJcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XHJcblxyXG4gICAgICAgICAgICAmLnVucmVhZCB7XHJcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRpdjpsYXN0LWNoaWxkIHtcclxuICAgICAgICAgICAgY29sb3I6ICM4YjhkOTI7XHJcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAmLnVucmVhZDo6YWZ0ZXIge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNDYgMTM3IDI1NSk7XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgICAgY29udGVudDogXCJcIjtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICBoZWlnaHQ6IDEwcHg7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHJpZ2h0OiA4cHg7XHJcbiAgICAgIHRvcDogY2FsYyg1MCUgLSA1cHgpO1xyXG4gICAgICB3aWR0aDogMTBweDtcclxuICAgIH1cclxuICB9XHJcbmA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWRDb250YWN0cztcclxuIl0sIm5hbWVzIjpbIm0iLCJtb3Rpb24iLCJzdHlsZWQiLCJTY3JvbGxCYXJzIiwiU3R5bGVkQ29udGFjdHMiLCJvbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledContacts.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledGetMoreMessages.ts":
/*!************************************************************!*\
  !*** ./components/apps/Messenger/StyledGetMoreMessages.ts ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledGetMoreMessages = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].li.withConfig({\n    componentId: \"sc-a6c129ee-0\"\n})([\n    `\n  background-color: rgb(68 69 70 / 50%);\n\n  &:hover {\n    background-color: rgb(68 69 70 / 80%);\n  }\n\n  button {\n    color: inherit;\n    display: flex;\n    font-size: 16px;\n    font-weight: 600;\n    height: 30px;\n    place-content: center;\n    place-items: center;\n\n    &:disabled {\n      opacity: 25%;\n    }\n  }\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledGetMoreMessages);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkR2V0TW9yZU1lc3NhZ2VzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBRXZDLE1BQU1DLHdCQUF3QkQsNERBQVM7OztJQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CeEM7O0FBRUEsaUVBQWVDLHFCQUFxQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZEdldE1vcmVNZXNzYWdlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuY29uc3QgU3R5bGVkR2V0TW9yZU1lc3NhZ2VzID0gc3R5bGVkLmxpYFxyXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig2OCA2OSA3MCAvIDUwJSk7XHJcblxyXG4gICY6aG92ZXIge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDY4IDY5IDcwIC8gODAlKTtcclxuICB9XHJcblxyXG4gIGJ1dHRvbiB7XHJcbiAgICBjb2xvcjogaW5oZXJpdDtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbiAgICBmb250LXdlaWdodDogNjAwO1xyXG4gICAgaGVpZ2h0OiAzMHB4O1xyXG4gICAgcGxhY2UtY29udGVudDogY2VudGVyO1xyXG4gICAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcclxuXHJcbiAgICAmOmRpc2FibGVkIHtcclxuICAgICAgb3BhY2l0eTogMjUlO1xyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZEdldE1vcmVNZXNzYWdlcztcclxuIl0sIm5hbWVzIjpbInN0eWxlZCIsIlN0eWxlZEdldE1vcmVNZXNzYWdlcyIsImxpIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledGetMoreMessages.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledMessenger.ts":
/*!******************************************************!*\
  !*** ./components/apps/Messenger/StyledMessenger.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledMessenger = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n    componentId: \"sc-f61ee497-0\"\n})([\n    `\n  display: flex;\n  flex-direction: column;\n\n  > div:nth-child(2) {\n    height: calc(100% - 69px);\n    position: relative;\n  }\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledMessenger);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkTWVzc2VuZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBRXZDLE1BQU1DLGtCQUFrQkQsNkRBQVU7OztJQUFDOzs7Ozs7OztBQVFuQzs7QUFFQSxpRUFBZUMsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZE1lc3Nlbmdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuY29uc3QgU3R5bGVkTWVzc2VuZ2VyID0gc3R5bGVkLmRpdmBcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcblxyXG4gID4gZGl2Om50aC1jaGlsZCgyKSB7XHJcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDY5cHgpO1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZE1lc3NlbmdlcjtcclxuIl0sIm5hbWVzIjpbInN0eWxlZCIsIlN0eWxlZE1lc3NlbmdlciIsImRpdiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledMessenger.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledProfile.ts":
/*!****************************************************!*\
  !*** ./components/apps/Messenger/StyledProfile.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledProfile = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].figure.withConfig({\n    componentId: \"sc-3842999d-0\"\n})([\n    `\n  > div {\n    cursor: `,\n    `;\n    position: relative;\n\n    > img,\n    > svg {\n      cursor: inherit;\n    }\n\n    div.verified {\n      cursor: inherit;\n\n      svg {\n        border: none;\n        bottom: 2px;\n        color: #000;\n        cursor: inherit;\n        fill: #000;\n        height: 18px;\n        left: -2px;\n        max-width: 18px;\n        min-height: auto;\n        min-width: 18px;\n        position: absolute;\n        width: 18px;\n\n        path {\n          cursor: inherit;\n        }\n      }\n    }\n  }\n`\n], ({ $clickable })=>$clickable ? \"pointer\" : \"default\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledProfile);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkUHJvZmlsZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQU12QyxNQUFNQyxnQkFBZ0JELGdFQUFhOzs7SUFBcUI7O1lBRTVDO0lBQTJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0J2RTtHQS9CYyxDQUFDLEVBQUVHLFVBQVUsRUFBRSxHQUFNQSxhQUFhLFlBQVk7QUFpQzVELGlFQUFlRixhQUFhQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXGNvbXBvbmVudHNcXGFwcHNcXE1lc3NlbmdlclxcU3R5bGVkUHJvZmlsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxudHlwZSBTdHlsZWRQcm9maWxlUHJvcHMgPSB7XHJcbiAgJGNsaWNrYWJsZT86IGJvb2xlYW47XHJcbn07XHJcblxyXG5jb25zdCBTdHlsZWRQcm9maWxlID0gc3R5bGVkLmZpZ3VyZTxTdHlsZWRQcm9maWxlUHJvcHM+YFxyXG4gID4gZGl2IHtcclxuICAgIGN1cnNvcjogJHsoeyAkY2xpY2thYmxlIH0pID0+ICgkY2xpY2thYmxlID8gXCJwb2ludGVyXCIgOiBcImRlZmF1bHRcIil9O1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG5cclxuICAgID4gaW1nLFxyXG4gICAgPiBzdmcge1xyXG4gICAgICBjdXJzb3I6IGluaGVyaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZGl2LnZlcmlmaWVkIHtcclxuICAgICAgY3Vyc29yOiBpbmhlcml0O1xyXG5cclxuICAgICAgc3ZnIHtcclxuICAgICAgICBib3JkZXI6IG5vbmU7XHJcbiAgICAgICAgYm90dG9tOiAycHg7XHJcbiAgICAgICAgY29sb3I6ICMwMDA7XHJcbiAgICAgICAgY3Vyc29yOiBpbmhlcml0O1xyXG4gICAgICAgIGZpbGw6ICMwMDA7XHJcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xyXG4gICAgICAgIGxlZnQ6IC0ycHg7XHJcbiAgICAgICAgbWF4LXdpZHRoOiAxOHB4O1xyXG4gICAgICAgIG1pbi1oZWlnaHQ6IGF1dG87XHJcbiAgICAgICAgbWluLXdpZHRoOiAxOHB4O1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB3aWR0aDogMThweDtcclxuXHJcbiAgICAgICAgcGF0aCB7XHJcbiAgICAgICAgICBjdXJzb3I6IGluaGVyaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVkUHJvZmlsZTtcclxuIl0sIm5hbWVzIjpbInN0eWxlZCIsIlN0eWxlZFByb2ZpbGUiLCJmaWd1cmUiLCIkY2xpY2thYmxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledProfile.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledProfileBanner.ts":
/*!**********************************************************!*\
  !*** ./components/apps/Messenger/StyledProfileBanner.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledProfileBanner = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n    componentId: \"sc-888b48f-0\"\n})([\n    `\n  background: linear-gradient(hsl(207 100% 72% / 50%), rgb(0 0 0 / 100%));\n  border-bottom: 1px solid rgb(57 58 59);\n  color: #fff;\n  display: flex;\n  font-size: 24px;\n  font-weight: 700;\n  height: 69px;\n  max-height: 69px;\n  min-height: 69px;\n  padding: 8px 15px;\n  place-content: space-between;\n  place-items: center;\n  position: relative;\n  text-shadow: 1px 1px 1px #000;\n\n  figure {\n    display: flex;\n    flex-direction: row-reverse;\n    gap: 15px;\n    place-items: center;\n\n    svg,\n    img {\n      aspect-ratio: 1/1;\n      border: 2px solid #fff;\n      border-radius: 50%;\n      cursor: pointer;\n      height: 38px;\n      max-height: 38px;\n      max-width: 38px;\n      min-height: 38px;\n      min-width: 38px;\n      width: 38px;\n\n      path {\n        cursor: pointer;\n      }\n    }\n\n    div {\n      display: flex;\n      place-items: center;\n\n      div.verified {\n        svg {\n          bottom: -3px;\n          left: -5px;\n        }\n      }\n    }\n  }\n\n  button:first-child {\n    border-radius: 5px;\n    cursor: pointer;\n    height: 30px;\n    padding-top: 3px;\n    width: 30px;\n\n    svg:first-child {\n      background-color: rgb(0 0 0 / 50%);\n      border-radius: 5px;\n      color: #fff;\n      fill: #fff;\n      height: 24px;\n      outline: 4px solid rgb(0 0 0 / 50%);\n      pointer-events: none;\n      width: 24px;\n    }\n\n    &:hover {\n      svg:first-child {\n        background-color: rgb(0 0 0 / 75%);\n        outline: 4px solid rgb(0 0 0 / 75%);\n      }\n    }\n  }\n\n  .relays {\n    display: flex;\n    flex-direction: row;\n    left: 0;\n    padding-right: 67px;\n    place-content: flex-end;\n    position: absolute;\n    top: 5px;\n    width: 100%;\n\n    ol {\n      background-color: rgb(0 0 0 / 50%);\n      border-radius: 10px;\n      display: flex;\n      gap: 3px;\n      max-width: calc(100% - 50px);\n      overflow: hidden;\n      padding: 2px 4px;\n\n      li {\n        font-size: 6.5px;\n      }\n    }\n  }\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledProfileBanner);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkUHJvZmlsZUJhbm5lci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUV2QyxNQUFNQyxzQkFBc0JELDZEQUFVOzs7SUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVHdkM7O0FBRUEsaUVBQWVDLG1CQUFtQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZFByb2ZpbGVCYW5uZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmNvbnN0IFN0eWxlZFByb2ZpbGVCYW5uZXIgPSBzdHlsZWQuZGl2YFxyXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChoc2woMjA3IDEwMCUgNzIlIC8gNTAlKSwgcmdiKDAgMCAwIC8gMTAwJSkpO1xyXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoNTcgNTggNTkpO1xyXG4gIGNvbG9yOiAjZmZmO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZm9udC1zaXplOiAyNHB4O1xyXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XHJcbiAgaGVpZ2h0OiA2OXB4O1xyXG4gIG1heC1oZWlnaHQ6IDY5cHg7XHJcbiAgbWluLWhlaWdodDogNjlweDtcclxuICBwYWRkaW5nOiA4cHggMTVweDtcclxuICBwbGFjZS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIHRleHQtc2hhZG93OiAxcHggMXB4IDFweCAjMDAwO1xyXG5cclxuICBmaWd1cmUge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcclxuICAgIGdhcDogMTVweDtcclxuICAgIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gICAgc3ZnLFxyXG4gICAgaW1nIHtcclxuICAgICAgYXNwZWN0LXJhdGlvOiAxLzE7XHJcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICBoZWlnaHQ6IDM4cHg7XHJcbiAgICAgIG1heC1oZWlnaHQ6IDM4cHg7XHJcbiAgICAgIG1heC13aWR0aDogMzhweDtcclxuICAgICAgbWluLWhlaWdodDogMzhweDtcclxuICAgICAgbWluLXdpZHRoOiAzOHB4O1xyXG4gICAgICB3aWR0aDogMzhweDtcclxuXHJcbiAgICAgIHBhdGgge1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRpdiB7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gICAgICBkaXYudmVyaWZpZWQge1xyXG4gICAgICAgIHN2ZyB7XHJcbiAgICAgICAgICBib3R0b206IC0zcHg7XHJcbiAgICAgICAgICBsZWZ0OiAtNXB4O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYnV0dG9uOmZpcnN0LWNoaWxkIHtcclxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGhlaWdodDogMzBweDtcclxuICAgIHBhZGRpbmctdG9wOiAzcHg7XHJcbiAgICB3aWR0aDogMzBweDtcclxuXHJcbiAgICBzdmc6Zmlyc3QtY2hpbGQge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyA1MCUpO1xyXG4gICAgICBib3JkZXItcmFkaXVzOiA1cHg7XHJcbiAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgICBmaWxsOiAjZmZmO1xyXG4gICAgICBoZWlnaHQ6IDI0cHg7XHJcbiAgICAgIG91dGxpbmU6IDRweCBzb2xpZCByZ2IoMCAwIDAgLyA1MCUpO1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgICAgd2lkdGg6IDI0cHg7XHJcbiAgICB9XHJcblxyXG4gICAgJjpob3ZlciB7XHJcbiAgICAgIHN2ZzpmaXJzdC1jaGlsZCB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gNzUlKTtcclxuICAgICAgICBvdXRsaW5lOiA0cHggc29saWQgcmdiKDAgMCAwIC8gNzUlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLnJlbGF5cyB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICAgIGxlZnQ6IDA7XHJcbiAgICBwYWRkaW5nLXJpZ2h0OiA2N3B4O1xyXG4gICAgcGxhY2UtY29udGVudDogZmxleC1lbmQ7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IDVweDtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG5cclxuICAgIG9sIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gNTAlKTtcclxuICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcclxuICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgZ2FwOiAzcHg7XHJcbiAgICAgIG1heC13aWR0aDogY2FsYygxMDAlIC0gNTBweCk7XHJcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgIHBhZGRpbmc6IDJweCA0cHg7XHJcblxyXG4gICAgICBsaSB7XHJcbiAgICAgICAgZm9udC1zaXplOiA2LjVweDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZFByb2ZpbGVCYW5uZXI7XHJcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJTdHlsZWRQcm9maWxlQmFubmVyIiwiZGl2Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledProfileBanner.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledSendMessage.ts":
/*!********************************************************!*\
  !*** ./components/apps/Messenger/StyledSendMessage.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styles/common/ScrollBars */ \"(pages-dir-browser)/./styles/common/ScrollBars.ts\");\n\n\nconst StyledSendMessage = styled_components__WEBPACK_IMPORTED_MODULE_1__[\"default\"].div.withConfig({\n    componentId: \"sc-72062471-0\"\n})([\n    `\n  display: flex;\n  place-items: center;\n\n  textarea {\n    `,\n    `\n    background-color: #3a3b3c;\n    border-radius: 20px;\n    color: #b0b3b8;\n    font-family: `,\n    `;\n    font-size: 14px;\n    height: 35px;\n    margin: 12px 0 12px 12px;\n    max-height: 150px;\n    overflow: hidden auto;\n    padding: 8px 14px 4px;\n    resize: none;\n    width: 100%;\n\n    &:disabled {\n      &::placeholder {\n        color: rgb(117 117 117 / 75%);\n      }\n    }\n  }\n\n  svg {\n    cursor: pointer;\n    fill: #0084ff;\n    height: 28px;\n    margin: 2px 12px 0 10px;\n    width: 28px;\n\n    path {\n      cursor: pointer;\n    }\n\n    &:hover {\n      fill: rgb(0 132 255 / 75%);\n    }\n  }\n\n  button {\n    width: unset;\n\n    &:disabled {\n      svg {\n        fill: #3a3b3c;\n      }\n    }\n  }\n`\n], (0,styles_common_ScrollBars__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), ({ theme })=>theme.formats.systemFont);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledSendMessage);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkU2VuZE1lc3NhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ1c7QUFFbEQsTUFBTUUsb0JBQW9CRiw2REFBVTs7O0lBQUM7Ozs7O0lBS2pDO0lBQWU7Ozs7aUJBSUY7SUFBMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDM0Q7R0E5Q01DLG9FQUFVQSxJQUlHLENBQUMsRUFBRUcsS0FBSyxFQUFFLEdBQUtBLE1BQU1DLE9BQU8sQ0FBQ0MsVUFBVTtBQTRDMUQsaUVBQWVKLGlCQUFpQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZFNlbmRNZXNzYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcbmltcG9ydCBTY3JvbGxCYXJzIGZyb20gXCJzdHlsZXMvY29tbW9uL1Njcm9sbEJhcnNcIjtcclxuXHJcbmNvbnN0IFN0eWxlZFNlbmRNZXNzYWdlID0gc3R5bGVkLmRpdmBcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gIHRleHRhcmVhIHtcclxuICAgICR7U2Nyb2xsQmFycygpfVxyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNhM2IzYztcclxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XHJcbiAgICBjb2xvcjogI2IwYjNiODtcclxuICAgIGZvbnQtZmFtaWx5OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmZvcm1hdHMuc3lzdGVtRm9udH07XHJcbiAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICBoZWlnaHQ6IDM1cHg7XHJcbiAgICBtYXJnaW46IDEycHggMCAxMnB4IDEycHg7XHJcbiAgICBtYXgtaGVpZ2h0OiAxNTBweDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW4gYXV0bztcclxuICAgIHBhZGRpbmc6IDhweCAxNHB4IDRweDtcclxuICAgIHJlc2l6ZTogbm9uZTtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG5cclxuICAgICY6ZGlzYWJsZWQge1xyXG4gICAgICAmOjpwbGFjZWhvbGRlciB7XHJcbiAgICAgICAgY29sb3I6IHJnYigxMTcgMTE3IDExNyAvIDc1JSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN2ZyB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBmaWxsOiAjMDA4NGZmO1xyXG4gICAgaGVpZ2h0OiAyOHB4O1xyXG4gICAgbWFyZ2luOiAycHggMTJweCAwIDEwcHg7XHJcbiAgICB3aWR0aDogMjhweDtcclxuXHJcbiAgICBwYXRoIHtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgfVxyXG5cclxuICAgICY6aG92ZXIge1xyXG4gICAgICBmaWxsOiByZ2IoMCAxMzIgMjU1IC8gNzUlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGJ1dHRvbiB7XHJcbiAgICB3aWR0aDogdW5zZXQ7XHJcblxyXG4gICAgJjpkaXNhYmxlZCB7XHJcbiAgICAgIHN2ZyB7XHJcbiAgICAgICAgZmlsbDogIzNhM2IzYztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZFNlbmRNZXNzYWdlO1xyXG4iXSwibmFtZXMiOlsic3R5bGVkIiwiU2Nyb2xsQmFycyIsIlN0eWxlZFNlbmRNZXNzYWdlIiwiZGl2IiwidGhlbWUiLCJmb3JtYXRzIiwic3lzdGVtRm9udCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledSendMessage.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/StyledTo.ts":
/*!***********************************************!*\
  !*** ./components/apps/Messenger/StyledTo.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nconst StyledTo = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n    componentId: \"sc-c9d5e339-0\"\n})([\n    `\n  input {\n    background-color: #242526;\n    border-bottom: 1px solid rgb(57 58 59);\n    color: #fff;\n    padding: 15px;\n    width: 100%;\n  }\n`\n]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StyledTo);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkVG8udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFFdkMsTUFBTUMsV0FBV0QsNkRBQVU7OztJQUFDOzs7Ozs7OztBQVE1Qjs7QUFFQSxpRUFBZUMsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXFN0eWxlZFRvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5jb25zdCBTdHlsZWRUbyA9IHN0eWxlZC5kaXZgXHJcbiAgaW5wdXQge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI0MjUyNjtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoNTcgNTggNTkpO1xyXG4gICAgY29sb3I6ICNmZmY7XHJcbiAgICBwYWRkaW5nOiAxNXB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgfVxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVkVG87XHJcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJTdHlsZWRUbyIsImRpdiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/StyledTo.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/To.tsx":
/*!******************************************!*\
  !*** ./components/apps/Messenger/To.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_apps_Messenger_StyledTo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/StyledTo */ \"(pages-dir-browser)/./components/apps/Messenger/StyledTo.ts\");\n\n\n\nconst To = ({ setRecipientKey })=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledTo__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n            onKeyDown: (event)=>{\n                if (event.key === \"Enter\" && event.currentTarget.value && !setRecipientKey(event.currentTarget.value.trim())) {\n                    // eslint-disable-next-line no-param-reassign\n                    event.currentTarget.value = \"\";\n                }\n            },\n            placeholder: \"Type a Nostr address (npub/nprofile/hex)\",\n            spellCheck: false,\n            type: \"text\",\n            autoFocus: true\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\To.tsx\",\n            lineNumber: 8,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\To.tsx\",\n        lineNumber: 7,\n        columnNumber: 3\n    }, undefined);\n_c = To;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(To));\nvar _c, _c1;\n$RefreshReg$(_c, \"To\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvVG8udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDNkI7QUFJMUQsTUFBTUUsS0FBa0IsQ0FBQyxFQUFFQyxlQUFlLEVBQUUsaUJBQzFDLDhEQUFDRiwwRUFBUUE7a0JBQ1AsNEVBQUNHO1lBQ0NDLFdBQVcsQ0FBQ0M7Z0JBQ1YsSUFDRUEsTUFBTUMsR0FBRyxLQUFLLFdBQ2RELE1BQU1FLGFBQWEsQ0FBQ0MsS0FBSyxJQUN6QixDQUFDTixnQkFBZ0JHLE1BQU1FLGFBQWEsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLEtBQy9DO29CQUNBLDZDQUE2QztvQkFDN0NKLE1BQU1FLGFBQWEsQ0FBQ0MsS0FBSyxHQUFHO2dCQUM5QjtZQUNGO1lBQ0FFLGFBQVk7WUFDWkMsWUFBWTtZQUNaQyxNQUFLO1lBQ0xDLFNBQVM7Ozs7Ozs7Ozs7O0tBaEJUWjtBQXFCTixvRkFBZUYsMkNBQUlBLENBQUNFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcY29tcG9uZW50c1xcYXBwc1xcTWVzc2VuZ2VyXFxUby50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgU3R5bGVkVG8gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvU3R5bGVkVG9cIjtcclxuXHJcbnR5cGUgVG9Qcm9wcyA9IHsgc2V0UmVjaXBpZW50S2V5OiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW4gfTtcclxuXHJcbmNvbnN0IFRvOiBGQzxUb1Byb3BzPiA9ICh7IHNldFJlY2lwaWVudEtleSB9KSA9PiAoXHJcbiAgPFN0eWxlZFRvPlxyXG4gICAgPGlucHV0XHJcbiAgICAgIG9uS2V5RG93bj17KGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiZcclxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUgJiZcclxuICAgICAgICAgICFzZXRSZWNpcGllbnRLZXkoZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfX1cclxuICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIGEgTm9zdHIgYWRkcmVzcyAobnB1Yi9ucHJvZmlsZS9oZXgpXCJcclxuICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XHJcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgYXV0b0ZvY3VzXHJcbiAgICAvPlxyXG4gIDwvU3R5bGVkVG8+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW1vKFRvKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJTdHlsZWRUbyIsIlRvIiwic2V0UmVjaXBpZW50S2V5IiwiaW5wdXQiLCJvbktleURvd24iLCJldmVudCIsImtleSIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsInRyaW0iLCJwbGFjZWhvbGRlciIsInNwZWxsQ2hlY2siLCJ0eXBlIiwiYXV0b0ZvY3VzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/To.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/constants.ts":
/*!************************************************!*\
  !*** ./components/apps/Messenger/constants.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_NIP05_URL: () => (/* binding */ BASE_NIP05_URL),\n/* harmony export */   BASE_RW_RELAYS: () => (/* binding */ BASE_RW_RELAYS),\n/* harmony export */   DM_KIND: () => (/* binding */ DM_KIND),\n/* harmony export */   GROUP_TIME_GAP_IN_SECONDS: () => (/* binding */ GROUP_TIME_GAP_IN_SECONDS),\n/* harmony export */   METADATA_KIND: () => (/* binding */ METADATA_KIND),\n/* harmony export */   NOTIFICATION_SOUND: () => (/* binding */ NOTIFICATION_SOUND),\n/* harmony export */   PRIVATE_KEY_IDB_NAME: () => (/* binding */ PRIVATE_KEY_IDB_NAME),\n/* harmony export */   PUBLIC_KEY_IDB_NAME: () => (/* binding */ PUBLIC_KEY_IDB_NAME),\n/* harmony export */   SEEN_EVENTS_DEBOUNCE_MS: () => (/* binding */ SEEN_EVENTS_DEBOUNCE_MS),\n/* harmony export */   SEEN_EVENT_IDS_PATH: () => (/* binding */ SEEN_EVENT_IDS_PATH),\n/* harmony export */   TIME_FORMAT: () => (/* binding */ TIME_FORMAT),\n/* harmony export */   UNKNOWN_PUBLIC_KEY: () => (/* binding */ UNKNOWN_PUBLIC_KEY),\n/* harmony export */   inLeftOutRight: () => (/* binding */ inLeftOutRight),\n/* harmony export */   inRightOutLeft: () => (/* binding */ inRightOutLeft)\n/* harmony export */ });\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n\nconst BASE_RW_RELAYS = [\n    \"wss://nos.lol\",\n    \"wss://nostr.mom\",\n    \"wss://public.relaying.io\",\n    \"wss://relay1.nostrchat.io\",\n    \"wss://relayable.org\"\n];\nconst METADATA_KIND = 0;\nconst DM_KIND = 4;\nconst PRIVATE_KEY_IDB_NAME = \"nostr_private_key\";\nconst PUBLIC_KEY_IDB_NAME = \"nostr_public_key\";\nconst NOTIFICATION_SOUND = \"/Program Files/Messenger/notification.mp3\";\nconst UNKNOWN_PUBLIC_KEY = \"?\";\nconst BASE_NIP05_URL = \"/.well-known/nostr.json\";\nconst SEEN_EVENT_IDS_PATH = `${utils_constants__WEBPACK_IMPORTED_MODULE_0__.HOME}/seenEvents.json`;\nconst GROUP_TIME_GAP_IN_SECONDS = utils_constants__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS_IN_MINUTE / utils_constants__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS_IN_SECOND * 30;\nconst TIME_FORMAT = {\n    hour: \"numeric\",\n    hour12: true,\n    minute: \"numeric\"\n};\nconst enterExitTransition = {\n    bounce: 0,\n    duration: 0.3,\n    type: \"spring\"\n};\nconst inLeftOutRight = {\n    animate: {\n        transform: \"translateX(0%)\"\n    },\n    exit: {\n        transform: \"translateX(100%)\"\n    },\n    initial: {\n        transform: \"translateX(100%)\"\n    },\n    ...enterExitTransition\n};\nconst inRightOutLeft = {\n    animate: {\n        transform: \"translateX(0%)\"\n    },\n    exit: {\n        transform: \"translateX(-100%)\"\n    },\n    initial: {\n        transform: \"translateX(-100%)\"\n    },\n    ...enterExitTransition\n};\nconst SEEN_EVENTS_DEBOUNCE_MS = 16; // 60 FPS == Math.floor(1000 / 60)\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvY29uc3RhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUt5QjtBQUVsQixNQUFNRyxpQkFBaUI7SUFDNUI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQUM7QUFFSyxNQUFNQyxnQkFBZ0IsRUFBRTtBQUN4QixNQUFNQyxVQUFVLEVBQUU7QUFFbEIsTUFBTUMsdUJBQXVCLG9CQUFvQjtBQUNqRCxNQUFNQyxzQkFBc0IsbUJBQW1CO0FBRS9DLE1BQU1DLHFCQUFxQiw0Q0FBNEM7QUFFdkUsTUFBTUMscUJBQXFCLElBQUk7QUFFL0IsTUFBTUMsaUJBQWlCLDBCQUEwQjtBQUVqRCxNQUFNQyxzQkFBc0IsR0FBR1gsaURBQUlBLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUV0RCxNQUFNWSw0QkFDWCxzRUFBMEJWLG1FQUFzQkEsR0FBSSxHQUFHO0FBRWxELE1BQU1XLGNBQW1EO0lBQzlEQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsUUFBUTtBQUNWLEVBQUU7QUFFRixNQUFNQyxzQkFBc0I7SUFBRUMsUUFBUTtJQUFHQyxVQUFVO0lBQUtDLE1BQU07QUFBUztBQUVoRSxNQUFNQyxpQkFBOEI7SUFDekNDLFNBQVM7UUFBRUMsV0FBVztJQUFpQjtJQUN2Q0MsTUFBTTtRQUFFRCxXQUFXO0lBQW1CO0lBQ3RDRSxTQUFTO1FBQUVGLFdBQVc7SUFBbUI7SUFDekMsR0FBR04sbUJBQW1CO0FBQ3hCLEVBQUU7QUFFSyxNQUFNUyxpQkFBOEI7SUFDekNKLFNBQVM7UUFBRUMsV0FBVztJQUFpQjtJQUN2Q0MsTUFBTTtRQUFFRCxXQUFXO0lBQW9CO0lBQ3ZDRSxTQUFTO1FBQUVGLFdBQVc7SUFBb0I7SUFDMUMsR0FBR04sbUJBQW1CO0FBQ3hCLEVBQUU7QUFFSyxNQUFNVSwwQkFBMEIsR0FBRyxDQUFDLGtDQUFrQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXGNvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0eXBlIE1vdGlvblByb3BzIH0gZnJvbSBcIm1vdGlvbi9yZWFjdFwiO1xyXG5pbXBvcnQge1xyXG4gIEhPTUUsXHJcbiAgTUlMTElTRUNPTkRTX0lOX01JTlVURSxcclxuICBNSUxMSVNFQ09ORFNfSU5fU0VDT05ELFxyXG59IGZyb20gXCJ1dGlscy9jb25zdGFudHNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBCQVNFX1JXX1JFTEFZUyA9IFtcclxuICBcIndzczovL25vcy5sb2xcIixcclxuICBcIndzczovL25vc3RyLm1vbVwiLFxyXG4gIFwid3NzOi8vcHVibGljLnJlbGF5aW5nLmlvXCIsXHJcbiAgXCJ3c3M6Ly9yZWxheTEubm9zdHJjaGF0LmlvXCIsXHJcbiAgXCJ3c3M6Ly9yZWxheWFibGUub3JnXCIsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgTUVUQURBVEFfS0lORCA9IDA7XHJcbmV4cG9ydCBjb25zdCBETV9LSU5EID0gNDtcclxuXHJcbmV4cG9ydCBjb25zdCBQUklWQVRFX0tFWV9JREJfTkFNRSA9IFwibm9zdHJfcHJpdmF0ZV9rZXlcIjtcclxuZXhwb3J0IGNvbnN0IFBVQkxJQ19LRVlfSURCX05BTUUgPSBcIm5vc3RyX3B1YmxpY19rZXlcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBOT1RJRklDQVRJT05fU09VTkQgPSBcIi9Qcm9ncmFtIEZpbGVzL01lc3Nlbmdlci9ub3RpZmljYXRpb24ubXAzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgVU5LTk9XTl9QVUJMSUNfS0VZID0gXCI/XCI7XHJcblxyXG5leHBvcnQgY29uc3QgQkFTRV9OSVAwNV9VUkwgPSBcIi8ud2VsbC1rbm93bi9ub3N0ci5qc29uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgU0VFTl9FVkVOVF9JRFNfUEFUSCA9IGAke0hPTUV9L3NlZW5FdmVudHMuanNvbmA7XHJcblxyXG5leHBvcnQgY29uc3QgR1JPVVBfVElNRV9HQVBfSU5fU0VDT05EUyA9XHJcbiAgKE1JTExJU0VDT05EU19JTl9NSU5VVEUgLyBNSUxMSVNFQ09ORFNfSU5fU0VDT05EKSAqIDMwO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRJTUVfRk9STUFUOiBQYXJ0aWFsPEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zPiA9IHtcclxuICBob3VyOiBcIm51bWVyaWNcIixcclxuICBob3VyMTI6IHRydWUsXHJcbiAgbWludXRlOiBcIm51bWVyaWNcIixcclxufTtcclxuXHJcbmNvbnN0IGVudGVyRXhpdFRyYW5zaXRpb24gPSB7IGJvdW5jZTogMCwgZHVyYXRpb246IDAuMywgdHlwZTogXCJzcHJpbmdcIiB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluTGVmdE91dFJpZ2h0OiBNb3Rpb25Qcm9wcyA9IHtcclxuICBhbmltYXRlOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDAlKVwiIH0sXHJcbiAgZXhpdDogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgxMDAlKVwiIH0sXHJcbiAgaW5pdGlhbDogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgxMDAlKVwiIH0sXHJcbiAgLi4uZW50ZXJFeGl0VHJhbnNpdGlvbixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpblJpZ2h0T3V0TGVmdDogTW90aW9uUHJvcHMgPSB7XHJcbiAgYW5pbWF0ZTogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgwJSlcIiB9LFxyXG4gIGV4aXQ6IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLTEwMCUpXCIgfSxcclxuICBpbml0aWFsOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKC0xMDAlKVwiIH0sXHJcbiAgLi4uZW50ZXJFeGl0VHJhbnNpdGlvbixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBTRUVOX0VWRU5UU19ERUJPVU5DRV9NUyA9IDE2OyAvLyA2MCBGUFMgPT0gTWF0aC5mbG9vcigxMDAwIC8gNjApXHJcbiJdLCJuYW1lcyI6WyJIT01FIiwiTUlMTElTRUNPTkRTX0lOX01JTlVURSIsIk1JTExJU0VDT05EU19JTl9TRUNPTkQiLCJCQVNFX1JXX1JFTEFZUyIsIk1FVEFEQVRBX0tJTkQiLCJETV9LSU5EIiwiUFJJVkFURV9LRVlfSURCX05BTUUiLCJQVUJMSUNfS0VZX0lEQl9OQU1FIiwiTk9USUZJQ0FUSU9OX1NPVU5EIiwiVU5LTk9XTl9QVUJMSUNfS0VZIiwiQkFTRV9OSVAwNV9VUkwiLCJTRUVOX0VWRU5UX0lEU19QQVRIIiwiR1JPVVBfVElNRV9HQVBfSU5fU0VDT05EUyIsIlRJTUVfRk9STUFUIiwiaG91ciIsImhvdXIxMiIsIm1pbnV0ZSIsImVudGVyRXhpdFRyYW5zaXRpb24iLCJib3VuY2UiLCJkdXJhdGlvbiIsInR5cGUiLCJpbkxlZnRPdXRSaWdodCIsImFuaW1hdGUiLCJ0cmFuc2Zvcm0iLCJleGl0IiwiaW5pdGlhbCIsImluUmlnaHRPdXRMZWZ0IiwiU0VFTl9FVkVOVFNfREVCT1VOQ0VfTVMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/constants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/functions.ts":
/*!************************************************!*\
  !*** ./components/apps/Messenger/functions.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertImageLinksToHtml: () => (/* binding */ convertImageLinksToHtml),\n/* harmony export */   convertNewLinesToBreaks: () => (/* binding */ convertNewLinesToBreaks),\n/* harmony export */   copyKeyMenuItems: () => (/* binding */ copyKeyMenuItems),\n/* harmony export */   createMessageEvent: () => (/* binding */ createMessageEvent),\n/* harmony export */   createProfileEvent: () => (/* binding */ createProfileEvent),\n/* harmony export */   dataToProfile: () => (/* binding */ dataToProfile),\n/* harmony export */   decryptMessage: () => (/* binding */ decryptMessage),\n/* harmony export */   descCreatedAt: () => (/* binding */ descCreatedAt),\n/* harmony export */   getKeyFromTags: () => (/* binding */ getKeyFromTags),\n/* harmony export */   getMessages: () => (/* binding */ getMessages),\n/* harmony export */   getNip05Domain: () => (/* binding */ getNip05Domain),\n/* harmony export */   getPrivateKey: () => (/* binding */ getPrivateKey),\n/* harmony export */   getPublicHexFromNostrAddress: () => (/* binding */ getPublicHexFromNostrAddress),\n/* harmony export */   getPublicHexKey: () => (/* binding */ getPublicHexKey),\n/* harmony export */   getRelayUrls: () => (/* binding */ getRelayUrls),\n/* harmony export */   getWebSocketStatusIcon: () => (/* binding */ getWebSocketStatusIcon),\n/* harmony export */   groupChatEvents: () => (/* binding */ groupChatEvents),\n/* harmony export */   maybeGetExistingPublicKey: () => (/* binding */ maybeGetExistingPublicKey),\n/* harmony export */   prettyChatTimestamp: () => (/* binding */ prettyChatTimestamp),\n/* harmony export */   shortTimeStamp: () => (/* binding */ shortTimeStamp),\n/* harmony export */   toHexKey: () => (/* binding */ toHexKey)\n/* harmony export */ });\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nostr-tools */ \"(pages-dir-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n// eslint-disable-next-line import/consistent-type-specifier-style\n\n\n\n\nconst getRelayUrls = async ()=>{\n    if (window.nostr?.getRelays) {\n        try {\n            return [\n                ...new Set([\n                    ...components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.BASE_RW_RELAYS,\n                    ...Object.entries(await window.nostr.getRelays()).map(([url])=>url.endsWith(\"/\") ? url.slice(0, -1) : url)\n                ])\n            ];\n        } catch  {\n        // Ignore failure to get relays\n        }\n    }\n    return components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.BASE_RW_RELAYS;\n};\nconst toHexKey = (key)=>{\n    if (key.startsWith(\"nprofile\") || key.startsWith(\"npub\") || key.startsWith(\"nsec\")) {\n        try {\n            const { data } = nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.decode(key);\n            if (typeof data === \"string\") return data;\n            if (typeof data === \"object\" && typeof data.pubkey === \"string\") {\n                return data.pubkey;\n            }\n        } catch  {\n            return key;\n        }\n    }\n    return key;\n};\nconst getPrivateKey = ()=>localStorage.getItem(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_IDB_NAME) || \"\";\nconst maybeGetExistingPublicKey = async ()=>{\n    const idbKey = localStorage.getItem(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_IDB_NAME) || \"\";\n    let publicKey = \"\";\n    try {\n        publicKey = await window.nostr?.getPublicKey() || \"\";\n    } catch  {\n    // Ignore failure to get public key\n    }\n    return publicKey || idbKey || \"\";\n};\nconst getPublicHexKey = (existingPublicKey)=>{\n    if (existingPublicKey) return toHexKey(existingPublicKey);\n    const newPrivateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.generatePrivateKey)();\n    const newPublicKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getPublicKey)(newPrivateKey);\n    localStorage.setItem(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_IDB_NAME, newPublicKey);\n    localStorage.setItem(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_IDB_NAME, newPrivateKey);\n    return toHexKey(newPublicKey);\n};\nconst getKeyFromTags = (tags = [])=>{\n    const [, key = \"\"] = tags.find(([tag])=>tag === \"p\") || [];\n    return key;\n};\nconst decryptedContent = {};\nconst decryptMessage = async (id, content, pubkey)=>{\n    if (decryptedContent[id] || decryptedContent[id] === false) {\n        return decryptedContent[id];\n    }\n    decryptedContent[id] = content;\n    try {\n        const message = await (window.nostr?.nip04 ? window.nostr.nip04.decrypt(pubkey, content) : nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip04.decrypt(toHexKey(getPrivateKey()), pubkey, content));\n        decryptedContent[id] = message;\n        return message;\n    } catch  {\n        decryptedContent[id] = \"\";\n        return \"\";\n    }\n};\nconst encryptMessage = async (content, pubkey)=>{\n    try {\n        return await (window.nostr?.nip04 ? window.nostr.nip04.encrypt(pubkey, content) : nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip04.encrypt(toHexKey(getPrivateKey()), pubkey, content));\n    } catch  {\n    // Ignore failure to decrypt\n    }\n    return \"\";\n};\nconst getMessages = (authorPublicKey, recipientPublicKey, since = 0)=>({\n        enabled: Boolean(authorPublicKey) || Boolean(recipientPublicKey),\n        filter: [\n            {\n                ...recipientPublicKey ? {\n                    \"#p\": [\n                        recipientPublicKey\n                    ]\n                } : {},\n                authors: [\n                    authorPublicKey\n                ],\n                kinds: [\n                    components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.DM_KIND\n                ],\n                since\n            },\n            {\n                ...recipientPublicKey ? {\n                    authors: [\n                        recipientPublicKey\n                    ]\n                } : {},\n                \"#p\": [\n                    authorPublicKey\n                ],\n                kinds: [\n                    components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.DM_KIND\n                ],\n                since\n            }\n        ]\n    });\nconst ascCreatedAt = (a, b)=>a.created_at - b.created_at;\nconst descCreatedAt = (a, b)=>b.created_at - a.created_at;\nconst shortTimeStamp = (timestamp)=>{\n    const now = Date.now();\n    const time = new Date(timestamp * utils_constants__WEBPACK_IMPORTED_MODULE_2__.MILLISECONDS_IN_SECOND).getTime();\n    const diff = now - time;\n    const seconds = Math.floor(diff / utils_constants__WEBPACK_IMPORTED_MODULE_2__.MILLISECONDS_IN_SECOND);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    const weeks = Math.floor(days / 7);\n    if (weeks > 0) return `${weeks}w`;\n    if (days > 0) return `${days}d`;\n    if (hours > 0) return `${hours}h`;\n    if (minutes > 0) return `${minutes}m`;\n    if (seconds < 10) return \"now\";\n    return `${seconds}s`;\n};\nconst copyKeyMenuItems = (hexKey, nsecHex)=>[\n        {\n            action: ()=>navigator.clipboard?.writeText(nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.npubEncode(hexKey)),\n            label: \"Copy npub address\"\n        },\n        ...nsecHex ? [\n            {\n                action: ()=>navigator.clipboard?.writeText(nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.nsecEncode(nsecHex)),\n                label: \"Copy nsec address\"\n            }\n        ] : [\n            {\n                action: ()=>navigator.clipboard?.writeText(hexKey),\n                label: \"Copy hex address\"\n            }\n        ]\n    ];\nconst signEvent = async (event)=>{\n    let signedEvent = event;\n    signedEvent.pubkey = window.nostr?.getPublicKey ? await window.nostr.getPublicKey() : (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getPublicKey)(getPrivateKey());\n    signedEvent.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getEventHash)(event);\n    if (window.nostr?.signEvent) {\n        signedEvent = await window.nostr.signEvent(signedEvent);\n    } else {\n        signedEvent.sig = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getSignature)(signedEvent, toHexKey(getPrivateKey()));\n    }\n    if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.validateEvent)(signedEvent) && (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.verifySignature)(signedEvent)) {\n        signedEvent[nostr_tools__WEBPACK_IMPORTED_MODULE_0__.verifiedSymbol] = true;\n    }\n    return signedEvent;\n};\nconst getUnixTime = ()=>Math.floor(Date.now() / utils_constants__WEBPACK_IMPORTED_MODULE_2__.MILLISECONDS_IN_SECOND);\nconst createProfileEvent = async (profile)=>signEvent({\n        content: JSON.stringify(profile),\n        created_at: getUnixTime(),\n        kind: components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.METADATA_KIND,\n        tags: []\n    });\nconst createMessageEvent = async (message, recipientPublicKey)=>signEvent({\n        content: await encryptMessage(message, recipientPublicKey),\n        created_at: getUnixTime(),\n        kind: components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.DM_KIND,\n        tags: [\n            [\n                \"p\",\n                recipientPublicKey\n            ]\n        ]\n    });\nconst VALID_PICTURE_PROTOCOLS = new Set([\n    \"http\",\n    \"https\",\n    \"data\"\n]);\nconst dataToProfile = (publicKey, data, created_at)=>{\n    const { about, banner, display_name, name, nip05, npub, picture, username, website } = data || {};\n    const [protocol = \"\"] = picture?.split(\":\") || [];\n    return {\n        about,\n        banner,\n        created_at,\n        data,\n        nip05,\n        picture: VALID_PICTURE_PROTOCOLS.has(protocol) ? picture : undefined,\n        userName: display_name || name || username || (npub || (publicKey.startsWith(\"npub\") ? publicKey : nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.npubEncode(publicKey))).slice(0, 12),\n        website\n    };\n};\nconst getPublicHexFromNostrAddress = (key)=>{\n    const nprofile = key.startsWith(\"nprofile\");\n    const nsec = key.startsWith(\"nsec\");\n    if (nprofile || nsec || key.startsWith(\"npub\")) {\n        try {\n            const { data } = nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.decode(key) || {};\n            const hex = nprofile ? data?.pubkey : data;\n            return nsec ? (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getPublicKey)(hex) : hex;\n        } catch  {\n            return \"\";\n        }\n    }\n    try {\n        return toHexKey(nostr_tools__WEBPACK_IMPORTED_MODULE_0__.nip19.npubEncode(key));\n    } catch  {\n        return \"\";\n    }\n};\nconst verifiedNip05Addresses = {};\nconst TIMEOUT_ERRORS = new Set([\n    408,\n    504\n]);\nconst getNip05Domain = async (nip05address, pubkey)=>{\n    if (!nip05address || !pubkey) return \"\";\n    try {\n        const [userName, domain] = nip05address.split(\"@\");\n        if (verifiedNip05Addresses[pubkey] === domain) return domain;\n        if (typeof verifiedNip05Addresses[pubkey] === \"number\" && !TIMEOUT_ERRORS.has(verifiedNip05Addresses[pubkey])) {\n            return \"\";\n        }\n        const nostrJson = await fetch(`https://${domain}${components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.BASE_NIP05_URL}?name=${userName}`);\n        if (nostrJson.ok) {\n            const { names = {} } = await nostrJson.json() || {};\n            let verified = false;\n            if (userName === \"_\") {\n                const [userKey, ...otherKeys] = Object.values(names);\n                const keyValue = otherKeys.length === 0 ? userKey : names[userName];\n                verified = keyValue === pubkey;\n            } else if (names[userName]) {\n                verified = names[userName] === pubkey;\n            }\n            if (verified) {\n                verifiedNip05Addresses[pubkey] = domain;\n            }\n            return verified ? domain : \"\";\n        }\n        verifiedNip05Addresses[pubkey] = nostrJson.status;\n    } catch  {\n        verifiedNip05Addresses[pubkey] = 0;\n    }\n    return \"\";\n};\nconst getWebSocketStatusIcon = (status)=>{\n    switch(status){\n        case WebSocket.prototype.CONNECTING:\n            return \"ðŸŸ¡\";\n        case WebSocket.prototype.OPEN:\n            return \"ðŸŸ¢\";\n        case WebSocket.prototype.CLOSING:\n            return \"ðŸŸ \";\n        default:\n            return \"ðŸ”´\";\n    }\n};\nconst convertImageLinksToHtml = (content)=>content.replace(/https?:\\/\\/\\S+\\.(?:png|jpg|jpeg|gif|webp)/gi, (match)=>`<img decoding=\"async\" loading=\"lazy\" src=\"${match}\" />`);\nconst convertNewLinesToBreaks = (content)=>content.replace(/\\n/g, \"<br />\");\nconst prettyChatTimestamp = (timestamp)=>{\n    const date = new Date(timestamp * utils_constants__WEBPACK_IMPORTED_MODULE_2__.MILLISECONDS_IN_SECOND);\n    const now = new Date();\n    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();\n    const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1).getTime();\n    const dateTimestamp = date.getTime();\n    const datePretty = date.toLocaleString(\"en-US\", components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.TIME_FORMAT);\n    if (dateTimestamp > today) return datePretty;\n    if (dateTimestamp > yesterday) return `Yesterday at ${datePretty}`;\n    if (dateTimestamp > today - 6 * utils_constants__WEBPACK_IMPORTED_MODULE_2__.MILLISECONDS_IN_DAY) {\n        return date.toLocaleString(\"en-US\", {\n            ...components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.TIME_FORMAT,\n            weekday: \"long\"\n        });\n    }\n    return date.toLocaleString(\"en-US\", {\n        ...components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.TIME_FORMAT,\n        day: \"numeric\",\n        month: \"short\",\n        year: \"numeric\"\n    });\n};\nconst groupChatEvents = (events)=>{\n    if (events.length === 0) return [];\n    const sortedEvents = (0,utils_functions__WEBPACK_IMPORTED_MODULE_3__.toSorted)(events, ascCreatedAt);\n    const [oldestEvent, ...remainingEvents] = sortedEvents;\n    const groupedEvents = [\n        [\n            prettyChatTimestamp(oldestEvent.created_at),\n            [\n                oldestEvent\n            ]\n        ]\n    ];\n    remainingEvents.forEach((event)=>{\n        const { created_at } = event;\n        const [, lastGroupedEvents] = groupedEvents[groupedEvents.length - 1];\n        const { created_at: last_created_at } = lastGroupedEvents[lastGroupedEvents.length - 1];\n        if (Math.abs(created_at - last_created_at) < components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_1__.GROUP_TIME_GAP_IN_SECONDS) {\n            lastGroupedEvents.push(event);\n        } else {\n            groupedEvents.push([\n                prettyChatTimestamp(created_at),\n                [\n                    event\n                ]\n            ]);\n        }\n    });\n    return groupedEvents;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvZnVuY3Rpb25zLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0U7QUFnQjdDO0FBVXdCO0FBU2lDO0FBQ25DO0FBRXBDLE1BQU1vQixlQUFlO0lBQzFCLElBQUlDLE9BQU9DLEtBQUssRUFBRUMsV0FBVztRQUMzQixJQUFJO1lBQ0YsT0FBTzttQkFDRixJQUFJQyxJQUFJO3VCQUNOZCwrRUFBY0E7dUJBQ2RlLE9BQU9DLE9BQU8sQ0FBQyxNQUFNTCxPQUFPQyxLQUFLLENBQUNDLFNBQVMsSUFBSUksR0FBRyxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxHQUMxREEsSUFBSUMsUUFBUSxDQUFDLE9BQU9ELElBQUlFLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBS0Y7aUJBRTFDO2FBQ0Y7UUFDSCxFQUFFLE9BQU07UUFDTiwrQkFBK0I7UUFDakM7SUFDRjtJQUVBLE9BQU9sQiwrRUFBY0E7QUFDdkIsRUFBRTtBQUVLLE1BQU1xQixXQUFXLENBQUNDO0lBQ3ZCLElBQ0VBLElBQUlDLFVBQVUsQ0FBQyxlQUNmRCxJQUFJQyxVQUFVLENBQUMsV0FDZkQsSUFBSUMsVUFBVSxDQUFDLFNBQ2Y7UUFDQSxJQUFJO1lBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRzdCLDhDQUFLQSxDQUFDOEIsTUFBTSxDQUFDSDtZQUU5QixJQUFJLE9BQU9FLFNBQVMsVUFBVSxPQUFPQTtZQUVyQyxJQUNFLE9BQU9BLFNBQVMsWUFDaEIsT0FBTyxLQUF5QkUsTUFBTSxLQUFLLFVBQzNDO2dCQUNBLE9BQU8sS0FBeUJBLE1BQU07WUFDeEM7UUFDRixFQUFFLE9BQU07WUFDTixPQUFPSjtRQUNUO0lBQ0Y7SUFFQSxPQUFPQTtBQUNULEVBQUU7QUFFSyxNQUFNSyxnQkFBZ0IsSUFDM0JDLGFBQWFDLE9BQU8sQ0FBQ3pCLHFGQUFvQkEsS0FBSyxHQUFHO0FBRTVDLE1BQU0wQiw0QkFBNEI7SUFDdkMsTUFBTUMsU0FBU0gsYUFBYUMsT0FBTyxDQUFDeEIsb0ZBQW1CQSxLQUFLO0lBQzVELElBQUkyQixZQUFZO0lBRWhCLElBQUk7UUFDRkEsWUFBWSxNQUFPckIsT0FBT0MsS0FBSyxFQUFFcEIsa0JBQW1CO0lBQ3RELEVBQUUsT0FBTTtJQUNOLG1DQUFtQztJQUNyQztJQUVBLE9BQU93QyxhQUFhRCxVQUFVO0FBQ2hDLEVBQUU7QUFFSyxNQUFNRSxrQkFBa0IsQ0FBQ0M7SUFDOUIsSUFBSUEsbUJBQW1CLE9BQU9iLFNBQVNhO0lBRXZDLE1BQU1DLGdCQUFnQjdDLCtEQUFrQkE7SUFDeEMsTUFBTThDLGVBQWU1Qyx5REFBWUEsQ0FBQzJDO0lBRWxDUCxhQUFhUyxPQUFPLENBQUNoQyxvRkFBbUJBLEVBQUUrQjtJQUMxQ1IsYUFBYVMsT0FBTyxDQUFDakMscUZBQW9CQSxFQUFFK0I7SUFFM0MsT0FBT2QsU0FBU2U7QUFDbEIsRUFBRTtBQUVLLE1BQU1FLGlCQUFpQixDQUFDQyxPQUFtQixFQUFFO0lBQ2xELE1BQU0sR0FBR2pCLE1BQU0sRUFBRSxDQUFDLEdBQUdpQixLQUFLQyxJQUFJLENBQUMsQ0FBQyxDQUFDQyxJQUFJLEdBQUtBLFFBQVEsUUFBUSxFQUFFO0lBRTVELE9BQU9uQjtBQUNULEVBQUU7QUFFRixNQUFNb0IsbUJBQXFDLENBQUM7QUFFckMsTUFBTUMsaUJBQWlCLE9BQzVCQyxJQUNBQyxTQUNBbkI7SUFFQSxJQUFJZ0IsZ0JBQWdCLENBQUNFLEdBQUcsSUFBSUYsZ0JBQWdCLENBQUNFLEdBQUcsS0FBSyxPQUFPO1FBQzFELE9BQU9GLGdCQUFnQixDQUFDRSxHQUFHO0lBQzdCO0lBRUFGLGdCQUFnQixDQUFDRSxHQUFHLEdBQUdDO0lBRXZCLElBQUk7UUFDRixNQUFNQyxVQUFVLE1BQU9uQyxDQUFBQSxPQUFPQyxLQUFLLEVBQUVsQixRQUNqQ2lCLE9BQU9DLEtBQUssQ0FBQ2xCLEtBQUssQ0FBQ3FELE9BQU8sQ0FBQ3JCLFFBQVFtQixXQUNuQ25ELDhDQUFLQSxDQUFDcUQsT0FBTyxDQUFDMUIsU0FBU00sa0JBQWtCRCxRQUFRbUIsUUFBTztRQUU1REgsZ0JBQWdCLENBQUNFLEdBQUcsR0FBR0U7UUFFdkIsT0FBT0E7SUFDVCxFQUFFLE9BQU07UUFDTkosZ0JBQWdCLENBQUNFLEdBQUcsR0FBRztRQUV2QixPQUFPO0lBQ1Q7QUFDRixFQUFFO0FBRUYsTUFBTUksaUJBQWlCLE9BQ3JCSCxTQUNBbkI7SUFFQSxJQUFJO1FBQ0YsT0FBTyxNQUFPZixDQUFBQSxPQUFPQyxLQUFLLEVBQUVsQixRQUN4QmlCLE9BQU9DLEtBQUssQ0FBQ2xCLEtBQUssQ0FBQ3VELE9BQU8sQ0FBQ3ZCLFFBQVFtQixXQUNuQ25ELDhDQUFLQSxDQUFDdUQsT0FBTyxDQUFDNUIsU0FBU00sa0JBQWtCRCxRQUFRbUIsUUFBTztJQUM5RCxFQUFFLE9BQU07SUFDTiw0QkFBNEI7SUFDOUI7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxNQUFNSyxjQUFjLENBQ3pCQyxpQkFDQUMsb0JBQ0FDLFFBQVEsQ0FBQyxHQUNRO1FBQ2pCQyxTQUFTQyxRQUFRSixvQkFBb0JJLFFBQVFIO1FBQzdDSSxRQUFRO1lBQ047Z0JBQ0UsR0FBSUoscUJBQXFCO29CQUFFLE1BQU07d0JBQUNBO3FCQUFtQjtnQkFBQyxJQUFJLENBQUMsQ0FBQztnQkFDNURLLFNBQVM7b0JBQUNOO2lCQUFnQjtnQkFDMUJPLE9BQU87b0JBQUN6RCx3RUFBT0E7aUJBQUM7Z0JBQ2hCb0Q7WUFDRjtZQUNBO2dCQUNFLEdBQUlELHFCQUFxQjtvQkFBRUssU0FBUzt3QkFBQ0w7cUJBQW1CO2dCQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvRCxNQUFNO29CQUFDRDtpQkFBZ0I7Z0JBQ3ZCTyxPQUFPO29CQUFDekQsd0VBQU9BO2lCQUFDO2dCQUNoQm9EO1lBQ0Y7U0FDRDtJQUNILEdBQUc7QUFFSCxNQUFNTSxlQUFlLENBQUNDLEdBQVVDLElBQzlCRCxFQUFFRSxVQUFVLEdBQUdELEVBQUVDLFVBQVU7QUFFdEIsTUFBTUMsZ0JBQWdCLENBQUNILEdBQVVDLElBQ3RDQSxFQUFFQyxVQUFVLEdBQUdGLEVBQUVFLFVBQVUsQ0FBQztBQUV2QixNQUFNRSxpQkFBaUIsQ0FBQ0M7SUFDN0IsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixNQUFNRSxPQUFPLElBQUlELEtBQUtGLFlBQVl6RCxtRUFBc0JBLEVBQUU2RCxPQUFPO0lBQ2pFLE1BQU1DLE9BQU9KLE1BQU1FO0lBQ25CLE1BQU1HLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0gsT0FBTzlELG1FQUFzQkE7SUFDeEQsTUFBTWtFLFVBQVVGLEtBQUtDLEtBQUssQ0FBQ0YsVUFBVTtJQUNyQyxNQUFNSSxRQUFRSCxLQUFLQyxLQUFLLENBQUNDLFVBQVU7SUFDbkMsTUFBTUUsT0FBT0osS0FBS0MsS0FBSyxDQUFDRSxRQUFRO0lBQ2hDLE1BQU1FLFFBQVFMLEtBQUtDLEtBQUssQ0FBQ0csT0FBTztJQUVoQyxJQUFJQyxRQUFRLEdBQUcsT0FBTyxHQUFHQSxNQUFNLENBQUMsQ0FBQztJQUNqQyxJQUFJRCxPQUFPLEdBQUcsT0FBTyxHQUFHQSxLQUFLLENBQUMsQ0FBQztJQUMvQixJQUFJRCxRQUFRLEdBQUcsT0FBTyxHQUFHQSxNQUFNLENBQUMsQ0FBQztJQUNqQyxJQUFJRCxVQUFVLEdBQUcsT0FBTyxHQUFHQSxRQUFRLENBQUMsQ0FBQztJQUNyQyxJQUFJSCxVQUFVLElBQUksT0FBTztJQUV6QixPQUFPLEdBQUdBLFFBQVEsQ0FBQyxDQUFDO0FBQ3RCLEVBQUU7QUFFSyxNQUFNTyxtQkFBbUIsQ0FDOUJDLFFBQ0FDLFVBQ2U7UUFDZjtZQUNFQyxRQUFRLElBQU1DLFVBQVVDLFNBQVMsRUFBRUMsVUFBVXpGLDhDQUFLQSxDQUFDMEYsVUFBVSxDQUFDTjtZQUM5RE8sT0FBTztRQUNUO1dBQ0lOLFVBQ0E7WUFDRTtnQkFDRUMsUUFBUSxJQUNOQyxVQUFVQyxTQUFTLEVBQUVDLFVBQVV6Riw4Q0FBS0EsQ0FBQzRGLFVBQVUsQ0FBQ1A7Z0JBQ2xETSxPQUFPO1lBQ1Q7U0FDRCxHQUNEO1lBQ0U7Z0JBQ0VMLFFBQVEsSUFBTUMsVUFBVUMsU0FBUyxFQUFFQyxVQUFVTDtnQkFDN0NPLE9BQU87WUFDVDtTQUNEO0tBQ04sQ0FBQztBQUVGLE1BQU1FLFlBQVksT0FBT0M7SUFDdkIsSUFBSUMsY0FBY0Q7SUFFbEJDLFlBQVloRSxNQUFNLEdBQUdmLE9BQU9DLEtBQUssRUFBRXBCLGVBQy9CLE1BQU1tQixPQUFPQyxLQUFLLENBQUNwQixZQUFZLEtBQy9CQSx5REFBWUEsQ0FBQ21DO0lBQ2pCK0QsWUFBWTlDLEVBQUUsR0FBR3JELHlEQUFZQSxDQUFDa0c7SUFFOUIsSUFBSTlFLE9BQU9DLEtBQUssRUFBRTRFLFdBQVc7UUFDM0JFLGNBQWUsTUFBTS9FLE9BQU9DLEtBQUssQ0FBQzRFLFNBQVMsQ0FBQ0U7SUFDOUMsT0FBTztRQUNMQSxZQUFZQyxHQUFHLEdBQUdsRyx5REFBWUEsQ0FBQ2lHLGFBQWFyRSxTQUFTTTtJQUN2RDtJQUVBLElBQUkvQiwwREFBYUEsQ0FBQzhGLGdCQUFnQjVGLDREQUFlQSxDQUFDNEYsY0FBYztRQUM5REEsV0FBVyxDQUFDN0YsdURBQWNBLENBQUMsR0FBRztJQUNoQztJQUVBLE9BQU82RjtBQUNUO0FBRUEsTUFBTUUsY0FBYyxJQUNsQnBCLEtBQUtDLEtBQUssQ0FBQ04sS0FBS0QsR0FBRyxLQUFLMUQsbUVBQXNCQTtBQUV6QyxNQUFNcUYscUJBQXFCLE9BQ2hDQyxVQUVBTixVQUFVO1FBQ1IzQyxTQUFTa0QsS0FBS0MsU0FBUyxDQUFDRjtRQUN4QmhDLFlBQVk4QjtRQUNaSyxNQUFNOUYsOEVBQWFBO1FBQ25Cb0MsTUFBTSxFQUFFO0lBQ1YsR0FBWTtBQUVQLE1BQU0yRCxxQkFBcUIsT0FDaENwRCxTQUNBTSxxQkFFQW9DLFVBQVU7UUFDUjNDLFNBQVMsTUFBTUcsZUFBZUYsU0FBU007UUFDdkNVLFlBQVk4QjtRQUNaSyxNQUFNaEcsd0VBQU9BO1FBQ2JzQyxNQUFNO1lBQUM7Z0JBQUM7Z0JBQUthO2FBQW1CO1NBQUM7SUFDbkMsR0FBWTtBQUVkLE1BQU0rQywwQkFBMEIsSUFBSXJGLElBQUk7SUFBQztJQUFRO0lBQVM7Q0FBTztBQUUxRCxNQUFNc0YsZ0JBQWdCLENBQzNCcEUsV0FDQVIsTUFDQXNDO0lBRUEsTUFBTSxFQUNKdUMsS0FBSyxFQUNMQyxNQUFNLEVBQ05DLFlBQVksRUFDWkMsSUFBSSxFQUNKQyxLQUFLLEVBQ0xDLElBQUksRUFDSkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUixHQUFHckYsUUFBUSxDQUFDO0lBQ2IsTUFBTSxDQUFDc0YsV0FBVyxFQUFFLENBQUMsR0FBR0gsU0FBU0ksTUFBTSxRQUFRLEVBQUU7SUFFakQsT0FBTztRQUNMVjtRQUNBQztRQUNBeEM7UUFDQXRDO1FBQ0FpRjtRQUNBRSxTQUFTUix3QkFBd0JhLEdBQUcsQ0FBQ0YsWUFBWUgsVUFBVU07UUFDM0RDLFVBQ0VYLGdCQUNBQyxRQUNBSSxZQUNBLENBQ0VGLFFBQ0MxRSxDQUFBQSxVQUFVVCxVQUFVLENBQUMsVUFBVVMsWUFBWXJDLDhDQUFLQSxDQUFDMEYsVUFBVSxDQUFDckQsVUFBUyxDQUFDLEVBQ3ZFWixLQUFLLENBQUMsR0FBRztRQUNieUY7SUFDRjtBQUNGLEVBQUU7QUFFSyxNQUFNTSwrQkFBK0IsQ0FBQzdGO0lBQzNDLE1BQU04RixXQUFXOUYsSUFBSUMsVUFBVSxDQUFDO0lBQ2hDLE1BQU04RixPQUFPL0YsSUFBSUMsVUFBVSxDQUFDO0lBRTVCLElBQUk2RixZQUFZQyxRQUFRL0YsSUFBSUMsVUFBVSxDQUFDLFNBQVM7UUFDOUMsSUFBSTtZQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUc3Qiw4Q0FBS0EsQ0FBQzhCLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDO1lBQ3ZDLE1BQU1nRyxNQUFNRixXQUNQNUYsTUFBeUJFLFNBQ3pCRjtZQUVMLE9BQU82RixPQUFPN0gseURBQVlBLENBQUM4SCxPQUFPQTtRQUNwQyxFQUFFLE9BQU07WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUk7UUFDRixPQUFPakcsU0FBUzFCLDhDQUFLQSxDQUFDMEYsVUFBVSxDQUFDL0Q7SUFDbkMsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUVGLE1BQU1pRyx5QkFBMEQsQ0FBQztBQUVqRSxNQUFNQyxpQkFBaUIsSUFBSTFHLElBQUk7SUFBQztJQUFLO0NBQUk7QUFFbEMsTUFBTTJHLGlCQUFpQixPQUM1QkMsY0FDQWhHO0lBRUEsSUFBSSxDQUFDZ0csZ0JBQWdCLENBQUNoRyxRQUFRLE9BQU87SUFFckMsSUFBSTtRQUNGLE1BQU0sQ0FBQ3dGLFVBQVVTLE9BQU8sR0FBR0QsYUFBYVgsS0FBSyxDQUFDO1FBRTlDLElBQUlRLHNCQUFzQixDQUFDN0YsT0FBTyxLQUFLaUcsUUFBUSxPQUFPQTtRQUN0RCxJQUNFLE9BQU9KLHNCQUFzQixDQUFDN0YsT0FBTyxLQUFLLFlBQzFDLENBQUM4RixlQUFlUixHQUFHLENBQUNPLHNCQUFzQixDQUFDN0YsT0FBTyxHQUNsRDtZQUNBLE9BQU87UUFDVDtRQUVBLE1BQU1rRyxZQUFZLE1BQU1DLE1BQ3RCLENBQUMsUUFBUSxFQUFFRixTQUFTNUgsK0VBQWNBLENBQUMsTUFBTSxFQUFFbUgsVUFBVTtRQUd2RCxJQUFJVSxVQUFVRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxFQUFFQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBUUgsVUFBVUksSUFBSSxNQUF1QixDQUFDO1lBQ3JFLElBQUlDLFdBQVc7WUFFZixJQUFJZixhQUFhLEtBQUs7Z0JBQ3BCLE1BQU0sQ0FBQ2dCLFNBQVMsR0FBR0MsVUFBVSxHQUFHcEgsT0FBT3FILE1BQU0sQ0FBQ0w7Z0JBQzlDLE1BQU1NLFdBQVdGLFVBQVVHLE1BQU0sS0FBSyxJQUFJSixVQUFVSCxLQUFLLENBQUNiLFNBQVM7Z0JBRW5FZSxXQUFXSSxhQUFhM0c7WUFDMUIsT0FBTyxJQUFJcUcsS0FBSyxDQUFDYixTQUFTLEVBQUU7Z0JBQzFCZSxXQUFXRixLQUFLLENBQUNiLFNBQVMsS0FBS3hGO1lBQ2pDO1lBRUEsSUFBSXVHLFVBQVU7Z0JBQ1pWLHNCQUFzQixDQUFDN0YsT0FBTyxHQUFHaUc7WUFDbkM7WUFFQSxPQUFPTSxXQUFXTixTQUFTO1FBQzdCO1FBQ0FKLHNCQUFzQixDQUFDN0YsT0FBTyxHQUFHa0csVUFBVVcsTUFBTTtJQUNuRCxFQUFFLE9BQU07UUFDTmhCLHNCQUFzQixDQUFDN0YsT0FBTyxHQUFHO0lBQ25DO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFSyxNQUFNOEcseUJBQXlCLENBQUNEO0lBQ3JDLE9BQVFBO1FBQ04sS0FBS0UsVUFBVUMsU0FBUyxDQUFDQyxVQUFVO1lBQ2pDLE9BQU87UUFDVCxLQUFLRixVQUFVQyxTQUFTLENBQUNFLElBQUk7WUFDM0IsT0FBTztRQUNULEtBQUtILFVBQVVDLFNBQVMsQ0FBQ0csT0FBTztZQUM5QixPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRixFQUFFO0FBRUssTUFBTUMsMEJBQTBCLENBQUNqRyxVQUN0Q0EsUUFBUWtHLE9BQU8sQ0FDYiwrQ0FDQSxDQUFDQyxRQUFVLENBQUMsMENBQTBDLEVBQUVBLE1BQU0sSUFBSSxDQUFDLEVBQ25FO0FBRUcsTUFBTUMsMEJBQTBCLENBQUNwRyxVQUN0Q0EsUUFBUWtHLE9BQU8sQ0FBQyxPQUFPLFVBQVU7QUFFNUIsTUFBTUcsc0JBQXNCLENBQUNqRjtJQUNsQyxNQUFNa0YsT0FBTyxJQUFJaEYsS0FBS0YsWUFBWXpELG1FQUFzQkE7SUFDeEQsTUFBTTBELE1BQU0sSUFBSUM7SUFDaEIsTUFBTWlGLFFBQVEsSUFBSWpGLEtBQ2hCRCxJQUFJbUYsV0FBVyxJQUNmbkYsSUFBSW9GLFFBQVEsSUFDWnBGLElBQUlxRixPQUFPLElBQ1hsRixPQUFPO0lBQ1QsTUFBTW1GLFlBQVksSUFBSXJGLEtBQ3BCRCxJQUFJbUYsV0FBVyxJQUNmbkYsSUFBSW9GLFFBQVEsSUFDWnBGLElBQUlxRixPQUFPLEtBQUssR0FDaEJsRixPQUFPO0lBQ1QsTUFBTW9GLGdCQUFnQk4sS0FBSzlFLE9BQU87SUFDbEMsTUFBTXFGLGFBQWFQLEtBQUtRLGNBQWMsQ0FBQyxTQUFTckosNEVBQVdBO0lBRTNELElBQUltSixnQkFBZ0JMLE9BQU8sT0FBT007SUFDbEMsSUFBSUQsZ0JBQWdCRCxXQUFXLE9BQU8sQ0FBQyxhQUFhLEVBQUVFLFlBQVk7SUFDbEUsSUFBSUQsZ0JBQWdCTCxRQUFRLElBQUk3SSxnRUFBbUJBLEVBQUU7UUFDbkQsT0FBTzRJLEtBQUtRLGNBQWMsQ0FBQyxTQUFTO1lBQ2xDLEdBQUdySiw0RUFBVztZQUNkc0osU0FBUztRQUNYO0lBQ0Y7SUFFQSxPQUFPVCxLQUFLUSxjQUFjLENBQUMsU0FBUztRQUNsQyxHQUFHckosNEVBQVc7UUFDZHVKLEtBQUs7UUFDTEMsT0FBTztRQUNQQyxNQUFNO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTUMsa0JBQWtCLENBQUNDO0lBQzlCLElBQUlBLE9BQU8zQixNQUFNLEtBQUssR0FBRyxPQUFPLEVBQUU7SUFFbEMsTUFBTTRCLGVBQWV6Six5REFBUUEsQ0FBQ3dKLFFBQVF0RztJQUN0QyxNQUFNLENBQUN3RyxhQUFhLEdBQUdDLGdCQUFnQixHQUFHRjtJQUMxQyxNQUFNRyxnQkFBNEI7UUFDaEM7WUFBQ25CLG9CQUFvQmlCLFlBQVlyRyxVQUFVO1lBQUc7Z0JBQUNxRzthQUFZO1NBQUM7S0FDN0Q7SUFFREMsZ0JBQWdCRSxPQUFPLENBQUMsQ0FBQzdFO1FBQ3ZCLE1BQU0sRUFBRTNCLFVBQVUsRUFBRSxHQUFHMkI7UUFDdkIsTUFBTSxHQUFHOEUsa0JBQWtCLEdBQUdGLGFBQWEsQ0FBQ0EsY0FBYy9CLE1BQU0sR0FBRyxFQUFFO1FBQ3JFLE1BQU0sRUFBRXhFLFlBQVkwRyxlQUFlLEVBQUUsR0FDbkNELGlCQUFpQixDQUFDQSxrQkFBa0JqQyxNQUFNLEdBQUcsRUFBRTtRQUVqRCxJQUFJOUQsS0FBS2lHLEdBQUcsQ0FBQzNHLGFBQWEwRyxtQkFBbUJ0SywwRkFBeUJBLEVBQUU7WUFDdEVxSyxrQkFBa0JHLElBQUksQ0FBQ2pGO1FBQ3pCLE9BQU87WUFDTDRFLGNBQWNLLElBQUksQ0FBQztnQkFBQ3hCLG9CQUFvQnBGO2dCQUFhO29CQUFDMkI7aUJBQU07YUFBQztRQUMvRDtJQUNGO0lBRUEsT0FBTzRFO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXGZ1bmN0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L2NvbnNpc3RlbnQtdHlwZS1zcGVjaWZpZXItc3R5bGVcclxuaW1wb3J0IHR5cGUgeyBQcm9maWxlUG9pbnRlciB9IGZyb20gXCJub3N0ci10b29scy9saWIvdHlwZXMvbmlwMTlcIjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9jb25zaXN0ZW50LXR5cGUtc3BlY2lmaWVyLXN0eWxlXHJcbmltcG9ydCB0eXBlIHsgTklQMDVSZXN1bHQgfSBmcm9tIFwibm9zdHItdG9vbHMvbGliL3R5cGVzL25pcDA1XCI7XHJcbmltcG9ydCB7XHJcbiAgZ2VuZXJhdGVQcml2YXRlS2V5LFxyXG4gIGdldEV2ZW50SGFzaCxcclxuICBnZXRQdWJsaWNLZXksXHJcbiAgZ2V0U2lnbmF0dXJlLFxyXG4gIG5pcDA0LFxyXG4gIG5pcDE5LFxyXG4gIHZhbGlkYXRlRXZlbnQsXHJcbiAgdmVyaWZpZWRTeW1ib2wsXHJcbiAgdmVyaWZ5U2lnbmF0dXJlLFxyXG4gIHR5cGUgRXZlbnQsXHJcbiAgdHlwZSBWZXJpZmllZEV2ZW50LFxyXG59IGZyb20gXCJub3N0ci10b29sc1wiO1xyXG5pbXBvcnQge1xyXG4gIEJBU0VfTklQMDVfVVJMLFxyXG4gIEJBU0VfUldfUkVMQVlTLFxyXG4gIERNX0tJTkQsXHJcbiAgR1JPVVBfVElNRV9HQVBfSU5fU0VDT05EUyxcclxuICBNRVRBREFUQV9LSU5ELFxyXG4gIFBSSVZBVEVfS0VZX0lEQl9OQU1FLFxyXG4gIFBVQkxJQ19LRVlfSURCX05BTUUsXHJcbiAgVElNRV9GT1JNQVQsXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7XHJcbiAgdHlwZSBDaGF0RXZlbnRzLFxyXG4gIHR5cGUgRGVjcnlwdGVkQ29udGVudCxcclxuICB0eXBlIE5vc3RyRXZlbnRzLFxyXG4gIHR5cGUgTm9zdHJQcm9maWxlLFxyXG4gIHR5cGUgUHJvZmlsZURhdGEsXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvdHlwZXNcIjtcclxuaW1wb3J0IHsgdHlwZSBNZW51SXRlbSB9IGZyb20gXCJjb250ZXh0cy9tZW51L3VzZU1lbnVDb250ZXh0U3RhdGVcIjtcclxuaW1wb3J0IHsgTUlMTElTRUNPTkRTX0lOX0RBWSwgTUlMTElTRUNPTkRTX0lOX1NFQ09ORCB9IGZyb20gXCJ1dGlscy9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgdG9Tb3J0ZWQgfSBmcm9tIFwidXRpbHMvZnVuY3Rpb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UmVsYXlVcmxzID0gYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcclxuICBpZiAod2luZG93Lm5vc3RyPy5nZXRSZWxheXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgLi4ubmV3IFNldChbXHJcbiAgICAgICAgICAuLi5CQVNFX1JXX1JFTEFZUyxcclxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGF3YWl0IHdpbmRvdy5ub3N0ci5nZXRSZWxheXMoKSkubWFwKChbdXJsXSkgPT5cclxuICAgICAgICAgICAgdXJsLmVuZHNXaXRoKFwiL1wiKSA/IHVybC5zbGljZSgwLCAtMSkgOiB1cmxcclxuICAgICAgICAgICksXHJcbiAgICAgICAgXSksXHJcbiAgICAgIF07XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gSWdub3JlIGZhaWx1cmUgdG8gZ2V0IHJlbGF5c1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJBU0VfUldfUkVMQVlTO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRvSGV4S2V5ID0gKGtleTogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICBpZiAoXHJcbiAgICBrZXkuc3RhcnRzV2l0aChcIm5wcm9maWxlXCIpIHx8XHJcbiAgICBrZXkuc3RhcnRzV2l0aChcIm5wdWJcIikgfHxcclxuICAgIGtleS5zdGFydHNXaXRoKFwibnNlY1wiKVxyXG4gICkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhIH0gPSBuaXAxOS5kZWNvZGUoa2V5KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICB0eXBlb2YgKGRhdGEgYXMgUHJvZmlsZVBvaW50ZXIpLnB1YmtleSA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gKGRhdGEgYXMgUHJvZmlsZVBvaW50ZXIpLnB1YmtleTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ga2V5O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFByaXZhdGVLZXkgPSAoKTogc3RyaW5nID0+XHJcbiAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oUFJJVkFURV9LRVlfSURCX05BTUUpIHx8IFwiXCI7XHJcblxyXG5leHBvcnQgY29uc3QgbWF5YmVHZXRFeGlzdGluZ1B1YmxpY0tleSA9IGFzeW5jICgpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IGlkYktleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBVQkxJQ19LRVlfSURCX05BTUUpIHx8IFwiXCI7XHJcbiAgbGV0IHB1YmxpY0tleSA9IFwiXCI7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBwdWJsaWNLZXkgPSAoYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRQdWJsaWNLZXkoKSkgfHwgXCJcIjtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIElnbm9yZSBmYWlsdXJlIHRvIGdldCBwdWJsaWMga2V5XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHVibGljS2V5IHx8IGlkYktleSB8fCBcIlwiO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFB1YmxpY0hleEtleSA9IChleGlzdGluZ1B1YmxpY0tleT86IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgaWYgKGV4aXN0aW5nUHVibGljS2V5KSByZXR1cm4gdG9IZXhLZXkoZXhpc3RpbmdQdWJsaWNLZXkpO1xyXG5cclxuICBjb25zdCBuZXdQcml2YXRlS2V5ID0gZ2VuZXJhdGVQcml2YXRlS2V5KCk7XHJcbiAgY29uc3QgbmV3UHVibGljS2V5ID0gZ2V0UHVibGljS2V5KG5ld1ByaXZhdGVLZXkpO1xyXG5cclxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShQVUJMSUNfS0VZX0lEQl9OQU1FLCBuZXdQdWJsaWNLZXkpO1xyXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBSSVZBVEVfS0VZX0lEQl9OQU1FLCBuZXdQcml2YXRlS2V5KTtcclxuXHJcbiAgcmV0dXJuIHRvSGV4S2V5KG5ld1B1YmxpY0tleSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0S2V5RnJvbVRhZ3MgPSAodGFnczogc3RyaW5nW11bXSA9IFtdKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBbLCBrZXkgPSBcIlwiXSA9IHRhZ3MuZmluZCgoW3RhZ10pID0+IHRhZyA9PT0gXCJwXCIpIHx8IFtdO1xyXG5cclxuICByZXR1cm4ga2V5O1xyXG59O1xyXG5cclxuY29uc3QgZGVjcnlwdGVkQ29udGVudDogRGVjcnlwdGVkQ29udGVudCA9IHt9O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlY3J5cHRNZXNzYWdlID0gYXN5bmMgKFxyXG4gIGlkOiBzdHJpbmcsXHJcbiAgY29udGVudDogc3RyaW5nLFxyXG4gIHB1YmtleTogc3RyaW5nXHJcbik6IFByb21pc2U8c3RyaW5nIHwgZmFsc2U+ID0+IHtcclxuICBpZiAoZGVjcnlwdGVkQ29udGVudFtpZF0gfHwgZGVjcnlwdGVkQ29udGVudFtpZF0gPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZGVjcnlwdGVkQ29udGVudFtpZF07XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0ZWRDb250ZW50W2lkXSA9IGNvbnRlbnQ7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgKHdpbmRvdy5ub3N0cj8ubmlwMDRcclxuICAgICAgPyB3aW5kb3cubm9zdHIubmlwMDQuZGVjcnlwdChwdWJrZXksIGNvbnRlbnQpXHJcbiAgICAgIDogbmlwMDQuZGVjcnlwdCh0b0hleEtleShnZXRQcml2YXRlS2V5KCkpLCBwdWJrZXksIGNvbnRlbnQpKTtcclxuXHJcbiAgICBkZWNyeXB0ZWRDb250ZW50W2lkXSA9IG1lc3NhZ2U7XHJcblxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICBkZWNyeXB0ZWRDb250ZW50W2lkXSA9IFwiXCI7XHJcblxyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZW5jcnlwdE1lc3NhZ2UgPSBhc3luYyAoXHJcbiAgY29udGVudDogc3RyaW5nLFxyXG4gIHB1YmtleTogc3RyaW5nXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBhd2FpdCAod2luZG93Lm5vc3RyPy5uaXAwNFxyXG4gICAgICA/IHdpbmRvdy5ub3N0ci5uaXAwNC5lbmNyeXB0KHB1YmtleSwgY29udGVudClcclxuICAgICAgOiBuaXAwNC5lbmNyeXB0KHRvSGV4S2V5KGdldFByaXZhdGVLZXkoKSksIHB1YmtleSwgY29udGVudCkpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgLy8gSWdub3JlIGZhaWx1cmUgdG8gZGVjcnlwdFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiXCI7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TWVzc2FnZXMgPSAoXHJcbiAgYXV0aG9yUHVibGljS2V5OiBzdHJpbmcsXHJcbiAgcmVjaXBpZW50UHVibGljS2V5Pzogc3RyaW5nLFxyXG4gIHNpbmNlID0gMFxyXG4pOiBOb3N0ckV2ZW50cyA9PiAoe1xyXG4gIGVuYWJsZWQ6IEJvb2xlYW4oYXV0aG9yUHVibGljS2V5KSB8fCBCb29sZWFuKHJlY2lwaWVudFB1YmxpY0tleSksXHJcbiAgZmlsdGVyOiBbXHJcbiAgICB7XHJcbiAgICAgIC4uLihyZWNpcGllbnRQdWJsaWNLZXkgPyB7IFwiI3BcIjogW3JlY2lwaWVudFB1YmxpY0tleV0gfSA6IHt9KSxcclxuICAgICAgYXV0aG9yczogW2F1dGhvclB1YmxpY0tleV0sXHJcbiAgICAgIGtpbmRzOiBbRE1fS0lORF0sXHJcbiAgICAgIHNpbmNlLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgLi4uKHJlY2lwaWVudFB1YmxpY0tleSA/IHsgYXV0aG9yczogW3JlY2lwaWVudFB1YmxpY0tleV0gfSA6IHt9KSxcclxuICAgICAgXCIjcFwiOiBbYXV0aG9yUHVibGljS2V5XSxcclxuICAgICAga2luZHM6IFtETV9LSU5EXSxcclxuICAgICAgc2luY2UsXHJcbiAgICB9LFxyXG4gIF0sXHJcbn0pO1xyXG5cclxuY29uc3QgYXNjQ3JlYXRlZEF0ID0gKGE6IEV2ZW50LCBiOiBFdmVudCk6IG51bWJlciA9PlxyXG4gIGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdDtcclxuXHJcbmV4cG9ydCBjb25zdCBkZXNjQ3JlYXRlZEF0ID0gKGE6IEV2ZW50LCBiOiBFdmVudCk6IG51bWJlciA9PlxyXG4gIGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdDtcclxuXHJcbmV4cG9ydCBjb25zdCBzaG9ydFRpbWVTdGFtcCA9ICh0aW1lc3RhbXA6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCB0aW1lID0gbmV3IERhdGUodGltZXN0YW1wICogTUlMTElTRUNPTkRTX0lOX1NFQ09ORCkuZ2V0VGltZSgpO1xyXG4gIGNvbnN0IGRpZmYgPSBub3cgLSB0aW1lO1xyXG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fU0VDT05EKTtcclxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xyXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xyXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGhvdXJzIC8gMjQpO1xyXG4gIGNvbnN0IHdlZWtzID0gTWF0aC5mbG9vcihkYXlzIC8gNyk7XHJcblxyXG4gIGlmICh3ZWVrcyA+IDApIHJldHVybiBgJHt3ZWVrc313YDtcclxuICBpZiAoZGF5cyA+IDApIHJldHVybiBgJHtkYXlzfWRgO1xyXG4gIGlmIChob3VycyA+IDApIHJldHVybiBgJHtob3Vyc31oYDtcclxuICBpZiAobWludXRlcyA+IDApIHJldHVybiBgJHttaW51dGVzfW1gO1xyXG4gIGlmIChzZWNvbmRzIDwgMTApIHJldHVybiBcIm5vd1wiO1xyXG5cclxuICByZXR1cm4gYCR7c2Vjb25kc31zYDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3B5S2V5TWVudUl0ZW1zID0gKFxyXG4gIGhleEtleTogc3RyaW5nLFxyXG4gIG5zZWNIZXg/OiBzdHJpbmdcclxuKTogTWVudUl0ZW1bXSA9PiBbXHJcbiAge1xyXG4gICAgYWN0aW9uOiAoKSA9PiBuYXZpZ2F0b3IuY2xpcGJvYXJkPy53cml0ZVRleHQobmlwMTkubnB1YkVuY29kZShoZXhLZXkpKSxcclxuICAgIGxhYmVsOiBcIkNvcHkgbnB1YiBhZGRyZXNzXCIsXHJcbiAgfSxcclxuICAuLi4obnNlY0hleFxyXG4gICAgPyBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYWN0aW9uOiAoKSA9PlxyXG4gICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkPy53cml0ZVRleHQobmlwMTkubnNlY0VuY29kZShuc2VjSGV4KSksXHJcbiAgICAgICAgICBsYWJlbDogXCJDb3B5IG5zZWMgYWRkcmVzc1wiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF1cclxuICAgIDogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGFjdGlvbjogKCkgPT4gbmF2aWdhdG9yLmNsaXBib2FyZD8ud3JpdGVUZXh0KGhleEtleSksXHJcbiAgICAgICAgICBsYWJlbDogXCJDb3B5IGhleCBhZGRyZXNzXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSksXHJcbl07XHJcblxyXG5jb25zdCBzaWduRXZlbnQgPSBhc3luYyAoZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTxFdmVudD4gPT4ge1xyXG4gIGxldCBzaWduZWRFdmVudCA9IGV2ZW50IGFzIFZlcmlmaWVkRXZlbnQ7XHJcblxyXG4gIHNpZ25lZEV2ZW50LnB1YmtleSA9IHdpbmRvdy5ub3N0cj8uZ2V0UHVibGljS2V5XHJcbiAgICA/IGF3YWl0IHdpbmRvdy5ub3N0ci5nZXRQdWJsaWNLZXkoKVxyXG4gICAgOiBnZXRQdWJsaWNLZXkoZ2V0UHJpdmF0ZUtleSgpKTtcclxuICBzaWduZWRFdmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XHJcblxyXG4gIGlmICh3aW5kb3cubm9zdHI/LnNpZ25FdmVudCkge1xyXG4gICAgc2lnbmVkRXZlbnQgPSAoYXdhaXQgd2luZG93Lm5vc3RyLnNpZ25FdmVudChzaWduZWRFdmVudCkpIGFzIFZlcmlmaWVkRXZlbnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNpZ25lZEV2ZW50LnNpZyA9IGdldFNpZ25hdHVyZShzaWduZWRFdmVudCwgdG9IZXhLZXkoZ2V0UHJpdmF0ZUtleSgpKSk7XHJcbiAgfVxyXG5cclxuICBpZiAodmFsaWRhdGVFdmVudChzaWduZWRFdmVudCkgJiYgdmVyaWZ5U2lnbmF0dXJlKHNpZ25lZEV2ZW50KSkge1xyXG4gICAgc2lnbmVkRXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzaWduZWRFdmVudDtcclxufTtcclxuXHJcbmNvbnN0IGdldFVuaXhUaW1lID0gKCk6IG51bWJlciA9PlxyXG4gIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIE1JTExJU0VDT05EU19JTl9TRUNPTkQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVByb2ZpbGVFdmVudCA9IGFzeW5jIChcclxuICBwcm9maWxlOiBQcm9maWxlRGF0YVxyXG4pOiBQcm9taXNlPEV2ZW50PiA9PlxyXG4gIHNpZ25FdmVudCh7XHJcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShwcm9maWxlKSxcclxuICAgIGNyZWF0ZWRfYXQ6IGdldFVuaXhUaW1lKCksXHJcbiAgICBraW5kOiBNRVRBREFUQV9LSU5ELFxyXG4gICAgdGFnczogW10gYXMgc3RyaW5nW11bXSxcclxuICB9IGFzIEV2ZW50KTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVNZXNzYWdlRXZlbnQgPSBhc3luYyAoXHJcbiAgbWVzc2FnZTogc3RyaW5nLFxyXG4gIHJlY2lwaWVudFB1YmxpY0tleTogc3RyaW5nXHJcbik6IFByb21pc2U8RXZlbnQ+ID0+XHJcbiAgc2lnbkV2ZW50KHtcclxuICAgIGNvbnRlbnQ6IGF3YWl0IGVuY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHJlY2lwaWVudFB1YmxpY0tleSksXHJcbiAgICBjcmVhdGVkX2F0OiBnZXRVbml4VGltZSgpLFxyXG4gICAga2luZDogRE1fS0lORCxcclxuICAgIHRhZ3M6IFtbXCJwXCIsIHJlY2lwaWVudFB1YmxpY0tleV1dLFxyXG4gIH0gYXMgRXZlbnQpO1xyXG5cclxuY29uc3QgVkFMSURfUElDVFVSRV9QUk9UT0NPTFMgPSBuZXcgU2V0KFtcImh0dHBcIiwgXCJodHRwc1wiLCBcImRhdGFcIl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRhdGFUb1Byb2ZpbGUgPSAoXHJcbiAgcHVibGljS2V5OiBzdHJpbmcsXHJcbiAgZGF0YT86IFByb2ZpbGVEYXRhLFxyXG4gIGNyZWF0ZWRfYXQ/OiBudW1iZXJcclxuKTogTm9zdHJQcm9maWxlID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBhYm91dCxcclxuICAgIGJhbm5lcixcclxuICAgIGRpc3BsYXlfbmFtZSxcclxuICAgIG5hbWUsXHJcbiAgICBuaXAwNSxcclxuICAgIG5wdWIsXHJcbiAgICBwaWN0dXJlLFxyXG4gICAgdXNlcm5hbWUsXHJcbiAgICB3ZWJzaXRlLFxyXG4gIH0gPSBkYXRhIHx8IHt9O1xyXG4gIGNvbnN0IFtwcm90b2NvbCA9IFwiXCJdID0gcGljdHVyZT8uc3BsaXQoXCI6XCIpIHx8IFtdO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYWJvdXQsXHJcbiAgICBiYW5uZXIsXHJcbiAgICBjcmVhdGVkX2F0LFxyXG4gICAgZGF0YSxcclxuICAgIG5pcDA1LFxyXG4gICAgcGljdHVyZTogVkFMSURfUElDVFVSRV9QUk9UT0NPTFMuaGFzKHByb3RvY29sKSA/IHBpY3R1cmUgOiB1bmRlZmluZWQsXHJcbiAgICB1c2VyTmFtZTpcclxuICAgICAgZGlzcGxheV9uYW1lIHx8XHJcbiAgICAgIG5hbWUgfHxcclxuICAgICAgdXNlcm5hbWUgfHxcclxuICAgICAgKFxyXG4gICAgICAgIG5wdWIgfHxcclxuICAgICAgICAocHVibGljS2V5LnN0YXJ0c1dpdGgoXCJucHViXCIpID8gcHVibGljS2V5IDogbmlwMTkubnB1YkVuY29kZShwdWJsaWNLZXkpKVxyXG4gICAgICApLnNsaWNlKDAsIDEyKSxcclxuICAgIHdlYnNpdGUsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRQdWJsaWNIZXhGcm9tTm9zdHJBZGRyZXNzID0gKGtleTogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBucHJvZmlsZSA9IGtleS5zdGFydHNXaXRoKFwibnByb2ZpbGVcIik7XHJcbiAgY29uc3QgbnNlYyA9IGtleS5zdGFydHNXaXRoKFwibnNlY1wiKTtcclxuXHJcbiAgaWYgKG5wcm9maWxlIHx8IG5zZWMgfHwga2V5LnN0YXJ0c1dpdGgoXCJucHViXCIpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEgfSA9IG5pcDE5LmRlY29kZShrZXkpIHx8IHt9O1xyXG4gICAgICBjb25zdCBoZXggPSBucHJvZmlsZVxyXG4gICAgICAgID8gKGRhdGEgYXMgUHJvZmlsZVBvaW50ZXIpPy5wdWJrZXlcclxuICAgICAgICA6IChkYXRhIGFzIHN0cmluZyk7XHJcblxyXG4gICAgICByZXR1cm4gbnNlYyA/IGdldFB1YmxpY0tleShoZXgpIDogaGV4O1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiB0b0hleEtleShuaXAxOS5ucHViRW5jb2RlKGtleSkpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgdmVyaWZpZWROaXAwNUFkZHJlc3NlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPiA9IHt9O1xyXG5cclxuY29uc3QgVElNRU9VVF9FUlJPUlMgPSBuZXcgU2V0KFs0MDgsIDUwNF0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5pcDA1RG9tYWluID0gYXN5bmMgKFxyXG4gIG5pcDA1YWRkcmVzcz86IHN0cmluZyxcclxuICBwdWJrZXk/OiBzdHJpbmdcclxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICBpZiAoIW5pcDA1YWRkcmVzcyB8fCAhcHVia2V5KSByZXR1cm4gXCJcIjtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IFt1c2VyTmFtZSwgZG9tYWluXSA9IG5pcDA1YWRkcmVzcy5zcGxpdChcIkBcIik7XHJcblxyXG4gICAgaWYgKHZlcmlmaWVkTmlwMDVBZGRyZXNzZXNbcHVia2V5XSA9PT0gZG9tYWluKSByZXR1cm4gZG9tYWluO1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgdmVyaWZpZWROaXAwNUFkZHJlc3Nlc1twdWJrZXldID09PSBcIm51bWJlclwiICYmXHJcbiAgICAgICFUSU1FT1VUX0VSUk9SUy5oYXModmVyaWZpZWROaXAwNUFkZHJlc3Nlc1twdWJrZXldKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vc3RySnNvbiA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBgaHR0cHM6Ly8ke2RvbWFpbn0ke0JBU0VfTklQMDVfVVJMfT9uYW1lPSR7dXNlck5hbWV9YFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAobm9zdHJKc29uLm9rKSB7XHJcbiAgICAgIGNvbnN0IHsgbmFtZXMgPSB7fSB9ID0gKChhd2FpdCBub3N0ckpzb24uanNvbigpKSBhcyBOSVAwNVJlc3VsdCkgfHwge307XHJcbiAgICAgIGxldCB2ZXJpZmllZCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKHVzZXJOYW1lID09PSBcIl9cIikge1xyXG4gICAgICAgIGNvbnN0IFt1c2VyS2V5LCAuLi5vdGhlcktleXNdID0gT2JqZWN0LnZhbHVlcyhuYW1lcyk7XHJcbiAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBvdGhlcktleXMubGVuZ3RoID09PSAwID8gdXNlcktleSA6IG5hbWVzW3VzZXJOYW1lXTtcclxuXHJcbiAgICAgICAgdmVyaWZpZWQgPSBrZXlWYWx1ZSA9PT0gcHVia2V5O1xyXG4gICAgICB9IGVsc2UgaWYgKG5hbWVzW3VzZXJOYW1lXSkge1xyXG4gICAgICAgIHZlcmlmaWVkID0gbmFtZXNbdXNlck5hbWVdID09PSBwdWJrZXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2ZXJpZmllZCkge1xyXG4gICAgICAgIHZlcmlmaWVkTmlwMDVBZGRyZXNzZXNbcHVia2V5XSA9IGRvbWFpbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZlcmlmaWVkID8gZG9tYWluIDogXCJcIjtcclxuICAgIH1cclxuICAgIHZlcmlmaWVkTmlwMDVBZGRyZXNzZXNbcHVia2V5XSA9IG5vc3RySnNvbi5zdGF0dXM7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICB2ZXJpZmllZE5pcDA1QWRkcmVzc2VzW3B1YmtleV0gPSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiXCI7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0V2ViU29ja2V0U3RhdHVzSWNvbiA9IChzdGF0dXM/OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICBjYXNlIFdlYlNvY2tldC5wcm90b3R5cGUuQ09OTkVDVElORzpcclxuICAgICAgcmV0dXJuIFwi8J+foVwiO1xyXG4gICAgY2FzZSBXZWJTb2NrZXQucHJvdG90eXBlLk9QRU46XHJcbiAgICAgIHJldHVybiBcIvCfn6JcIjtcclxuICAgIGNhc2UgV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TSU5HOlxyXG4gICAgICByZXR1cm4gXCLwn5+gXCI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gXCLwn5S0XCI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRJbWFnZUxpbmtzVG9IdG1sID0gKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyA9PlxyXG4gIGNvbnRlbnQucmVwbGFjZShcclxuICAgIC9odHRwcz86XFwvXFwvXFxTK1xcLig/OnBuZ3xqcGd8anBlZ3xnaWZ8d2VicCkvZ2ksXHJcbiAgICAobWF0Y2gpID0+IGA8aW1nIGRlY29kaW5nPVwiYXN5bmNcIiBsb2FkaW5nPVwibGF6eVwiIHNyYz1cIiR7bWF0Y2h9XCIgLz5gXHJcbiAgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0TmV3TGluZXNUb0JyZWFrcyA9IChjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcgPT5cclxuICBjb250ZW50LnJlcGxhY2UoL1xcbi9nLCBcIjxiciAvPlwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcmV0dHlDaGF0VGltZXN0YW1wID0gKHRpbWVzdGFtcDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wICogTUlMTElTRUNPTkRTX0lOX1NFQ09ORCk7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKFxyXG4gICAgbm93LmdldEZ1bGxZZWFyKCksXHJcbiAgICBub3cuZ2V0TW9udGgoKSxcclxuICAgIG5vdy5nZXREYXRlKClcclxuICApLmdldFRpbWUoKTtcclxuICBjb25zdCB5ZXN0ZXJkYXkgPSBuZXcgRGF0ZShcclxuICAgIG5vdy5nZXRGdWxsWWVhcigpLFxyXG4gICAgbm93LmdldE1vbnRoKCksXHJcbiAgICBub3cuZ2V0RGF0ZSgpIC0gMVxyXG4gICkuZ2V0VGltZSgpO1xyXG4gIGNvbnN0IGRhdGVUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcclxuICBjb25zdCBkYXRlUHJldHR5ID0gZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIFRJTUVfRk9STUFUKTtcclxuXHJcbiAgaWYgKGRhdGVUaW1lc3RhbXAgPiB0b2RheSkgcmV0dXJuIGRhdGVQcmV0dHk7XHJcbiAgaWYgKGRhdGVUaW1lc3RhbXAgPiB5ZXN0ZXJkYXkpIHJldHVybiBgWWVzdGVyZGF5IGF0ICR7ZGF0ZVByZXR0eX1gO1xyXG4gIGlmIChkYXRlVGltZXN0YW1wID4gdG9kYXkgLSA2ICogTUlMTElTRUNPTkRTX0lOX0RBWSkge1xyXG4gICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XHJcbiAgICAgIC4uLlRJTUVfRk9STUFULFxyXG4gICAgICB3ZWVrZGF5OiBcImxvbmdcIixcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XHJcbiAgICAuLi5USU1FX0ZPUk1BVCxcclxuICAgIGRheTogXCJudW1lcmljXCIsXHJcbiAgICBtb250aDogXCJzaG9ydFwiLFxyXG4gICAgeWVhcjogXCJudW1lcmljXCIsXHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JvdXBDaGF0RXZlbnRzID0gKGV2ZW50czogRXZlbnRbXSk6IENoYXRFdmVudHMgPT4ge1xyXG4gIGlmIChldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XHJcblxyXG4gIGNvbnN0IHNvcnRlZEV2ZW50cyA9IHRvU29ydGVkKGV2ZW50cywgYXNjQ3JlYXRlZEF0KTtcclxuICBjb25zdCBbb2xkZXN0RXZlbnQsIC4uLnJlbWFpbmluZ0V2ZW50c10gPSBzb3J0ZWRFdmVudHM7XHJcbiAgY29uc3QgZ3JvdXBlZEV2ZW50czogQ2hhdEV2ZW50cyA9IFtcclxuICAgIFtwcmV0dHlDaGF0VGltZXN0YW1wKG9sZGVzdEV2ZW50LmNyZWF0ZWRfYXQpLCBbb2xkZXN0RXZlbnRdXSxcclxuICBdO1xyXG5cclxuICByZW1haW5pbmdFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcclxuICAgIGNvbnN0IHsgY3JlYXRlZF9hdCB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCBbLCBsYXN0R3JvdXBlZEV2ZW50c10gPSBncm91cGVkRXZlbnRzW2dyb3VwZWRFdmVudHMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCB7IGNyZWF0ZWRfYXQ6IGxhc3RfY3JlYXRlZF9hdCB9ID1cclxuICAgICAgbGFzdEdyb3VwZWRFdmVudHNbbGFzdEdyb3VwZWRFdmVudHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGNyZWF0ZWRfYXQgLSBsYXN0X2NyZWF0ZWRfYXQpIDwgR1JPVVBfVElNRV9HQVBfSU5fU0VDT05EUykge1xyXG4gICAgICBsYXN0R3JvdXBlZEV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdyb3VwZWRFdmVudHMucHVzaChbcHJldHR5Q2hhdFRpbWVzdGFtcChjcmVhdGVkX2F0KSwgW2V2ZW50XV0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZ3JvdXBlZEV2ZW50cztcclxufTtcclxuIl0sIm5hbWVzIjpbImdlbmVyYXRlUHJpdmF0ZUtleSIsImdldEV2ZW50SGFzaCIsImdldFB1YmxpY0tleSIsImdldFNpZ25hdHVyZSIsIm5pcDA0IiwibmlwMTkiLCJ2YWxpZGF0ZUV2ZW50IiwidmVyaWZpZWRTeW1ib2wiLCJ2ZXJpZnlTaWduYXR1cmUiLCJCQVNFX05JUDA1X1VSTCIsIkJBU0VfUldfUkVMQVlTIiwiRE1fS0lORCIsIkdST1VQX1RJTUVfR0FQX0lOX1NFQ09ORFMiLCJNRVRBREFUQV9LSU5EIiwiUFJJVkFURV9LRVlfSURCX05BTUUiLCJQVUJMSUNfS0VZX0lEQl9OQU1FIiwiVElNRV9GT1JNQVQiLCJNSUxMSVNFQ09ORFNfSU5fREFZIiwiTUlMTElTRUNPTkRTX0lOX1NFQ09ORCIsInRvU29ydGVkIiwiZ2V0UmVsYXlVcmxzIiwid2luZG93Iiwibm9zdHIiLCJnZXRSZWxheXMiLCJTZXQiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwidXJsIiwiZW5kc1dpdGgiLCJzbGljZSIsInRvSGV4S2V5Iiwia2V5Iiwic3RhcnRzV2l0aCIsImRhdGEiLCJkZWNvZGUiLCJwdWJrZXkiLCJnZXRQcml2YXRlS2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm1heWJlR2V0RXhpc3RpbmdQdWJsaWNLZXkiLCJpZGJLZXkiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNIZXhLZXkiLCJleGlzdGluZ1B1YmxpY0tleSIsIm5ld1ByaXZhdGVLZXkiLCJuZXdQdWJsaWNLZXkiLCJzZXRJdGVtIiwiZ2V0S2V5RnJvbVRhZ3MiLCJ0YWdzIiwiZmluZCIsInRhZyIsImRlY3J5cHRlZENvbnRlbnQiLCJkZWNyeXB0TWVzc2FnZSIsImlkIiwiY29udGVudCIsIm1lc3NhZ2UiLCJkZWNyeXB0IiwiZW5jcnlwdE1lc3NhZ2UiLCJlbmNyeXB0IiwiZ2V0TWVzc2FnZXMiLCJhdXRob3JQdWJsaWNLZXkiLCJyZWNpcGllbnRQdWJsaWNLZXkiLCJzaW5jZSIsImVuYWJsZWQiLCJCb29sZWFuIiwiZmlsdGVyIiwiYXV0aG9ycyIsImtpbmRzIiwiYXNjQ3JlYXRlZEF0IiwiYSIsImIiLCJjcmVhdGVkX2F0IiwiZGVzY0NyZWF0ZWRBdCIsInNob3J0VGltZVN0YW1wIiwidGltZXN0YW1wIiwibm93IiwiRGF0ZSIsInRpbWUiLCJnZXRUaW1lIiwiZGlmZiIsInNlY29uZHMiLCJNYXRoIiwiZmxvb3IiLCJtaW51dGVzIiwiaG91cnMiLCJkYXlzIiwid2Vla3MiLCJjb3B5S2V5TWVudUl0ZW1zIiwiaGV4S2V5IiwibnNlY0hleCIsImFjdGlvbiIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsIm5wdWJFbmNvZGUiLCJsYWJlbCIsIm5zZWNFbmNvZGUiLCJzaWduRXZlbnQiLCJldmVudCIsInNpZ25lZEV2ZW50Iiwic2lnIiwiZ2V0VW5peFRpbWUiLCJjcmVhdGVQcm9maWxlRXZlbnQiLCJwcm9maWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsImtpbmQiLCJjcmVhdGVNZXNzYWdlRXZlbnQiLCJWQUxJRF9QSUNUVVJFX1BST1RPQ09MUyIsImRhdGFUb1Byb2ZpbGUiLCJhYm91dCIsImJhbm5lciIsImRpc3BsYXlfbmFtZSIsIm5hbWUiLCJuaXAwNSIsIm5wdWIiLCJwaWN0dXJlIiwidXNlcm5hbWUiLCJ3ZWJzaXRlIiwicHJvdG9jb2wiLCJzcGxpdCIsImhhcyIsInVuZGVmaW5lZCIsInVzZXJOYW1lIiwiZ2V0UHVibGljSGV4RnJvbU5vc3RyQWRkcmVzcyIsIm5wcm9maWxlIiwibnNlYyIsImhleCIsInZlcmlmaWVkTmlwMDVBZGRyZXNzZXMiLCJUSU1FT1VUX0VSUk9SUyIsImdldE5pcDA1RG9tYWluIiwibmlwMDVhZGRyZXNzIiwiZG9tYWluIiwibm9zdHJKc29uIiwiZmV0Y2giLCJvayIsIm5hbWVzIiwianNvbiIsInZlcmlmaWVkIiwidXNlcktleSIsIm90aGVyS2V5cyIsInZhbHVlcyIsImtleVZhbHVlIiwibGVuZ3RoIiwic3RhdHVzIiwiZ2V0V2ViU29ja2V0U3RhdHVzSWNvbiIsIldlYlNvY2tldCIsInByb3RvdHlwZSIsIkNPTk5FQ1RJTkciLCJPUEVOIiwiQ0xPU0lORyIsImNvbnZlcnRJbWFnZUxpbmtzVG9IdG1sIiwicmVwbGFjZSIsIm1hdGNoIiwiY29udmVydE5ld0xpbmVzVG9CcmVha3MiLCJwcmV0dHlDaGF0VGltZXN0YW1wIiwiZGF0ZSIsInRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJ5ZXN0ZXJkYXkiLCJkYXRlVGltZXN0YW1wIiwiZGF0ZVByZXR0eSIsInRvTG9jYWxlU3RyaW5nIiwid2Vla2RheSIsImRheSIsIm1vbnRoIiwieWVhciIsImdyb3VwQ2hhdEV2ZW50cyIsImV2ZW50cyIsInNvcnRlZEV2ZW50cyIsIm9sZGVzdEV2ZW50IiwicmVtYWluaW5nRXZlbnRzIiwiZ3JvdXBlZEV2ZW50cyIsImZvckVhY2giLCJsYXN0R3JvdXBlZEV2ZW50cyIsImxhc3RfY3JlYXRlZF9hdCIsImFicyIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/functions.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/hooks.ts":
/*!********************************************!*\
  !*** ./components/apps/Messenger/hooks.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNip05: () => (/* binding */ useNip05),\n/* harmony export */   useNip05Domain: () => (/* binding */ useNip05Domain),\n/* harmony export */   useNostrContacts: () => (/* binding */ useNostrContacts),\n/* harmony export */   useNostrEvents: () => (/* binding */ useNostrEvents),\n/* harmony export */   useNostrProfile: () => (/* binding */ useNostrProfile),\n/* harmony export */   usePublicKey: () => (/* binding */ usePublicKey),\n/* harmony export */   useUnreadStatus: () => (/* binding */ useUnreadStatus)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! components/apps/Messenger/HistoryContext */ \"(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\");\n/* harmony import */ var components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/MessageContext */ \"(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx\");\n/* harmony import */ var components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/NostrContext */ \"(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var contexts_process__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! contexts/process */ \"(pages-dir-browser)/./contexts/process/index.ts\");\n/* harmony import */ var contexts_process_directory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! contexts/process/directory */ \"(pages-dir-browser)/./contexts/process/directory.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\n\n\n\n\n\n\n\n\n\nconst useNostrEvents = ({ enabled = true, filter, onEvent })=>{\n    const { connectedRelays } = (0,components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_3__.useNostr)();\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const seenEventIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const filterString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrEvents.useMemo[filterString]\": ()=>JSON.stringify(filter)\n    }[\"useNostrEvents.useMemo[filterString]\"], [\n        filter\n    ]);\n    const seenDebounceTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostrEvents.useCallback[subscribe]\": (relay, subFilter)=>{\n            const sub = relay.sub(subFilter);\n            sub.on(\"event\", {\n                \"useNostrEvents.useCallback[subscribe]\": (event)=>{\n                    if (seenEventIds.current[event.id]) return;\n                    seenEventIds.current[event.id] = event;\n                    onEvent?.(event);\n                    if (seenDebounceTimer.current) {\n                        window.clearTimeout(seenDebounceTimer.current);\n                    }\n                    seenDebounceTimer.current = window.setTimeout({\n                        \"useNostrEvents.useCallback[subscribe]\": ()=>{\n                            seenDebounceTimer.current = 0;\n                            setEvents({\n                                \"useNostrEvents.useCallback[subscribe]\": (currentEvents)=>currentEvents.some({\n                                        \"useNostrEvents.useCallback[subscribe]\": ({ id })=>id === event.id\n                                    }[\"useNostrEvents.useCallback[subscribe]\"]) ? currentEvents : Object.values(seenEventIds.current)\n                            }[\"useNostrEvents.useCallback[subscribe]\"]);\n                        }\n                    }[\"useNostrEvents.useCallback[subscribe]\"], seenDebounceTimer.current ? components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_4__.SEEN_EVENTS_DEBOUNCE_MS : 0);\n                }\n            }[\"useNostrEvents.useCallback[subscribe]\"]);\n            return sub;\n        }\n    }[\"useNostrEvents.useCallback[subscribe]\"], [\n        onEvent\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostrEvents.useEffect\": ()=>{\n            if (!enabled) return;\n            const relaySubs = connectedRelays.map({\n                \"useNostrEvents.useEffect.relaySubs\": (relay)=>({\n                        relay,\n                        sub: subscribe(relay, JSON.parse(filterString))\n                    })\n            }[\"useNostrEvents.useEffect.relaySubs\"]);\n            // eslint-disable-next-line consistent-return\n            return ({\n                \"useNostrEvents.useEffect\": ()=>relaySubs.forEach({\n                        \"useNostrEvents.useEffect\": ({ sub })=>sub.unsub()\n                    }[\"useNostrEvents.useEffect\"])\n            })[\"useNostrEvents.useEffect\"];\n        }\n    }[\"useNostrEvents.useEffect\"], [\n        connectedRelays,\n        enabled,\n        filterString,\n        subscribe\n    ]);\n    return events;\n};\nconst useNip05 = ()=>{\n    const [nip05, setNip05] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const updateNip05 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNip05.useCallback[updateNip05]\": async (url)=>{\n            const nostrJson = await fetch(url);\n            if (nostrJson.ok) {\n                const { names = {} } = await nostrJson.json() || {};\n                setNip05({\n                    names\n                });\n            }\n            return nostrJson.ok;\n        }\n    }[\"useNip05.useCallback[updateNip05]\"], []);\n    const fetchNip05Json = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNip05.useCallback[fetchNip05Json]\": async ()=>{\n            if (!await updateNip05(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_4__.BASE_NIP05_URL)) {\n                setNip05({\n                    relays: {}\n                });\n            }\n        }\n    }[\"useNip05.useCallback[fetchNip05Json]\"], [\n        updateNip05\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNip05.useEffect\": ()=>{\n            if (!nip05) fetchNip05Json();\n        }\n    }[\"useNip05.useEffect\"], [\n        fetchNip05Json,\n        nip05\n    ]);\n    return nip05 || {};\n};\nconst useNostrContacts = (publicKey, wellKnownNames)=>{\n    const globalContacts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrContacts.useMemo[globalContacts]\": ()=>[\n                ...utils_constants__WEBPACK_IMPORTED_MODULE_8__.PACKAGE_DATA?.author?.npub ? new Set([\n                    (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.toHexKey)(utils_constants__WEBPACK_IMPORTED_MODULE_8__.PACKAGE_DATA.author.npub),\n                    ...Object.values(wellKnownNames || {})\n                ]) : Object.values(wellKnownNames || {})\n            ].filter(Boolean).map({\n                \"useNostrContacts.useMemo[globalContacts]\": (key)=>(0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.toHexKey)(key)\n            }[\"useNostrContacts.useMemo[globalContacts]\"])\n    }[\"useNostrContacts.useMemo[globalContacts]\"], [\n        wellKnownNames\n    ]);\n    const { events } = (0,components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_2__.useMessageContext)();\n    const contactKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrContacts.useMemo[contactKeys]\": ()=>{\n            const keys = new Set((0,utils_functions__WEBPACK_IMPORTED_MODULE_9__.toSorted)(events, components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.descCreatedAt).map({\n                \"useNostrContacts.useMemo[contactKeys]\": ({ pubkey, tags })=>pubkey === publicKey ? (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.getKeyFromTags)(tags) || \"\" : pubkey\n            }[\"useNostrContacts.useMemo[contactKeys]\"]).filter({\n                \"useNostrContacts.useMemo[contactKeys]\": (pubkey)=>!globalContacts.includes(pubkey)\n            }[\"useNostrContacts.useMemo[contactKeys]\"]));\n            return [\n                ...globalContacts,\n                ...keys\n            ].filter({\n                \"useNostrContacts.useMemo[contactKeys]\": (key)=>key !== publicKey\n            }[\"useNostrContacts.useMemo[contactKeys]\"]);\n        }\n    }[\"useNostrContacts.useMemo[contactKeys]\"], [\n        events,\n        globalContacts,\n        publicKey\n    ]);\n    const lastEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrContacts.useMemo[lastEvents]\": ()=>Object.fromEntries(contactKeys.map({\n                \"useNostrContacts.useMemo[lastEvents]\": (pubkey)=>[\n                        pubkey,\n                        events.filter({\n                            \"useNostrContacts.useMemo[lastEvents]\": (event)=>[\n                                    event.pubkey,\n                                    (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.getKeyFromTags)(event.tags)\n                                ].includes(pubkey)\n                        }[\"useNostrContacts.useMemo[lastEvents]\"]).sort(components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.descCreatedAt)[0]\n                    ]\n            }[\"useNostrContacts.useMemo[lastEvents]\"]))\n    }[\"useNostrContacts.useMemo[lastEvents]\"], [\n        contactKeys,\n        events\n    ]);\n    const { seenEventIds } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_1__.useHistoryContext)();\n    const unreadEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrContacts.useMemo[unreadEvents]\": ()=>events.filter({\n                \"useNostrContacts.useMemo[unreadEvents]\": ({ id, pubkey })=>pubkey !== publicKey && !seenEventIds.includes(id)\n            }[\"useNostrContacts.useMemo[unreadEvents]\"])\n    }[\"useNostrContacts.useMemo[unreadEvents]\"], [\n        events,\n        publicKey,\n        seenEventIds\n    ]);\n    return {\n        contactKeys,\n        events,\n        lastEvents,\n        unreadEvents\n    };\n};\nconst usePublicKey = ()=>{\n    const [publicKey, setPublicKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"usePublicKey.useEffect\": ()=>{\n            if (initialized.current) return;\n            initialized.current = true;\n            (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.maybeGetExistingPublicKey)().then(components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.getPublicHexKey).then(setPublicKey);\n        }\n    }[\"usePublicKey.useEffect\"], []);\n    return publicKey;\n};\nconst useUnreadStatus = (id, unreadCount)=>{\n    const [currentUnreadCount, setCurrentUnreadCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(unreadCount);\n    const { title } = (0,contexts_process__WEBPACK_IMPORTED_MODULE_6__.useProcesses)();\n    const [pid] = id.split(utils_constants__WEBPACK_IMPORTED_MODULE_8__.PROCESS_DELIMITER);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useUnreadStatus.useEffect\": ()=>{\n            title(pid, `${contexts_process_directory__WEBPACK_IMPORTED_MODULE_7__[\"default\"][pid]?.title}${unreadCount > 0 ? ` (${unreadCount})` : \"\"}`);\n        }\n    }[\"useUnreadStatus.useEffect\"], [\n        pid,\n        title,\n        unreadCount\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useUnreadStatus.useEffect\": ()=>{\n            if (unreadCount > currentUnreadCount) {\n                new Audio(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_4__.NOTIFICATION_SOUND).play();\n            }\n            setCurrentUnreadCount(unreadCount);\n        }\n    }[\"useUnreadStatus.useEffect\"], [\n        currentUnreadCount,\n        unreadCount\n    ]);\n};\nconst useNip05Domain = (nip05, publicKey)=>{\n    const [nip05Domain, setNip05Domain] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNip05Domain.useEffect\": ()=>{\n            (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.getNip05Domain)(nip05, publicKey).then(setNip05Domain);\n        }\n    }[\"useNip05Domain.useEffect\"], [\n        nip05,\n        publicKey\n    ]);\n    return nip05Domain;\n};\nconst useNostrProfile = (publicKey, isVisible = true)=>{\n    const { profiles, setProfiles } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_1__.useHistoryContext)();\n    const onEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostrProfile.useCallback[onEvent]\": ({ content, created_at, pubkey })=>{\n            if (!publicKey || publicKey !== pubkey || profiles?.[publicKey]?.created_at >= created_at) {\n                return;\n            }\n            try {\n                const metadata = JSON.parse(content);\n                if (metadata) {\n                    setProfiles({\n                        \"useNostrProfile.useCallback[onEvent]\": (currentProfiles)=>({\n                                ...currentProfiles,\n                                [publicKey]: (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.dataToProfile)(publicKey, metadata, created_at)\n                            })\n                    }[\"useNostrProfile.useCallback[onEvent]\"]);\n                }\n            } catch  {\n            // Ignore errors parsing profile data\n            }\n        }\n    }[\"useNostrProfile.useCallback[onEvent]\"], [\n        profiles,\n        publicKey,\n        setProfiles\n    ]);\n    const profileFilter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useNostrProfile.useMemo[profileFilter]\": ()=>({\n                enabled: !!publicKey && isVisible,\n                filter: [\n                    {\n                        authors: [\n                            publicKey\n                        ],\n                        kinds: [\n                            components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_4__.METADATA_KIND\n                        ]\n                    }\n                ],\n                onEvent\n            })\n    }[\"useNostrProfile.useMemo[profileFilter]\"], [\n        isVisible,\n        onEvent,\n        publicKey\n    ]);\n    useNostrEvents(profileFilter);\n    return publicKey ? profiles[publicKey] || (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_5__.dataToProfile)(publicKey) : {};\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvaG9va3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBFO0FBU0c7QUFDQTtBQUNYO0FBTXJCO0FBU0E7QUFNRztBQUNHO0FBQ2U7QUFDdkI7QUFFcEMsTUFBTXdCLGlCQUFpQixDQUFDLEVBQzdCQyxVQUFVLElBQUksRUFDZEMsTUFBTSxFQUNOQyxPQUFPLEVBS1I7SUFDQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHckIsZ0ZBQVFBO0lBQ3BDLE1BQU0sQ0FBQ3NCLFFBQVFDLFVBQVUsR0FBRzFCLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTTJCLGVBQWU1Qiw2Q0FBTUEsQ0FBNkIsQ0FBQztJQUN6RCxNQUFNNkIsZUFBZTlCLDhDQUFPQTtnREFBQyxJQUFNK0IsS0FBS0MsU0FBUyxDQUFDUjsrQ0FBUztRQUFDQTtLQUFPO0lBQ25FLE1BQU1TLG9CQUFvQmhDLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU1pQyxZQUFZcEMsa0RBQVdBO2lEQUMzQixDQUFDcUMsT0FBY0M7WUFDYixNQUFNQyxNQUFNRixNQUFNRSxHQUFHLENBQUNEO1lBRXRCQyxJQUFJQyxFQUFFLENBQUM7eURBQVMsQ0FBQ0M7b0JBQ2YsSUFBSVYsYUFBYVcsT0FBTyxDQUFDRCxNQUFNRSxFQUFFLENBQUMsRUFBRTtvQkFFcENaLGFBQWFXLE9BQU8sQ0FBQ0QsTUFBTUUsRUFBRSxDQUFDLEdBQUdGO29CQUVqQ2QsVUFBVWM7b0JBRVYsSUFBSU4sa0JBQWtCTyxPQUFPLEVBQUU7d0JBQzdCRSxPQUFPQyxZQUFZLENBQUNWLGtCQUFrQk8sT0FBTztvQkFDL0M7b0JBRUFQLGtCQUFrQk8sT0FBTyxHQUFHRSxPQUFPRSxVQUFVO2lFQUMzQzs0QkFDRVgsa0JBQWtCTyxPQUFPLEdBQUc7NEJBRTVCWjt5RUFBVSxDQUFDaUIsZ0JBQ1RBLGNBQWNDLElBQUk7aUZBQUMsQ0FBQyxFQUFFTCxFQUFFLEVBQUUsR0FBS0EsT0FBT0YsTUFBTUUsRUFBRTtrRkFDMUNJLGdCQUNBRSxPQUFPQyxNQUFNLENBQUNuQixhQUFhVyxPQUFPOzt3QkFFMUM7Z0VBQ0FQLGtCQUFrQk8sT0FBTyxHQUFHL0Isd0ZBQXVCQSxHQUFHO2dCQUUxRDs7WUFFQSxPQUFPNEI7UUFDVDtnREFDQTtRQUFDWjtLQUFRO0lBR1gxQixnREFBU0E7b0NBQUM7WUFDUixJQUFJLENBQUN3QixTQUFTO1lBRWQsTUFBTTBCLFlBQVl2QixnQkFBZ0J3QixHQUFHO3NEQUFDLENBQUNmLFFBQVc7d0JBQ2hEQTt3QkFDQUUsS0FBS0gsVUFBVUMsT0FBT0osS0FBS29CLEtBQUssQ0FBQ3JCO29CQUNuQzs7WUFFQSw2Q0FBNkM7WUFDN0M7NENBQU8sSUFBTW1CLFVBQVVHLE9BQU87b0RBQUMsQ0FBQyxFQUFFZixHQUFHLEVBQUUsR0FBS0EsSUFBSWdCLEtBQUs7OztRQUN2RDttQ0FBRztRQUFDM0I7UUFBaUJIO1FBQVNPO1FBQWNJO0tBQVU7SUFFdEQsT0FBT1A7QUFDVCxFQUFFO0FBRUssTUFBTTJCLFdBQVc7SUFDdEIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUd0RCwrQ0FBUUE7SUFDbEMsTUFBTXVELGNBQWMzRCxrREFBV0E7NkNBQUMsT0FBTzREO1lBQ3JDLE1BQU1DLFlBQVksTUFBTUMsTUFBTUY7WUFFOUIsSUFBSUMsVUFBVUUsRUFBRSxFQUFFO2dCQUNoQixNQUFNLEVBQUVDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxNQUFRSCxVQUFVSSxJQUFJLE1BQXVCLENBQUM7Z0JBRXJFUCxTQUFTO29CQUFFTTtnQkFBTTtZQUNuQjtZQUVBLE9BQU9ILFVBQVVFLEVBQUU7UUFDckI7NENBQUcsRUFBRTtJQUNMLE1BQU1HLGlCQUFpQmxFLGtEQUFXQTtnREFBQztZQUNqQyxJQUFJLENBQUUsTUFBTTJELFlBQVluRCwrRUFBY0EsR0FBSTtnQkFDeENrRCxTQUFTO29CQUFFUyxRQUFRLENBQUM7Z0JBQUU7WUFDeEI7UUFDRjsrQ0FBRztRQUFDUjtLQUFZO0lBRWhCMUQsZ0RBQVNBOzhCQUFDO1lBQ1IsSUFBSSxDQUFDd0QsT0FBT1M7UUFDZDs2QkFBRztRQUFDQTtRQUFnQlQ7S0FBTTtJQUUxQixPQUFPQSxTQUFVLENBQUM7QUFDcEIsRUFBRTtBQUVLLE1BQU1XLG1CQUFtQixDQUM5QkMsV0FDQUM7SUFFQSxNQUFNQyxpQkFBaUJyRSw4Q0FBT0E7b0RBQzVCLElBQ0U7bUJBQ01tQix5REFBWUEsRUFBRW1ELFFBQVFDLE9BQ3RCLElBQUlDLElBQUk7b0JBQ054RCw2RUFBUUEsQ0FBQ0cseURBQVlBLENBQUNtRCxNQUFNLENBQUNDLElBQUk7dUJBQzlCeEIsT0FBT0MsTUFBTSxDQUFDb0Isa0JBQWtCLENBQUM7aUJBQ3JDLElBQ0RyQixPQUFPQyxNQUFNLENBQUNvQixrQkFBa0IsQ0FBQzthQUN0QyxDQUNFNUMsTUFBTSxDQUFDaUQsU0FDUHZCLEdBQUc7NERBQUMsQ0FBQ3dCLE1BQVExRCw2RUFBUUEsQ0FBQzBEOzttREFDM0I7UUFBQ047S0FBZTtJQUVsQixNQUFNLEVBQUV6QyxNQUFNLEVBQUUsR0FBR3ZCLDJGQUFpQkE7SUFDcEMsTUFBTXVFLGNBQWMzRSw4Q0FBT0E7aURBQUM7WUFDMUIsTUFBTTRFLE9BQU8sSUFBSUosSUFDZm5ELHlEQUFRQSxDQUFDTSxRQUFRaEIsOEVBQWFBLEVBQzNCdUMsR0FBRzt5REFBQyxDQUFDLEVBQUUyQixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUNwQkQsV0FBV1YsWUFBWXZELG1GQUFjQSxDQUFDa0UsU0FBUyxLQUFLRDt3REFFckRyRCxNQUFNO3lEQUFDLENBQUNxRCxTQUFXLENBQUNSLGVBQWVVLFFBQVEsQ0FBQ0Y7O1lBR2pELE9BQU87bUJBQUlSO21CQUFtQk87YUFBSyxDQUFDcEQsTUFBTTt5REFBQyxDQUFDa0QsTUFBUUEsUUFBUVA7O1FBQzlEO2dEQUFHO1FBQUN4QztRQUFRMEM7UUFBZ0JGO0tBQVU7SUFDdEMsTUFBTWEsYUFBYWhGLDhDQUFPQTtnREFDeEIsSUFDRStDLE9BQU9rQyxXQUFXLENBQ2hCTixZQUFZekIsR0FBRzt3REFBQyxDQUFDMkIsU0FBVzt3QkFDMUJBO3dCQUNBbEQsT0FDR0gsTUFBTTtvRUFBQyxDQUFDZSxRQUNQO29DQUFDQSxNQUFNc0MsTUFBTTtvQ0FBRWpFLG1GQUFjQSxDQUFDMkIsTUFBTXVDLElBQUk7aUNBQUUsQ0FBQ0MsUUFBUSxDQUFDRjttRUFFckRLLElBQUksQ0FBQ3ZFLDhFQUFhQSxDQUFDLENBQUMsRUFBRTtxQkFDMUI7OytDQUVMO1FBQUNnRTtRQUFhaEQ7S0FBTztJQUV2QixNQUFNLEVBQUVFLFlBQVksRUFBRSxHQUFHMUIsMkZBQWlCQTtJQUMxQyxNQUFNZ0YsZUFBZW5GLDhDQUFPQTtrREFDMUIsSUFDRTJCLE9BQU9ILE1BQU07MERBQ1gsQ0FBQyxFQUFFaUIsRUFBRSxFQUFFb0MsTUFBTSxFQUFFLEdBQUtBLFdBQVdWLGFBQWEsQ0FBQ3RDLGFBQWFrRCxRQUFRLENBQUN0Qzs7aURBRXZFO1FBQUNkO1FBQVF3QztRQUFXdEM7S0FBYTtJQUduQyxPQUFPO1FBQUU4QztRQUFhaEQ7UUFBUXFEO1FBQVlHO0lBQWE7QUFDekQsRUFBRTtBQUVLLE1BQU1DLGVBQWU7SUFDMUIsTUFBTSxDQUFDakIsV0FBV2tCLGFBQWEsR0FBR25GLCtDQUFRQSxDQUFTO0lBQ25ELE1BQU1vRixjQUFjckYsNkNBQU1BLENBQUM7SUFFM0JGLGdEQUFTQTtrQ0FBQztZQUNSLElBQUl1RixZQUFZOUMsT0FBTyxFQUFFO1lBRXpCOEMsWUFBWTlDLE9BQU8sR0FBRztZQUV0QnpCLDhGQUF5QkEsR0FBR3dFLElBQUksQ0FBQ3pFLGdGQUFlQSxFQUFFeUUsSUFBSSxDQUFDRjtRQUN6RDtpQ0FBRyxFQUFFO0lBRUwsT0FBT2xCO0FBQ1QsRUFBRTtBQUVLLE1BQU1xQixrQkFBa0IsQ0FBQy9DLElBQVlnRDtJQUMxQyxNQUFNLENBQUNDLG9CQUFvQkMsc0JBQXNCLEdBQUd6RiwrQ0FBUUEsQ0FBQ3VGO0lBQzdELE1BQU0sRUFBRUcsS0FBSyxFQUFFLEdBQUczRSw4REFBWUE7SUFDOUIsTUFBTSxDQUFDNEUsSUFBSSxHQUFHcEQsR0FBR3FELEtBQUssQ0FBQzFFLDhEQUFpQkE7SUFFeENyQixnREFBU0E7cUNBQUM7WUFDUjZGLE1BQ0VDLEtBQ0EsR0FBRzNFLGtFQUFTLENBQUMyRSxJQUFJLEVBQUVELFFBQVFILGNBQWMsSUFBSSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJO1FBRTNFO29DQUFHO1FBQUNJO1FBQUtEO1FBQU9IO0tBQVk7SUFFNUIxRixnREFBU0E7cUNBQUM7WUFDUixJQUFJMEYsY0FBY0Msb0JBQW9CO2dCQUNwQyxJQUFJSyxNQUFNdkYsbUZBQWtCQSxFQUFFd0YsSUFBSTtZQUNwQztZQUVBTCxzQkFBc0JGO1FBQ3hCO29DQUFHO1FBQUNDO1FBQW9CRDtLQUFZO0FBQ3RDLEVBQUU7QUFFSyxNQUFNUSxpQkFBaUIsQ0FBQzFDLE9BQWdCWTtJQUM3QyxNQUFNLENBQUMrQixhQUFhQyxlQUFlLEdBQUdqRywrQ0FBUUEsQ0FBQztJQUUvQ0gsZ0RBQVNBO29DQUFDO1lBQ1JjLG1GQUFjQSxDQUFDMEMsT0FBT1ksV0FBV29CLElBQUksQ0FBQ1k7UUFDeEM7bUNBQUc7UUFBQzVDO1FBQU9ZO0tBQVU7SUFFckIsT0FBTytCO0FBQ1QsRUFBRTtBQUVLLE1BQU1FLGtCQUFrQixDQUM3QmpDLFdBQ0FrQyxZQUFZLElBQUk7SUFFaEIsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFdBQVcsRUFBRSxHQUFHcEcsMkZBQWlCQTtJQUNuRCxNQUFNc0IsVUFBVTNCLGtEQUFXQTtnREFDekIsQ0FBQyxFQUFFMEcsT0FBTyxFQUFFQyxVQUFVLEVBQUU1QixNQUFNLEVBQWM7WUFDMUMsSUFDRSxDQUFDVixhQUNEQSxjQUFjVSxVQUNkLFVBQVcsQ0FBQ1YsVUFBVSxFQUFFc0MsY0FBeUJBLFlBQ2pEO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJO2dCQUNGLE1BQU1DLFdBQVczRSxLQUFLb0IsS0FBSyxDQUFDcUQ7Z0JBRTVCLElBQUlFLFVBQVU7b0JBQ1pIO2dFQUFZLENBQUNJLGtCQUFxQjtnQ0FDaEMsR0FBR0EsZUFBZTtnQ0FDbEIsQ0FBQ3hDLFVBQVUsRUFBRXpELGtGQUFhQSxDQUFDeUQsV0FBV3VDLFVBQVVEOzRCQUNsRDs7Z0JBQ0Y7WUFDRixFQUFFLE9BQU07WUFDTixxQ0FBcUM7WUFDdkM7UUFDRjsrQ0FDQTtRQUFDSDtRQUFVbkM7UUFBV29DO0tBQVk7SUFFcEMsTUFBTUssZ0JBQWdCNUcsOENBQU9BO2tEQUMzQixJQUFPO2dCQUNMdUIsU0FBUyxDQUFDLENBQUM0QyxhQUFha0M7Z0JBQ3hCN0UsUUFBUTtvQkFDTjt3QkFDRXFGLFNBQVM7NEJBQUMxQzt5QkFBVTt3QkFDcEIyQyxPQUFPOzRCQUFDdkcsOEVBQWFBO3lCQUFDO29CQUN4QjtpQkFDRDtnQkFDRGtCO1lBQ0Y7aURBQ0E7UUFBQzRFO1FBQVc1RTtRQUFTMEM7S0FBVTtJQUdqQzdDLGVBQWVzRjtJQUVmLE9BQU96QyxZQUFZbUMsUUFBUSxDQUFDbkMsVUFBVSxJQUFJekQsa0ZBQWFBLENBQUN5RCxhQUFhLENBQUM7QUFDeEUsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXGhvb2tzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9jb25zaXN0ZW50LXR5cGUtc3BlY2lmaWVyLXN0eWxlXHJcbmltcG9ydCB0eXBlIHsgTklQMDVSZXN1bHQgfSBmcm9tIFwibm9zdHItdG9vbHMvbGliL3R5cGVzL25pcDA1XCI7XHJcbmltcG9ydCB7XHJcbiAgdHlwZSBGaWx0ZXIsXHJcbiAgdHlwZSBFdmVudCBhcyBOb3N0ckV2ZW50LFxyXG4gIHR5cGUgUmVsYXksXHJcbiAgdHlwZSBTdWIsXHJcbn0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XHJcbmltcG9ydCB7IHVzZUhpc3RvcnlDb250ZXh0IH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSGlzdG9yeUNvbnRleHRcIjtcclxuaW1wb3J0IHsgdXNlTWVzc2FnZUNvbnRleHQgfSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9NZXNzYWdlQ29udGV4dFwiO1xyXG5pbXBvcnQgeyB1c2VOb3N0ciB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL05vc3RyQ29udGV4dFwiO1xyXG5pbXBvcnQge1xyXG4gIEJBU0VfTklQMDVfVVJMLFxyXG4gIE1FVEFEQVRBX0tJTkQsXHJcbiAgTk9USUZJQ0FUSU9OX1NPVU5ELFxyXG4gIFNFRU5fRVZFTlRTX0RFQk9VTkNFX01TLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQge1xyXG4gIGRhdGFUb1Byb2ZpbGUsXHJcbiAgZGVzY0NyZWF0ZWRBdCxcclxuICBnZXRLZXlGcm9tVGFncyxcclxuICBnZXROaXAwNURvbWFpbixcclxuICBnZXRQdWJsaWNIZXhLZXksXHJcbiAgbWF5YmVHZXRFeGlzdGluZ1B1YmxpY0tleSxcclxuICB0b0hleEtleSxcclxufSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9mdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtcclxuICB0eXBlIE1ldGFkYXRhLFxyXG4gIHR5cGUgTm9zdHJDb250YWN0cyxcclxuICB0eXBlIE5vc3RyUHJvZmlsZSxcclxufSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci90eXBlc1wiO1xyXG5pbXBvcnQgeyB1c2VQcm9jZXNzZXMgfSBmcm9tIFwiY29udGV4dHMvcHJvY2Vzc1wiO1xyXG5pbXBvcnQgZGlyZWN0b3J5IGZyb20gXCJjb250ZXh0cy9wcm9jZXNzL2RpcmVjdG9yeVwiO1xyXG5pbXBvcnQgeyBQQUNLQUdFX0RBVEEsIFBST0NFU1NfREVMSU1JVEVSIH0gZnJvbSBcInV0aWxzL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyB0b1NvcnRlZCB9IGZyb20gXCJ1dGlscy9mdW5jdGlvbnNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VOb3N0ckV2ZW50cyA9ICh7XHJcbiAgZW5hYmxlZCA9IHRydWUsXHJcbiAgZmlsdGVyLFxyXG4gIG9uRXZlbnQsXHJcbn06IHtcclxuICBlbmFibGVkPzogYm9vbGVhbjtcclxuICBmaWx0ZXI6IEZpbHRlcltdO1xyXG4gIG9uRXZlbnQ/OiAoZXZlbnQ6IE5vc3RyRXZlbnQpID0+IHZvaWQ7XHJcbn0pOiBOb3N0ckV2ZW50W10gPT4ge1xyXG4gIGNvbnN0IHsgY29ubmVjdGVkUmVsYXlzIH0gPSB1c2VOb3N0cigpO1xyXG4gIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZTxOb3N0ckV2ZW50W10+KFtdKTtcclxuICBjb25zdCBzZWVuRXZlbnRJZHMgPSB1c2VSZWY8UmVjb3JkPHN0cmluZywgTm9zdHJFdmVudD4+KHt9KTtcclxuICBjb25zdCBmaWx0ZXJTdHJpbmcgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KGZpbHRlciksIFtmaWx0ZXJdKTtcclxuICBjb25zdCBzZWVuRGVib3VuY2VUaW1lciA9IHVzZVJlZigwKTtcclxuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayhcclxuICAgIChyZWxheTogUmVsYXksIHN1YkZpbHRlcjogRmlsdGVyW10pOiBTdWIgPT4ge1xyXG4gICAgICBjb25zdCBzdWIgPSByZWxheS5zdWIoc3ViRmlsdGVyKTtcclxuXHJcbiAgICAgIHN1Yi5vbihcImV2ZW50XCIsIChldmVudDogTm9zdHJFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChzZWVuRXZlbnRJZHMuY3VycmVudFtldmVudC5pZF0pIHJldHVybjtcclxuXHJcbiAgICAgICAgc2VlbkV2ZW50SWRzLmN1cnJlbnRbZXZlbnQuaWRdID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIG9uRXZlbnQ/LihldmVudCk7XHJcblxyXG4gICAgICAgIGlmIChzZWVuRGVib3VuY2VUaW1lci5jdXJyZW50KSB7XHJcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNlZW5EZWJvdW5jZVRpbWVyLmN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VlbkRlYm91bmNlVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxyXG4gICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICBzZWVuRGVib3VuY2VUaW1lci5jdXJyZW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHNldEV2ZW50cygoY3VycmVudEV2ZW50cykgPT5cclxuICAgICAgICAgICAgICBjdXJyZW50RXZlbnRzLnNvbWUoKHsgaWQgfSkgPT4gaWQgPT09IGV2ZW50LmlkKVxyXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50RXZlbnRzXHJcbiAgICAgICAgICAgICAgICA6IE9iamVjdC52YWx1ZXMoc2VlbkV2ZW50SWRzLmN1cnJlbnQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc2VlbkRlYm91bmNlVGltZXIuY3VycmVudCA/IFNFRU5fRVZFTlRTX0RFQk9VTkNFX01TIDogMFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH0sXHJcbiAgICBbb25FdmVudF1cclxuICApO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcmVsYXlTdWJzID0gY29ubmVjdGVkUmVsYXlzLm1hcCgocmVsYXkpID0+ICh7XHJcbiAgICAgIHJlbGF5LFxyXG4gICAgICBzdWI6IHN1YnNjcmliZShyZWxheSwgSlNPTi5wYXJzZShmaWx0ZXJTdHJpbmcpIGFzIEZpbHRlcltdKSxcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cclxuICAgIHJldHVybiAoKSA9PiByZWxheVN1YnMuZm9yRWFjaCgoeyBzdWIgfSkgPT4gc3ViLnVuc3ViKCkpO1xyXG4gIH0sIFtjb25uZWN0ZWRSZWxheXMsIGVuYWJsZWQsIGZpbHRlclN0cmluZywgc3Vic2NyaWJlXSk7XHJcblxyXG4gIHJldHVybiBldmVudHM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlTmlwMDUgPSAoKTogTklQMDVSZXN1bHQgPT4ge1xyXG4gIGNvbnN0IFtuaXAwNSwgc2V0TmlwMDVdID0gdXNlU3RhdGU8TklQMDVSZXN1bHQ+KCk7XHJcbiAgY29uc3QgdXBkYXRlTmlwMDUgPSB1c2VDYWxsYmFjayhhc3luYyAodXJsOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICAgIGNvbnN0IG5vc3RySnNvbiA9IGF3YWl0IGZldGNoKHVybCk7XHJcblxyXG4gICAgaWYgKG5vc3RySnNvbi5vaykge1xyXG4gICAgICBjb25zdCB7IG5hbWVzID0ge30gfSA9ICgoYXdhaXQgbm9zdHJKc29uLmpzb24oKSkgYXMgTklQMDVSZXN1bHQpIHx8IHt9O1xyXG5cclxuICAgICAgc2V0TmlwMDUoeyBuYW1lcyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9zdHJKc29uLm9rO1xyXG4gIH0sIFtdKTtcclxuICBjb25zdCBmZXRjaE5pcDA1SnNvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGlmICghKGF3YWl0IHVwZGF0ZU5pcDA1KEJBU0VfTklQMDVfVVJMKSkpIHtcclxuICAgICAgc2V0TmlwMDUoeyByZWxheXM6IHt9IH0gYXMgTklQMDVSZXN1bHQpO1xyXG4gICAgfVxyXG4gIH0sIFt1cGRhdGVOaXAwNV0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFuaXAwNSkgZmV0Y2hOaXAwNUpzb24oKTtcclxuICB9LCBbZmV0Y2hOaXAwNUpzb24sIG5pcDA1XSk7XHJcblxyXG4gIHJldHVybiBuaXAwNSB8fCAoe30gYXMgTklQMDVSZXN1bHQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZU5vc3RyQ29udGFjdHMgPSAoXHJcbiAgcHVibGljS2V5OiBzdHJpbmcsXHJcbiAgd2VsbEtub3duTmFtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cclxuKTogTm9zdHJDb250YWN0cyA9PiB7XHJcbiAgY29uc3QgZ2xvYmFsQ29udGFjdHMgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT5cclxuICAgICAgW1xyXG4gICAgICAgIC4uLihQQUNLQUdFX0RBVEE/LmF1dGhvcj8ubnB1YlxyXG4gICAgICAgICAgPyBuZXcgU2V0KFtcclxuICAgICAgICAgICAgICB0b0hleEtleShQQUNLQUdFX0RBVEEuYXV0aG9yLm5wdWIpLFxyXG4gICAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMod2VsbEtub3duTmFtZXMgfHwge30pLFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICAgOiBPYmplY3QudmFsdWVzKHdlbGxLbm93bk5hbWVzIHx8IHt9KSksXHJcbiAgICAgIF1cclxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXHJcbiAgICAgICAgLm1hcCgoa2V5KSA9PiB0b0hleEtleShrZXkpKSxcclxuICAgIFt3ZWxsS25vd25OYW1lc11cclxuICApO1xyXG4gIGNvbnN0IHsgZXZlbnRzIH0gPSB1c2VNZXNzYWdlQ29udGV4dCgpO1xyXG4gIGNvbnN0IGNvbnRhY3RLZXlzID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChcclxuICAgICAgdG9Tb3J0ZWQoZXZlbnRzLCBkZXNjQ3JlYXRlZEF0KVxyXG4gICAgICAgIC5tYXAoKHsgcHVia2V5LCB0YWdzIH0pID0+XHJcbiAgICAgICAgICBwdWJrZXkgPT09IHB1YmxpY0tleSA/IGdldEtleUZyb21UYWdzKHRhZ3MpIHx8IFwiXCIgOiBwdWJrZXlcclxuICAgICAgICApXHJcbiAgICAgICAgLmZpbHRlcigocHVia2V5KSA9PiAhZ2xvYmFsQ29udGFjdHMuaW5jbHVkZXMocHVia2V5KSlcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIFsuLi5nbG9iYWxDb250YWN0cywgLi4ua2V5c10uZmlsdGVyKChrZXkpID0+IGtleSAhPT0gcHVibGljS2V5KTtcclxuICB9LCBbZXZlbnRzLCBnbG9iYWxDb250YWN0cywgcHVibGljS2V5XSk7XHJcbiAgY29uc3QgbGFzdEV2ZW50cyA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PlxyXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAgICAgY29udGFjdEtleXMubWFwKChwdWJrZXkpID0+IFtcclxuICAgICAgICAgIHB1YmtleSxcclxuICAgICAgICAgIGV2ZW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT5cclxuICAgICAgICAgICAgICBbZXZlbnQucHVia2V5LCBnZXRLZXlGcm9tVGFncyhldmVudC50YWdzKV0uaW5jbHVkZXMocHVia2V5KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5zb3J0KGRlc2NDcmVhdGVkQXQpWzBdLFxyXG4gICAgICAgIF0pXHJcbiAgICAgICksXHJcbiAgICBbY29udGFjdEtleXMsIGV2ZW50c11cclxuICApO1xyXG4gIGNvbnN0IHsgc2VlbkV2ZW50SWRzIH0gPSB1c2VIaXN0b3J5Q29udGV4dCgpO1xyXG4gIGNvbnN0IHVucmVhZEV2ZW50cyA9IHVzZU1lbW8oXHJcbiAgICAoKSA9PlxyXG4gICAgICBldmVudHMuZmlsdGVyKFxyXG4gICAgICAgICh7IGlkLCBwdWJrZXkgfSkgPT4gcHVia2V5ICE9PSBwdWJsaWNLZXkgJiYgIXNlZW5FdmVudElkcy5pbmNsdWRlcyhpZClcclxuICAgICAgKSxcclxuICAgIFtldmVudHMsIHB1YmxpY0tleSwgc2VlbkV2ZW50SWRzXVxyXG4gICk7XHJcblxyXG4gIHJldHVybiB7IGNvbnRhY3RLZXlzLCBldmVudHMsIGxhc3RFdmVudHMsIHVucmVhZEV2ZW50cyB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVB1YmxpY0tleSA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IFtwdWJsaWNLZXksIHNldFB1YmxpY0tleV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4gIGNvbnN0IGluaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpbml0aWFsaXplZC5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgbWF5YmVHZXRFeGlzdGluZ1B1YmxpY0tleSgpLnRoZW4oZ2V0UHVibGljSGV4S2V5KS50aGVuKHNldFB1YmxpY0tleSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4gcHVibGljS2V5O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVVucmVhZFN0YXR1cyA9IChpZDogc3RyaW5nLCB1bnJlYWRDb3VudDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgW2N1cnJlbnRVbnJlYWRDb3VudCwgc2V0Q3VycmVudFVucmVhZENvdW50XSA9IHVzZVN0YXRlKHVucmVhZENvdW50KTtcclxuICBjb25zdCB7IHRpdGxlIH0gPSB1c2VQcm9jZXNzZXMoKTtcclxuICBjb25zdCBbcGlkXSA9IGlkLnNwbGl0KFBST0NFU1NfREVMSU1JVEVSKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHRpdGxlKFxyXG4gICAgICBwaWQsXHJcbiAgICAgIGAke2RpcmVjdG9yeVtwaWRdPy50aXRsZX0ke3VucmVhZENvdW50ID4gMCA/IGAgKCR7dW5yZWFkQ291bnR9KWAgOiBcIlwifWBcclxuICAgICk7XHJcbiAgfSwgW3BpZCwgdGl0bGUsIHVucmVhZENvdW50XSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodW5yZWFkQ291bnQgPiBjdXJyZW50VW5yZWFkQ291bnQpIHtcclxuICAgICAgbmV3IEF1ZGlvKE5PVElGSUNBVElPTl9TT1VORCkucGxheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEN1cnJlbnRVbnJlYWRDb3VudCh1bnJlYWRDb3VudCk7XHJcbiAgfSwgW2N1cnJlbnRVbnJlYWRDb3VudCwgdW5yZWFkQ291bnRdKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VOaXAwNURvbWFpbiA9IChuaXAwNT86IHN0cmluZywgcHVibGljS2V5Pzogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBbbmlwMDVEb21haW4sIHNldE5pcDA1RG9tYWluXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZ2V0TmlwMDVEb21haW4obmlwMDUsIHB1YmxpY0tleSkudGhlbihzZXROaXAwNURvbWFpbik7XHJcbiAgfSwgW25pcDA1LCBwdWJsaWNLZXldKTtcclxuXHJcbiAgcmV0dXJuIG5pcDA1RG9tYWluO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZU5vc3RyUHJvZmlsZSA9IChcclxuICBwdWJsaWNLZXk6IHN0cmluZyxcclxuICBpc1Zpc2libGUgPSB0cnVlXHJcbik6IE5vc3RyUHJvZmlsZSA9PiB7XHJcbiAgY29uc3QgeyBwcm9maWxlcywgc2V0UHJvZmlsZXMgfSA9IHVzZUhpc3RvcnlDb250ZXh0KCk7XHJcbiAgY29uc3Qgb25FdmVudCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHsgY29udGVudCwgY3JlYXRlZF9hdCwgcHVia2V5IH06IE5vc3RyRXZlbnQpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFwdWJsaWNLZXkgfHxcclxuICAgICAgICBwdWJsaWNLZXkgIT09IHB1YmtleSB8fFxyXG4gICAgICAgIChwcm9maWxlcz8uW3B1YmxpY0tleV0/LmNyZWF0ZWRfYXQgYXMgbnVtYmVyKSA+PSBjcmVhdGVkX2F0XHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgTWV0YWRhdGE7XHJcblxyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgc2V0UHJvZmlsZXMoKGN1cnJlbnRQcm9maWxlcykgPT4gKHtcclxuICAgICAgICAgICAgLi4uY3VycmVudFByb2ZpbGVzLFxyXG4gICAgICAgICAgICBbcHVibGljS2V5XTogZGF0YVRvUHJvZmlsZShwdWJsaWNLZXksIG1ldGFkYXRhLCBjcmVhdGVkX2F0KSxcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgcGFyc2luZyBwcm9maWxlIGRhdGFcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtwcm9maWxlcywgcHVibGljS2V5LCBzZXRQcm9maWxlc11cclxuICApO1xyXG4gIGNvbnN0IHByb2ZpbGVGaWx0ZXIgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT4gKHtcclxuICAgICAgZW5hYmxlZDogISFwdWJsaWNLZXkgJiYgaXNWaXNpYmxlLFxyXG4gICAgICBmaWx0ZXI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBhdXRob3JzOiBbcHVibGljS2V5XSxcclxuICAgICAgICAgIGtpbmRzOiBbTUVUQURBVEFfS0lORF0sXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgb25FdmVudCxcclxuICAgIH0pLFxyXG4gICAgW2lzVmlzaWJsZSwgb25FdmVudCwgcHVibGljS2V5XVxyXG4gICk7XHJcblxyXG4gIHVzZU5vc3RyRXZlbnRzKHByb2ZpbGVGaWx0ZXIpO1xyXG5cclxuICByZXR1cm4gcHVibGljS2V5ID8gcHJvZmlsZXNbcHVibGljS2V5XSB8fCBkYXRhVG9Qcm9maWxlKHB1YmxpY0tleSkgOiB7fTtcclxufTtcclxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlSGlzdG9yeUNvbnRleHQiLCJ1c2VNZXNzYWdlQ29udGV4dCIsInVzZU5vc3RyIiwiQkFTRV9OSVAwNV9VUkwiLCJNRVRBREFUQV9LSU5EIiwiTk9USUZJQ0FUSU9OX1NPVU5EIiwiU0VFTl9FVkVOVFNfREVCT1VOQ0VfTVMiLCJkYXRhVG9Qcm9maWxlIiwiZGVzY0NyZWF0ZWRBdCIsImdldEtleUZyb21UYWdzIiwiZ2V0TmlwMDVEb21haW4iLCJnZXRQdWJsaWNIZXhLZXkiLCJtYXliZUdldEV4aXN0aW5nUHVibGljS2V5IiwidG9IZXhLZXkiLCJ1c2VQcm9jZXNzZXMiLCJkaXJlY3RvcnkiLCJQQUNLQUdFX0RBVEEiLCJQUk9DRVNTX0RFTElNSVRFUiIsInRvU29ydGVkIiwidXNlTm9zdHJFdmVudHMiLCJlbmFibGVkIiwiZmlsdGVyIiwib25FdmVudCIsImNvbm5lY3RlZFJlbGF5cyIsImV2ZW50cyIsInNldEV2ZW50cyIsInNlZW5FdmVudElkcyIsImZpbHRlclN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZWVuRGVib3VuY2VUaW1lciIsInN1YnNjcmliZSIsInJlbGF5Iiwic3ViRmlsdGVyIiwic3ViIiwib24iLCJldmVudCIsImN1cnJlbnQiLCJpZCIsIndpbmRvdyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjdXJyZW50RXZlbnRzIiwic29tZSIsIk9iamVjdCIsInZhbHVlcyIsInJlbGF5U3VicyIsIm1hcCIsInBhcnNlIiwiZm9yRWFjaCIsInVuc3ViIiwidXNlTmlwMDUiLCJuaXAwNSIsInNldE5pcDA1IiwidXBkYXRlTmlwMDUiLCJ1cmwiLCJub3N0ckpzb24iLCJmZXRjaCIsIm9rIiwibmFtZXMiLCJqc29uIiwiZmV0Y2hOaXAwNUpzb24iLCJyZWxheXMiLCJ1c2VOb3N0ckNvbnRhY3RzIiwicHVibGljS2V5Iiwid2VsbEtub3duTmFtZXMiLCJnbG9iYWxDb250YWN0cyIsImF1dGhvciIsIm5wdWIiLCJTZXQiLCJCb29sZWFuIiwia2V5IiwiY29udGFjdEtleXMiLCJrZXlzIiwicHVia2V5IiwidGFncyIsImluY2x1ZGVzIiwibGFzdEV2ZW50cyIsImZyb21FbnRyaWVzIiwic29ydCIsInVucmVhZEV2ZW50cyIsInVzZVB1YmxpY0tleSIsInNldFB1YmxpY0tleSIsImluaXRpYWxpemVkIiwidGhlbiIsInVzZVVucmVhZFN0YXR1cyIsInVucmVhZENvdW50IiwiY3VycmVudFVucmVhZENvdW50Iiwic2V0Q3VycmVudFVucmVhZENvdW50IiwidGl0bGUiLCJwaWQiLCJzcGxpdCIsIkF1ZGlvIiwicGxheSIsInVzZU5pcDA1RG9tYWluIiwibmlwMDVEb21haW4iLCJzZXROaXAwNURvbWFpbiIsInVzZU5vc3RyUHJvZmlsZSIsImlzVmlzaWJsZSIsInByb2ZpbGVzIiwic2V0UHJvZmlsZXMiLCJjb250ZW50IiwiY3JlYXRlZF9hdCIsIm1ldGFkYXRhIiwiY3VycmVudFByb2ZpbGVzIiwicHJvZmlsZUZpbHRlciIsImF1dGhvcnMiLCJraW5kcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/hooks.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/apps/Messenger/index.tsx":
/*!*********************************************!*\
  !*** ./components/apps/Messenger/index.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! motion/react */ \"(pages-dir-browser)/./node_modules/motion/dist/es/react.mjs\");\n/* harmony import */ var components_apps_Messenger_ChatLog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/apps/Messenger/ChatLog */ \"(pages-dir-browser)/./components/apps/Messenger/ChatLog.tsx\");\n/* harmony import */ var components_apps_Messenger_Contact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/apps/Messenger/Contact */ \"(pages-dir-browser)/./components/apps/Messenger/Contact.tsx\");\n/* harmony import */ var components_apps_Messenger_GetMoreMessages__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! components/apps/Messenger/GetMoreMessages */ \"(pages-dir-browser)/./components/apps/Messenger/GetMoreMessages.tsx\");\n/* harmony import */ var components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! components/apps/Messenger/HistoryContext */ \"(pages-dir-browser)/./components/apps/Messenger/HistoryContext.tsx\");\n/* harmony import */ var components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/apps/Messenger/MessageContext */ \"(pages-dir-browser)/./components/apps/Messenger/MessageContext.tsx\");\n/* harmony import */ var components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! components/apps/Messenger/NostrContext */ \"(pages-dir-browser)/./components/apps/Messenger/NostrContext.tsx\");\n/* harmony import */ var components_apps_Messenger_ProfileBanner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! components/apps/Messenger/ProfileBanner */ \"(pages-dir-browser)/./components/apps/Messenger/ProfileBanner.tsx\");\n/* harmony import */ var components_apps_Messenger_SendMessage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! components/apps/Messenger/SendMessage */ \"(pages-dir-browser)/./components/apps/Messenger/SendMessage.tsx\");\n/* harmony import */ var components_apps_Messenger_StyledChatContainer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! components/apps/Messenger/StyledChatContainer */ \"(pages-dir-browser)/./components/apps/Messenger/StyledChatContainer.ts\");\n/* harmony import */ var components_apps_Messenger_StyledContacts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! components/apps/Messenger/StyledContacts */ \"(pages-dir-browser)/./components/apps/Messenger/StyledContacts.ts\");\n/* harmony import */ var components_apps_Messenger_StyledMessenger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! components/apps/Messenger/StyledMessenger */ \"(pages-dir-browser)/./components/apps/Messenger/StyledMessenger.ts\");\n/* harmony import */ var components_apps_Messenger_To__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! components/apps/Messenger/To */ \"(pages-dir-browser)/./components/apps/Messenger/To.tsx\");\n/* harmony import */ var components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! components/apps/Messenger/constants */ \"(pages-dir-browser)/./components/apps/Messenger/constants.ts\");\n/* harmony import */ var components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! components/apps/Messenger/functions */ \"(pages-dir-browser)/./components/apps/Messenger/functions.ts\");\n/* harmony import */ var components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! components/apps/Messenger/hooks */ \"(pages-dir-browser)/./components/apps/Messenger/hooks.ts\");\n/* harmony import */ var contexts_process__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! contexts/process */ \"(pages-dir-browser)/./contexts/process/index.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n/* harmony import */ var utils_functions__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! utils/functions */ \"(pages-dir-browser)/./utils/functions.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst NostrChat = ({ processId, publicKey, relayUrls, setSince, wellKnownNames })=>{\n    _s();\n    const { setSeenEventIds } = (0,components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_5__.useHistoryContext)();\n    const [selectedRecipientKey, setSelectedRecipientKey] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [hideReadMessages, setHideReadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const changeRecipient = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NostrChat.useCallback[changeRecipient]\": (recipientKey, currentEvents)=>setSelectedRecipientKey({\n                \"NostrChat.useCallback[changeRecipient]\": (currenRecipientKey)=>{\n                    if ((currenRecipientKey || recipientKey) && currentEvents) {\n                        setSeenEventIds({\n                            \"NostrChat.useCallback[changeRecipient]\": (currentSeenEventIds)=>[\n                                    ...new Set([\n                                        ...currentEvents.filter({\n                                            \"NostrChat.useCallback[changeRecipient]\": ({ pubkey })=>[\n                                                    recipientKey,\n                                                    currenRecipientKey\n                                                ].includes(pubkey)\n                                        }[\"NostrChat.useCallback[changeRecipient]\"]).map({\n                                            \"NostrChat.useCallback[changeRecipient]\": ({ id })=>id\n                                        }[\"NostrChat.useCallback[changeRecipient]\"]),\n                                        ...currentSeenEventIds\n                                    ])\n                                ]\n                        }[\"NostrChat.useCallback[changeRecipient]\"]);\n                    }\n                    return recipientKey;\n                }\n            }[\"NostrChat.useCallback[changeRecipient]\"])\n    }[\"NostrChat.useCallback[changeRecipient]\"], [\n        setSeenEventIds\n    ]);\n    const { contactKeys, events, lastEvents, unreadEvents } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useNostrContacts)(publicKey, wellKnownNames);\n    const setRecipientKey = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NostrChat.useCallback[setRecipientKey]\": (recipientKey)=>{\n            const hexKey = (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_15__.getPublicHexFromNostrAddress)(recipientKey);\n            if (hexKey) changeRecipient(hexKey);\n            return Boolean(hexKey);\n        }\n    }[\"NostrChat.useCallback[setRecipientKey]\"], [\n        changeRecipient\n    ]);\n    const { processes: { [processId]: process }, url: setUrl } = (0,contexts_process__WEBPACK_IMPORTED_MODULE_17__.useProcesses)();\n    const { url } = process || {};\n    (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useUnreadStatus)(processId, contactKeys.filter({\n        \"NostrChat.useUnreadStatus\": (contactKey)=>unreadEvents.includes(lastEvents[contactKey])\n    }[\"NostrChat.useUnreadStatus\"]).length);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrChat.useEffect\": ()=>{\n            if (!url || !url.startsWith(\"nostr:npub\") && !url.startsWith(\"nostr:nprofile\")) {\n                return;\n            }\n            const [, key] = url.split(\"nostr:\");\n            if (key) {\n                const hexKey = (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_15__.toHexKey)(key);\n                if (key !== hexKey) {\n                    setSelectedRecipientKey(hexKey);\n                    setUrl(processId, \"\");\n                }\n            }\n        }\n    }[\"NostrChat.useEffect\"], [\n        processId,\n        setUrl,\n        url\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrChat.useEffect\": ()=>{\n            if (unreadEvents && selectedRecipientKey) {\n                unreadEvents.filter({\n                    \"NostrChat.useEffect\": ({ pubkey })=>pubkey === selectedRecipientKey\n                }[\"NostrChat.useEffect\"]).forEach({\n                    \"NostrChat.useEffect\": ({ id })=>setSeenEventIds({\n                            \"NostrChat.useEffect\": (currentSeenEventIds)=>[\n                                    ...new Set([\n                                        id,\n                                        ...currentSeenEventIds\n                                    ])\n                                ]\n                        }[\"NostrChat.useEffect\"])\n                }[\"NostrChat.useEffect\"]);\n            }\n        }\n    }[\"NostrChat.useEffect\"], [\n        selectedRecipientKey,\n        setSeenEventIds,\n        unreadEvents\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledMessenger__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_ProfileBanner__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                goHome: ()=>changeRecipient(\"\", events),\n                hideReadMessages: hideReadMessages,\n                newChat: ()=>changeRecipient(components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_14__.UNKNOWN_PUBLIC_KEY),\n                publicKey: publicKey,\n                relayUrls: relayUrls,\n                selectedRecipientKey: selectedRecipientKey,\n                setHideReadMessages: setHideReadMessages\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                lineNumber: 139,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(motion_react__WEBPACK_IMPORTED_MODULE_20__.AnimatePresence, {\n                    initial: false,\n                    presenceAffectsLayout: false,\n                    children: selectedRecipientKey ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledChatContainer__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                        ...components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_14__.inRightOutLeft,\n                        children: [\n                            selectedRecipientKey === components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_14__.UNKNOWN_PUBLIC_KEY && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_To__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                                setRecipientKey: setRecipientKey\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                                lineNumber: 153,\n                                columnNumber: 17\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_ChatLog__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                recipientPublicKey: selectedRecipientKey\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                                lineNumber: 155,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_SendMessage__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                recipientPublicKey: selectedRecipientKey\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                                lineNumber: 156,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, \"chat\", true, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                        lineNumber: 151,\n                        columnNumber: 13\n                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_StyledContacts__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                        onContextMenu: utils_functions__WEBPACK_IMPORTED_MODULE_19__.haltEvent,\n                        ...components_apps_Messenger_constants__WEBPACK_IMPORTED_MODULE_14__.inLeftOutRight,\n                        children: [\n                            contactKeys.filter((contactKey)=>!hideReadMessages || unreadEvents.includes(lastEvents[contactKey])).map((contactKey)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_Contact__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    lastEvent: lastEvents[contactKey],\n                                    onClick: ()=>changeRecipient(contactKey, events),\n                                    pubkey: contactKey,\n                                    publicKey: publicKey,\n                                    unreadEvent: hideReadMessages || unreadEvents.includes(lastEvents[contactKey])\n                                }, contactKey, false, {\n                                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                                    lineNumber: 171,\n                                    columnNumber: 19\n                                }, undefined)),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_GetMoreMessages__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                setSince: setSince\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                                lineNumber: 183,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, \"contacts\", true, {\n                        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                        lineNumber: 159,\n                        columnNumber: 13\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                    lineNumber: 149,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                lineNumber: 148,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n        lineNumber: 138,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NostrChat, \"1WU4LYD9JcVtW7nRsYK5O+rm30o=\", false, function() {\n    return [\n        components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_5__.useHistoryContext,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useNostrContacts,\n        contexts_process__WEBPACK_IMPORTED_MODULE_17__.useProcesses,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useUnreadStatus\n    ];\n});\n_c = NostrChat;\nconst Messenger = ({ id })=>{\n    _s1();\n    const [since, setSince] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"Messenger.useState\": ()=>utils_constants__WEBPACK_IMPORTED_MODULE_18__.MILLISECONDS_IN_DAY\n    }[\"Messenger.useState\"]);\n    const timeSince = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"Messenger.useMemo[timeSince]\": ()=>Math.floor((Date.now() - since) / utils_constants__WEBPACK_IMPORTED_MODULE_18__.MILLISECONDS_IN_SECOND)\n    }[\"Messenger.useMemo[timeSince]\"], [\n        since\n    ]);\n    const [relayUrls, setRelayUrls] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const initStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const { names } = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useNip05)();\n    const publicKey = (0,components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.usePublicKey)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Messenger.useEffect\": ()=>{\n            if (initStarted.current || !publicKey) return;\n            initStarted.current = true;\n            (0,components_apps_Messenger_functions__WEBPACK_IMPORTED_MODULE_15__.getRelayUrls)().then(setRelayUrls);\n        }\n    }[\"Messenger.useEffect\"], [\n        publicKey\n    ]);\n    return publicKey && relayUrls ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_NostrContext__WEBPACK_IMPORTED_MODULE_7__.NostrProvider, {\n        relayUrls: relayUrls,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_HistoryContext__WEBPACK_IMPORTED_MODULE_5__.HistoryProvider, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_apps_Messenger_MessageContext__WEBPACK_IMPORTED_MODULE_6__.MessageProvider, {\n                publicKey: publicKey,\n                since: timeSince,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrChat, {\n                    processId: id,\n                    publicKey: publicKey,\n                    relayUrls: relayUrls,\n                    setSince: setSince,\n                    wellKnownNames: names\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                    lineNumber: 215,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n                lineNumber: 214,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n            lineNumber: 213,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\User\\\\Documents\\\\Sites\\\\Sites\\\\em desenvolvimento\\\\Portfolio2\\\\components\\\\apps\\\\Messenger\\\\index.tsx\",\n        lineNumber: 212,\n        columnNumber: 5\n    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: \" \"\n    }, void 0, false);\n};\n_s1(Messenger, \"NabCUJPv1GMauhp1EuTJM+vhbhk=\", false, function() {\n    return [\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.useNip05,\n        components_apps_Messenger_hooks__WEBPACK_IMPORTED_MODULE_16__.usePublicKey\n    ];\n});\n_c1 = Messenger;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(Messenger));\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"NostrChat\");\n$RefreshReg$(_c1, \"Messenger\");\n$RefreshReg$(_c2, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBRWpDO0FBQ1M7QUFDQTtBQUNnQjtBQUl0QjtBQUN5QjtBQUNKO0FBQ0g7QUFDSjtBQUNnQjtBQUNWO0FBQ0U7QUFDMUI7QUFLRDtBQUtBO0FBTUo7QUFFTztBQUM4QjtBQUNsQztBQVU1QyxNQUFNa0MsWUFBZ0MsQ0FBQyxFQUNyQ0MsU0FBUyxFQUNUQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxjQUFjLEVBQ2Y7O0lBQ0MsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBRzdCLDJGQUFpQkE7SUFDN0MsTUFBTSxDQUFDOEIsc0JBQXNCQyx3QkFBd0IsR0FBR3JDLCtDQUFRQSxDQUFTO0lBQ3pFLE1BQU0sQ0FBQ3NDLGtCQUFrQkMsb0JBQW9CLEdBQUd2QywrQ0FBUUEsQ0FBVTtJQUNsRSxNQUFNd0Msa0JBQWtCNUMsa0RBQVdBO2tEQUNqQyxDQUFDNkMsY0FBc0JDLGdCQUNyQkw7MERBQXdCLENBQUNNO29CQUN2QixJQUFJLENBQUNBLHNCQUFzQkYsWUFBVyxLQUFNQyxlQUFlO3dCQUN6RFA7c0VBQWdCLENBQUNTLHNCQUF3Qjt1Q0FDcEMsSUFBSUMsSUFBSTsyQ0FDTkgsY0FDQUksTUFBTTtzRkFBQyxDQUFDLEVBQUVDLE1BQU0sRUFBRSxHQUNqQjtvREFBQ047b0RBQWNFO2lEQUFtQixDQUFDSyxRQUFRLENBQUNEO3FGQUU3Q0UsR0FBRztzRkFBQyxDQUFDLEVBQUVDLEVBQUUsRUFBRSxHQUFLQTs7MkNBQ2hCTjtxQ0FDSjtpQ0FDRjs7b0JBQ0g7b0JBRUEsT0FBT0g7Z0JBQ1Q7O2lEQUNGO1FBQUNOO0tBQWdCO0lBRW5CLE1BQU0sRUFBRWdCLFdBQVcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksRUFBRSxHQUFHaEMsa0ZBQWdCQSxDQUN4RVMsV0FDQUc7SUFFRixNQUFNcUIsa0JBQWtCM0Qsa0RBQVdBO2tEQUNqQyxDQUFDNkM7WUFDQyxNQUFNZSxTQUFTdEMsa0dBQTRCQSxDQUFDdUI7WUFFNUMsSUFBSWUsUUFBUWhCLGdCQUFnQmdCO1lBRTVCLE9BQU9DLFFBQVFEO1FBQ2pCO2lEQUNBO1FBQUNoQjtLQUFnQjtJQUVuQixNQUFNLEVBQ0prQixXQUFXLEVBQUUsQ0FBQzVCLFVBQVUsRUFBRTZCLE9BQU8sRUFBRSxFQUNuQ0MsS0FBS0MsTUFBTSxFQUNaLEdBQUdwQywrREFBWUE7SUFDaEIsTUFBTSxFQUFFbUMsR0FBRyxFQUFFLEdBQUdELFdBQVcsQ0FBQztJQUU1Qm5DLGlGQUFlQSxDQUNiTSxXQUNBcUIsWUFBWUwsTUFBTTtxQ0FBQyxDQUFDZ0IsYUFDbEJSLGFBQWFOLFFBQVEsQ0FBQ0ssVUFBVSxDQUFDUyxXQUFXO29DQUM1Q0MsTUFBTTtJQUdWbEUsZ0RBQVNBOytCQUFDO1lBQ1IsSUFDRSxDQUFDK0QsT0FDQSxDQUFDQSxJQUFJSSxVQUFVLENBQUMsaUJBQWlCLENBQUNKLElBQUlJLFVBQVUsQ0FBQyxtQkFDbEQ7Z0JBQ0E7WUFDRjtZQUVBLE1BQU0sR0FBR0MsSUFBSSxHQUFHTCxJQUFJTSxLQUFLLENBQUM7WUFFMUIsSUFBSUQsS0FBSztnQkFDUCxNQUFNVCxTQUFTcEMsOEVBQVFBLENBQUM2QztnQkFFeEIsSUFBSUEsUUFBUVQsUUFBUTtvQkFDbEJuQix3QkFBd0JtQjtvQkFDeEJLLE9BQU8vQixXQUFXO2dCQUNwQjtZQUNGO1FBQ0Y7OEJBQUc7UUFBQ0E7UUFBVytCO1FBQVFEO0tBQUk7SUFFM0IvRCxnREFBU0E7K0JBQUM7WUFDUixJQUFJeUQsZ0JBQWdCbEIsc0JBQXNCO2dCQUN4Q2tCLGFBQ0dSLE1BQU07MkNBQUMsQ0FBQyxFQUFFQyxNQUFNLEVBQUUsR0FBS0EsV0FBV1g7MENBQ2xDK0IsT0FBTzsyQ0FBQyxDQUFDLEVBQUVqQixFQUFFLEVBQUUsR0FDZGY7bURBQWdCLENBQUNTLHNCQUF3Qjt1Q0FDcEMsSUFBSUMsSUFBSTt3Q0FBQ0s7MkNBQU9OO3FDQUFvQjtpQ0FDeEM7OztZQUVQO1FBQ0Y7OEJBQUc7UUFBQ1I7UUFBc0JEO1FBQWlCbUI7S0FBYTtJQUV4RCxxQkFDRSw4REFBQ3pDLGtGQUFlQTs7MEJBQ2QsOERBQUNKLCtFQUFhQTtnQkFDWjJELFFBQVEsSUFBTTVCLGdCQUFnQixJQUFJWTtnQkFDbENkLGtCQUFrQkE7Z0JBQ2xCK0IsU0FBUyxJQUFNN0IsZ0JBQWdCekIsb0ZBQWtCQTtnQkFDakRnQixXQUFXQTtnQkFDWEMsV0FBV0E7Z0JBQ1hJLHNCQUFzQkE7Z0JBQ3RCRyxxQkFBcUJBOzs7Ozs7MEJBRXZCLDhEQUFDK0I7MEJBQ0MsNEVBQUNyRSwwREFBZUE7b0JBQUNzRSxTQUFTO29CQUFPQyx1QkFBdUI7OEJBQ3JEcEMscUNBQ0MsOERBQUN6QixzRkFBbUJBO3dCQUFhLEdBQUdNLGdGQUFjOzs0QkFDL0NtQix5QkFBeUJyQixvRkFBa0JBLGtCQUMxQyw4REFBQ0QscUVBQUVBO2dDQUFDeUMsaUJBQWlCQTs7Ozs7OzBDQUV2Qiw4REFBQ3JELHlFQUFPQTtnQ0FBQ3VFLG9CQUFvQnJDOzs7Ozs7MENBQzdCLDhEQUFDMUIsNkVBQVdBO2dDQUFDK0Qsb0JBQW9CckM7Ozs7Ozs7dUJBTFY7Ozs7a0RBUXpCLDhEQUFDeEIsaUZBQWNBO3dCQUViOEQsZUFBZTlDLHVEQUFTQTt3QkFDdkIsR0FBR1osZ0ZBQWM7OzRCQUVqQm1DLFlBQ0VMLE1BQU0sQ0FDTCxDQUFDZ0IsYUFDQyxDQUFDeEIsb0JBQ0RnQixhQUFhTixRQUFRLENBQUNLLFVBQVUsQ0FBQ1MsV0FBVyxHQUUvQ2IsR0FBRyxDQUFDLENBQUNhLDJCQUNKLDhEQUFDM0QseUVBQU9BO29DQUVOd0UsV0FBV3RCLFVBQVUsQ0FBQ1MsV0FBVztvQ0FDakNjLFNBQVMsSUFBTXBDLGdCQUFnQnNCLFlBQVlWO29DQUMzQ0wsUUFBUWU7b0NBQ1IvQixXQUFXQTtvQ0FDWDhDLGFBQ0V2QyxvQkFDQWdCLGFBQWFOLFFBQVEsQ0FBQ0ssVUFBVSxDQUFDUyxXQUFXO21DQVB6Q0E7Ozs7OzBDQVdYLDhEQUFDMUQsaUZBQWVBO2dDQUFDNkIsVUFBVUE7Ozs7Ozs7dUJBdkJ2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJsQjtHQTlJTUo7O1FBT3dCdkIsdUZBQWlCQTtRQXVCYWdCLDhFQUFnQkE7UUFpQnRFRywyREFBWUE7UUFHaEJELDZFQUFlQTs7O0tBbERYSztBQWdKTixNQUFNaUQsWUFBdUMsQ0FBQyxFQUFFNUIsRUFBRSxFQUFFOztJQUNsRCxNQUFNLENBQUM2QixPQUFPOUMsU0FBUyxHQUFHakMsK0NBQVFBOzhCQUFDLElBQU0wQixpRUFBbUJBOztJQUM1RCxNQUFNc0QsWUFBWWxGLDhDQUFPQTt3Q0FDdkIsSUFBTW1GLEtBQUtDLEtBQUssQ0FBQyxDQUFDQyxLQUFLQyxHQUFHLEtBQUtMLEtBQUksSUFBS3BELG9FQUFzQkE7dUNBQzlEO1FBQUNvRDtLQUFNO0lBRVQsTUFBTSxDQUFDL0MsV0FBV3FELGFBQWEsR0FBR3JGLCtDQUFRQTtJQUMxQyxNQUFNc0YsY0FBY3ZGLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU0sRUFBRXdGLEtBQUssRUFBRSxHQUFHbEUsMEVBQVFBO0lBQzFCLE1BQU1VLFlBQVlSLDhFQUFZQTtJQUU5QjFCLGdEQUFTQTsrQkFBQztZQUNSLElBQUl5RixZQUFZRSxPQUFPLElBQUksQ0FBQ3pELFdBQVc7WUFFdkN1RCxZQUFZRSxPQUFPLEdBQUc7WUFFdEJyRSxrRkFBWUEsR0FBR3NFLElBQUksQ0FBQ0o7UUFDdEI7OEJBQUc7UUFBQ3REO0tBQVU7SUFFZCxPQUFPQSxhQUFhQywwQkFDbEIsOERBQUN4QixpRkFBYUE7UUFBQ3dCLFdBQVdBO2tCQUN4Qiw0RUFBQzNCLHFGQUFlQTtzQkFDZCw0RUFBQ0UscUZBQWVBO2dCQUFDd0IsV0FBV0E7Z0JBQVdnRCxPQUFPQzswQkFDNUMsNEVBQUNuRDtvQkFDQ0MsV0FBV29CO29CQUNYbkIsV0FBV0E7b0JBQ1hDLFdBQVdBO29CQUNYQyxVQUFVQTtvQkFDVkMsZ0JBQWdCcUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQU14QjtrQkFBRTs7QUFFTjtJQXBDTVQ7O1FBUWN6RCxzRUFBUUE7UUFDUkUsMEVBQVlBOzs7TUFUMUJ1RDtBQXNDTixvRkFBZW5GLDJDQUFJQSxDQUFDbUYsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxjb21wb25lbnRzXFxhcHBzXFxNZXNzZW5nZXJcXGluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHR5cGUgRXZlbnQgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcclxuaW1wb3J0IHsgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSBcIm1vdGlvbi9yZWFjdFwiO1xyXG5pbXBvcnQgQ2hhdExvZyBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9DaGF0TG9nXCI7XHJcbmltcG9ydCBDb250YWN0IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL0NvbnRhY3RcIjtcclxuaW1wb3J0IEdldE1vcmVNZXNzYWdlcyBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9HZXRNb3JlTWVzc2FnZXNcIjtcclxuaW1wb3J0IHtcclxuICBIaXN0b3J5UHJvdmlkZXIsXHJcbiAgdXNlSGlzdG9yeUNvbnRleHQsXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvSGlzdG9yeUNvbnRleHRcIjtcclxuaW1wb3J0IHsgTWVzc2FnZVByb3ZpZGVyIH0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvTWVzc2FnZUNvbnRleHRcIjtcclxuaW1wb3J0IHsgTm9zdHJQcm92aWRlciB9IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL05vc3RyQ29udGV4dFwiO1xyXG5pbXBvcnQgUHJvZmlsZUJhbm5lciBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9Qcm9maWxlQmFubmVyXCI7XHJcbmltcG9ydCBTZW5kTWVzc2FnZSBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9TZW5kTWVzc2FnZVwiO1xyXG5pbXBvcnQgU3R5bGVkQ2hhdENvbnRhaW5lciBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9TdHlsZWRDaGF0Q29udGFpbmVyXCI7XHJcbmltcG9ydCBTdHlsZWRDb250YWN0cyBmcm9tIFwiY29tcG9uZW50cy9hcHBzL01lc3Nlbmdlci9TdHlsZWRDb250YWN0c1wiO1xyXG5pbXBvcnQgU3R5bGVkTWVzc2VuZ2VyIGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL1N0eWxlZE1lc3NlbmdlclwiO1xyXG5pbXBvcnQgVG8gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvVG9cIjtcclxuaW1wb3J0IHtcclxuICBVTktOT1dOX1BVQkxJQ19LRVksXHJcbiAgaW5MZWZ0T3V0UmlnaHQsXHJcbiAgaW5SaWdodE91dExlZnQsXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7XHJcbiAgZ2V0UHVibGljSGV4RnJvbU5vc3RyQWRkcmVzcyxcclxuICBnZXRSZWxheVVybHMsXHJcbiAgdG9IZXhLZXksXHJcbn0gZnJvbSBcImNvbXBvbmVudHMvYXBwcy9NZXNzZW5nZXIvZnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7XHJcbiAgdXNlTmlwMDUsXHJcbiAgdXNlTm9zdHJDb250YWN0cyxcclxuICB1c2VQdWJsaWNLZXksXHJcbiAgdXNlVW5yZWFkU3RhdHVzLFxyXG59IGZyb20gXCJjb21wb25lbnRzL2FwcHMvTWVzc2VuZ2VyL2hvb2tzXCI7XHJcbmltcG9ydCB7IHR5cGUgQ29tcG9uZW50UHJvY2Vzc1Byb3BzIH0gZnJvbSBcImNvbXBvbmVudHMvc3lzdGVtL0FwcHMvUmVuZGVyQ29tcG9uZW50XCI7XHJcbmltcG9ydCB7IHVzZVByb2Nlc3NlcyB9IGZyb20gXCJjb250ZXh0cy9wcm9jZXNzXCI7XHJcbmltcG9ydCB7IE1JTExJU0VDT05EU19JTl9EQVksIE1JTExJU0VDT05EU19JTl9TRUNPTkQgfSBmcm9tIFwidXRpbHMvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IGhhbHRFdmVudCB9IGZyb20gXCJ1dGlscy9mdW5jdGlvbnNcIjtcclxuXHJcbnR5cGUgTm9zdHJDaGF0UHJvcHMgPSB7XHJcbiAgcHJvY2Vzc0lkOiBzdHJpbmc7XHJcbiAgcHVibGljS2V5OiBzdHJpbmc7XHJcbiAgcmVsYXlVcmxzOiBzdHJpbmdbXTtcclxuICBzZXRTaW5jZTogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248bnVtYmVyPj47XHJcbiAgd2VsbEtub3duTmFtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn07XHJcblxyXG5jb25zdCBOb3N0ckNoYXQ6IEZDPE5vc3RyQ2hhdFByb3BzPiA9ICh7XHJcbiAgcHJvY2Vzc0lkLFxyXG4gIHB1YmxpY0tleSxcclxuICByZWxheVVybHMsXHJcbiAgc2V0U2luY2UsXHJcbiAgd2VsbEtub3duTmFtZXMsXHJcbn0pID0+IHtcclxuICBjb25zdCB7IHNldFNlZW5FdmVudElkcyB9ID0gdXNlSGlzdG9yeUNvbnRleHQoKTtcclxuICBjb25zdCBbc2VsZWN0ZWRSZWNpcGllbnRLZXksIHNldFNlbGVjdGVkUmVjaXBpZW50S2V5XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbiAgY29uc3QgW2hpZGVSZWFkTWVzc2FnZXMsIHNldEhpZGVSZWFkTWVzc2FnZXNdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGNoYW5nZVJlY2lwaWVudCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHJlY2lwaWVudEtleTogc3RyaW5nLCBjdXJyZW50RXZlbnRzPzogRXZlbnRbXSkgPT5cclxuICAgICAgc2V0U2VsZWN0ZWRSZWNpcGllbnRLZXkoKGN1cnJlblJlY2lwaWVudEtleTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKChjdXJyZW5SZWNpcGllbnRLZXkgfHwgcmVjaXBpZW50S2V5KSAmJiBjdXJyZW50RXZlbnRzKSB7XHJcbiAgICAgICAgICBzZXRTZWVuRXZlbnRJZHMoKGN1cnJlbnRTZWVuRXZlbnRJZHMpID0+IFtcclxuICAgICAgICAgICAgLi4ubmV3IFNldChbXHJcbiAgICAgICAgICAgICAgLi4uY3VycmVudEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBwdWJrZXkgfSkgPT5cclxuICAgICAgICAgICAgICAgICAgW3JlY2lwaWVudEtleSwgY3VycmVuUmVjaXBpZW50S2V5XS5pbmNsdWRlcyhwdWJrZXkpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IGlkIH0pID0+IGlkKSxcclxuICAgICAgICAgICAgICAuLi5jdXJyZW50U2VlbkV2ZW50SWRzLFxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlY2lwaWVudEtleTtcclxuICAgICAgfSksXHJcbiAgICBbc2V0U2VlbkV2ZW50SWRzXVxyXG4gICk7XHJcbiAgY29uc3QgeyBjb250YWN0S2V5cywgZXZlbnRzLCBsYXN0RXZlbnRzLCB1bnJlYWRFdmVudHMgfSA9IHVzZU5vc3RyQ29udGFjdHMoXHJcbiAgICBwdWJsaWNLZXksXHJcbiAgICB3ZWxsS25vd25OYW1lc1xyXG4gICk7XHJcbiAgY29uc3Qgc2V0UmVjaXBpZW50S2V5ID0gdXNlQ2FsbGJhY2soXHJcbiAgICAocmVjaXBpZW50S2V5OiBzdHJpbmcpOiBib29sZWFuID0+IHtcclxuICAgICAgY29uc3QgaGV4S2V5ID0gZ2V0UHVibGljSGV4RnJvbU5vc3RyQWRkcmVzcyhyZWNpcGllbnRLZXkpO1xyXG5cclxuICAgICAgaWYgKGhleEtleSkgY2hhbmdlUmVjaXBpZW50KGhleEtleSk7XHJcblxyXG4gICAgICByZXR1cm4gQm9vbGVhbihoZXhLZXkpO1xyXG4gICAgfSxcclxuICAgIFtjaGFuZ2VSZWNpcGllbnRdXHJcbiAgKTtcclxuICBjb25zdCB7XHJcbiAgICBwcm9jZXNzZXM6IHsgW3Byb2Nlc3NJZF06IHByb2Nlc3MgfSxcclxuICAgIHVybDogc2V0VXJsLFxyXG4gIH0gPSB1c2VQcm9jZXNzZXMoKTtcclxuICBjb25zdCB7IHVybCB9ID0gcHJvY2VzcyB8fCB7fTtcclxuXHJcbiAgdXNlVW5yZWFkU3RhdHVzKFxyXG4gICAgcHJvY2Vzc0lkLFxyXG4gICAgY29udGFjdEtleXMuZmlsdGVyKChjb250YWN0S2V5KSA9PlxyXG4gICAgICB1bnJlYWRFdmVudHMuaW5jbHVkZXMobGFzdEV2ZW50c1tjb250YWN0S2V5XSlcclxuICAgICkubGVuZ3RoXHJcbiAgKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChcclxuICAgICAgIXVybCB8fFxyXG4gICAgICAoIXVybC5zdGFydHNXaXRoKFwibm9zdHI6bnB1YlwiKSAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJub3N0cjpucHJvZmlsZVwiKSlcclxuICAgICkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgWywga2V5XSA9IHVybC5zcGxpdChcIm5vc3RyOlwiKTtcclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgIGNvbnN0IGhleEtleSA9IHRvSGV4S2V5KGtleSk7XHJcblxyXG4gICAgICBpZiAoa2V5ICE9PSBoZXhLZXkpIHtcclxuICAgICAgICBzZXRTZWxlY3RlZFJlY2lwaWVudEtleShoZXhLZXkpO1xyXG4gICAgICAgIHNldFVybChwcm9jZXNzSWQsIFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW3Byb2Nlc3NJZCwgc2V0VXJsLCB1cmxdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh1bnJlYWRFdmVudHMgJiYgc2VsZWN0ZWRSZWNpcGllbnRLZXkpIHtcclxuICAgICAgdW5yZWFkRXZlbnRzXHJcbiAgICAgICAgLmZpbHRlcigoeyBwdWJrZXkgfSkgPT4gcHVia2V5ID09PSBzZWxlY3RlZFJlY2lwaWVudEtleSlcclxuICAgICAgICAuZm9yRWFjaCgoeyBpZCB9KSA9PlxyXG4gICAgICAgICAgc2V0U2VlbkV2ZW50SWRzKChjdXJyZW50U2VlbkV2ZW50SWRzKSA9PiBbXHJcbiAgICAgICAgICAgIC4uLm5ldyBTZXQoW2lkLCAuLi5jdXJyZW50U2VlbkV2ZW50SWRzXSksXHJcbiAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkUmVjaXBpZW50S2V5LCBzZXRTZWVuRXZlbnRJZHMsIHVucmVhZEV2ZW50c10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZE1lc3Nlbmdlcj5cclxuICAgICAgPFByb2ZpbGVCYW5uZXJcclxuICAgICAgICBnb0hvbWU9eygpID0+IGNoYW5nZVJlY2lwaWVudChcIlwiLCBldmVudHMpfVxyXG4gICAgICAgIGhpZGVSZWFkTWVzc2FnZXM9e2hpZGVSZWFkTWVzc2FnZXN9XHJcbiAgICAgICAgbmV3Q2hhdD17KCkgPT4gY2hhbmdlUmVjaXBpZW50KFVOS05PV05fUFVCTElDX0tFWSl9XHJcbiAgICAgICAgcHVibGljS2V5PXtwdWJsaWNLZXl9XHJcbiAgICAgICAgcmVsYXlVcmxzPXtyZWxheVVybHN9XHJcbiAgICAgICAgc2VsZWN0ZWRSZWNpcGllbnRLZXk9e3NlbGVjdGVkUmVjaXBpZW50S2V5fVxyXG4gICAgICAgIHNldEhpZGVSZWFkTWVzc2FnZXM9e3NldEhpZGVSZWFkTWVzc2FnZXN9XHJcbiAgICAgIC8+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPEFuaW1hdGVQcmVzZW5jZSBpbml0aWFsPXtmYWxzZX0gcHJlc2VuY2VBZmZlY3RzTGF5b3V0PXtmYWxzZX0+XHJcbiAgICAgICAgICB7c2VsZWN0ZWRSZWNpcGllbnRLZXkgPyAoXHJcbiAgICAgICAgICAgIDxTdHlsZWRDaGF0Q29udGFpbmVyIGtleT1cImNoYXRcIiB7Li4uaW5SaWdodE91dExlZnR9PlxyXG4gICAgICAgICAgICAgIHtzZWxlY3RlZFJlY2lwaWVudEtleSA9PT0gVU5LTk9XTl9QVUJMSUNfS0VZICYmIChcclxuICAgICAgICAgICAgICAgIDxUbyBzZXRSZWNpcGllbnRLZXk9e3NldFJlY2lwaWVudEtleX0gLz5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIDxDaGF0TG9nIHJlY2lwaWVudFB1YmxpY0tleT17c2VsZWN0ZWRSZWNpcGllbnRLZXl9IC8+XHJcbiAgICAgICAgICAgICAgPFNlbmRNZXNzYWdlIHJlY2lwaWVudFB1YmxpY0tleT17c2VsZWN0ZWRSZWNpcGllbnRLZXl9IC8+XHJcbiAgICAgICAgICAgIDwvU3R5bGVkQ2hhdENvbnRhaW5lcj5cclxuICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgIDxTdHlsZWRDb250YWN0c1xyXG4gICAgICAgICAgICAgIGtleT1cImNvbnRhY3RzXCJcclxuICAgICAgICAgICAgICBvbkNvbnRleHRNZW51PXtoYWx0RXZlbnR9XHJcbiAgICAgICAgICAgICAgey4uLmluTGVmdE91dFJpZ2h0fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAge2NvbnRhY3RLZXlzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgICAoY29udGFjdEtleSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAhaGlkZVJlYWRNZXNzYWdlcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHVucmVhZEV2ZW50cy5pbmNsdWRlcyhsYXN0RXZlbnRzW2NvbnRhY3RLZXldKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoY29udGFjdEtleSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8Q29udGFjdFxyXG4gICAgICAgICAgICAgICAgICAgIGtleT17Y29udGFjdEtleX1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnQ9e2xhc3RFdmVudHNbY29udGFjdEtleV19XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gY2hhbmdlUmVjaXBpZW50KGNvbnRhY3RLZXksIGV2ZW50cyl9XHJcbiAgICAgICAgICAgICAgICAgICAgcHVia2V5PXtjb250YWN0S2V5fVxyXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleT17cHVibGljS2V5fVxyXG4gICAgICAgICAgICAgICAgICAgIHVucmVhZEV2ZW50PXtcclxuICAgICAgICAgICAgICAgICAgICAgIGhpZGVSZWFkTWVzc2FnZXMgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIHVucmVhZEV2ZW50cy5pbmNsdWRlcyhsYXN0RXZlbnRzW2NvbnRhY3RLZXldKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgIDxHZXRNb3JlTWVzc2FnZXMgc2V0U2luY2U9e3NldFNpbmNlfSAvPlxyXG4gICAgICAgICAgICA8L1N0eWxlZENvbnRhY3RzPlxyXG4gICAgICAgICAgKX1cclxuICAgICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L1N0eWxlZE1lc3Nlbmdlcj5cclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgTWVzc2VuZ2VyOiBGQzxDb21wb25lbnRQcm9jZXNzUHJvcHM+ID0gKHsgaWQgfSkgPT4ge1xyXG4gIGNvbnN0IFtzaW5jZSwgc2V0U2luY2VdID0gdXNlU3RhdGUoKCkgPT4gTUlMTElTRUNPTkRTX0lOX0RBWSk7XHJcbiAgY29uc3QgdGltZVNpbmNlID0gdXNlTWVtbyhcclxuICAgICgpID0+IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBzaW5jZSkgLyBNSUxMSVNFQ09ORFNfSU5fU0VDT05EKSxcclxuICAgIFtzaW5jZV1cclxuICApO1xyXG4gIGNvbnN0IFtyZWxheVVybHMsIHNldFJlbGF5VXJsc10gPSB1c2VTdGF0ZTxzdHJpbmdbXSB8IHVuZGVmaW5lZD4oKTtcclxuICBjb25zdCBpbml0U3RhcnRlZCA9IHVzZVJlZihmYWxzZSk7XHJcbiAgY29uc3QgeyBuYW1lcyB9ID0gdXNlTmlwMDUoKTtcclxuICBjb25zdCBwdWJsaWNLZXkgPSB1c2VQdWJsaWNLZXkoKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpbml0U3RhcnRlZC5jdXJyZW50IHx8ICFwdWJsaWNLZXkpIHJldHVybjtcclxuXHJcbiAgICBpbml0U3RhcnRlZC5jdXJyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICBnZXRSZWxheVVybHMoKS50aGVuKHNldFJlbGF5VXJscyk7XHJcbiAgfSwgW3B1YmxpY0tleV0pO1xyXG5cclxuICByZXR1cm4gcHVibGljS2V5ICYmIHJlbGF5VXJscyA/IChcclxuICAgIDxOb3N0clByb3ZpZGVyIHJlbGF5VXJscz17cmVsYXlVcmxzfT5cclxuICAgICAgPEhpc3RvcnlQcm92aWRlcj5cclxuICAgICAgICA8TWVzc2FnZVByb3ZpZGVyIHB1YmxpY0tleT17cHVibGljS2V5fSBzaW5jZT17dGltZVNpbmNlfT5cclxuICAgICAgICAgIDxOb3N0ckNoYXRcclxuICAgICAgICAgICAgcHJvY2Vzc0lkPXtpZH1cclxuICAgICAgICAgICAgcHVibGljS2V5PXtwdWJsaWNLZXl9XHJcbiAgICAgICAgICAgIHJlbGF5VXJscz17cmVsYXlVcmxzfVxyXG4gICAgICAgICAgICBzZXRTaW5jZT17c2V0U2luY2V9XHJcbiAgICAgICAgICAgIHdlbGxLbm93bk5hbWVzPXtuYW1lc31cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9NZXNzYWdlUHJvdmlkZXI+XHJcbiAgICAgIDwvSGlzdG9yeVByb3ZpZGVyPlxyXG4gICAgPC9Ob3N0clByb3ZpZGVyPlxyXG4gICkgOiAoXHJcbiAgICA8PiA8Lz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWVtbyhNZXNzZW5nZXIpO1xyXG4iXSwibmFtZXMiOlsibWVtbyIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiQW5pbWF0ZVByZXNlbmNlIiwiQ2hhdExvZyIsIkNvbnRhY3QiLCJHZXRNb3JlTWVzc2FnZXMiLCJIaXN0b3J5UHJvdmlkZXIiLCJ1c2VIaXN0b3J5Q29udGV4dCIsIk1lc3NhZ2VQcm92aWRlciIsIk5vc3RyUHJvdmlkZXIiLCJQcm9maWxlQmFubmVyIiwiU2VuZE1lc3NhZ2UiLCJTdHlsZWRDaGF0Q29udGFpbmVyIiwiU3R5bGVkQ29udGFjdHMiLCJTdHlsZWRNZXNzZW5nZXIiLCJUbyIsIlVOS05PV05fUFVCTElDX0tFWSIsImluTGVmdE91dFJpZ2h0IiwiaW5SaWdodE91dExlZnQiLCJnZXRQdWJsaWNIZXhGcm9tTm9zdHJBZGRyZXNzIiwiZ2V0UmVsYXlVcmxzIiwidG9IZXhLZXkiLCJ1c2VOaXAwNSIsInVzZU5vc3RyQ29udGFjdHMiLCJ1c2VQdWJsaWNLZXkiLCJ1c2VVbnJlYWRTdGF0dXMiLCJ1c2VQcm9jZXNzZXMiLCJNSUxMSVNFQ09ORFNfSU5fREFZIiwiTUlMTElTRUNPTkRTX0lOX1NFQ09ORCIsImhhbHRFdmVudCIsIk5vc3RyQ2hhdCIsInByb2Nlc3NJZCIsInB1YmxpY0tleSIsInJlbGF5VXJscyIsInNldFNpbmNlIiwid2VsbEtub3duTmFtZXMiLCJzZXRTZWVuRXZlbnRJZHMiLCJzZWxlY3RlZFJlY2lwaWVudEtleSIsInNldFNlbGVjdGVkUmVjaXBpZW50S2V5IiwiaGlkZVJlYWRNZXNzYWdlcyIsInNldEhpZGVSZWFkTWVzc2FnZXMiLCJjaGFuZ2VSZWNpcGllbnQiLCJyZWNpcGllbnRLZXkiLCJjdXJyZW50RXZlbnRzIiwiY3VycmVuUmVjaXBpZW50S2V5IiwiY3VycmVudFNlZW5FdmVudElkcyIsIlNldCIsImZpbHRlciIsInB1YmtleSIsImluY2x1ZGVzIiwibWFwIiwiaWQiLCJjb250YWN0S2V5cyIsImV2ZW50cyIsImxhc3RFdmVudHMiLCJ1bnJlYWRFdmVudHMiLCJzZXRSZWNpcGllbnRLZXkiLCJoZXhLZXkiLCJCb29sZWFuIiwicHJvY2Vzc2VzIiwicHJvY2VzcyIsInVybCIsInNldFVybCIsImNvbnRhY3RLZXkiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwia2V5Iiwic3BsaXQiLCJmb3JFYWNoIiwiZ29Ib21lIiwibmV3Q2hhdCIsImRpdiIsImluaXRpYWwiLCJwcmVzZW5jZUFmZmVjdHNMYXlvdXQiLCJyZWNpcGllbnRQdWJsaWNLZXkiLCJvbkNvbnRleHRNZW51IiwibGFzdEV2ZW50Iiwib25DbGljayIsInVucmVhZEV2ZW50IiwiTWVzc2VuZ2VyIiwic2luY2UiLCJ0aW1lU2luY2UiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93Iiwic2V0UmVsYXlVcmxzIiwiaW5pdFN0YXJ0ZWQiLCJuYW1lcyIsImN1cnJlbnQiLCJ0aGVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/apps/Messenger/index.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./hooks/useIsVisible.ts":
/*!*******************************!*\
  !*** ./hooks/useIsVisible.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useIsVisible: () => (/* binding */ useIsVisible)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n\n\nconst useIsVisible = (elementRef, parentSelector, alwaysVisible = false)=>{\n    const watching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [isVisible, setIsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(alwaysVisible);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useIsVisible.useEffect\": ()=>{\n            if (alwaysVisible || !elementRef.current || watching.current) return;\n            watching.current = true;\n            new IntersectionObserver({\n                \"useIsVisible.useEffect\": (entries)=>entries.forEach({\n                        \"useIsVisible.useEffect\": ({ isIntersecting })=>setIsVisible(isIntersecting)\n                    }[\"useIsVisible.useEffect\"])\n            }[\"useIsVisible.useEffect\"], {\n                root: typeof parentSelector === \"object\" && parentSelector.current || typeof parentSelector === \"string\" && elementRef.current.closest(parentSelector) || elementRef.current.parentElement,\n                ...utils_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_INTERSECTION_OPTIONS\n            }).observe(elementRef.current);\n        }\n    }[\"useIsVisible.useEffect\"], [\n        alwaysVisible,\n        elementRef,\n        parentSelector\n    ]);\n    return isVisible;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2hvb2tzL3VzZUlzVmlzaWJsZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBQ1c7QUFFeEQsTUFBTUksZUFBZSxDQUMxQkMsWUFDQUMsZ0JBQ0FDLGdCQUFnQixLQUFLO0lBRXJCLE1BQU1DLFdBQVdSLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU0sQ0FBQ1MsV0FBV0MsYUFBYSxHQUFHVCwrQ0FBUUEsQ0FBQ007SUFFM0NMLGdEQUFTQTtrQ0FBQztZQUNSLElBQUlLLGlCQUFpQixDQUFDRixXQUFXTSxPQUFPLElBQUlILFNBQVNHLE9BQU8sRUFBRTtZQUU5REgsU0FBU0csT0FBTyxHQUFHO1lBRW5CLElBQUlDOzBDQUNGLENBQUNDLFVBQ0NBLFFBQVFDLE9BQU87a0RBQUMsQ0FBQyxFQUFFQyxjQUFjLEVBQUUsR0FBS0wsYUFBYUs7O3lDQUN2RDtnQkFDRUMsTUFDRSxPQUFRVixtQkFBbUIsWUFBWUEsZUFBZUssT0FBTyxJQUM1RCxPQUFPTCxtQkFBbUIsWUFDekJELFdBQVdNLE9BQU8sQ0FBQ00sT0FBTyxDQUFDWCxtQkFDN0JELFdBQVdNLE9BQU8sQ0FBQ08sYUFBYTtnQkFDbEMsR0FBR2YseUVBQTRCO1lBQ2pDLEdBQ0FnQixPQUFPLENBQUNkLFdBQVdNLE9BQU87UUFDOUI7aUNBQUc7UUFBQ0o7UUFBZUY7UUFBWUM7S0FBZTtJQUU5QyxPQUFPRztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcaG9va3NcXHVzZUlzVmlzaWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgREVGQVVMVF9JTlRFUlNFQ1RJT05fT1BUSU9OUyB9IGZyb20gXCJ1dGlscy9jb25zdGFudHNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VJc1Zpc2libGUgPSAoXHJcbiAgZWxlbWVudFJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxFbGVtZW50IHwgbnVsbD4sXHJcbiAgcGFyZW50U2VsZWN0b3I/OiBzdHJpbmcgfCBSZWFjdC5SZWZPYmplY3Q8SFRNTEVsZW1lbnQgfCBudWxsPixcclxuICBhbHdheXNWaXNpYmxlID0gZmFsc2VcclxuKTogYm9vbGVhbiA9PiB7XHJcbiAgY29uc3Qgd2F0Y2hpbmcgPSB1c2VSZWYoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1Zpc2libGUsIHNldElzVmlzaWJsZV0gPSB1c2VTdGF0ZShhbHdheXNWaXNpYmxlKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChhbHdheXNWaXNpYmxlIHx8ICFlbGVtZW50UmVmLmN1cnJlbnQgfHwgd2F0Y2hpbmcuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIHdhdGNoaW5nLmN1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcclxuICAgICAgKGVudHJpZXMpID0+XHJcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKCh7IGlzSW50ZXJzZWN0aW5nIH0pID0+IHNldElzVmlzaWJsZShpc0ludGVyc2VjdGluZykpLFxyXG4gICAgICB7XHJcbiAgICAgICAgcm9vdDpcclxuICAgICAgICAgICh0eXBlb2YgcGFyZW50U2VsZWN0b3IgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50U2VsZWN0b3IuY3VycmVudCkgfHxcclxuICAgICAgICAgICh0eXBlb2YgcGFyZW50U2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LmNsb3Nlc3QocGFyZW50U2VsZWN0b3IpKSB8fFxyXG4gICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnBhcmVudEVsZW1lbnQsXHJcbiAgICAgICAgLi4uREVGQVVMVF9JTlRFUlNFQ1RJT05fT1BUSU9OUyxcclxuICAgICAgfVxyXG4gICAgKS5vYnNlcnZlKGVsZW1lbnRSZWYuY3VycmVudCk7XHJcbiAgfSwgW2Fsd2F5c1Zpc2libGUsIGVsZW1lbnRSZWYsIHBhcmVudFNlbGVjdG9yXSk7XHJcblxyXG4gIHJldHVybiBpc1Zpc2libGU7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkRFRkFVTFRfSU5URVJTRUNUSU9OX09QVElPTlMiLCJ1c2VJc1Zpc2libGUiLCJlbGVtZW50UmVmIiwicGFyZW50U2VsZWN0b3IiLCJhbHdheXNWaXNpYmxlIiwid2F0Y2hpbmciLCJpc1Zpc2libGUiLCJzZXRJc1Zpc2libGUiLCJjdXJyZW50IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImlzSW50ZXJzZWN0aW5nIiwicm9vdCIsImNsb3Nlc3QiLCJwYXJlbnRFbGVtZW50Iiwib2JzZXJ2ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./hooks/useIsVisible.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_assert.js":
/*!****************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_assert.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxlc21cXF9hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2ggbXVzdCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_poly1305.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_poly1305.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poly1305: () => (/* binding */ poly1305),\n/* harmony export */   wrapConstructorWithKey: () => (/* binding */ wrapConstructorWithKey)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_assert.js\");\n\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(key);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].exists(this);\n        const { buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].output(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\nconst poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX3BvbHkxMzA1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0Q7QUFDaEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTztBQUNyQixRQUFRLHNEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLGdCQUFnQixtQkFBbUI7QUFDbkMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx5REFBYTtBQUNyQjtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFEQUFxRCxrREFBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxlc21cXF9wb2x5MTMwNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0J5dGVzLCBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gUG9seTEzMDUgaXMgYSBmYXN0IGFuZCBwYXJhbGxlbCBzZWNyZXQta2V5IG1lc3NhZ2UtYXV0aGVudGljYXRpb24gY29kZS5cbi8vIGh0dHBzOi8vY3IueXAudG8vbWFjLmh0bWwsIGh0dHBzOi8vY3IueXAudG8vbWFjL3BvbHkxMzA1LTIwMDUwMzI5LnBkZlxuLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM4NDM5XG4vLyBCYXNlZCBvbiBQdWJsaWMgRG9tYWluIHBvbHkxMzA1LWRvbm5hIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuY29uc3QgdTh0bzE2ID0gKGEsIGkpID0+IChhW2krK10gJiAweGZmKSB8ICgoYVtpKytdICYgMHhmZikgPDwgOCk7XG5jbGFzcyBQb2x5MTMwNSB7XG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSAxNjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAxNjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAga2V5ID0gdG9CeXRlcyhrZXkpO1xuICAgICAgICBlbnN1cmVCeXRlcyhrZXksIDMyKTtcbiAgICAgICAgY29uc3QgdDAgPSB1OHRvMTYoa2V5LCAwKTtcbiAgICAgICAgY29uc3QgdDEgPSB1OHRvMTYoa2V5LCAyKTtcbiAgICAgICAgY29uc3QgdDIgPSB1OHRvMTYoa2V5LCA0KTtcbiAgICAgICAgY29uc3QgdDMgPSB1OHRvMTYoa2V5LCA2KTtcbiAgICAgICAgY29uc3QgdDQgPSB1OHRvMTYoa2V5LCA4KTtcbiAgICAgICAgY29uc3QgdDUgPSB1OHRvMTYoa2V5LCAxMCk7XG4gICAgICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGtleSwgMTIpO1xuICAgICAgICBjb25zdCB0NyA9IHU4dG8xNihrZXksIDE0KTtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hL2Jsb2IvZTZhZDZlMDkxZDMwZDdmNGVjMmQ0Zjk3OGJlMWZjZmNiY2U3Mjc4MS9wb2x5MTMwNS1kb25uYS0xNi5oI0w0N1xuICAgICAgICB0aGlzLnJbMF0gPSB0MCAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzJdID0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWYwMztcbiAgICAgICAgdGhpcy5yWzNdID0gKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbNF0gPSAoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICAgICAgICB0aGlzLnJbNV0gPSAodDQgPj4+IDEpICYgMHgxZmZlO1xuICAgICAgICB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZjgxO1xuICAgICAgICB0aGlzLnJbOF0gPSAoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls5XSA9ICh0NyA+Pj4gNSkgJiAweDAwN2Y7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgdGhpcy5wYWRbaV0gPSB1OHRvMTYoa2V5LCAxNiArIDIgKiBpKTtcbiAgICB9XG4gICAgcHJvY2VzcyhkYXRhLCBvZmZzZXQsIGlzTGFzdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGhpYml0ID0gaXNMYXN0ID8gMCA6IDEgPDwgMTE7XG4gICAgICAgIGNvbnN0IHsgaCwgciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcjAgPSByWzBdO1xuICAgICAgICBjb25zdCByMSA9IHJbMV07XG4gICAgICAgIGNvbnN0IHIyID0gclsyXTtcbiAgICAgICAgY29uc3QgcjMgPSByWzNdO1xuICAgICAgICBjb25zdCByNCA9IHJbNF07XG4gICAgICAgIGNvbnN0IHI1ID0gcls1XTtcbiAgICAgICAgY29uc3QgcjYgPSByWzZdO1xuICAgICAgICBjb25zdCByNyA9IHJbN107XG4gICAgICAgIGNvbnN0IHI4ID0gcls4XTtcbiAgICAgICAgY29uc3QgcjkgPSByWzldO1xuICAgICAgICBjb25zdCB0MCA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAwKTtcbiAgICAgICAgY29uc3QgdDEgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMik7XG4gICAgICAgIGNvbnN0IHQyID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDQpO1xuICAgICAgICBjb25zdCB0MyA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgICAgY29uc3QgdDQgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgOCk7XG4gICAgICAgIGNvbnN0IHQ1ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEwKTtcbiAgICAgICAgY29uc3QgdDYgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTIpO1xuICAgICAgICBjb25zdCB0NyA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxNCk7XG4gICAgICAgIGxldCBoMCA9IGhbMF0gKyAodDAgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDEgPSBoWzFdICsgKCgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDIgPSBoWzJdICsgKCgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDMgPSBoWzNdICsgKCgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoNCA9IGhbNF0gKyAoKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoNSA9IGhbNV0gKyAoKHQ0ID4+PiAxKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoNiA9IGhbNl0gKyAoKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoNyA9IGhbN10gKyAoKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoOCA9IGhbOF0gKyAoKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg5ID0gaFs5XSArICgodDcgPj4+IDUpIHwgaGliaXQpO1xuICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgIGxldCBkMCA9IGMgKyBoMCAqIHIwICsgaDEgKiAoNSAqIHI5KSArIGgyICogKDUgKiByOCkgKyBoMyAqICg1ICogcjcpICsgaDQgKiAoNSAqIHI2KTtcbiAgICAgICAgYyA9IGQwID4+PiAxMztcbiAgICAgICAgZDAgJj0gMHgxZmZmO1xuICAgICAgICBkMCArPSBoNSAqICg1ICogcjUpICsgaDYgKiAoNSAqIHI0KSArIGg3ICogKDUgKiByMykgKyBoOCAqICg1ICogcjIpICsgaDkgKiAoNSAqIHIxKTtcbiAgICAgICAgYyArPSBkMCA+Pj4gMTM7XG4gICAgICAgIGQwICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQxID0gYyArIGgwICogcjEgKyBoMSAqIHIwICsgaDIgKiAoNSAqIHI5KSArIGgzICogKDUgKiByOCkgKyBoNCAqICg1ICogcjcpO1xuICAgICAgICBjID0gZDEgPj4+IDEzO1xuICAgICAgICBkMSAmPSAweDFmZmY7XG4gICAgICAgIGQxICs9IGg1ICogKDUgKiByNikgKyBoNiAqICg1ICogcjUpICsgaDcgKiAoNSAqIHI0KSArIGg4ICogKDUgKiByMykgKyBoOSAqICg1ICogcjIpO1xuICAgICAgICBjICs9IGQxID4+PiAxMztcbiAgICAgICAgZDEgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDIgPSBjICsgaDAgKiByMiArIGgxICogcjEgKyBoMiAqIHIwICsgaDMgKiAoNSAqIHI5KSArIGg0ICogKDUgKiByOCk7XG4gICAgICAgIGMgPSBkMiA+Pj4gMTM7XG4gICAgICAgIGQyICY9IDB4MWZmZjtcbiAgICAgICAgZDIgKz0gaDUgKiAoNSAqIHI3KSArIGg2ICogKDUgKiByNikgKyBoNyAqICg1ICogcjUpICsgaDggKiAoNSAqIHI0KSArIGg5ICogKDUgKiByMyk7XG4gICAgICAgIGMgKz0gZDIgPj4+IDEzO1xuICAgICAgICBkMiAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMyA9IGMgKyBoMCAqIHIzICsgaDEgKiByMiArIGgyICogcjEgKyBoMyAqIHIwICsgaDQgKiAoNSAqIHI5KTtcbiAgICAgICAgYyA9IGQzID4+PiAxMztcbiAgICAgICAgZDMgJj0gMHgxZmZmO1xuICAgICAgICBkMyArPSBoNSAqICg1ICogcjgpICsgaDYgKiAoNSAqIHI3KSArIGg3ICogKDUgKiByNikgKyBoOCAqICg1ICogcjUpICsgaDkgKiAoNSAqIHI0KTtcbiAgICAgICAgYyArPSBkMyA+Pj4gMTM7XG4gICAgICAgIGQzICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ0ID0gYyArIGgwICogcjQgKyBoMSAqIHIzICsgaDIgKiByMiArIGgzICogcjEgKyBoNCAqIHIwO1xuICAgICAgICBjID0gZDQgPj4+IDEzO1xuICAgICAgICBkNCAmPSAweDFmZmY7XG4gICAgICAgIGQ0ICs9IGg1ICogKDUgKiByOSkgKyBoNiAqICg1ICogcjgpICsgaDcgKiAoNSAqIHI3KSArIGg4ICogKDUgKiByNikgKyBoOSAqICg1ICogcjUpO1xuICAgICAgICBjICs9IGQ0ID4+PiAxMztcbiAgICAgICAgZDQgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDUgPSBjICsgaDAgKiByNSArIGgxICogcjQgKyBoMiAqIHIzICsgaDMgKiByMiArIGg0ICogcjE7XG4gICAgICAgIGMgPSBkNSA+Pj4gMTM7XG4gICAgICAgIGQ1ICY9IDB4MWZmZjtcbiAgICAgICAgZDUgKz0gaDUgKiByMCArIGg2ICogKDUgKiByOSkgKyBoNyAqICg1ICogcjgpICsgaDggKiAoNSAqIHI3KSArIGg5ICogKDUgKiByNik7XG4gICAgICAgIGMgKz0gZDUgPj4+IDEzO1xuICAgICAgICBkNSAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNiA9IGMgKyBoMCAqIHI2ICsgaDEgKiByNSArIGgyICogcjQgKyBoMyAqIHIzICsgaDQgKiByMjtcbiAgICAgICAgYyA9IGQ2ID4+PiAxMztcbiAgICAgICAgZDYgJj0gMHgxZmZmO1xuICAgICAgICBkNiArPSBoNSAqIHIxICsgaDYgKiByMCArIGg3ICogKDUgKiByOSkgKyBoOCAqICg1ICogcjgpICsgaDkgKiAoNSAqIHI3KTtcbiAgICAgICAgYyArPSBkNiA+Pj4gMTM7XG4gICAgICAgIGQ2ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ3ID0gYyArIGgwICogcjcgKyBoMSAqIHI2ICsgaDIgKiByNSArIGgzICogcjQgKyBoNCAqIHIzO1xuICAgICAgICBjID0gZDcgPj4+IDEzO1xuICAgICAgICBkNyAmPSAweDFmZmY7XG4gICAgICAgIGQ3ICs9IGg1ICogcjIgKyBoNiAqIHIxICsgaDcgKiByMCArIGg4ICogKDUgKiByOSkgKyBoOSAqICg1ICogcjgpO1xuICAgICAgICBjICs9IGQ3ID4+PiAxMztcbiAgICAgICAgZDcgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDggPSBjICsgaDAgKiByOCArIGgxICogcjcgKyBoMiAqIHI2ICsgaDMgKiByNSArIGg0ICogcjQ7XG4gICAgICAgIGMgPSBkOCA+Pj4gMTM7XG4gICAgICAgIGQ4ICY9IDB4MWZmZjtcbiAgICAgICAgZDggKz0gaDUgKiByMyArIGg2ICogcjIgKyBoNyAqIHIxICsgaDggKiByMCArIGg5ICogKDUgKiByOSk7XG4gICAgICAgIGMgKz0gZDggPj4+IDEzO1xuICAgICAgICBkOCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkOSA9IGMgKyBoMCAqIHI5ICsgaDEgKiByOCArIGgyICogcjcgKyBoMyAqIHI2ICsgaDQgKiByNTtcbiAgICAgICAgYyA9IGQ5ID4+PiAxMztcbiAgICAgICAgZDkgJj0gMHgxZmZmO1xuICAgICAgICBkOSArPSBoNSAqIHI0ICsgaDYgKiByMyArIGg3ICogcjIgKyBoOCAqIHIxICsgaDkgKiByMDtcbiAgICAgICAgYyArPSBkOSA+Pj4gMTM7XG4gICAgICAgIGQ5ICY9IDB4MWZmZjtcbiAgICAgICAgYyA9ICgoYyA8PCAyKSArIGMpIHwgMDtcbiAgICAgICAgYyA9IChjICsgZDApIHwgMDtcbiAgICAgICAgZDAgPSBjICYgMHgxZmZmO1xuICAgICAgICBjID0gYyA+Pj4gMTM7XG4gICAgICAgIGQxICs9IGM7XG4gICAgICAgIGhbMF0gPSBkMDtcbiAgICAgICAgaFsxXSA9IGQxO1xuICAgICAgICBoWzJdID0gZDI7XG4gICAgICAgIGhbM10gPSBkMztcbiAgICAgICAgaFs0XSA9IGQ0O1xuICAgICAgICBoWzVdID0gZDU7XG4gICAgICAgIGhbNl0gPSBkNjtcbiAgICAgICAgaFs3XSA9IGQ3O1xuICAgICAgICBoWzhdID0gZDg7XG4gICAgICAgIGhbOV0gPSBkOTtcbiAgICB9XG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgcGFkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgICAgICAgbGV0IGMgPSBoWzFdID4+PiAxMztcbiAgICAgICAgaFsxXSAmPSAweDFmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgaFtpXSArPSBjO1xuICAgICAgICAgICAgYyA9IGhbaV0gPj4+IDEzO1xuICAgICAgICAgICAgaFtpXSAmPSAweDFmZmY7XG4gICAgICAgIH1cbiAgICAgICAgaFswXSArPSBjICogNTtcbiAgICAgICAgYyA9IGhbMF0gPj4+IDEzO1xuICAgICAgICBoWzBdICY9IDB4MWZmZjtcbiAgICAgICAgaFsxXSArPSBjO1xuICAgICAgICBjID0gaFsxXSA+Pj4gMTM7XG4gICAgICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgICAgICBoWzJdICs9IGM7XG4gICAgICAgIGdbMF0gPSBoWzBdICsgNTtcbiAgICAgICAgYyA9IGdbMF0gPj4+IDEzO1xuICAgICAgICBnWzBdICY9IDB4MWZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICBnW2ldID0gaFtpXSArIGM7XG4gICAgICAgICAgICBjID0gZ1tpXSA+Pj4gMTM7XG4gICAgICAgICAgICBnW2ldICY9IDB4MWZmZjtcbiAgICAgICAgfVxuICAgICAgICBnWzldIC09IDEgPDwgMTM7XG4gICAgICAgIGxldCBtYXNrID0gKGMgXiAxKSAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgICAgIGdbaV0gJj0gbWFzaztcbiAgICAgICAgbWFzayA9IH5tYXNrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBoW2ldID0gKGhbaV0gJiBtYXNrKSB8IGdbaV07XG4gICAgICAgIGhbMF0gPSAoaFswXSB8IChoWzFdIDw8IDEzKSkgJiAweGZmZmY7XG4gICAgICAgIGhbMV0gPSAoKGhbMV0gPj4+IDMpIHwgKGhbMl0gPDwgMTApKSAmIDB4ZmZmZjtcbiAgICAgICAgaFsyXSA9ICgoaFsyXSA+Pj4gNikgfCAoaFszXSA8PCA3KSkgJiAweGZmZmY7XG4gICAgICAgIGhbM10gPSAoKGhbM10gPj4+IDkpIHwgKGhbNF0gPDwgNCkpICYgMHhmZmZmO1xuICAgICAgICBoWzRdID0gKChoWzRdID4+PiAxMikgfCAoaFs1XSA8PCAxKSB8IChoWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gICAgICAgIGhbNV0gPSAoKGhbNl0gPj4+IDIpIHwgKGhbN10gPDwgMTEpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs2XSA9ICgoaFs3XSA+Pj4gNSkgfCAoaFs4XSA8PCA4KSkgJiAweGZmZmY7XG4gICAgICAgIGhbN10gPSAoKGhbOF0gPj4+IDgpIHwgKGhbOV0gPDwgNSkpICYgMHhmZmZmO1xuICAgICAgICBsZXQgZiA9IGhbMF0gKyBwYWRbMF07XG4gICAgICAgIGhbMF0gPSBmICYgMHhmZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgZiA9ICgoKGhbaV0gKyBwYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgICAgICAgICBoW2ldID0gZiAmIDB4ZmZmZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0XG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhLCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmguZmlsbCgwKTtcbiAgICAgICAgdGhpcy5yLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMucGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBoIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltwb3MrK10gPSAxO1xuICAgICAgICAgICAgLy8gYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgICAgIGZvciAoOyBwb3MgPCAxNjsgcG9zKyspXG4gICAgICAgICAgICAgICAgYnVmZmVyW3Bvc10gPSAwO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICBsZXQgb3BvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDA7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBrZXkpID0+IGhhc2hDb25zKGtleSkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChrZXkpID0+IGhhc2hDb25zKGtleSk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGNvbnN0IHBvbHkxMzA1ID0gd3JhcENvbnN0cnVjdG9yV2l0aEtleSgoa2V5KSA9PiBuZXcgUG9seTEzMDUoa2V5KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcG9seTEzMDUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_poly1305.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_salsa.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/_salsa.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   salsaBasic: () => (/* binding */ salsaBasic)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js\");\n// Basic utils for salsa-like ciphers\n// Check out _micro.ts for descriptive documentation.\n\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- Original papers don't allow mutating counters\n- Counter overflow is undefined: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n- 3rd-party library stablelib implementation uses an approach where you can provide\n  nonce and counter instead of just nonce - and it will re-use it\n- We could have did something similar, but ChaCha has different counter position\n  (counter | nonce), which is not composable with XChaCha, because full counter\n  is (nonce16 | counter | nonce16). Stablelib doesn't support in-place counter for XChaCha.\n- We could separate nonce & counter and provide separate API for counter re-use, but\n  there are different counter sizes depending on an algorithm.\n- Salsa & ChaCha also differ in structures of key / sigma:\n\n    salsa:     c0 | k(4) | c1 | nonce(2) | ctr(2) | c2 | k(4) | c4\n    chacha:    c(4) | k(8) | ctr(1) | nonce(3)\n    chachaDJB: c(4) | k(8) | ctr(2) | nonce(2)\n- Creating function such as `setSalsaState(key, nonce, sigma, data)` won't work,\n  because we can't re-use counter array\n- 32-bit nonce is `2 ** 32 * 64` = 256GB with 32-bit counter\n- JS does not allow UintArrays bigger than 4GB, so supporting 64-bit counters doesn't matter\n\nStructure is as following:\n\nkey=16 -> sigma16, k=key|key\nkey=32 -> sigma32, k=key\n\nnonces:\nsalsa20:      8   (8-byte counter)\nchacha20djb:  8   (8-byte counter)\nchacha20tls:  12  (4-byte counter)\nxsalsa:       24  (16 -> hsalsa, 8 -> old nonce)\nxchacha:      24  (16 -> hchacha, 8 -> old nonce)\n\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\nUse the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n*/\nconst sigma16 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('expand 16-byte k');\nconst sigma32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('expand 32-byte k');\nconst sigma16_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(sigma16);\nconst sigma32_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(sigma32);\n// Is byte array aligned to 4 byte offset (u32)?\nconst isAligned32 = (b) => !(b.byteOffset % 4);\nconst salsaBasic = (opts) => {\n    const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 }, opts);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(counterLen);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(rounds);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(blockLen);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bool(counterRight);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bool(allow128bitKeys);\n    const blockLen32 = blockLen / 4;\n    if (blockLen % 4 !== 0)\n        throw new Error('Salsa/ChaCha: blockLen must be aligned to 4 bytes');\n    return (key, nonce, data, output, counter = 0) => {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(key);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(nonce);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(data);\n        if (!output)\n            output = new Uint8Array(data.length);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(output);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(counter);\n        // > new Uint32Array([2**32])\n        // Uint32Array(1) [ 0 ]\n        // > new Uint32Array([2**32-1])\n        // Uint32Array(1) [ 4294967295 ]\n        if (counter < 0 || counter >= 2 ** 32 - 1)\n            throw new Error('Salsa/ChaCha: counter overflow');\n        if (output.length < data.length) {\n            throw new Error(`Salsa/ChaCha: output (${output.length}) is shorter than data (${data.length})`);\n        }\n        const toClean = [];\n        let k, sigma;\n        // Handle 128 byte keys\n        if (key.length === 32) {\n            k = key;\n            sigma = sigma32_32;\n        }\n        else if (key.length === 16 && allow128bitKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else\n            throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${key.length}`);\n        // Handle extended nonce (HChaCha/HSalsa)\n        if (extendNonceFn) {\n            if (nonce.length <= 16)\n                throw new Error(`Salsa/ChaCha: extended nonce must be bigger than 16 bytes`);\n            k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));\n            toClean.push(k);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceLen = 16 - counterLen;\n        if (nonce.length !== nonceLen)\n            throw new Error(`Salsa/ChaCha: nonce must be ${nonceLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            toClean.push((nonce = nc));\n        }\n        // Counter positions\n        const block = new Uint8Array(blockLen);\n        // Cast to Uint32Array for speed\n        const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(block);\n        const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(k);\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(nonce);\n        // Make sure that buffers aligned to 4 bytes\n        const d32 = isAligned32(data) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(data);\n        const o32 = isAligned32(output) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(output);\n        toClean.push(b32);\n        const len = data.length;\n        for (let pos = 0, ctr = counter; pos < len; ctr++) {\n            core(sigma, k32, n32, b32, ctr, rounds);\n            if (ctr >= 2 ** 32 - 1)\n                throw new Error('Salsa/ChaCha: counter overflow');\n            const take = Math.min(blockLen, len - pos);\n            // full block && aligned to 4 bytes\n            if (take === blockLen && o32 && d32) {\n                const pos32 = pos / 4;\n                if (pos % 4 !== 0)\n                    throw new Error('Salsa/ChaCha: invalid block position');\n                for (let j = 0; j < blockLen32; j++)\n                    o32[pos32 + j] = d32[pos32 + j] ^ b32[j];\n                pos += blockLen;\n                continue;\n            }\n            for (let j = 0; j < take; j++)\n                output[pos + j] = data[pos + j] ^ block[j];\n            pos += take;\n        }\n        for (let i = 0; i < toClean.length; i++)\n            toClean[i].fill(0);\n        return output;\n    };\n};\n//# sourceMappingURL=_salsa.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX3NhbHNhLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDa0M7QUFDdUI7QUFDekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVc7QUFDM0IsZ0JBQWdCLHNEQUFXO0FBQzNCLG1CQUFtQiw4Q0FBRztBQUN0QixtQkFBbUIsOENBQUc7QUFDdEI7QUFDQTtBQUNPO0FBQ1AsWUFBWSxtRkFBbUYsRUFBRSxvREFBUyxHQUFHLHFGQUFxRjtBQUNsTSxJQUFJLHlEQUFhO0FBQ2pCLElBQUkseURBQWE7QUFDakIsSUFBSSx5REFBYTtBQUNqQixJQUFJLHVEQUFXO0FBQ2YsSUFBSSx1REFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBWTtBQUNwQixRQUFRLHdEQUFZO0FBQ3BCLFFBQVEsd0RBQVk7QUFDcEI7QUFDQTtBQUNBLFFBQVEsd0RBQVk7QUFDcEIsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjLDBCQUEwQixZQUFZO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFdBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBRztBQUN2QixvQkFBb0IsOENBQUc7QUFDdkIsb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0EseUNBQXlDLDhDQUFHO0FBQzVDLDJDQUEyQyw4Q0FBRztBQUM5QztBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY2lwaGVyc1xcZXNtXFxfc2Fsc2EuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFzaWMgdXRpbHMgZm9yIHNhbHNhLWxpa2UgY2lwaGVyc1xuLy8gQ2hlY2sgb3V0IF9taWNyby50cyBmb3IgZGVzY3JpcHRpdmUgZG9jdW1lbnRhdGlvbi5cbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHUzMiwgdXRmOFRvQnl0ZXMsIGNoZWNrT3B0cyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLypcblJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuYXV0aEtleSBzdGFydHMgd2l0aCBjb3VudGVyOiAwLCBhY3R1YWwgbXNnIHdpdGggY291bnRlcjogMS5cblxuRm9yIHRoaXMsIHdlIG5lZWQgYSB3YXkgdG8gcmUtdXNlIG5vbmNlIC8gY291bnRlcjpcblxuICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAxXG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMlxuXG5UaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG4tIE9yaWdpbmFsIHBhcGVycyBkb24ndCBhbGxvdyBtdXRhdGluZyBjb3VudGVyc1xuLSBDb3VudGVyIG92ZXJmbG93IGlzIHVuZGVmaW5lZDogaHR0cHM6Ly9tYWlsYXJjaGl2ZS5pZXRmLm9yZy9hcmNoL21zZy9jZnJnL2dzT25USnpjYmdHNk9xRDhTYzBHTzVhUl90VS9cbi0gM3JkLXBhcnR5IGxpYnJhcnkgc3RhYmxlbGliIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gYXBwcm9hY2ggd2hlcmUgeW91IGNhbiBwcm92aWRlXG4gIG5vbmNlIGFuZCBjb3VudGVyIGluc3RlYWQgb2YganVzdCBub25jZSAtIGFuZCBpdCB3aWxsIHJlLXVzZSBpdFxuLSBXZSBjb3VsZCBoYXZlIGRpZCBzb21ldGhpbmcgc2ltaWxhciwgYnV0IENoYUNoYSBoYXMgZGlmZmVyZW50IGNvdW50ZXIgcG9zaXRpb25cbiAgKGNvdW50ZXIgfCBub25jZSksIHdoaWNoIGlzIG5vdCBjb21wb3NhYmxlIHdpdGggWENoYUNoYSwgYmVjYXVzZSBmdWxsIGNvdW50ZXJcbiAgaXMgKG5vbmNlMTYgfCBjb3VudGVyIHwgbm9uY2UxNikuIFN0YWJsZWxpYiBkb2Vzbid0IHN1cHBvcnQgaW4tcGxhY2UgY291bnRlciBmb3IgWENoYUNoYS5cbi0gV2UgY291bGQgc2VwYXJhdGUgbm9uY2UgJiBjb3VudGVyIGFuZCBwcm92aWRlIHNlcGFyYXRlIEFQSSBmb3IgY291bnRlciByZS11c2UsIGJ1dFxuICB0aGVyZSBhcmUgZGlmZmVyZW50IGNvdW50ZXIgc2l6ZXMgZGVwZW5kaW5nIG9uIGFuIGFsZ29yaXRobS5cbi0gU2Fsc2EgJiBDaGFDaGEgYWxzbyBkaWZmZXIgaW4gc3RydWN0dXJlcyBvZiBrZXkgLyBzaWdtYTpcblxuICAgIHNhbHNhOiAgICAgYzAgfCBrKDQpIHwgYzEgfCBub25jZSgyKSB8IGN0cigyKSB8IGMyIHwgayg0KSB8IGM0XG4gICAgY2hhY2hhOiAgICBjKDQpIHwgayg4KSB8IGN0cigxKSB8IG5vbmNlKDMpXG4gICAgY2hhY2hhREpCOiBjKDQpIHwgayg4KSB8IGN0cigyKSB8IG5vbmNlKDIpXG4tIENyZWF0aW5nIGZ1bmN0aW9uIHN1Y2ggYXMgYHNldFNhbHNhU3RhdGUoa2V5LCBub25jZSwgc2lnbWEsIGRhdGEpYCB3b24ndCB3b3JrLFxuICBiZWNhdXNlIHdlIGNhbid0IHJlLXVzZSBjb3VudGVyIGFycmF5XG4tIDMyLWJpdCBub25jZSBpcyBgMiAqKiAzMiAqIDY0YCA9IDI1NkdCIHdpdGggMzItYml0IGNvdW50ZXJcbi0gSlMgZG9lcyBub3QgYWxsb3cgVWludEFycmF5cyBiaWdnZXIgdGhhbiA0R0IsIHNvIHN1cHBvcnRpbmcgNjQtYml0IGNvdW50ZXJzIGRvZXNuJ3QgbWF0dGVyXG5cblN0cnVjdHVyZSBpcyBhcyBmb2xsb3dpbmc6XG5cbmtleT0xNiAtPiBzaWdtYTE2LCBrPWtleXxrZXlcbmtleT0zMiAtPiBzaWdtYTMyLCBrPWtleVxuXG5ub25jZXM6XG5zYWxzYTIwOiAgICAgIDggICAoOC1ieXRlIGNvdW50ZXIpXG5jaGFjaGEyMGRqYjogIDggICAoOC1ieXRlIGNvdW50ZXIpXG5jaGFjaGEyMHRsczogIDEyICAoNC1ieXRlIGNvdW50ZXIpXG54c2Fsc2E6ICAgICAgIDI0ICAoMTYgLT4gaHNhbHNhLCA4IC0+IG9sZCBub25jZSlcbnhjaGFjaGE6ICAgICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcblxuaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSNhcHBlbmRpeC1BLjJcblVzZSB0aGUgc3Via2V5IGFuZCByZW1haW5pbmcgOCBieXRlIG5vbmNlIHdpdGggQ2hhQ2hhMjAgYXMgbm9ybWFsXG4ocHJlZml4ZWQgYnkgNCBOVUwgYnl0ZXMsIHNpbmNlIFtSRkM4NDM5XSBzcGVjaWZpZXMgYSAxMi1ieXRlIG5vbmNlKS5cbiovXG5jb25zdCBzaWdtYTE2ID0gdXRmOFRvQnl0ZXMoJ2V4cGFuZCAxNi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMzIgPSB1dGY4VG9CeXRlcygnZXhwYW5kIDMyLWJ5dGUgaycpO1xuY29uc3Qgc2lnbWExNl8zMiA9IHUzMihzaWdtYTE2KTtcbmNvbnN0IHNpZ21hMzJfMzIgPSB1MzIoc2lnbWEzMik7XG4vLyBJcyBieXRlIGFycmF5IGFsaWduZWQgdG8gNCBieXRlIG9mZnNldCAodTMyKT9cbmNvbnN0IGlzQWxpZ25lZDMyID0gKGIpID0+ICEoYi5ieXRlT2Zmc2V0ICUgNCk7XG5leHBvcnQgY29uc3Qgc2Fsc2FCYXNpYyA9IChvcHRzKSA9PiB7XG4gICAgY29uc3QgeyBjb3JlLCByb3VuZHMsIGNvdW50ZXJSaWdodCwgY291bnRlckxlbiwgYWxsb3cxMjhiaXRLZXlzLCBleHRlbmROb25jZUZuLCBibG9ja0xlbiB9ID0gY2hlY2tPcHRzKHsgcm91bmRzOiAyMCwgY291bnRlclJpZ2h0OiBmYWxzZSwgY291bnRlckxlbjogOCwgYWxsb3cxMjhiaXRLZXlzOiB0cnVlLCBibG9ja0xlbjogNjQgfSwgb3B0cyk7XG4gICAgYXNzZXJ0Lm51bWJlcihjb3VudGVyTGVuKTtcbiAgICBhc3NlcnQubnVtYmVyKHJvdW5kcyk7XG4gICAgYXNzZXJ0Lm51bWJlcihibG9ja0xlbik7XG4gICAgYXNzZXJ0LmJvb2woY291bnRlclJpZ2h0KTtcbiAgICBhc3NlcnQuYm9vbChhbGxvdzEyOGJpdEtleXMpO1xuICAgIGNvbnN0IGJsb2NrTGVuMzIgPSBibG9ja0xlbiAvIDQ7XG4gICAgaWYgKGJsb2NrTGVuICUgNCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYWxzYS9DaGFDaGE6IGJsb2NrTGVuIG11c3QgYmUgYWxpZ25lZCB0byA0IGJ5dGVzJyk7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIgPSAwKSA9PiB7XG4gICAgICAgIGFzc2VydC5ieXRlcyhrZXkpO1xuICAgICAgICBhc3NlcnQuYnl0ZXMobm9uY2UpO1xuICAgICAgICBhc3NlcnQuYnl0ZXMoZGF0YSk7XG4gICAgICAgIGlmICghb3V0cHV0KVxuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBhc3NlcnQuYnl0ZXMob3V0cHV0KTtcbiAgICAgICAgYXNzZXJ0Lm51bWJlcihjb3VudGVyKTtcbiAgICAgICAgLy8gPiBuZXcgVWludDMyQXJyYXkoWzIqKjMyXSlcbiAgICAgICAgLy8gVWludDMyQXJyYXkoMSkgWyAwIF1cbiAgICAgICAgLy8gPiBuZXcgVWludDMyQXJyYXkoWzIqKjMyLTFdKVxuICAgICAgICAvLyBVaW50MzJBcnJheSgxKSBbIDQyOTQ5NjcyOTUgXVxuICAgICAgICBpZiAoY291bnRlciA8IDAgfHwgY291bnRlciA+PSAyICoqIDMyIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Fsc2EvQ2hhQ2hhOiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Fsc2EvQ2hhQ2hhOiBvdXRwdXQgKCR7b3V0cHV0Lmxlbmd0aH0pIGlzIHNob3J0ZXIgdGhhbiBkYXRhICgke2RhdGEubGVuZ3RofSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b0NsZWFuID0gW107XG4gICAgICAgIGxldCBrLCBzaWdtYTtcbiAgICAgICAgLy8gSGFuZGxlIDEyOCBieXRlIGtleXNcbiAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBrID0ga2V5O1xuICAgICAgICAgICAgc2lnbWEgPSBzaWdtYTMyXzMyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDE2ICYmIGFsbG93MTI4Yml0S2V5cykge1xuICAgICAgICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGsuc2V0KGtleSk7XG4gICAgICAgICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNhbHNhL0NoYUNoYTogaW52YWxpZCAzMi1ieXRlIGtleSwgZ290IGxlbmd0aD0ke2tleS5sZW5ndGh9YCk7XG4gICAgICAgIC8vIEhhbmRsZSBleHRlbmRlZCBub25jZSAoSENoYUNoYS9IU2Fsc2EpXG4gICAgICAgIGlmIChleHRlbmROb25jZUZuKSB7XG4gICAgICAgICAgICBpZiAobm9uY2UubGVuZ3RoIDw9IDE2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Fsc2EvQ2hhQ2hhOiBleHRlbmRlZCBub25jZSBtdXN0IGJlIGJpZ2dlciB0aGFuIDE2IGJ5dGVzYCk7XG4gICAgICAgICAgICBrID0gZXh0ZW5kTm9uY2VGbihzaWdtYSwgaywgbm9uY2Uuc3ViYXJyYXkoMCwgMTYpLCBuZXcgVWludDhBcnJheSgzMikpO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGspO1xuICAgICAgICAgICAgbm9uY2UgPSBub25jZS5zdWJhcnJheSgxNik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG5vbmNlIGNvdW50ZXJcbiAgICAgICAgY29uc3Qgbm9uY2VMZW4gPSAxNiAtIGNvdW50ZXJMZW47XG4gICAgICAgIGlmIChub25jZS5sZW5ndGggIT09IG5vbmNlTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTYWxzYS9DaGFDaGE6IG5vbmNlIG11c3QgYmUgJHtub25jZUxlbn0gb3IgMTYgYnl0ZXNgKTtcbiAgICAgICAgLy8gUGFkIGNvdW50ZXIgd2hlbiBub25jZSBpcyA2NCBiaXRcbiAgICAgICAgaWYgKG5vbmNlTGVuICE9PSAxMikge1xuICAgICAgICAgICAgY29uc3QgbmMgPSBuZXcgVWludDhBcnJheSgxMik7XG4gICAgICAgICAgICBuYy5zZXQobm9uY2UsIGNvdW50ZXJSaWdodCA/IDAgOiAxMiAtIG5vbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2goKG5vbmNlID0gbmMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3VudGVyIHBvc2l0aW9uc1xuICAgICAgICBjb25zdCBibG9jayA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gQ2FzdCB0byBVaW50MzJBcnJheSBmb3Igc3BlZWRcbiAgICAgICAgY29uc3QgYjMyID0gdTMyKGJsb2NrKTtcbiAgICAgICAgY29uc3QgazMyID0gdTMyKGspO1xuICAgICAgICBjb25zdCBuMzIgPSB1MzIobm9uY2UpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXJzIGFsaWduZWQgdG8gNCBieXRlc1xuICAgICAgICBjb25zdCBkMzIgPSBpc0FsaWduZWQzMihkYXRhKSAmJiB1MzIoZGF0YSk7XG4gICAgICAgIGNvbnN0IG8zMiA9IGlzQWxpZ25lZDMyKG91dHB1dCkgJiYgdTMyKG91dHB1dCk7XG4gICAgICAgIHRvQ2xlYW4ucHVzaChiMzIpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgY3RyID0gY291bnRlcjsgcG9zIDwgbGVuOyBjdHIrKykge1xuICAgICAgICAgICAgY29yZShzaWdtYSwgazMyLCBuMzIsIGIzMiwgY3RyLCByb3VuZHMpO1xuICAgICAgICAgICAgaWYgKGN0ciA+PSAyICoqIDMyIC0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHNhL0NoYUNoYTogY291bnRlciBvdmVyZmxvdycpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gZnVsbCBibG9jayAmJiBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbiAmJiBvMzIgJiYgZDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zMzIgPSBwb3MgLyA0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgJSA0ICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHNhL0NoYUNoYTogaW52YWxpZCBibG9jayBwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2tMZW4zMjsgaisrKVxuICAgICAgICAgICAgICAgICAgICBvMzJbcG9zMzIgKyBqXSA9IGQzMltwb3MzMiArIGpdIF4gYjMyW2pdO1xuICAgICAgICAgICAgICAgIHBvcyArPSBibG9ja0xlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFrZTsgaisrKVxuICAgICAgICAgICAgICAgIG91dHB1dFtwb3MgKyBqXSA9IGRhdGFbcG9zICsgal0gXiBibG9ja1tqXTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9DbGVhbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRvQ2xlYW5baV0uZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zYWxzYS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_salsa.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/ciphers/esm/chacha.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/chacha.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _poly1305_aead: () => (/* binding */ _poly1305_aead),\n/* harmony export */   chacha12: () => (/* binding */ chacha12),\n/* harmony export */   chacha20: () => (/* binding */ chacha20),\n/* harmony export */   chacha20orig: () => (/* binding */ chacha20orig),\n/* harmony export */   chacha20poly1305: () => (/* binding */ chacha20poly1305),\n/* harmony export */   chacha8: () => (/* binding */ chacha8),\n/* harmony export */   hchacha: () => (/* binding */ hchacha),\n/* harmony export */   xchacha20: () => (/* binding */ xchacha20),\n/* harmony export */   xchacha20poly1305: () => (/* binding */ xchacha20poly1305)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _poly1305_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_poly1305.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_poly1305.js\");\n/* harmony import */ var _salsa_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_salsa.js */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/_salsa.js\");\n\n\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(c, k, n, out, cnt, rounds = 20) {\n    let y00 = c[0], y01 = c[1], y02 = c[2], y03 = c[3]; // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    let y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3]; // Key      Key     Key     Key\n    let y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7]; // Key      Key     Key     Key\n    let y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop\n    for (let i = 0; i < rounds; i += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(c, key, src, out) {\n    const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(key);\n    const i32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(src);\n    const o32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(out);\n    let x00 = c[0], x01 = c[1], x02 = c[2], x03 = c[3];\n    let x04 = k32[0], x05 = k32[1], x06 = k32[2], x07 = k32[3];\n    let x08 = k32[4], x09 = k32[5], x10 = k32[6], x11 = k32[7];\n    let x12 = i32[0], x13 = i32[1], x14 = i32[2], x15 = i32[3];\n    for (let i = 0; i < 20; i += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    o32[0] = x00;\n    o32[1] = x01;\n    o32[2] = x02;\n    o32[3] = x03;\n    o32[4] = x12;\n    o32[5] = x13;\n    o32[6] = x14;\n    o32[7] = x15;\n    return out;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nconst chacha20orig = /* @__PURE__ */ (0,_salsa_js__WEBPACK_IMPORTED_MODULE_2__.salsaBasic)({\n    core: chachaCore,\n    counterRight: false,\n    counterLen: 8,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nconst chacha20 = /* @__PURE__ */ (0,_salsa_js__WEBPACK_IMPORTED_MODULE_2__.salsaBasic)({\n    core: chachaCore,\n    counterRight: false,\n    counterLen: 4,\n    allow128bitKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nconst xchacha20 = /* @__PURE__ */ (0,_salsa_js__WEBPACK_IMPORTED_MODULE_2__.salsaBasic)({\n    core: chachaCore,\n    counterRight: false,\n    counterLen: 8,\n    extendNonceFn: hchacha,\n    allow128bitKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nconst chacha8 = /* @__PURE__ */ (0,_salsa_js__WEBPACK_IMPORTED_MODULE_2__.salsaBasic)({\n    core: chachaCore,\n    counterRight: false,\n    counterLen: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nconst chacha12 = /* @__PURE__ */ (0,_salsa_js__WEBPACK_IMPORTED_MODULE_2__.salsaBasic)({\n    core: chachaCore,\n    counterRight: false,\n    counterLen: 4,\n    rounds: 12,\n});\nconst ZERO = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZERO.subarray(left));\n};\nconst computeTag = (fn, key, nonce, data, AAD) => {\n    const authKey = fn(key, nonce, new Uint8Array(32));\n    const h = _poly1305_js__WEBPACK_IMPORTED_MODULE_1__.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(num);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n};\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(key, 32);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(nonce);\n    return {\n        tagLength,\n        encrypt: (plaintext, output) => {\n            const plength = plaintext.length;\n            const clength = plength + tagLength;\n            if (output) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(output, clength);\n            }\n            else {\n                output = new Uint8Array(clength);\n            }\n            xorStream(key, nonce, plaintext, output, 1);\n            const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n            output.set(tag, plength); // append tag\n            return output;\n        },\n        decrypt: (ciphertext, output) => {\n            const clength = ciphertext.length;\n            const plength = clength - tagLength;\n            if (clength < tagLength)\n                throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n            if (output) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(output, plength);\n            }\n            else {\n                output = new Uint8Array(plength);\n            }\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            xorStream(key, nonce, data, output, 1);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nconst chacha20poly1305 = /* @__PURE__ */ _poly1305_aead(chacha20);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nconst xchacha20poly1305 = /* @__PURE__ */ _poly1305_aead(xchacha20);\n//# sourceMappingURL=chacha.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vY2hhY2hhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUMxQztBQUNEO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsOENBQUc7QUFDbkIsZ0JBQWdCLDhDQUFHO0FBQ25CLGdCQUFnQiw4Q0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxxREFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMscURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxxREFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxxREFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMscURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCLElBQUksdURBQVk7QUFDaEIsSUFBSSx1REFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLElBQUksc0RBQVc7QUFDZixJQUFJLHNEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFO0FBQ0EsZ0JBQWdCLHNEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxlc21cXGNoYWNoYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVWaWV3LCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgc2V0QmlnVWludDY0LCB1MzIgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHBvbHkxMzA1IH0gZnJvbSAnLi9fcG9seTEzMDUuanMnO1xuaW1wb3J0IHsgc2Fsc2FCYXNpYyB9IGZyb20gJy4vX3NhbHNhLmpzJztcbi8vIENoYUNoYTIwIHN0cmVhbSBjaXBoZXIgd2FzIHJlbGVhc2VkIGluIDIwMDguIENoYUNoYSBhaW1zIHRvIGluY3JlYXNlXG4vLyB0aGUgZGlmZnVzaW9uIHBlciByb3VuZCwgYnV0IGhhZCBzbGlnaHRseSBsZXNzIGNyeXB0YW5hbHlzaXMuXG4vLyBodHRwczovL2NyLnlwLnRvL2NoYWNoYS5odG1sLCBodHRwOi8vY3IueXAudG8vY2hhY2hhL2NoYWNoYS0yMDA4MDEyOC5wZGZcbi8vIExlZnQgcm90YXRlIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAoYSwgYikgPT4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKGMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBjWzBdLCB5MDEgPSBjWzFdLCB5MDIgPSBjWzJdLCB5MDMgPSBjWzNdOyAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICBsZXQgeTA0ID0ga1swXSwgeTA1ID0ga1sxXSwgeTA2ID0ga1syXSwgeTA3ID0ga1szXTsgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIGxldCB5MDggPSBrWzRdLCB5MDkgPSBrWzVdLCB5MTAgPSBrWzZdLCB5MTEgPSBrWzddOyAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgbGV0IHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgLy8gTWFpbiBsb29wXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG4gKiBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnLlxuICogU2FtZSBhcyBjaGFjaGFDb3JlLCBidXQgdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgd2F5IHRvIG1vdmUgdGhlIGJsb2NrXG4gKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBoY2hhY2hhKGMsIGtleSwgc3JjLCBvdXQpIHtcbiAgICBjb25zdCBrMzIgPSB1MzIoa2V5KTtcbiAgICBjb25zdCBpMzIgPSB1MzIoc3JjKTtcbiAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICBsZXQgeDAwID0gY1swXSwgeDAxID0gY1sxXSwgeDAyID0gY1syXSwgeDAzID0gY1szXTtcbiAgICBsZXQgeDA0ID0gazMyWzBdLCB4MDUgPSBrMzJbMV0sIHgwNiA9IGszMlsyXSwgeDA3ID0gazMyWzNdO1xuICAgIGxldCB4MDggPSBrMzJbNF0sIHgwOSA9IGszMls1XSwgeDEwID0gazMyWzZdLCB4MTEgPSBrMzJbN107XG4gICAgbGV0IHgxMiA9IGkzMlswXSwgeDEzID0gaTMyWzFdLCB4MTQgPSBpMzJbMl0sIHgxNSA9IGkzMlszXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgMTYpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA4LCAxMik7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDAsIDgpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA4LCA3KTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgMTYpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDA5LCAxMik7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDEsIDgpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDA5LCA3KTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgMTYpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDEwLCAxMik7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDIsIDgpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDEwLCA3KTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgMTYpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDExLCAxMik7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDgpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDExLCA3KTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgMTYpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDEwLCAxMik7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDgpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDEwLCA3KTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgMTYpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDExLCAxMik7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDEsIDgpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDExLCA3KTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgMTYpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDA4LCAxMik7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDIsIDgpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDA4LCA3KTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgMTYpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA5LCAxMik7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDMsIDgpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA5LCA3KTtcbiAgICB9XG4gICAgbzMyWzBdID0geDAwO1xuICAgIG8zMlsxXSA9IHgwMTtcbiAgICBvMzJbMl0gPSB4MDI7XG4gICAgbzMyWzNdID0geDAzO1xuICAgIG8zMls0XSA9IHgxMjtcbiAgICBvMzJbNV0gPSB4MTM7XG4gICAgbzMyWzZdID0geDE0O1xuICAgIG8zMls3XSA9IHgxNTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBPcmlnaW5hbCwgbm9uLVJGQyBjaGFjaGEyMCBmcm9tIERKQi4gOC1ieXRlIG5vbmNlLCA4LWJ5dGUgY291bnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwb3JpZyA9IC8qIEBfX1BVUkVfXyAqLyBzYWxzYUJhc2ljKHtcbiAgICBjb3JlOiBjaGFjaGFDb3JlLFxuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbjogOCxcbn0pO1xuLyoqXG4gKiBDaGFDaGEgc3RyZWFtIGNpcGhlci4gQ29uZm9ybXMgdG8gUkZDIDg0MzkgKElFVEYsIFRMUykuIDEyLWJ5dGUgbm9uY2UsIDQtYnl0ZSBjb3VudGVyLlxuICogV2l0aCAxMi1ieXRlIG5vbmNlLCBpdCdzIG5vdCBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwID0gLyogQF9fUFVSRV9fICovIHNhbHNhQmFzaWMoe1xuICAgIGNvcmU6IGNoYWNoYUNvcmUsXG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuOiA0LFxuICAgIGFsbG93MTI4Yml0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIDI0LWJ5dGUgbm9uY2UuXG4gKiBXaXRoIDI0LWJ5dGUgbm9uY2UsIGl0J3Mgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGFcbiAqL1xuZXhwb3J0IGNvbnN0IHhjaGFjaGEyMCA9IC8qIEBfX1BVUkVfXyAqLyBzYWxzYUJhc2ljKHtcbiAgICBjb3JlOiBjaGFjaGFDb3JlLFxuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbjogOCxcbiAgICBleHRlbmROb25jZUZuOiBoY2hhY2hhLFxuICAgIGFsbG93MTI4Yml0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogUmVkdWNlZCA4LXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhOCA9IC8qIEBfX1BVUkVfXyAqLyBzYWxzYUJhc2ljKHtcbiAgICBjb3JlOiBjaGFjaGFDb3JlLFxuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbjogNCxcbiAgICByb3VuZHM6IDgsXG59KTtcbi8qKlxuICogUmVkdWNlZCAxMi1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTEyID0gLyogQF9fUFVSRV9fICovIHNhbHNhQmFzaWMoe1xuICAgIGNvcmU6IGNoYWNoYUNvcmUsXG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuOiA0LFxuICAgIHJvdW5kczogMTIsXG59KTtcbmNvbnN0IFpFUk8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcbiAgICBoLnVwZGF0ZShtc2cpO1xuICAgIGNvbnN0IGxlZnQgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnQpXG4gICAgICAgIGgudXBkYXRlKFpFUk8uc3ViYXJyYXkobGVmdCkpO1xufTtcbmNvbnN0IGNvbXB1dGVUYWcgPSAoZm4sIGtleSwgbm9uY2UsIGRhdGEsIEFBRCkgPT4ge1xuICAgIGNvbnN0IGF1dGhLZXkgPSBmbihrZXksIG5vbmNlLCBuZXcgVWludDhBcnJheSgzMikpO1xuICAgIGNvbnN0IGggPSBwb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkKGgsIEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhudW0pO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGRhdGEubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICAgIGF1dGhLZXkuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cbiAqIFNhbHNhMjAgYW5kIGNoYWNoYSAoUkZDIDg0MzkpIHVzZSBwb2x5MTMwNSBkaWZmZXJlbnRseS5cbiAqIFdlIGNvdWxkIGhhdmUgY29tcG9zZWQgdGhlbSBzaW1pbGFyIHRvOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1iYXNlL2Jsb2IvYjI2NmM3M2RkZTk3N2IxZGQ3ZWY0MGVmN2EyM2NjMTVhYWI1MjZiMy9pbmRleC50cyNMMjUwXG4gKiBCdXQgaXQncyBoYXJkIGJlY2F1c2Ugb2YgYXV0aEtleTpcbiAqIEluIHNhbHNhMjAsIGF1dGhLZXkgY2hhbmdlcyBwb3NpdGlvbiBpbiBzYWxzYSBzdHJlYW0uXG4gKiBJbiBjaGFjaGEsIGF1dGhLZXkgY2FuJ3QgYmUgY29tcHV0ZWQgaW5zaWRlIGNvbXB1dGVUYWcsIGl0IG1vZGlmaWVzIHRoZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgX3BvbHkxMzA1X2FlYWQgPSAoeG9yU3RyZWFtKSA9PiAoa2V5LCBub25jZSwgQUFEKSA9PiB7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgZW5zdXJlQnl0ZXMoa2V5LCAzMik7XG4gICAgZW5zdXJlQnl0ZXMobm9uY2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhZ0xlbmd0aCxcbiAgICAgICAgZW5jcnlwdDogKHBsYWludGV4dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gcGxhaW50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNsZW5ndGggPSBwbGVuZ3RoICsgdGFnTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGVuc3VyZUJ5dGVzKG91dHB1dCwgY2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShjbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBwbGFpbnRleHQsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgb3V0cHV0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpLCBBQUQpO1xuICAgICAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVuZ3RoID0gY2lwaGVydGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gY2xlbmd0aCAtIHRhZ0xlbmd0aDtcbiAgICAgICAgICAgIGlmIChjbGVuZ3RoIDwgdGFnTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5jcnlwdGVkIGRhdGEgbXVzdCBiZSBhdCBsZWFzdCAke3RhZ0xlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBlbnN1cmVCeXRlcyhvdXRwdXQsIHBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkocGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgZGF0YSwgQUFEKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxCeXRlcyhwYXNzZWRUYWcsIHRhZykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZycpO1xuICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuICogV2l0aCAxMi1ieXRlIG5vbmNlLCBpdCdzIG5vdCBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwcG9seTEzMDUgPSAvKiBAX19QVVJFX18gKi8gX3BvbHkxMzA1X2FlYWQoY2hhY2hhMjApO1xuLyoqXG4gKiBYQ2hhQ2hhMjAtUG9seTEzMDUgZXh0ZW5kZWQtbm9uY2UgY2hhY2hhLlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYVxuICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjBwb2x5MTMwNSA9IC8qIEBfX1BVUkVfXyAqLyBfcG9seTEzMDVfYWVhZCh4Y2hhY2hhMjApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhY2hhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/ciphers/esm/chacha.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/ciphers/esm/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u16: () => (/* binding */ u16),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes)\n/* harmony export */ });\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction ensureBytes(b, len) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    if (typeof len === 'number')\n        if (b.length !== len)\n            throw new Error(`Uint8Array length ${len} expected`);\n}\n// Constant-time equality\nfunction equalBytes(a, b) {\n    // Should not happen\n    if (a.length !== b.length)\n        throw new Error('equalBytes: Different size of Uint8Arrays');\n    let isSame = true;\n    for (let i = 0; i < a.length; i++)\n        isSame && (isSame = a[i] === b[i]); // Lets hope JIT won't optimize away.\n    return isSame;\n}\n// For runtime check if class implements interface\nclass Hash {\n}\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxlc21cXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jaXBoZXJzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUxNiA9IChhcnIpID0+IG5ldyBVaW50MTZBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDIpKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGIsIGxlbikge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICdudW1iZXInKVxuICAgICAgICBpZiAoYi5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBsZW5ndGggJHtsZW59IGV4cGVjdGVkYCk7XG59XG4vLyBDb25zdGFudC10aW1lIGVxdWFsaXR5XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgLy8gU2hvdWxkIG5vdCBoYXBwZW5cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VxdWFsQnl0ZXM6IERpZmZlcmVudCBzaXplIG9mIFVpbnQ4QXJyYXlzJyk7XG4gICAgbGV0IGlzU2FtZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpc1NhbWUgJiYgKGlzU2FtZSA9IGFbaV0gPT09IGJbaV0pOyAvLyBMZXRzIGhvcGUgSklUIHdvbid0IG9wdGltaXplIGF3YXkuXG4gICAgcmV0dXJuIGlzU2FtZTtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGVzbVxcX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ð‘Š) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ð‘Šâˆ’1) * (Math.ceil(ð‘› / ð‘Š) + 1), where:\n         * - ð‘Š is the window size\n         * - ð‘› is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxhYnN0cmFjdFxcY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(options, {\n        DST: 'string',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDb0Q7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU8sU0FBUyxPQUFPO0FBQ3hFO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxTQUFTLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUE2RTtBQUNqRztBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGVzbVxcYWJzdHJhY3RcXGhhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZHN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RTVCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG59XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTEjc2VjdGlvbi01LjQuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTExI3NlY3Rpb24tNS4zXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmcnLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZVxuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) â‰¡ 1    if a is a square (mod p)\n    // (a | p) â‰¡ -1   if a is not a square (mod p)\n    // (a | p) â‰¡ 0    if a â‰¡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) â‰¡ -1 and set c â‰¡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be â‰¡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P â‰¡ 3 (mod 4)\n    // âˆšn = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q â‰¡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P â‰¡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n// 0 is non-invertible: non-batched version will throw on 0\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcseURBQWM7QUFDekI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzREFBc0Q7QUFDN0Q7QUFDQSxzREFBc0QsTUFBTTtBQUM1RCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFlLGVBQWUsMERBQWU7QUFDL0U7QUFDQTtBQUNBLDBEQUEwRCxNQUFNLFFBQVEsYUFBYTtBQUNyRiwwQkFBMEIsMERBQWUsVUFBVSwwREFBZTtBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHNEQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLDRCQUE0QixRQUFRO0FBQ3BHLHVCQUF1QiwwREFBZSxTQUFTLDBEQUFlO0FBQzlEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxlc21cXGFic3RyYWN0XFxtb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuLy8gUGFwZXIgMTogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuLy8gUGFwZXIgMjogU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vLyAwIGlzIG5vbi1pbnZlcnRpYmxlOiBub24tYmF0Y2hlZCB2ZXJzaW9uIHdpbGwgdGhyb3cgb24gMFxuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGdhbG9pcyBmaWVsZCBvdmVyIHByaW1lLiBOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBub3cuXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2UgZ2FpbnM6XG4gKiBhKSBub24tbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogYikgYE9iamVjdC5mcmVlemVgXG4gKiBjKSBTYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRnAgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogRklQUyAxODYgQi40LjEtY29tcGxpYW50IFwiY29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuKzgpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDAgYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBjdXJ2ZUZuLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxpQ0FBaUMsSUFBSSxZQUFZLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLFdBQVcsZ0JBQWdCLGFBQWEsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxlc21cXGFic3RyYWN0XFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodThhKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: yÂ² = xÂ³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((c, point, isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * yÂ² = xÂ³ + ax + b: Short weierstrass curve formula\n     * @returns yÂ²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) âˆ‹ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            // Zero is valid point too!\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint)\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // yÂ²\n            const right = weierstrassEquation(x); // xÂ³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) âˆ‹ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_0__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // yÂ² = xÂ³ + ax + b\n                let y = Fp.sqrt(y2); // y = yÂ² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size (nBitLength+64)\n         * as per FIPS 186 B.4.1 with modulo bias being neglible.\n         */\n        randomPrivateKey: () => {\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.hashToPrivateScalar(rand, CURVE_ORDER);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b âˆˆ [1,qâˆ’1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G Ã— k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1â‹…G - U2â‹…P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1â‹…G + u2â‹…P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDSDtBQUNRO0FBQ1E7QUFDakQ7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksS0FBSyxTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0VBQW9FO0FBQ3BGO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWtCLENBQUMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQSxrQkFBa0IsNENBQU8sVUFBVTtBQUNuQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLDBEQUEwRDtBQUMxRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNPO0FBQ1A7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlLDRDQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLCtDQUFVO0FBQ3pCO0FBQ0EsWUFBWSwyRkFBMkY7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBa0I7QUFDNUM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbURBQW1ELEtBQUssd0JBQXdCLGVBQWUsc0JBQXNCLGlCQUFpQjtBQUN0STtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsbUNBQW1DLGlEQUFhLENBQUMsc0RBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxZQUFZLHNEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxvQ0FBb0Msc0RBQVcsdUJBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsa0VBQWtFO0FBQ2xFO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBdUI7QUFDL0MsbUJBQW1CLHNEQUFrQjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWtCLFNBQVM7QUFDbkQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUIsOENBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0EsZUFBZSxzREFBa0I7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGNBQWMsbUNBQW1DLFFBQVE7QUFDekQ7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDBCQUEwQixzREFBVyxnQ0FBZ0M7QUFDckU7QUFDQSxxQkFBcUIsa0RBQWMsZUFBZTtBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG1DQUFtQztBQUNqRTtBQUNBLHFCQUFxQixxREFBaUI7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QixvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLDBDQUEwQztBQUMxQyw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQywwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBLGtCQUFrQjtBQUNsQiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qiw0Q0FBNEM7QUFDNUM7QUFDQSxzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQSx5QkFBeUIsU0FBUztBQUNsQywrQkFBK0I7QUFDL0Isc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDLDBDQUEwQztBQUMxQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsdUNBQXVDO0FBQ3ZDO0FBQ0EsaUNBQWlDO0FBQ2pDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsK0NBQStDLGtCQUFrQjtBQUNqRSx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1FQUFtRTtBQUNuRSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxhYnN0cmFjdFxcd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gWmVybyBpcyB2YWxpZCBwb2ludCB0b28hXG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplIChuQml0TGVuZ3RoKzY0KVxuICAgICAgICAgKiBhcyBwZXIgRklQUyAxODYgQi40LjEgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmQgPSBDVVJWRS5yYW5kb21CeXRlcyhGcC5CWVRFUyArIDgpO1xuICAgICAgICAgICAgY29uc3QgbnVtID0gbW9kLmhhc2hUb1ByaXZhdGVTY2FsYXIocmFuZCwgQ1VSVkVfT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUsIEZwLkJZVEVTKSk7IC8vIGNoZWNrIGZvciBiZWluZyBvZiBzaXplIEJZVEVTXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogRnJvbSBkcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/modular.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * âˆšn = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'â‹…G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x â‰¥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = xÂ³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'â‰¥n. Ret bytes(d'â‹…G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'â‹…G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r â‰¥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s â‰¥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sâ‹…G - eâ‹…P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) â‰  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ087QUFDTztBQUNpQztBQUMxQjtBQUN0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZXNtXFxzZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDTztBQUNQO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF9hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxjcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/hkdf.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hkdf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9oa2RmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrQztBQUNHO0FBQ0o7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxXQUFXLDhDQUFJLE9BQU8sa0RBQU8sUUFBUSxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx1REFBVztBQUNmLElBQUkseURBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBSTtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcaGtkZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSB7XG4gICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgLy8gTk9URTogc29tZSBsaWJyYXJpZXMgdHJlYXQgemVyby1sZW5ndGggYXJyYXkgYXMgJ25vdCBwcm92aWRlZCc7XG4gICAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5vdXRwdXRMZW4pOyAvLyBpZiBub3QgcHJvdmlkZWQsIGl0IGlzIHNldCB0byBhIHN0cmluZyBvZiBIYXNoTGVuIHplcm9zXG4gICAgcmV0dXJuIGhtYWMoaGFzaCwgdG9CeXRlcyhzYWx0KSwgdG9CeXRlcyhpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSBuZXcgVWludDhBcnJheShbMF0pO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gbmV3IFVpbnQ4QXJyYXkoKTtcbi8qKlxuICogSEtERi1leHBhbmQgZnJvbSB0aGUgc3BlYy5cbiAqIEBwYXJhbSBwcmsgLSBhIHBzZXVkb3JhbmRvbSBrZXkgb2YgYXQgbGVhc3QgSGFzaExlbiBvY3RldHMgKHVzdWFsbHksIHRoZSBvdXRwdXQgZnJvbSB0aGUgZXh0cmFjdCBzdGVwKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiAoY2FuIGJlIGEgemVyby1sZW5ndGggc3RyaW5nKVxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICBhc3NlcnQubnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBoYXNoLm91dHB1dExlbik7XG4gICAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/hkdf.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDUztBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVc7QUFDbkIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLFFBQVEsd0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxobWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLDBEQUFlO0FBQzlCLGVBQWUsMERBQWU7QUFDckMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUcsT0FBTyxLQUFLO0FBQy9FO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSyxPQUFPLEtBQUs7QUFDbEY7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMsZ0JBQWdCLE1BQU07QUFDOUU7QUFDQTtBQUNBLGtCQUFrQixRQUFRLEdBQUcsNEJBQTRCLEVBQUUsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBLHdEQUF3RCxZQUFZLEdBQUcsSUFBSSxrQkFBa0IsTUFBTTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksY0FBYyxJQUFJO0FBQ3pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnRUFBZ0UsVUFBVSxjQUFjLFNBQVM7QUFDakc7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCO0FBQzNCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmFzZVxcbGliXFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXNcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gLypAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDsgLy8gYml0d2lzZSBwb3NpdGlvbiBpbiBjdXJyZW50IGVsZW1lbnRcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgY29uc3QgYmFzZTE2ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMybm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4bm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjRub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@scure/bip32/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HARDENED_OFFSET: () => (/* binding */ HARDENED_OFFSET),\n/* harmony export */   HDKey: () => (/* binding */ HDKey)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/base */ \"(pages-dir-browser)/./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\n\n\n\nconst Point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint;\nconst base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_2__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.hexToBytes)(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('Bitcoin seed');\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nconst HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_5__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256)(data));\nconst fromU32 = (data) => (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.createView)(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.createView)(buf).setUint32(0, n, false);\n    return buf;\n};\nclass HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__.bytes)(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_7__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_8__.sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.createView)(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            if (!m || m.length !== 3) {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m[1];\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(new Uint8Array([0]), priv, data);\n        }\n        else {\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(this.pubKey, data);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_7__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_8__.sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            if (this.privateKey) {\n                const added = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_1__.mod)(this.privKey + childTweak, _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE.n);\n                if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__.bytes)(hash, 32);\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__.bytes)(hash, 32);\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__.bytes)(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_6__.bytes)(key, 33);\n        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNVO0FBQ047QUFDQTtBQUNlO0FBQ3NDO0FBQ3ZDO0FBQ1A7QUFDTTtBQUMzRCxjQUFjLDhEQUFJO0FBQ2xCLG9CQUFvQix3REFBYSxDQUFDLHdEQUFNO0FBQ3hDO0FBQ0EsdUJBQXVCLCtEQUFVLFFBQVE7QUFDekM7QUFDQTtBQUNBLFdBQVcsK0RBQVU7QUFDckI7QUFDQSxzQkFBc0IsZ0VBQVc7QUFDakMsMkJBQTJCO0FBQ3BCO0FBQ1AsMEJBQTBCLGtFQUFTLENBQUMsNERBQU07QUFDMUMsMEJBQTBCLCtEQUFVO0FBQ3BDO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0EsSUFBSSwrREFBVTtBQUNkO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0VBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQVc7QUFDbkI7QUFDQSx3REFBd0QsWUFBWSxzQ0FBc0M7QUFDMUc7QUFDQSxrQkFBa0Isd0RBQUksQ0FBQyx3REFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQVc7QUFDOUI7QUFDQTtBQUNBLG1CQUFtQixnRUFBVztBQUM5QjtBQUNBLGtCQUFrQix3REFBSSxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLDhEQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQUcsNEJBQTRCLDhEQUFJO0FBQ2pFLHFCQUFxQiw4REFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CLGVBQWUsOERBQUk7QUFDbkI7QUFDQTtBQUNBLFFBQVEsMkRBQVc7QUFDbkIsUUFBUSwyREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQVc7QUFDbkIsZUFBZSxnRUFBVztBQUMxQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDMyXFxsaWJcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyByaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTUxMic7XG5pbXBvcnQgeyBieXRlcyBhcyBhc3NlcnRCeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvX2Fzc2VydCc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBjb25jYXRCeXRlcywgY3JlYXRlVmlldywgaGV4VG9CeXRlcywgdXRmOFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0IHsgbW9kIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbmltcG9ydCB7IGJhc2U1OGNoZWNrIGFzIGJhc2U1OGNoZWNrZXIgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG5jb25zdCBQb2ludCA9IHNlY3AuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgYmFzZTU4Y2hlY2sgPSBiYXNlNThjaGVja2VyKHNoYTI1Nik7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke2J5dGVzVG9IZXgoYnl0ZXMpfWApO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyhudW0pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpKTtcbn1cbmNvbnN0IE1BU1RFUl9TRUNSRVQgPSB1dGY4VG9CeXRlcygnQml0Y29pbiBzZWVkJyk7XG5jb25zdCBCSVRDT0lOX1ZFUlNJT05TID0geyBwcml2YXRlOiAweDA0ODhhZGU0LCBwdWJsaWM6IDB4MDQ4OGIyMWUgfTtcbmV4cG9ydCBjb25zdCBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuY29uc3QgaGFzaDE2MCA9IChkYXRhKSA9PiByaXBlbWQxNjAoc2hhMjU2KGRhdGEpKTtcbmNvbnN0IGZyb21VMzIgPSAoZGF0YSkgPT4gY3JlYXRlVmlldyhkYXRhKS5nZXRVaW50MzIoMCwgZmFsc2UpO1xuY29uc3QgdG9VMzIgPSAobikgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDIgKiogMzIgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXI9JHtufS4gU2hvdWxkIGJlIGZyb20gMCB0byAyICoqIDMyIC0gMWApO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjcmVhdGVWaWV3KGJ1Zikuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydCBjbGFzcyBIREtleSB7XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucHViSGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVTMyKHRoaXMucHViSGFzaCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICAgIH1cbiAgICBnZXQgcHViS2V5SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZLZXlCeXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCFwcml2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnByaXZhdGUsIGNvbmNhdEJ5dGVzKG5ldyBVaW50OEFycmF5KFswXSksIHByaXYpKSk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJLZXkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NYXN0ZXJTZWVkKHNlZWQsIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICBhc3NlcnRCeXRlcyhzZWVkKTtcbiAgICAgICAgaWYgKDggKiBzZWVkLmxlbmd0aCA8IDEyOCB8fCA4ICogc2VlZC5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSERLZXk6IHdyb25nIHNlZWQgbGVuZ3RoPSR7c2VlZC5sZW5ndGh9LiBTaG91bGQgYmUgYmV0d2VlbiAxMjggYW5kIDUxMiBiaXRzOyAyNTYgYml0cyBpcyBhZHZpc2VkKWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgTUFTVEVSX1NFQ1JFVCwgc2VlZCk7XG4gICAgICAgIHJldHVybiBuZXcgSERLZXkoe1xuICAgICAgICAgICAgdmVyc2lvbnMsXG4gICAgICAgICAgICBjaGFpbkNvZGU6IEkuc2xpY2UoMzIpLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogSS5zbGljZSgwLCAzMiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGJhc2U1OGtleSwgdmVyc2lvbnMgPSBCSVRDT0lOX1ZFUlNJT05TKSB7XG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IGJhc2U1OGNoZWNrLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gY3JlYXRlVmlldyhrZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0ga2V5Vmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGRlcHRoOiBrZXlCdWZmZXJbNF0sXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDoga2V5Vmlldy5nZXRVaW50MzIoNSwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZXg6IGtleVZpZXcuZ2V0VWludDMyKDksIGZhbHNlKSxcbiAgICAgICAgICAgIGNoYWluQ29kZToga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSk7XG4gICAgICAgIGNvbnN0IGlzUHJpdiA9IGtleVswXSA9PT0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHZlcnNpb25zW2lzUHJpdiA/ICdwcml2YXRlJyA6ICdwdWJsaWMnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpdikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHVibGljS2V5OiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShqc29uLnhwcml2KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG9wdC5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gb3B0LnBhcmVudEZpbmdlcnByaW50IHx8IDA7XG4gICAgICAgIGlmICghdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnB1YmxpY0tleSAmJiBvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogcHVibGljS2V5IGFuZCBwcml2YXRlS2V5IGF0IHNhbWUgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkob3B0LnByaXZhdGVLZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gUG9pbnQuZnJvbUhleChvcHQucHVibGljS2V5KS50b1Jhd0J5dGVzKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogbm8gcHVibGljIG9yIHByaXZhdGUga2V5IHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdWJIYXNoID0gaGFzaDE2MCh0aGlzLnB1YktleSk7XG4gICAgfVxuICAgIGRlcml2ZShwYXRoKSB7XG4gICAgICAgIGlmICghL15bbU1dJz8vLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IHN0YXJ0IHdpdGggXCJtXCIgb3IgXCJNXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bbU1dJz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGgucmVwbGFjZSgvXlttTV0nP1xcLy8sICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXihcXGQrKSgnPykkLy5leGVjKGMpO1xuICAgICAgICAgICAgaWYgKCFtIHx8IG0ubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoaWxkIGluZGV4OiAke2N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWR4ID0gK21bMV07XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlkeCkgfHwgaWR4ID49IEhBUkRFTkVEX09GRlNFVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMl0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgaWR4ICs9IEhBUkRFTkVEX09GRlNFVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuZGVyaXZlQ2hpbGQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGRlcml2ZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJLZXkgfHwgIXRoaXMuY2hhaW5Db2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBvciBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSB0b1UzMihpbmRleCk7XG4gICAgICAgIGlmIChpbmRleCA+PSBIQVJERU5FRF9PRkZTRVQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaXYgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgICAgICBpZiAoIXByaXYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gY29uY2F0Qnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzBdKSwgcHJpdiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gY29uY2F0Qnl0ZXModGhpcy5wdWJLZXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgdGhpcy5jaGFpbkNvZGUsIGRhdGEpO1xuICAgICAgICBjb25zdCBjaGlsZFR3ZWFrID0gYnl0ZXNUb051bWJlcihJLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IEkuc2xpY2UoMzIpO1xuICAgICAgICBpZiAoIXNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoY2hpbGRUd2VhaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHdlYWsgYmlnZ2VyIHRoYW4gY3VydmUgb3JkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uczogdGhpcy52ZXJzaW9ucyxcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoICsgMSxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWQgPSBtb2QodGhpcy5wcml2S2V5ICsgY2hpbGRUd2Vhaywgc2VjcC5DVVJWRS5uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoYWRkZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LnByaXZhdGVLZXkgPSBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gUG9pbnQuZnJvbUhleCh0aGlzLnB1YktleSkuYWRkKFBvaW50LmZyb21Qcml2YXRlS2V5KGNoaWxkVHdlYWspKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQuZXF1YWxzKFBvaW50LlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LnB1YmxpY0tleSA9IGFkZGVkLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJpdmF0ZUtleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoaGFzaCwgMzIpO1xuICAgICAgICByZXR1cm4gc2VjcC5zaWduKGhhc2gsIHRoaXMucHJpdktleSkudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRCeXRlcyhoYXNoLCAzMik7XG4gICAgICAgIGFzc2VydEJ5dGVzKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoa2V5LCAzMyk7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyh0b1UzMih2ZXJzaW9uKSwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuZGVwdGhdKSwgdG9VMzIodGhpcy5wYXJlbnRGaW5nZXJwcmludCksIHRvVTMyKHRoaXMuaW5kZXgpLCB0aGlzLmNoYWluQ29kZSwga2V5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/lib/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDMyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF9hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDMyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF91NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCLFFBQVEsaURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDMyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXGhtYWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1c7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsMENBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBLG9EQUFvRDtBQUNwRCxzREFBc0Q7QUFDdEQsNERBQTREO0FBQzVELDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsMERBQWU7QUFDeEQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDMyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHJpcGVtZDE2MC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG5jb25zdCBSaG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKF8sIGkpID0+IGkpO1xuY29uc3QgUGkgPSAvKiBAX19QVVJFX18gKi8gSWQubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KTtcbmxldCBpZHhMID0gW0lkXTtcbmxldCBpZHhSID0gW1BpXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAobGV0IGogb2YgW2lkeEwsIGlkeFJdKVxuICAgICAgICBqLnB1c2goaltpXS5tYXAoKGspID0+IFJob1trXSkpO1xuY29uc3Qgc2hpZnRzID0gLyogQF9fUFVSRV9fICovIFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUiA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IEtsID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDUwYTI4YmU2LCAweDVjNGRkMTI0LCAweDZkNzAzZWYzLCAweDdhNmQ3NmU5LCAweDAwMDAwMDAwLFxuXSk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAod29yZCA+Pj4gKDMyIC0gc2hpZnQpKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMSlcbiAgICAgICAgcmV0dXJuICh4ICYgeSkgfCAofnggJiB6KTtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB4IF4gKHkgfCB+eik7XG59XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IEJVRiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuZXhwb3J0IGNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0xbZ3JvdXBdLCBzciA9IHNoaWZ0c1JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgdGhpcy5zZXQoKHRoaXMuaDEgKyBjbCArIGRyKSB8IDAsICh0aGlzLmgyICsgZGwgKyBlcikgfCAwLCAodGhpcy5oMyArIGVsICsgYXIpIHwgMCwgKHRoaXMuaDQgKyBhbCArIGJyKSB8IDAsICh0aGlzLmgwICsgYmwgKyBjcikgfCAwKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQHNjdXJlXFxiaXAzMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2lCO0FBQzdDO0FBQ0E7QUFDQSxzREFBc0QscURBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDBDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekYsd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkYsd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkY7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx3QkFBd0IscURBQVM7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlLEVBQUUsbURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDLGlCQUFpQixxREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLG1DQUFtQywwREFBZTtBQUNsRCxtQ0FBbUMsMERBQWU7QUFDbEQsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQHNjdXJlXFxiaXAzMlxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGE1MTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbi8vIE90aGVyIGxpYnJhcmllcyB3b3VsZCBzaWxlbnRseSBjb3JydXB0IHRoZSBkYXRhIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IsXG4vLyB3aGVuIHRoZXkgZG9uJ3Qgc3VwcG9ydCBpdC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGlmICghaXNCeXRlcyhhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(pages-dir-browser)/./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(entropy, 16, 20, 24, 28, 32);\n}\nfunction generateMnemonic(wordlist, strength = 128) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    const bitsLeft = 8 - entropy.length / 4;\n    return new Uint8Array([((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.alphabet(wordlist));\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNnQjtBQUNiO0FBQ0E7QUFDSTtBQUNEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJLGtFQUFZO0FBQ2hCO0FBQ087QUFDUCxJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9ELEtBQUs7QUFDTCxXQUFXLDhDQUFTLE9BQU8sOENBQVMsNEJBQTRCLDhDQUFTLG1CQUFtQiw4Q0FBUztBQUNyRztBQUNPO0FBQ1AsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ2pEO0FBQ1AsV0FBVyxpRUFBVyxDQUFDLHdEQUFNLGdEQUFnRCxvQkFBb0I7QUFDakc7QUFDTztBQUNQLFdBQVcsNERBQU0sQ0FBQyx3REFBTSxnREFBZ0Qsb0JBQW9CO0FBQzVGO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDM5XFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnQG5vYmxlL2hhc2hlcy9fYXNzZXJ0JztcbmltcG9ydCB7IHBia2RmMiwgcGJrZGYyQXN5bmMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3Bia2RmMic7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTUxMic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgdXRpbHMgYXMgYmFzZVV0aWxzIH0gZnJvbSAnQHNjdXJlL2Jhc2UnO1xuY29uc3QgaXNKYXBhbmVzZSA9ICh3b3JkbGlzdCkgPT4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnO1xuZnVuY3Rpb24gbmZrZChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbW5lbW9uaWMgdHlwZTogJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBzdHIubm9ybWFsaXplKCdORktEJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUoc3RyKSB7XG4gICAgY29uc3Qgbm9ybSA9IG5ma2Qoc3RyKTtcbiAgICBjb25zdCB3b3JkcyA9IG5vcm0uc3BsaXQoJyAnKTtcbiAgICBpZiAoIVsxMiwgMTUsIDE4LCAyMSwgMjRdLmluY2x1ZGVzKHdvcmRzLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtbmVtb25pYycpO1xuICAgIHJldHVybiB7IG5ma2Q6IG5vcm0sIHdvcmRzIH07XG59XG5mdW5jdGlvbiBhc3NlcnRFbnRyb3B5KGVudHJvcHkpIHtcbiAgICBhc3NlcnQuYnl0ZXMoZW50cm9weSwgMTYsIDIwLCAyNCwgMjgsIDMyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIGFzc2VydC5udW1iZXIoc3RyZW5ndGgpO1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwIHx8IHN0cmVuZ3RoID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGVudHJvcHknKTtcbiAgICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMocmFuZG9tQnl0ZXMoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuY29uc3QgY2FsY0NoZWNrc3VtID0gKGVudHJvcHkpID0+IHtcbiAgICBjb25zdCBiaXRzTGVmdCA9IDggLSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsoc2hhMjU2KGVudHJvcHkpWzBdID4+IGJpdHNMZWZ0KSA8PCBiaXRzTGVmdF0pO1xufTtcbmZ1bmN0aW9uIGdldENvZGVyKHdvcmRsaXN0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRsaXN0KSB8fCB3b3JkbGlzdC5sZW5ndGggIT09IDIwNDggfHwgdHlwZW9mIHdvcmRsaXN0WzBdICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JsaXN0OiBleHBlY3RlZCBhcnJheSBvZiAyMDQ4IHN0cmluZ3MnKTtcbiAgICB3b3JkbGlzdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICR7aX1gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZVV0aWxzLmNoYWluKGJhc2VVdGlscy5jaGVja3N1bSgxLCBjYWxjQ2hlY2tzdW0pLCBiYXNlVXRpbHMucmFkaXgyKDExLCB0cnVlKSwgYmFzZVV0aWxzLmFscGhhYmV0KHdvcmRsaXN0KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gbm9ybWFsaXplKG1uZW1vbmljKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Q29kZXIod29yZGxpc3QpLmRlY29kZSh3b3Jkcyk7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGFzc2VydEVudHJvcHkoZW50cm9weSk7XG4gICAgY29uc3Qgd29yZHMgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZW5jb2RlKGVudHJvcHkpO1xuICAgIHJldHVybiB3b3Jkcy5qb2luKGlzSmFwYW5lc2Uod29yZGxpc3QpID8gJ1xcdTMwMDAnIDogJyAnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIHRyeSB7XG4gICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoYG1uZW1vbmljJHtwYXNzcGhyYXNlfWApO1xuZXhwb3J0IGZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gcGJrZGYyQXN5bmMoc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHNhbHQocGFzc3BocmFzZSksIHsgYzogMjA0OCwgZGtMZW46IDY0IH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuIHBia2RmMihzaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/esm/wordlists/english.js":
/*!************************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/wordlists/english.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wordlist: () => (/* binding */ wordlist)\n/* harmony export */ });\nconst wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n//# sourceMappingURL=english.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvZXNtL3dvcmRsaXN0cy9lbmdsaXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDM5XFxlc21cXHdvcmRsaXN0c1xcZW5nbGlzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgd29yZGxpc3QgPSBgYWJhbmRvblxuYWJpbGl0eVxuYWJsZVxuYWJvdXRcbmFib3ZlXG5hYnNlbnRcbmFic29yYlxuYWJzdHJhY3RcbmFic3VyZFxuYWJ1c2VcbmFjY2Vzc1xuYWNjaWRlbnRcbmFjY291bnRcbmFjY3VzZVxuYWNoaWV2ZVxuYWNpZFxuYWNvdXN0aWNcbmFjcXVpcmVcbmFjcm9zc1xuYWN0XG5hY3Rpb25cbmFjdG9yXG5hY3RyZXNzXG5hY3R1YWxcbmFkYXB0XG5hZGRcbmFkZGljdFxuYWRkcmVzc1xuYWRqdXN0XG5hZG1pdFxuYWR1bHRcbmFkdmFuY2VcbmFkdmljZVxuYWVyb2JpY1xuYWZmYWlyXG5hZmZvcmRcbmFmcmFpZFxuYWdhaW5cbmFnZVxuYWdlbnRcbmFncmVlXG5haGVhZFxuYWltXG5haXJcbmFpcnBvcnRcbmFpc2xlXG5hbGFybVxuYWxidW1cbmFsY29ob2xcbmFsZXJ0XG5hbGllblxuYWxsXG5hbGxleVxuYWxsb3dcbmFsbW9zdFxuYWxvbmVcbmFscGhhXG5hbHJlYWR5XG5hbHNvXG5hbHRlclxuYWx3YXlzXG5hbWF0ZXVyXG5hbWF6aW5nXG5hbW9uZ1xuYW1vdW50XG5hbXVzZWRcbmFuYWx5c3RcbmFuY2hvclxuYW5jaWVudFxuYW5nZXJcbmFuZ2xlXG5hbmdyeVxuYW5pbWFsXG5hbmtsZVxuYW5ub3VuY2VcbmFubnVhbFxuYW5vdGhlclxuYW5zd2VyXG5hbnRlbm5hXG5hbnRpcXVlXG5hbnhpZXR5XG5hbnlcbmFwYXJ0XG5hcG9sb2d5XG5hcHBlYXJcbmFwcGxlXG5hcHByb3ZlXG5hcHJpbFxuYXJjaFxuYXJjdGljXG5hcmVhXG5hcmVuYVxuYXJndWVcbmFybVxuYXJtZWRcbmFybW9yXG5hcm15XG5hcm91bmRcbmFycmFuZ2VcbmFycmVzdFxuYXJyaXZlXG5hcnJvd1xuYXJ0XG5hcnRlZmFjdFxuYXJ0aXN0XG5hcnR3b3JrXG5hc2tcbmFzcGVjdFxuYXNzYXVsdFxuYXNzZXRcbmFzc2lzdFxuYXNzdW1lXG5hc3RobWFcbmF0aGxldGVcbmF0b21cbmF0dGFja1xuYXR0ZW5kXG5hdHRpdHVkZVxuYXR0cmFjdFxuYXVjdGlvblxuYXVkaXRcbmF1Z3VzdFxuYXVudFxuYXV0aG9yXG5hdXRvXG5hdXR1bW5cbmF2ZXJhZ2VcbmF2b2NhZG9cbmF2b2lkXG5hd2FrZVxuYXdhcmVcbmF3YXlcbmF3ZXNvbWVcbmF3ZnVsXG5hd2t3YXJkXG5heGlzXG5iYWJ5XG5iYWNoZWxvclxuYmFjb25cbmJhZGdlXG5iYWdcbmJhbGFuY2VcbmJhbGNvbnlcbmJhbGxcbmJhbWJvb1xuYmFuYW5hXG5iYW5uZXJcbmJhclxuYmFyZWx5XG5iYXJnYWluXG5iYXJyZWxcbmJhc2VcbmJhc2ljXG5iYXNrZXRcbmJhdHRsZVxuYmVhY2hcbmJlYW5cbmJlYXV0eVxuYmVjYXVzZVxuYmVjb21lXG5iZWVmXG5iZWZvcmVcbmJlZ2luXG5iZWhhdmVcbmJlaGluZFxuYmVsaWV2ZVxuYmVsb3dcbmJlbHRcbmJlbmNoXG5iZW5lZml0XG5iZXN0XG5iZXRyYXlcbmJldHRlclxuYmV0d2VlblxuYmV5b25kXG5iaWN5Y2xlXG5iaWRcbmJpa2VcbmJpbmRcbmJpb2xvZ3lcbmJpcmRcbmJpcnRoXG5iaXR0ZXJcbmJsYWNrXG5ibGFkZVxuYmxhbWVcbmJsYW5rZXRcbmJsYXN0XG5ibGVha1xuYmxlc3NcbmJsaW5kXG5ibG9vZFxuYmxvc3NvbVxuYmxvdXNlXG5ibHVlXG5ibHVyXG5ibHVzaFxuYm9hcmRcbmJvYXRcbmJvZHlcbmJvaWxcbmJvbWJcbmJvbmVcbmJvbnVzXG5ib29rXG5ib29zdFxuYm9yZGVyXG5ib3JpbmdcbmJvcnJvd1xuYm9zc1xuYm90dG9tXG5ib3VuY2VcbmJveFxuYm95XG5icmFja2V0XG5icmFpblxuYnJhbmRcbmJyYXNzXG5icmF2ZVxuYnJlYWRcbmJyZWV6ZVxuYnJpY2tcbmJyaWRnZVxuYnJpZWZcbmJyaWdodFxuYnJpbmdcbmJyaXNrXG5icm9jY29saVxuYnJva2VuXG5icm9uemVcbmJyb29tXG5icm90aGVyXG5icm93blxuYnJ1c2hcbmJ1YmJsZVxuYnVkZHlcbmJ1ZGdldFxuYnVmZmFsb1xuYnVpbGRcbmJ1bGJcbmJ1bGtcbmJ1bGxldFxuYnVuZGxlXG5idW5rZXJcbmJ1cmRlblxuYnVyZ2VyXG5idXJzdFxuYnVzXG5idXNpbmVzc1xuYnVzeVxuYnV0dGVyXG5idXllclxuYnV6elxuY2FiYmFnZVxuY2FiaW5cbmNhYmxlXG5jYWN0dXNcbmNhZ2VcbmNha2VcbmNhbGxcbmNhbG1cbmNhbWVyYVxuY2FtcFxuY2FuXG5jYW5hbFxuY2FuY2VsXG5jYW5keVxuY2Fubm9uXG5jYW5vZVxuY2FudmFzXG5jYW55b25cbmNhcGFibGVcbmNhcGl0YWxcbmNhcHRhaW5cbmNhclxuY2FyYm9uXG5jYXJkXG5jYXJnb1xuY2FycGV0XG5jYXJyeVxuY2FydFxuY2FzZVxuY2FzaFxuY2FzaW5vXG5jYXN0bGVcbmNhc3VhbFxuY2F0XG5jYXRhbG9nXG5jYXRjaFxuY2F0ZWdvcnlcbmNhdHRsZVxuY2F1Z2h0XG5jYXVzZVxuY2F1dGlvblxuY2F2ZVxuY2VpbGluZ1xuY2VsZXJ5XG5jZW1lbnRcbmNlbnN1c1xuY2VudHVyeVxuY2VyZWFsXG5jZXJ0YWluXG5jaGFpclxuY2hhbGtcbmNoYW1waW9uXG5jaGFuZ2VcbmNoYW9zXG5jaGFwdGVyXG5jaGFyZ2VcbmNoYXNlXG5jaGF0XG5jaGVhcFxuY2hlY2tcbmNoZWVzZVxuY2hlZlxuY2hlcnJ5XG5jaGVzdFxuY2hpY2tlblxuY2hpZWZcbmNoaWxkXG5jaGltbmV5XG5jaG9pY2VcbmNob29zZVxuY2hyb25pY1xuY2h1Y2tsZVxuY2h1bmtcbmNodXJuXG5jaWdhclxuY2lubmFtb25cbmNpcmNsZVxuY2l0aXplblxuY2l0eVxuY2l2aWxcbmNsYWltXG5jbGFwXG5jbGFyaWZ5XG5jbGF3XG5jbGF5XG5jbGVhblxuY2xlcmtcbmNsZXZlclxuY2xpY2tcbmNsaWVudFxuY2xpZmZcbmNsaW1iXG5jbGluaWNcbmNsaXBcbmNsb2NrXG5jbG9nXG5jbG9zZVxuY2xvdGhcbmNsb3VkXG5jbG93blxuY2x1YlxuY2x1bXBcbmNsdXN0ZXJcbmNsdXRjaFxuY29hY2hcbmNvYXN0XG5jb2NvbnV0XG5jb2RlXG5jb2ZmZWVcbmNvaWxcbmNvaW5cbmNvbGxlY3RcbmNvbG9yXG5jb2x1bW5cbmNvbWJpbmVcbmNvbWVcbmNvbWZvcnRcbmNvbWljXG5jb21tb25cbmNvbXBhbnlcbmNvbmNlcnRcbmNvbmR1Y3RcbmNvbmZpcm1cbmNvbmdyZXNzXG5jb25uZWN0XG5jb25zaWRlclxuY29udHJvbFxuY29udmluY2VcbmNvb2tcbmNvb2xcbmNvcHBlclxuY29weVxuY29yYWxcbmNvcmVcbmNvcm5cbmNvcnJlY3RcbmNvc3RcbmNvdHRvblxuY291Y2hcbmNvdW50cnlcbmNvdXBsZVxuY291cnNlXG5jb3VzaW5cbmNvdmVyXG5jb3lvdGVcbmNyYWNrXG5jcmFkbGVcbmNyYWZ0XG5jcmFtXG5jcmFuZVxuY3Jhc2hcbmNyYXRlclxuY3Jhd2xcbmNyYXp5XG5jcmVhbVxuY3JlZGl0XG5jcmVla1xuY3Jld1xuY3JpY2tldFxuY3JpbWVcbmNyaXNwXG5jcml0aWNcbmNyb3BcbmNyb3NzXG5jcm91Y2hcbmNyb3dkXG5jcnVjaWFsXG5jcnVlbFxuY3J1aXNlXG5jcnVtYmxlXG5jcnVuY2hcbmNydXNoXG5jcnlcbmNyeXN0YWxcbmN1YmVcbmN1bHR1cmVcbmN1cFxuY3VwYm9hcmRcbmN1cmlvdXNcbmN1cnJlbnRcbmN1cnRhaW5cbmN1cnZlXG5jdXNoaW9uXG5jdXN0b21cbmN1dGVcbmN5Y2xlXG5kYWRcbmRhbWFnZVxuZGFtcFxuZGFuY2VcbmRhbmdlclxuZGFyaW5nXG5kYXNoXG5kYXVnaHRlclxuZGF3blxuZGF5XG5kZWFsXG5kZWJhdGVcbmRlYnJpc1xuZGVjYWRlXG5kZWNlbWJlclxuZGVjaWRlXG5kZWNsaW5lXG5kZWNvcmF0ZVxuZGVjcmVhc2VcbmRlZXJcbmRlZmVuc2VcbmRlZmluZVxuZGVmeVxuZGVncmVlXG5kZWxheVxuZGVsaXZlclxuZGVtYW5kXG5kZW1pc2VcbmRlbmlhbFxuZGVudGlzdFxuZGVueVxuZGVwYXJ0XG5kZXBlbmRcbmRlcG9zaXRcbmRlcHRoXG5kZXB1dHlcbmRlcml2ZVxuZGVzY3JpYmVcbmRlc2VydFxuZGVzaWduXG5kZXNrXG5kZXNwYWlyXG5kZXN0cm95XG5kZXRhaWxcbmRldGVjdFxuZGV2ZWxvcFxuZGV2aWNlXG5kZXZvdGVcbmRpYWdyYW1cbmRpYWxcbmRpYW1vbmRcbmRpYXJ5XG5kaWNlXG5kaWVzZWxcbmRpZXRcbmRpZmZlclxuZGlnaXRhbFxuZGlnbml0eVxuZGlsZW1tYVxuZGlubmVyXG5kaW5vc2F1clxuZGlyZWN0XG5kaXJ0XG5kaXNhZ3JlZVxuZGlzY292ZXJcbmRpc2Vhc2VcbmRpc2hcbmRpc21pc3NcbmRpc29yZGVyXG5kaXNwbGF5XG5kaXN0YW5jZVxuZGl2ZXJ0XG5kaXZpZGVcbmRpdm9yY2VcbmRpenp5XG5kb2N0b3JcbmRvY3VtZW50XG5kb2dcbmRvbGxcbmRvbHBoaW5cbmRvbWFpblxuZG9uYXRlXG5kb25rZXlcbmRvbm9yXG5kb29yXG5kb3NlXG5kb3VibGVcbmRvdmVcbmRyYWZ0XG5kcmFnb25cbmRyYW1hXG5kcmFzdGljXG5kcmF3XG5kcmVhbVxuZHJlc3NcbmRyaWZ0XG5kcmlsbFxuZHJpbmtcbmRyaXBcbmRyaXZlXG5kcm9wXG5kcnVtXG5kcnlcbmR1Y2tcbmR1bWJcbmR1bmVcbmR1cmluZ1xuZHVzdFxuZHV0Y2hcbmR1dHlcbmR3YXJmXG5keW5hbWljXG5lYWdlclxuZWFnbGVcbmVhcmx5XG5lYXJuXG5lYXJ0aFxuZWFzaWx5XG5lYXN0XG5lYXN5XG5lY2hvXG5lY29sb2d5XG5lY29ub215XG5lZGdlXG5lZGl0XG5lZHVjYXRlXG5lZmZvcnRcbmVnZ1xuZWlnaHRcbmVpdGhlclxuZWxib3dcbmVsZGVyXG5lbGVjdHJpY1xuZWxlZ2FudFxuZWxlbWVudFxuZWxlcGhhbnRcbmVsZXZhdG9yXG5lbGl0ZVxuZWxzZVxuZW1iYXJrXG5lbWJvZHlcbmVtYnJhY2VcbmVtZXJnZVxuZW1vdGlvblxuZW1wbG95XG5lbXBvd2VyXG5lbXB0eVxuZW5hYmxlXG5lbmFjdFxuZW5kXG5lbmRsZXNzXG5lbmRvcnNlXG5lbmVteVxuZW5lcmd5XG5lbmZvcmNlXG5lbmdhZ2VcbmVuZ2luZVxuZW5oYW5jZVxuZW5qb3lcbmVubGlzdFxuZW5vdWdoXG5lbnJpY2hcbmVucm9sbFxuZW5zdXJlXG5lbnRlclxuZW50aXJlXG5lbnRyeVxuZW52ZWxvcGVcbmVwaXNvZGVcbmVxdWFsXG5lcXVpcFxuZXJhXG5lcmFzZVxuZXJvZGVcbmVyb3Npb25cbmVycm9yXG5lcnVwdFxuZXNjYXBlXG5lc3NheVxuZXNzZW5jZVxuZXN0YXRlXG5ldGVybmFsXG5ldGhpY3NcbmV2aWRlbmNlXG5ldmlsXG5ldm9rZVxuZXZvbHZlXG5leGFjdFxuZXhhbXBsZVxuZXhjZXNzXG5leGNoYW5nZVxuZXhjaXRlXG5leGNsdWRlXG5leGN1c2VcbmV4ZWN1dGVcbmV4ZXJjaXNlXG5leGhhdXN0XG5leGhpYml0XG5leGlsZVxuZXhpc3RcbmV4aXRcbmV4b3RpY1xuZXhwYW5kXG5leHBlY3RcbmV4cGlyZVxuZXhwbGFpblxuZXhwb3NlXG5leHByZXNzXG5leHRlbmRcbmV4dHJhXG5leWVcbmV5ZWJyb3dcbmZhYnJpY1xuZmFjZVxuZmFjdWx0eVxuZmFkZVxuZmFpbnRcbmZhaXRoXG5mYWxsXG5mYWxzZVxuZmFtZVxuZmFtaWx5XG5mYW1vdXNcbmZhblxuZmFuY3lcbmZhbnRhc3lcbmZhcm1cbmZhc2hpb25cbmZhdFxuZmF0YWxcbmZhdGhlclxuZmF0aWd1ZVxuZmF1bHRcbmZhdm9yaXRlXG5mZWF0dXJlXG5mZWJydWFyeVxuZmVkZXJhbFxuZmVlXG5mZWVkXG5mZWVsXG5mZW1hbGVcbmZlbmNlXG5mZXN0aXZhbFxuZmV0Y2hcbmZldmVyXG5mZXdcbmZpYmVyXG5maWN0aW9uXG5maWVsZFxuZmlndXJlXG5maWxlXG5maWxtXG5maWx0ZXJcbmZpbmFsXG5maW5kXG5maW5lXG5maW5nZXJcbmZpbmlzaFxuZmlyZVxuZmlybVxuZmlyc3RcbmZpc2NhbFxuZmlzaFxuZml0XG5maXRuZXNzXG5maXhcbmZsYWdcbmZsYW1lXG5mbGFzaFxuZmxhdFxuZmxhdm9yXG5mbGVlXG5mbGlnaHRcbmZsaXBcbmZsb2F0XG5mbG9ja1xuZmxvb3JcbmZsb3dlclxuZmx1aWRcbmZsdXNoXG5mbHlcbmZvYW1cbmZvY3VzXG5mb2dcbmZvaWxcbmZvbGRcbmZvbGxvd1xuZm9vZFxuZm9vdFxuZm9yY2VcbmZvcmVzdFxuZm9yZ2V0XG5mb3JrXG5mb3J0dW5lXG5mb3J1bVxuZm9yd2FyZFxuZm9zc2lsXG5mb3N0ZXJcbmZvdW5kXG5mb3hcbmZyYWdpbGVcbmZyYW1lXG5mcmVxdWVudFxuZnJlc2hcbmZyaWVuZFxuZnJpbmdlXG5mcm9nXG5mcm9udFxuZnJvc3RcbmZyb3duXG5mcm96ZW5cbmZydWl0XG5mdWVsXG5mdW5cbmZ1bm55XG5mdXJuYWNlXG5mdXJ5XG5mdXR1cmVcbmdhZGdldFxuZ2FpblxuZ2FsYXh5XG5nYWxsZXJ5XG5nYW1lXG5nYXBcbmdhcmFnZVxuZ2FyYmFnZVxuZ2FyZGVuXG5nYXJsaWNcbmdhcm1lbnRcbmdhc1xuZ2FzcFxuZ2F0ZVxuZ2F0aGVyXG5nYXVnZVxuZ2F6ZVxuZ2VuZXJhbFxuZ2VuaXVzXG5nZW5yZVxuZ2VudGxlXG5nZW51aW5lXG5nZXN0dXJlXG5naG9zdFxuZ2lhbnRcbmdpZnRcbmdpZ2dsZVxuZ2luZ2VyXG5naXJhZmZlXG5naXJsXG5naXZlXG5nbGFkXG5nbGFuY2VcbmdsYXJlXG5nbGFzc1xuZ2xpZGVcbmdsaW1wc2Vcbmdsb2JlXG5nbG9vbVxuZ2xvcnlcbmdsb3ZlXG5nbG93XG5nbHVlXG5nb2F0XG5nb2RkZXNzXG5nb2xkXG5nb29kXG5nb29zZVxuZ29yaWxsYVxuZ29zcGVsXG5nb3NzaXBcbmdvdmVyblxuZ293blxuZ3JhYlxuZ3JhY2VcbmdyYWluXG5ncmFudFxuZ3JhcGVcbmdyYXNzXG5ncmF2aXR5XG5ncmVhdFxuZ3JlZW5cbmdyaWRcbmdyaWVmXG5ncml0XG5ncm9jZXJ5XG5ncm91cFxuZ3Jvd1xuZ3J1bnRcbmd1YXJkXG5ndWVzc1xuZ3VpZGVcbmd1aWx0XG5ndWl0YXJcbmd1blxuZ3ltXG5oYWJpdFxuaGFpclxuaGFsZlxuaGFtbWVyXG5oYW1zdGVyXG5oYW5kXG5oYXBweVxuaGFyYm9yXG5oYXJkXG5oYXJzaFxuaGFydmVzdFxuaGF0XG5oYXZlXG5oYXdrXG5oYXphcmRcbmhlYWRcbmhlYWx0aFxuaGVhcnRcbmhlYXZ5XG5oZWRnZWhvZ1xuaGVpZ2h0XG5oZWxsb1xuaGVsbWV0XG5oZWxwXG5oZW5cbmhlcm9cbmhpZGRlblxuaGlnaFxuaGlsbFxuaGludFxuaGlwXG5oaXJlXG5oaXN0b3J5XG5ob2JieVxuaG9ja2V5XG5ob2xkXG5ob2xlXG5ob2xpZGF5XG5ob2xsb3dcbmhvbWVcbmhvbmV5XG5ob29kXG5ob3BlXG5ob3JuXG5ob3Jyb3JcbmhvcnNlXG5ob3NwaXRhbFxuaG9zdFxuaG90ZWxcbmhvdXJcbmhvdmVyXG5odWJcbmh1Z2Vcbmh1bWFuXG5odW1ibGVcbmh1bW9yXG5odW5kcmVkXG5odW5ncnlcbmh1bnRcbmh1cmRsZVxuaHVycnlcbmh1cnRcbmh1c2JhbmRcbmh5YnJpZFxuaWNlXG5pY29uXG5pZGVhXG5pZGVudGlmeVxuaWRsZVxuaWdub3JlXG5pbGxcbmlsbGVnYWxcbmlsbG5lc3NcbmltYWdlXG5pbWl0YXRlXG5pbW1lbnNlXG5pbW11bmVcbmltcGFjdFxuaW1wb3NlXG5pbXByb3ZlXG5pbXB1bHNlXG5pbmNoXG5pbmNsdWRlXG5pbmNvbWVcbmluY3JlYXNlXG5pbmRleFxuaW5kaWNhdGVcbmluZG9vclxuaW5kdXN0cnlcbmluZmFudFxuaW5mbGljdFxuaW5mb3JtXG5pbmhhbGVcbmluaGVyaXRcbmluaXRpYWxcbmluamVjdFxuaW5qdXJ5XG5pbm1hdGVcbmlubmVyXG5pbm5vY2VudFxuaW5wdXRcbmlucXVpcnlcbmluc2FuZVxuaW5zZWN0XG5pbnNpZGVcbmluc3BpcmVcbmluc3RhbGxcbmludGFjdFxuaW50ZXJlc3RcbmludG9cbmludmVzdFxuaW52aXRlXG5pbnZvbHZlXG5pcm9uXG5pc2xhbmRcbmlzb2xhdGVcbmlzc3VlXG5pdGVtXG5pdm9yeVxuamFja2V0XG5qYWd1YXJcbmphclxuamF6elxuamVhbG91c1xuamVhbnNcbmplbGx5XG5qZXdlbFxuam9iXG5qb2luXG5qb2tlXG5qb3VybmV5XG5qb3lcbmp1ZGdlXG5qdWljZVxuanVtcFxuanVuZ2xlXG5qdW5pb3Jcbmp1bmtcbmp1c3Rcbmthbmdhcm9vXG5rZWVuXG5rZWVwXG5rZXRjaHVwXG5rZXlcbmtpY2tcbmtpZFxua2lkbmV5XG5raW5kXG5raW5nZG9tXG5raXNzXG5raXRcbmtpdGNoZW5cbmtpdGVcbmtpdHRlblxua2l3aVxua25lZVxua25pZmVcbmtub2NrXG5rbm93XG5sYWJcbmxhYmVsXG5sYWJvclxubGFkZGVyXG5sYWR5XG5sYWtlXG5sYW1wXG5sYW5ndWFnZVxubGFwdG9wXG5sYXJnZVxubGF0ZXJcbmxhdGluXG5sYXVnaFxubGF1bmRyeVxubGF2YVxubGF3XG5sYXduXG5sYXdzdWl0XG5sYXllclxubGF6eVxubGVhZGVyXG5sZWFmXG5sZWFyblxubGVhdmVcbmxlY3R1cmVcbmxlZnRcbmxlZ1xubGVnYWxcbmxlZ2VuZFxubGVpc3VyZVxubGVtb25cbmxlbmRcbmxlbmd0aFxubGVuc1xubGVvcGFyZFxubGVzc29uXG5sZXR0ZXJcbmxldmVsXG5saWFyXG5saWJlcnR5XG5saWJyYXJ5XG5saWNlbnNlXG5saWZlXG5saWZ0XG5saWdodFxubGlrZVxubGltYlxubGltaXRcbmxpbmtcbmxpb25cbmxpcXVpZFxubGlzdFxubGl0dGxlXG5saXZlXG5saXphcmRcbmxvYWRcbmxvYW5cbmxvYnN0ZXJcbmxvY2FsXG5sb2NrXG5sb2dpY1xubG9uZWx5XG5sb25nXG5sb29wXG5sb3R0ZXJ5XG5sb3VkXG5sb3VuZ2VcbmxvdmVcbmxveWFsXG5sdWNreVxubHVnZ2FnZVxubHVtYmVyXG5sdW5hclxubHVuY2hcbmx1eHVyeVxubHlyaWNzXG5tYWNoaW5lXG5tYWRcbm1hZ2ljXG5tYWduZXRcbm1haWRcbm1haWxcbm1haW5cbm1ham9yXG5tYWtlXG5tYW1tYWxcbm1hblxubWFuYWdlXG5tYW5kYXRlXG5tYW5nb1xubWFuc2lvblxubWFudWFsXG5tYXBsZVxubWFyYmxlXG5tYXJjaFxubWFyZ2luXG5tYXJpbmVcbm1hcmtldFxubWFycmlhZ2Vcbm1hc2tcbm1hc3Ncbm1hc3RlclxubWF0Y2hcbm1hdGVyaWFsXG5tYXRoXG5tYXRyaXhcbm1hdHRlclxubWF4aW11bVxubWF6ZVxubWVhZG93XG5tZWFuXG5tZWFzdXJlXG5tZWF0XG5tZWNoYW5pY1xubWVkYWxcbm1lZGlhXG5tZWxvZHlcbm1lbHRcbm1lbWJlclxubWVtb3J5XG5tZW50aW9uXG5tZW51XG5tZXJjeVxubWVyZ2Vcbm1lcml0XG5tZXJyeVxubWVzaFxubWVzc2FnZVxubWV0YWxcbm1ldGhvZFxubWlkZGxlXG5taWRuaWdodFxubWlsa1xubWlsbGlvblxubWltaWNcbm1pbmRcbm1pbmltdW1cbm1pbm9yXG5taW51dGVcbm1pcmFjbGVcbm1pcnJvclxubWlzZXJ5XG5taXNzXG5taXN0YWtlXG5taXhcbm1peGVkXG5taXh0dXJlXG5tb2JpbGVcbm1vZGVsXG5tb2RpZnlcbm1vbVxubW9tZW50XG5tb25pdG9yXG5tb25rZXlcbm1vbnN0ZXJcbm1vbnRoXG5tb29uXG5tb3JhbFxubW9yZVxubW9ybmluZ1xubW9zcXVpdG9cbm1vdGhlclxubW90aW9uXG5tb3RvclxubW91bnRhaW5cbm1vdXNlXG5tb3ZlXG5tb3ZpZVxubXVjaFxubXVmZmluXG5tdWxlXG5tdWx0aXBseVxubXVzY2xlXG5tdXNldW1cbm11c2hyb29tXG5tdXNpY1xubXVzdFxubXV0dWFsXG5teXNlbGZcbm15c3Rlcnlcbm15dGhcbm5haXZlXG5uYW1lXG5uYXBraW5cbm5hcnJvd1xubmFzdHlcbm5hdGlvblxubmF0dXJlXG5uZWFyXG5uZWNrXG5uZWVkXG5uZWdhdGl2ZVxubmVnbGVjdFxubmVpdGhlclxubmVwaGV3XG5uZXJ2ZVxubmVzdFxubmV0XG5uZXR3b3JrXG5uZXV0cmFsXG5uZXZlclxubmV3c1xubmV4dFxubmljZVxubmlnaHRcbm5vYmxlXG5ub2lzZVxubm9taW5lZVxubm9vZGxlXG5ub3JtYWxcbm5vcnRoXG5ub3NlXG5ub3RhYmxlXG5ub3RlXG5ub3RoaW5nXG5ub3RpY2Vcbm5vdmVsXG5ub3dcbm51Y2xlYXJcbm51bWJlclxubnVyc2Vcbm51dFxub2FrXG5vYmV5XG5vYmplY3Rcbm9ibGlnZVxub2JzY3VyZVxub2JzZXJ2ZVxub2J0YWluXG5vYnZpb3VzXG5vY2N1clxub2NlYW5cbm9jdG9iZXJcbm9kb3Jcbm9mZlxub2ZmZXJcbm9mZmljZVxub2Z0ZW5cbm9pbFxub2theVxub2xkXG5vbGl2ZVxub2x5bXBpY1xub21pdFxub25jZVxub25lXG5vbmlvblxub25saW5lXG5vbmx5XG5vcGVuXG5vcGVyYVxub3Bpbmlvblxub3Bwb3NlXG5vcHRpb25cbm9yYW5nZVxub3JiaXRcbm9yY2hhcmRcbm9yZGVyXG5vcmRpbmFyeVxub3JnYW5cbm9yaWVudFxub3JpZ2luYWxcbm9ycGhhblxub3N0cmljaFxub3RoZXJcbm91dGRvb3Jcbm91dGVyXG5vdXRwdXRcbm91dHNpZGVcbm92YWxcbm92ZW5cbm92ZXJcbm93blxub3duZXJcbm94eWdlblxub3lzdGVyXG5vem9uZVxucGFjdFxucGFkZGxlXG5wYWdlXG5wYWlyXG5wYWxhY2VcbnBhbG1cbnBhbmRhXG5wYW5lbFxucGFuaWNcbnBhbnRoZXJcbnBhcGVyXG5wYXJhZGVcbnBhcmVudFxucGFya1xucGFycm90XG5wYXJ0eVxucGFzc1xucGF0Y2hcbnBhdGhcbnBhdGllbnRcbnBhdHJvbFxucGF0dGVyblxucGF1c2VcbnBhdmVcbnBheW1lbnRcbnBlYWNlXG5wZWFudXRcbnBlYXJcbnBlYXNhbnRcbnBlbGljYW5cbnBlblxucGVuYWx0eVxucGVuY2lsXG5wZW9wbGVcbnBlcHBlclxucGVyZmVjdFxucGVybWl0XG5wZXJzb25cbnBldFxucGhvbmVcbnBob3RvXG5waHJhc2VcbnBoeXNpY2FsXG5waWFub1xucGljbmljXG5waWN0dXJlXG5waWVjZVxucGlnXG5waWdlb25cbnBpbGxcbnBpbG90XG5waW5rXG5waW9uZWVyXG5waXBlXG5waXN0b2xcbnBpdGNoXG5waXp6YVxucGxhY2VcbnBsYW5ldFxucGxhc3RpY1xucGxhdGVcbnBsYXlcbnBsZWFzZVxucGxlZGdlXG5wbHVja1xucGx1Z1xucGx1bmdlXG5wb2VtXG5wb2V0XG5wb2ludFxucG9sYXJcbnBvbGVcbnBvbGljZVxucG9uZFxucG9ueVxucG9vbFxucG9wdWxhclxucG9ydGlvblxucG9zaXRpb25cbnBvc3NpYmxlXG5wb3N0XG5wb3RhdG9cbnBvdHRlcnlcbnBvdmVydHlcbnBvd2RlclxucG93ZXJcbnByYWN0aWNlXG5wcmFpc2VcbnByZWRpY3RcbnByZWZlclxucHJlcGFyZVxucHJlc2VudFxucHJldHR5XG5wcmV2ZW50XG5wcmljZVxucHJpZGVcbnByaW1hcnlcbnByaW50XG5wcmlvcml0eVxucHJpc29uXG5wcml2YXRlXG5wcml6ZVxucHJvYmxlbVxucHJvY2Vzc1xucHJvZHVjZVxucHJvZml0XG5wcm9ncmFtXG5wcm9qZWN0XG5wcm9tb3RlXG5wcm9vZlxucHJvcGVydHlcbnByb3NwZXJcbnByb3RlY3RcbnByb3VkXG5wcm92aWRlXG5wdWJsaWNcbnB1ZGRpbmdcbnB1bGxcbnB1bHBcbnB1bHNlXG5wdW1wa2luXG5wdW5jaFxucHVwaWxcbnB1cHB5XG5wdXJjaGFzZVxucHVyaXR5XG5wdXJwb3NlXG5wdXJzZVxucHVzaFxucHV0XG5wdXp6bGVcbnB5cmFtaWRcbnF1YWxpdHlcbnF1YW50dW1cbnF1YXJ0ZXJcbnF1ZXN0aW9uXG5xdWlja1xucXVpdFxucXVpelxucXVvdGVcbnJhYmJpdFxucmFjY29vblxucmFjZVxucmFja1xucmFkYXJcbnJhZGlvXG5yYWlsXG5yYWluXG5yYWlzZVxucmFsbHlcbnJhbXBcbnJhbmNoXG5yYW5kb21cbnJhbmdlXG5yYXBpZFxucmFyZVxucmF0ZVxucmF0aGVyXG5yYXZlblxucmF3XG5yYXpvclxucmVhZHlcbnJlYWxcbnJlYXNvblxucmViZWxcbnJlYnVpbGRcbnJlY2FsbFxucmVjZWl2ZVxucmVjaXBlXG5yZWNvcmRcbnJlY3ljbGVcbnJlZHVjZVxucmVmbGVjdFxucmVmb3JtXG5yZWZ1c2VcbnJlZ2lvblxucmVncmV0XG5yZWd1bGFyXG5yZWplY3RcbnJlbGF4XG5yZWxlYXNlXG5yZWxpZWZcbnJlbHlcbnJlbWFpblxucmVtZW1iZXJcbnJlbWluZFxucmVtb3ZlXG5yZW5kZXJcbnJlbmV3XG5yZW50XG5yZW9wZW5cbnJlcGFpclxucmVwZWF0XG5yZXBsYWNlXG5yZXBvcnRcbnJlcXVpcmVcbnJlc2N1ZVxucmVzZW1ibGVcbnJlc2lzdFxucmVzb3VyY2VcbnJlc3BvbnNlXG5yZXN1bHRcbnJldGlyZVxucmV0cmVhdFxucmV0dXJuXG5yZXVuaW9uXG5yZXZlYWxcbnJldmlld1xucmV3YXJkXG5yaHl0aG1cbnJpYlxucmliYm9uXG5yaWNlXG5yaWNoXG5yaWRlXG5yaWRnZVxucmlmbGVcbnJpZ2h0XG5yaWdpZFxucmluZ1xucmlvdFxucmlwcGxlXG5yaXNrXG5yaXR1YWxcbnJpdmFsXG5yaXZlclxucm9hZFxucm9hc3RcbnJvYm90XG5yb2J1c3RcbnJvY2tldFxucm9tYW5jZVxucm9vZlxucm9va2llXG5yb29tXG5yb3NlXG5yb3RhdGVcbnJvdWdoXG5yb3VuZFxucm91dGVcbnJveWFsXG5ydWJiZXJcbnJ1ZGVcbnJ1Z1xucnVsZVxucnVuXG5ydW53YXlcbnJ1cmFsXG5zYWRcbnNhZGRsZVxuc2FkbmVzc1xuc2FmZVxuc2FpbFxuc2FsYWRcbnNhbG1vblxuc2Fsb25cbnNhbHRcbnNhbHV0ZVxuc2FtZVxuc2FtcGxlXG5zYW5kXG5zYXRpc2Z5XG5zYXRvc2hpXG5zYXVjZVxuc2F1c2FnZVxuc2F2ZVxuc2F5XG5zY2FsZVxuc2Nhblxuc2NhcmVcbnNjYXR0ZXJcbnNjZW5lXG5zY2hlbWVcbnNjaG9vbFxuc2NpZW5jZVxuc2Npc3NvcnNcbnNjb3JwaW9uXG5zY291dFxuc2NyYXBcbnNjcmVlblxuc2NyaXB0XG5zY3J1Ylxuc2VhXG5zZWFyY2hcbnNlYXNvblxuc2VhdFxuc2Vjb25kXG5zZWNyZXRcbnNlY3Rpb25cbnNlY3VyaXR5XG5zZWVkXG5zZWVrXG5zZWdtZW50XG5zZWxlY3RcbnNlbGxcbnNlbWluYXJcbnNlbmlvclxuc2Vuc2VcbnNlbnRlbmNlXG5zZXJpZXNcbnNlcnZpY2VcbnNlc3Npb25cbnNldHRsZVxuc2V0dXBcbnNldmVuXG5zaGFkb3dcbnNoYWZ0XG5zaGFsbG93XG5zaGFyZVxuc2hlZFxuc2hlbGxcbnNoZXJpZmZcbnNoaWVsZFxuc2hpZnRcbnNoaW5lXG5zaGlwXG5zaGl2ZXJcbnNob2NrXG5zaG9lXG5zaG9vdFxuc2hvcFxuc2hvcnRcbnNob3VsZGVyXG5zaG92ZVxuc2hyaW1wXG5zaHJ1Z1xuc2h1ZmZsZVxuc2h5XG5zaWJsaW5nXG5zaWNrXG5zaWRlXG5zaWVnZVxuc2lnaHRcbnNpZ25cbnNpbGVudFxuc2lsa1xuc2lsbHlcbnNpbHZlclxuc2ltaWxhclxuc2ltcGxlXG5zaW5jZVxuc2luZ1xuc2lyZW5cbnNpc3Rlclxuc2l0dWF0ZVxuc2l4XG5zaXplXG5za2F0ZVxuc2tldGNoXG5za2lcbnNraWxsXG5za2luXG5za2lydFxuc2t1bGxcbnNsYWJcbnNsYW1cbnNsZWVwXG5zbGVuZGVyXG5zbGljZVxuc2xpZGVcbnNsaWdodFxuc2xpbVxuc2xvZ2FuXG5zbG90XG5zbG93XG5zbHVzaFxuc21hbGxcbnNtYXJ0XG5zbWlsZVxuc21va2VcbnNtb290aFxuc25hY2tcbnNuYWtlXG5zbmFwXG5zbmlmZlxuc25vd1xuc29hcFxuc29jY2VyXG5zb2NpYWxcbnNvY2tcbnNvZGFcbnNvZnRcbnNvbGFyXG5zb2xkaWVyXG5zb2xpZFxuc29sdXRpb25cbnNvbHZlXG5zb21lb25lXG5zb25nXG5zb29uXG5zb3JyeVxuc29ydFxuc291bFxuc291bmRcbnNvdXBcbnNvdXJjZVxuc291dGhcbnNwYWNlXG5zcGFyZVxuc3BhdGlhbFxuc3Bhd25cbnNwZWFrXG5zcGVjaWFsXG5zcGVlZFxuc3BlbGxcbnNwZW5kXG5zcGhlcmVcbnNwaWNlXG5zcGlkZXJcbnNwaWtlXG5zcGluXG5zcGlyaXRcbnNwbGl0XG5zcG9pbFxuc3BvbnNvclxuc3Bvb25cbnNwb3J0XG5zcG90XG5zcHJheVxuc3ByZWFkXG5zcHJpbmdcbnNweVxuc3F1YXJlXG5zcXVlZXplXG5zcXVpcnJlbFxuc3RhYmxlXG5zdGFkaXVtXG5zdGFmZlxuc3RhZ2VcbnN0YWlyc1xuc3RhbXBcbnN0YW5kXG5zdGFydFxuc3RhdGVcbnN0YXlcbnN0ZWFrXG5zdGVlbFxuc3RlbVxuc3RlcFxuc3RlcmVvXG5zdGlja1xuc3RpbGxcbnN0aW5nXG5zdG9ja1xuc3RvbWFjaFxuc3RvbmVcbnN0b29sXG5zdG9yeVxuc3RvdmVcbnN0cmF0ZWd5XG5zdHJlZXRcbnN0cmlrZVxuc3Ryb25nXG5zdHJ1Z2dsZVxuc3R1ZGVudFxuc3R1ZmZcbnN0dW1ibGVcbnN0eWxlXG5zdWJqZWN0XG5zdWJtaXRcbnN1YndheVxuc3VjY2Vzc1xuc3VjaFxuc3VkZGVuXG5zdWZmZXJcbnN1Z2FyXG5zdWdnZXN0XG5zdWl0XG5zdW1tZXJcbnN1blxuc3VubnlcbnN1bnNldFxuc3VwZXJcbnN1cHBseVxuc3VwcmVtZVxuc3VyZVxuc3VyZmFjZVxuc3VyZ2VcbnN1cnByaXNlXG5zdXJyb3VuZFxuc3VydmV5XG5zdXNwZWN0XG5zdXN0YWluXG5zd2FsbG93XG5zd2FtcFxuc3dhcFxuc3dhcm1cbnN3ZWFyXG5zd2VldFxuc3dpZnRcbnN3aW1cbnN3aW5nXG5zd2l0Y2hcbnN3b3JkXG5zeW1ib2xcbnN5bXB0b21cbnN5cnVwXG5zeXN0ZW1cbnRhYmxlXG50YWNrbGVcbnRhZ1xudGFpbFxudGFsZW50XG50YWxrXG50YW5rXG50YXBlXG50YXJnZXRcbnRhc2tcbnRhc3RlXG50YXR0b29cbnRheGlcbnRlYWNoXG50ZWFtXG50ZWxsXG50ZW5cbnRlbmFudFxudGVubmlzXG50ZW50XG50ZXJtXG50ZXN0XG50ZXh0XG50aGFua1xudGhhdFxudGhlbWVcbnRoZW5cbnRoZW9yeVxudGhlcmVcbnRoZXlcbnRoaW5nXG50aGlzXG50aG91Z2h0XG50aHJlZVxudGhyaXZlXG50aHJvd1xudGh1bWJcbnRodW5kZXJcbnRpY2tldFxudGlkZVxudGlnZXJcbnRpbHRcbnRpbWJlclxudGltZVxudGlueVxudGlwXG50aXJlZFxudGlzc3VlXG50aXRsZVxudG9hc3RcbnRvYmFjY29cbnRvZGF5XG50b2RkbGVyXG50b2VcbnRvZ2V0aGVyXG50b2lsZXRcbnRva2VuXG50b21hdG9cbnRvbW9ycm93XG50b25lXG50b25ndWVcbnRvbmlnaHRcbnRvb2xcbnRvb3RoXG50b3BcbnRvcGljXG50b3BwbGVcbnRvcmNoXG50b3JuYWRvXG50b3J0b2lzZVxudG9zc1xudG90YWxcbnRvdXJpc3RcbnRvd2FyZFxudG93ZXJcbnRvd25cbnRveVxudHJhY2tcbnRyYWRlXG50cmFmZmljXG50cmFnaWNcbnRyYWluXG50cmFuc2ZlclxudHJhcFxudHJhc2hcbnRyYXZlbFxudHJheVxudHJlYXRcbnRyZWVcbnRyZW5kXG50cmlhbFxudHJpYmVcbnRyaWNrXG50cmlnZ2VyXG50cmltXG50cmlwXG50cm9waHlcbnRyb3VibGVcbnRydWNrXG50cnVlXG50cnVseVxudHJ1bXBldFxudHJ1c3RcbnRydXRoXG50cnlcbnR1YmVcbnR1aXRpb25cbnR1bWJsZVxudHVuYVxudHVubmVsXG50dXJrZXlcbnR1cm5cbnR1cnRsZVxudHdlbHZlXG50d2VudHlcbnR3aWNlXG50d2luXG50d2lzdFxudHdvXG50eXBlXG50eXBpY2FsXG51Z2x5XG51bWJyZWxsYVxudW5hYmxlXG51bmF3YXJlXG51bmNsZVxudW5jb3ZlclxudW5kZXJcbnVuZG9cbnVuZmFpclxudW5mb2xkXG51bmhhcHB5XG51bmlmb3JtXG51bmlxdWVcbnVuaXRcbnVuaXZlcnNlXG51bmtub3duXG51bmxvY2tcbnVudGlsXG51bnVzdWFsXG51bnZlaWxcbnVwZGF0ZVxudXBncmFkZVxudXBob2xkXG51cG9uXG51cHBlclxudXBzZXRcbnVyYmFuXG51cmdlXG51c2FnZVxudXNlXG51c2VkXG51c2VmdWxcbnVzZWxlc3NcbnVzdWFsXG51dGlsaXR5XG52YWNhbnRcbnZhY3V1bVxudmFndWVcbnZhbGlkXG52YWxsZXlcbnZhbHZlXG52YW5cbnZhbmlzaFxudmFwb3JcbnZhcmlvdXNcbnZhc3RcbnZhdWx0XG52ZWhpY2xlXG52ZWx2ZXRcbnZlbmRvclxudmVudHVyZVxudmVudWVcbnZlcmJcbnZlcmlmeVxudmVyc2lvblxudmVyeVxudmVzc2VsXG52ZXRlcmFuXG52aWFibGVcbnZpYnJhbnRcbnZpY2lvdXNcbnZpY3RvcnlcbnZpZGVvXG52aWV3XG52aWxsYWdlXG52aW50YWdlXG52aW9saW5cbnZpcnR1YWxcbnZpcnVzXG52aXNhXG52aXNpdFxudmlzdWFsXG52aXRhbFxudml2aWRcbnZvY2FsXG52b2ljZVxudm9pZFxudm9sY2Fub1xudm9sdW1lXG52b3RlXG52b3lhZ2VcbndhZ2VcbndhZ29uXG53YWl0XG53YWxrXG53YWxsXG53YWxudXRcbndhbnRcbndhcmZhcmVcbndhcm1cbndhcnJpb3Jcbndhc2hcbndhc3Bcbndhc3RlXG53YXRlclxud2F2ZVxud2F5XG53ZWFsdGhcbndlYXBvblxud2Vhclxud2Vhc2VsXG53ZWF0aGVyXG53ZWJcbndlZGRpbmdcbndlZWtlbmRcbndlaXJkXG53ZWxjb21lXG53ZXN0XG53ZXRcbndoYWxlXG53aGF0XG53aGVhdFxud2hlZWxcbndoZW5cbndoZXJlXG53aGlwXG53aGlzcGVyXG53aWRlXG53aWR0aFxud2lmZVxud2lsZFxud2lsbFxud2luXG53aW5kb3dcbndpbmVcbndpbmdcbndpbmtcbndpbm5lclxud2ludGVyXG53aXJlXG53aXNkb21cbndpc2Vcbndpc2hcbndpdG5lc3NcbndvbGZcbndvbWFuXG53b25kZXJcbndvb2Rcbndvb2xcbndvcmRcbndvcmtcbndvcmxkXG53b3JyeVxud29ydGhcbndyYXBcbndyZWNrXG53cmVzdGxlXG53cmlzdFxud3JpdGVcbndyb25nXG55YXJkXG55ZWFyXG55ZWxsb3dcbnlvdVxueW91bmdcbnlvdXRoXG56ZWJyYVxuemVyb1xuem9uZVxuem9vYC5zcGxpdCgnXFxuJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdsaXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/esm/wordlists/english.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDM5XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF9hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzlcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDM5XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXF91NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzlcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCLFFBQVEsaURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxAc2N1cmVcXGJpcDM5XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXGhtYWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Ucâˆ’1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Ucâˆ’1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRTtBQUN6QztBQUNzQztBQUN2RTtBQUNBO0FBQ0EsSUFBSSxnREFBVTtBQUNkLGlCQUFpQixvREFBUyxHQUFHLDBCQUEwQjtBQUN2RCxZQUFZLHNCQUFzQjtBQUNsQyxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBO0FBQ0EscUJBQXFCLGtEQUFPO0FBQzVCLGlCQUFpQixrREFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQUk7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ087QUFDUCxZQUFZLDZCQUE2QjtBQUN6QyxjQUFjO0FBQ2Q7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzlcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxccGJrZGYyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgbnVtYmVyIGFzIGFzc2VydE51bWJlciB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIHRvQnl0ZXMsIGNoZWNrT3B0cywgYXN5bmNMb29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICAgIGFzc2VydE51bWJlcihjKTtcbiAgICBhc3NlcnROdW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xuICAgIGlmIChjIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQktERjI6IGl0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSB0b0J5dGVzKF9wYXNzd29yZCk7XG4gICAgY29uc3Qgc2FsdCA9IHRvQnl0ZXMoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgdS5maWxsKDApO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQHNjdXJlXFxiaXAzOVxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2lCO0FBQzdDO0FBQ0E7QUFDQSxzREFBc0QscURBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDBDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekYsd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkYsd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkY7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx3QkFBd0IscURBQVM7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlLEVBQUUsbURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDLGlCQUFpQixxREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLG1DQUFtQywwREFBZTtBQUNsRCxtQ0FBbUMsMERBQWU7QUFDbEQsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcQHNjdXJlXFxiaXAzOVxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGE1MTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXEBzY3VyZVxcYmlwMzlcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbi8vIE90aGVyIGxpYnJhcmllcyB3b3VsZCBzaWxlbnRseSBjb3JydXB0IHRoZSBkYXRhIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IsXG4vLyB3aGVuIHRoZXkgZG9uJ3Qgc3VwcG9ydCBpdC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGlmICghaXNCeXRlcyhhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/nostr-tools/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nostr-tools/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kind: () => (/* binding */ Kind),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   eventsGenerator: () => (/* binding */ eventsGenerator),\n/* harmony export */   finishEvent: () => (/* binding */ finishEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generatePrivateKey: () => (/* binding */ generatePrivateKey),\n/* harmony export */   getBlankEvent: () => (/* binding */ getBlankEvent),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip06: () => (/* binding */ nip06_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip26: () => (/* binding */ nip26_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   relayInit: () => (/* binding */ relayInit),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   signEvent: () => (/* binding */ signEvent),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(pages-dir-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(pages-dir-browser)/./node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _scure_bip39_wordlists_english__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/bip39/wordlists/english */ \"(pages-dir-browser)/./node_modules/@scure/bip39/esm/wordlists/english.js\");\n/* harmony import */ var _scure_bip39__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @scure/bip39 */ \"(pages-dir-browser)/./node_modules/@scure/bip39/esm/index.js\");\n/* harmony import */ var _scure_bip32__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @scure/bip32 */ \"(pages-dir-browser)/./node_modules/@scure/bip32/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(pages-dir-browser)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(pages-dir-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// keys.ts\n\n\nfunction generatePrivateKey() {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.utils.randomPrivateKey());\n}\nfunction getPublicKey(privateKey) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.getPublicKey(privateKey));\n}\n\n// event.ts\n\n\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  MessageNode: () => MessageNode,\n  MessageQueue: () => MessageQueue,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  let start = 0;\n  let end = sortedArray.length - 1;\n  let midPoint;\n  let position = start;\n  if (end < 0) {\n    position = 0;\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1;\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start;\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end;\n        break;\n      }\n      midPoint = Math.floor(start + (end - start) / 2);\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint;\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint;\n      } else {\n        position = midPoint;\n        break;\n      }\n    }\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)];\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  let start = 0;\n  let end = sortedArray.length - 1;\n  let midPoint;\n  let position = start;\n  if (end < 0) {\n    position = 0;\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1;\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start;\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end;\n        break;\n      }\n      midPoint = Math.floor(start + (end - start) / 2);\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint;\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint;\n      } else {\n        position = midPoint;\n        break;\n      }\n    }\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)];\n  }\n  return sortedArray;\n}\nvar MessageNode = class {\n  _value;\n  _next;\n  get value() {\n    return this._value;\n  }\n  set value(message) {\n    this._value = message;\n  }\n  get next() {\n    return this._next;\n  }\n  set next(node) {\n    this._next = node;\n  }\n  constructor(message) {\n    this._value = message;\n    this._next = null;\n  }\n};\nvar MessageQueue = class {\n  _first;\n  _last;\n  get first() {\n    return this._first;\n  }\n  set first(messageNode) {\n    this._first = messageNode;\n  }\n  get last() {\n    return this._last;\n  }\n  set last(messageNode) {\n    this._last = messageNode;\n  }\n  _size;\n  get size() {\n    return this._size;\n  }\n  set size(v) {\n    this._size = v;\n  }\n  constructor() {\n    this._first = null;\n    this._last = null;\n    this._size = 0;\n  }\n  enqueue(message) {\n    const newNode = new MessageNode(message);\n    if (this._size === 0 || !this._last) {\n      this._first = newNode;\n      this._last = newNode;\n    } else {\n      this._last.next = newNode;\n      this._last = newNode;\n    }\n    this._size++;\n    return true;\n  }\n  dequeue() {\n    if (this._size === 0 || !this._first)\n      return null;\n    let prev = this._first;\n    this._first = prev.next;\n    prev.next = null;\n    this._size--;\n    return prev.value;\n  }\n};\n\n// event.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar Kind = /* @__PURE__ */ ((Kind3) => {\n  Kind3[Kind3[\"Metadata\"] = 0] = \"Metadata\";\n  Kind3[Kind3[\"Text\"] = 1] = \"Text\";\n  Kind3[Kind3[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  Kind3[Kind3[\"Contacts\"] = 3] = \"Contacts\";\n  Kind3[Kind3[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  Kind3[Kind3[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  Kind3[Kind3[\"Repost\"] = 6] = \"Repost\";\n  Kind3[Kind3[\"Reaction\"] = 7] = \"Reaction\";\n  Kind3[Kind3[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  Kind3[Kind3[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  Kind3[Kind3[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  Kind3[Kind3[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  Kind3[Kind3[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  Kind3[Kind3[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  Kind3[Kind3[\"Blank\"] = 255] = \"Blank\";\n  Kind3[Kind3[\"Report\"] = 1984] = \"Report\";\n  Kind3[Kind3[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  Kind3[Kind3[\"Zap\"] = 9735] = \"Zap\";\n  Kind3[Kind3[\"RelayList\"] = 10002] = \"RelayList\";\n  Kind3[Kind3[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  Kind3[Kind3[\"NwcRequest\"] = 23194] = \"NwcRequest\";\n  Kind3[Kind3[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  Kind3[Kind3[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  Kind3[Kind3[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  Kind3[Kind3[\"Article\"] = 30023] = \"Article\";\n  Kind3[Kind3[\"FileMetadata\"] = 1063] = \"FileMetadata\";\n  return Kind3;\n})(Kind || {});\nfunction getBlankEvent(kind = 255 /* Blank */) {\n  return {\n    kind,\n    content: \"\",\n    tags: [],\n    created_at: 0\n  };\n}\nfunction finishEvent(t, privateKey) {\n  const event = t;\n  event.pubkey = getPublicKey(privateKey);\n  event.id = getEventHash(event);\n  event.sig = getSignature(event, privateKey);\n  event[verifiedSymbol] = true;\n  return event;\n}\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(eventHash);\n}\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction verifySignature(event) {\n  if (typeof event[verifiedSymbol] === \"boolean\")\n    return event[verifiedSymbol];\n  const hash = getEventHash(event);\n  if (hash !== event.id) {\n    return event[verifiedSymbol] = false;\n  }\n  try {\n    return event[verifiedSymbol] = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.verify(event.sig, hash, event.pubkey);\n  } catch (err) {\n    return event[verifiedSymbol] = false;\n  }\n}\nfunction signEvent(event, key) {\n  console.warn(\n    \"nostr-tools: `signEvent` is deprecated and will be removed or changed in the future. Please use `getSignature` instead.\"\n  );\n  return getSignature(event, key);\n}\nfunction getSignature(event, key) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.sign(getEventHash(event), key));\n}\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    if (!filter.ids.some((prefix) => event.id.startsWith(prefix))) {\n      return false;\n    }\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1)\n    return false;\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    if (!filter.authors.some((prefix) => event.pubkey.startsWith(prefix))) {\n      return false;\n    }\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event))\n      return true;\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i = 0; i < filters.length; i++) {\n    let filter = filters[i];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// relay.ts\nvar newListeners = () => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: []\n});\nfunction relayInit(url, options = {}) {\n  let { listTimeout = 3e3, getTimeout = 3e3, countTimeout = 3e3 } = options;\n  var ws;\n  var openSubs = {};\n  var listeners = newListeners();\n  var subListeners = {};\n  var pubListeners = {};\n  var connectionPromise;\n  async function connectRelay() {\n    if (connectionPromise)\n      return connectionPromise;\n    connectionPromise = new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url);\n      } catch (err) {\n        reject(err);\n      }\n      ws.onopen = () => {\n        listeners.connect.forEach((cb) => cb());\n        resolve();\n      };\n      ws.onerror = () => {\n        connectionPromise = void 0;\n        listeners.error.forEach((cb) => cb());\n        reject();\n      };\n      ws.onclose = async () => {\n        connectionPromise = void 0;\n        listeners.disconnect.forEach((cb) => cb());\n      };\n      let incomingMessageQueue = new MessageQueue();\n      let handleNextInterval;\n      ws.onmessage = (e) => {\n        incomingMessageQueue.enqueue(e.data);\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0);\n        }\n      };\n      function handleNext() {\n        if (incomingMessageQueue.size === 0) {\n          clearInterval(handleNextInterval);\n          handleNextInterval = null;\n          return;\n        }\n        var json = incomingMessageQueue.dequeue();\n        if (!json)\n          return;\n        let subid = getSubscriptionId(json);\n        if (subid) {\n          let so = openSubs[subid];\n          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, \"id\"), url)) {\n            return;\n          }\n        }\n        try {\n          let data = JSON.parse(json);\n          switch (data[0]) {\n            case \"EVENT\": {\n              let id2 = data[1];\n              let event = data[2];\n              if (validateEvent(event) && openSubs[id2] && (openSubs[id2].skipVerification || verifySignature(event)) && matchFilters(openSubs[id2].filters, event)) {\n                openSubs[id2];\n                (subListeners[id2]?.event || []).forEach((cb) => cb(event));\n              }\n              return;\n            }\n            case \"COUNT\":\n              let id = data[1];\n              let payload = data[2];\n              if (openSubs[id]) {\n                ;\n                (subListeners[id]?.count || []).forEach((cb) => cb(payload));\n              }\n              return;\n            case \"EOSE\": {\n              let id2 = data[1];\n              if (id2 in subListeners) {\n                subListeners[id2].eose.forEach((cb) => cb());\n                subListeners[id2].eose = [];\n              }\n              return;\n            }\n            case \"OK\": {\n              let id2 = data[1];\n              let ok = data[2];\n              let reason = data[3] || \"\";\n              if (id2 in pubListeners) {\n                let { resolve: resolve2, reject: reject2 } = pubListeners[id2];\n                if (ok)\n                  resolve2(null);\n                else\n                  reject2(new Error(reason));\n              }\n              return;\n            }\n            case \"NOTICE\":\n              let notice = data[1];\n              listeners.notice.forEach((cb) => cb(notice));\n              return;\n            case \"AUTH\": {\n              let challenge = data[1];\n              listeners.auth?.forEach((cb) => cb(challenge));\n              return;\n            }\n          }\n        } catch (err) {\n          return;\n        }\n      }\n    });\n    return connectionPromise;\n  }\n  function connected() {\n    return ws?.readyState === 1;\n  }\n  async function connect() {\n    if (connected())\n      return;\n    await connectRelay();\n  }\n  async function trySend(params) {\n    let msg = JSON.stringify(params);\n    if (!connected()) {\n      await new Promise((resolve) => setTimeout(resolve, 1e3));\n      if (!connected()) {\n        return;\n      }\n    }\n    try {\n      ws.send(msg);\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  const sub = (filters, {\n    verb = \"REQ\",\n    skipVerification = false,\n    alreadyHaveEvent = null,\n    id = Math.random().toString().slice(2)\n  } = {}) => {\n    let subid = id;\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent\n    };\n    trySend([verb, subid, ...filters]);\n    let subscription = {\n      sub: (newFilters, newOpts = {}) => sub(newFilters || filters, {\n        skipVerification: newOpts.skipVerification || skipVerification,\n        alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n        id: subid\n      }),\n      unsub: () => {\n        delete openSubs[subid];\n        delete subListeners[subid];\n        trySend([\"CLOSE\", subid]);\n      },\n      on: (type, cb) => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          count: [],\n          eose: []\n        };\n        subListeners[subid][type].push(cb);\n      },\n      off: (type, cb) => {\n        let listeners2 = subListeners[subid];\n        let idx = listeners2[type].indexOf(cb);\n        if (idx >= 0)\n          listeners2[type].splice(idx, 1);\n      },\n      get events() {\n        return eventsGenerator(subscription);\n      }\n    };\n    return subscription;\n  };\n  function _publishEvent(event, type) {\n    return new Promise((resolve, reject) => {\n      if (!event.id) {\n        reject(new Error(`event ${event} has no id`));\n        return;\n      }\n      let id = event.id;\n      trySend([type, event]);\n      pubListeners[id] = { resolve, reject };\n    });\n  }\n  return {\n    url,\n    sub,\n    on: (type, cb) => {\n      listeners[type].push(cb);\n      if (type === \"connect\" && ws?.readyState === 1) {\n        ;\n        cb();\n      }\n    },\n    off: (type, cb) => {\n      let index = listeners[type].indexOf(cb);\n      if (index !== -1)\n        listeners[type].splice(index, 1);\n    },\n    list: (filters, opts) => new Promise((resolve) => {\n      let s = sub(filters, opts);\n      let events = [];\n      let timeout = setTimeout(() => {\n        s.unsub();\n        resolve(events);\n      }, listTimeout);\n      s.on(\"eose\", () => {\n        s.unsub();\n        clearTimeout(timeout);\n        resolve(events);\n      });\n      s.on(\"event\", (event) => {\n        events.push(event);\n      });\n    }),\n    get: (filter, opts) => new Promise((resolve) => {\n      let s = sub([filter], opts);\n      let timeout = setTimeout(() => {\n        s.unsub();\n        resolve(null);\n      }, getTimeout);\n      s.on(\"event\", (event) => {\n        s.unsub();\n        clearTimeout(timeout);\n        resolve(event);\n      });\n    }),\n    count: (filters) => new Promise((resolve) => {\n      let s = sub(filters, { ...sub, verb: \"COUNT\" });\n      let timeout = setTimeout(() => {\n        s.unsub();\n        resolve(null);\n      }, countTimeout);\n      s.on(\"count\", (event) => {\n        s.unsub();\n        clearTimeout(timeout);\n        resolve(event);\n      });\n    }),\n    async publish(event) {\n      await _publishEvent(event, \"EVENT\");\n    },\n    async auth(event) {\n      await _publishEvent(event, \"AUTH\");\n    },\n    connect,\n    close() {\n      listeners = newListeners();\n      subListeners = {};\n      pubListeners = {};\n      if (ws?.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3;\n    }\n  };\n}\nasync function* eventsGenerator(sub) {\n  let nextResolve;\n  const eventQueue = [];\n  const pushToQueue = (event) => {\n    if (nextResolve) {\n      nextResolve(event);\n      nextResolve = void 0;\n    } else {\n      eventQueue.push(event);\n    }\n  };\n  sub.on(\"event\", pushToQueue);\n  try {\n    while (true) {\n      if (eventQueue.length > 0) {\n        yield eventQueue.shift();\n      } else {\n        const event = await new Promise((resolve) => {\n          nextResolve = resolve;\n        });\n        yield event;\n      }\n    }\n  } finally {\n    sub.off(\"event\", pushToQueue);\n  }\n}\n\n// pool.ts\nvar SimplePool = class {\n  _conn;\n  _seenOn = {};\n  batchedByKey = {};\n  eoseSubTimeout;\n  getTimeout;\n  seenOnEnabled = true;\n  batchInterval = 100;\n  constructor(options = {}) {\n    this._conn = {};\n    this.eoseSubTimeout = options.eoseSubTimeout || 3400;\n    this.getTimeout = options.getTimeout || 3400;\n    this.seenOnEnabled = options.seenOnEnabled !== false;\n    this.batchInterval = options.batchInterval || 100;\n  }\n  close(relays) {\n    relays.forEach((url) => {\n      let relay = this._conn[normalizeURL(url)];\n      if (relay)\n        relay.close();\n    });\n  }\n  async ensureRelay(url) {\n    const nm = normalizeURL(url);\n    if (!this._conn[nm]) {\n      this._conn[nm] = relayInit(nm, {\n        getTimeout: this.getTimeout * 0.9,\n        listTimeout: this.getTimeout * 0.9\n      });\n    }\n    const relay = this._conn[nm];\n    await relay.connect();\n    return relay;\n  }\n  sub(relays, filters, opts) {\n    let _knownIds = /* @__PURE__ */ new Set();\n    let modifiedOpts = { ...opts || {} };\n    modifiedOpts.alreadyHaveEvent = (id, url) => {\n      if (opts?.alreadyHaveEvent?.(id, url)) {\n        return true;\n      }\n      if (this.seenOnEnabled) {\n        let set = this._seenOn[id] || /* @__PURE__ */ new Set();\n        set.add(url);\n        this._seenOn[id] = set;\n      }\n      return _knownIds.has(id);\n    };\n    let subs = [];\n    let eventListeners = /* @__PURE__ */ new Set();\n    let eoseListeners = /* @__PURE__ */ new Set();\n    let eosesMissing = relays.length;\n    let eoseSent = false;\n    let eoseTimeout = setTimeout(\n      () => {\n        eoseSent = true;\n        for (let cb of eoseListeners.values())\n          cb();\n      },\n      opts?.eoseSubTimeout || this.eoseSubTimeout\n    );\n    relays.filter((r, i, a) => a.indexOf(r) === i).forEach(async (relay) => {\n      let r;\n      try {\n        r = await this.ensureRelay(relay);\n      } catch (err) {\n        handleEose();\n        return;\n      }\n      if (!r)\n        return;\n      let s = r.sub(filters, modifiedOpts);\n      s.on(\"event\", (event) => {\n        _knownIds.add(event.id);\n        for (let cb of eventListeners.values())\n          cb(event);\n      });\n      s.on(\"eose\", () => {\n        if (eoseSent)\n          return;\n        handleEose();\n      });\n      subs.push(s);\n      function handleEose() {\n        eosesMissing--;\n        if (eosesMissing === 0) {\n          clearTimeout(eoseTimeout);\n          for (let cb of eoseListeners.values())\n            cb();\n        }\n      }\n    });\n    let greaterSub = {\n      sub(filters2, opts2) {\n        subs.forEach((sub) => sub.sub(filters2, opts2));\n        return greaterSub;\n      },\n      unsub() {\n        subs.forEach((sub) => sub.unsub());\n      },\n      on(type, cb) {\n        if (type === \"event\") {\n          eventListeners.add(cb);\n        } else if (type === \"eose\") {\n          eoseListeners.add(cb);\n        }\n      },\n      off(type, cb) {\n        if (type === \"event\") {\n          eventListeners.delete(cb);\n        } else if (type === \"eose\")\n          eoseListeners.delete(cb);\n      },\n      get events() {\n        return eventsGenerator(greaterSub);\n      }\n    };\n    return greaterSub;\n  }\n  get(relays, filter, opts) {\n    return new Promise((resolve) => {\n      let sub = this.sub(relays, [filter], opts);\n      let timeout = setTimeout(() => {\n        sub.unsub();\n        resolve(null);\n      }, this.getTimeout);\n      sub.on(\"event\", (event) => {\n        resolve(event);\n        clearTimeout(timeout);\n        sub.unsub();\n      });\n    });\n  }\n  list(relays, filters, opts) {\n    return new Promise((resolve) => {\n      let events = [];\n      let sub = this.sub(relays, filters, opts);\n      sub.on(\"event\", (event) => {\n        events.push(event);\n      });\n      sub.on(\"eose\", () => {\n        sub.unsub();\n        resolve(events);\n      });\n    });\n  }\n  batchedList(batchKey, relays, filters) {\n    return new Promise((resolve) => {\n      if (!this.batchedByKey[batchKey]) {\n        this.batchedByKey[batchKey] = [\n          {\n            filters,\n            relays,\n            resolve,\n            events: []\n          }\n        ];\n        setTimeout(() => {\n          Object.keys(this.batchedByKey).forEach(async (batchKey2) => {\n            const batchedRequests = this.batchedByKey[batchKey2];\n            const filters2 = [];\n            const relays2 = [];\n            batchedRequests.forEach((br) => {\n              filters2.push(...br.filters);\n              relays2.push(...br.relays);\n            });\n            const sub = this.sub(relays2, [mergeFilters(...filters2)]);\n            sub.on(\"event\", (event) => {\n              batchedRequests.forEach((br) => matchFilters(br.filters, event) && br.events.push(event));\n            });\n            sub.on(\"eose\", () => {\n              sub.unsub();\n              batchedRequests.forEach((br) => br.resolve(br.events));\n            });\n            delete this.batchedByKey[batchKey2];\n          });\n        }, this.batchInterval);\n      } else {\n        this.batchedByKey[batchKey].push({\n          filters,\n          relays,\n          resolve,\n          events: []\n        });\n      }\n    });\n  }\n  publish(relays, event) {\n    return relays.map(async (relay) => {\n      let r = await this.ensureRelay(relay);\n      return r.publish(event);\n    });\n  }\n  seenOn(id) {\n    return Array.from(this._seenOn[id]?.values?.() || []);\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  decode: () => decode,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nrelayEncode: () => nrelayEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nrelay\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nrelay\");\n      return {\n        type: \"nrelay\",\n        data: utf8Decoder.decode(tlv[0][0])\n      };\n    }\n    case \"nsec\":\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    if (!l)\n      throw new Error(`malformed TLV ${t}`);\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(hex) {\n  return encodeBytes(\"nsec\", hex);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", hex);\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", hex);\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, hex) {\n  let data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex);\n  return encodeBech32(prefix, data);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind != void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction nrelayEncode(url) {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)]\n  });\n  return encodeBech32(\"nrelay\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\nif (typeof crypto !== \"undefined\" && !crypto.subtle && crypto.webcrypto) {\n  crypto.subtle = crypto.webcrypto.subtle;\n}\nasync function encrypt(privkey, pubkey, text) {\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let cryptoKey = await crypto.subtle.importKey(\"raw\", normalizedKey, { name: \"AES-CBC\" }, false, [\"encrypt\"]);\n  let ciphertext = await crypto.subtle.encrypt({ name: \"AES-CBC\", iv }, cryptoKey, plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(privkey, pubkey, data) {\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let cryptoKey = await crypto.subtle.importKey(\"raw\", normalizedKey, { name: \"AES-CBC\" }, false, [\"decrypt\"]);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let plaintext = await crypto.subtle.decrypt({ name: \"AES-CBC\", iv }, cryptoKey, ciphertext);\n  let text = utf8Decoder.decode(plaintext);\n  return text;\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch {\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();\n    return res.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [_, name = \"_\", domain] = match;\n  try {\n    const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`);\n    const { names, relays } = parseNIP05Result(await res.json());\n    const pubkey = names[name];\n    return pubkey ? { pubkey, relays: relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// nip06.ts\nvar nip06_exports = {};\n__export(nip06_exports, {\n  generateSeedWords: () => generateSeedWords,\n  privateKeyFromSeedWords: () => privateKeyFromSeedWords,\n  validateWords: () => validateWords\n});\n\n\n\n\nfunction privateKeyFromSeedWords(mnemonic, passphrase) {\n  let root = _scure_bip32__WEBPACK_IMPORTED_MODULE_6__.HDKey.fromMasterSeed((0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.mnemonicToSeedSync)(mnemonic, passphrase));\n  let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;\n  if (!privateKey)\n    throw new Error(\"could not derive private key\");\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(privateKey);\n}\nfunction generateSeedWords() {\n  return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.generateMnemonic)(_scure_bip39_wordlists_english__WEBPACK_IMPORTED_MODULE_4__.wordlist);\n}\nfunction validateWords(words) {\n  return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.validateMnemonic)(words, _scure_bip39_wordlists_english__WEBPACK_IMPORTED_MODULE_4__.wordlist);\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: []\n  };\n  const eTags = [];\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && tag[1]) {\n      eTags.push(tag);\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n    }\n  }\n  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {\n    const eTag = eTags[eTagIndex];\n    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;\n    const eventPointer = {\n      id: eTagEventId,\n      relays: eTagRelayUrl ? [eTagRelayUrl] : []\n    };\n    const isFirstETag = eTagIndex === 0;\n    const isLastETag = eTagIndex === eTags.length - 1;\n    if (eTagMarker === \"root\") {\n      result.root = eventPointer;\n      continue;\n    }\n    if (eTagMarker === \"reply\") {\n      result.reply = eventPointer;\n      continue;\n    }\n    if (eTagMarker === \"mention\") {\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (isFirstETag) {\n      result.root = eventPointer;\n      continue;\n    }\n    if (isLastETag) {\n      result.reply = eventPointer;\n      continue;\n    }\n    result.mentions.push(eventPointer);\n  }\n  return result;\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  getPow: () => getPow,\n  minePow: () => minePow\n});\nfunction getPow(hex) {\n  let count = 0;\n  for (let i = 0; i < hex.length; i++) {\n    const nibble = parseInt(hex[i], 16);\n    if (nibble === 0) {\n      count += 4;\n    } else {\n      count += Math.clz32(nibble) - 28;\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now = Math.floor(new Date().getTime() / 1e3);\n    if (now !== event.created_at) {\n      count = 0;\n      event.created_at = now;\n    }\n    tag[1] = (++count).toString();\n    event.id = getEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  return finishEvent(\n    {\n      kind: 6 /* Repost */,\n      tags: [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]],\n      content: t.content === \"\" ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (event.kind !== 6 /* Repost */) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === void 0 || lastPTag === void 0); i--) {\n    const tag = event.tags[i];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifySignature(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finishEvent(\n    {\n      ...t,\n      kind: 7 /* Reaction */,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== 7 /* Reaction */) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === void 0 || lastPTag === void 0); i--) {\n    const tag = event.tags[i];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip26.ts\nvar nip26_exports = {};\n__export(nip26_exports, {\n  createDelegation: () => createDelegation,\n  getDelegator: () => getDelegator\n});\n\n\n\nfunction createDelegation(privateKey, parameters) {\n  let conditions = [];\n  if ((parameters.kind || -1) >= 0)\n    conditions.push(`kind=${parameters.kind}`);\n  if (parameters.until)\n    conditions.push(`created_at<${parameters.until}`);\n  if (parameters.since)\n    conditions.push(`created_at>${parameters.since}`);\n  let cond = conditions.join(\"&\");\n  if (cond === \"\")\n    throw new Error(\"refusing to create a delegation without any conditions\");\n  let sighash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`));\n  let sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.sign(sighash, privateKey));\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig\n  };\n}\nfunction getDelegator(event) {\n  let tag = event.tags.find((tag2) => tag2[0] === \"delegation\" && tag2.length >= 4);\n  if (!tag)\n    return null;\n  let pubkey = tag[1];\n  let cond = tag[2];\n  let sig = tag[3];\n  let conditions = cond.split(\"&\");\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/);\n    if (key === \"kind\" && operator === \"=\" && event.kind === parseInt(value))\n      continue;\n    else if (key === \"created_at\" && operator === \"<\" && event.created_at < parseInt(value))\n      continue;\n    else if (key === \"created_at\" && operator === \">\" && event.created_at > parseInt(value))\n      continue;\n    else\n      return null;\n  }\n  let sighash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`));\n  if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.verify(sig, sighash, pubkey))\n    return null;\n  return pubkey;\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [uri, value] = match;\n      yield {\n        uri,\n        value,\n        decoded: decode(value),\n        start: match.index,\n        end: match.index + uri.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (uri, value) => {\n    return replacer({\n      uri,\n      value,\n      decoded: decode(value)\n    });\n  });\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finishEvent(\n    {\n      kind: 40 /* ChannelCreation */,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finishEvent(\n    {\n      kind: 41 /* ChannelMetadata */,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finishEvent(\n    {\n      kind: 42 /* ChannelMessage */,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finishEvent(\n    {\n      kind: 43 /* ChannelHideMessage */,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finishEvent(\n    {\n      kind: 44 /* ChannelMuteUser */,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation2,\n  validateGithub: () => validateGithub\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  authenticate: () => authenticate\n});\nvar authenticate = async ({\n  challenge,\n  relay,\n  sign\n}) => {\n  const e = {\n    kind: 22242 /* ClientAuth */,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n  return relay.auth(await sign(e));\n};\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  utils: () => utils\n});\n\n\n\n\n\n\n\n\nvar utils = {\n  v2: {\n    maxPlaintextSize: 65536 - 128,\n    minCiphertextSize: 100,\n    maxCiphertextSize: 102400,\n    getConversationKey(privkeyA, pubkeyB) {\n      const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB);\n      return key.subarray(1, 33);\n    },\n    getMessageKeys(conversationKey, salt) {\n      const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_9__.hkdf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256, conversationKey, salt, \"nip44-v2\", 76);\n      return {\n        encryption: keys.subarray(0, 32),\n        nonce: keys.subarray(32, 44),\n        auth: keys.subarray(44, 76)\n      };\n    },\n    calcPadding(len) {\n      if (!Number.isSafeInteger(len) || len < 0)\n        throw new Error(\"expected positive integer\");\n      if (len <= 32)\n        return 32;\n      const nextpower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n      const chunk = nextpower <= 256 ? 32 : nextpower / 8;\n      return chunk * (Math.floor((len - 1) / chunk) + 1);\n    },\n    pad(unpadded) {\n      const unpaddedB = utf8Encoder.encode(unpadded);\n      const len = unpaddedB.length;\n      if (len < 1 || len >= utils.v2.maxPlaintextSize)\n        throw new Error(\"invalid plaintext length: must be between 1b and 64KB\");\n      const paddedLen = utils.v2.calcPadding(len);\n      const zeros = new Uint8Array(paddedLen - len);\n      const lenBuf = new Uint8Array(2);\n      new DataView(lenBuf.buffer).setUint16(0, len);\n      return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(lenBuf, unpaddedB, zeros);\n    },\n    unpad(padded) {\n      const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n      const unpadded = padded.subarray(2, 2 + unpaddedLen);\n      if (unpaddedLen === 0 || unpadded.length !== unpaddedLen || padded.length !== 2 + utils.v2.calcPadding(unpaddedLen))\n        throw new Error(\"invalid padding\");\n      return utf8Decoder.decode(unpadded);\n    }\n  }\n};\nfunction encrypt2(key, plaintext, options = {}) {\n  const version = options.version ?? 2;\n  if (version !== 2)\n    throw new Error(\"unknown encryption version \" + version);\n  const salt = options.salt ?? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(32);\n  (0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.ensureBytes)(salt, 32);\n  const keys = utils.v2.getMessageKeys(key, salt);\n  const padded = utils.v2.pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(keys.encryption, keys.nonce, padded);\n  const mac = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_10__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256, keys.auth, ciphertext);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(new Uint8Array([version]), salt, ciphertext, mac));\n}\nfunction decrypt2(key, ciphertext) {\n  const u = utils.v2;\n  (0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.ensureBytes)(key, 32);\n  const clen = ciphertext.length;\n  if (clen < u.minCiphertextSize || clen >= u.maxCiphertextSize)\n    throw new Error(\"invalid ciphertext length: \" + clen);\n  if (ciphertext[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ciphertext);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const vers = data.subarray(0, 1)[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  const salt = data.subarray(1, 33);\n  const ciphertext_ = data.subarray(33, -32);\n  const mac = data.subarray(-32);\n  const keys = u.getMessageKeys(key, salt);\n  const calculatedMac = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_10__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256, keys.auth, ciphertext_);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(keys.encryption, keys.nonce, ciphertext_);\n  return u.unpad(padded);\n}\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent({\n  pubkey,\n  secret,\n  invoice\n}) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secret, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: 23194 /* NwcRequest */,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finishEvent(eventTemplate, secret);\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation3,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`;\n    } else {\n      return null;\n    }\n    let res = await _fetch3(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifySignature(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateToken: () => validateToken\n});\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false) {\n  if (!loginUrl || !httpMethod)\n    throw new Error(\"Missing loginUrl or httpMethod\");\n  const event = getBlankEvent(27235 /* HttpAuth */);\n  event.tags = [\n    [\"u\", loginUrl],\n    [\"method\", httpMethod]\n  ];\n  event.created_at = Math.round(new Date().getTime() / 1e3);\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nasync function validateEvent2(event, url, method) {\n  if (!event) {\n    throw new Error(\"Invalid nostr event\");\n  }\n  if (!verifySignature(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (event.kind !== 27235 /* HttpAuth */) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!event.created_at) {\n    throw new Error(\"Invalid nostr event, created_at invalid\");\n  }\n  if (Math.round(new Date().getTime() / 1e3) - event.created_at > 60) {\n    throw new Error(\"Invalid nostr event, expired\");\n  }\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (urlTag?.length !== 1 && urlTag?.[1] !== url) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (methodTag?.length !== 1 && methodTag?.[1].toLowerCase() !== method.toLowerCase()) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNrRDtBQUNEO0FBQ2pEO0FBQ0EsU0FBUywrREFBVSxDQUFDLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxTQUFTLCtEQUFVLENBQUMsNERBQU87QUFDM0I7O0FBRUE7QUFDOEQ7QUFDaEI7QUFDa0I7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFNO0FBQ3hCLFNBQVMsK0RBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBUTtBQUMzQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFXLENBQUMsNERBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDLFFBQVEsMERBQTBEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN3RjtBQUNwRDtBQUNyQztBQUNBLGdDQUFnQyxLQUFLLG9DQUFvQyxHQUFHO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCLEVBQUUsK0NBQU07QUFDaEMsNEJBQTRCLCtDQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFXO0FBQ3pCO0FBQ0EsZ0NBQWdDLCtEQUFXO0FBQzNDLHVDQUF1QywrREFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBVztBQUM3Qix5QkFBeUIsK0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQiwrREFBVztBQUM5QztBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQU07QUFDcEIsU0FBUywrQ0FBTTtBQUNmO0FBQ0E7QUFDQSxhQUFhLCtEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBVTtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBVTtBQUNsQjtBQUNBLHVCQUF1QiwrREFBVTtBQUNqQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBVTtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILFNBQVMsZ0VBQVc7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNpRDtBQUNFO0FBQ2Y7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFTO0FBQ3ZCO0FBQ0EsMkJBQTJCLGdFQUFXO0FBQ3RDO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RixpREFBaUQscUJBQXFCO0FBQ3RFLGNBQWMsK0NBQU07QUFDcEIsY0FBYywrQ0FBTTtBQUNwQixZQUFZLE1BQU0sTUFBTSxNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQVM7QUFDckI7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGLG1CQUFtQiwrQ0FBTTtBQUN6QixXQUFXLCtDQUFNO0FBQ2pCLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLCtCQUErQixNQUFNO0FBQ3pGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPLCtCQUErQixLQUFLO0FBQ25GLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrRDtBQUNOO0FBQzRCO0FBQ2pEO0FBQ3JDO0FBQ0EsYUFBYSwrQ0FBSyxnQkFBZ0IsZ0VBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0RBQVc7QUFDcEI7QUFDQTtBQUNBLFNBQVMsOERBQWdCLENBQUMsb0VBQVE7QUFDbEM7QUFDQTtBQUNBLFNBQVMsOERBQWdCLFFBQVEsb0VBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdEQUF3RDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUIsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDLG9CQUFvQjtBQUMvRDtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3REFBd0Q7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDNkQ7QUFDRTtBQUNQO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQU8sd0NBQXdDLGtCQUFrQixHQUFHLEtBQUs7QUFDekYsWUFBWSwrREFBVyxDQUFDLDREQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQU8sd0NBQXdDLGFBQWEsR0FBRyxLQUFLO0FBQ3BGLE9BQU8sNERBQVE7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTLEdBQUcsTUFBTTtBQUNoRiwrRUFBK0UsT0FBTztBQUN0RixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnRDtBQUNjO0FBQ0c7QUFDeEI7QUFDQTtBQUNlO0FBQ3NDO0FBQy9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBVTtBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQix3REFBSSxDQUFDLHdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFZO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdFQUFZO0FBQzNDLEVBQUUsaUVBQVc7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLCtEQUFRO0FBQzdCLGNBQWMseURBQUksQ0FBQyx3REFBTztBQUMxQixTQUFTLCtDQUFPLFFBQVEsZ0VBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBTztBQUNsQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFJLENBQUMsd0RBQU87QUFDcEMsT0FBTyxnRUFBVTtBQUNqQjtBQUNBLGlCQUFpQiwrREFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDK0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0EsWUFBWSxRQUFRLEVBQUUsK0NBQU87QUFDN0IsaUJBQWlCLCtDQUFPO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseUJBQXlCLE9BQU8sc0JBQXNCLEtBQUs7QUFDM0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBTztBQUM3QyxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5Q0UiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcbm9kZV9tb2R1bGVzXFxub3N0ci10b29sc1xcbGliXFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIGtleXMudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuZnVuY3Rpb24gZ2VuZXJhdGVQcml2YXRlS2V5KCkge1xuICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShwcml2YXRlS2V5KSk7XG59XG5cbi8vIGV2ZW50LnRzXG5pbXBvcnQgeyBzY2hub3JyIGFzIHNjaG5vcnIyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyB1dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgTWVzc2FnZU5vZGU6ICgpID0+IE1lc3NhZ2VOb2RlLFxuICBNZXNzYWdlUXVldWU6ICgpID0+IE1lc3NhZ2VRdWV1ZSxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdCxcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0LFxuICBub3JtYWxpemVVUkw6ICgpID0+IG5vcm1hbGl6ZVVSTCxcbiAgdXRmOERlY29kZXI6ICgpID0+IHV0ZjhEZWNvZGVyLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gdXRmOEVuY29kZXJcbn0pO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgbGV0IHAgPSBuZXcgVVJMKHVybCk7XG4gIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUuc2xpY2UoMCwgLTEpO1xuICBpZiAocC5wb3J0ID09PSBcIjgwXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBwLnBvcnQgPT09IFwiNDQzXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpXG4gICAgcC5wb3J0ID0gXCJcIjtcbiAgcC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICBwLmhhc2ggPSBcIlwiO1xuICByZXR1cm4gcC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBzb3J0ZWRBcnJheS5sZW5ndGggLSAxO1xuICBsZXQgbWlkUG9pbnQ7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0O1xuICBpZiAoZW5kIDwgMCkge1xuICAgIHBvc2l0aW9uID0gMDtcbiAgfSBlbHNlIGlmIChldmVudC5jcmVhdGVkX2F0IDwgc29ydGVkQXJyYXlbZW5kXS5jcmVhdGVkX2F0KSB7XG4gICAgcG9zaXRpb24gPSBlbmQgKyAxO1xuICB9IGVsc2UgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPj0gc29ydGVkQXJyYXlbc3RhcnRdLmNyZWF0ZWRfYXQpIHtcbiAgICBwb3NpdGlvbiA9IHN0YXJ0O1xuICB9IGVsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBzdGFydCArIDEpIHtcbiAgICAgICAgcG9zaXRpb24gPSBlbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWlkUG9pbnQgPSBNYXRoLmZsb29yKHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAvIDIpO1xuICAgICAgaWYgKHNvcnRlZEFycmF5W21pZFBvaW50XS5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgICBzdGFydCA9IG1pZFBvaW50O1xuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRBcnJheVttaWRQb2ludF0uY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgZW5kID0gbWlkUG9pbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbiA9IG1pZFBvaW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIGlmIChzb3J0ZWRBcnJheVtwb3NpdGlvbl0/LmlkICE9PSBldmVudC5pZCkge1xuICAgIHJldHVybiBbLi4uc29ydGVkQXJyYXkuc2xpY2UoMCwgcG9zaXRpb24pLCBldmVudCwgLi4uc29ydGVkQXJyYXkuc2xpY2UocG9zaXRpb24pXTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gc29ydGVkQXJyYXkubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZFBvaW50O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBwb3NpdGlvbiA9IDA7XG4gIH0gZWxzZSBpZiAoZXZlbnQuY3JlYXRlZF9hdCA+IHNvcnRlZEFycmF5W2VuZF0uY3JlYXRlZF9hdCkge1xuICAgIHBvc2l0aW9uID0gZW5kICsgMTtcbiAgfSBlbHNlIGlmIChldmVudC5jcmVhdGVkX2F0IDw9IHNvcnRlZEFycmF5W3N0YXJ0XS5jcmVhdGVkX2F0KSB7XG4gICAgcG9zaXRpb24gPSBzdGFydDtcbiAgfSBlbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gc3RhcnQgKyAxKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1pZFBvaW50ID0gTWF0aC5mbG9vcihzdGFydCArIChlbmQgLSBzdGFydCkgLyAyKTtcbiAgICAgIGlmIChzb3J0ZWRBcnJheVttaWRQb2ludF0uY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRQb2ludDtcbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkQXJyYXlbbWlkUG9pbnRdLmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgIGVuZCA9IG1pZFBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSBtaWRQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICBpZiAoc29ydGVkQXJyYXlbcG9zaXRpb25dPy5pZCAhPT0gZXZlbnQuaWQpIHtcbiAgICByZXR1cm4gWy4uLnNvcnRlZEFycmF5LnNsaWNlKDAsIHBvc2l0aW9uKSwgZXZlbnQsIC4uLnNvcnRlZEFycmF5LnNsaWNlKHBvc2l0aW9uKV07XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxudmFyIE1lc3NhZ2VOb2RlID0gY2xhc3Mge1xuICBfdmFsdWU7XG4gIF9uZXh0O1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShtZXNzYWdlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBtZXNzYWdlO1xuICB9XG4gIGdldCBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0O1xuICB9XG4gIHNldCBuZXh0KG5vZGUpIHtcbiAgICB0aGlzLl9uZXh0ID0gbm9kZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBtZXNzYWdlO1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICB9XG59O1xudmFyIE1lc3NhZ2VRdWV1ZSA9IGNsYXNzIHtcbiAgX2ZpcnN0O1xuICBfbGFzdDtcbiAgZ2V0IGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgfVxuICBzZXQgZmlyc3QobWVzc2FnZU5vZGUpIHtcbiAgICB0aGlzLl9maXJzdCA9IG1lc3NhZ2VOb2RlO1xuICB9XG4gIGdldCBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0O1xuICB9XG4gIHNldCBsYXN0KG1lc3NhZ2VOb2RlKSB7XG4gICAgdGhpcy5fbGFzdCA9IG1lc3NhZ2VOb2RlO1xuICB9XG4gIF9zaXplO1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuICBzZXQgc2l6ZSh2KSB7XG4gICAgdGhpcy5fc2l6ZSA9IHY7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZmlyc3QgPSBudWxsO1xuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICB9XG4gIGVucXVldWUobWVzc2FnZSkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTWVzc2FnZU5vZGUobWVzc2FnZSk7XG4gICAgaWYgKHRoaXMuX3NpemUgPT09IDAgfHwgIXRoaXMuX2xhc3QpIHtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMuX2xhc3QgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgfVxuICAgIHRoaXMuX3NpemUrKztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICh0aGlzLl9zaXplID09PSAwIHx8ICF0aGlzLl9maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBwcmV2ID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fZmlyc3QgPSBwcmV2Lm5leHQ7XG4gICAgcHJldi5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9zaXplLS07XG4gICAgcmV0dXJuIHByZXYudmFsdWU7XG4gIH1cbn07XG5cbi8vIGV2ZW50LnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBLaW5kID0gLyogQF9fUFVSRV9fICovICgoS2luZDMpID0+IHtcbiAgS2luZDNbS2luZDNbXCJNZXRhZGF0YVwiXSA9IDBdID0gXCJNZXRhZGF0YVwiO1xuICBLaW5kM1tLaW5kM1tcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICBLaW5kM1tLaW5kM1tcIlJlY29tbWVuZFJlbGF5XCJdID0gMl0gPSBcIlJlY29tbWVuZFJlbGF5XCI7XG4gIEtpbmQzW0tpbmQzW1wiQ29udGFjdHNcIl0gPSAzXSA9IFwiQ29udGFjdHNcIjtcbiAgS2luZDNbS2luZDNbXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCJdID0gNF0gPSBcIkVuY3J5cHRlZERpcmVjdE1lc3NhZ2VcIjtcbiAgS2luZDNbS2luZDNbXCJFdmVudERlbGV0aW9uXCJdID0gNV0gPSBcIkV2ZW50RGVsZXRpb25cIjtcbiAgS2luZDNbS2luZDNbXCJSZXBvc3RcIl0gPSA2XSA9IFwiUmVwb3N0XCI7XG4gIEtpbmQzW0tpbmQzW1wiUmVhY3Rpb25cIl0gPSA3XSA9IFwiUmVhY3Rpb25cIjtcbiAgS2luZDNbS2luZDNbXCJCYWRnZUF3YXJkXCJdID0gOF0gPSBcIkJhZGdlQXdhcmRcIjtcbiAgS2luZDNbS2luZDNbXCJDaGFubmVsQ3JlYXRpb25cIl0gPSA0MF0gPSBcIkNoYW5uZWxDcmVhdGlvblwiO1xuICBLaW5kM1tLaW5kM1tcIkNoYW5uZWxNZXRhZGF0YVwiXSA9IDQxXSA9IFwiQ2hhbm5lbE1ldGFkYXRhXCI7XG4gIEtpbmQzW0tpbmQzW1wiQ2hhbm5lbE1lc3NhZ2VcIl0gPSA0Ml0gPSBcIkNoYW5uZWxNZXNzYWdlXCI7XG4gIEtpbmQzW0tpbmQzW1wiQ2hhbm5lbEhpZGVNZXNzYWdlXCJdID0gNDNdID0gXCJDaGFubmVsSGlkZU1lc3NhZ2VcIjtcbiAgS2luZDNbS2luZDNbXCJDaGFubmVsTXV0ZVVzZXJcIl0gPSA0NF0gPSBcIkNoYW5uZWxNdXRlVXNlclwiO1xuICBLaW5kM1tLaW5kM1tcIkJsYW5rXCJdID0gMjU1XSA9IFwiQmxhbmtcIjtcbiAgS2luZDNbS2luZDNbXCJSZXBvcnRcIl0gPSAxOTg0XSA9IFwiUmVwb3J0XCI7XG4gIEtpbmQzW0tpbmQzW1wiWmFwUmVxdWVzdFwiXSA9IDk3MzRdID0gXCJaYXBSZXF1ZXN0XCI7XG4gIEtpbmQzW0tpbmQzW1wiWmFwXCJdID0gOTczNV0gPSBcIlphcFwiO1xuICBLaW5kM1tLaW5kM1tcIlJlbGF5TGlzdFwiXSA9IDEwMDAyXSA9IFwiUmVsYXlMaXN0XCI7XG4gIEtpbmQzW0tpbmQzW1wiQ2xpZW50QXV0aFwiXSA9IDIyMjQyXSA9IFwiQ2xpZW50QXV0aFwiO1xuICBLaW5kM1tLaW5kM1tcIk53Y1JlcXVlc3RcIl0gPSAyMzE5NF0gPSBcIk53Y1JlcXVlc3RcIjtcbiAgS2luZDNbS2luZDNbXCJIdHRwQXV0aFwiXSA9IDI3MjM1XSA9IFwiSHR0cEF1dGhcIjtcbiAgS2luZDNbS2luZDNbXCJQcm9maWxlQmFkZ2VcIl0gPSAzMDAwOF0gPSBcIlByb2ZpbGVCYWRnZVwiO1xuICBLaW5kM1tLaW5kM1tcIkJhZGdlRGVmaW5pdGlvblwiXSA9IDMwMDA5XSA9IFwiQmFkZ2VEZWZpbml0aW9uXCI7XG4gIEtpbmQzW0tpbmQzW1wiQXJ0aWNsZVwiXSA9IDMwMDIzXSA9IFwiQXJ0aWNsZVwiO1xuICBLaW5kM1tLaW5kM1tcIkZpbGVNZXRhZGF0YVwiXSA9IDEwNjNdID0gXCJGaWxlTWV0YWRhdGFcIjtcbiAgcmV0dXJuIEtpbmQzO1xufSkoS2luZCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRCbGFua0V2ZW50KGtpbmQgPSAyNTUgLyogQmxhbmsgKi8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgY3JlYXRlZF9hdDogMFxuICB9O1xufVxuZnVuY3Rpb24gZmluaXNoRXZlbnQodCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBldmVudCA9IHQ7XG4gIGV2ZW50LnB1YmtleSA9IGdldFB1YmxpY0tleShwcml2YXRlS2V5KTtcbiAgZXZlbnQuaWQgPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICBldmVudC5zaWcgPSBnZXRTaWduYXR1cmUoZXZlbnQsIHByaXZhdGVLZXkpO1xuICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4MihldmVudEhhc2gpO1xufVxudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhZy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHR5cGVvZiB0YWdbal0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUoZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBldmVudFt2ZXJpZmllZFN5bWJvbF0gPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gIGNvbnN0IGhhc2ggPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICBpZiAoaGFzaCAhPT0gZXZlbnQuaWQpIHtcbiAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gc2Nobm9ycjIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBzaWduRXZlbnQoZXZlbnQsIGtleSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJub3N0ci10b29sczogYHNpZ25FdmVudGAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIG9yIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZS4gUGxlYXNlIHVzZSBgZ2V0U2lnbmF0dXJlYCBpbnN0ZWFkLlwiXG4gICk7XG4gIHJldHVybiBnZXRTaWduYXR1cmUoZXZlbnQsIGtleSk7XG59XG5mdW5jdGlvbiBnZXRTaWduYXR1cmUoZXZlbnQsIGtleSkge1xuICByZXR1cm4gYnl0ZXNUb0hleDIoc2Nobm9ycjIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBrZXkpKTtcbn1cblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgaWYgKCFmaWx0ZXIuaWRzLnNvbWUoKHByZWZpeCkgPT4gZXZlbnQuaWQuc3RhcnRzV2l0aChwcmVmaXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXV0aG9ycy5zb21lKChwcmVmaXgpID0+IGV2ZW50LnB1YmtleS5zdGFydHNXaXRoKHByZWZpeCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpXSwgZXZlbnQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzKC4uLmZpbHRlcnMpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICBPYmplY3QuZW50cmllcyhmaWx0ZXIpLmZvckVhY2goKFtwcm9wZXJ0eSwgdmFsdWVzXSkgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSBcImtpbmRzXCIgfHwgcHJvcGVydHkgPT09IFwiaWRzXCIgfHwgcHJvcGVydHkgPT09IFwiYXV0aG9yc1wiIHx8IHByb3BlcnR5WzBdID09PSBcIiNcIikge1xuICAgICAgICByZXN1bHRbcHJvcGVydHldID0gcmVzdWx0W3Byb3BlcnR5XSB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB2YWx1ZXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbdl07XG4gICAgICAgICAgaWYgKCFyZXN1bHRbcHJvcGVydHldLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZmlsdGVyLmxpbWl0ICYmICghcmVzdWx0LmxpbWl0IHx8IGZpbHRlci5saW1pdCA+IHJlc3VsdC5saW1pdCkpXG4gICAgICByZXN1bHQubGltaXQgPSBmaWx0ZXIubGltaXQ7XG4gICAgaWYgKGZpbHRlci51bnRpbCAmJiAoIXJlc3VsdC51bnRpbCB8fCBmaWx0ZXIudW50aWwgPiByZXN1bHQudW50aWwpKVxuICAgICAgcmVzdWx0LnVudGlsID0gZmlsdGVyLnVudGlsO1xuICAgIGlmIChmaWx0ZXIuc2luY2UgJiYgKCFyZXN1bHQuc2luY2UgfHwgZmlsdGVyLnNpbmNlIDwgcmVzdWx0LnNpbmNlKSlcbiAgICAgIHJlc3VsdC5zaW5jZSA9IGZpbHRlci5zaW5jZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBmYWtlanNvbi50c1xudmFyIGZha2Vqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZha2Vqc29uX2V4cG9ydHMsIHtcbiAgZ2V0SGV4NjQ6ICgpID0+IGdldEhleDY0LFxuICBnZXRJbnQ6ICgpID0+IGdldEludCxcbiAgZ2V0U3Vic2NyaXB0aW9uSWQ6ICgpID0+IGdldFN1YnNjcmlwdGlvbklkLFxuICBtYXRjaEV2ZW50SWQ6ICgpID0+IG1hdGNoRXZlbnRJZCxcbiAgbWF0Y2hFdmVudEtpbmQ6ICgpID0+IG1hdGNoRXZlbnRLaW5kLFxuICBtYXRjaEV2ZW50UHVia2V5OiAoKSA9PiBtYXRjaEV2ZW50UHVia2V5XG59KTtcbmZ1bmN0aW9uIGdldEhleDY0KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGggKyAzO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW47XG4gIGxldCBzID0ganNvbi5zbGljZShpZHgpLmluZGV4T2YoYFwiYCkgKyBpZHggKyAxO1xuICByZXR1cm4ganNvbi5zbGljZShzLCBzICsgNjQpO1xufVxuZnVuY3Rpb24gZ2V0SW50KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGg7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbiArIDM7XG4gIGxldCBzbGljZWQgPSBqc29uLnNsaWNlKGlkeCk7XG4gIGxldCBlbmQgPSBNYXRoLm1pbihzbGljZWQuaW5kZXhPZihcIixcIiksIHNsaWNlZC5pbmRleE9mKFwifVwiKSk7XG4gIHJldHVybiBwYXJzZUludChzbGljZWQuc2xpY2UoMCwgZW5kKSwgMTApO1xufVxuZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uSWQoanNvbikge1xuICBsZXQgaWR4ID0ganNvbi5zbGljZSgwLCAyMikuaW5kZXhPZihgXCJFVkVOVFwiYCk7XG4gIGlmIChpZHggPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcHN0YXJ0ID0ganNvbi5zbGljZShpZHggKyA3ICsgMSkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBzdGFydCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBzdGFydCA9IGlkeCArIDcgKyAxICsgcHN0YXJ0O1xuICBsZXQgcGVuZCA9IGpzb24uc2xpY2Uoc3RhcnQgKyAxLCA4MCkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBlbmQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgZW5kID0gc3RhcnQgKyAxICsgcGVuZDtcbiAgcmV0dXJuIGpzb24uc2xpY2Uoc3RhcnQgKyAxLCBlbmQpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudElkKGpzb24sIGlkKSB7XG4gIHJldHVybiBpZCA9PT0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRQdWJrZXkoanNvbiwgcHVia2V5KSB7XG4gIHJldHVybiBwdWJrZXkgPT09IGdldEhleDY0KGpzb24sIFwicHVia2V5XCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudEtpbmQoanNvbiwga2luZCkge1xuICByZXR1cm4ga2luZCA9PT0gZ2V0SW50KGpzb24sIFwia2luZFwiKTtcbn1cblxuLy8gcmVsYXkudHNcbnZhciBuZXdMaXN0ZW5lcnMgPSAoKSA9PiAoe1xuICBjb25uZWN0OiBbXSxcbiAgZGlzY29ubmVjdDogW10sXG4gIGVycm9yOiBbXSxcbiAgbm90aWNlOiBbXSxcbiAgYXV0aDogW11cbn0pO1xuZnVuY3Rpb24gcmVsYXlJbml0KHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7IGxpc3RUaW1lb3V0ID0gM2UzLCBnZXRUaW1lb3V0ID0gM2UzLCBjb3VudFRpbWVvdXQgPSAzZTMgfSA9IG9wdGlvbnM7XG4gIHZhciB3cztcbiAgdmFyIG9wZW5TdWJzID0ge307XG4gIHZhciBsaXN0ZW5lcnMgPSBuZXdMaXN0ZW5lcnMoKTtcbiAgdmFyIHN1Ykxpc3RlbmVycyA9IHt9O1xuICB2YXIgcHViTGlzdGVuZXJzID0ge307XG4gIHZhciBjb25uZWN0aW9uUHJvbWlzZTtcbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdFJlbGF5KCkge1xuICAgIGlmIChjb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiBjb25uZWN0aW9uUHJvbWlzZTtcbiAgICBjb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdzID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuY29ubmVjdC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgbGlzdGVuZXJzLmVycm9yLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgICAgd3Mub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIGxpc3RlbmVycy5kaXNjb25uZWN0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgIH07XG4gICAgICBsZXQgaW5jb21pbmdNZXNzYWdlUXVldWUgPSBuZXcgTWVzc2FnZVF1ZXVlKCk7XG4gICAgICBsZXQgaGFuZGxlTmV4dEludGVydmFsO1xuICAgICAgd3Mub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgaW5jb21pbmdNZXNzYWdlUXVldWUuZW5xdWV1ZShlLmRhdGEpO1xuICAgICAgICBpZiAoIWhhbmRsZU5leHRJbnRlcnZhbCkge1xuICAgICAgICAgIGhhbmRsZU5leHRJbnRlcnZhbCA9IHNldEludGVydmFsKGhhbmRsZU5leHQsIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaGFuZGxlTmV4dCgpIHtcbiAgICAgICAgaWYgKGluY29taW5nTWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGhhbmRsZU5leHRJbnRlcnZhbCk7XG4gICAgICAgICAgaGFuZGxlTmV4dEludGVydmFsID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzb24gPSBpbmNvbWluZ01lc3NhZ2VRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBzdWJpZCA9IGdldFN1YnNjcmlwdGlvbklkKGpzb24pO1xuICAgICAgICBpZiAoc3ViaWQpIHtcbiAgICAgICAgICBsZXQgc28gPSBvcGVuU3Vic1tzdWJpZF07XG4gICAgICAgICAgaWYgKHNvICYmIHNvLmFscmVhZHlIYXZlRXZlbnQgJiYgc28uYWxyZWFkeUhhdmVFdmVudChnZXRIZXg2NChqc29uLCBcImlkXCIpLCB1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICAgICAgbGV0IGlkMiA9IGRhdGFbMV07XG4gICAgICAgICAgICAgIGxldCBldmVudCA9IGRhdGFbMl07XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUV2ZW50KGV2ZW50KSAmJiBvcGVuU3Vic1tpZDJdICYmIChvcGVuU3Vic1tpZDJdLnNraXBWZXJpZmljYXRpb24gfHwgdmVyaWZ5U2lnbmF0dXJlKGV2ZW50KSkgJiYgbWF0Y2hGaWx0ZXJzKG9wZW5TdWJzW2lkMl0uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgb3BlblN1YnNbaWQyXTtcbiAgICAgICAgICAgICAgICAoc3ViTGlzdGVuZXJzW2lkMl0/LmV2ZW50IHx8IFtdKS5mb3JFYWNoKChjYikgPT4gY2IoZXZlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQ09VTlRcIjpcbiAgICAgICAgICAgICAgbGV0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgICAgICBpZiAob3BlblN1YnNbaWRdKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIChzdWJMaXN0ZW5lcnNbaWRdPy5jb3VudCB8fCBbXSkuZm9yRWFjaCgoY2IpID0+IGNiKHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgICAgIGxldCBpZDIgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICBpZiAoaWQyIGluIHN1Ykxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHN1Ykxpc3RlbmVyc1tpZDJdLmVvc2UuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgICAgICAgICAgICAgIHN1Ykxpc3RlbmVyc1tpZDJdLmVvc2UgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgICAgICBsZXQgaWQyID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgbGV0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IGRhdGFbM10gfHwgXCJcIjtcbiAgICAgICAgICAgICAgaWYgKGlkMiBpbiBwdWJMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyByZXNvbHZlOiByZXNvbHZlMiwgcmVqZWN0OiByZWplY3QyIH0gPSBwdWJMaXN0ZW5lcnNbaWQyXTtcbiAgICAgICAgICAgICAgICBpZiAob2spXG4gICAgICAgICAgICAgICAgICByZXNvbHZlMihudWxsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICByZWplY3QyKG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgICAgIGxldCBub3RpY2UgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICBsaXN0ZW5lcnMubm90aWNlLmZvckVhY2goKGNiKSA9PiBjYihub3RpY2UpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgICAgICBsZXQgY2hhbGxlbmdlID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLmF1dGg/LmZvckVhY2goKGNiKSA9PiBjYihjaGFsbGVuZ2UpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25Qcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gd3M/LnJlYWR5U3RhdGUgPT09IDE7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICBpZiAoY29ubmVjdGVkKCkpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgY29ubmVjdFJlbGF5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdHJ5U2VuZChwYXJhbXMpIHtcbiAgICBsZXQgbXNnID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICBpZiAoIWNvbm5lY3RlZCgpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxZTMpKTtcbiAgICAgIGlmICghY29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgd3Muc2VuZChtc2cpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3ViID0gKGZpbHRlcnMsIHtcbiAgICB2ZXJiID0gXCJSRVFcIixcbiAgICBza2lwVmVyaWZpY2F0aW9uID0gZmFsc2UsXG4gICAgYWxyZWFkeUhhdmVFdmVudCA9IG51bGwsXG4gICAgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoMilcbiAgfSA9IHt9KSA9PiB7XG4gICAgbGV0IHN1YmlkID0gaWQ7XG4gICAgb3BlblN1YnNbc3ViaWRdID0ge1xuICAgICAgaWQ6IHN1YmlkLFxuICAgICAgZmlsdGVycyxcbiAgICAgIHNraXBWZXJpZmljYXRpb24sXG4gICAgICBhbHJlYWR5SGF2ZUV2ZW50XG4gICAgfTtcbiAgICB0cnlTZW5kKFt2ZXJiLCBzdWJpZCwgLi4uZmlsdGVyc10pO1xuICAgIGxldCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICBzdWI6IChuZXdGaWx0ZXJzLCBuZXdPcHRzID0ge30pID0+IHN1YihuZXdGaWx0ZXJzIHx8IGZpbHRlcnMsIHtcbiAgICAgICAgc2tpcFZlcmlmaWNhdGlvbjogbmV3T3B0cy5za2lwVmVyaWZpY2F0aW9uIHx8IHNraXBWZXJpZmljYXRpb24sXG4gICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IG5ld09wdHMuYWxyZWFkeUhhdmVFdmVudCB8fCBhbHJlYWR5SGF2ZUV2ZW50LFxuICAgICAgICBpZDogc3ViaWRcbiAgICAgIH0pLFxuICAgICAgdW5zdWI6ICgpID0+IHtcbiAgICAgICAgZGVsZXRlIG9wZW5TdWJzW3N1YmlkXTtcbiAgICAgICAgZGVsZXRlIHN1Ykxpc3RlbmVyc1tzdWJpZF07XG4gICAgICAgIHRyeVNlbmQoW1wiQ0xPU0VcIiwgc3ViaWRdKTtcbiAgICAgIH0sXG4gICAgICBvbjogKHR5cGUsIGNiKSA9PiB7XG4gICAgICAgIHN1Ykxpc3RlbmVyc1tzdWJpZF0gPSBzdWJMaXN0ZW5lcnNbc3ViaWRdIHx8IHtcbiAgICAgICAgICBldmVudDogW10sXG4gICAgICAgICAgY291bnQ6IFtdLFxuICAgICAgICAgIGVvc2U6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHN1Ykxpc3RlbmVyc1tzdWJpZF1bdHlwZV0ucHVzaChjYik7XG4gICAgICB9LFxuICAgICAgb2ZmOiAodHlwZSwgY2IpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyczIgPSBzdWJMaXN0ZW5lcnNbc3ViaWRdO1xuICAgICAgICBsZXQgaWR4ID0gbGlzdGVuZXJzMlt0eXBlXS5pbmRleE9mKGNiKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgIGxpc3RlbmVyczJbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50c0dlbmVyYXRvcihzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfTtcbiAgZnVuY3Rpb24gX3B1Ymxpc2hFdmVudChldmVudCwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LmlkKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYGV2ZW50ICR7ZXZlbnR9IGhhcyBubyBpZGApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGlkID0gZXZlbnQuaWQ7XG4gICAgICB0cnlTZW5kKFt0eXBlLCBldmVudF0pO1xuICAgICAgcHViTGlzdGVuZXJzW2lkXSA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cmwsXG4gICAgc3ViLFxuICAgIG9uOiAodHlwZSwgY2IpID0+IHtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGNiKTtcbiAgICAgIGlmICh0eXBlID09PSBcImNvbm5lY3RcIiAmJiB3cz8ucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICA7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvZmY6ICh0eXBlLCBjYikgPT4ge1xuICAgICAgbGV0IGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YoY2IpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSxcbiAgICBsaXN0OiAoZmlsdGVycywgb3B0cykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBzID0gc3ViKGZpbHRlcnMsIG9wdHMpO1xuICAgICAgbGV0IGV2ZW50cyA9IFtdO1xuICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcy51bnN1YigpO1xuICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICB9LCBsaXN0VGltZW91dCk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHMudW5zdWIoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICB9KTtcbiAgICAgIHMub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSksXG4gICAgZ2V0OiAoZmlsdGVyLCBvcHRzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IHMgPSBzdWIoW2ZpbHRlcl0sIG9wdHMpO1xuICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcy51bnN1YigpO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfSwgZ2V0VGltZW91dCk7XG4gICAgICBzLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHMudW5zdWIoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGNvdW50OiAoZmlsdGVycykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBzID0gc3ViKGZpbHRlcnMsIHsgLi4uc3ViLCB2ZXJiOiBcIkNPVU5UXCIgfSk7XG4gICAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzLnVuc3ViKCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9LCBjb3VudFRpbWVvdXQpO1xuICAgICAgcy5vbihcImNvdW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBzLnVuc3ViKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgICBhd2FpdCBfcHVibGlzaEV2ZW50KGV2ZW50LCBcIkVWRU5UXCIpO1xuICAgIH0sXG4gICAgYXN5bmMgYXV0aChldmVudCkge1xuICAgICAgYXdhaXQgX3B1Ymxpc2hFdmVudChldmVudCwgXCJBVVRIXCIpO1xuICAgIH0sXG4gICAgY29ubmVjdCxcbiAgICBjbG9zZSgpIHtcbiAgICAgIGxpc3RlbmVycyA9IG5ld0xpc3RlbmVycygpO1xuICAgICAgc3ViTGlzdGVuZXJzID0ge307XG4gICAgICBwdWJMaXN0ZW5lcnMgPSB7fTtcbiAgICAgIGlmICh3cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICByZXR1cm4gd3M/LnJlYWR5U3RhdGUgPz8gMztcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiogZXZlbnRzR2VuZXJhdG9yKHN1Yikge1xuICBsZXQgbmV4dFJlc29sdmU7XG4gIGNvbnN0IGV2ZW50UXVldWUgPSBbXTtcbiAgY29uc3QgcHVzaFRvUXVldWUgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAobmV4dFJlc29sdmUpIHtcbiAgICAgIG5leHRSZXNvbHZlKGV2ZW50KTtcbiAgICAgIG5leHRSZXNvbHZlID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgc3ViLm9uKFwiZXZlbnRcIiwgcHVzaFRvUXVldWUpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZXZlbnRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBuZXh0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc3ViLm9mZihcImV2ZW50XCIsIHB1c2hUb1F1ZXVlKTtcbiAgfVxufVxuXG4vLyBwb29sLnRzXG52YXIgU2ltcGxlUG9vbCA9IGNsYXNzIHtcbiAgX2Nvbm47XG4gIF9zZWVuT24gPSB7fTtcbiAgYmF0Y2hlZEJ5S2V5ID0ge307XG4gIGVvc2VTdWJUaW1lb3V0O1xuICBnZXRUaW1lb3V0O1xuICBzZWVuT25FbmFibGVkID0gdHJ1ZTtcbiAgYmF0Y2hJbnRlcnZhbCA9IDEwMDtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY29ubiA9IHt9O1xuICAgIHRoaXMuZW9zZVN1YlRpbWVvdXQgPSBvcHRpb25zLmVvc2VTdWJUaW1lb3V0IHx8IDM0MDA7XG4gICAgdGhpcy5nZXRUaW1lb3V0ID0gb3B0aW9ucy5nZXRUaW1lb3V0IHx8IDM0MDA7XG4gICAgdGhpcy5zZWVuT25FbmFibGVkID0gb3B0aW9ucy5zZWVuT25FbmFibGVkICE9PSBmYWxzZTtcbiAgICB0aGlzLmJhdGNoSW50ZXJ2YWwgPSBvcHRpb25zLmJhdGNoSW50ZXJ2YWwgfHwgMTAwO1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIGxldCByZWxheSA9IHRoaXMuX2Nvbm5bbm9ybWFsaXplVVJMKHVybCldO1xuICAgICAgaWYgKHJlbGF5KVxuICAgICAgICByZWxheS5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuc3VyZVJlbGF5KHVybCkge1xuICAgIGNvbnN0IG5tID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgaWYgKCF0aGlzLl9jb25uW25tXSkge1xuICAgICAgdGhpcy5fY29ubltubV0gPSByZWxheUluaXQobm0sIHtcbiAgICAgICAgZ2V0VGltZW91dDogdGhpcy5nZXRUaW1lb3V0ICogMC45LFxuICAgICAgICBsaXN0VGltZW91dDogdGhpcy5nZXRUaW1lb3V0ICogMC45XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLl9jb25uW25tXTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIHN1YihyZWxheXMsIGZpbHRlcnMsIG9wdHMpIHtcbiAgICBsZXQgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgbW9kaWZpZWRPcHRzID0geyAuLi5vcHRzIHx8IHt9IH07XG4gICAgbW9kaWZpZWRPcHRzLmFscmVhZHlIYXZlRXZlbnQgPSAoaWQsIHVybCkgPT4ge1xuICAgICAgaWYgKG9wdHM/LmFscmVhZHlIYXZlRXZlbnQ/LihpZCwgdXJsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlZW5PbkVuYWJsZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuX3NlZW5PbltpZF0gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgc2V0LmFkZCh1cmwpO1xuICAgICAgICB0aGlzLl9zZWVuT25baWRdID0gc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9rbm93bklkcy5oYXMoaWQpO1xuICAgIH07XG4gICAgbGV0IHN1YnMgPSBbXTtcbiAgICBsZXQgZXZlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBlb3NlTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZW9zZXNNaXNzaW5nID0gcmVsYXlzLmxlbmd0aDtcbiAgICBsZXQgZW9zZVNlbnQgPSBmYWxzZTtcbiAgICBsZXQgZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBlb3NlU2VudCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGNiIG9mIGVvc2VMaXN0ZW5lcnMudmFsdWVzKCkpXG4gICAgICAgICAgY2IoKTtcbiAgICAgIH0sXG4gICAgICBvcHRzPy5lb3NlU3ViVGltZW91dCB8fCB0aGlzLmVvc2VTdWJUaW1lb3V0XG4gICAgKTtcbiAgICByZWxheXMuZmlsdGVyKChyLCBpLCBhKSA9PiBhLmluZGV4T2YocikgPT09IGkpLmZvckVhY2goYXN5bmMgKHJlbGF5KSA9PiB7XG4gICAgICBsZXQgcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHJlbGF5KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBoYW5kbGVFb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHMgPSByLnN1YihmaWx0ZXJzLCBtb2RpZmllZE9wdHMpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBfa25vd25JZHMuYWRkKGV2ZW50LmlkKTtcbiAgICAgICAgZm9yIChsZXQgY2Igb2YgZXZlbnRMaXN0ZW5lcnMudmFsdWVzKCkpXG4gICAgICAgICAgY2IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmIChlb3NlU2VudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhhbmRsZUVvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgc3Vicy5wdXNoKHMpO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlRW9zZSgpIHtcbiAgICAgICAgZW9zZXNNaXNzaW5nLS07XG4gICAgICAgIGlmIChlb3Nlc01pc3NpbmcgPT09IDApIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZW9zZVRpbWVvdXQpO1xuICAgICAgICAgIGZvciAobGV0IGNiIG9mIGVvc2VMaXN0ZW5lcnMudmFsdWVzKCkpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGdyZWF0ZXJTdWIgPSB7XG4gICAgICBzdWIoZmlsdGVyczIsIG9wdHMyKSB7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiBzdWIuc3ViKGZpbHRlcnMyLCBvcHRzMikpO1xuICAgICAgICByZXR1cm4gZ3JlYXRlclN1YjtcbiAgICAgIH0sXG4gICAgICB1bnN1YigpIHtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHN1Yi51bnN1YigpKTtcbiAgICAgIH0sXG4gICAgICBvbih0eXBlLCBjYikge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVvc2VcIikge1xuICAgICAgICAgIGVvc2VMaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9mZih0eXBlLCBjYikge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVvc2VcIilcbiAgICAgICAgICBlb3NlTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9LFxuICAgICAgZ2V0IGV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50c0dlbmVyYXRvcihncmVhdGVyU3ViKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBncmVhdGVyU3ViO1xuICB9XG4gIGdldChyZWxheXMsIGZpbHRlciwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IHN1YiA9IHRoaXMuc3ViKHJlbGF5cywgW2ZpbHRlcl0sIG9wdHMpO1xuICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3ViLnVuc3ViKCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9LCB0aGlzLmdldFRpbWVvdXQpO1xuICAgICAgc3ViLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN1Yi51bnN1YigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdChyZWxheXMsIGZpbHRlcnMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBldmVudHMgPSBbXTtcbiAgICAgIGxldCBzdWIgPSB0aGlzLnN1YihyZWxheXMsIGZpbHRlcnMsIG9wdHMpO1xuICAgICAgc3ViLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHN1Yi51bnN1YigpO1xuICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBiYXRjaGVkTGlzdChiYXRjaEtleSwgcmVsYXlzLCBmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYmF0Y2hlZEJ5S2V5W2JhdGNoS2V5XSkge1xuICAgICAgICB0aGlzLmJhdGNoZWRCeUtleVtiYXRjaEtleV0gPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVycyxcbiAgICAgICAgICAgIHJlbGF5cyxcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICBldmVudHM6IFtdXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmJhdGNoZWRCeUtleSkuZm9yRWFjaChhc3luYyAoYmF0Y2hLZXkyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXRjaGVkUmVxdWVzdHMgPSB0aGlzLmJhdGNoZWRCeUtleVtiYXRjaEtleTJdO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyczIgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF5czIgPSBbXTtcbiAgICAgICAgICAgIGJhdGNoZWRSZXF1ZXN0cy5mb3JFYWNoKChicikgPT4ge1xuICAgICAgICAgICAgICBmaWx0ZXJzMi5wdXNoKC4uLmJyLmZpbHRlcnMpO1xuICAgICAgICAgICAgICByZWxheXMyLnB1c2goLi4uYnIucmVsYXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWIocmVsYXlzMiwgW21lcmdlRmlsdGVycyguLi5maWx0ZXJzMildKTtcbiAgICAgICAgICAgIHN1Yi5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICBiYXRjaGVkUmVxdWVzdHMuZm9yRWFjaCgoYnIpID0+IG1hdGNoRmlsdGVycyhici5maWx0ZXJzLCBldmVudCkgJiYgYnIuZXZlbnRzLnB1c2goZXZlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHN1Yi51bnN1YigpO1xuICAgICAgICAgICAgICBiYXRjaGVkUmVxdWVzdHMuZm9yRWFjaCgoYnIpID0+IGJyLnJlc29sdmUoYnIuZXZlbnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJhdGNoZWRCeUtleVtiYXRjaEtleTJdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLmJhdGNoSW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXRjaGVkQnlLZXlbYmF0Y2hLZXldLnB1c2goe1xuICAgICAgICAgIGZpbHRlcnMsXG4gICAgICAgICAgcmVsYXlzLFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgZXZlbnRzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoKHJlbGF5cywgZXZlbnQpIHtcbiAgICByZXR1cm4gcmVsYXlzLm1hcChhc3luYyAocmVsYXkpID0+IHtcbiAgICAgIGxldCByID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheShyZWxheSk7XG4gICAgICByZXR1cm4gci5wdWJsaXNoKGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuICBzZWVuT24oaWQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9zZWVuT25baWRdPy52YWx1ZXM/LigpIHx8IFtdKTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBkZWNvZGU6ICgpID0+IGRlY29kZSxcbiAgbmFkZHJFbmNvZGU6ICgpID0+IG5hZGRyRW5jb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBucmVsYXlFbmNvZGU6ICgpID0+IG5yZWxheUVuY29kZSxcbiAgbnNlY0VuY29kZTogKCkgPT4gbnNlY0VuY29kZVxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgzLCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBCZWNoMzJNYXhTaXplID0gNWUzO1xudmFyIEJFQ0gzMl9SRUdFWCA9IC9bXFx4MjEtXFx4N0VdezEsODN9MVswMjM0NTY3ODlhY2RlZmdoamtsbW5wcXJzdHV2d3h5el17Nix9LztcbmZ1bmN0aW9uIGludGVnZXJUb1VpbnQ4QXJyYXkobnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgdWludDhBcnJheVswXSA9IG51bWJlciA+PiAyNCAmIDI1NTtcbiAgdWludDhBcnJheVsxXSA9IG51bWJlciA+PiAxNiAmIDI1NTtcbiAgdWludDhBcnJheVsyXSA9IG51bWJlciA+PiA4ICYgMjU1O1xuICB1aW50OEFycmF5WzNdID0gbnVtYmVyICYgMjU1O1xuICByZXR1cm4gdWludDhBcnJheTtcbn1cbmZ1bmN0aW9uIGRlY29kZShuaXAxOSkge1xuICBsZXQgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKG5pcDE5LCBCZWNoMzJNYXhTaXplKTtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKSk7XG4gIHN3aXRjaCAocHJlZml4KSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5wcm9maWxlXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgzKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuZXZlbnRcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbMl0gJiYgdGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbM10gJiYgdGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGJ5dGVzVG9IZXgzKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiB0bHZbMl0/LlswXSA/IGJ5dGVzVG9IZXgzKHRsdlsyXVswXSkgOiB2b2lkIDAsXG4gICAgICAgICAga2luZDogdGx2WzNdPy5bMF0gPyBwYXJzZUludChieXRlc1RvSGV4Myh0bHZbM11bMF0pLCAxNikgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKCF0bHZbMl0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICghdGx2WzNdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYWRkclwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpZmllcjogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSksXG4gICAgICAgICAgcHVia2V5OiBieXRlc1RvSGV4Myh0bHZbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGJ5dGVzVG9IZXgzKHRsdlszXVswXSksIDE2KSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnJlbGF5XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5yZWxheVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnJlbGF5XCIsXG4gICAgICAgIGRhdGE6IHV0ZjhEZWNvZGVyLmRlY29kZSh0bHZbMF1bMF0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnNlY1wiOlxuICAgIGNhc2UgXCJucHViXCI6XG4gICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IHByZWZpeCwgZGF0YTogYnl0ZXNUb0hleDMoZGF0YSkgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByZWZpeCAke3ByZWZpeH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUTFYoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCByZXN0ID0gZGF0YTtcbiAgd2hpbGUgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIGxldCB0ID0gcmVzdFswXTtcbiAgICBsZXQgbCA9IHJlc3RbMV07XG4gICAgaWYgKCFsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgVExWICR7dH1gKTtcbiAgICBsZXQgdiA9IHJlc3Quc2xpY2UoMiwgMiArIGwpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDIgKyBsKTtcbiAgICBpZiAodi5sZW5ndGggPCBsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHt0fWApO1xuICAgIHJlc3VsdFt0XSA9IHJlc3VsdFt0XSB8fCBbXTtcbiAgICByZXN1bHRbdF0ucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbnNlY0VuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnNlY1wiLCBoZXgpO1xufVxuZnVuY3Rpb24gbnB1YkVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnB1YlwiLCBoZXgpO1xufVxuZnVuY3Rpb24gbm90ZUVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibm90ZVwiLCBoZXgpO1xufVxuZnVuY3Rpb24gZW5jb2RlQmVjaDMyKHByZWZpeCwgZGF0YSkge1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGhleCkge1xuICBsZXQgZGF0YSA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGRhdGEpO1xufVxuZnVuY3Rpb24gbnByb2ZpbGVFbmNvZGUocHJvZmlsZSkge1xuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW2hleFRvQnl0ZXMocHJvZmlsZS5wdWJrZXkpXSxcbiAgICAxOiAocHJvZmlsZS5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSlcbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJucHJvZmlsZVwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5ldmVudEVuY29kZShldmVudCkge1xuICBsZXQga2luZEFycmF5O1xuICBpZiAoZXZlbnQua2luZCAhPSB2b2lkIDApIHtcbiAgICBraW5kQXJyYXkgPSBpbnRlZ2VyVG9VaW50OEFycmF5KGV2ZW50LmtpbmQpO1xuICB9XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlcyhldmVudC5pZCldLFxuICAgIDE6IChldmVudC5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSksXG4gICAgMjogZXZlbnQuYXV0aG9yID8gW2hleFRvQnl0ZXMoZXZlbnQuYXV0aG9yKV0gOiBbXSxcbiAgICAzOiBraW5kQXJyYXkgPyBbbmV3IFVpbnQ4QXJyYXkoa2luZEFycmF5KV0gOiBbXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5ldmVudFwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5hZGRyRW5jb2RlKGFkZHIpIHtcbiAgbGV0IGtpbmQgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIG5ldyBEYXRhVmlldyhraW5kKS5zZXRVaW50MzIoMCwgYWRkci5raW5kLCBmYWxzZSk7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbdXRmOEVuY29kZXIuZW5jb2RlKGFkZHIuaWRlbnRpZmllcildLFxuICAgIDE6IChhZGRyLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBbaGV4VG9CeXRlcyhhZGRyLnB1YmtleSldLFxuICAgIDM6IFtuZXcgVWludDhBcnJheShraW5kKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJuYWRkclwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5yZWxheUVuY29kZSh1cmwpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUodXJsKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJucmVsYXlcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGVUTFYodGx2KSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIE9iamVjdC5lbnRyaWVzKHRsdikuZm9yRWFjaCgoW3QsIHZzXSkgPT4ge1xuICAgIHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IG5ldyBVaW50OEFycmF5KHYubGVuZ3RoICsgMik7XG4gICAgICBlbnRyeS5zZXQoW3BhcnNlSW50KHQpXSwgMCk7XG4gICAgICBlbnRyeS5zZXQoW3YubGVuZ3RoXSwgMSk7XG4gICAgICBlbnRyeS5zZXQodiwgMik7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLmVudHJpZXMpO1xufVxuXG4vLyByZWZlcmVuY2VzLnRzXG52YXIgbWVudGlvblJlZ2V4ID0gL1xcYm5vc3RyOigobm90ZXxucHVifG5hZGRyfG5ldmVudHxucHJvZmlsZSkxXFx3KylcXGJ8I1xcWyhcXGQrKVxcXS9nO1xuZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2VzKGV2dCkge1xuICBsZXQgcmVmZXJlbmNlcyA9IFtdO1xuICBmb3IgKGxldCByZWYgb2YgZXZ0LmNvbnRlbnQubWF0Y2hBbGwobWVudGlvblJlZ2V4KSkge1xuICAgIGlmIChyZWZbMl0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGRhdGEgfSA9IGRlY29kZShyZWZbMV0pO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnB1YlwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJub3RlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZbM10pIHtcbiAgICAgIGxldCBpZHggPSBwYXJzZUludChyZWZbM10sIDEwKTtcbiAgICAgIGxldCB0YWcgPSBldnQudGFnc1tpZHhdO1xuICAgICAgaWYgKCF0YWcpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgY2FzZSBcInBcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBraW5kOiBwYXJzZUludChraW5kLCAxMCksXG4gICAgICAgICAgICAgICAgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmZXJlbmNlcztcbn1cblxuLy8gbmlwMDQudHNcbnZhciBuaXAwNF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHRcbn0pO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbmlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmICFjcnlwdG8uc3VidGxlICYmIGNyeXB0by53ZWJjcnlwdG8pIHtcbiAgY3J5cHRvLnN1YnRsZSA9IGNyeXB0by53ZWJjcnlwdG8uc3VidGxlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChwcml2a2V5LCBwdWJrZXksIHRleHQpIHtcbiAgY29uc3Qga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBjb25zdCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKDE2KSk7XG4gIGxldCBwbGFpbnRleHQgPSB1dGY4RW5jb2Rlci5lbmNvZGUodGV4dCk7XG4gIGxldCBjcnlwdG9LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBub3JtYWxpemVkS2V5LCB7IG5hbWU6IFwiQUVTLUNCQ1wiIH0sIGZhbHNlLCBbXCJlbmNyeXB0XCJdKTtcbiAgbGV0IGNpcGhlcnRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXYgfSwgY3J5cHRvS2V5LCBwbGFpbnRleHQpO1xuICBsZXQgY3RiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShpdi5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2N0YjY0fT9pdj0ke2l2YjY0fWA7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KHByaXZrZXksIHB1YmtleSwgZGF0YSkge1xuICBsZXQgW2N0YjY0LCBpdmI2NF0gPSBkYXRhLnNwbGl0KFwiP2l2PVwiKTtcbiAgbGV0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgbGV0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgY3J5cHRvS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgbm9ybWFsaXplZEtleSwgeyBuYW1lOiBcIkFFUy1DQkNcIiB9LCBmYWxzZSwgW1wiZGVjcnlwdFwiXSk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gYmFzZTY0LmRlY29kZShjdGI2NCk7XG4gIGxldCBpdiA9IGJhc2U2NC5kZWNvZGUoaXZiNjQpO1xuICBsZXQgcGxhaW50ZXh0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogXCJBRVMtQ0JDXCIsIGl2IH0sIGNyeXB0b0tleSwgY2lwaGVydGV4dCk7XG4gIGxldCB0ZXh0ID0gdXRmOERlY29kZXIuZGVjb2RlKHBsYWludGV4dCk7XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFgoa2V5KSB7XG4gIHJldHVybiBrZXkuc2xpY2UoMSwgMzMpO1xufVxuXG4vLyBuaXAwNS50c1xudmFyIG5pcDA1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA1X2V4cG9ydHMsIHtcbiAgTklQMDVfUkVHRVg6ICgpID0+IE5JUDA1X1JFR0VYLFxuICBxdWVyeVByb2ZpbGU6ICgpID0+IHF1ZXJ5UHJvZmlsZSxcbiAgc2VhcmNoRG9tYWluOiAoKSA9PiBzZWFyY2hEb21haW4sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb25cbn0pO1xudmFyIE5JUDA1X1JFR0VYID0gL14oPzooW1xcdy4rLV0rKUApPyhbXFx3Li1dKykkLztcbnZhciBfZmV0Y2g7XG50cnkge1xuICBfZmV0Y2ggPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBzZWFyY2hEb21haW4oZG9tYWluLCBxdWVyeSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzID0gYXdhaXQgKGF3YWl0IF9mZXRjaChgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7cXVlcnl9YCkpLmpzb24oKTtcbiAgICByZXR1cm4gcmVzLm5hbWVzO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeVByb2ZpbGUoZnVsbG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBmdWxsbmFtZS5tYXRjaChOSVAwNV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFtfLCBuYW1lID0gXCJfXCIsIGRvbWFpbl0gPSBtYXRjaDtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2goYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YCk7XG4gICAgY29uc3QgeyBuYW1lcywgcmVsYXlzIH0gPSBwYXJzZU5JUDA1UmVzdWx0KGF3YWl0IHJlcy5qc29uKCkpO1xuICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWVdO1xuICAgIHJldHVybiBwdWJrZXkgPyB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldIH0gOiBudWxsO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZU5JUDA1UmVzdWx0KGpzb24pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG5hbWVzOiB7fVxuICB9O1xuICBmb3IgKGNvbnN0IFtuYW1lLCBwdWJrZXldIG9mIE9iamVjdC5lbnRyaWVzKGpzb24ubmFtZXMpKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwdWJrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlc3VsdC5uYW1lc1tuYW1lXSA9IHB1YmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ucmVsYXlzKSB7XG4gICAgcmVzdWx0LnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlzXSBvZiBPYmplY3QuZW50cmllcyhqc29uLnJlbGF5cykpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkocmVsYXlzKSkge1xuICAgICAgICByZXN1bHQucmVsYXlzW3B1YmtleV0gPSByZWxheXMuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gbmlwMDYudHNcbnZhciBuaXAwNl9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNl9leHBvcnRzLCB7XG4gIGdlbmVyYXRlU2VlZFdvcmRzOiAoKSA9PiBnZW5lcmF0ZVNlZWRXb3JkcyxcbiAgcHJpdmF0ZUtleUZyb21TZWVkV29yZHM6ICgpID0+IHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzLFxuICB2YWxpZGF0ZVdvcmRzOiAoKSA9PiB2YWxpZGF0ZVdvcmRzXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgd29yZGxpc3QgfSBmcm9tIFwiQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZU1uZW1vbmljLCBtbmVtb25pY1RvU2VlZFN5bmMsIHZhbGlkYXRlTW5lbW9uaWMgfSBmcm9tIFwiQHNjdXJlL2JpcDM5XCI7XG5pbXBvcnQgeyBIREtleSB9IGZyb20gXCJAc2N1cmUvYmlwMzJcIjtcbmZ1bmN0aW9uIHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzKG1uZW1vbmljLCBwYXNzcGhyYXNlKSB7XG4gIGxldCByb290ID0gSERLZXkuZnJvbU1hc3RlclNlZWQobW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlKSk7XG4gIGxldCBwcml2YXRlS2V5ID0gcm9vdC5kZXJpdmUoYG0vNDQnLzEyMzcnLzAnLzAvMGApLnByaXZhdGVLZXk7XG4gIGlmICghcHJpdmF0ZUtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZGVyaXZlIHByaXZhdGUga2V5XCIpO1xuICByZXR1cm4gYnl0ZXNUb0hleDQocHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlZWRXb3JkcygpIHtcbiAgcmV0dXJuIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXb3Jkcyh3b3Jkcykge1xuICByZXR1cm4gdmFsaWRhdGVNbmVtb25pYyh3b3Jkcywgd29yZGxpc3QpO1xufVxuXG4vLyBuaXAxMC50c1xudmFyIG5pcDEwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEwX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlXG59KTtcbmZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdXG4gIH07XG4gIGNvbnN0IGVUYWdzID0gW107XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGVUYWdzLnB1c2godGFnKTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgdGFnWzFdKSB7XG4gICAgICByZXN1bHQucHJvZmlsZXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogdGFnWzFdLFxuICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBlVGFnSW5kZXggPSAwOyBlVGFnSW5kZXggPCBlVGFncy5sZW5ndGg7IGVUYWdJbmRleCsrKSB7XG4gICAgY29uc3QgZVRhZyA9IGVUYWdzW2VUYWdJbmRleF07XG4gICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmwsIGVUYWdNYXJrZXJdID0gZVRhZztcbiAgICBjb25zdCBldmVudFBvaW50ZXIgPSB7XG4gICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW11cbiAgICB9O1xuICAgIGNvbnN0IGlzRmlyc3RFVGFnID0gZVRhZ0luZGV4ID09PSAwO1xuICAgIGNvbnN0IGlzTGFzdEVUYWcgPSBlVGFnSW5kZXggPT09IGVUYWdzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicm9vdFwiKSB7XG4gICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyZXBseVwiKSB7XG4gICAgICByZXN1bHQucmVwbHkgPSBldmVudFBvaW50ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVUYWdNYXJrZXIgPT09IFwibWVudGlvblwiKSB7XG4gICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc0ZpcnN0RVRhZykge1xuICAgICAgcmVzdWx0LnJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzTGFzdEVUYWcpIHtcbiAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIG5pcDEzLnRzXG52YXIgbmlwMTNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTNfZXhwb3J0cywge1xuICBnZXRQb3c6ICgpID0+IGdldFBvdyxcbiAgbWluZVBvdzogKCkgPT4gbWluZVBvd1xufSk7XG5mdW5jdGlvbiBnZXRQb3coaGV4KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmliYmxlID0gcGFyc2VJbnQoaGV4W2ldLCAxNik7XG4gICAgaWYgKG5pYmJsZSA9PT0gMCkge1xuICAgICAgY291bnQgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gTWF0aC5jbHozMihuaWJibGUpIC0gMjg7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gbWluZVBvdyh1bnNpZ25lZCwgZGlmZmljdWx0eSkge1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBldmVudCA9IHVuc2lnbmVkO1xuICBjb25zdCB0YWcgPSBbXCJub25jZVwiLCBjb3VudC50b1N0cmluZygpLCBkaWZmaWN1bHR5LnRvU3RyaW5nKCldO1xuICBldmVudC50YWdzLnB1c2godGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKTtcbiAgICBpZiAobm93ICE9PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBldmVudC5jcmVhdGVkX2F0ID0gbm93O1xuICAgIH1cbiAgICB0YWdbMV0gPSAoKytjb3VudCkudG9TdHJpbmcoKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGdldFBvdyhldmVudC5pZCkgPj0gZGlmZmljdWx0eSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gbmlwMTgudHNcbnZhciBuaXAxOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOF9leHBvcnRzLCB7XG4gIGZpbmlzaFJlcG9zdEV2ZW50OiAoKSA9PiBmaW5pc2hSZXBvc3RFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudDogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlcG9zdEV2ZW50KHQsIHJlcG9zdGVkLCByZWxheVVybCwgcHJpdmF0ZUtleSkge1xuICByZXR1cm4gZmluaXNoRXZlbnQoXG4gICAge1xuICAgICAga2luZDogNiAvKiBSZXBvc3QgKi8sXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkocmVwb3N0ZWQpLFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gNiAvKiBSZXBvc3QgKi8pIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGktLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaV07XG4gICAgaWYgKHRhZy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgbGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0RVRhZyA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInBcIiAmJiBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RQVGFnID0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnPy5bMl1dLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIpLFxuICAgIGF1dGhvcjogbGFzdFBUYWc/LlsxXVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVwb3N0ZWRFdmVudChldmVudCwgeyBza2lwVmVyaWZpY2F0aW9uIH0gPSB7fSkge1xuICBjb25zdCBwb2ludGVyID0gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXIoZXZlbnQpO1xuICBpZiAocG9pbnRlciA9PT0gdm9pZCAwIHx8IGV2ZW50LmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCByZXBvc3RlZEV2ZW50O1xuICB0cnkge1xuICAgIHJlcG9zdGVkRXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlcG9zdGVkRXZlbnQuaWQgIT09IHBvaW50ZXIuaWQpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICghc2tpcFZlcmlmaWNhdGlvbiAmJiAhdmVyaWZ5U2lnbmF0dXJlKHJlcG9zdGVkRXZlbnQpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVwb3N0ZWRFdmVudDtcbn1cblxuLy8gbmlwMjEudHNcbnZhciBuaXAyMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyMV9leHBvcnRzLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gTk9TVFJfVVJJX1JFR0VYLFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICB0ZXN0OiAoKSA9PiB0ZXN0XG59KTtcbnZhciBOT1NUUl9VUklfUkVHRVggPSBuZXcgUmVnRXhwKGBub3N0cjooJHtCRUNIMzJfUkVHRVguc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKS50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMih1cmkpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gobmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dXJpfWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogbWF0Y2hbMF0sXG4gICAgdmFsdWU6IG1hdGNoWzFdLFxuICAgIGRlY29kZWQ6IGRlY29kZShtYXRjaFsxXSlcbiAgfTtcbn1cblxuLy8gbmlwMjUudHNcbnZhciBuaXAyNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNV9leHBvcnRzLCB7XG4gIGZpbmlzaFJlYWN0aW9uRXZlbnQ6ICgpID0+IGZpbmlzaFJlYWN0aW9uRXZlbnQsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlYWN0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVhY3Rpb25FdmVudCh0LCByZWFjdGVkLCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IGluaGVyaXRlZFRhZ3MgPSByZWFjdGVkLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZy5sZW5ndGggPj0gMiAmJiAodGFnWzBdID09PSBcImVcIiB8fCB0YWdbMF0gPT09IFwicFwiKSk7XG4gIHJldHVybiBmaW5pc2hFdmVudChcbiAgICB7XG4gICAgICAuLi50LFxuICAgICAga2luZDogNyAvKiBSZWFjdGlvbiAqLyxcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIC4uLmluaGVyaXRlZFRhZ3MsIFtcImVcIiwgcmVhY3RlZC5pZF0sIFtcInBcIiwgcmVhY3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA/PyBcIitcIlxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gNyAvKiBSZWFjdGlvbiAqLykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGxhc3RFVGFnO1xuICBsZXQgbGFzdFBUYWc7XG4gIGZvciAobGV0IGkgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaS0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZ1syXV0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApLFxuICAgIGF1dGhvcjogbGFzdFBUYWdbMV1cbiAgfTtcbn1cblxuLy8gbmlwMjYudHNcbnZhciBuaXAyNl9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNl9leHBvcnRzLCB7XG4gIGNyZWF0ZURlbGVnYXRpb246ICgpID0+IGNyZWF0ZURlbGVnYXRpb24sXG4gIGdldERlbGVnYXRvcjogKCkgPT4gZ2V0RGVsZWdhdG9yXG59KTtcbmltcG9ydCB7IHNjaG5vcnIgYXMgc2Nobm9ycjMgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDUgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmZ1bmN0aW9uIGNyZWF0ZURlbGVnYXRpb24ocHJpdmF0ZUtleSwgcGFyYW1ldGVycykge1xuICBsZXQgY29uZGl0aW9ucyA9IFtdO1xuICBpZiAoKHBhcmFtZXRlcnMua2luZCB8fCAtMSkgPj0gMClcbiAgICBjb25kaXRpb25zLnB1c2goYGtpbmQ9JHtwYXJhbWV0ZXJzLmtpbmR9YCk7XG4gIGlmIChwYXJhbWV0ZXJzLnVudGlsKVxuICAgIGNvbmRpdGlvbnMucHVzaChgY3JlYXRlZF9hdDwke3BhcmFtZXRlcnMudW50aWx9YCk7XG4gIGlmIChwYXJhbWV0ZXJzLnNpbmNlKVxuICAgIGNvbmRpdGlvbnMucHVzaChgY3JlYXRlZF9hdD4ke3BhcmFtZXRlcnMuc2luY2V9YCk7XG4gIGxldCBjb25kID0gY29uZGl0aW9ucy5qb2luKFwiJlwiKTtcbiAgaWYgKGNvbmQgPT09IFwiXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVmdXNpbmcgdG8gY3JlYXRlIGEgZGVsZWdhdGlvbiB3aXRob3V0IGFueSBjb25kaXRpb25zXCIpO1xuICBsZXQgc2lnaGFzaCA9IHNoYTI1NjIodXRmOEVuY29kZXIuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7cGFyYW1ldGVycy5wdWJrZXl9OiR7Y29uZH1gKSk7XG4gIGxldCBzaWcgPSBieXRlc1RvSGV4NShzY2hub3JyMy5zaWduKHNpZ2hhc2gsIHByaXZhdGVLZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSksXG4gICAgdG86IHBhcmFtZXRlcnMucHVia2V5LFxuICAgIGNvbmQsXG4gICAgc2lnXG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWxlZ2F0b3IoZXZlbnQpIHtcbiAgbGV0IHRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodGFnMikgPT4gdGFnMlswXSA9PT0gXCJkZWxlZ2F0aW9uXCIgJiYgdGFnMi5sZW5ndGggPj0gNCk7XG4gIGlmICghdGFnKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcHVia2V5ID0gdGFnWzFdO1xuICBsZXQgY29uZCA9IHRhZ1syXTtcbiAgbGV0IHNpZyA9IHRhZ1szXTtcbiAgbGV0IGNvbmRpdGlvbnMgPSBjb25kLnNwbGl0KFwiJlwiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25kaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtrZXksIG9wZXJhdG9yLCB2YWx1ZV0gPSBjb25kaXRpb25zW2ldLnNwbGl0KC9cXGIvKTtcbiAgICBpZiAoa2V5ID09PSBcImtpbmRcIiAmJiBvcGVyYXRvciA9PT0gXCI9XCIgJiYgZXZlbnQua2luZCA9PT0gcGFyc2VJbnQodmFsdWUpKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZSBpZiAoa2V5ID09PSBcImNyZWF0ZWRfYXRcIiAmJiBvcGVyYXRvciA9PT0gXCI8XCIgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IHBhcnNlSW50KHZhbHVlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2UgaWYgKGtleSA9PT0gXCJjcmVhdGVkX2F0XCIgJiYgb3BlcmF0b3IgPT09IFwiPlwiICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBwYXJzZUludCh2YWx1ZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc2lnaGFzaCA9IHNoYTI1NjIodXRmOEVuY29kZXIuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7ZXZlbnQucHVia2V5fToke2NvbmR9YCkpO1xuICBpZiAoIXNjaG5vcnIzLnZlcmlmeShzaWcsIHNpZ2hhc2gsIHB1YmtleSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBwdWJrZXk7XG59XG5cbi8vIG5pcDI3LnRzXG52YXIgbmlwMjdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjdfZXhwb3J0cywge1xuICBtYXRjaEFsbDogKCkgPT4gbWF0Y2hBbGwsXG4gIHJlZ2V4OiAoKSA9PiByZWdleCxcbiAgcmVwbGFjZUFsbDogKCkgPT4gcmVwbGFjZUFsbFxufSk7XG52YXIgcmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcYiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX1cXFxcYmAsIFwiZ1wiKTtcbmZ1bmN0aW9uKiBtYXRjaEFsbChjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4KCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3VyaSwgdmFsdWVdID0gbWF0Y2g7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHVyaSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRlY29kZWQ6IGRlY29kZSh2YWx1ZSksXG4gICAgICAgIHN0YXJ0OiBtYXRjaC5pbmRleCxcbiAgICAgICAgZW5kOiBtYXRjaC5pbmRleCArIHVyaS5sZW5ndGhcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoY29udGVudCwgcmVwbGFjZXIpIHtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChyZWdleCgpLCAodXJpLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICB1cmksXG4gICAgICB2YWx1ZSxcbiAgICAgIGRlY29kZWQ6IGRlY29kZSh2YWx1ZSlcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIG5pcDI4LnRzXG52YXIgbmlwMjhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjhfZXhwb3J0cywge1xuICBjaGFubmVsQ3JlYXRlRXZlbnQ6ICgpID0+IGNoYW5uZWxDcmVhdGVFdmVudCxcbiAgY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQ6ICgpID0+IGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50LFxuICBjaGFubmVsTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsTWVzc2FnZUV2ZW50LFxuICBjaGFubmVsTWV0YWRhdGFFdmVudDogKCkgPT4gY2hhbm5lbE1ldGFkYXRhRXZlbnQsXG4gIGNoYW5uZWxNdXRlVXNlckV2ZW50OiAoKSA9PiBjaGFubmVsTXV0ZVVzZXJFdmVudFxufSk7XG52YXIgY2hhbm5lbENyZWF0ZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluaXNoRXZlbnQoXG4gICAge1xuICAgICAga2luZDogNDAgLyogQ2hhbm5lbENyZWF0aW9uICovLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluaXNoRXZlbnQoXG4gICAge1xuICAgICAga2luZDogNDEgLyogQ2hhbm5lbE1ldGFkYXRhICovLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBjb25zdCB0YWdzID0gW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZCwgdC5yZWxheV91cmwsIFwicm9vdFwiXV07XG4gIGlmICh0LnJlcGx5X3RvX2NoYW5uZWxfbWVzc2FnZV9ldmVudF9pZCkge1xuICAgIHRhZ3MucHVzaChbXCJlXCIsIHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyZXBseVwiXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmlzaEV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IDQyIC8qIENoYW5uZWxNZXNzYWdlICovLFxuICAgICAgdGFnczogWy4uLnRhZ3MsIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5pc2hFdmVudChcbiAgICB7XG4gICAgICBraW5kOiA0MyAvKiBDaGFubmVsSGlkZU1lc3NhZ2UgKi8sXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluaXNoRXZlbnQoXG4gICAge1xuICAgICAga2luZDogNDQgLyogQ2hhbm5lbE11dGVVc2VyICovLFxuICAgICAgdGFnczogW1tcInBcIiwgdC5wdWJrZXlfdG9fbXV0ZV0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMjtcbnRyeSB7XG4gIF9mZXRjaDIgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gyID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gyKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQyLnRzXG52YXIgbmlwNDJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDJfZXhwb3J0cywge1xuICBhdXRoZW50aWNhdGU6ICgpID0+IGF1dGhlbnRpY2F0ZVxufSk7XG52YXIgYXV0aGVudGljYXRlID0gYXN5bmMgKHtcbiAgY2hhbGxlbmdlLFxuICByZWxheSxcbiAgc2lnblxufSkgPT4ge1xuICBjb25zdCBlID0ge1xuICAgIGtpbmQ6IDIyMjQyIC8qIENsaWVudEF1dGggKi8sXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheS51cmxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbiAgcmV0dXJuIHJlbGF5LmF1dGgoYXdhaXQgc2lnbihlKSk7XG59O1xuXG4vLyBuaXA0NC50c1xudmFyIG5pcDQ0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdDIsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHQyLFxuICB1dGlsczogKCkgPT4gdXRpbHNcbn0pO1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhXCI7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcyB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiO1xuaW1wb3J0IHsgc2VjcDI1NmsxIGFzIHNlY3AyNTZrMTIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGhrZGYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9oa2RmXCI7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaG1hY1wiO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEJ5dGVzMiwgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgdXRpbHMgPSB7XG4gIHYyOiB7XG4gICAgbWF4UGxhaW50ZXh0U2l6ZTogNjU1MzYgLSAxMjgsXG4gICAgbWluQ2lwaGVydGV4dFNpemU6IDEwMCxcbiAgICBtYXhDaXBoZXJ0ZXh0U2l6ZTogMTAyNDAwLFxuICAgIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICAgICAgY29uc3Qga2V5ID0gc2VjcDI1NmsxMi5nZXRTaGFyZWRTZWNyZXQocHJpdmtleUEsIFwiMDJcIiArIHB1YmtleUIpO1xuICAgICAgcmV0dXJuIGtleS5zdWJhcnJheSgxLCAzMyk7XG4gICAgfSxcbiAgICBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIHNhbHQpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBoa2RmKHNoYTI1NjMsIGNvbnZlcnNhdGlvbktleSwgc2FsdCwgXCJuaXA0NC12MlwiLCA3Nik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0aW9uOiBrZXlzLnN1YmFycmF5KDAsIDMyKSxcbiAgICAgICAgbm9uY2U6IGtleXMuc3ViYXJyYXkoMzIsIDQ0KSxcbiAgICAgICAgYXV0aDoga2V5cy5zdWJhcnJheSg0NCwgNzYpXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2FsY1BhZGRpbmcobGVuKSB7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxlbikgfHwgbGVuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICAgIGlmIChsZW4gPD0gMzIpXG4gICAgICAgIHJldHVybiAzMjtcbiAgICAgIGNvbnN0IG5leHRwb3dlciA9IDEgPDwgTWF0aC5mbG9vcihNYXRoLmxvZzIobGVuIC0gMSkpICsgMTtcbiAgICAgIGNvbnN0IGNodW5rID0gbmV4dHBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dHBvd2VyIC8gODtcbiAgICAgIHJldHVybiBjaHVuayAqIChNYXRoLmZsb29yKChsZW4gLSAxKSAvIGNodW5rKSArIDEpO1xuICAgIH0sXG4gICAgcGFkKHVucGFkZGVkKSB7XG4gICAgICBjb25zdCB1bnBhZGRlZEIgPSB1dGY4RW5jb2Rlci5lbmNvZGUodW5wYWRkZWQpO1xuICAgICAgY29uc3QgbGVuID0gdW5wYWRkZWRCLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCAxIHx8IGxlbiA+PSB1dGlscy52Mi5tYXhQbGFpbnRleHRTaXplKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBsZW5ndGg6IG11c3QgYmUgYmV0d2VlbiAxYiBhbmQgNjRLQlwiKTtcbiAgICAgIGNvbnN0IHBhZGRlZExlbiA9IHV0aWxzLnYyLmNhbGNQYWRkaW5nKGxlbik7XG4gICAgICBjb25zdCB6ZXJvcyA9IG5ldyBVaW50OEFycmF5KHBhZGRlZExlbiAtIGxlbik7XG4gICAgICBjb25zdCBsZW5CdWYgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgICAgIG5ldyBEYXRhVmlldyhsZW5CdWYuYnVmZmVyKS5zZXRVaW50MTYoMCwgbGVuKTtcbiAgICAgIHJldHVybiBjb25jYXRCeXRlczIobGVuQnVmLCB1bnBhZGRlZEIsIHplcm9zKTtcbiAgICB9LFxuICAgIHVucGFkKHBhZGRlZCkge1xuICAgICAgY29uc3QgdW5wYWRkZWRMZW4gPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICAgICAgY29uc3QgdW5wYWRkZWQgPSBwYWRkZWQuc3ViYXJyYXkoMiwgMiArIHVucGFkZGVkTGVuKTtcbiAgICAgIGlmICh1bnBhZGRlZExlbiA9PT0gMCB8fCB1bnBhZGRlZC5sZW5ndGggIT09IHVucGFkZGVkTGVuIHx8IHBhZGRlZC5sZW5ndGggIT09IDIgKyB1dGlscy52Mi5jYWxjUGFkZGluZyh1bnBhZGRlZExlbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFkZGluZ1wiKTtcbiAgICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodW5wYWRkZWQpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGVuY3J5cHQyKGtleSwgcGxhaW50ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/PyAyO1xuICBpZiAodmVyc2lvbiAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvbiBcIiArIHZlcnNpb24pO1xuICBjb25zdCBzYWx0ID0gb3B0aW9ucy5zYWx0ID8/IHJhbmRvbUJ5dGVzMigzMik7XG4gIGVuc3VyZUJ5dGVzKHNhbHQsIDMyKTtcbiAgY29uc3Qga2V5cyA9IHV0aWxzLnYyLmdldE1lc3NhZ2VLZXlzKGtleSwgc2FsdCk7XG4gIGNvbnN0IHBhZGRlZCA9IHV0aWxzLnYyLnBhZChwbGFpbnRleHQpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gY2hhY2hhMjAoa2V5cy5lbmNyeXB0aW9uLCBrZXlzLm5vbmNlLCBwYWRkZWQpO1xuICBjb25zdCBtYWMgPSBobWFjKHNoYTI1NjMsIGtleXMuYXV0aCwgY2lwaGVydGV4dCk7XG4gIHJldHVybiBiYXNlNjQyLmVuY29kZShjb25jYXRCeXRlczIobmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb25dKSwgc2FsdCwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihrZXksIGNpcGhlcnRleHQpIHtcbiAgY29uc3QgdSA9IHV0aWxzLnYyO1xuICBlbnN1cmVCeXRlcyhrZXksIDMyKTtcbiAgY29uc3QgY2xlbiA9IGNpcGhlcnRleHQubGVuZ3RoO1xuICBpZiAoY2xlbiA8IHUubWluQ2lwaGVydGV4dFNpemUgfHwgY2xlbiA+PSB1Lm1heENpcGhlcnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBsZW5ndGg6IFwiICsgY2xlbik7XG4gIGlmIChjaXBoZXJ0ZXh0WzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGJhc2U2NDIuZGVjb2RlKGNpcGhlcnRleHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IHZlcnMgPSBkYXRhLnN1YmFycmF5KDAsIDEpWzBdO1xuICBpZiAodmVycyAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvbiBcIiArIHZlcnMpO1xuICBjb25zdCBzYWx0ID0gZGF0YS5zdWJhcnJheSgxLCAzMyk7XG4gIGNvbnN0IGNpcGhlcnRleHRfID0gZGF0YS5zdWJhcnJheSgzMywgLTMyKTtcbiAgY29uc3QgbWFjID0gZGF0YS5zdWJhcnJheSgtMzIpO1xuICBjb25zdCBrZXlzID0gdS5nZXRNZXNzYWdlS2V5cyhrZXksIHNhbHQpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hYyhzaGEyNTYzLCBrZXlzLmF1dGgsIGNpcGhlcnRleHRfKTtcbiAgaWYgKCFlcXVhbEJ5dGVzKGNhbGN1bGF0ZWRNYWMsIG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNQUNcIik7XG4gIGNvbnN0IHBhZGRlZCA9IGNoYWNoYTIwKGtleXMuZW5jcnlwdGlvbiwga2V5cy5ub25jZSwgY2lwaGVydGV4dF8pO1xuICByZXR1cm4gdS51bnBhZChwYWRkZWQpO1xufVxuXG4vLyBuaXA0Ny50c1xudmFyIG5pcDQ3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ3X2V4cG9ydHMsIHtcbiAgbWFrZU53Y1JlcXVlc3RFdmVudDogKCkgPT4gbWFrZU53Y1JlcXVlc3RFdmVudCxcbiAgcGFyc2VDb25uZWN0aW9uU3RyaW5nOiAoKSA9PiBwYXJzZUNvbm5lY3Rpb25TdHJpbmdcbn0pO1xuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBjb25zdCBwdWJrZXkgPSBwYXRobmFtZTtcbiAgY29uc3QgcmVsYXkgPSBzZWFyY2hQYXJhbXMuZ2V0KFwicmVsYXlcIik7XG4gIGNvbnN0IHNlY3JldCA9IHNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gIGlmICghcHVia2V5IHx8ICFyZWxheSB8fCAhc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uIHN0cmluZ1wiKTtcbiAgfVxuICByZXR1cm4geyBwdWJrZXksIHJlbGF5LCBzZWNyZXQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VOd2NSZXF1ZXN0RXZlbnQoe1xuICBwdWJrZXksXG4gIHNlY3JldCxcbiAgaW52b2ljZVxufSkge1xuICBjb25zdCBjb250ZW50ID0ge1xuICAgIG1ldGhvZDogXCJwYXlfaW52b2ljZVwiLFxuICAgIHBhcmFtczoge1xuICAgICAgaW52b2ljZVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5jcnlwdGVkQ29udGVudCA9IGF3YWl0IGVuY3J5cHQoc2VjcmV0LCBwdWJrZXksIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcbiAgY29uc3QgZXZlbnRUZW1wbGF0ZSA9IHtcbiAgICBraW5kOiAyMzE5NCAvKiBOd2NSZXF1ZXN0ICovLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgY29udGVudDogZW5jcnlwdGVkQ29udGVudCxcbiAgICB0YWdzOiBbW1wicFwiLCBwdWJrZXldXVxuICB9O1xuICByZXR1cm4gZmluaXNoRXZlbnQoZXZlbnRUZW1wbGF0ZSwgc2VjcmV0KTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiBnZXRaYXBFbmRwb2ludCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1ha2VaYXBSZWNlaXB0LFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gbWFrZVphcFJlcXVlc3QsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb24zLFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IHZhbGlkYXRlWmFwUmVxdWVzdFxufSk7XG5pbXBvcnQgeyBiZWNoMzIgYXMgYmVjaDMyMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9mZXRjaDM7XG50cnkge1xuICBfZmV0Y2gzID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24zKGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoMyA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRaYXBFbmRwb2ludChtZXRhZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBsbnVybCA9IFwiXCI7XG4gICAgbGV0IHsgbHVkMDYsIGx1ZDE2IH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhLmNvbnRlbnQpO1xuICAgIGlmIChsdWQwNikge1xuICAgICAgbGV0IHsgd29yZHMgfSA9IGJlY2gzMjIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgICAgbGV0IGRhdGEgPSBiZWNoMzIyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgICBsbnVybCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDE2KSB7XG4gICAgICBsZXQgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgICBsbnVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgX2ZldGNoMyhsbnVybCk7XG4gICAgbGV0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChib2R5LmFsbG93c05vc3RyICYmIGJvZHkubm9zdHJQdWJrZXkpIHtcbiAgICAgIHJldHVybiBib2R5LmNhbGxiYWNrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVxdWVzdCh7XG4gIHByb2ZpbGUsXG4gIGV2ZW50LFxuICBhbW91bnQsXG4gIHJlbGF5cyxcbiAgY29tbWVudCA9IFwiXCJcbn0pIHtcbiAgaWYgKCFhbW91bnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCFwcm9maWxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgenIgPSB7XG4gICAga2luZDogOTczNCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGNvbW1lbnQsXG4gICAgdGFnczogW1xuICAgICAgW1wicFwiLCBwcm9maWxlXSxcbiAgICAgIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucmVsYXlzXVxuICAgIF1cbiAgfTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgenIudGFncy5wdXNoKFtcImVcIiwgZXZlbnRdKTtcbiAgfVxuICByZXR1cm4genI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVphcFJlcXVlc3QoemFwUmVxdWVzdFN0cmluZykge1xuICBsZXQgemFwUmVxdWVzdDtcbiAgdHJ5IHtcbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0U3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCF2ZXJpZnlTaWduYXR1cmUoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJib2x0MTFcIiwgYm9sdDExXSwgW1wiZGVzY3JpcHRpb25cIiwgemFwUmVxdWVzdF1dXG4gIH07XG4gIGlmIChwcmVpbWFnZSkge1xuICAgIHphcC50YWdzLnB1c2goW1wicHJlaW1hZ2VcIiwgcHJlaW1hZ2VdKTtcbiAgfVxuICByZXR1cm4gemFwO1xufVxuXG4vLyBuaXA5OC50c1xudmFyIG5pcDk4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDk4X2V4cG9ydHMsIHtcbiAgZ2V0VG9rZW46ICgpID0+IGdldFRva2VuLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZVRva2VuOiAoKSA9PiB2YWxpZGF0ZVRva2VuXG59KTtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQzIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgX2F1dGhvcml6YXRpb25TY2hlbWUgPSBcIk5vc3RyIFwiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW4obG9naW5VcmwsIGh0dHBNZXRob2QsIHNpZ24sIGluY2x1ZGVBdXRob3JpemF0aW9uU2NoZW1lID0gZmFsc2UpIHtcbiAgaWYgKCFsb2dpblVybCB8fCAhaHR0cE1ldGhvZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGxvZ2luVXJsIG9yIGh0dHBNZXRob2RcIik7XG4gIGNvbnN0IGV2ZW50ID0gZ2V0QmxhbmtFdmVudCgyNzIzNSAvKiBIdHRwQXV0aCAqLyk7XG4gIGV2ZW50LnRhZ3MgPSBbXG4gICAgW1widVwiLCBsb2dpblVybF0sXG4gICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gIF07XG4gIGV2ZW50LmNyZWF0ZWRfYXQgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKTtcbiAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBzaWduKGV2ZW50KTtcbiAgY29uc3QgYXV0aG9yaXphdGlvblNjaGVtZSA9IGluY2x1ZGVBdXRob3JpemF0aW9uU2NoZW1lID8gX2F1dGhvcml6YXRpb25TY2hlbWUgOiBcIlwiO1xuICByZXR1cm4gYXV0aG9yaXphdGlvblNjaGVtZSArIGJhc2U2NDMuZW5jb2RlKHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShzaWduZWRFdmVudCkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVG9rZW4odG9rZW4sIHVybCwgbWV0aG9kKSB7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdW5wYWNrRXZlbnRGcm9tVG9rZW4odG9rZW4pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcbiAgY29uc3QgdmFsaWQgPSBhd2FpdCB2YWxpZGF0ZUV2ZW50MihldmVudCwgdXJsLCBtZXRob2QpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcbiAgcmV0dXJuIHZhbGlkO1xufVxuYXN5bmMgZnVuY3Rpb24gdW5wYWNrRXZlbnRGcm9tVG9rZW4odG9rZW4pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdG9rZW5cIik7XG4gIH1cbiAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKF9hdXRob3JpemF0aW9uU2NoZW1lLCBcIlwiKTtcbiAgY29uc3QgZXZlbnRCNjQgPSB1dGY4RGVjb2Rlci5kZWNvZGUoYmFzZTY0My5kZWNvZGUodG9rZW4pKTtcbiAgaWYgKCFldmVudEI2NCB8fCBldmVudEI2NC5sZW5ndGggPT09IDAgfHwgIWV2ZW50QjY0LnN0YXJ0c1dpdGgoXCJ7XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBldmVudCA9IEpTT04ucGFyc2UoZXZlbnRCNjQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50MihldmVudCwgdXJsLCBtZXRob2QpIHtcbiAgaWYgKCFldmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnRcIik7XG4gIH1cbiAgaWYgKCF2ZXJpZnlTaWduYXR1cmUoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKGV2ZW50LmtpbmQgIT09IDI3MjM1IC8qIEh0dHBBdXRoICovKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwga2luZCBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMykgLSBldmVudC5jcmVhdGVkX2F0ID4gNjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBleHBpcmVkXCIpO1xuICB9XG4gIGNvbnN0IHVybFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJ1XCIpO1xuICBpZiAodXJsVGFnPy5sZW5ndGggIT09IDEgJiYgdXJsVGFnPy5bMV0gIT09IHVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHVybCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBjb25zdCBtZXRob2RUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwibWV0aG9kXCIpO1xuICBpZiAobWV0aG9kVGFnPy5sZW5ndGggIT09IDEgJiYgbWV0aG9kVGFnPy5bMV0udG9Mb3dlckNhc2UoKSAhPT0gbWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBtZXRob2QgdGFnIGludmFsaWRcIik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBLaW5kLFxuICBTaW1wbGVQb29sLFxuICBldmVudHNHZW5lcmF0b3IsXG4gIGZpbmlzaEV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVByaXZhdGVLZXksXG4gIGdldEJsYW5rRXZlbnQsXG4gIGdldEV2ZW50SGFzaCxcbiAgZ2V0UHVibGljS2V5LFxuICBnZXRTaWduYXR1cmUsXG4gIG1hdGNoRmlsdGVyLFxuICBtYXRjaEZpbHRlcnMsXG4gIG1lcmdlRmlsdGVycyxcbiAgbmlwMDRfZXhwb3J0cyBhcyBuaXAwNCxcbiAgbmlwMDVfZXhwb3J0cyBhcyBuaXAwNSxcbiAgbmlwMDZfZXhwb3J0cyBhcyBuaXAwNixcbiAgbmlwMTBfZXhwb3J0cyBhcyBuaXAxMCxcbiAgbmlwMTNfZXhwb3J0cyBhcyBuaXAxMyxcbiAgbmlwMThfZXhwb3J0cyBhcyBuaXAxOCxcbiAgbmlwMTlfZXhwb3J0cyBhcyBuaXAxOSxcbiAgbmlwMjFfZXhwb3J0cyBhcyBuaXAyMSxcbiAgbmlwMjVfZXhwb3J0cyBhcyBuaXAyNSxcbiAgbmlwMjZfZXhwb3J0cyBhcyBuaXAyNixcbiAgbmlwMjdfZXhwb3J0cyBhcyBuaXAyNyxcbiAgbmlwMjhfZXhwb3J0cyBhcyBuaXAyOCxcbiAgbmlwMzlfZXhwb3J0cyBhcyBuaXAzOSxcbiAgbmlwNDJfZXhwb3J0cyBhcyBuaXA0MixcbiAgbmlwNDRfZXhwb3J0cyBhcyBuaXA0NCxcbiAgbmlwNDdfZXhwb3J0cyBhcyBuaXA0NyxcbiAgbmlwNTdfZXhwb3J0cyBhcyBuaXA1NyxcbiAgbmlwOThfZXhwb3J0cyBhcyBuaXA5OCxcbiAgcGFyc2VSZWZlcmVuY2VzLFxuICByZWxheUluaXQsXG4gIHNlcmlhbGl6ZUV2ZW50LFxuICBzaWduRXZlbnQsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlTaWduYXR1cmVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/nostr-tools/lib/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRyxhQUFhLGdCQUFnQjtBQUNyRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxHQUFHLE9BQU8sS0FBSztBQUMvRTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUssT0FBTyxLQUFLO0FBQ2xGO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4RjtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxnQkFBZ0IsTUFBTTtBQUM5RTtBQUNBLGtCQUFrQixPQUFPLEdBQUcsNEJBQTRCLEVBQUUsNENBQTRDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0Esd0RBQXdELFlBQVksR0FBRyxJQUFJLGtCQUFrQixNQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxjQUFjLElBQUk7QUFDekUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQzFGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERvY3VtZW50c1xcU2l0ZXNcXFNpdGVzXFxlbSBkZXNlbnZvbHZpbWVudG9cXFBvcnRmb2xpbzJcXG5vZGVfbW9kdWxlc1xcbm9zdHItdG9vbHNcXG5vZGVfbW9kdWxlc1xcQHNjdXJlXFxiYXNlXFxsaWJcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRzW2ldKSB8fCBkaWdpdHNbaV0gKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghZGlnaXRzW2ldKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxO1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IHV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG5leHBvcnQgY29uc3QgYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7YmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoQ09ERVJTKS5qb2luKCcsICcpfWA7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./styles/ArrowIcons.ts":
/*!******************************!*\
  !*** ./styles/ArrowIcons.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOWN: () => (/* binding */ DOWN),\n/* harmony export */   LEFT: () => (/* binding */ LEFT),\n/* harmony export */   RIGHT: () => (/* binding */ RIGHT),\n/* harmony export */   UP: () => (/* binding */ UP)\n/* harmony export */ });\nconst UP = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKElEQVR42mOgMRgF6enp/ynSDMMUaEZgsjST5RJsikk2AKc4bcAoAADI7y5FsB5j/QAAAABJRU5ErkJggg==\";\nconst DOWN = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAK0lEQVR42mOgARgF6enp/0kRZ8KvGMEnyQUwjMwn0xBMzWQZQlmA0h6MAgAuqCnfdOk/ZQAAAABJRU5ErkJggg==\";\nconst LEFT = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAG0lEQVR42mPAD0ZBenr6fxge4ppHuiGEwSgAAGJiLkXUVlYDAAAAAElFTkSuQmCC\";\nconst RIGHT = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAG0lEQVR42mPADkZBenr6fxgeZoYMV82Ug1EAAPiTLkWjutmQAAAAAElFTkSuQmCC\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3N0eWxlcy9BcnJvd0ljb25zLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTyxNQUFNQSxLQUNYLDZKQUE2SjtBQUV4SixNQUFNQyxPQUNYLGlLQUFpSztBQUU1SixNQUFNQyxPQUNYLHlJQUF5STtBQUVwSSxNQUFNQyxRQUNYLHlJQUF5SSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxzdHlsZXNcXEFycm93SWNvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFVQID1cclxuICBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFLRWxFUVZSNDJtT2dNUmdGNmVucC95blNETU1VYUVaZ3NqU1Q1UkpzaWtrMkFLYzRiY0FvQUFESTd5NUZzQjVqL1FBQUFBQkpSVTVFcmtKZ2dnPT1cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBET1dOID1cclxuICBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFLMGxFUVZSNDJtT2dBUmdGNmVucC8wa1JaOEt2R01FbnlRVXdqTXduMHhCTXpXUVpRbG1BMGg2TUFnQXVxQ25mZE9rL1pRQUFBQUJKUlU1RXJrSmdnZz09XCI7XHJcblxyXG5leHBvcnQgY29uc3QgTEVGVCA9XHJcbiAgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBRzBsRVFWUjQybVBBRDBaQmVucjZmeGdlNHBwSHVpR0V3U2dBQUdKaUxrWFVWbFlEQUFBQUFFbEZUa1N1UW1DQ1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJJR0hUID1cclxuICBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFHMGxFUVZSNDJtUEFEa1pCZW5yNmZ4Z2Vab1lNVjgyVWcxRUFBUGlUTGtXanV0bVFBQUFBQUVsRlRrU3VRbUNDXCI7XHJcbiJdLCJuYW1lcyI6WyJVUCIsIkRPV04iLCJMRUZUIiwiUklHSFQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./styles/ArrowIcons.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./styles/common/ScrollBars.ts":
/*!*************************************!*\
  !*** ./styles/common/ScrollBars.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ \"(pages-dir-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var styles_ArrowIcons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styles/ArrowIcons */ \"(pages-dir-browser)/./styles/ArrowIcons.ts\");\n/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/constants */ \"(pages-dir-browser)/./utils/constants.ts\");\n\n\n\nconst colorScheme = {\n    dark: {\n        active: \"rgb(166, 166, 166)\",\n        blendMode: \"color-burn\",\n        buttonHover: \"rgb(55, 55, 55)\",\n        thumb: \"rgb(77, 77, 77)\",\n        thumbHover: \"rgb(122, 122, 122)\",\n        track: \"rgb(23, 23, 23)\"\n    },\n    light: {\n        active: \"rgb(96, 96, 96)\",\n        blendMode: \"color-dodge\",\n        buttonHover: \"rgb(218, 218, 218)\",\n        thumb: \"rgb(205, 205, 205)\",\n        thumbHover: \"rgb(166, 166, 166)\",\n        track: \"rgb(240, 240, 240)\"\n    }\n};\nconst ScrollBars = (size = utils_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SCROLLBAR_WIDTH, verticalX = 0, verticalY = 0, scheme = \"dark\")=>(0,styled_components__WEBPACK_IMPORTED_MODULE_2__.css)([\n        `\n  overflow: auto;\n  scrollbar-gutter: stable;\n\n  @supports not selector(::-webkit-scrollbar) {\n    scrollbar-color: `,\n        ` `,\n        `;\n  }\n\n  &::-webkit-scrollbar {\n    height: `,\n        `px;\n    width: `,\n        `px;\n  }\n\n  &::-webkit-scrollbar-corner,\n  &::-webkit-scrollbar-track {\n    background-color: `,\n        `;\n  }\n\n  &::-webkit-scrollbar-thumb {\n    background-clip: padding-box;\n    background-color: `,\n        `;\n  }\n\n  &::-webkit-scrollbar-thumb:vertical {\n    background-clip: padding-box;\n    background-color: `,\n        `;\n    border-left: 1px solid transparent;\n    border-right: 1px solid transparent;\n  }\n\n  &::-webkit-scrollbar-thumb:horizontal {\n    border-bottom: 1px solid transparent;\n    border-top: 1px solid transparent;\n  }\n\n  &::-webkit-scrollbar-thumb:hover {\n    background-color: `,\n        `;\n  }\n\n  &::-webkit-scrollbar-thumb:active {\n    background-color: `,\n        `;\n  }\n\n  &::-webkit-scrollbar-button:single-button {\n    background-clip: padding-box;\n    background-color: `,\n        `;\n    background-position: center 4px;\n    background-repeat: no-repeat;\n    background-size: 10px;\n    border: 1px solid `,\n        `;\n    display: block;\n    height: `,\n        `;\n\n    &:hover {\n      background-color: `,\n        `;\n    }\n\n    &:active {\n      background-color: `,\n        `;\n    }\n  }\n\n  &::-webkit-scrollbar-button:single-button:vertical:decrement,\n  &::-webkit-scrollbar-button:single-button:vertical:increment {\n    background-position-x: `,\n        `;\n    background-position-y: `,\n        `;\n    background-size: 16px;\n    border-bottom: 0;\n    border-top: 0;\n    image-rendering: pixelated;\n  }\n\n  &::-webkit-scrollbar-button:single-button:vertical:decrement {\n    background-image: url(`,\n        `);\n  }\n\n  &::-webkit-scrollbar-button:single-button:vertical:increment {\n    background-image: url(`,\n        `);\n  }\n\n  &::-webkit-scrollbar-button:single-button:horizontal:decrement,\n  &::-webkit-scrollbar-button:single-button:horizontal:increment {\n    background-position: center;\n    background-size: 16px;\n    border-left: 0;\n    border-right: 0;\n    image-rendering: pixelated;\n  }\n\n  &::-webkit-scrollbar-button:single-button:horizontal:decrement {\n    background-image: url(`,\n        `);\n  }\n\n  &::-webkit-scrollbar-button:single-button:horizontal:increment {\n    background-image: url(`,\n        `);\n  }\n\n  &::-webkit-scrollbar-button:single-button:vertical:decrement:active,\n  &::-webkit-scrollbar-button:single-button:vertical:increment:active,\n  &::-webkit-scrollbar-button:single-button:horizontal:decrement:active,\n  &::-webkit-scrollbar-button:single-button:horizontal:increment:active {\n    background-blend-mode: `,\n        `;\n  }\n`\n    ], colorScheme[scheme].thumb, colorScheme[scheme].track, size, size, colorScheme[scheme].track, colorScheme[scheme].thumb, colorScheme[scheme].thumb, colorScheme[scheme].thumbHover, colorScheme[scheme].active, colorScheme[scheme].track, colorScheme[scheme].track, size ? `${size}px` : \"initial\", colorScheme[scheme].buttonHover, colorScheme[scheme].active, verticalX === 0 ? \"center\" : `${verticalX}px`, verticalY === 0 ? \"center\" : `${verticalY}px`, styles_ArrowIcons__WEBPACK_IMPORTED_MODULE_0__.UP, styles_ArrowIcons__WEBPACK_IMPORTED_MODULE_0__.DOWN, styles_ArrowIcons__WEBPACK_IMPORTED_MODULE_0__.LEFT, styles_ArrowIcons__WEBPACK_IMPORTED_MODULE_0__.RIGHT, colorScheme[scheme].blendMode);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScrollBars);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3N0eWxlcy9jb21tb24vU2Nyb2xsQmFycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNEO0FBQ0k7QUFDQTtBQWExRCxNQUFNTSxjQUFpRDtJQUNyREMsTUFBTTtRQUNKQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLFlBQVk7UUFDWkMsT0FBTztJQUNUO0lBQ0FDLE9BQU87UUFDTE4sUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxZQUFZO1FBQ1pDLE9BQU87SUFDVDtBQUNGO0FBRUEsTUFBTUUsYUFBYSxDQUNqQkMsT0FBT1gsb0VBQXVCLEVBQzlCWSxZQUFZLENBQUMsRUFDYkMsWUFBWSxDQUFDLEVBQ2JDLFNBQXVCLE1BQU0sR0FDVG5CLHNEQUFHQTtRQUFDOzs7OztxQkFLTDtRQUE0QixFQUFDO1FBQTRCOzs7O1lBSWxFO1FBQU87V0FDUjtRQUFPOzs7OztzQkFLSTtRQUE0Qjs7Ozs7c0JBSzVCO1FBQTRCOzs7OztzQkFLNUI7UUFBNEI7Ozs7Ozs7Ozs7O3NCQVc1QjtRQUFpQzs7OztzQkFJakM7UUFBNkI7Ozs7O3NCQUs3QjtRQUE0Qjs7OztzQkFJNUI7UUFBNEI7O1lBRXRDO1FBQWlDOzs7d0JBR3JCO1FBQWtDOzs7O3dCQUlsQztRQUE2Qjs7Ozs7OzJCQU0xQjtRQUFnRDsyQkFDaEQ7UUFBZ0Q7Ozs7Ozs7OzBCQVFqRDtRQUFLOzs7OzBCQUlMO1FBQU87Ozs7Ozs7Ozs7Ozs7MEJBYVA7UUFBTzs7OzswQkFJUDtRQUFROzs7Ozs7OzJCQU9QO1FBQWdDOztBQUUzRDtPQWxHdUJNLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDUixLQUFLLEVBQUlMLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDTixLQUFLLEVBSS9ERyxNQUNEQSxNQUtXVixXQUFXLENBQUNhLE9BQU8sQ0FBQ04sS0FBSyxFQUt6QlAsV0FBVyxDQUFDYSxPQUFPLENBQUNSLEtBQUssRUFLekJMLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDUixLQUFLLEVBV3pCTCxXQUFXLENBQUNhLE9BQU8sQ0FBQ1AsVUFBVSxFQUk5Qk4sV0FBVyxDQUFDYSxPQUFPLENBQUNYLE1BQU0sRUFLMUJGLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDTixLQUFLLEVBSXpCUCxXQUFXLENBQUNhLE9BQU8sQ0FBQ04sS0FBSyxFQUVuQ0csT0FBTyxHQUFHQSxLQUFLLEVBQUUsQ0FBQyxHQUFHLFdBR1RWLFdBQVcsQ0FBQ2EsT0FBTyxDQUFDVCxXQUFXLEVBSS9CSixXQUFXLENBQUNhLE9BQU8sQ0FBQ1gsTUFBTSxFQU12QlMsY0FBYyxJQUFJLFdBQVcsR0FBR0EsVUFBVSxFQUFFLENBQUMsRUFDN0NDLGNBQWMsSUFBSSxXQUFXLEdBQUdBLFVBQVUsRUFBRSxDQUFDLEVBUTlDZCxpREFBRUEsRUFJRkgsbURBQUlBLEVBYUpDLG1EQUFJQSxFQUlKQyxvREFBS0EsRUFPSkcsV0FBVyxDQUFDYSxPQUFPLENBQUNWLFNBQVM7QUFJMUQsaUVBQWVNLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRG9jdW1lbnRzXFxTaXRlc1xcU2l0ZXNcXGVtIGRlc2Vudm9sdmltZW50b1xcUG9ydGZvbGlvMlxcc3R5bGVzXFxjb21tb25cXFNjcm9sbEJhcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBSdWxlU2V0LCBjc3MgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuaW1wb3J0IHsgRE9XTiwgTEVGVCwgUklHSFQsIFVQIH0gZnJvbSBcInN0eWxlcy9BcnJvd0ljb25zXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfU0NST0xMQkFSX1dJRFRIIH0gZnJvbSBcInV0aWxzL2NvbnN0YW50c1wiO1xyXG5cclxudHlwZSBDb2xvclNjaGVtZXMgPSBcImRhcmtcIiB8IFwibGlnaHRcIjtcclxuXHJcbnR5cGUgQ29sb3JTY2hlbWUgPSB7XHJcbiAgYWN0aXZlOiBzdHJpbmc7XHJcbiAgYmxlbmRNb2RlOiBzdHJpbmc7XHJcbiAgYnV0dG9uSG92ZXI6IHN0cmluZztcclxuICB0aHVtYjogc3RyaW5nO1xyXG4gIHRodW1iSG92ZXI6IHN0cmluZztcclxuICB0cmFjazogc3RyaW5nO1xyXG59O1xyXG5cclxuY29uc3QgY29sb3JTY2hlbWU6IFJlY29yZDxDb2xvclNjaGVtZXMsIENvbG9yU2NoZW1lPiA9IHtcclxuICBkYXJrOiB7XHJcbiAgICBhY3RpdmU6IFwicmdiKDE2NiwgMTY2LCAxNjYpXCIsXHJcbiAgICBibGVuZE1vZGU6IFwiY29sb3ItYnVyblwiLFxyXG4gICAgYnV0dG9uSG92ZXI6IFwicmdiKDU1LCA1NSwgNTUpXCIsXHJcbiAgICB0aHVtYjogXCJyZ2IoNzcsIDc3LCA3NylcIixcclxuICAgIHRodW1iSG92ZXI6IFwicmdiKDEyMiwgMTIyLCAxMjIpXCIsXHJcbiAgICB0cmFjazogXCJyZ2IoMjMsIDIzLCAyMylcIixcclxuICB9LFxyXG4gIGxpZ2h0OiB7XHJcbiAgICBhY3RpdmU6IFwicmdiKDk2LCA5NiwgOTYpXCIsXHJcbiAgICBibGVuZE1vZGU6IFwiY29sb3ItZG9kZ2VcIixcclxuICAgIGJ1dHRvbkhvdmVyOiBcInJnYigyMTgsIDIxOCwgMjE4KVwiLFxyXG4gICAgdGh1bWI6IFwicmdiKDIwNSwgMjA1LCAyMDUpXCIsXHJcbiAgICB0aHVtYkhvdmVyOiBcInJnYigxNjYsIDE2NiwgMTY2KVwiLFxyXG4gICAgdHJhY2s6IFwicmdiKDI0MCwgMjQwLCAyNDApXCIsXHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IFNjcm9sbEJhcnMgPSAoXHJcbiAgc2l6ZSA9IERFRkFVTFRfU0NST0xMQkFSX1dJRFRILFxyXG4gIHZlcnRpY2FsWCA9IDAsXHJcbiAgdmVydGljYWxZID0gMCxcclxuICBzY2hlbWU6IENvbG9yU2NoZW1lcyA9IFwiZGFya1wiXHJcbik6IFJ1bGVTZXQ8b2JqZWN0PiA9PiBjc3NgXHJcbiAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgc2Nyb2xsYmFyLWd1dHRlcjogc3RhYmxlO1xyXG5cclxuICBAc3VwcG9ydHMgbm90IHNlbGVjdG9yKDo6LXdlYmtpdC1zY3JvbGxiYXIpIHtcclxuICAgIHNjcm9sbGJhci1jb2xvcjogJHtjb2xvclNjaGVtZVtzY2hlbWVdLnRodW1ifSAke2NvbG9yU2NoZW1lW3NjaGVtZV0udHJhY2t9O1xyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG4gICAgaGVpZ2h0OiAke3NpemV9cHg7XHJcbiAgICB3aWR0aDogJHtzaXplfXB4O1xyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyLFxyXG4gICY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JTY2hlbWVbc2NoZW1lXS50cmFja307XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XHJcbiAgICBiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvclNjaGVtZVtzY2hlbWVdLnRodW1ifTtcclxuICB9XHJcblxyXG4gICY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOnZlcnRpY2FsIHtcclxuICAgIGJhY2tncm91bmQtY2xpcDogcGFkZGluZy1ib3g7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yU2NoZW1lW3NjaGVtZV0udGh1bWJ9O1xyXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWI6aG9yaXpvbnRhbCB7XHJcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yU2NoZW1lW3NjaGVtZV0udGh1bWJIb3Zlcn07XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjphY3RpdmUge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvclNjaGVtZVtzY2hlbWVdLmFjdGl2ZX07XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246c2luZ2xlLWJ1dHRvbiB7XHJcbiAgICBiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvclNjaGVtZVtzY2hlbWVdLnRyYWNrfTtcclxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciA0cHg7XHJcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xyXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMHB4O1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgJHtjb2xvclNjaGVtZVtzY2hlbWVdLnRyYWNrfTtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgaGVpZ2h0OiAke3NpemUgPyBgJHtzaXplfXB4YCA6IFwiaW5pdGlhbFwifTtcclxuXHJcbiAgICAmOmhvdmVyIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvclNjaGVtZVtzY2hlbWVdLmJ1dHRvbkhvdmVyfTtcclxuICAgIH1cclxuXHJcbiAgICAmOmFjdGl2ZSB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JTY2hlbWVbc2NoZW1lXS5hY3RpdmV9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnNpbmdsZS1idXR0b246dmVydGljYWw6ZGVjcmVtZW50LFxyXG4gICY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpzaW5nbGUtYnV0dG9uOnZlcnRpY2FsOmluY3JlbWVudCB7XHJcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6ICR7dmVydGljYWxYID09PSAwID8gXCJjZW50ZXJcIiA6IGAke3ZlcnRpY2FsWH1weGB9O1xyXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbi15OiAke3ZlcnRpY2FsWSA9PT0gMCA/IFwiY2VudGVyXCIgOiBgJHt2ZXJ0aWNhbFl9cHhgfTtcclxuICAgIGJhY2tncm91bmQtc2l6ZTogMTZweDtcclxuICAgIGJvcmRlci1ib3R0b206IDA7XHJcbiAgICBib3JkZXItdG9wOiAwO1xyXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiBwaXhlbGF0ZWQ7XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246c2luZ2xlLWJ1dHRvbjp2ZXJ0aWNhbDpkZWNyZW1lbnQge1xyXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7VVB9KTtcclxuICB9XHJcblxyXG4gICY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpzaW5nbGUtYnV0dG9uOnZlcnRpY2FsOmluY3JlbWVudCB7XHJcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHtET1dOfSk7XHJcbiAgfVxyXG5cclxuICAmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246c2luZ2xlLWJ1dHRvbjpob3Jpem9udGFsOmRlY3JlbWVudCxcclxuICAmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246c2luZ2xlLWJ1dHRvbjpob3Jpem9udGFsOmluY3JlbWVudCB7XHJcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XHJcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDE2cHg7XHJcbiAgICBib3JkZXItbGVmdDogMDtcclxuICAgIGJvcmRlci1yaWdodDogMDtcclxuICAgIGltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkO1xyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnNpbmdsZS1idXR0b246aG9yaXpvbnRhbDpkZWNyZW1lbnQge1xyXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7TEVGVH0pO1xyXG4gIH1cclxuXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnNpbmdsZS1idXR0b246aG9yaXpvbnRhbDppbmNyZW1lbnQge1xyXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7UklHSFR9KTtcclxuICB9XHJcblxyXG4gICY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpzaW5nbGUtYnV0dG9uOnZlcnRpY2FsOmRlY3JlbWVudDphY3RpdmUsXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnNpbmdsZS1idXR0b246dmVydGljYWw6aW5jcmVtZW50OmFjdGl2ZSxcclxuICAmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246c2luZ2xlLWJ1dHRvbjpob3Jpem9udGFsOmRlY3JlbWVudDphY3RpdmUsXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnNpbmdsZS1idXR0b246aG9yaXpvbnRhbDppbmNyZW1lbnQ6YWN0aXZlIHtcclxuICAgIGJhY2tncm91bmQtYmxlbmQtbW9kZTogJHtjb2xvclNjaGVtZVtzY2hlbWVdLmJsZW5kTW9kZX07XHJcbiAgfVxyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsQmFycztcclxuIl0sIm5hbWVzIjpbImNzcyIsIkRPV04iLCJMRUZUIiwiUklHSFQiLCJVUCIsIkRFRkFVTFRfU0NST0xMQkFSX1dJRFRIIiwiY29sb3JTY2hlbWUiLCJkYXJrIiwiYWN0aXZlIiwiYmxlbmRNb2RlIiwiYnV0dG9uSG92ZXIiLCJ0aHVtYiIsInRodW1iSG92ZXIiLCJ0cmFjayIsImxpZ2h0IiwiU2Nyb2xsQmFycyIsInNpemUiLCJ2ZXJ0aWNhbFgiLCJ2ZXJ0aWNhbFkiLCJzY2hlbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./styles/common/ScrollBars.ts\n"));

/***/ })

}]);