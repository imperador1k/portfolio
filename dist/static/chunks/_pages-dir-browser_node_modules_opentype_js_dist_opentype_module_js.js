/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_opentype_js_dist_opentype_module_js"],{

/***/ "(pages-dir-browser)/./node_modules/opentype.js/dist/opentype.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/opentype.js/dist/opentype.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   Glyph: () => (/* binding */ Glyph),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   _parse: () => (/* binding */ parse),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadSync: () => (/* binding */ loadSync),\n/* harmony export */   parse: () => (/* binding */ parseBuffer)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n\nvar TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    { return base; }\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    { return TINF_DATA_ERROR; }\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      { throw new Error('Data error'); }\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      { return d.dest.slice(0, d.destLen); }\n    else\n      { return d.dest.subarray(0, d.destLen); }\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nvar tinyInflate = tinf_uncompress;\n\n// The Bounding Box object\n\nfunction derive(v0, v1, v2, v3, t) {\n    return Math.pow(1 - t, 3) * v0 +\n        3 * Math.pow(1 - t, 2) * t * v1 +\n        3 * (1 - t) * Math.pow(t, 2) * v2 +\n        Math.pow(t, 3) * v3;\n}\n/**\n * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n * It is used to calculate the bounding box of a glyph or text path.\n *\n * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n *\n * @exports opentype.BoundingBox\n * @class\n * @constructor\n */\nfunction BoundingBox() {\n    this.x1 = Number.NaN;\n    this.y1 = Number.NaN;\n    this.x2 = Number.NaN;\n    this.y2 = Number.NaN;\n}\n\n/**\n * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n */\nBoundingBox.prototype.isEmpty = function() {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\n\n/**\n * Add the point to the bounding box.\n * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n * @param {number} x - The X coordinate of the point.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addPoint = function(x, y) {\n    if (typeof x === 'number') {\n        if (isNaN(this.x1) || isNaN(this.x2)) {\n            this.x1 = x;\n            this.x2 = x;\n        }\n        if (x < this.x1) {\n            this.x1 = x;\n        }\n        if (x > this.x2) {\n            this.x2 = x;\n        }\n    }\n    if (typeof y === 'number') {\n        if (isNaN(this.y1) || isNaN(this.y2)) {\n            this.y1 = y;\n            this.y2 = y;\n        }\n        if (y < this.y1) {\n            this.y1 = y;\n        }\n        if (y > this.y2) {\n            this.y2 = y;\n        }\n    }\n};\n\n/**\n * Add a X coordinate to the bounding box.\n * This extends the bounding box to include the X coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} x - The X coordinate of the point.\n */\nBoundingBox.prototype.addX = function(x) {\n    this.addPoint(x, null);\n};\n\n/**\n * Add a Y coordinate to the bounding box.\n * This extends the bounding box to include the Y coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addY = function(y) {\n    this.addPoint(null, y);\n};\n\n/**\n * Add a Bézier curve to the bounding box.\n * This extends the bounding box to include the entire Bézier.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the first control point.\n * @param {number} y1 - The Y coordinate of the first control point.\n * @param {number} x2 - The X coordinate of the second control point.\n * @param {number} y2 - The Y coordinate of the second control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    var p0 = [x0, y0];\n    var p1 = [x1, y1];\n    var p2 = [x2, y2];\n    var p3 = [x, y];\n\n    this.addPoint(x0, y0);\n    this.addPoint(x, y);\n\n    for (var i = 0; i <= 1; i++) {\n        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n        var c = 3 * p1[i] - 3 * p0[i];\n\n        if (a === 0) {\n            if (b === 0) { continue; }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n            }\n            continue;\n        }\n\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) { continue; }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n        }\n    }\n};\n\n/**\n * Add a quadratic curve to the bounding box.\n * This extends the bounding box to include the entire quadratic curve.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the control point.\n * @param {number} y1 - The Y coordinate of the control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n    var cp1x = x0 + 2 / 3 * (x1 - x0);\n    var cp1y = y0 + 2 / 3 * (y1 - y0);\n    var cp2x = cp1x + 1 / 3 * (x - x0);\n    var cp2y = cp1y + 1 / 3 * (y - y0);\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n};\n\n// Geometric objects\n\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    } else if (pathOrCommands instanceof BoundingBox) {\n        var box = pathOrCommands;\n        this.moveTo(box.x1, box.y1);\n        this.lineTo(box.x2, box.y1);\n        this.lineTo(box.x2, box.y2);\n        this.lineTo(box.x1, box.y2);\n        this.close();\n        return;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\nPath.prototype.getBoundingBox = function() {\n    var box = new BoundingBox();\n\n    var startX = 0;\n    var startY = 0;\n    var prevX = 0;\n    var prevY = 0;\n    for (var i = 0; i < this.commands.length; i++) {\n        var cmd = this.commands[i];\n        switch (cmd.type) {\n            case 'M':\n                box.addPoint(cmd.x, cmd.y);\n                startX = prevX = cmd.x;\n                startY = prevY = cmd.y;\n                break;\n            case 'L':\n                box.addPoint(cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Q':\n                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'C':\n                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Z':\n                prevX = startX;\n                prevY = startY;\n                break;\n            default:\n                throw new Error('Unexpected path command ' + cmd.type);\n        }\n    }\n    if (box.isEmpty()) {\n        box.addPoint(0, 0);\n    }\n    return box;\n};\n\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toSVG = function(decimalPlaces) {\n    var svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill && this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\nPath.prototype.toDOMElement = function(decimalPlaces) {\n    var temporaryPath = this.toPathData(decimalPlaces);\n    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    newPath.setAttribute('d', temporaryPath);\n\n    return newPath;\n};\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// Data types used in the OpenType font file.\n\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nvar encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nvar sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        v = '';\n        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');\n    }\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        return 0;\n    }\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    var value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    var nibbles = '';\n    for (var i = 0, ii = value.length; i < ii; i += 1) {\n        var c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    var out = [30];\n    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        var codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nvar macEncodingCacheKeys;\nvar getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (var e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    var cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        var cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    var decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    var encodingTable = {};\n    for (var i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    var table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    var b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (var i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (var i = offset; i < pos; ++i) {\n        var val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    var pos = 0;\n    var result = [];\n    while (pos < deltas.length) {\n        var value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    var offset = 1; // First offset is always 1.\n    var offsets = [offset];\n    var data = [];\n    for (var i = 0; i < l.length; i += 1) {\n        var v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    var encodedOffsets = [];\n    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n        var encodedOffset = offsetEncoder(offsets[i$1]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    var d = [];\n    var keys = Object.keys(m);\n    var length = keys.length;\n\n    for (var i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        var k = parseInt(keys[i], 0);\n        var v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    var d = [];\n    if (Array.isArray(type)) {\n        for (var i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        var cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    var d = [];\n    var length = ops.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    var encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    var sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    var d = [];\n    var length = table.fields.length;\n    var subtables = [];\n    var subtableOffsets = [];\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        var bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n        var o = subtableOffsets[i$1];\n        var offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i$1]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    var numBytes = 0;\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\n// Table metadata\n\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\nfunction Table(tableName, fields, options) {\n    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n        for (var i = 0; i < fields.length; i += 1) {\n            var field = fields[i];\n            this[field.name] = field.value;\n        }\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        var optionKeys = Object.keys(options);\n        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n            var k = optionKeys[i$1];\n            var v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\n/**\n * Get the size of the table.\n * @return {number}\n */\nTable.prototype.sizeOf = function() {\n    return sizeOf.TABLE(this);\n};\n\n/**\n * @private\n */\nfunction ushortList(itemName, list, count) {\n    if (count === undefined) {\n        count = list.length;\n    }\n    var fields = new Array(list.length + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < list.length; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction tableList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = new Array(count + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction recordList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = [];\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields = fields.concat(itemCallback(records[i], i));\n    }\n    return fields;\n}\n\n// Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n            .concat(ushortList('glyph', coverageTable.glyphs))\n        );\n    } else if (coverageTable.format === 2) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 2}]\n            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {\n                return [\n                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},\n                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},\n                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];\n            }))\n        );\n    } else {\n        check.assert(false, 'Coverage format must be 1 or 2.');\n    }\n}\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n    Table.call(this, 'scriptListTable',\n        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n            var script = scriptRecord.script;\n            var defaultLangSys = script.defaultLangSys;\n            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n            return [\n                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n                        var langSys = langSysRecord.langSys;\n                        return [\n                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n                        ];\n                    })))}\n            ];\n        })\n    );\n}\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction FeatureList(featureListTable) {\n    Table.call(this, 'featureListTable',\n        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n            var feature = featureRecord.feature;\n            return [\n                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n            ];\n        })\n    );\n}\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\nfunction LookupList(lookupListTable, subtableMakers) {\n    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n        var subtableCallback = subtableMakers[lookupTable.lookupType];\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n        return new Table('lookupTable', [\n            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n    }));\n}\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList;\n\n// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\nvar table = {\n    Table: Table,\n    Record: Table,\n    Coverage: Coverage,\n    ScriptList: ScriptList,\n    FeatureList: FeatureList,\n    LookupList: LookupList,\n    ushortList: ushortList,\n    tableList: tableList,\n    recordList: recordList,\n};\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0,\n        glyphIndex: glyphIndex\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\n// Make cmap table, format 4 by default, 12 if needed only\nfunction makeCmapTable(glyphs) {\n    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n    var isPlan0Only = true;\n    var i;\n\n    // Check if we need to add cmap format 12 or if format 4 only is fine\n    for (i = glyphs.length - 1; i > 0; i -= 1) {\n        var g = glyphs.get(i);\n        if (g.unicode > 65535) {\n            console.log('Adding CMAP format 12 (needed!)');\n            isPlan0Only = false;\n            break;\n        }\n    }\n\n    var cmapTable = [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n        // CMAP 4 header\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n    ];\n\n    if (!isPlan0Only)\n        { cmapTable = cmapTable.concat([\n            // CMAP 12 header\n            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n        ]); }\n\n    cmapTable = cmapTable.concat([\n        // CMAP 4 Subtable\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'cmap4Length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    var t = new table.Table('cmap', cmapTable);\n\n    t.segments = [];\n    for (i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function (a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    var segCount = t.segments.length;\n    var segCountToRemove = 0;\n\n    // CMAP 4\n    // Set up parallel segment arrays.\n    var endCounts = [];\n    var startCounts = [];\n    var idDeltas = [];\n    var idRangeOffsets = [];\n    var glyphIds = [];\n\n    // CMAP 12\n    var cmap12Groups = [];\n\n    // Reminder this loop is not following the specification at 100%\n    // The specification -> find suites of characters and make a group\n    // Here we're doing one group for each letter\n    // Doing as the spec can save 8 times (or more) space\n    for (i = 0; i < segCount; i += 1) {\n        var segment = t.segments[i];\n\n        // CMAP 4\n        if (segment.end <= 65535 && segment.start <= 65535) {\n            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n            if (segment.glyphId !== undefined) {\n                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n            }\n        } else {\n            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n            segCountToRemove += 1;\n        }\n\n        // CMAP 12\n        // Skip Terminator Segment\n        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n        }\n    }\n\n    // CMAP 4 Subtable\n    t.segCountX2 = (segCount - segCountToRemove) * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.cmap4Length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    if (!isPlan0Only) {\n        // CMAP 12 Subtable\n        var cmap12Length = 16 + // Subtable header\n            cmap12Groups.length * 4;\n\n        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n        t.fields = t.fields.concat([\n            {name: 'cmap12Format', type: 'USHORT', value: 12},\n            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n            {name: 'cmap12Language', type: 'ULONG', value: 0},\n            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n        ]);\n\n        t.fields = t.fields.concat(cmap12Groups);\n    }\n\n    return t;\n}\n\nvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nvar cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nvar cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nvar standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\n/**\n * @exports opentype.GlyphNames\n * @class\n * @constructor\n * @param {Object} post\n */\nfunction GlyphNames(post) {\n    switch (post.version) {\n        case 1:\n            this.names = standardNames.slice();\n            break;\n        case 2:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < standardNames.length) {\n                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n                } else {\n                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n                }\n            }\n\n            break;\n        case 2.5:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n            }\n\n            break;\n        case 3:\n            this.names = [];\n            break;\n        default:\n            this.names = [];\n            break;\n    }\n}\n\n/**\n * Gets the index of a glyph by name.\n * @param  {string} name - The glyph name\n * @return {number} The index\n */\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\n/**\n * @param  {number} gid\n * @return {string}\n */\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n        glyph = font.glyphs.get(i$1);\n        if (font.cffEncoding) {\n            if (font.isCIDFont) {\n                glyph.name = 'gid' + i$1;\n            } else {\n                glyph.name = font.cffEncoding.charset[i$1];\n            }\n        } else if (font.glyphNames.names) {\n            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n        }\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)]\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Drawing utility functions.\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\nvar draw = { line: line };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\nGlyph.prototype.getBoundingBox = function() {\n    return this.path.getBoundingBox();\n};\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = { }; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\nGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n        ctx.beginPath();\n        for (var j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n    var blueCircles = [];\n    var redCircles = [];\n    var path = this.path;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    var scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0;\n    var yMin = this.yMin || 0;\n    var xMax = this.xMax || 0;\n    var yMax = this.yMax || 0;\n    var advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function(index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        if (this.font.cffEncoding) {\n            if (this.font.isCIDFont) {\n                glyph.name = 'gid' + index;\n            } else {\n                glyph.name = this.font.cffEncoding.charset[index];\n            }\n        } else if (this.font.glyphNames.names) {\n            glyph.name = this.font.glyphNames.glyphIndexToName(index);\n        }\n\n        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return {offsets: offsets, startOffset: start, endOffset: endOffset};\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n    }\n\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nvar PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function(i) {\n            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        }\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    var sid;\n\n    // Is the string in the CFF standard strings?\n    var i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    var t = new table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (var i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    var m = {};\n    for (var i = 0; i < meta.length; i += 1) {\n        var entry = meta[i];\n        var value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    var t = new table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    var t = new table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    var t = new table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (var i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    var t = new table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (var i = 0; i < glyphNames.length; i += 1) {\n        var glyphName = glyphNames[i];\n        var glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    var ops = [];\n    var path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var dx = (void 0);\n        var dy = (void 0);\n        var cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: Math.round(_13 * x + _23 * cmd.x1),\n                y1: Math.round(_13 * y + _23 * cmd.y1),\n                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            var dx1 = Math.round(cmd.x1 - x);\n            var dy1 = Math.round(cmd.y1 - y);\n            var dx2 = Math.round(cmd.x2 - cmd.x1);\n            var dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    var t = new table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    var t = new table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    var fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    var privateAttrs = {};\n\n    var glyphNames = [];\n    var glyph;\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    var strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    var topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    var startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n    var createdTimestamp = timestamp;\n\n    if (options.createdTimestamp) {\n        createdTimestamp = options.createdTimestamp + 2082844800;\n    }\n\n    return new table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\nvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else\n        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nfunction makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', []);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var advanceWidth = glyph.advanceWidth || 0;\n        var leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\nvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction makeLtagTable(tags) {\n    var result = new table.Table('ltag', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'numTags', type: 'ULONG', value: tags.length}\n    ]);\n\n    var stringPool = '';\n    var stringPoolOffset = 12 + tags.length * 4;\n    for (var i = 0; i < tags.length; ++i) {\n        var pos = stringPool.indexOf(tags[i]);\n        if (pos < 0) {\n            pos = stringPool.length;\n            stringPool += tags[i];\n        }\n\n        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n    return result;\n}\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\nvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n// The `name` naming table.\n\n// NameIDs for the name table.\nvar nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'license',                // 13\n    'licenseURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\nvar macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn'\n};\n\n// MacOS language ID → MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageToScript = {\n    0: 0,  // langEnglish → smRoman\n    1: 0,  // langFrench → smRoman\n    2: 0,  // langGerman → smRoman\n    3: 0,  // langItalian → smRoman\n    4: 0,  // langDutch → smRoman\n    5: 0,  // langSwedish → smRoman\n    6: 0,  // langSpanish → smRoman\n    7: 0,  // langDanish → smRoman\n    8: 0,  // langPortuguese → smRoman\n    9: 0,  // langNorwegian → smRoman\n    10: 5,  // langHebrew → smHebrew\n    11: 1,  // langJapanese → smJapanese\n    12: 4,  // langArabic → smArabic\n    13: 0,  // langFinnish → smRoman\n    14: 6,  // langGreek → smGreek\n    15: 0,  // langIcelandic → smRoman (modified)\n    16: 0,  // langMaltese → smRoman\n    17: 0,  // langTurkish → smRoman (modified)\n    18: 0,  // langCroatian → smRoman (modified)\n    19: 2,  // langTradChinese → smTradChinese\n    20: 4,  // langUrdu → smArabic\n    21: 9,  // langHindi → smDevanagari\n    22: 21,  // langThai → smThai\n    23: 3,  // langKorean → smKorean\n    24: 29,  // langLithuanian → smCentralEuroRoman\n    25: 29,  // langPolish → smCentralEuroRoman\n    26: 29,  // langHungarian → smCentralEuroRoman\n    27: 29,  // langEstonian → smCentralEuroRoman\n    28: 29,  // langLatvian → smCentralEuroRoman\n    29: 0,  // langSami → smRoman\n    30: 0,  // langFaroese → smRoman (modified)\n    31: 4,  // langFarsi → smArabic (modified)\n    32: 7,  // langRussian → smCyrillic\n    33: 25,  // langSimpChinese → smSimpChinese\n    34: 0,  // langFlemish → smRoman\n    35: 0,  // langIrishGaelic → smRoman (modified)\n    36: 0,  // langAlbanian → smRoman\n    37: 0,  // langRomanian → smRoman (modified)\n    38: 29,  // langCzech → smCentralEuroRoman\n    39: 29,  // langSlovak → smCentralEuroRoman\n    40: 0,  // langSlovenian → smRoman (modified)\n    41: 5,  // langYiddish → smHebrew\n    42: 7,  // langSerbian → smCyrillic\n    43: 7,  // langMacedonian → smCyrillic\n    44: 7,  // langBulgarian → smCyrillic\n    45: 7,  // langUkrainian → smCyrillic (modified)\n    46: 7,  // langByelorussian → smCyrillic\n    47: 7,  // langUzbek → smCyrillic\n    48: 7,  // langKazakh → smCyrillic\n    49: 7,  // langAzerbaijani → smCyrillic\n    50: 4,  // langAzerbaijanAr → smArabic\n    51: 24,  // langArmenian → smArmenian\n    52: 23,  // langGeorgian → smGeorgian\n    53: 7,  // langMoldavian → smCyrillic\n    54: 7,  // langKirghiz → smCyrillic\n    55: 7,  // langTajiki → smCyrillic\n    56: 7,  // langTurkmen → smCyrillic\n    57: 27,  // langMongolian → smMongolian\n    58: 7,  // langMongolianCyr → smCyrillic\n    59: 4,  // langPashto → smArabic\n    60: 4,  // langKurdish → smArabic\n    61: 4,  // langKashmiri → smArabic\n    62: 4,  // langSindhi → smArabic\n    63: 26,  // langTibetan → smTibetan\n    64: 9,  // langNepali → smDevanagari\n    65: 9,  // langSanskrit → smDevanagari\n    66: 9,  // langMarathi → smDevanagari\n    67: 13,  // langBengali → smBengali\n    68: 13,  // langAssamese → smBengali\n    69: 11,  // langGujarati → smGujarati\n    70: 10,  // langPunjabi → smGurmukhi\n    71: 12,  // langOriya → smOriya\n    72: 17,  // langMalayalam → smMalayalam\n    73: 16,  // langKannada → smKannada\n    74: 14,  // langTamil → smTamil\n    75: 15,  // langTelugu → smTelugu\n    76: 18,  // langSinhalese → smSinhalese\n    77: 19,  // langBurmese → smBurmese\n    78: 20,  // langKhmer → smKhmer\n    79: 22,  // langLao → smLao\n    80: 30,  // langVietnamese → smVietnamese\n    81: 0,  // langIndonesian → smRoman\n    82: 0,  // langTagalog → smRoman\n    83: 0,  // langMalayRoman → smRoman\n    84: 4,  // langMalayArabic → smArabic\n    85: 28,  // langAmharic → smEthiopic\n    86: 28,  // langTigrinya → smEthiopic\n    87: 28,  // langOromo → smEthiopic\n    88: 0,  // langSomali → smRoman\n    89: 0,  // langSwahili → smRoman\n    90: 0,  // langKinyarwanda → smRoman\n    91: 0,  // langRundi → smRoman\n    92: 0,  // langNyanja → smRoman\n    93: 0,  // langMalagasy → smRoman\n    94: 0,  // langEsperanto → smRoman\n    128: 0,  // langWelsh → smRoman (modified)\n    129: 0,  // langBasque → smRoman\n    130: 0,  // langCatalan → smRoman\n    131: 0,  // langLatin → smRoman\n    132: 0,  // langQuechua → smRoman\n    133: 0,  // langGuarani → smRoman\n    134: 0,  // langAymara → smRoman\n    135: 7,  // langTatar → smCyrillic\n    136: 4,  // langUighur → smArabic\n    137: 26,  // langDzongkha → smTibetan\n    138: 0,  // langJavaneseRom → smRoman\n    139: 0,  // langSundaneseRom → smRoman\n    140: 0,  // langGalician → smRoman\n    141: 0,  // langAfrikaans → smRoman\n    142: 0,  // langBreton → smRoman (modified)\n    143: 28,  // langInuktitut → smEthiopic (modified)\n    144: 0,  // langScottishGaelic → smRoman (modified)\n    145: 0,  // langManxGaelic → smRoman (modified)\n    146: 0,  // langIrishGaelicScript → smRoman (modified)\n    147: 0,  // langTongan → smRoman\n    148: 6,  // langGreekAncient → smRoman\n    149: 0,  // langGreenlandic → smRoman\n    150: 0,  // langAzerbaijanRoman → smRoman\n    151: 0   // langNynorsk → smRoman\n};\n\n// While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\nvar windowsLanguages = {\n    0x0436: 'af',\n    0x041C: 'sq',\n    0x0484: 'gsw',\n    0x045E: 'am',\n    0x1401: 'ar-DZ',\n    0x3C01: 'ar-BH',\n    0x0C01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2C01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1C01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042B: 'hy',\n    0x044D: 'as',\n    0x082C: 'az-Cyrl',\n    0x042C: 'az',\n    0x046D: 'ba',\n    0x042D: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201A: 'bs-Cyrl',\n    0x141A: 'bs',\n    0x047E: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0C04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041A: 'hr',\n    0x101A: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048C: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0C09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1C09: 'en-ZA',\n    0x2C09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040B: 'fi',\n    0x080C: 'fr-BE',\n    0x0C0C: 'fr-CA',\n    0x040C: 'fr',\n    0x140C: 'fr-LU',\n    0x180C: 'fr-MC',\n    0x100C: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0C07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046F: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040D: 'he',\n    0x0439: 'hi',\n    0x040E: 'hu',\n    0x040F: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045D: 'iu',\n    0x085D: 'iu-Latn',\n    0x083C: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044B: 'kn',\n    0x043F: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082E: 'dsb',\n    0x046E: 'lb',\n    0x042F: 'mk',\n    0x083E: 'ms-BN',\n    0x043E: 'ms',\n    0x044C: 'ml',\n    0x043A: 'mt',\n    0x0481: 'mi',\n    0x047A: 'arn',\n    0x044E: 'mr',\n    0x047C: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046B: 'qu-BO',\n    0x086B: 'qu-EC',\n    0x0C6B: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243B: 'smn',\n    0x103B: 'smj-NO',\n    0x143B: 'smj',\n    0x0C3B: 'se-FI',\n    0x043B: 'se',\n    0x083B: 'se-SE',\n    0x203B: 'sms',\n    0x183B: 'sma-NO',\n    0x1C3B: 'sms',\n    0x044F: 'sa',\n    0x1C1A: 'sr-Cyrl-BA',\n    0x0C1A: 'sr',\n    0x181A: 'sr-Latn-BA',\n    0x081A: 'sr-Latn',\n    0x046C: 'nso',\n    0x0432: 'tn',\n    0x045B: 'si',\n    0x041B: 'sk',\n    0x0424: 'sl',\n    0x2C0A: 'es-AR',\n    0x400A: 'es-BO',\n    0x340A: 'es-CL',\n    0x240A: 'es-CO',\n    0x140A: 'es-CR',\n    0x1C0A: 'es-DO',\n    0x300A: 'es-EC',\n    0x440A: 'es-SV',\n    0x100A: 'es-GT',\n    0x480A: 'es-HN',\n    0x080A: 'es-MX',\n    0x4C0A: 'es-NI',\n    0x180A: 'es-PA',\n    0x3C0A: 'es-PY',\n    0x280A: 'es-PE',\n    0x500A: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // “Spanish with modern sorting” and “Spanish with traditional\n    // sorting”. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give “es” in both cases.\n    0x0C0A: 'es',\n    0x040A: 'es',\n\n    0x540A: 'es-US',\n    0x380A: 'es-UY',\n    0x200A: 'es-VE',\n    0x081D: 'sv-FI',\n    0x041D: 'sv',\n    0x045A: 'syr',\n    0x0428: 'tg',\n    0x085F: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044A: 'te',\n    0x041E: 'th',\n    0x0451: 'bo',\n    0x041F: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042E: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042A: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046A: 'yo'\n};\n\n// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\nfunction getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n        case 0:  // Unicode\n            if (languageID === 0xFFFF) {\n                return 'und';\n            } else if (ltag) {\n                return ltag[languageID];\n            }\n\n            break;\n\n        case 1:  // Macintosh\n            return macLanguages[languageID];\n\n        case 3:  // Windows\n            return windowsLanguages[languageID];\n    }\n\n    return undefined;\n}\n\nvar utf16 = 'utf-16';\n\n// MacOS script ID → encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\nvar macScriptEncodings = {\n    0: 'macintosh',           // smRoman\n    1: 'x-mac-japanese',      // smJapanese\n    2: 'x-mac-chinesetrad',   // smTradChinese\n    3: 'x-mac-korean',        // smKorean\n    6: 'x-mac-greek',         // smGreek\n    7: 'x-mac-cyrillic',      // smCyrillic\n    9: 'x-mac-devanagai',     // smDevanagari\n    10: 'x-mac-gurmukhi',     // smGurmukhi\n    11: 'x-mac-gujarati',     // smGujarati\n    12: 'x-mac-oriya',        // smOriya\n    13: 'x-mac-bengali',      // smBengali\n    14: 'x-mac-tamil',        // smTamil\n    15: 'x-mac-telugu',       // smTelugu\n    16: 'x-mac-kannada',      // smKannada\n    17: 'x-mac-malayalam',    // smMalayalam\n    18: 'x-mac-sinhalese',    // smSinhalese\n    19: 'x-mac-burmese',      // smBurmese\n    20: 'x-mac-khmer',        // smKhmer\n    21: 'x-mac-thai',         // smThai\n    22: 'x-mac-lao',          // smLao\n    23: 'x-mac-georgian',     // smGeorgian\n    24: 'x-mac-armenian',     // smArmenian\n    25: 'x-mac-chinesesimp',  // smSimpChinese\n    26: 'x-mac-tibetan',      // smTibetan\n    27: 'x-mac-mongolian',    // smMongolian\n    28: 'x-mac-ethiopic',     // smEthiopic\n    29: 'x-mac-ce',           // smCentralEuroRoman\n    30: 'x-mac-vietnamese',   // smVietnamese\n    31: 'x-mac-extarabic'     // smExtArabic\n};\n\n// MacOS language ID → encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageEncodings = {\n    15: 'x-mac-icelandic',    // langIcelandic\n    17: 'x-mac-turkish',      // langTurkish\n    18: 'x-mac-croatian',     // langCroatian\n    24: 'x-mac-ce',           // langLithuanian\n    25: 'x-mac-ce',           // langPolish\n    26: 'x-mac-ce',           // langHungarian\n    27: 'x-mac-ce',           // langEstonian\n    28: 'x-mac-ce',           // langLatvian\n    30: 'x-mac-icelandic',    // langFaroese\n    37: 'x-mac-romanian',     // langRomanian\n    38: 'x-mac-ce',           // langCzech\n    39: 'x-mac-ce',           // langSlovak\n    40: 'x-mac-ce',           // langSlovenian\n    143: 'x-mac-inuit',       // langInuktitut\n    146: 'x-mac-gaelic'       // langIrishGaelicScript\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n        case 0:  // Unicode\n            return utf16;\n\n        case 1:  // Apple Macintosh\n            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n        case 3:  // Microsoft Windows\n            if (encodingID === 1 || encodingID === 10) {\n                return utf16;\n            }\n\n            break;\n    }\n\n    return undefined;\n}\n\n// Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\nfunction parseNameTable(data, start, ltag) {\n    var name = {};\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    var count = p.parseUShort();\n    var stringOffset = p.offset + p.parseUShort();\n    for (var i = 0; i < count; i++) {\n        var platformID = p.parseUShort();\n        var encodingID = p.parseUShort();\n        var languageID = p.parseUShort();\n        var nameID = p.parseUShort();\n        var property = nameTableNames[nameID] || nameID;\n        var byteLength = p.parseUShort();\n        var offset = p.parseUShort();\n        var language = getLanguageCode(platformID, languageID, ltag);\n        var encoding = getEncoding(platformID, encodingID, languageID);\n        if (encoding !== undefined && language !== undefined) {\n            var text = (void 0);\n            if (encoding === utf16) {\n                text = decode.UTF16(data, stringOffset + offset, byteLength);\n            } else {\n                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n            }\n\n            if (text) {\n                var translations = name[property];\n                if (translations === undefined) {\n                    translations = name[property] = {};\n                }\n\n                translations[language] = text;\n            }\n        }\n    }\n\n    var langTagCount = 0;\n    if (format === 1) {\n        // FIXME: Also handle Microsoft's 'name' table 1.\n        langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\n// {23: 'foo'} → {'foo': 23}\n// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\nfunction reverseDict(dict) {\n    var result = {};\n    for (var key in dict) {\n        result[dict[key]] = parseInt(key);\n    }\n\n    return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Record('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\n// Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\nfunction findSubArray(needle, haystack) {\n    var needleLength = needle.length;\n    var limit = haystack.length - needleLength + 1;\n\n    loop:\n    for (var pos = 0; pos < limit; pos++) {\n        for (; pos < limit; pos++) {\n            for (var k = 0; k < needleLength; k++) {\n                if (haystack[pos + k] !== needle[k]) {\n                    continue loop;\n                }\n            }\n\n            return pos;\n        }\n    }\n\n    return -1;\n}\n\nfunction addStringToPool(s, pool) {\n    var offset = findSubArray(s, pool);\n    if (offset < 0) {\n        offset = pool.length;\n        var i = 0;\n        var len = s.length;\n        for (; i < len; ++i) {\n            pool.push(s[i]);\n        }\n\n    }\n\n    return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n    var nameID;\n    var nameIDs = [];\n\n    var namesWithNumericKeys = {};\n    var nameTableIds = reverseDict(nameTableNames);\n    for (var key in names) {\n        var id = nameTableIds[key];\n        if (id === undefined) {\n            id = key;\n        }\n\n        nameID = parseInt(id);\n\n        if (isNaN(nameID)) {\n            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n        }\n\n        namesWithNumericKeys[nameID] = names[key];\n        nameIDs.push(nameID);\n    }\n\n    var macLanguageIds = reverseDict(macLanguages);\n    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n    var nameRecords = [];\n    var stringPool = [];\n\n    for (var i = 0; i < nameIDs.length; i++) {\n        nameID = nameIDs[i];\n        var translations = namesWithNumericKeys[nameID];\n        for (var lang in translations) {\n            var text = translations[lang];\n\n            // For MacOS, we try to emit the name in the form that was introduced\n            // in the initial version of the TrueType spec (in the late 1980s).\n            // However, this can fail for various reasons: the requested BCP 47\n            // language code might not have an old-style Mac equivalent;\n            // we might not have a codec for the needed character encoding;\n            // or the name might contain characters that cannot be expressed\n            // in the old-style Macintosh encoding. In case of failure, we emit\n            // the name in a more modern fashion (Unicode encoding with BCP 47\n            // language tags) that is recognized by MacOS 10.5, released in 2009.\n            // If fonts were only read by operating systems, we could simply\n            // emit all names in the modern form; this would be much easier.\n            // However, there are many applications and libraries that read\n            // 'name' tables directly, and these will usually only recognize\n            // the ancient form (silently skipping the unrecognized names).\n            var macPlatform = 1;  // Macintosh\n            var macLanguage = macLanguageIds[lang];\n            var macScript = macLanguageToScript[macLanguage];\n            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n            var macName = encode.MACSTRING(text, macEncoding);\n            if (macName === undefined) {\n                macPlatform = 0;  // Unicode\n                macLanguage = ltag.indexOf(lang);\n                if (macLanguage < 0) {\n                    macLanguage = ltag.length;\n                    ltag.push(lang);\n                }\n\n                macScript = 4;  // Unicode 2.0 and later\n                macName = encode.UTF16(text);\n            }\n\n            var macNameOffset = addStringToPool(macName, stringPool);\n            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n                                            nameID, macName.length, macNameOffset));\n\n            var winLanguage = windowsLanguageIds[lang];\n            if (winLanguage !== undefined) {\n                var winName = encode.UTF16(text);\n                var winNameOffset = addStringToPool(winName, stringPool);\n                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n                                                nameID, winName.length, winNameOffset));\n            }\n        }\n    }\n\n    nameRecords.sort(function(a, b) {\n        return ((a.platformID - b.platformID) ||\n                (a.encodingID - b.encodingID) ||\n                (a.languageID - b.languageID) ||\n                (a.nameID - b.nameID));\n    });\n\n    var t = new table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: nameRecords.length},\n        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n    ]);\n\n    for (var r = 0; r < nameRecords.length; r++) {\n        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n    }\n\n    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n    return t;\n}\n\nvar _name = { parse: parseNameTable, make: makeNameTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\nvar unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n        var range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n        case 1:\n            post.names = standardNames.slice();\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n\n            post.names = [];\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n                    var nameLength = p.parseChar();\n                    post.names.push(p.parseString(nameLength));\n                }\n            }\n\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n                post.offset[i$2] = p.parseChar();\n            }\n\n            break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\nvar post = { parse: parsePostTable, make: makePostTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers[extensionLookupType].call(extensionParser)\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GSUB Writing //////////////////////////////////////////////\nvar subtableMakers = new Array(9);\n\nsubtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 1},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n        ]);\n    } else {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 2},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.ushortList('substitute', subtable.substitute)));\n    }\n};\n\nsubtableMakers[2] = function makeLookup2(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {\n        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));\n    })));\n};\n\nsubtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n    })));\n};\n\nsubtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n            return new table.Table('ligatureTable',\n                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n            );\n        }));\n    })));\n};\n\nsubtableMakers[6] = function makeLookup6(subtable) {\n    if (subtable.substFormat === 1) {\n        var returnTable = new table.Table('chainContextTable', [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {\n            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {\n                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));\n\n                chainRule.lookupRecords.forEach(function (record, i) {\n                    tableData = tableData\n                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n                });\n                return new table.Table('chainRuleTable', tableData);\n            }));\n        })));\n        return returnTable;\n    } else if (subtable.substFormat === 2) {\n        check.assert(false, 'lookup type 6 format 2 is not yet supported.');\n    } else if (subtable.substFormat === 3) {\n        var tableData = [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];\n\n        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});\n        subtable.backtrackCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});\n        subtable.inputCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});\n        subtable.lookaheadCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n\n        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});\n        subtable.lookupRecords.forEach(function (record, i) {\n            tableData = tableData\n                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n        });\n\n        var returnTable$1 = new table.Table('chainContextTable', tableData);\n\n        return returnTable$1;\n    }\n\n    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');\n};\n\nfunction makeGsubTable(gsub) {\n    return new table.Table('GSUB', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n    ]);\n}\n\nvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nfunction makeMetaTable(tags) {\n    var numTags = Object.keys(tags).length;\n    var stringPool = '';\n    var stringPoolOffset = 16 + numTags * 12;\n\n    var result = new table.Table('meta', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n        {name: 'numTags', type: 'ULONG', value: numTags}\n    ]);\n\n    for (var tag in tags) {\n        var pos = stringPool.length;\n        stringPool += tags[tag];\n\n        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n    return result;\n}\n\nvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n// The `sfnt` wrapper provides organization for the tables in the font.\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    var sum = 0;\n    for (var i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    var recordFields = [];\n    var tableFields = [];\n\n    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n        var t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        var tableLength = t.sizeOf();\n        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n        var glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            var glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    var sum = 0;\n    for (var i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    var xMins = [];\n    var yMins = [];\n    var xMaxs = [];\n    var yMaxs = [];\n    var advanceWidths = [];\n    var leftSideBearings = [];\n    var rightSideBearings = [];\n    var firstCharIndex;\n    var lastCharIndex = 0;\n    var ulUnicodeRange1 = 0;\n    var ulUnicodeRange2 = 0;\n    var ulUnicodeRange3 = 0;\n    var ulUnicodeRange4 = 0;\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n        var glyph = font.glyphs.get(i);\n        var unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        var position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') { continue; }\n        var metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    var globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    var headTable = head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    var hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    var maxpTable = maxp.make(font.glyphs.length);\n\n    var os2Table = os2.make(Object.assign({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n    }, font.tables.os2));\n\n    var hmtxTable = hmtx.make(font.glyphs);\n    var cmapTable = cmap.make(font.glyphs);\n\n    var englishFamilyName = font.getEnglishName('fontFamily');\n    var englishStyleName = font.getEnglishName('fontSubfamily');\n    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n    var postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    var names = {};\n    for (var n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    var languageTags = [];\n    var nameTable = _name.make(names, languageTags);\n    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n    var postTable = post.make();\n    var cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    var sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode();\n    var checkSum = computeCheckSum(bytes);\n    var tableFields = sfntTable.fields;\n    var checkSumAdjusted = false;\n    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n        if (tableFields[i$1].name === 'head table') {\n            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        var layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        var layout = this.getTable();\n        if (!layout) { return; }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(script, language, feature, create);\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function(classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function(coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) { return false; }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) { return false; }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [{\n            tag: 'DFLT',\n            script: {\n                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n                langSysRecords: []\n            }\n        }],\n        features: [],\n        lookups: []\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function(feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function(feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {format: 1, glyphs: []},\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function(feature, substitution, script, language) {\n    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        sequences: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language)\n                    .concat(this.getAlternates(feature, script, language));\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language)\n                .concat(this.getLigatures(feature, script, language));\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nfunction nodeBufferToArrayBuffer(buffer) {\n    var ab = new ArrayBuffer(buffer.length);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        view[i] = buffer[i];\n    }\n\n    return ab;\n}\n\nfunction arrayBufferToNodeBuffer(ab) {\n    var buffer = new Buffer(ab.byteLength);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n\n    return buffer;\n}\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');\n\n        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n        this.names = {\n            fontFamily: {en: options.familyName || ' '},\n            fontSubfamily: {en: options.styleName || ' '},\n            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n            // postScriptName may not contain any whitespace\n            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n            designer: {en: options.designer || ' '},\n            designerURL: {en: options.designerURL || ' '},\n            manufacturer: {en: options.manufacturer || ' '},\n            manufacturerURL: {en: options.manufacturerURL || ' '},\n            license: {en: options.license || ' '},\n            licenseURL: {en: options.licenseURL || ' '},\n            version: {en: options.version || 'Version 0.1'},\n            description: {en: options.description || ' '},\n            copyright: {en: options.copyright || ' '},\n            trademark: {en: options.trademark || ' '}\n        };\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign({\n                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n            }, options.tables.os2)\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function() {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        }\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; })\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function(s, options) {\n    var this$1 = this;\n\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options ?\n    this.updateFeatures(options.features) :\n    this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.nameToGlyph = function(name) {\n    var glyphIndex = this.nameToGlyphIndex(name);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * @param  {Number}\n * @return {String}\n */\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] }\n    ]\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(script, options.language);\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups ?\n                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n                  this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * @param  {string}\n * @return {string}\n */\nFont.prototype.getEnglishName = function(name) {\n    var translations = this.names[name];\n    if (translations) {\n        return translations.en;\n    }\n};\n\n/**\n * Validate\n */\nFont.prototype.validate = function() {\n    var _this = this;\n\n    function assert(predicate, message) {\n    }\n\n    function assertNamePresent(name) {\n        var englishName = _this.getEnglishName(name);\n        assert(englishName && englishName.trim().length > 0);\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily');\n    assertNamePresent('weightName');\n    assertNamePresent('manufacturer');\n    assertNamePresent('copyright');\n    assertNamePresent('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0);\n};\n\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\nFont.prototype.toTables = function() {\n    return sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\nFont.prototype.toBuffer = function() {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n    return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\nFont.prototype.toArrayBuffer = function() {\n    var sfntTable = this.toTables();\n    var bytes = sfntTable.encode();\n    var buffer = new ArrayBuffer(bytes.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n/**\n * Initiate a download of the OpenType font.\n */\nFont.prototype.download = function(fileName) {\n    var familyName = this.getEnglishName('fontFamily');\n    var styleName = this.getEnglishName('fontSubfamily');\n    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n    var arrayBuffer = this.toArrayBuffer();\n\n    if (isBrowser()) {\n        window.URL = window.URL || window.webkitURL;\n\n        if (window.URL) {\n            var dataView = new DataView(arrayBuffer);\n            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n            var link = document.createElement('a');\n            link.href = window.URL.createObjectURL(blob);\n            link.download = fileName;\n\n            var event = document.createEvent('MouseEvents');\n            event.initEvent('click', true, false);\n            link.dispatchEvent(event);\n        } else {\n            console.warn('Font file could not be downloaded. Try using a different browser.');\n        }\n    } else {\n        var fs = __webpack_require__(/*! fs */ \"?3514\");\n        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n        fs.writeFileSync(fileName, buffer);\n    }\n};\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC:              0x001, //1\n    UNDERSCORE:          0x002, //2\n    NEGATIVE:            0x004, //4\n    OUTLINED:            0x008, //8\n    STRIKEOUT:           0x010, //16\n    BOLD:                0x020, //32\n    REGULAR:             0x040, //64\n    USER_TYPO_METRICS:   0x080, //128\n    WWS:                 0x100, //256\n    OBLIQUE:             0x200  //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK:    900\n};\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction addName(name, names) {\n    var nameString = JSON.stringify(name);\n    var nameID = 256;\n    for (var nameKey in names) {\n        var n = parseInt(nameKey);\n        if (!n || n < 256) {\n            continue;\n        }\n\n        if (JSON.stringify(names[nameKey]) === nameString) {\n            return n;\n        }\n\n        if (nameID <= n) {\n            nameID = n + 1;\n        }\n    }\n\n    names[nameID] = name;\n    return nameID;\n}\n\nfunction makeFvarAxis(n, axis, names) {\n    var nameID = addName(axis.name, names);\n    return [\n        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n        {name: 'flags_' + n, type: 'USHORT', value: 0},\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n    ];\n}\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction makeFvarInstance(n, inst, axes, names) {\n    var nameID = addName(inst.name, names);\n    var fields = [\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n        {name: 'flags_' + n, type: 'USHORT', value: 0}\n    ];\n\n    for (var i = 0; i < axes.length; ++i) {\n        var axisTag = axes[i].tag;\n        fields.push({\n            name: 'axis_' + n + ' ' + axisTag,\n            type: 'FIXED',\n            value: inst.coordinates[axisTag] << 16\n        });\n    }\n\n    return fields;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction makeFvarTable(fvar, names) {\n    var result = new table.Table('fvar', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'offsetToData', type: 'USHORT', value: 0},\n        {name: 'countSizePairs', type: 'USHORT', value: 2},\n        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n        {name: 'axisSize', type: 'USHORT', value: 20},\n        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n    ]);\n    result.offsetToData = result.sizeOf();\n\n    for (var i = 0; i < fvar.axes.length; i++) {\n        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n    }\n\n    for (var j = 0; j < fvar.instances.length; j++) {\n        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n    }\n\n    return result;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n\n    return {axes: axes, instances: instances};\n}\n\nvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord()\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers$1[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n                return {        // pairValueRecord\n                    secondGlyph: this.parseUShort(),\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            })))\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n                return {\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            }))\n        };\n    }\n};\n\nsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\nsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\nsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\nsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\nsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\nsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\nsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GPOS Writing //////////////////////////////////////////////\n// NOT SUPPORTED\nvar subtableMakers$1 = new Array(10);\n\nfunction makeGposTable(gpos) {\n    return new table.Table('GPOS', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n    ]);\n}\n\nvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    var fs = __webpack_require__(/*! fs */ \"?3514\");\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, nodeBufferToArrayBuffer(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.response) {\n            return callback(null, request.response);\n        } else {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        var outBuffer = new Uint8Array(tableEntry.length);\n        tinyInflate(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n\n    var indexToLocFormat;\n    var ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var nameTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    var nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n    var isNode = typeof window === 'undefined';\n    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;\n\n    return new Promise(function (resolve, reject) {\n        loadFn(url, function(err, arrayBuffer) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                } else {\n                    reject(err);\n                }\n            }\n            var font;\n            try {\n                font = parseBuffer(arrayBuffer, opt);\n            } catch (e) {\n                if (callback) {\n                    return callback(e, null);\n                } else {\n                    reject(e);\n                }\n            }\n            if (callback) {\n                return callback(null, font);\n            } else {\n                resolve(font);\n            }\n        });\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @param  {Object} opt - opt.lowMemory\n * @return {opentype.Font}\n */\nfunction loadSync(url, opt) {\n    var fs = __webpack_require__(/*! fs */ \"?3514\");\n    var buffer = fs.readFileSync(url);\n    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);\n}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tFont: Font,\n\tGlyph: Glyph,\n\tPath: Path,\n\tBoundingBox: BoundingBox,\n\t_parse: parse,\n\tparse: parseBuffer,\n\tload: load,\n\tloadSync: loadSync\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (opentype);\n\n//# sourceMappingURL=opentype.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9kaXN0L29wZW50eXBlLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxXQUFXLE9BQU87QUFDaEMsY0FBYyxnQkFBZ0IsT0FBTzs7QUFFckM7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU8sT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUSxPQUFPO0FBQzdCLGNBQWMsU0FBUyxPQUFPO0FBQzlCLGNBQWMsT0FBTyxPQUFPO0FBQzVCLGNBQWMsU0FBUyxPQUFPOztBQUU5QjtBQUNBLGNBQWMsT0FBTyxPQUFPOztBQUU1Qjs7QUFFQSxjQUFjLFFBQVEsT0FBTztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVEsT0FBTzs7QUFFN0I7QUFDQSxjQUFjLFNBQVMsT0FBTzs7QUFFOUI7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkIsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRLE9BQU87O0FBRTdCO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVIsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQSxxQkFBcUI7QUFDckIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxh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QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEUsZ0NBQWdDLG9DQUFvQztBQUNwRSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFLGdDQUFnQyxvQ0FBb0M7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDhDQUE4QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYSxpREFBaUQ7QUFDOUQsYUFBYSx5REFBeUQ7QUFDdEUsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNY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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUztBQUNUO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLFdBQVcsR0FBRztBQUNsQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsZUFBZSxhQUFhO0FBQzVCLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLHlEQUF5RDtBQUNsRSxTQUFTO0FBQ1Q7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1Qyx1QkFBdUIsMkRBQTJEO0FBQ2xGOztBQUVBLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQTs7QUFFQSxjQUFjOztBQUVkOztBQUVBO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywrQkFBK0I7QUFDcEM7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx3Q0FBd0M7QUFDakQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxvREFBb0Q7QUFDN0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUztBQUNUO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGtEQUFrRDtBQUMzRCxTQUFTLDZDQUE2QztBQUN0RCxTQUFTLG1EQUFtRDtBQUM1RCxTQUFTLG9EQUFvRDtBQUM3RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDZDQUE2QztBQUN0RCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0QsYUFBYSw4RUFBOEU7QUFDM0YsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUEyRDtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpRTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7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RXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpQkFBSTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlFQUFlLFFBQVEsRUFBQztBQUN5RTtBQUNqRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb2N1bWVudHNcXFNpdGVzXFxTaXRlc1xcZW0gZGVzZW52b2x2aW1lbnRvXFxQb3J0Zm9saW8yXFxub2RlX21vZHVsZXNcXG9wZW50eXBlLmpzXFxkaXN0XFxvcGVudHlwZS5tb2R1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL29wZW50eXBlLmpzLm9yZyB2MS4zLjQgfCAoYykgRnJlZGVyaWsgRGUgQmxlc2VyIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBNSVQgTGljZW5zZSB8IFVzZXMgdGlueS1pbmZsYXRlIGJ5IERldm9uIEdvdmV0dCBhbmQgc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdCBwb2x5ZmlsbCBieSBNYXRoaWFzIEJ5bmVuc1xuICovXG5cbi8qISBodHRwczovL210aHMuYmUvY29kZXBvaW50YXQgdjAuMi4wIGJ5IEBtYXRoaWFzICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQpIHtcblx0KGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0XHRcdC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdFx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9KCkpO1xuXHRcdHZhciBjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAodGhpcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcblx0XHRcdHZhciBzaXplID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdC8vIGBUb0ludGVnZXJgXG5cdFx0XHR2YXIgaW5kZXggPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuXHRcdFx0aWYgKGluZGV4ICE9IGluZGV4KSB7IC8vIGJldHRlciBgaXNOYU5gXG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdC8vIEFjY291bnQgZm9yIG91dC1vZi1ib3VuZHMgaW5kaWNlczpcblx0XHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gR2V0IHRoZSBmaXJzdCBjb2RlIHVuaXRcblx0XHRcdHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcblx0XHRcdHZhciBzZWNvbmQ7XG5cdFx0XHRpZiAoIC8vIGNoZWNrIGlmIGl04oCZcyB0aGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIC8vIGhpZ2ggc3Vycm9nYXRlXG5cdFx0XHRcdHNpemUgPiBpbmRleCArIDEgLy8gdGhlcmUgaXMgYSBuZXh0IGNvZGUgdW5pdFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cdFx0XHRcdGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRcdHJldHVybiAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlyc3Q7XG5cdFx0fTtcblx0XHRpZiAoZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdjb2RlUG9pbnRBdCcsIHtcblx0XHRcdFx0J3ZhbHVlJzogY29kZVBvaW50QXQsXG5cdFx0XHRcdCdjb25maWd1cmFibGUnOiB0cnVlLFxuXHRcdFx0XHQnd3JpdGFibGUnOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0U3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGNvZGVQb2ludEF0O1xuXHRcdH1cblx0fSgpKTtcbn1cblxudmFyIFRJTkZfT0sgPSAwO1xudmFyIFRJTkZfREFUQV9FUlJPUiA9IC0zO1xuXG5mdW5jdGlvbiBUcmVlKCkge1xuICB0aGlzLnRhYmxlID0gbmV3IFVpbnQxNkFycmF5KDE2KTsgICAvKiB0YWJsZSBvZiBjb2RlIGxlbmd0aCBjb3VudHMgKi9cbiAgdGhpcy50cmFucyA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAgLyogY29kZSAtPiBzeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKi9cbn1cblxuZnVuY3Rpb24gRGF0YShzb3VyY2UsIGRlc3QpIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuc291cmNlSW5kZXggPSAwO1xuICB0aGlzLnRhZyA9IDA7XG4gIHRoaXMuYml0Y291bnQgPSAwO1xuICBcbiAgdGhpcy5kZXN0ID0gZGVzdDtcbiAgdGhpcy5kZXN0TGVuID0gMDtcbiAgXG4gIHRoaXMubHRyZWUgPSBuZXcgVHJlZSgpOyAgLyogZHluYW1pYyBsZW5ndGgvc3ltYm9sIHRyZWUgKi9cbiAgdGhpcy5kdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGRpc3RhbmNlIHRyZWUgKi9cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIHVuaW5pdGlhbGl6ZWQgZ2xvYmFsIGRhdGEgKHN0YXRpYyBzdHJ1Y3R1cmVzKSAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIHNsdHJlZSA9IG5ldyBUcmVlKCk7XG52YXIgc2R0cmVlID0gbmV3IFRyZWUoKTtcblxuLyogZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgZm9yIGxlbmd0aCBjb2RlcyAqL1xudmFyIGxlbmd0aF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xudmFyIGxlbmd0aF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuLyogZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgZm9yIGRpc3RhbmNlIGNvZGVzICovXG52YXIgZGlzdF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xudmFyIGRpc3RfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cbi8qIHNwZWNpYWwgb3JkZXJpbmcgb2YgY29kZSBsZW5ndGggY29kZXMgKi9cbnZhciBjbGNpZHggPSBuZXcgVWludDhBcnJheShbXG4gIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsXG4gIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLFxuICAxNCwgMSwgMTVcbl0pO1xuXG4vKiB1c2VkIGJ5IHRpbmZfZGVjb2RlX3RyZWVzLCBhdm9pZHMgYWxsb2NhdGlvbnMgZXZlcnkgY2FsbCAqL1xudmFyIGNvZGVfdHJlZSA9IG5ldyBUcmVlKCk7XG52YXIgbGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDI4OCArIDMyKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gdXRpbGl0eSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogYnVpbGQgZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgKi9cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfYml0c19iYXNlKGJpdHMsIGJhc2UsIGRlbHRhLCBmaXJzdCkge1xuICB2YXIgaSwgc3VtO1xuXG4gIC8qIGJ1aWxkIGJpdHMgdGFibGUgKi9cbiAgZm9yIChpID0gMDsgaSA8IGRlbHRhOyArK2kpIHsgYml0c1tpXSA9IDA7IH1cbiAgZm9yIChpID0gMDsgaSA8IDMwIC0gZGVsdGE7ICsraSkgeyBiaXRzW2kgKyBkZWx0YV0gPSBpIC8gZGVsdGEgfCAwOyB9XG5cbiAgLyogYnVpbGQgYmFzZSB0YWJsZSAqL1xuICBmb3IgKHN1bSA9IGZpcnN0LCBpID0gMDsgaSA8IDMwOyArK2kpIHtcbiAgICBiYXNlW2ldID0gc3VtO1xuICAgIHN1bSArPSAxIDw8IGJpdHNbaV07XG4gIH1cbn1cblxuLyogYnVpbGQgdGhlIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfZml4ZWRfdHJlZXMobHQsIGR0KSB7XG4gIHZhciBpO1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGxlbmd0aCB0cmVlICovXG4gIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHsgbHQudGFibGVbaV0gPSAwOyB9XG5cbiAgbHQudGFibGVbN10gPSAyNDtcbiAgbHQudGFibGVbOF0gPSAxNTI7XG4gIGx0LnRhYmxlWzldID0gMTEyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAyNDsgKytpKSB7IGx0LnRyYW5zW2ldID0gMjU2ICsgaTsgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTQ0OyArK2kpIHsgbHQudHJhbnNbMjQgKyBpXSA9IGk7IH1cbiAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkgeyBsdC50cmFuc1syNCArIDE0NCArIGldID0gMjgwICsgaTsgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTEyOyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyA4ICsgaV0gPSAxNDQgKyBpOyB9XG5cbiAgLyogYnVpbGQgZml4ZWQgZGlzdGFuY2UgdHJlZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgNTsgKytpKSB7IGR0LnRhYmxlW2ldID0gMDsgfVxuXG4gIGR0LnRhYmxlWzVdID0gMzI7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyArK2kpIHsgZHQudHJhbnNbaV0gPSBpOyB9XG59XG5cbi8qIGdpdmVuIGFuIGFycmF5IG9mIGNvZGUgbGVuZ3RocywgYnVpbGQgYSB0cmVlICovXG52YXIgb2ZmcyA9IG5ldyBVaW50MTZBcnJheSgxNik7XG5cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfdHJlZSh0LCBsZW5ndGhzLCBvZmYsIG51bSkge1xuICB2YXIgaSwgc3VtO1xuXG4gIC8qIGNsZWFyIGNvZGUgbGVuZ3RoIGNvdW50IHRhYmxlICovXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7IHQudGFibGVbaV0gPSAwOyB9XG5cbiAgLyogc2NhbiBzeW1ib2wgbGVuZ3RocywgYW5kIHN1bSBjb2RlIGxlbmd0aCBjb3VudHMgKi9cbiAgZm9yIChpID0gMDsgaSA8IG51bTsgKytpKSB7IHQudGFibGVbbGVuZ3Roc1tvZmYgKyBpXV0rKzsgfVxuXG4gIHQudGFibGVbMF0gPSAwO1xuXG4gIC8qIGNvbXB1dGUgb2Zmc2V0IHRhYmxlIGZvciBkaXN0cmlidXRpb24gc29ydCAqL1xuICBmb3IgKHN1bSA9IDAsIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIG9mZnNbaV0gPSBzdW07XG4gICAgc3VtICs9IHQudGFibGVbaV07XG4gIH1cblxuICAvKiBjcmVhdGUgY29kZS0+c3ltYm9sIHRyYW5zbGF0aW9uIHRhYmxlIChzeW1ib2xzIHNvcnRlZCBieSBjb2RlKSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICBpZiAobGVuZ3Roc1tvZmYgKyBpXSkgeyB0LnRyYW5zW29mZnNbbGVuZ3Roc1tvZmYgKyBpXV0rK10gPSBpOyB9XG4gIH1cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBkZWNvZGUgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogZ2V0IG9uZSBiaXQgZnJvbSBzb3VyY2Ugc3RyZWFtICovXG5mdW5jdGlvbiB0aW5mX2dldGJpdChkKSB7XG4gIC8qIGNoZWNrIGlmIHRhZyBpcyBlbXB0eSAqL1xuICBpZiAoIWQuYml0Y291bnQtLSkge1xuICAgIC8qIGxvYWQgbmV4dCB0YWcgKi9cbiAgICBkLnRhZyA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107XG4gICAgZC5iaXRjb3VudCA9IDc7XG4gIH1cblxuICAvKiBzaGlmdCBiaXQgb3V0IG9mIHRhZyAqL1xuICB2YXIgYml0ID0gZC50YWcgJiAxO1xuICBkLnRhZyA+Pj49IDE7XG5cbiAgcmV0dXJuIGJpdDtcbn1cblxuLyogcmVhZCBhIG51bSBiaXQgdmFsdWUgZnJvbSBhIHN0cmVhbSBhbmQgYWRkIGJhc2UgKi9cbmZ1bmN0aW9uIHRpbmZfcmVhZF9iaXRzKGQsIG51bSwgYmFzZSkge1xuICBpZiAoIW51bSlcbiAgICB7IHJldHVybiBiYXNlOyB9XG5cbiAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudDtcbiAgICBkLmJpdGNvdW50ICs9IDg7XG4gIH1cblxuICB2YXIgdmFsID0gZC50YWcgJiAoMHhmZmZmID4+PiAoMTYgLSBudW0pKTtcbiAgZC50YWcgPj4+PSBudW07XG4gIGQuYml0Y291bnQgLT0gbnVtO1xuICByZXR1cm4gdmFsICsgYmFzZTtcbn1cblxuLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSBhbmQgYSB0cmVlLCBkZWNvZGUgYSBzeW1ib2wgKi9cbmZ1bmN0aW9uIHRpbmZfZGVjb2RlX3N5bWJvbChkLCB0KSB7XG4gIHdoaWxlIChkLmJpdGNvdW50IDwgMjQpIHtcbiAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG4gICAgZC5iaXRjb3VudCArPSA4O1xuICB9XG4gIFxuICB2YXIgc3VtID0gMCwgY3VyID0gMCwgbGVuID0gMDtcbiAgdmFyIHRhZyA9IGQudGFnO1xuXG4gIC8qIGdldCBtb3JlIGJpdHMgd2hpbGUgY29kZSB2YWx1ZSBpcyBhYm92ZSBzdW0gKi9cbiAgZG8ge1xuICAgIGN1ciA9IDIgKiBjdXIgKyAodGFnICYgMSk7XG4gICAgdGFnID4+Pj0gMTtcbiAgICArK2xlbjtcblxuICAgIHN1bSArPSB0LnRhYmxlW2xlbl07XG4gICAgY3VyIC09IHQudGFibGVbbGVuXTtcbiAgfSB3aGlsZSAoY3VyID49IDApO1xuICBcbiAgZC50YWcgPSB0YWc7XG4gIGQuYml0Y291bnQgLT0gbGVuO1xuXG4gIHJldHVybiB0LnRyYW5zW3N1bSArIGN1cl07XG59XG5cbi8qIGdpdmVuIGEgZGF0YSBzdHJlYW0sIGRlY29kZSBkeW5hbWljIHRyZWVzIGZyb20gaXQgKi9cbmZ1bmN0aW9uIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGx0LCBkdCkge1xuICB2YXIgaGxpdCwgaGRpc3QsIGhjbGVuO1xuICB2YXIgaSwgbnVtLCBsZW5ndGg7XG5cbiAgLyogZ2V0IDUgYml0cyBITElUICgyNTctMjg2KSAqL1xuICBobGl0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMjU3KTtcblxuICAvKiBnZXQgNSBiaXRzIEhESVNUICgxLTMyKSAqL1xuICBoZGlzdCA9IHRpbmZfcmVhZF9iaXRzKGQsIDUsIDEpO1xuXG4gIC8qIGdldCA0IGJpdHMgSENMRU4gKDQtMTkpICovXG4gIGhjbGVuID0gdGluZl9yZWFkX2JpdHMoZCwgNCwgNCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDE5OyArK2kpIHsgbGVuZ3Roc1tpXSA9IDA7IH1cblxuICAvKiByZWFkIGNvZGUgbGVuZ3RocyBmb3IgY29kZSBsZW5ndGggYWxwaGFiZXQgKi9cbiAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyArK2kpIHtcbiAgICAvKiBnZXQgMyBiaXRzIGNvZGUgbGVuZ3RoICgwLTcpICovXG4gICAgdmFyIGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAwKTtcbiAgICBsZW5ndGhzW2NsY2lkeFtpXV0gPSBjbGVuO1xuICB9XG5cbiAgLyogYnVpbGQgY29kZSBsZW5ndGggdHJlZSAqL1xuICB0aW5mX2J1aWxkX3RyZWUoY29kZV90cmVlLCBsZW5ndGhzLCAwLCAxOSk7XG5cbiAgLyogZGVjb2RlIGNvZGUgbGVuZ3RocyBmb3IgdGhlIGR5bmFtaWMgdHJlZXMgKi9cbiAgZm9yIChudW0gPSAwOyBudW0gPCBobGl0ICsgaGRpc3Q7KSB7XG4gICAgdmFyIHN5bSA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBjb2RlX3RyZWUpO1xuXG4gICAgc3dpdGNoIChzeW0pIHtcbiAgICAgIGNhc2UgMTY6XG4gICAgICAgIC8qIGNvcHkgcHJldmlvdXMgY29kZSBsZW5ndGggMy02IHRpbWVzIChyZWFkIDIgYml0cykgKi9cbiAgICAgICAgdmFyIHByZXYgPSBsZW5ndGhzW251bSAtIDFdO1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNzpcbiAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDMtMTAgdGltZXMgKHJlYWQgMyBiaXRzKSAqL1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODpcbiAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDExLTEzOCB0aW1lcyAocmVhZCA3IGJpdHMpICovXG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgNywgMTEpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogdmFsdWVzIDAtMTUgcmVwcmVzZW50IHRoZSBhY3R1YWwgY29kZSBsZW5ndGhzICovXG4gICAgICAgIGxlbmd0aHNbbnVtKytdID0gc3ltO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKiBidWlsZCBkeW5hbWljIHRyZWVzICovXG4gIHRpbmZfYnVpbGRfdHJlZShsdCwgbGVuZ3RocywgMCwgaGxpdCk7XG4gIHRpbmZfYnVpbGRfdHJlZShkdCwgbGVuZ3RocywgaGxpdCwgaGRpc3QpO1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBibG9jayBpbmZsYXRlIGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBnaXZlbiBhIHN0cmVhbSBhbmQgdHdvIHRyZWVzLCBpbmZsYXRlIGEgYmxvY2sgb2YgZGF0YSAqL1xuZnVuY3Rpb24gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgbHQsIGR0KSB7XG4gIHdoaWxlICgxKSB7XG4gICAgdmFyIHN5bSA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBsdCk7XG5cbiAgICAvKiBjaGVjayBmb3IgZW5kIG9mIGJsb2NrICovXG4gICAgaWYgKHN5bSA9PT0gMjU2KSB7XG4gICAgICByZXR1cm4gVElORl9PSztcbiAgICB9XG5cbiAgICBpZiAoc3ltIDwgMjU2KSB7XG4gICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gc3ltO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuZ3RoLCBkaXN0LCBvZmZzO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHN5bSAtPSAyNTc7XG5cbiAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBsZW5ndGggY29kZSAqL1xuICAgICAgbGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgbGVuZ3RoX2JpdHNbc3ltXSwgbGVuZ3RoX2Jhc2Vbc3ltXSk7XG5cbiAgICAgIGRpc3QgPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgZHQpO1xuXG4gICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gZGlzdGFuY2UgY29kZSAqL1xuICAgICAgb2ZmcyA9IGQuZGVzdExlbiAtIHRpbmZfcmVhZF9iaXRzKGQsIGRpc3RfYml0c1tkaXN0XSwgZGlzdF9iYXNlW2Rpc3RdKTtcblxuICAgICAgLyogY29weSBtYXRjaCAqL1xuICAgICAgZm9yIChpID0gb2ZmczsgaSA8IG9mZnMgKyBsZW5ndGg7ICsraSkge1xuICAgICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5kZXN0W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiBpbmZsYXRlIGFuIHVuY29tcHJlc3NlZCBibG9jayBvZiBkYXRhICovXG5mdW5jdGlvbiB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpIHtcbiAgdmFyIGxlbmd0aCwgaW52bGVuZ3RoO1xuICB2YXIgaTtcbiAgXG4gIC8qIHVucmVhZCBmcm9tIGJpdGJ1ZmZlciAqL1xuICB3aGlsZSAoZC5iaXRjb3VudCA+IDgpIHtcbiAgICBkLnNvdXJjZUluZGV4LS07XG4gICAgZC5iaXRjb3VudCAtPSA4O1xuICB9XG5cbiAgLyogZ2V0IGxlbmd0aCAqL1xuICBsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMV07XG4gIGxlbmd0aCA9IDI1NiAqIGxlbmd0aCArIGQuc291cmNlW2Quc291cmNlSW5kZXhdO1xuXG4gIC8qIGdldCBvbmUncyBjb21wbGVtZW50IG9mIGxlbmd0aCAqL1xuICBpbnZsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgM107XG4gIGludmxlbmd0aCA9IDI1NiAqIGludmxlbmd0aCArIGQuc291cmNlW2Quc291cmNlSW5kZXggKyAyXTtcblxuICAvKiBjaGVjayBsZW5ndGggKi9cbiAgaWYgKGxlbmd0aCAhPT0gKH5pbnZsZW5ndGggJiAweDAwMDBmZmZmKSlcbiAgICB7IHJldHVybiBUSU5GX0RBVEFfRVJST1I7IH1cblxuICBkLnNvdXJjZUluZGV4ICs9IDQ7XG5cbiAgLyogY29weSBibG9jayAqL1xuICBmb3IgKGkgPSBsZW5ndGg7IGk7IC0taSlcbiAgICB7IGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdOyB9XG5cbiAgLyogbWFrZSBzdXJlIHdlIHN0YXJ0IG5leHQgYmxvY2sgb24gYSBieXRlIGJvdW5kYXJ5ICovXG4gIGQuYml0Y291bnQgPSAwO1xuXG4gIHJldHVybiBUSU5GX09LO1xufVxuXG4vKiBpbmZsYXRlIHN0cmVhbSBmcm9tIHNvdXJjZSB0byBkZXN0ICovXG5mdW5jdGlvbiB0aW5mX3VuY29tcHJlc3Moc291cmNlLCBkZXN0KSB7XG4gIHZhciBkID0gbmV3IERhdGEoc291cmNlLCBkZXN0KTtcbiAgdmFyIGJmaW5hbCwgYnR5cGUsIHJlcztcblxuICBkbyB7XG4gICAgLyogcmVhZCBmaW5hbCBibG9jayBmbGFnICovXG4gICAgYmZpbmFsID0gdGluZl9nZXRiaXQoZCk7XG5cbiAgICAvKiByZWFkIGJsb2NrIHR5cGUgKDIgYml0cykgKi9cbiAgICBidHlwZSA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDApO1xuXG4gICAgLyogZGVjb21wcmVzcyBibG9jayAqL1xuICAgIHN3aXRjaCAoYnR5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLyogZGVjb21wcmVzcyB1bmNvbXByZXNzZWQgYmxvY2sgKi9cbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgd2l0aCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG4gICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIHNsdHJlZSwgc2R0cmVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgd2l0aCBkeW5hbWljIGh1ZmZtYW4gdHJlZXMgKi9cbiAgICAgICAgdGluZl9kZWNvZGVfdHJlZXMoZCwgZC5sdHJlZSwgZC5kdHJlZSk7XG4gICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcyA9IFRJTkZfREFUQV9FUlJPUjtcbiAgICB9XG5cbiAgICBpZiAocmVzICE9PSBUSU5GX09LKVxuICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZXJyb3InKTsgfVxuXG4gIH0gd2hpbGUgKCFiZmluYWwpO1xuXG4gIGlmIChkLmRlc3RMZW4gPCBkLmRlc3QubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBkLmRlc3Quc2xpY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICB7IHJldHVybiBkLmRlc3Quc2xpY2UoMCwgZC5kZXN0TGVuKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIGQuZGVzdC5zdWJhcnJheSgwLCBkLmRlc3RMZW4pOyB9XG4gIH1cbiAgXG4gIHJldHVybiBkLmRlc3Q7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGluaXRpYWxpemF0aW9uIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbnRpbmZfYnVpbGRfZml4ZWRfdHJlZXMoc2x0cmVlLCBzZHRyZWUpO1xuXG4vKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xudGluZl9idWlsZF9iaXRzX2Jhc2UobGVuZ3RoX2JpdHMsIGxlbmd0aF9iYXNlLCA0LCAzKTtcbnRpbmZfYnVpbGRfYml0c19iYXNlKGRpc3RfYml0cywgZGlzdF9iYXNlLCAyLCAxKTtcblxuLyogZml4IGEgc3BlY2lhbCBjYXNlICovXG5sZW5ndGhfYml0c1syOF0gPSAwO1xubGVuZ3RoX2Jhc2VbMjhdID0gMjU4O1xuXG52YXIgdGlueUluZmxhdGUgPSB0aW5mX3VuY29tcHJlc3M7XG5cbi8vIFRoZSBCb3VuZGluZyBCb3ggb2JqZWN0XG5cbmZ1bmN0aW9uIGRlcml2ZSh2MCwgdjEsIHYyLCB2MywgdCkge1xuICAgIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMykgKiB2MCArXG4gICAgICAgIDMgKiBNYXRoLnBvdygxIC0gdCwgMikgKiB0ICogdjEgK1xuICAgICAgICAzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogdjIgK1xuICAgICAgICBNYXRoLnBvdyh0LCAzKSAqIHYzO1xufVxuLyoqXG4gKiBBIGJvdW5kaW5nIGJveCBpcyBhbiBlbmNsb3NpbmcgYm94IHRoYXQgZGVzY3JpYmVzIHRoZSBzbWFsbGVzdCBtZWFzdXJlIHdpdGhpbiB3aGljaCBhbGwgdGhlIHBvaW50cyBsaWUuXG4gKiBJdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIGEgZ2x5cGggb3IgdGV4dCBwYXRoLlxuICpcbiAqIE9uIGluaXRpYWxpemF0aW9uLCB4MS95MS94Mi95MiB3aWxsIGJlIE5hTi4gQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSB1c2luZyBgaXNFbXB0eSgpYC5cbiAqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Cb3VuZGluZ0JveFxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQm91bmRpbmdCb3goKSB7XG4gICAgdGhpcy54MSA9IE51bWJlci5OYU47XG4gICAgdGhpcy55MSA9IE51bWJlci5OYU47XG4gICAgdGhpcy54MiA9IE51bWJlci5OYU47XG4gICAgdGhpcy55MiA9IE51bWJlci5OYU47XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBib3VuZGluZyBib3ggaXMgZW1wdHksIHRoYXQgaXMsIG5vIHBvaW50cyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGJveCB5ZXQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueDIpIHx8IGlzTmFOKHRoaXMueTIpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHBvaW50IHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGUgeDEveTEveDIveTIgY29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kaW5nIGJveCB3aWxsIG5vdyBlbmNvbXBhc3MgdGhlIGdpdmVuIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IHRoaXMueDEpIHtcbiAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID4gdGhpcy54Mikge1xuICAgICAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCB0aGlzLnkxKSB7XG4gICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRoaXMueTIpIHtcbiAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBYIGNvb3JkaW5hdGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIFggY29vcmRpbmF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGluc2lkZSBvZiBhZGRCZXppZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkWCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB0aGlzLmFkZFBvaW50KHgsIG51bGwpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBZIGNvb3JkaW5hdGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIFkgY29vcmRpbmF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGluc2lkZSBvZiBhZGRCZXppZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkWSA9IGZ1bmN0aW9uKHkpIHtcbiAgICB0aGlzLmFkZFBvaW50KG51bGwsIHkpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBCw6l6aWVyIGN1cnZlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBlbnRpcmUgQsOpemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRoZSBzdGFydGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgZW5kaW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZGluZyBZIGNvb3JkaW5hdGUuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRCZXppZXIgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIGh0dHA6Ly9uaXNoaW9oaXJva2F6dS5ibG9nc3BvdC5jb20vMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vaWNvbnM4L3N2Zy1wYXRoLWJvdW5kaW5nLWJveFxuXG4gICAgdmFyIHAwID0gW3gwLCB5MF07XG4gICAgdmFyIHAxID0gW3gxLCB5MV07XG4gICAgdmFyIHAyID0gW3gyLCB5Ml07XG4gICAgdmFyIHAzID0gW3gsIHldO1xuXG4gICAgdGhpcy5hZGRQb2ludCh4MCwgeTApO1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgICB2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICAgIHZhciBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuXG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgdmFyIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7IH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcbiAgICAgICAgaWYgKGIyYWMgPCAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcy5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHsgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcy5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDIpKTsgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHsgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDIpKTsgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIHN0YXJ0aW5nIFkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgZW5kaW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZGluZyBZIGNvb3JkaW5hdGUuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRRdWFkID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICB2YXIgY3AxeCA9IHgwICsgMiAvIDMgKiAoeDEgLSB4MCk7XG4gICAgdmFyIGNwMXkgPSB5MCArIDIgLyAzICogKHkxIC0geTApO1xuICAgIHZhciBjcDJ4ID0gY3AxeCArIDEgLyAzICogKHggLSB4MCk7XG4gICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAoeSAtIHkwKTtcbiAgICB0aGlzLmFkZEJlemllcih4MCwgeTAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xufTtcblxuLy8gR2VvbWV0cmljIG9iamVjdHNcblxuLyoqXG4gKiBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTCcsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogY3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBiZXppZXJDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqIEBzZWUgY3VydmVUb1xuICovXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRyYXRpY0N1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VQYXRoXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuXG4vKipcbiAqIENsb3NlIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJ1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gKi9cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhdGhPckNvbW1hbmRzKSB7XG4gICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG4gICAgICAgIHBhdGhPckNvbW1hbmRzID0gcGF0aE9yQ29tbWFuZHMuY29tbWFuZHM7XG4gICAgfSBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgIHZhciBib3ggPSBwYXRoT3JDb21tYW5kcztcbiAgICAgICAgdGhpcy5tb3ZlVG8oYm94LngxLCBib3gueTEpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55MSk7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkyKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngxLCBib3gueTIpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBwYXRoT3JDb21tYW5kcyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBwYXRoLlxuICogQHJldHVybnMge29wZW50eXBlLkJvdW5kaW5nQm94fVxuICovXG5QYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBzdGFydFggPSAwO1xuICAgIHZhciBzdGFydFkgPSAwO1xuICAgIHZhciBwcmV2WCA9IDA7XG4gICAgdmFyIHByZXZZID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRRdWFkKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgYm94LmFkZEJlemllcihwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBwcmV2WCA9IHN0YXJ0WDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHN0YXJ0WTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhdGggY29tbWFuZCAnICsgY21kLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib3guaXNFbXB0eSgpKSB7XG4gICAgICAgIGJveC5hZGRQb2ludCgwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQuXG4gKi9cblBhdGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIFBhdGggdG8gYSBzdHJpbmcgb2YgcGF0aCBkYXRhIGluc3RydWN0aW9uc1xuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG4gICAgZnVuY3Rpb24gZmxvYXRUb1N0cmluZyh2KSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHYpID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhY2tWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHMkMVtpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDAgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyArPSBmbG9hdFRvU3RyaW5nKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXRoIHRvIGFuIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciBzdmcgPSAnPHBhdGggZD1cIic7XG4gICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBzdmcgKz0gJ1wiJztcbiAgICBpZiAodGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ2JsYWNrJykge1xuICAgICAgICBpZiAodGhpcy5maWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwibm9uZVwiJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCInICsgdGhpcy5maWxsICsgJ1wiJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cblxuICAgIHN2ZyArPSAnLz4nO1xuICAgIHJldHVybiBzdmc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhdGggdG8gYSBET00gZWxlbWVudC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge1NWR1BhdGhFbGVtZW50fVxuICovXG5QYXRoLnByb3RvdHlwZS50b0RPTUVsZW1lbnQgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgdmFyIHRlbXBvcmFyeVBhdGggPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG4gICAgdmFyIG5ld1BhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcblxuICAgIG5ld1BhdGguc2V0QXR0cmlidXRlKCdkJywgdGVtcG9yYXJ5UGF0aCk7XG5cbiAgICByZXR1cm4gbmV3UGF0aDtcbn07XG5cbi8vIFJ1bi10aW1lIGNoZWNraW5nIG9mIHByZWNvbmRpdGlvbnMuXG5cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmZ1bmN0aW9uIGFyZ3VtZW50KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIGZhaWwobWVzc2FnZSk7XG4gICAgfVxufVxudmFyIGNoZWNrID0geyBmYWlsOiBmYWlsLCBhcmd1bWVudDogYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcblxuLy8gRGF0YSB0eXBlcyB1c2VkIGluIHRoZSBPcGVuVHlwZSBmb250IGZpbGUuXG5cbnZhciBMSU1JVDE2ID0gMzI3Njg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDE2LWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMl4xNVxudmFyIExJTUlUMzIgPSAyMTQ3NDgzNjQ4OyAvLyBUaGUgbGltaXQgYXQgd2hpY2ggYSAzMi1iaXQgbnVtYmVyIHN3aXRjaGVzIHNpZ25zID09IDIgXiAzMVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLmRlY29kZVxuICogQGNsYXNzXG4gKi9cbnZhciBkZWNvZGUgPSB7fTtcbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZW5jb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGVuY29kZSA9IHt9O1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5zaXplT2ZcbiAqIEBjbGFzc1xuICovXG52YXIgc2l6ZU9mID0ge307XG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuXG5mdW5jdGlvbiBjb25zdGFudCh2KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbnZlcnQgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYgPj0gMCAmJiB2IDw9IDI1NSwgJ0J5dGUgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMjU1LicpO1xuICAgIHJldHVybiBbdl07XG59O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5CWVRFID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2ID0gJyc7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5kZWZpbmVkIENIQVJBUlJBWSBlbmNvdW50ZXJlZCBhbmQgdHJlYXRlZCBhcyBhbiBlbXB0eSBzdHJpbmcuIFRoaXMgaXMgcHJvYmFibHkgY2F1c2VkIGJ5IGEgbWlzc2luZyBnbHlwaCBuYW1lLicpO1xuICAgIH1cbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiW2ldID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBiO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdi5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVVNIT1JUID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVTSE9SVCA9IGNvbnN0YW50KDIpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAxNi1iaXQgc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlNIT1JUID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDE2KSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMjQtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDMgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5MT05HID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDMyKSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMzItYml0IEFwcGxlIE1hYyB0aW1lc3RhbXAgaW50ZWdlciB0byBhIGxpc3Qgb2YgOCBieXRlcywgNjQtYml0IHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkxPTkdEQVRFVElNRSA9IGNvbnN0YW50KDgpO1xuXG4vKipcbiAqIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5UQUcgPSBmdW5jdGlvbih2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVEFHID0gY29uc3RhbnQoNCk7XG5cbi8vIENGRiBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmVuY29kZS5DYXJkOCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLkNhcmQ4ID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5DYXJkMTYgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLkNhcmQxNiA9IHNpemVPZi5VU0hPUlQ7XG5cbmVuY29kZS5PZmZTaXplID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuT2ZmU2l6ZSA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuU0lEID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5TSUQgPSBzaXplT2YuVVNIT1JUO1xuXG4vLyBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgPj0gLTEwNyAmJiB2IDw9IDEwNykge1xuICAgICAgICByZXR1cm4gW3YgKyAxMzldO1xuICAgIH0gZWxzZSBpZiAodiA+PSAxMDggJiYgdiA8PSAxMTMxKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtMzI3NjggYW5kICszMjc2NyB0byBhIHRocmVlLWJ5dGUgdmFsdWUuXG4gKiBUaGlzIGVuc3VyZXMgd2UgYWx3YXlzIHVzZSB0aHJlZSBieXRlcywgYnV0IGlzIG5vdCB0aGUgbW9zdCBjb21wYWN0IGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsyOCwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMyk7XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtKDJeMzEpIGFuZCArKDJeMzEtMSkgdG8gYSBmaXZlLWJ5dGUgdmFsdWUuXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBiZSBzdXJlIHlvdSBhbHdheXMgdXNlIGZvdXIgYnl0ZXMsXG4gKiBhdCB0aGUgZXhwZW5zZSBvZiB3YXN0aW5nIGEgZmV3IGJ5dGVzIGZvciBzbWFsbGVyIG51bWJlcnMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjksICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDUpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuUkVBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgdmFsdWUgPSB2LnRvU3RyaW5nKCk7XG5cbiAgICAvLyBTb21lIG51bWJlcnMgdXNlIGFuIGVwc2lsb24gdG8gZW5jb2RlIHRoZSB2YWx1ZS4gKGUuZy4gSmF2YVNjcmlwdCB3aWxsIHN0b3JlIDAuMDAwMDAwMSBhcyAxZS03KVxuICAgIC8vIFRoaXMgY29kZSBjb252ZXJ0cyBpdCBiYWNrIHRvIGEgbnVtYmVyIHdpdGhvdXQgdGhlIGVwc2lsb24uXG4gICAgdmFyIG0gPSAvXFwuKFxcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcXGR7MCwyfSg/OmUoLispfCQpLy5leGVjKHZhbHVlKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IHBhcnNlRmxvYXQoJzFlJyArICgobVsyXSA/ICttWzJdIDogMCkgKyBtWzFdLmxlbmd0aCkpO1xuICAgICAgICB2YWx1ZSA9IChNYXRoLnJvdW5kKHYgKiBlcHNpbG9uKSAvIGVwc2lsb24pLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIG5pYmJsZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gdmFsdWVbaV07XG4gICAgICAgIGlmIChjID09PSAnZScpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gdmFsdWVbKytpXSA9PT0gJy0nID8gJ2MnIDogJ2InO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcuJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSAnYSc7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9ICdlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5pYmJsZXMgKz0gKG5pYmJsZXMubGVuZ3RoICYgMSkgPyAnZicgOiAnZmYnO1xuICAgIHZhciBvdXQgPSBbMzBdO1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGlpJDEgPSBuaWJibGVzLmxlbmd0aDsgaSQxIDwgaWkkMTsgaSQxICs9IDIpIHtcbiAgICAgICAgb3V0LnB1c2gocGFyc2VJbnQobmliYmxlcy5zdWJzdHIoaSQxLCAyKSwgMTYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDgob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcyAvIDI7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIFVURjE2LUJFLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY29kZXBvaW50ID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IChjb2RlcG9pbnQgPj4gOCkgJiAweEZGO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IGNvZGVwb2ludCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAqIDI7XG59O1xuXG4vLyBEYXRhIGZvciBjb252ZXJ0aW5nIG9sZCBlaWdodC1iaXQgTWFjaW50b3NoIGVuY29kaW5ncyB0byBVbmljb2RlLlxuLy8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcbi8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcbi8vIHdhbnQgdG8gb3BlbiBmb250cywgYnV0IHNhdmluZyBhIGZvbnQgd2lsbCBiZSBjb21wYXJhdGl2ZWx5IHJhcmVcbi8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG4vL1xuLy8gUHl0aG9uIHNjcmlwdCBmb3IgZ2VuZXJhdGluZyB0aGVzZSBzdHJpbmdzOlxuLy9cbi8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG4vLyAgICAgcHJpbnQocy5lbmNvZGUoJ3V0Zi04JykpXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlaWdodEJpdE1hY0VuY29kaW5ncyA9IHtcbiAgICAneC1tYWMtY3JvYXRpYW4nOiAgLy8gUHl0aG9uOiAnbWFjX2Nyb2F0aWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7FoOKEosK0wqjiiaDFvcOY4oiewrHiiaTiiaXiiIbCteKIguKIkeKIj8Wh4oirwqrCus6pxb7DuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvo7/CqeKBhOKCrOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLhycsXG4gICAgJ3gtbWFjLWN5cmlsbGljJzogIC8vIFB5dGhvbjogJ21hY19jeXJpbGxpYydcbiAgICAn0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGaJyArXG4gICAgJ9GY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjicsXG4gICAgJ3gtbWFjLWdhZWxpYyc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9HQUVMSUMuVFhUXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jhuILCseKJpOKJpeG4g8SKxIvhuIrhuIvhuJ7huJ/EoMSh4bmAw6bDuCcgK1xuICAgICfhuYHhuZbhuZfJvMaSxb/huaDCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZ4bmh4bqbw7/FuOG5quKCrOKAueKAusW2xbfhuavCt+G7suG7s+KBisOCw4rDgcOLw4jDjcOOw4/DjMOTw5TimaPDksOaw5vDmcSxw53DvcW0xbXhuoThuoXhuoDhuoHhuoLhuoMnLFxuICAgICd4LW1hYy1ncmVlayc6ICAvLyBQeXRob246ICdtYWNfZ3JlZWsnXG4gICAgJ8OEwrnCssOJwrPDlsOczoXDoMOiw6TOhMKow6fDqcOow6rDq8Kj4oSiw67Dr+KAosK94oCww7TDtsKm4oKsw7nDu8O84oCgzpPOlM6YzpvOns6gw5/CrsKpzqPOqsKn4omgwrDCt86RwrHiiaTiiaXCpc6SzpXOls6XzpnOms6czqbOq86ozqknICtcbiAgICAnzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrBcXHUwMEFEJyxcbiAgICAneC1tYWMtaWNlbGFuZGljJzogIC8vIFB5dGhvbjogJ21hY19pY2VsYW5kJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O8w53CsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKsw5DDsMOew77DvcK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLWludWl0JzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0lOVUlULlRYVFxuICAgICfhkIPhkIThkIXhkIbhkIrhkIvhkLHhkLLhkLPhkLThkLjhkLnhkYnhkY7hkY/hkZDhkZHhkZXhkZbhkabhka3hka7hka/hkbDhkbLhkbPhkoPhkovhkozhko3hko7hkpDhkpHCsOGSoeGSpeGSpuKAosK24ZKnwq7CqeKEouGSqOGSquGSq+GSu+GTguGTg+GThOGTheGTh+GTiOGTkOGTr+GTsOGTseGTsuGTtOGTteGUheGTleGTluGTlycgK1xuICAgICfhk5jhk5rhk5vhk6rhlKjhlKnhlKrhlKvhlK3igKbCoOGUruGUvuGVleGVluGVl+KAk+KAlOKAnOKAneKAmOKAmeGVmOGVmeGVmuGVneGVhuGVh+GViOGVieGVi+GVjOGVkOGVv+GWgOGWgeGWguGWg+GWhOGWheGWj+GWkOGWkeGWkuGWk+GWlOGWleGZseGZsuGZs+GZtOGZteGZtuGWluGWoOGWoeGWouGWo+GWpOGWpeGWpuGVvMWBxYInLFxuICAgICd4LW1hYy1jZSc6ICAvLyBQeXRob246ICdtYWNfbGF0aW4yJ1xuICAgICfDhMSAxIHDicSEw5bDnMOhxIXEjMOkxI3EhsSHw6nFucW6xI7DrcSPxJLEk8SWw7PEl8O0w7bDtcO6xJrEm8O84oCgwrDEmMKjwqfigKLCtsOfwq7CqeKEosSZwqjiiaDEo8SuxK/EquKJpOKJpcSrxLbiiILiiJHFgsS7xLzEvcS+xLnEusWFJyArXG4gICAgJ8WGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4cnLFxuICAgIG1hY2ludG9zaDogIC8vIFB5dGhvbjogJ21hY19yb21hbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1yb21hbmlhbic6ICAvLyBQeXRob246ICdtYWNfcm9tYW5pYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMSCyJjiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcSDyJknICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC6yJrIm+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXR1cmtpc2gnOiAgLy8gUHl0aG9uOiAnbWFjX3R1cmtpc2gnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W4xJ7En8SwxLHFnsWf4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nvoqDLhsucwq/LmMuZy5rCuMudy5vLhydcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBlaXRoZXIgYSBVbmljb2RlIEphdmFTY3JpcHRcbiAqIHN0cmluZywgb3IgJ3VuZGVmaW5lZCcgaWYgdGhlIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLiBGb3IgZXhhbXBsZSwgd2UgZG9cbiAqIG5vdCBzdXBwb3J0IENoaW5lc2UsIEphcGFuZXNlIG9yIEtvcmVhbiBiZWNhdXNlIHRoZXNlIHdvdWxkIG5lZWQgbGFyZ2VcbiAqIG1hcHBpbmcgdGFibGVzLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBkYXRhTGVuZ3RoLCBlbmNvZGluZykge1xuICAgIHZhciB0YWJsZSA9IGVpZ2h0Qml0TWFjRW5jb2RpbmdzW2VuY29kaW5nXTtcbiAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGFibGVbYyAmIDB4N0ZdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZW5jb2RlLk1BQ1NUUklORy4gUmV0dXJucyBhIGRpY3Rpb25hcnkgZm9yIG1hcHBpbmdcbi8vIFVuaWNvZGUgY2hhcmFjdGVyIGNvZGVzIHRvIHRoZWlyIDgtYml0IE1hY09TIGVxdWl2YWxlbnQuIFRoaXMgdGFibGVcbi8vIGlzIG5vdCBleGFjdGx5IGEgc3VwZXIgY2hlYXAgZGF0YSBzdHJ1Y3R1cmUsIGJ1dCB3ZSBkbyBub3QgY2FyZSBiZWNhdXNlXG4vLyBlbmNvZGluZyBNYWNpbnRvc2ggc3RyaW5ncyBpcyBvbmx5IHJhcmVseSBuZWVkZWQgaW4gdHlwaWNhbCBhcHBsaWNhdGlvbnMuXG52YXIgbWFjRW5jb2RpbmdUYWJsZUNhY2hlID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgbmV3IFdlYWtNYXAoKTtcbnZhciBtYWNFbmNvZGluZ0NhY2hlS2V5cztcbnZhciBnZXRNYWNFbmNvZGluZ1RhYmxlID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgLy8gU2luY2Ugd2UgdXNlIGVuY29kaW5nIGFzIGEgY2FjaGUga2V5IGZvciBXZWFrTWFwLCBpdCBoYXMgdG8gYmVcbiAgICAvLyBhIFN0cmluZyBvYmplY3QgYW5kIG5vdCBhIGxpdGVyYWwuIEFuZCBhdCBsZWFzdCBvbiBOb2RlSlMgMi4xMC4xLFxuICAgIC8vIFdlYWtNYXAgcmVxdWlyZXMgdGhhdCB0aGUgc2FtZSBTdHJpbmcgaW5zdGFuY2UgaXMgcGFzc2VkIGZvciBjYWNoZSBoaXRzLlxuICAgIGlmICghbWFjRW5jb2RpbmdDYWNoZUtleXMpIHtcbiAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZSBpbiBlaWdodEJpdE1hY0VuY29kaW5ncykge1xuICAgICAgICAgICAgLypqc2hpbnQgLVcwNTMgKi8gIC8vIFN1cHByZXNzIFwiRG8gbm90IHVzZSBTdHJpbmcgYXMgYSBjb25zdHJ1Y3Rvci5cIlxuICAgICAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXNbZV0gPSBuZXcgU3RyaW5nKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlS2V5ID0gbWFjRW5jb2RpbmdDYWNoZUtleXNbZW5jb2RpbmddO1xuICAgIGlmIChjYWNoZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgZG8gXCJpZiAoY2FjaGUuaGFzKGtleSkpIHtyZXR1cm4gY2FjaGUuZ2V0KGtleSl9XCIgaGVyZTpcbiAgICAvLyBzaW5jZSBnYXJiYWdlIGNvbGxlY3Rpb24gbWF5IHJ1biBhdCBhbnkgdGltZSwgaXQgY291bGQgYWxzbyBraWNrIGluXG4gICAgLy8gYmV0d2VlbiB0aGUgY2FsbHMgdG8gY2FjaGUuaGFzKCkgYW5kIGNhY2hlLmdldCgpLiBJbiB0aGF0IGNhc2UsXG4gICAgLy8gd2Ugd291bGQgcmV0dXJuICd1bmRlZmluZWQnIGV2ZW4gdGhvdWdoIHdlIGRvIHN1cHBvcnQgdGhlIGVuY29kaW5nLlxuICAgIGlmIChtYWNFbmNvZGluZ1RhYmxlQ2FjaGUpIHtcbiAgICAgICAgdmFyIGNhY2hlZFRhYmxlID0gbWFjRW5jb2RpbmdUYWJsZUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmIChjYWNoZWRUYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVGFibGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVjb2RpbmdUYWJsZSA9IGVpZ2h0Qml0TWFjRW5jb2RpbmdzW2VuY29kaW5nXTtcbiAgICBpZiAoZGVjb2RpbmdUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGVuY29kaW5nVGFibGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kaW5nVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5jb2RpbmdUYWJsZVtkZWNvZGluZ1RhYmxlLmNoYXJDb2RlQXQoaSldID0gaSArIDB4ODA7XG4gICAgfVxuXG4gICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuICAgICAgICBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBlbmNvZGluZ1RhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RpbmdUYWJsZTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBhIGJ5dGUgYXJyYXkgdXBvbiBzdWNjZXNzLlxuICogSWYgdGhlIHJlcXVlc3RlZCBlbmNvZGluZyBpcyB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWluc1xuICogYSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkIGluIHRoZSBlbmNvZGluZywgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICd1bmRlZmluZWQnLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG4gICAgdmFyIHRhYmxlID0gZ2V0TWFjRW5jb2RpbmdUYWJsZShlbmNvZGluZyk7XG4gICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPj0gMHg4MCkge1xuICAgICAgICAgICAgYyA9IHRhYmxlW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0ciBjb250YWlucyBhIFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGVuY29kZWRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcmVxdWVzdGVkIGVuY29kaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0gYztcbiAgICAgICAgLy8gcmVzdWx0LnB1c2goYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuICAgIHZhciBiID0gZW5jb2RlLk1BQ1NUUklORyhzdHIsIGVuY29kaW5nKTtcbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDw9IDEyNztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzWmVyb2VzKGRlbHRhcywgcG9zLCByZXN1bHQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gMDtcbiAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDwgbnVtRGVsdGFzICYmIHJ1bkxlbmd0aCA8IDY0ICYmIGRlbHRhc1twb3NdID09PSAwKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goMHg4MCB8IChydW5MZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzQnl0ZXMoZGVsdGFzLCBvZmZzZXQsIHJlc3VsdCkge1xuICAgIHZhciBydW5MZW5ndGggPSAwO1xuICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIHZhciBwb3MgPSBvZmZzZXQ7XG4gICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcbiAgICAgICAgaWYgKCFpc0J5dGVFbmNvZGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdpdGhpbiBhIGJ5dGUtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBhIHNpbmdsZSB6ZXJvIGlzIGJlc3RcbiAgICAgICAgLy8gc3RvcmVkIGxpdGVyYWxseSBhcyAweDAwIHZhbHVlLiBIb3dldmVyLCBpZiB3ZSBoYXZlIHR3byBvclxuICAgICAgICAvLyBtb3JlIHplcm9lcyBpbiBhIHNlcXVlbmNlLCBpdCBpcyBiZXR0ZXIgdG8gc3RhcnQgYSBuZXcgcnVuLlxuICAgICAgICAvLyBGb3JlIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBvZiBkZWx0YXMgWzE1LCAxNSwgMCwgMTUsIDE1XVxuICAgICAgICAvLyBiZWNvbWVzIDYgYnl0ZXMgKDA0IDBGIDBGIDAwIDBGIDBGKSB3aGVuIHN0b3JpbmcgdGhlIHplcm9cbiAgICAgICAgLy8gd2l0aGluIHRoZSBjdXJyZW50IHJ1biwgYnV0IDcgYnl0ZXMgKDAxIDBGIDBGIDgwIDAxIDBGIDBGKVxuICAgICAgICAvLyB3aGVuIHN0YXJ0aW5nIGEgbmV3IHJ1bi5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgZGVsdGFzW3BvcyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocnVuTGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChkZWx0YXNbaV0gKyAyNTYpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgb2Zmc2V0LCByZXN1bHQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gMDtcbiAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG5cbiAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGl0IGlzIGVhc2llc3QgdG8gc3RhcnRcbiAgICAgICAgLy8gYSBuZXcgcnVuICh3aXRoIGEgZGlmZmVyZW50IGVuY29kaW5nKSB3aGVuZXZlciB3ZSBlbmNvdW50ZXJcbiAgICAgICAgLy8gYSB6ZXJvIHZhbHVlLiBGb3IgZXhhbXBsZSwgdGhlIHNlcXVlbmNlIFsweDY2NjYsIDAsIDB4Nzc3N11cbiAgICAgICAgLy8gbmVlZHMgNyBieXRlcyB3aGVuIHN0b3JpbmcgdGhlIHplcm8gaW5zaWRlIHRoZSBjdXJyZW50IHJ1blxuICAgICAgICAvLyAoNDIgNjYgNjYgMDAgMDAgNzcgNzcpLCBhbmQgZXF1YWxseSA3IGJ5dGVzIHdoZW4gc3RhcnRpbmcgYVxuICAgICAgICAvLyBuZXcgcnVuICg0MCA2NiA2NiA4MCA0MCA3NyA3NykuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaXRoaW4gYSB3b3JkLWVuY29kZWQgcnVuIG9mIGRlbHRhcywgYSBzaW5nbGUgdmFsdWUgaW4gdGhlXG4gICAgICAgIC8vIHJhbmdlICgtMTI4Li4xMjcpIHNob3VsZCBiZSBlbmNvZGVkIHdpdGhpbiB0aGUgY3VycmVudCBydW5cbiAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBtb3JlIGNvbXBhY3QuIEZvciBleGFtcGxlLCB0aGUgc2VxdWVuY2VcbiAgICAgICAgLy8gWzB4NjY2NiwgMiwgMHg3Nzc3XSBiZWNvbWVzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB2YWx1ZVxuICAgICAgICAvLyBsaXRlcmFsbHkgKDQyIDY2IDY2IDAwIDAyIDc3IDc3KSwgYnV0IDggYnl0ZXMgd2hlbiBzdGFydGluZ1xuICAgICAgICAvLyBhIG5ldyBydW4gKDQwIDY2IDY2IDAwIDAyIDQwIDc3IDc3KS5cbiAgICAgICAgaWYgKGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkgJiYgcG9zICsgMSA8IG51bURlbHRhcyAmJiBpc0J5dGVFbmNvZGFibGUoZGVsdGFzW3BvcyArIDFdKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK3BvcztcbiAgICAgICAgKytydW5MZW5ndGg7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKDB4NDAgfCAocnVuTGVuZ3RoIC0gMSkpO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBwb3M7ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gZGVsdGFzW2ldO1xuICAgICAgICByZXN1bHQucHVzaCgoKHZhbCArIDB4MTAwMDApID4+IDgpICYgMHhmZiwgKHZhbCArIDB4MTAwKSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuXG4vKipcbiAqIEVuY29kZSBhIGxpc3Qgb2YgdmFyaWF0aW9uIGFkanVzdG1lbnQgZGVsdGFzLlxuICpcbiAqIFZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcyBhcmUgdXNlZCBpbiDigJhndmFy4oCZIGFuZCDigJhjdmFy4oCZIHRhYmxlcy5cbiAqIFRoZXkgaW5kaWNhdGUgaG93IHBvaW50cyAoaW4g4oCYZ3ZhcuKAmSkgb3IgdmFsdWVzIChpbiDigJhjdmFy4oCZKSBnZXQgYWRqdXN0ZWRcbiAqIHdoZW4gZ2VuZXJhdGluZyBpbnN0YW5jZXMgb2YgdmFyaWF0aW9uIGZvbnRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9ndmFyLmh0bVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2Z3Zhci5odG1sXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmVuY29kZS5WQVJERUxUQVMgPSBmdW5jdGlvbihkZWx0YXMpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHBvcyA8IGRlbHRhcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc1plcm9lcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDw9IDEyNykge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc0J5dGVzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiB2YWx1ZXMgdG8gYSBDRkYgSU5ERVggc3RydWN0dXJlLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLklOREVYID0gZnVuY3Rpb24obCkge1xuICAgIC8vdmFyIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgLy8gICAgaSwgdjtcbiAgICAvLyBCZWNhdXNlIHdlIGhhdmUgdG8ga25vdyB3aGljaCBkYXRhIHR5cGUgdG8gdXNlIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyxcbiAgICAvLyB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggdGhlIHZhbHVlcyB0d2ljZTogb25jZSB0byBlbmNvZGUgdGhlIGRhdGEgYW5kXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBvZmZzZXRzLCB0aGVuIGFnYWluIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyB1c2luZyB0aGUgZml0dGluZyBkYXRhIHR5cGUuXG4gICAgdmFyIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICB2YXIgb2Zmc2V0cyA9IFtvZmZzZXRdO1xuICAgIHZhciBkYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIG9mZnNldCArPSB2Lmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgdmFyIG9mZlNpemUgPSAoMSArIE1hdGguZmxvb3IoTWF0aC5sb2cob2Zmc2V0KSAvIE1hdGgubG9nKDIpKSAvIDgpIHwgMDtcbiAgICB2YXIgb2Zmc2V0RW5jb2RlciA9IFt1bmRlZmluZWQsIGVuY29kZS5CWVRFLCBlbmNvZGUuVVNIT1JULCBlbmNvZGUuVUlOVDI0LCBlbmNvZGUuVUxPTkddW29mZlNpemVdO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZW5jb2RlZE9mZnNldCA9IG9mZnNldEVuY29kZXIob2Zmc2V0c1tpJDFdKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KGVuY29kZS5DYXJkMTYobC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLk9mZlNpemUob2ZmU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkT2Zmc2V0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLklOREVYID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuSU5ERVgodikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbiAqIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuICogVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gbVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobSk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBPYmplY3Qua2V5cygpIHJldHVybiBzdHJpbmcga2V5cywgYnV0IG91ciBrZXlzIGFyZSBhbHdheXMgbnVtZXJpYy5cbiAgICAgICAgdmFyIGsgPSBwYXJzZUludChrZXlzW2ldLCAwKTtcbiAgICAgICAgdmFyIHYgPSBtW2tdO1xuICAgICAgICAvLyBWYWx1ZSBjb21lcyBiZWZvcmUgdGhlIGtleS5cbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHYudmFsdWUsIHYudHlwZSkpO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBVE9SKGspKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gZW5jb2RlLkRJQ1QobSkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9QRVJBVE9SID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2IDwgMTIwMCkge1xuICAgICAgICByZXR1cm4gW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTIsIHYgLSAxMjAwXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHZcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT1BFUkFORCA9IGZ1bmN0aW9uKHYsIHR5cGUpIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IHR5cGUubGVuZ3RoLCAnTm90IGVub3VnaCBhcmd1bWVudHMgZ2l2ZW4gZm9yIHR5cGUnICsgdHlwZSk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodltpXSwgdHlwZVtpXSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIC8vIFdlIG1ha2UgaXQgZWFzeSBmb3Igb3Vyc2VsdmVzIGFuZCBhbHdheXMgZW5jb2RlIG9mZnNldHMgYXNcbiAgICAgICAgICAgIC8vIDQgYnl0ZXMuIFRoaXMgbWFrZXMgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciB0aGUgdG9wIGRpY3QgZWFzaWVyLlxuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIzMih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVhbCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuUkVBTCh2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb3BlcmFuZCB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgICAgIC8vIEZJWE1FIEFkZCBzdXBwb3J0IGZvciBib29sZWFuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbnZhciB3bW0gPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIENoYXJTdHJpbmcgb3BlcmF0aW9ucyB0byBieXRlcy5cbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG4gICAgLy8gU2VlIGVuY29kZS5NQUNTVFJJTkcgZm9yIHdoeSB3ZSBkb24ndCBkbyBcImlmICh3bW0gJiYgd21tLmhhcyhvcHMpKVwiLlxuICAgIGlmICh3bW0pIHtcbiAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gd21tLmdldChvcHMpO1xuICAgICAgICBpZiAoY2FjaGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gb3BzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlW29wLnR5cGVdKG9wLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICB3bW0uc2V0KG9wcywgZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuICAgIHJldHVybiBlbmNvZGUuQ0hBUlNUUklORyhvcHMpLmxlbmd0aDtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuT0JKRUNUID0gZnVuY3Rpb24odikge1xuICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZlt2LnR5cGVdO1xuICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIHNpemVPZkZ1bmN0aW9uKHYudmFsdWUpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdGFibGUgb2JqZWN0IHRvIGJ5dGVzLlxuICogQSB0YWJsZSBjb250YWlucyBhIGxpc3Qgb2YgZmllbGRzIGNvbnRhaW5pbmcgdGhlIG1ldGFkYXRhIChuYW1lLCB0eXBlIGFuZCBkZWZhdWx0IHZhbHVlKS5cbiAqIFRoZSB0YWJsZSBpdHNlbGYgaGFzIHRoZSBmaWVsZCB2YWx1ZXMgc2V0IGFzIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG4gICAgdmFyIHN1YnRhYmxlcyA9IFtdO1xuICAgIHZhciBzdWJ0YWJsZU9mZnNldHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBieXRlcyA9IGVuY29kaW5nRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICBzdWJ0YWJsZU9mZnNldHMucHVzaChkLmxlbmd0aCk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoWzAsIDBdKTtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IHN1YnRhYmxlT2Zmc2V0c1tpJDFdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZC5sZW5ndGg7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KG9mZnNldCA8IDY1NTM2LCAnVGFibGUgJyArIHRhYmxlLnRhYmxlTmFtZSArICcgdG9vIGJpZy4nKTtcbiAgICAgICAgZFtvXSA9IG9mZnNldCA+PiA4O1xuICAgICAgICBkW28gKyAxXSA9IG9mZnNldCAmIDB4ZmY7XG4gICAgICAgIGQgPSBkLmNvbmNhdChzdWJ0YWJsZXNbaSQxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIHZhciBudW1CeXRlcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRhYmxlLmZpZWxkc1tpXTtcbiAgICAgICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW2ZpZWxkLnR5cGVdO1xuICAgICAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBudW1CeXRlcyArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3VidGFibGVzIHRha2UgMiBtb3JlIGJ5dGVzIGZvciBvZmZzZXRzLlxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgbnVtQnl0ZXMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1CeXRlcztcbn07XG5cbmVuY29kZS5SRUNPUkQgPSBlbmNvZGUuVEFCTEU7XG5zaXplT2YuUkVDT1JEID0gc2l6ZU9mLlRBQkxFO1xuXG4vLyBNZXJnZSBpbiBhIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTElURVJBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbn07XG5cbnNpemVPZi5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cbi8vIFRhYmxlIG1ldGFkYXRhXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuVGFibGVcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYmxlKHRhYmxlTmFtZSwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgLy8gRm9yIGNvdmVyYWdlIHRhYmxlcyB3aXRoIGNvdmVyYWdlIGZvcm1hdCAyLCB3ZSBkbyBub3Qgd2FudCB0byBhZGQgdGhlIGNvdmVyYWdlIGRhdGEgZGlyZWN0bHkgdG8gdGhlIHRhYmxlIG9iamVjdCxcbiAgICAvLyBhcyB0aGlzIHdpbGwgcmVzdWx0IGluIHdyb25nIGVuY29kaW5nIG9yZGVyIG9mIHRoZSBjb3ZlcmFnZSBkYXRhIG9uIHNlcmlhbGl6YXRpb24gdG8gYnl0ZXMuXG4gICAgLy8gVGhlIGZhbGxiYWNrIG9mIHVzaW5nIHRoZSBmaWVsZCB2YWx1ZXMgZGlyZWN0bHkgd2hlbiBub3QgcHJlc2VudCBvbiB0aGUgdGFibGUgaXMgaGFuZGxlZCBpbiB0eXBlcy5lbmNvZGUuVEFCTEUoKSBhbHJlYWR5LlxuICAgIGlmIChmaWVsZHMubGVuZ3RoICYmIChmaWVsZHNbMF0ubmFtZSAhPT0gJ2NvdmVyYWdlRm9ybWF0JyB8fCBmaWVsZHNbMF0udmFsdWUgPT09IDEpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHRpb25LZXlzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBrID0gb3B0aW9uS2V5c1tpJDFdO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEVuY29kZXMgdGhlIHRhYmxlIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGJ5dGVzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuVGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdGFibGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblRhYmxlLnByb3RvdHlwZS5zaXplT2YgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2l6ZU9mLlRBQkxFKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1c2hvcnRMaXN0KGl0ZW1OYW1lLCBsaXN0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdW50ID0gbGlzdC5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSBuZXcgQXJyYXkobGlzdC5sZW5ndGggKyAxKTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlzdFtpXX07XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGFibGVMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcbiAgICB2YXIgZmllbGRzID0gbmV3IEFycmF5KGNvdW50ICsgMSk7XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZpZWxkc1tpICsgMV0gPSB7bmFtZTogaXRlbU5hbWUgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogaXRlbUNhbGxiYWNrKHJlY29yZHNbaV0sIGkpfTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvcmRMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkcy5jb25jYXQoaXRlbUNhbGxiYWNrKHJlY29yZHNbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLy8gQ29tbW9uIExheW91dCBUYWJsZXNcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Db3ZlcmFnZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBDb3ZlcmFnZShjb3ZlcmFnZVRhYmxlKSB7XG4gICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIFRhYmxlLmNhbGwodGhpcywgJ2NvdmVyYWdlVGFibGUnLFxuICAgICAgICAgICAgW3tuYW1lOiAnY292ZXJhZ2VGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9XVxuICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdnbHlwaCcsIGNvdmVyYWdlVGFibGUuZ2x5cGhzKSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIFRhYmxlLmNhbGwodGhpcywgJ2NvdmVyYWdlVGFibGUnLFxuICAgICAgICAgICAgW3tuYW1lOiAnY292ZXJhZ2VGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9XVxuICAgICAgICAgICAgLmNvbmNhdChyZWNvcmRMaXN0KCdyYW5nZVJlY29yZCcsIGNvdmVyYWdlVGFibGUucmFuZ2VzLCBmdW5jdGlvbihSYW5nZVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnc3RhcnRHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBSYW5nZVJlY29yZC5zdGFydH0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZW5kR2x5cGhJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogUmFuZ2VSZWNvcmQuZW5kfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdzdGFydENvdmVyYWdlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IFJhbmdlUmVjb3JkLmluZGV4fSBdO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuICAgIH1cbn1cbkNvdmVyYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcbkNvdmVyYWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvdmVyYWdlO1xuXG5mdW5jdGlvbiBTY3JpcHRMaXN0KHNjcmlwdExpc3RUYWJsZSkge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ3NjcmlwdExpc3RUYWJsZScsXG4gICAgICAgIHJlY29yZExpc3QoJ3NjcmlwdFJlY29yZCcsIHNjcmlwdExpc3RUYWJsZSwgZnVuY3Rpb24oc2NyaXB0UmVjb3JkLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0UmVjb3JkLnNjcmlwdDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TGFuZ1N5cyA9IHNjcmlwdC5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCghIWRlZmF1bHRMYW5nU3lzLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUI6IHNjcmlwdCAnICsgc2NyaXB0UmVjb3JkLnRhZyArICcgaGFzIG5vIGRlZmF1bHQgbGFuZ3VhZ2Ugc3lzdGVtLicpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdFRhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IHNjcmlwdFJlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnc2NyaXB0JyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ3NjcmlwdFRhYmxlJywgW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2RlZmF1bHRMYW5nU3lzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnZGVmYXVsdExhbmdTeXMnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cE9yZGVyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBkZWZhdWx0TGFuZ1N5cy5yZXFGZWF0dXJlSW5kZXh9XVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBkZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cbiAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQocmVjb3JkTGlzdCgnbGFuZ1N5cycsIHNjcmlwdC5sYW5nU3lzUmVjb3JkcywgZnVuY3Rpb24obGFuZ1N5c1JlY29yZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5c1RhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGxhbmdTeXNSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xhbmdTeXMnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnbGFuZ1N5cycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5TY3JpcHRMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblNjcmlwdExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NyaXB0TGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5GZWF0dXJlTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlTGlzdChmZWF0dXJlTGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnZmVhdHVyZUxpc3RUYWJsZScsXG4gICAgICAgIHJlY29yZExpc3QoJ2ZlYXR1cmVSZWNvcmQnLCBmZWF0dXJlTGlzdFRhYmxlLCBmdW5jdGlvbihmZWF0dXJlUmVjb3JkLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlVGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogZmVhdHVyZVJlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdmZWF0dXJlVGFibGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZVBhcmFtcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZmVhdHVyZS5mZWF0dXJlUGFyYW1zfSBdLmNvbmNhdCh1c2hvcnRMaXN0KCdsb29rdXBMaXN0SW5kZXgnLCBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzKSkpfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICApO1xufVxuRmVhdHVyZUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuRmVhdHVyZUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmVhdHVyZUxpc3Q7XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTG9va3VwTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIExvb2t1cExpc3QobG9va3VwTGlzdFRhYmxlLCBzdWJ0YWJsZU1ha2Vycykge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ2xvb2t1cExpc3RUYWJsZScsIHRhYmxlTGlzdCgnbG9va3VwJywgbG9va3VwTGlzdFRhYmxlLCBmdW5jdGlvbihsb29rdXBUYWJsZSkge1xuICAgICAgICB2YXIgc3VidGFibGVDYWxsYmFjayA9IHN1YnRhYmxlTWFrZXJzW2xvb2t1cFRhYmxlLmxvb2t1cFR5cGVdO1xuICAgICAgICBjaGVjay5hc3NlcnQoISFzdWJ0YWJsZUNhbGxiYWNrLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgKyAnIHRhYmxlcy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZSgnbG9va3VwVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cFR5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cFR5cGV9LFxuICAgICAgICAgICAge25hbWU6ICdsb29rdXBGbGFnJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsb29rdXBUYWJsZS5sb29rdXBGbGFnfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZUxpc3QoJ3N1YnRhYmxlJywgbG9va3VwVGFibGUuc3VidGFibGVzLCBzdWJ0YWJsZUNhbGxiYWNrKSkpO1xuICAgIH0pKTtcbn1cbkxvb2t1cExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuTG9va3VwTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29rdXBMaXN0O1xuXG4vLyBSZWNvcmQgPSBzYW1lIGFzIFRhYmxlLCBidXQgaW5saW5lZCAoYSBUYWJsZSBoYXMgYW4gb2Zmc2V0IGFuZCBpdHMgZGF0YSBpcyBmdXJ0aGVyIGluIHRoZSBzdHJlYW0pXG4vLyBEb24ndCB1c2Ugb2Zmc2V0cyBpbnNpZGUgUmVjb3JkcyAocHJvYmFibGUgYnVnKSwgb25seSBpbiBUYWJsZXMuXG52YXIgdGFibGUgPSB7XG4gICAgVGFibGU6IFRhYmxlLFxuICAgIFJlY29yZDogVGFibGUsXG4gICAgQ292ZXJhZ2U6IENvdmVyYWdlLFxuICAgIFNjcmlwdExpc3Q6IFNjcmlwdExpc3QsXG4gICAgRmVhdHVyZUxpc3Q6IEZlYXR1cmVMaXN0LFxuICAgIExvb2t1cExpc3Q6IExvb2t1cExpc3QsXG4gICAgdXNob3J0TGlzdDogdXNob3J0TGlzdCxcbiAgICB0YWJsZUxpc3Q6IHRhYmxlTGlzdCxcbiAgICByZWNvcmRMaXN0OiByZWNvcmRMaXN0LFxufTtcblxuLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0U2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMzItYml0IGxvbmcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRVTG9uZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0Rml4ZWQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgdmFyIGZyYWN0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIsIGZhbHNlKTtcbiAgICByZXR1cm4gZGVjaW1hbCArIGZyYWN0aW9uIC8gNjU1MzU7XG59XG5cbi8vIFJldHJpZXZlIGEgNC1jaGFyYWN0ZXIgdGFnIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5mdW5jdGlvbiBnZXRUYWcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciB0YWcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG59XG5cbi8vIFJldHJpZXZlIGFuIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIE9mZnNldHMgYXJlIDEgdG8gNCBieXRlcyBpbiBsZW5ndGgsIGRlcGVuZGluZyBvbiB0aGUgb2ZmU2l6ZSBhcmd1bWVudC5cbmZ1bmN0aW9uIGdldE9mZnNldChkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIHYgPDw9IDg7XG4gICAgICAgIHYgKz0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZXMoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5cbi8vIENvbnZlcnQgdGhlIGxpc3Qgb2YgYnl0ZXMgdG8gYSBzdHJpbmcuXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG59XG5cbnZhciB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkOCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUYyRG90MTQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG4vLyArIFNpbmNlIHVudGlsIDIwMzggdGhvc2UgYml0cyB3aWxsIGJlIGZpbGxlZCBieSB6ZXJvcyB3ZSBjYW4gaWdub3JlIHRoZW0uXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuICAgIC8vIFN1YnRyYWN0IHNlY29uZHMgYmV0d2VlbiAwMS8wMS8xOTA0IGFuZCAwMS8wMS8xOTcwXG4gICAgLy8gdG8gY29udmVydCBBcHBsZSBNYWMgdGltZXN0YW1wIHRvIFN0YW5kYXJkIFVuaXggdGltZXN0YW1wXG4gICAgdiAtPSAyMDgyODQ0ODAwO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24obWlub3JCYXNlKSB7XG4gICAgdmFyIG1ham9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gRGVmYXVsdCByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIC8vIFNldCBtaW5vckJhc2UgdG8gMSBmb3IgdGFibGVzIHRoYXQgdXNlIG1pbm9yID0gTiB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICBpZiAobWlub3JCYXNlID09PSB1bmRlZmluZWQpIHsgbWlub3JCYXNlID0gMHgxMDAwOyB9XG4gICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyBtaW5vckJhc2UgLyAxMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHR5cGUsIGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG4vLy8vLyBQYXJzaW5nIGxpc3RzIGFuZCByZWNvcmRzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBsaXN0IG9mIDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDQ7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMTYgYml0IHVuc2lnbmVkIGludGVnZXJzLiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGNhbiBiZSByZWFkIG9uIHRoZSBzdHJlYW1cbi8vIG9yIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIDE2IGJpdCBzaWduZWQgaW50ZWdlcnMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZUxpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCsrKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgaXRlbXMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBpdGVtQ2FsbGJhY2sgaXMgb25lIG9mIHRoZSBQYXJzZXIgbWV0aG9kcy5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiByZWNvcmRzLlxuICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICogRXhhbXBsZSBvZiByZWNvcmREZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cbi8vIFBhcnNlIGEgZGF0YSBzdHJ1Y3R1cmUgaW50byBhbiBvYmplY3Rcbi8vIEV4YW1wbGUgb2YgZGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3QgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBkZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgc3RydWN0W2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgIH1cbn07XG5cbi8qKlxuICogUGFyc2UgYSBHUE9TIHZhbHVlUmVjb3JkXG4gKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcbiAqIHZhbHVlRm9ybWF0IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmQgPSBmdW5jdGlvbih2YWx1ZUZvcm1hdCkge1xuICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWVGb3JtYXQgPT09IDApIHtcbiAgICAgICAgLy8gdmFsdWVGb3JtYXQyIGluIGtlcm5pbmcgcGFpcnMgaXMgbW9zdCBvZnRlbiAwXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgYW4gZW1wdHkgb2JqZWN0LCB0byBzYXZlIHNwYWNlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZhbHVlUmVjb3JkID0ge307XG5cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDEpIHsgdmFsdWVSZWNvcmQueFBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAyKSB7IHZhbHVlUmVjb3JkLnlQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwNCkgeyB2YWx1ZVJlY29yZC54QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA4KSB7IHZhbHVlUmVjb3JkLnlBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuICAgIC8vIERldmljZSB0YWJsZSAobm9uLXZhcmlhYmxlIGZvbnQpIC8gVmFyaWF0aW9uSW5kZXggdGFibGUgKHZhcmlhYmxlIGZvbnQpIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9mci1mci90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjZGV2VmFySWR4VGJsc1xuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAxMCkgeyB2YWx1ZVJlY29yZC54UGxhRGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAyMCkgeyB2YWx1ZVJlY29yZC55UGxhRGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDA0MCkgeyB2YWx1ZVJlY29yZC54QWR2RGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDA4MCkgeyB2YWx1ZVJlY29yZC55QWR2RGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG4gICAgcmV0dXJuIHZhbHVlUmVjb3JkO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgR1BPUyB2YWx1ZVJlY29yZHNcbiAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuICogdmFsdWVGb3JtYXQgYW5kIHZhbHVlQ291bnQgYXJlIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDMyKCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIDE2LWJpdCBpbnRlZ2VycyxcbiAqIG9yIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIG9mZnNldHMgdG8gYW55IGtpbmQgb2YgaXRlbXMuXG4gKiBJZiBpdGVtQ2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkLCBhIGxpc3Qgb2YgbGlzdCBvZiBVU2hvcnQgaXMgYXNzdW1lZC5cbiAqIElmIHByb3ZpZGVkLCBpdGVtQ2FsbGJhY2sgaXMgY2FsbGVkIG9uIGVhY2ggaXRlbSBhbmQgbXVzdCBwYXJzZSB0aGUgaXRlbS5cbiAqIFNlZSBleGFtcGxlcyBpbiB0YWJsZXMvZ3N1Yi5qc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdE9mTGlzdHMgPSBmdW5jdGlvbihpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcbiAgICB2YXIgY291bnQgPSBvZmZzZXRzLmxlbmd0aDtcbiAgICB2YXIgcmVsYXRpdmVPZmZzZXQgPSB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOVUxMIG9mZnNldFxuICAgICAgICAgICAgLy8gQWRkIGkgYXMgb3duZWQgcHJvcGVydHkgdG8gbGlzdC4gQ29udmVuaWVudCB3aXRoIGFzc2VydC5cbiAgICAgICAgICAgIGxpc3RbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdWJPZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgICAgICAgICAgdmFyIHN1Ykxpc3QgPSBuZXcgQXJyYXkoc3ViT2Zmc2V0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJPZmZzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0ICsgc3ViT2Zmc2V0c1tqXTtcbiAgICAgICAgICAgICAgICBzdWJMaXN0W2pdID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0W2ldID0gc3ViTGlzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RbaV0gPSB0aGlzLnBhcnNlVVNob3J0TGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vLy8vIENvbXBsZXggdGFibGVzIHBhcnNpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cbi8vIHBhcnNlci5vZmZzZXQgbXVzdCBwb2ludCB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5pbmcgdGhlIGNvdmVyYWdlLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIGdseXBoczogdGhpcy5wYXJzZVVTaG9ydExpc3QoY291bnQpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmFuZ2VzW2ldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiByYW5nZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDb3ZlcmFnZSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBQYXJzZSBhIENsYXNzIERlZmluaXRpb24gVGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAxLFxuICAgICAgICAgICAgc3RhcnRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDIsXG4gICAgICAgICAgICByYW5nZXM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICBzdGFydDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICAgICAgICAgICBlbmQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgY2xhc3NJZDogUGFyc2VyLnVTaG9ydFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDbGFzc0RlZiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLy8vLyBTdGF0aWMgbWV0aG9kcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhlc2UgY29udmVuaWVuY2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBhcyBjYWxsYmFja3MgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBcInRoaXNcIiBjb250ZXh0IHNldCB0byBhIFBhcnNlciBpbnN0YW5jZS5cblxuUGFyc2VyLmxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoY291bnQsIGl0ZW1DYWxsYmFjayk7XG4gICAgfTtcbn07XG5cblBhcnNlci5saXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QzMihjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdChjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QzMihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcjMyKGRlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnRhZyA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VUYWc7XG5QYXJzZXIuYnl0ZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuUGFyc2VyLnVTaG9ydCA9IFBhcnNlci5vZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIudVNob3J0TGlzdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0O1xuUGFyc2VyLnVMb25nID0gUGFyc2VyLm9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuUGFyc2VyLnVMb25nTGlzdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3Q7XG5QYXJzZXIuc3RydWN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdDtcblBhcnNlci5jb3ZlcmFnZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZTtcblBhcnNlci5jbGFzc0RlZiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZjtcblxuLy8vLy8gU2NyaXB0LCBGZWF0dXJlLCBMb29rdXAgbGlzdHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cbnZhciBsYW5nU3lzVGFibGUgPSB7XG4gICAgcmVzZXJ2ZWQ6IFBhcnNlci51U2hvcnQsXG4gICAgcmVxRmVhdHVyZUluZGV4OiBQYXJzZXIudVNob3J0LFxuICAgIGZlYXR1cmVJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIHNjcmlwdDogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSksXG4gICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgICAgICAgICBsYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0pKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgZmVhdHVyZTogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZmVhdHVyZVBhcmFtczogUGFyc2VyLm9mZnNldDE2LFxuICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG4gICAgICAgIH0pXG4gICAgfSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvb2t1cExpc3QgPSBmdW5jdGlvbihsb29rdXBUYWJsZVBhcnNlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmxpc3QoUGFyc2VyLnBvaW50ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudCgxIDw9IGxvb2t1cFR5cGUgJiYgbG9va3VwVHlwZSA8PSA5LCAnR1BPUy9HU1VCIGxvb2t1cCB0eXBlICcgKyBsb29rdXBUeXBlICsgJyB1bmtub3duLicpO1xuICAgICAgICB2YXIgbG9va3VwRmxhZyA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHVzZU1hcmtGaWx0ZXJpbmdTZXQgPSBsb29rdXBGbGFnICYgMHgxMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG4gICAgICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICAgICAgc3VidGFibGVzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihsb29rdXBUYWJsZVBhcnNlcnNbbG9va3VwVHlwZV0pKSxcbiAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVzZU1hcmtGaWx0ZXJpbmdTZXQgPyB0aGlzLnBhcnNlVVNob3J0KCkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9KSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcjMyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFqb3JWZXJzaW9uID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbWlub3JWZXJzaW9uID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudChtYWpvclZlcnNpb24gPT09IDEgJiYgbWlub3JWZXJzaW9uIDwgMSwgJ0dQT1MvR1NVQiBmZWF0dXJlIHZhcmlhdGlvbnMgdGFibGUgdW5rbm93bi4nKTtcbiAgICAgICAgdmFyIGZlYXR1cmVWYXJpYXRpb25zID0gdGhpcy5wYXJzZVJlY29yZExpc3QzMih7XG4gICAgICAgICAgICBjb25kaXRpb25TZXRPZmZzZXQ6IFBhcnNlci5vZmZzZXQzMixcbiAgICAgICAgICAgIGZlYXR1cmVUYWJsZVN1YnN0aXR1dGlvbk9mZnNldDogUGFyc2VyLm9mZnNldDMyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZVZhcmlhdGlvbnM7XG4gICAgfSkgfHwgW107XG59O1xuXG52YXIgcGFyc2UgPSB7XG4gICAgZ2V0Qnl0ZTogZ2V0Qnl0ZSxcbiAgICBnZXRDYXJkODogZ2V0Qnl0ZSxcbiAgICBnZXRVU2hvcnQ6IGdldFVTaG9ydCxcbiAgICBnZXRDYXJkMTY6IGdldFVTaG9ydCxcbiAgICBnZXRTaG9ydDogZ2V0U2hvcnQsXG4gICAgZ2V0VUxvbmc6IGdldFVMb25nLFxuICAgIGdldEZpeGVkOiBnZXRGaXhlZCxcbiAgICBnZXRUYWc6IGdldFRhZyxcbiAgICBnZXRPZmZzZXQ6IGdldE9mZnNldCxcbiAgICBnZXRCeXRlczogZ2V0Qnl0ZXMsXG4gICAgYnl0ZXNUb1N0cmluZzogYnl0ZXNUb1N0cmluZyxcbiAgICBQYXJzZXI6IFBhcnNlcixcbn07XG5cbi8vIFRoZSBgY21hcGAgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApIHtcbiAgICAvL1NraXAgcmVzZXJ2ZWQuXG4gICAgcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIGdyb3VwQ291bnQ7XG4gICAgY21hcC5ncm91cENvdW50ID0gZ3JvdXBDb3VudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIGVuZENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBzdGFydEdseXBoSWQgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDaGFyQ29kZTsgYyA8PSBlbmRDaGFyQ29kZTsgYyArPSAxKSB7XG4gICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBzdGFydEdseXBoSWQ7XG4gICAgICAgICAgICBzdGFydEdseXBoSWQrKztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIC8vIHNlZ0NvdW50IGlzIHN0b3JlZCB4IDIuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIGNtYXAuc2VnQ291bnQgPSBzZWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKSA+PiAxO1xuXG4gICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuXG4gICAgLy8gVGhlIFwidW5yb2xsZWRcIiBtYXBwaW5nIGZyb20gY2hhcmFjdGVyIGNvZGVzIHRvIGdseXBoIGluZGljZXMuXG4gICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG4gICAgdmFyIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICB2YXIgc3RhcnRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMik7XG4gICAgdmFyIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDQpO1xuICAgIHZhciBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2KTtcbiAgICB2YXIgZ2x5cGhJbmRleE9mZnNldCA9IHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdDb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3RhcnRDb3VudCA9IHN0YXJ0Q291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkRGVsdGEgPSBpZERlbHRhUGFyc2VyLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENvdW50OyBjIDw9IGVuZENvdW50OyBjICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpZFJhbmdlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlkUmFuZ2VPZmZzZXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgY3VycmVudCBvZmZzZXQgaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCA9IChpZFJhbmdlT2Zmc2V0UGFyc2VyLm9mZnNldCArIGlkUmFuZ2VPZmZzZXRQYXJzZXIucmVsYXRpdmVPZmZzZXQgLSAyKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2VnbWVudCwgbXVsdGlwbGllZCBieSAyIGZvciBVU0hPUlRzLlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhGRkZGO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBnbHlwaEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0IGFuZCAxMi5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGBDbWFwRW5jb2RpbmdgIG9iamVjdCBvciBudWxsIGlmIG5vIHN1cHBvcnRlZCBmb3JtYXQgY291bGQgYmUgZm91bmQuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBjbWFwID0ge307XG4gICAgY21hcC52ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudChjbWFwLnZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cbiAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuICAgIC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBhIFwicGxhdGZvcm0gMFwiIChVbmljb2RlIGZvcm1hdCkgYW5kIFwicGxhdGZvcm0gM1wiIChXaW5kb3dzIGZvcm1hdCkgdGFibGUuXG4gICAgY21hcC5udW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IGNtYXAubnVtVGFibGVzIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyAyKTtcbiAgICAgICAgaWYgKChwbGF0Zm9ybUlkID09PSAzICYmIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMTApKSB8fFxuICAgICAgICAgICAgKHBsYXRmb3JtSWQgPT09IDAgJiYgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAyIHx8IGVuY29kaW5nSWQgPT09IDMgfHwgZW5jb2RpbmdJZCA9PT0gNCkpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNtYXAgc3ViLXRhYmxlcyBmb3VuZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuICAgIGNtYXAuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKGNtYXAuZm9ybWF0ID09PSAxMikge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApO1xuICAgIH0gZWxzZSBpZiAoY21hcC5mb3JtYXQgPT09IDQpIHtcbiAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBmb3JtYXQgNCBhbmQgMTIgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZCAoZm91bmQgZm9ybWF0ICcgKyBjbWFwLmZvcm1hdCArICcpLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjbWFwO1xufVxuXG5mdW5jdGlvbiBhZGRTZWdtZW50KHQsIGNvZGUsIGdseXBoSW5kZXgpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IGNvZGUsXG4gICAgICAgIHN0YXJ0OiBjb2RlLFxuICAgICAgICBkZWx0YTogLShjb2RlIC0gZ2x5cGhJbmRleCksXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgZ2x5cGhJbmRleDogZ2x5cGhJbmRleFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KSB7XG4gICAgdC5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgZW5kOiAweEZGRkYsXG4gICAgICAgIHN0YXJ0OiAweEZGRkYsXG4gICAgICAgIGRlbHRhOiAxLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbn1cblxuLy8gTWFrZSBjbWFwIHRhYmxlLCBmb3JtYXQgNCBieSBkZWZhdWx0LCAxMiBpZiBuZWVkZWQgb25seVxuZnVuY3Rpb24gbWFrZUNtYXBUYWJsZShnbHlwaHMpIHtcbiAgICAvLyBQbGFuIDAgaXMgdGhlIGJhc2UgVW5pY29kZSBQbGFuIGJ1dCBlbW9qaXMsIGZvciBleGFtcGxlIGFyZSBvbiBhbm90aGVyIHBsYW4sIGFuZCBuZWVkcyBjbWFwIDEyIGZvcm1hdCAod2l0aCAzMmJpdClcbiAgICB2YXIgaXNQbGFuME9ubHkgPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgY21hcCBmb3JtYXQgMTIgb3IgaWYgZm9ybWF0IDQgb25seSBpcyBmaW5lXG4gICAgZm9yIChpID0gZ2x5cGhzLmxlbmd0aCAtIDE7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIGcgPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBpZiAoZy51bmljb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgQ01BUCBmb3JtYXQgMTIgKG5lZWRlZCEpJyk7XG4gICAgICAgICAgICBpc1BsYW4wT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY21hcFRhYmxlID0gW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogaXNQbGFuME9ubHkgPyAxIDogMn0sXG5cbiAgICAgICAgLy8gQ01BUCA0IGhlYWRlclxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBpc1BsYW4wT25seSA/IDEyIDogKDEyICsgOCl9XG4gICAgXTtcblxuICAgIGlmICghaXNQbGFuME9ubHkpXG4gICAgICAgIHsgY21hcFRhYmxlID0gY21hcFRhYmxlLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBDTUFQIDEyIGhlYWRlclxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJQbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAzfSwgLy8gV2UgZW5jb2RlIG9ubHkgZm9yIFBsYXRmb3JtSUQgPSAzIChXaW5kb3dzKSBiZWNhdXNlIGl0IGlzIHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkVuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyT2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9XG4gICAgICAgIF0pOyB9XG5cbiAgICBjbWFwVGFibGUgPSBjbWFwVGFibGUuY29uY2F0KFtcbiAgICAgICAgLy8gQ01BUCA0IFN1YnRhYmxlXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdjbWFwNExlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlZ0NvdW50WDInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuXG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ2NtYXAnLCBjbWFwVGFibGUpO1xuXG4gICAgdC5zZWdtZW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWRkU2VnbWVudCh0LCBnbHlwaC51bmljb2Rlc1tqXSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICB0LnNlZ21lbnRzID0gdC5zZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdmFyIHNlZ0NvdW50VG9SZW1vdmUgPSAwO1xuXG4gICAgLy8gQ01BUCA0XG4gICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXTtcbiAgICB2YXIgc3RhcnRDb3VudHMgPSBbXTtcbiAgICB2YXIgaWREZWx0YXMgPSBbXTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldHMgPSBbXTtcbiAgICB2YXIgZ2x5cGhJZHMgPSBbXTtcblxuICAgIC8vIENNQVAgMTJcbiAgICB2YXIgY21hcDEyR3JvdXBzID0gW107XG5cbiAgICAvLyBSZW1pbmRlciB0aGlzIGxvb3AgaXMgbm90IGZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbiBhdCAxMDAlXG4gICAgLy8gVGhlIHNwZWNpZmljYXRpb24gLT4gZmluZCBzdWl0ZXMgb2YgY2hhcmFjdGVycyBhbmQgbWFrZSBhIGdyb3VwXG4gICAgLy8gSGVyZSB3ZSdyZSBkb2luZyBvbmUgZ3JvdXAgZm9yIGVhY2ggbGV0dGVyXG4gICAgLy8gRG9pbmcgYXMgdGhlIHNwZWMgY2FuIHNhdmUgOCB0aW1lcyAob3IgbW9yZSkgc3BhY2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHQuc2VnbWVudHNbaV07XG5cbiAgICAgICAgLy8gQ01BUCA0XG4gICAgICAgIGlmIChzZWdtZW50LmVuZCA8PSA2NTUzNSAmJiBzZWdtZW50LnN0YXJ0IDw9IDY1NTM1KSB7XG4gICAgICAgICAgICBlbmRDb3VudHMgPSBlbmRDb3VudHMuY29uY2F0KHtuYW1lOiAnZW5kXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG4gICAgICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgICAgIGlkRGVsdGFzID0gaWREZWx0YXMuY29uY2F0KHtuYW1lOiAnaWREZWx0YV8nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IHNlZ21lbnQuZGVsdGF9KTtcbiAgICAgICAgICAgIGlkUmFuZ2VPZmZzZXRzID0gaWRSYW5nZU9mZnNldHMuY29uY2F0KHtuYW1lOiAnaWRSYW5nZU9mZnNldF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50Lm9mZnNldH0pO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJZHMgPSBnbHlwaElkcy5jb25jYXQoe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmdseXBoSWR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNraXAgVW5pY29kZSA+IDY1NTM1ICgxNmJpdCB1bnNpZ25lZCBtYXgpIGZvciBDTUFQIDQsIHdpbGwgYmUgYWRkZWQgaW4gQ01BUCAxMlxuICAgICAgICAgICAgc2VnQ291bnRUb1JlbW92ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ01BUCAxMlxuICAgICAgICAvLyBTa2lwIFRlcm1pbmF0b3IgU2VnbWVudFxuICAgICAgICBpZiAoIWlzUGxhbjBPbmx5ICYmIHNlZ21lbnQuZ2x5cGhJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyU3RhcnRfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LnN0YXJ0fSk7XG4gICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyRW5kXycgKyBpLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc2VnbWVudC5lbmR9KTtcbiAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJHbHlwaF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJbmRleH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ01BUCA0IFN1YnRhYmxlXG4gICAgdC5zZWdDb3VudFgyID0gKHNlZ0NvdW50IC0gc2VnQ291bnRUb1JlbW92ZSkgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKChzZWdDb3VudCAtIHNlZ0NvdW50VG9SZW1vdmUpKSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChlbmRDb3VudHMpO1xuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZXNlcnZlZFBhZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0pO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KHN0YXJ0Q291bnRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZERlbHRhcyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWRSYW5nZU9mZnNldHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGdseXBoSWRzKTtcblxuICAgIHQuY21hcDRMZW5ndGggPSAxNCArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuICAgICAgICBzdGFydENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBnbHlwaElkcy5sZW5ndGggKiAyO1xuXG4gICAgaWYgKCFpc1BsYW4wT25seSkge1xuICAgICAgICAvLyBDTUFQIDEyIFN1YnRhYmxlXG4gICAgICAgIHZhciBjbWFwMTJMZW5ndGggPSAxNiArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICAgICAgY21hcDEyR3JvdXBzLmxlbmd0aCAqIDQ7XG5cbiAgICAgICAgdC5jbWFwMTJPZmZzZXQgPSAxMiArICgyICogMikgKyA0ICsgdC5jbWFwNExlbmd0aDtcbiAgICAgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoW1xuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEyfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyUmVzZXJ2ZWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJMZW5ndGgnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY21hcDEyTGVuZ3RofSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyTGFuZ3VhZ2UnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMm5Hcm91cHMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY21hcDEyR3JvdXBzLmxlbmd0aCAvIDN9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGNtYXAxMkdyb3Vwcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBjbWFwID0geyBwYXJzZTogcGFyc2VDbWFwVGFibGUsIG1ha2U6IG1ha2VDbWFwVGFibGUgfTtcblxuLy8gR2x5cGggZW5jb2RpbmdcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJycsICdwYXJhZ3JhcGgnLCAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG4gICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnQUUnLCAnJywgJ29yZGZlbWluaW5lJywgJycsICcnLCAnJyxcbiAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG4gICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICd0d29kb3RlbmxlYWRlcicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuICAgICdzZW1pY29sb24nLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJywgJ3F1ZXN0aW9uc21hbGwnLCAnJywgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICcnLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsICcnLCAnRG90YWNjZW50c21hbGwnLCAnJywgJycsICdNYWNyb25zbWFsbCcsICcnLCAnJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcbiAgICAnJywgJ3plcm9zdXBlcmlvcicsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJywgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLCAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxudmFyIHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbiAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4gKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5EZWZhdWx0RW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBjb2RlID0gYy5jb2RlUG9pbnRBdCgwKTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcbiAgICBpZiAoZ2x5cGhzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNtYXBFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbWFwIC0gYSBvYmplY3Qgd2l0aCB0aGUgY21hcCBlbmNvZGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gQ21hcEVuY29kaW5nKGNtYXApIHtcbiAgICB0aGlzLmNtYXAgPSBjbWFwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gYyAtIHRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdseXBoIGluZGV4LlxuICovXG5DbWFwRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY29kZVBvaW50QXQoMCldIHx8IDA7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNmZkVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIC0gVGhlIGVuY29kaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFyc2V0IC0gVGhlIGNoYXJhY3RlciBzZXQuXG4gKi9cbmZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBzIC0gVGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXguXG4gKi9cbkNmZkVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBjb2RlID0gcy5jb2RlUG9pbnRBdCgwKTtcbiAgICB2YXIgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuICAgIHJldHVybiB0aGlzLmNoYXJzZXQuaW5kZXhPZihjaGFyTmFtZSk7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoTmFtZXNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zdFxuICovXG5mdW5jdGlvbiBHbHlwaE5hbWVzKHBvc3QpIHtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3N0LmdseXBoTmFtZUluZGV4W2ldIDwgc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IHN0YW5kYXJkTmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IHBvc3QubmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXSAtIHN0YW5kYXJkTmFtZXMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDErKykge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaSQxXSA9IHN0YW5kYXJkTmFtZXNbaSQxICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIGEgZ2x5cGggYnkgbmFtZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAtIFRoZSBnbHlwaCBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleFxuICovXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzLmluZGV4T2YobmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gZ2lkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkdseXBoTmFtZXMucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xufTtcblxuZnVuY3Rpb24gYWRkR2x5cGhOYW1lc0FsbChmb250KSB7XG4gICAgdmFyIGdseXBoO1xuICAgIHZhciBnbHlwaEluZGV4TWFwID0gZm9udC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwO1xuICAgIHZhciBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGdseXBoSW5kZXhNYXBbY107XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBmb250LmdseXBocy5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGkkMSk7XG4gICAgICAgIGlmIChmb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gJ2dpZCcgKyBpJDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmNmZkVuY29kaW5nLmNoYXJzZXRbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb250LmdseXBoTmFtZXMubmFtZXMpIHtcbiAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShpJDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzVG9Vbmljb2RlTWFwKGZvbnQpIHtcbiAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcCA9IHt9O1xuXG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgaWYgKGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHVuaWNvZGVzOiBbcGFyc2VJbnQoYyldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0udW5pY29kZXMucHVzaChwYXJzZUludChjKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmFkZEdseXBoTmFtZXNcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkR2x5cGhOYW1lc0FsbChmb250KTtcbiAgICB9XG59XG5cbi8vIERyYXdpbmcgdXRpbGl0eSBmdW5jdGlvbnMuXG5cbi8vIERyYXcgYSBsaW5lIG9uIHRoZSBnaXZlbiBjb250ZXh0IGZyb20gcG9pbnQgYHgxLHkxYCB0byBwb2ludCBgeDIseTJgLlxuZnVuY3Rpb24gbGluZShjdHgsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuXG52YXIgZHJhdyA9IHsgbGluZTogbGluZSB9O1xuXG4vLyBUaGUgR2x5cGggb2JqZWN0XG4vLyBpbXBvcnQgZ2x5ZiBmcm9tICcuL3RhYmxlcy9nbHlmJyBDYW4ndCBiZSBpbXBvcnRlZCBoZXJlLCBiZWNhdXNlIGl0J3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cbmZ1bmN0aW9uIGdldFBhdGhEZWZpbml0aW9uKGdseXBoLCBwYXRoKSB7XG4gICAgdmFyIF9wYXRoID0gcGF0aCB8fCBuZXcgUGF0aCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF9wYXRoID0gX3BhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgZ2x5cGggbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt1bmljb2RlXVxuICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlV2lkdGhdXG4gKi9cblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcbiAgICAvLyBCeSBwdXR0aW5nIGFsbCB0aGUgY29kZSBvbiBhIHByb3RvdHlwZSBmdW5jdGlvbiAod2hpY2ggaXMgb25seSBkZWNsYXJlZCBvbmNlKVxuICAgIC8vIHdlIHJlZHVjZSB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgbGFyZ2VyIGZvbnRzIGJ5IHNvbWUgMiVcbiAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5iaW5kQ29uc3RydWN0b3JWYWx1ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuICAgIC8vIFRoZXNlIHRocmVlIHZhbHVlcyBjYW5ub3QgYmUgZGVmZXJyZWQgZm9yIG1lbW9yeSBvcHRpbWl6YXRpb246XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID0gb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZCA/IFtvcHRpb25zLnVuaWNvZGVdIDogW107XG5cbiAgICAvLyBCdXQgYnkgYmluZGluZyB0aGVzZSB2YWx1ZXMgb25seSB3aGVuIG5lY2Vzc2FyeSwgd2UgcmVkdWNlIGNhblxuICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuICAgIGlmICgneE1pbicgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnhNaW4gPSBvcHRpb25zLnhNaW47XG4gICAgfVxuXG4gICAgaWYgKCd5TWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueU1pbiA9IG9wdGlvbnMueU1pbjtcbiAgICB9XG5cbiAgICBpZiAoJ3hNYXgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4O1xuICAgIH1cblxuICAgIGlmICgneU1heCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnlNYXggPSBvcHRpb25zLnlNYXg7XG4gICAgfVxuXG4gICAgaWYgKCdhZHZhbmNlV2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aCBmb3IgYSBnbHlwaCBpcyB0aGUgbW9zdCBtZW1vcnkgaW50ZW5zaXZlLCBhbmQgaXMgYm91bmQgYXMgYSB2YWx1ZVxuICAgIC8vIHdpdGggYSBnZXR0ZXIvc2V0dGVyIHRvIGVuc3VyZSB3ZSBhY3R1YWxseSBkbyBwYXRoIHBhcnNpbmcgb25seSBvbmNlIHRoZVxuICAgIC8vIHBhdGggaXMgYWN0dWFsbHkgbmVlZGVkIGJ5IGFueXRoaW5nLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIGdldFBhdGhEZWZpbml0aW9uKHRoaXMsIG9wdGlvbnMucGF0aCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmFkZFVuaWNvZGUgPSBmdW5jdGlvbih1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuXG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciB0aGlzIGdseXBoLlxuICogQHJldHVybiB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguZ2V0Qm91bmRpbmdCb3goKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBpZiBoaW50aW5nIGlzIHRvIGJlIHVzZWQsIHRoZSBmb250XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmb250KSB7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgaFBvaW50cztcbiAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHsgfTsgfVxuICAgIHZhciB4U2NhbGUgPSBvcHRpb25zLnhTY2FsZTtcbiAgICB2YXIgeVNjYWxlID0gb3B0aW9ucy55U2NhbGU7XG5cbiAgICBpZiAob3B0aW9ucy5oaW50aW5nICYmIGZvbnQgJiYgZm9udC5oaW50aW5nKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgaGludGluZywgdGhlIGhpbnRpbmcgZW5naW5lIHRha2VzIGNhcmVcbiAgICAgICAgLy8gb2Ygc2NhbGluZyB0aGUgcG9pbnRzIChub3QgdGhlIHBhdGgpIGJlZm9yZSBoaW50aW5nLlxuICAgICAgICBoUG9pbnRzID0gdGhpcy5wYXRoICYmIGZvbnQuaGludGluZy5leGVjKHRoaXMsIGZvbnRTaXplKTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgaGludGluZyBlbmdpbmUgZmFpbGVkIGhQb2ludHMgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFuZCB0aHVzIHJldmVydHMgdG8gcGxhaW4gcmVuZGluZ1xuICAgIH1cblxuICAgIGlmIChoUG9pbnRzKSB7XG4gICAgICAgIC8vIENhbGwgZm9udC5oaW50aW5nLmdldENvbW1hbmRzIGluc3RlYWQgb2YgYGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kc2AgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgIGNvbW1hbmRzID0gZm9udC5oaW50aW5nLmdldENvbW1hbmRzKGhQb2ludHMpO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIC8vIFRPRE8gaW4gY2FzZSBvZiBoaW50aW5nIHh5U2NhbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICB4U2NhbGUgPSB5U2NhbGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKHRoaXMucGF0aC51bml0c1BlckVtIHx8IDEwMDApICogZm9udFNpemU7XG4gICAgICAgIGlmICh4U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB4U2NhbGUgPSBzY2FsZTsgfVxuICAgICAgICBpZiAoeVNjYWxlID09PSB1bmRlZmluZWQpIHsgeVNjYWxlID0gc2NhbGU7IH1cbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyh4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBwLmxpbmVUbyh4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oeCArIChjbWQueDEgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTEgKiB5U2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHAuY3VydmVUbyh4ICsgKGNtZC54MSAqIHhTY2FsZSksIHkgKyAoLWNtZC55MSAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueDIgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTIgKiB5U2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIGdseXBoIGludG8gY29udG91cnMuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgdG9cbiAqIHByb3ZpZGUgcmF3IGFjY2VzcyB0byB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZXMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldENvbnRvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgeE1pbi95TWluL3hNYXgveU1heC9sc2IvcnNiIGZvciBhIEdseXBoLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICB2YXIgeENvb3JkcyA9IFtdO1xuICAgIHZhciB5Q29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSAhPT0gJ1onKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnIHx8IGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDEpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55MSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54Mik7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiB0aGlzLmxlZnRTaWRlQmVhcmluZ1xuICAgIH07XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcbiAgICAgICAgbWV0cmljcy54TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcbiAgICAgICAgbWV0cmljcy54TWF4ID0gdGhpcy5hZHZhbmNlV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG4gICAgICAgIG1ldHJpY3MueU1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG4gICAgICAgIG1ldHJpY3MueU1heCA9IDA7XG4gICAgfVxuXG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBnbHlwaCBvbiB0aGUgZ2l2ZW4gY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwb2ludHMgb2YgdGhlIGdseXBoLlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgdmFyIHNjYWxlID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICB2YXIgYmx1ZUNpcmNsZXMgPSBbXTtcbiAgICB2YXIgcmVkQ2lyY2xlcyA9IFtdO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsdWVDaXJjbGVzLnB1c2goe3g6IGNtZC54LCB5OiAtY21kLnl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQueDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDEsIHk6IC1jbWQueTF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQueDIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDIsIHk6IC1jbWQueTJ9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5maWxsU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhd0NpcmNsZXMoYmx1ZUNpcmNsZXMsIHgsIHksIHNjYWxlKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgZHJhd0NpcmNsZXMocmVkQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xufTtcblxuLyoqXG4gKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzLlxuICogQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4gKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4gKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICovXG5HbHlwaC5wcm90b3R5cGUuZHJhd01ldHJpY3MgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgLy8gRHJhdyB0aGUgb3JpZ2luXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4LCAtMTAwMDAsIHgsIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHksIDEwMDAwLCB5KTtcblxuICAgIC8vIFRoaXMgY29kZSBpcyBoZXJlIGR1ZSB0byBtZW1vcnkgb3B0aW1pemF0aW9uOiBieSBub3QgdXNpbmdcbiAgICAvLyBkZWZhdWx0cyBpbiB0aGUgY29uc3RydWN0b3IsIHdlIHNhdmUgYSBub3RhYmxlIGFtb3VudCBvZiBtZW1vcnkuXG4gICAgdmFyIHhNaW4gPSB0aGlzLnhNaW4gfHwgMDtcbiAgICB2YXIgeU1pbiA9IHRoaXMueU1pbiB8fCAwO1xuICAgIHZhciB4TWF4ID0gdGhpcy54TWF4IHx8IDA7XG4gICAgdmFyIHlNYXggPSB0aGlzLnlNYXggfHwgMDtcbiAgICB2YXIgYWR2YW5jZVdpZHRoID0gdGhpcy5hZHZhbmNlV2lkdGggfHwgMDtcblxuICAgIC8vIERyYXcgdGhlIGdseXBoIGJveFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh4TWluICogc2NhbGUpLCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWF4ICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1heCAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgteU1pbiAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSkpO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgteU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSkpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWR2YW5jZSB3aWR0aFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIC0xMDAwMCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIDEwMDAwKTtcbn07XG5cbi8vIFRoZSBHbHlwaFNldCBvYmplY3RcblxuLy8gRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIGdseXBoIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGF0aCBiZWluZyBsb2FkZWQuXG5mdW5jdGlvbiBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcGF0aCBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhlIHBhdGggaXMgbG9hZGVkLlxuICAgICAgICAgICAgZ2x5cGgucGF0aDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhbaW50ZXJuYWxOYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZ2x5cGhbaW50ZXJuYWxOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBIEdseXBoU2V0IHJlcHJlc2VudHMgYWxsIGdseXBocyBhdmFpbGFibGUgaW4gdGhlIGZvbnQsIGJ1dCBtb2RlbGxlZCB1c2luZ1xuICogYSBkZWZlcnJlZCBnbHlwaCBsb2FkZXIsIGZvciByZXRyaWV2aW5nIGdseXBocyBvbmx5IG9uY2UgdGhleSBhcmUgYWJzb2x1dGVseVxuICogbmVjZXNzYXJ5LCB0byBrZWVwIHRoZSBtZW1vcnkgZm9vdHByaW50IGRvd24uXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFNldFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAcGFyYW0ge0FycmF5fVxuICovXG5mdW5jdGlvbiBHbHlwaFNldChmb250LCBnbHlwaHMpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMuZ2x5cGhzID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2x5cGhzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICAgZ2x5cGgucGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgdGhpcy5nbHlwaHNbaV0gPSBnbHlwaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gKGdseXBocyAmJiBnbHlwaHMubGVuZ3RoKSB8fCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAvLyB0aGlzLmdseXBoc1tpbmRleF0gaXMgJ3VuZGVmaW5lZCcgd2hlbiBsb3cgbWVtb3J5IG1vZGUgaXMgb24uIGdseXBoIGlzIHB1c2hlZCBvbiByZXF1ZXN0IG9ubHkuXG4gICAgaWYgKHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9udC5fcHVzaChpbmRleCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2luZGV4XTtcbiAgICAgICAgdmFyIHVuaWNvZGVPYmogPSB0aGlzLmZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2luZGV4XTtcblxuICAgICAgICBpZiAodW5pY29kZU9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bmljb2RlT2JqLnVuaWNvZGVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHsgZ2x5cGguYWRkVW5pY29kZSh1bmljb2RlT2JqLnVuaWNvZGVzW2pdKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZm9udC5jZmZFbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gJ2dpZCcgKyBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IHRoaXMuZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnQuZ2x5cGhOYW1lcy5uYW1lcykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IHRoaXMuZm9udC5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdLmFkdmFuY2VXaWR0aCA9IHRoaXMuZm9udC5faG10eFRhYmxlRGF0YVtpbmRleF0uYWR2YW5jZVdpZHRoO1xuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0ubGVmdFNpZGVCZWFyaW5nID0gdGhpcy5mb250Ll9obXR4VGFibGVEYXRhW2luZGV4XS5sZWZ0U2lkZUJlYXJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhzW2luZGV4XTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7T2JqZWN0fVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGluZGV4LCBsb2FkZXIpIHtcbiAgICB0aGlzLmdseXBoc1tpbmRleF0gPSBsb2FkZXI7XG4gICAgdGhpcy5sZW5ndGgrKztcbn07XG5cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gZ2x5cGhMb2FkZXIoZm9udCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0dWIgZ2x5cGggdGhhdCBjYW4gYmUgZmlsbGVkIHdpdGggYWxsIG1ldGFkYXRhICpleGNlcHQqXG4gKiB0aGUgXCJwb2ludHNcIiBhbmQgXCJwYXRoXCIgcHJvcGVydGllcywgd2hpY2ggbXVzdCBiZSBsb2FkZWQgb25seSBvbmNlXG4gKiB0aGUgZ2x5cGgncyBwYXRoIGlzIGFjdHVhbGx5IHJlcXVlc3RlZCBmb3IgdGV4dCBzaGFwaW5nLlxuICogQGFsaWFzIG9wZW50eXBlLnR0ZkdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGFyc2VHbHlwaFxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYnVpbGRQYXRoXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gdHRmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlR2x5cGgsIGRhdGEsIHBvc2l0aW9uLCBidWlsZFBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1pbicsICdfeE1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1heCcsICdfeU1heCcpO1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY2hhcnN0cmluZ1xuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGNmZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNoYXJzdHJpbmcpO1xuICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH07XG59XG5cbnZhciBnbHlwaHNldCA9IHsgR2x5cGhTZXQ6IEdseXBoU2V0LCBnbHlwaExvYWRlcjogZ2x5cGhMb2FkZXIsIHR0ZkdseXBoTG9hZGVyOiB0dGZHbHlwaExvYWRlciwgY2ZmR2x5cGhMb2FkZXI6IGNmZkdseXBoTG9hZGVyIH07XG5cbi8vIFRoZSBgQ0ZGYCB0YWJsZSBjb250YWlucyB0aGUgZ2x5cGggb3V0bGluZXMgaW4gUG9zdFNjcmlwdCBmb3JtYXQuXG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFN1YnJvdXRpbmVzIGFyZSBlbmNvZGVkIHVzaW5nIHRoZSBuZWdhdGl2ZSBoYWxmIG9mIHRoZSBudW1iZXIgc3BhY2UuXG4vLyBTZWUgdHlwZSAyIGNoYXB0ZXIgNC43IFwiU3Vicm91dGluZSBvcGVyYXRvcnNcIi5cbmZ1bmN0aW9uIGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhzdWJycykge1xuICAgIHZhciBiaWFzO1xuICAgIGlmIChzdWJycy5sZW5ndGggPCAxMjQwKSB7XG4gICAgICAgIGJpYXMgPSAxMDc7XG4gICAgfSBlbHNlIGlmIChzdWJycy5sZW5ndGggPCAzMzkwMCkge1xuICAgICAgICBiaWFzID0gMTEzMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiaWFzID0gMzI3Njg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgSU5ERVggYXJyYXkuXG4vLyBBbiBpbmRleCBhcnJheSBjb25zaXN0cyBvZiBhIGxpc3Qgb2Ygb2Zmc2V0cywgdGhlbiBhIGxpc3Qgb2Ygb2JqZWN0cyBhdCB0aG9zZSBvZmZzZXRzLlxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0O1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG4gICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG4gICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxXSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDEgKyAxXSk7XG4gICAgICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtvYmplY3RzOiBvYmplY3RzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleExvd01lbW9yeShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvZmZzZXRzID0gW107XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIHJldHVybiB7b2Zmc2V0czogb2Zmc2V0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5mdW5jdGlvbiBnZXRDZmZJbmRleE9iamVjdChpLCBvZmZzZXRzLCBkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0ID0gMDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSkgKyAyO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICBpZiAoY29udmVyc2lvbkZuKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1QgcmVhbCB2YWx1ZS5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIGVvZiA9IDE1O1xuICAgIHZhciBsb29rdXAgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLicsICdFJywgJ0UtJywgbnVsbCwgJy0nXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgYiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgdmFyIG4xID0gYiA+PiA0O1xuICAgICAgICB2YXIgbjIgPSBiICYgMTU7XG5cbiAgICAgICAgaWYgKG4xID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzKTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9wZXJhbmQuXG5mdW5jdGlvbiBwYXJzZU9wZXJhbmQocGFyc2VyLCBiMCkge1xuICAgIHZhciBiMTtcbiAgICB2YXIgYjI7XG4gICAgdmFyIGIzO1xuICAgIHZhciBiNDtcbiAgICBpZiAoYjAgPT09IDI4KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIGIxIDw8IDggfCBiMjtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDMwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpO1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAzMiAmJiBiMCA8PSAyNDYpIHtcbiAgICAgICAgcmV0dXJuIGIwIC0gMTM5O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNTEgJiYgYjAgPD0gMjU0KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gLShiMCAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwODtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYjAgJyArIGIwKTtcbn1cblxuLy8gQ29udmVydCB0aGUgZW50cmllcyByZXR1cm5lZCBieSBgcGFyc2VEaWN0YCB0byBhIHByb3BlciBkaWN0aW9uYXJ5LlxuLy8gSWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb25lLCBpdCBpcyB1bnBhY2tlZC5cbmZ1bmN0aW9uIGVudHJpZXNUb09iamVjdChlbnRyaWVzKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbaV1bMF07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc05hTihvW2tleV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG87XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvYmplY3QuXG4vLyBBIGRpY3Rpb25hcnkgY29udGFpbnMga2V5LXZhbHVlIHBhaXJzIGluIGEgY29tcGFjdCB0b2tlbml6ZWQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKSB7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIHZhciBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICB2YXIgb3AgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtvcCwgb3BlcmFuZHNdKTtcbiAgICAgICAgICAgIG9wZXJhbmRzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgb3BlcmFuZHMgKHZhbHVlcykgY29tZSBiZWZvcmUgdGhlIG9wZXJhdG9ycyAoa2V5cyksIHdlIHN0b3JlIGFsbCBvcGVyYW5kcyBpbiBhIGxpc3RcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIGVuY291bnRlciBhbiBvcGVyYXRvci5cbiAgICAgICAgICAgIG9wZXJhbmRzLnB1c2gocGFyc2VPcGVyYW5kKHBhcnNlciwgb3ApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzVG9PYmplY3QoZW50cmllcyk7XG59XG5cbi8vIEdpdmVuIGEgU3RyaW5nIEluZGV4IChTSUQpLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG4vLyBTdHJpbmdzIGJlbG93IGluZGV4IDM5MiBhcmUgc3RhbmRhcmQgQ0ZGIHN0cmluZ3MgYW5kIGFyZSBub3QgZW5jb2RlZCBpbiB0aGUgZm9udC5cbmZ1bmN0aW9uIGdldENGRlN0cmluZyhzdHJpbmdzLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8PSAzOTApIHtcbiAgICAgICAgaW5kZXggPSBjZmZTdGFuZGFyZFN0cmluZ3NbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gc3RyaW5nc1tpbmRleCAtIDM5MV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIG5ld0RpY3QgPSB7fTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtID0gbWV0YVtpXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbS50eXBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbS50eXBlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdICE9PSB1bmRlZmluZWQgPyBkaWN0W20ub3BdW2pdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG0udmFsdWVbal0gIT09IHVuZGVmaW5lZCA/IG0udmFsdWVbal0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge1xuICAgICAgICBuYW1lOiAnZm9udE1hdHJpeCcsXG4gICAgICAgIG9wOiAxMjA3LFxuICAgICAgICB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sXG4gICAgICAgIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXVxuICAgIH0sXG4gICAge25hbWU6ICd1bmlxdWVJZCcsIG9wOiAxMywgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZm9udEJCb3gnLCBvcDogNSwgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSwgdmFsdWU6IFswLCAwLCAwLCAwXX0sXG4gICAge25hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAneHVpZCcsIG9wOiAxNCwgdHlwZTogW10sIHZhbHVlOiBudWxsfSxcbiAgICB7bmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgb3A6IDE3LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF19LFxuICAgIHtuYW1lOiAncm9zJywgb3A6IDEyMzAsIHR5cGU6IFsnU0lEJywgJ1NJRCcsICdudW1iZXInXX0sXG4gICAge25hbWU6ICdjaWRGb250VmVyc2lvbicsIG9wOiAxMjMxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2lkRm9udFJldmlzaW9uJywgb3A6IDEyMzIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRGb250VHlwZScsIG9wOiAxMjMzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2lkQ291bnQnLCBvcDogMTIzNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA4NzIwfSxcbiAgICB7bmFtZTogJ3VpZEJhc2UnLCBvcDogMTIzNSwgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZmRBcnJheScsIG9wOiAxMjM2LCB0eXBlOiAnb2Zmc2V0J30sXG4gICAge25hbWU6ICdmZFNlbGVjdCcsIG9wOiAxMjM3LCB0eXBlOiAnb2Zmc2V0J30sXG4gICAge25hbWU6ICdmb250TmFtZScsIG9wOiAxMjM4LCB0eXBlOiAnU0lEJ31cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgVE9QX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgcHJpdmF0ZSBkaWN0aW9uYXJ5LiBXZSBkb24ndCBmdWxseSBwYXJzZSBvdXQgYWxsIHRoZSB2YWx1ZXMsIG9ubHkgdGhlIG9uZXMgd2UgbmVlZC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgc3RhcnQsIHNpemUsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgUFJJVkFURV9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBcIlRvcCBESUNUXCJzIGZvdW5kIHVzaW5nIGFuIElOREVYIGxpc3QuXG4vLyBVc2VkIHRvIHJlYWQgYm90aCB0aGUgdXN1YWwgaGlnaC1sZXZlbCBUb3AgRElDVHMgYW5kIGFsc28gdGhlIEZEQXJyYXlcbi8vIGRpc2NvdmVyZWQgaW5zaWRlIENJRC1rZXllZCBmb250cy4gIFdoZW4gYSBUb3AgRElDVCBoYXMgYSByZWZlcmVuY2UgdG9cbi8vIGEgUHJpdmF0ZSBESUNUIHRoYXQgaXMgcmVhZCBhbmQgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4vL1xuLy8gSW4gYWRkaXRpb24gdG8gdGhlIGV4cGVjdGVkL29wdGlvbmFsIHZhbHVlcyBhcyBvdXRsaW5lZCBpbiBUT1BfRElDVF9NRVRBXG4vLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBtaWdodCBiZSBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyAgICBfc3VicnMgW10gICAgICAgIGFycmF5IG9mIGxvY2FsIENGRiBzdWJyb3V0aW5lcyBmcm9tIFByaXZhdGUgRElDVFxuLy8gICAgX3N1YnJzQmlhcyAgICAgICBiaWFzIHZhbHVlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIHN1YnJvdXRpbmVzXG4vLyAgICAgICAgICAgICAgICAgICAgICAoc2VlIGNhbGNDRkZTdWJyb3V0aW5lQmlhcygpIGFuZCBwYXJzZUNGRkNoYXJzdHJpbmcoKSlcbi8vICAgIF9kZWZhdWx0V2lkdGhYICAgZGVmYXVsdCB3aWR0aHMgZm9yIENGRiBjaGFyYWN0ZXJzXG4vLyAgICBfbm9taW5hbFdpZHRoWCAgIGJpYXMgYWRkZWQgdG8gd2lkdGggZW1iZWRkZWQgd2l0aGluIGdseXBoIGRlc2NyaXB0aW9uXG4vL1xuLy8gICAgX3ByaXZhdGVEaWN0ICAgICBzYXZlZCBjb3B5IG9mIHBhcnNlZCBQcml2YXRlIERJQ1QgZnJvbSBUb3AgRElDVFxuZnVuY3Rpb24gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGNmZkluZGV4LCBzdHJpbmdzKSB7XG4gICAgdmFyIHRvcERpY3RBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGlUb3BEaWN0ID0gMDsgaVRvcERpY3QgPCBjZmZJbmRleC5sZW5ndGg7IGlUb3BEaWN0ICs9IDEpIHtcbiAgICAgICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KGNmZkluZGV4W2lUb3BEaWN0XSkuYnVmZmVyKTtcbiAgICAgICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ3MpO1xuICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IFtdO1xuICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSAwO1xuICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gMDtcbiAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IDA7XG4gICAgICAgIHZhciBwcml2YXRlU2l6ZSA9IHRvcERpY3QucHJpdmF0ZVswXTtcbiAgICAgICAgdmFyIHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgICAgIGlmIChwcml2YXRlU2l6ZSAhPT0gMCAmJiBwcml2YXRlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVPZmZzZXQgKyBzdGFydCwgcHJpdmF0ZVNpemUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgdG9wRGljdC5fZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZU9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICAgICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQgKyBzdGFydCk7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXModG9wRGljdC5fc3VicnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wRGljdC5fcHJpdmF0ZURpY3QgPSBwcml2YXRlRGljdDtcbiAgICAgICAgfVxuICAgICAgICB0b3BEaWN0QXJyYXkucHVzaCh0b3BEaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcERpY3RBcnJheTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgc2lkO1xuICAgIHZhciBjb3VudDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cbiAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG4gICAgbkdseXBocyAtPSAxO1xuICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPD0gY291bnQ7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPD0gY291bnQ7IGkkMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIGVuYyA9IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHZhciBuQ29kZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Db2RlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb2RlID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGVuY1tjb2RlXSA9IGk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBuUmFuZ2VzOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIHZhciBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZmlyc3Q7IGogPD0gZmlyc3QgKyBuTGVmdDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZW5jW2pdID0gY29kZTtcbiAgICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY29kZSkge1xuICAgIHZhciBjMXg7XG4gICAgdmFyIGMxeTtcbiAgICB2YXIgYzJ4O1xuICAgIHZhciBjMnk7XG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBuU3RlbXMgPSAwO1xuICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHN1YnJzO1xuICAgIHZhciBzdWJyc0JpYXM7XG4gICAgdmFyIGRlZmF1bHRXaWR0aFg7XG4gICAgdmFyIG5vbWluYWxXaWR0aFg7XG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEluZGV4ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkU2VsZWN0W2dseXBoLmluZGV4XTtcbiAgICAgICAgdmFyIGZkRGljdCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9mZEFycmF5W2ZkSW5kZXhdO1xuICAgICAgICBzdWJycyA9IGZkRGljdC5fc3VicnM7XG4gICAgICAgIHN1YnJzQmlhcyA9IGZkRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZmREaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZmREaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnJzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgIG5vbWluYWxXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gZGVmYXVsdFdpZHRoWDtcblxuICAgIGZ1bmN0aW9uIG5ld0NvbnRvdXIoeCwgeSkge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAubW92ZVRvKHgsIHkpO1xuICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0ZW1zKCkge1xuICAgICAgICB2YXIgaGFzV2lkdGhBcmc7XG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgIH1cblxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgYjE7XG4gICAgICAgIHZhciBiMjtcbiAgICAgICAgdmFyIGIzO1xuICAgICAgICB2YXIgYjQ7XG4gICAgICAgIHZhciBjb2RlSW5kZXg7XG4gICAgICAgIHZhciBzdWJyQ29kZTtcbiAgICAgICAgdmFyIGpweDtcbiAgICAgICAgdmFyIGpweTtcbiAgICAgICAgdmFyIGMzeDtcbiAgICAgICAgdmFyIGMzeTtcbiAgICAgICAgdmFyIGM0eDtcbiAgICAgICAgdmFyIGM0eTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gaHN0ZW1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHZzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiAvLyB2bW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyBybGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gaGxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiAvLyB2bGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIHJyY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOiAvLyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IC8vIGZsZXggb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNTogLy8gZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkeDYgZHk2IGZkIGZsZXggKDEyIDM1KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OiAvLyBoZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR4NiBoZmxleCAoMTIgMzQpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjogLy8gaGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkNiBmbGV4MSAoMTIgMzcpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgMTIwMCArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICAgICAgY2FzZSAyMDogLy8gY250cm1hc2tcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMjogLy8gaG1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6IC8vIHZzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0OiAvLyByY3VydmVsaW5lXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyB2dmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gaGhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjg6IC8vIHNob3J0aW50XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikpID4+IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI5OiAvLyBjYWxsZ3N1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBmb250LmdzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyB2aGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzE6IC8vIGh2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIHYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godiAtIDEzOSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgodiAtIDI0NykgKiAyNTYgKyBiMSArIDEwOCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIzID0gY29kZVtpICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBiNCA9IGNvZGVbaSArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNCkgLyA2NTUzNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlKGNvZGUpO1xuXG4gICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIGZkQXJyYXlDb3VudCkge1xuICAgIHZhciBmZFNlbGVjdCA9IFtdO1xuICAgIHZhciBmZEluZGV4O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIC8vIFNpbXBsZSBsaXN0IG9mIG5HbHlwaHMgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaUdpZCA9IDA7IGlHaWQgPCBuR2x5cGhzOyBpR2lkKyspIHtcbiAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICsgZmRJbmRleCArICcgKEZEIGNvdW50ICcgKyBmZEFycmF5Q291bnQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgIC8vIFJhbmdlc1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgaWYgKGZpcnN0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGluaXRpYWwgR0lEICcgKyBmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIGZvciAodmFyIGlSYW5nZSA9IDA7IGlSYW5nZSA8IG5SYW5nZXM7IGlSYW5nZSsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIG5leHQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID4gbkdseXBocykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgR0lEICcgKyBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBmaXJzdCA8IG5leHQ7IGZpcnN0KyspIHtcbiAgICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0ICE9PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGZpbmFsIEdJRCAnICsgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCB0YWJsZSBoYXMgdW5zdXBwb3J0ZWQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmRTZWxlY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCwgb3B0KSB7XG4gICAgZm9udC50YWJsZXMuY2ZmID0ge307XG4gICAgdmFyIGhlYWRlciA9IHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB2YXIgdG9wRGljdEluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBuYW1lSW5kZXguZW5kT2Zmc2V0KTtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHRvcERpY3RJbmRleC5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3RBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCB0b3BEaWN0SW5kZXgub2JqZWN0cywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgaWYgKHRvcERpY3RBcnJheS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgdGFibGUgaGFzIHRvbyBtYW55IGZvbnRzIGluIFxcJ0ZvbnRTZXRcXCcgLSBjb3VudCBvZiBmb250cyBOYW1lSW5kZXgubGVuZ3RoID0gJyArIHRvcERpY3RBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciB0b3BEaWN0ID0gdG9wRGljdEFycmF5WzBdO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIGlmICh0b3BEaWN0Ll9wcml2YXRlRGljdCkge1xuICAgICAgICBmb250LmRlZmF1bHRXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgICBmb250Lm5vbWluYWxXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgIH1cblxuICAgIGlmICh0b3BEaWN0LnJvc1swXSAhPT0gdW5kZWZpbmVkICYmIHRvcERpY3Qucm9zWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9udC5pc0NJREZvbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICB2YXIgZmRBcnJheU9mZnNldCA9IHRvcERpY3QuZmRBcnJheTtcbiAgICAgICAgdmFyIGZkU2VsZWN0T2Zmc2V0ID0gdG9wRGljdC5mZFNlbGVjdDtcbiAgICAgICAgaWYgKGZkQXJyYXlPZmZzZXQgPT09IDAgfHwgZmRTZWxlY3RPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9udCBpcyBtYXJrZWQgYXMgYSBDSUQgZm9udCwgYnV0IEZEQXJyYXkgYW5kL29yIEZEU2VsZWN0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmZEFycmF5T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB2YXIgZmRBcnJheUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBmZEFycmF5T2Zmc2V0KTtcbiAgICAgICAgdmFyIGZkQXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgZmRBcnJheUluZGV4Lm9iamVjdHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgICAgICB0b3BEaWN0Ll9mZEFycmF5ID0gZmRBcnJheTtcbiAgICAgICAgZmRTZWxlY3RPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIHRvcERpY3QuX2ZkU2VsZWN0ID0gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBmZFNlbGVjdE9mZnNldCwgZm9udC5udW1HbHlwaHMsIGZkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgcHJpdmF0ZURpY3RPZmZzZXQgPSBzdGFydCArIHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0LnByaXZhdGVbMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICB2YXIgc3Vick9mZnNldCA9IHByaXZhdGVEaWN0T2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQpO1xuICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuc3VicnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VicnMgPSBbXTtcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSAwO1xuICAgIH1cblxuICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuICAgIHZhciBjaGFyU3RyaW5nc0luZGV4O1xuICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4TG93TWVtb3J5KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2Zmc2V0cy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzKTtcbiAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhcnNldCwgZm9udC5uR2x5cGhzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAvLyBTdGFuZGFyZCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAvLyBFeHBlcnQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgZm9udC5fcHVzaCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gZ2V0Q2ZmSW5kZXhPYmplY3QoaSwgY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLCBkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgICAgICAgICAgZm9udC5nbHlwaHMucHVzaChpLCBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBTdHJpbmcgSUQgKFNJRCkuXG4vLyBUaGUgbGlzdCBvZiBzdHJpbmdzIGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgc2lkO1xuXG4gICAgLy8gSXMgdGhlIHN0cmluZyBpbiB0aGUgQ0ZGIHN0YW5kYXJkIHN0cmluZ3M/XG4gICAgdmFyIGkgPSBjZmZTdGFuZGFyZFN0cmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHNpZCA9IGk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlIHN0cmluZyBhbHJlYWR5IGluIHRoZSBzdHJpbmcgaW5kZXg/XG4gICAgaSA9IHN0cmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHNpZCA9IGkgKyBjZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZCA9IGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGggKyBzdHJpbmdzLmxlbmd0aDtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0hlYWRlcicsIFtcbiAgICAgICAge25hbWU6ICdtYWpvcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdtaW5vcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdoZHJTaXplJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lSW5kZXgoZm9udE5hbWVzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdOYW1lIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ25hbWVzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQubmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnROYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0Lm5hbWVzLnB1c2goe25hbWU6ICduYW1lXycgKyBpLCB0eXBlOiAnTkFNRScsIHZhbHVlOiBmb250TmFtZXNbaV19KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuLy8gR2l2ZW4gYSBkaWN0aW9uYXJ5J3MgbWV0YWRhdGEsIGNyZWF0ZSBhIERJQ1Qgc3RydWN0dXJlLlxuZnVuY3Rpb24gbWFrZURpY3QobWV0YSwgYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgbSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZW50cnkgPSBtZXRhW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tlbnRyeS5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxdWFscyh2YWx1ZSwgZW50cnkudmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVuY29kZVN0cmluZyh2YWx1ZSwgc3RyaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1bZW50cnkub3BdID0ge25hbWU6IGVudHJ5Lm5hbWUsIHR5cGU6IGVudHJ5LnR5cGUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdUb3AgRElDVCcsIFtcbiAgICAgICAge25hbWU6ICdkaWN0JywgdHlwZTogJ0RJQ1QnLCB2YWx1ZToge319XG4gICAgXSk7XG4gICAgdC5kaWN0ID0gbWFrZURpY3QoVE9QX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3RvcERpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQudG9wRGljdHMgPSBbe25hbWU6ICd0b3BEaWN0XzAnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdG9wRGljdH1dO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZUdsb2JhbFN1YnJJbmRleCgpIHtcbiAgICAvLyBDdXJyZW50bHkgd2UgZG9uJ3QgdXNlIHN1YnJvdXRpbmVzLlxuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ0NoYXJzZXRzJywgW1xuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhOYW1lID0gZ2x5cGhOYW1lc1tpXTtcbiAgICAgICAgdmFyIGdseXBoU0lEID0gZW5jb2RlU3RyaW5nKGdseXBoTmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1NJRCcsIHZhbHVlOiBnbHlwaFNJRH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdO1xuICAgIHZhciBwYXRoID0gZ2x5cGgucGF0aDtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZHggPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIGR5ID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gQ0ZGIG9ubHkgc3VwcG9ydHMgYsOpemllciBjdXJ2ZXMsIHNvIGNvbnZlcnQgdGhlIHF1YWQgdG8gYSBiw6l6aWVyLlxuICAgICAgICAgICAgdmFyIF8xMyA9IDEgLyAzO1xuICAgICAgICAgICAgdmFyIF8yMyA9IDIgLyAzO1xuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBjcmVhdGUgYSBuZXcgY29tbWFuZCBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIG9yaWdpbmFsIHBhdGguXG4gICAgICAgICAgICAvLyBTaW5jZSBhbGwgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlLCB3ZSByb3VuZCgpIHRoZW0gQVNBUCB0byBhdm9pZCBwcm9wYWdhdGluZyBlcnJvcnMuXG4gICAgICAgICAgICBjbWQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICAgICAgICAgIHg6IGNtZC54LFxuICAgICAgICAgICAgICAgIHk6IGNtZC55LFxuICAgICAgICAgICAgICAgIHgxOiBNYXRoLnJvdW5kKF8xMyAqIHggKyBfMjMgKiBjbWQueDEpLFxuICAgICAgICAgICAgICAgIHkxOiBNYXRoLnJvdW5kKF8xMyAqIHkgKyBfMjMgKiBjbWQueTEpLFxuICAgICAgICAgICAgICAgIHgyOiBNYXRoLnJvdW5kKF8xMyAqIGNtZC54ICsgXzIzICogY21kLngxKSxcbiAgICAgICAgICAgICAgICB5MjogTWF0aC5yb3VuZChfMTMgKiBjbWQueSArIF8yMyAqIGNtZC55MSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0geCk7XG4gICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSB5KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0geCk7XG4gICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSB5KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB2YXIgZHgxID0gTWF0aC5yb3VuZChjbWQueDEgLSB4KTtcbiAgICAgICAgICAgIHZhciBkeTEgPSBNYXRoLnJvdW5kKGNtZC55MSAtIHkpO1xuICAgICAgICAgICAgdmFyIGR4MiA9IE1hdGgucm91bmQoY21kLngyIC0gY21kLngxKTtcbiAgICAgICAgICAgIHZhciBkeTIgPSBNYXRoLnJvdW5kKGNtZC55MiAtIGNtZC55MSk7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSBjbWQueDIpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0gY21kLnkyKTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udG91cnMgYXJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5LlxuICAgIH1cblxuICAgIG9wcy5wdXNoKHtuYW1lOiAnZW5kY2hhcicsIHR5cGU6ICdPUCcsIHZhbHVlOiAxNH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnUHJpdmF0ZSBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NGRiAnLCBbXG4gICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ25hbWVJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICd0b3BEaWN0SW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnZ2xvYmFsU3VickluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJzZXRzJywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3QnLCB0eXBlOiAnUkVDT1JEJ31cbiAgICBdKTtcblxuICAgIHZhciBmb250U2NhbGUgPSAxIC8gb3B0aW9ucy51bml0c1BlckVtO1xuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodDogb3B0aW9ucy53ZWlnaHROYW1lLFxuICAgICAgICBmb250QkJveDogb3B0aW9ucy5mb250QkJveCB8fCBbMCwgMCwgMCwgMF0sXG4gICAgICAgIGZvbnRNYXRyaXg6IFtmb250U2NhbGUsIDAsIDAsIGZvbnRTY2FsZSwgMCwgMF0sXG4gICAgICAgIGNoYXJzZXQ6IDk5OSxcbiAgICAgICAgZW5jb2Rpbmc6IDAsXG4gICAgICAgIGNoYXJTdHJpbmdzOiA5OTksXG4gICAgICAgIHByaXZhdGU6IFswLCA5OTldXG4gICAgfTtcblxuICAgIHZhciBwcml2YXRlQXR0cnMgPSB7fTtcblxuICAgIHZhciBnbHlwaE5hbWVzID0gW107XG4gICAgdmFyIGdseXBoO1xuXG4gICAgLy8gU2tpcCBmaXJzdCBnbHlwaCAoLm5vdGRlZilcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoTmFtZXMucHVzaChnbHlwaC5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG4gICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG4gICAgdC5uYW1lSW5kZXggPSBtYWtlTmFtZUluZGV4KFtvcHRpb25zLnBvc3RTY3JpcHROYW1lXSk7XG4gICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuICAgIHQuZ2xvYmFsU3VickluZGV4ID0gbWFrZUdsb2JhbFN1YnJJbmRleCgpO1xuICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG4gICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcbiAgICB0LnByaXZhdGVEaWN0ID0gbWFrZVByaXZhdGVEaWN0KHByaXZhdGVBdHRycywgc3RyaW5ncyk7XG5cbiAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cbiAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdC5oZWFkZXIuc2l6ZU9mKCkgK1xuICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5zdHJpbmdJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcblxuICAgIC8vIFdlIHVzZSB0aGUgQ0ZGIHN0YW5kYXJkIGVuY29kaW5nOyBwcm9wZXIgZW5jb2Rpbmcgd2lsbCBiZSBoYW5kbGVkIGluIGNtYXAuXG4gICAgYXR0cnMuZW5jb2RpbmcgPSAwO1xuICAgIGF0dHJzLmNoYXJTdHJpbmdzID0gYXR0cnMuY2hhcnNldCArIHQuY2hhcnNldHMuc2l6ZU9mKCk7XG4gICAgYXR0cnMucHJpdmF0ZVsxXSA9IGF0dHJzLmNoYXJTdHJpbmdzICsgdC5jaGFyU3RyaW5nc0luZGV4LnNpemVPZigpO1xuXG4gICAgLy8gUmVjcmVhdGUgdGhlIFRvcCBESUNUIElOREVYIHdpdGggdGhlIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuICAgIHQudG9wRGljdEluZGV4ID0gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KTtcblxuICAgIHJldHVybiB0O1xufVxuXG52YXIgY2ZmID0geyBwYXJzZTogcGFyc2VDRkZUYWJsZSwgbWFrZTogbWFrZUNGRlRhYmxlIH07XG5cbi8vIFRoZSBgaGVhZGAgdGFibGUgY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb250LlxuXG4vLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIZWFkVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGVhZC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoZWFkLmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQocC5wYXJzZUZpeGVkKCkgKiAxMDAwKSAvIDEwMDA7XG4gICAgaGVhZC5jaGVja1N1bUFkanVzdG1lbnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBoZWFkLm1hZ2ljTnVtYmVyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQoaGVhZC5tYWdpY051bWJlciA9PT0gMHg1RjBGM0NGNSwgJ0ZvbnQgaGVhZGVyIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIuJyk7XG4gICAgaGVhZC5mbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLnVuaXRzUGVyRW0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5jcmVhdGVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQubW9kaWZpZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC54TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5tYWNTdHlsZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmxvd2VzdFJlY1BQRU0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5mb250RGlyZWN0aW9uSGludCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQuaW5kZXhUb0xvY0Zvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkVGFibGUob3B0aW9ucykge1xuICAgIC8vIEFwcGxlIE1hYyB0aW1lc3RhbXAgZXBvY2ggaXMgMDEvMDEvMTkwNCBub3QgMDEvMDEvMTk3MFxuICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyAyMDgyODQ0ODAwO1xuICAgIHZhciBjcmVhdGVkVGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcCkge1xuICAgICAgICBjcmVhdGVkVGltZXN0YW1wID0gb3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wICsgMjA4Mjg0NDgwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoZWFkJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udFJldmlzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtQWRqdXN0bWVudCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWdpY051bWJlcicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDVGMEYzQ0Y1fSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5pdHNQZXJFbScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMTAwMH0sXG4gICAgICAgIHtuYW1lOiAnY3JlYXRlZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogY3JlYXRlZFRpbWVzdGFtcH0sXG4gICAgICAgIHtuYW1lOiAnbW9kaWZpZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IHRpbWVzdGFtcH0sXG4gICAgICAgIHtuYW1lOiAneE1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udERpcmVjdGlvbkhpbnQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxudmFyIGhlYWQgPSB7IHBhcnNlOiBwYXJzZUhlYWRUYWJsZSwgbWFrZTogbWFrZUhlYWRUYWJsZSB9O1xuXG4vLyBUaGUgYGhoZWFgIHRhYmxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBob3Jpem9udGFsIGxheW91dC5cblxuLy8gUGFyc2UgdGhlIGhvcml6b250YWwgaGVhZGVyIGBoaGVhYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIaGVhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGhlYSA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGhlYS52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoaGVhLmFzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5kZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmxpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmFkdmFuY2VXaWR0aE1heCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoaGVhLm1pbkxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubWluUmlnaHRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEueE1heEV4dGVudCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJpc2UgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSdW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0T2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIGhoZWEubWV0cmljRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubnVtYmVyT2ZITWV0cmljcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICByZXR1cm4gaGhlYTtcbn1cblxuZnVuY3Rpb24gbWFrZUhoZWFUYWJsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGhlYScsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2FzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2Rlc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsaW5lR2FwJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FkdmFuY2VXaWR0aE1heCcsIHR5cGU6ICdVRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTGVmdFNpZGVCZWFyaW5nJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pblJpZ2h0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heEV4dGVudCcsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUmlzZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUnVuJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0T2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkNCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtZXRyaWNEYXRhRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bWJlck9mSE1ldHJpY3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSwgb3B0aW9ucyk7XG59XG5cbnZhciBoaGVhID0geyBwYXJzZTogcGFyc2VIaGVhVGFibGUsIG1ha2U6IG1ha2VIaGVhVGFibGUgfTtcblxuLy8gVGhlIGBobXR4YCB0YWJsZSBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZUFsbChkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgYWR2YW5jZVdpZHRoO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gYWR2YW5jZVdpZHRoO1xuICAgICAgICBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgPSBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpIHtcbiAgICBmb250Ll9obXR4VGFibGVEYXRhID0ge307XG5cbiAgICB2YXIgYWR2YW5jZVdpZHRoO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9udC5faG10eFRhYmxlRGF0YVtpXSA9IHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogYWR2YW5jZVdpZHRoLFxuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiBsZWZ0U2lkZUJlYXJpbmdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzLCBvcHQpIHtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSlcbiAgICAgICAgeyBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpOyB9XG4gICAgZWxzZVxuICAgICAgICB7IHBhcnNlSG10eFRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocyk7IH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBsZWZ0U2lkZUJlYXJpbmcgPSBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgfHwgMDtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2FkdmFuY2VXaWR0aF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBhZHZhbmNlV2lkdGh9KTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlZnRTaWRlQmVhcmluZ18nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IGxlZnRTaWRlQmVhcmluZ30pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG52YXIgaG10eCA9IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlLCBtYWtlOiBtYWtlSG10eFRhYmxlIH07XG5cbi8vIFRoZSBgbHRhZ2AgdGFibGUgc3RvcmVzIElFVEYgQkNQLTQ3IGxhbmd1YWdlIHRhZ3MuIEl0IGFsbG93cyBzdXBwb3J0aW5nXG5cbmZ1bmN0aW9uIG1ha2VMdGFnVGFibGUodGFncykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2x0YWcnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3MubGVuZ3RofVxuICAgIF0pO1xuXG4gICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcbiAgICB2YXIgc3RyaW5nUG9vbE9mZnNldCA9IDEyICsgdGFncy5sZW5ndGggKiA0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5pbmRleE9mKHRhZ3NbaV0pO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgcG9zID0gc3RyaW5nUG9vbC5sZW5ndGg7XG4gICAgICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdvZmZzZXQgJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldCArIHBvc30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogdGFnc1tpXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdQb29sJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMdGFnVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcbiAgICB2YXIgbnVtVGFncyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhZ3M7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IG9mZnNldCArIGxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldEludDgoaikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbnZhciBsdGFnID0geyBtYWtlOiBtYWtlTHRhZ1RhYmxlLCBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcblxuLy8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgbWF4cCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAobWF4cC52ZXJzaW9uID09PSAxLjApIHtcbiAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlUG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFR3aWxpZ2h0UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEluc3RydWN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnRFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4cDtcbn1cblxuZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdtYXhwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG4gICAgXSk7XG59XG5cbnZhciBtYXhwID0geyBwYXJzZTogcGFyc2VNYXhwVGFibGUsIG1ha2U6IG1ha2VNYXhwVGFibGUgfTtcblxuLy8gVGhlIGBuYW1lYCBuYW1pbmcgdGFibGUuXG5cbi8vIE5hbWVJRHMgZm9yIHRoZSBuYW1lIHRhYmxlLlxudmFyIG5hbWVUYWJsZU5hbWVzID0gW1xuICAgICdjb3B5cmlnaHQnLCAgICAgICAgICAgICAgLy8gMFxuICAgICdmb250RmFtaWx5JywgICAgICAgICAgICAgLy8gMVxuICAgICdmb250U3ViZmFtaWx5JywgICAgICAgICAgLy8gMlxuICAgICd1bmlxdWVJRCcsICAgICAgICAgICAgICAgLy8gM1xuICAgICdmdWxsTmFtZScsICAgICAgICAgICAgICAgLy8gNFxuICAgICd2ZXJzaW9uJywgICAgICAgICAgICAgICAgLy8gNVxuICAgICdwb3N0U2NyaXB0TmFtZScsICAgICAgICAgLy8gNlxuICAgICd0cmFkZW1hcmsnLCAgICAgICAgICAgICAgLy8gN1xuICAgICdtYW51ZmFjdHVyZXInLCAgICAgICAgICAgLy8gOFxuICAgICdkZXNpZ25lcicsICAgICAgICAgICAgICAgLy8gOVxuICAgICdkZXNjcmlwdGlvbicsICAgICAgICAgICAgLy8gMTBcbiAgICAnbWFudWZhY3R1cmVyVVJMJywgICAgICAgIC8vIDExXG4gICAgJ2Rlc2lnbmVyVVJMJywgICAgICAgICAgICAvLyAxMlxuICAgICdsaWNlbnNlJywgICAgICAgICAgICAgICAgLy8gMTNcbiAgICAnbGljZW5zZVVSTCcsICAgICAgICAgICAgIC8vIDE0XG4gICAgJ3Jlc2VydmVkJywgICAgICAgICAgICAgICAvLyAxNVxuICAgICdwcmVmZXJyZWRGYW1pbHknLCAgICAgICAgLy8gMTZcbiAgICAncHJlZmVycmVkU3ViZmFtaWx5JywgICAgIC8vIDE3XG4gICAgJ2NvbXBhdGlibGVGdWxsTmFtZScsICAgICAvLyAxOFxuICAgICdzYW1wbGVUZXh0JywgICAgICAgICAgICAgLy8gMTlcbiAgICAncG9zdFNjcmlwdEZpbmRGb250TmFtZScsIC8vIDIwXG4gICAgJ3d3c0ZhbWlseScsICAgICAgICAgICAgICAvLyAyMVxuICAgICd3d3NTdWJmYW1pbHknICAgICAgICAgICAgLy8gMjJcbl07XG5cbnZhciBtYWNMYW5ndWFnZXMgPSB7XG4gICAgMDogJ2VuJyxcbiAgICAxOiAnZnInLFxuICAgIDI6ICdkZScsXG4gICAgMzogJ2l0JyxcbiAgICA0OiAnbmwnLFxuICAgIDU6ICdzdicsXG4gICAgNjogJ2VzJyxcbiAgICA3OiAnZGEnLFxuICAgIDg6ICdwdCcsXG4gICAgOTogJ25vJyxcbiAgICAxMDogJ2hlJyxcbiAgICAxMTogJ2phJyxcbiAgICAxMjogJ2FyJyxcbiAgICAxMzogJ2ZpJyxcbiAgICAxNDogJ2VsJyxcbiAgICAxNTogJ2lzJyxcbiAgICAxNjogJ210JyxcbiAgICAxNzogJ3RyJyxcbiAgICAxODogJ2hyJyxcbiAgICAxOTogJ3poLUhhbnQnLFxuICAgIDIwOiAndXInLFxuICAgIDIxOiAnaGknLFxuICAgIDIyOiAndGgnLFxuICAgIDIzOiAna28nLFxuICAgIDI0OiAnbHQnLFxuICAgIDI1OiAncGwnLFxuICAgIDI2OiAnaHUnLFxuICAgIDI3OiAnZXMnLFxuICAgIDI4OiAnbHYnLFxuICAgIDI5OiAnc2UnLFxuICAgIDMwOiAnZm8nLFxuICAgIDMxOiAnZmEnLFxuICAgIDMyOiAncnUnLFxuICAgIDMzOiAnemgnLFxuICAgIDM0OiAnbmwtQkUnLFxuICAgIDM1OiAnZ2EnLFxuICAgIDM2OiAnc3EnLFxuICAgIDM3OiAncm8nLFxuICAgIDM4OiAnY3onLFxuICAgIDM5OiAnc2snLFxuICAgIDQwOiAnc2knLFxuICAgIDQxOiAneWknLFxuICAgIDQyOiAnc3InLFxuICAgIDQzOiAnbWsnLFxuICAgIDQ0OiAnYmcnLFxuICAgIDQ1OiAndWsnLFxuICAgIDQ2OiAnYmUnLFxuICAgIDQ3OiAndXonLFxuICAgIDQ4OiAna2snLFxuICAgIDQ5OiAnYXotQ3lybCcsXG4gICAgNTA6ICdhei1BcmFiJyxcbiAgICA1MTogJ2h5JyxcbiAgICA1MjogJ2thJyxcbiAgICA1MzogJ21vJyxcbiAgICA1NDogJ2t5JyxcbiAgICA1NTogJ3RnJyxcbiAgICA1NjogJ3RrJyxcbiAgICA1NzogJ21uLUNOJyxcbiAgICA1ODogJ21uJyxcbiAgICA1OTogJ3BzJyxcbiAgICA2MDogJ2tzJyxcbiAgICA2MTogJ2t1JyxcbiAgICA2MjogJ3NkJyxcbiAgICA2MzogJ2JvJyxcbiAgICA2NDogJ25lJyxcbiAgICA2NTogJ3NhJyxcbiAgICA2NjogJ21yJyxcbiAgICA2NzogJ2JuJyxcbiAgICA2ODogJ2FzJyxcbiAgICA2OTogJ2d1JyxcbiAgICA3MDogJ3BhJyxcbiAgICA3MTogJ29yJyxcbiAgICA3MjogJ21sJyxcbiAgICA3MzogJ2tuJyxcbiAgICA3NDogJ3RhJyxcbiAgICA3NTogJ3RlJyxcbiAgICA3NjogJ3NpJyxcbiAgICA3NzogJ215JyxcbiAgICA3ODogJ2ttJyxcbiAgICA3OTogJ2xvJyxcbiAgICA4MDogJ3ZpJyxcbiAgICA4MTogJ2lkJyxcbiAgICA4MjogJ3RsJyxcbiAgICA4MzogJ21zJyxcbiAgICA4NDogJ21zLUFyYWInLFxuICAgIDg1OiAnYW0nLFxuICAgIDg2OiAndGknLFxuICAgIDg3OiAnb20nLFxuICAgIDg4OiAnc28nLFxuICAgIDg5OiAnc3cnLFxuICAgIDkwOiAncncnLFxuICAgIDkxOiAncm4nLFxuICAgIDkyOiAnbnknLFxuICAgIDkzOiAnbWcnLFxuICAgIDk0OiAnZW8nLFxuICAgIDEyODogJ2N5JyxcbiAgICAxMjk6ICdldScsXG4gICAgMTMwOiAnY2EnLFxuICAgIDEzMTogJ2xhJyxcbiAgICAxMzI6ICdxdScsXG4gICAgMTMzOiAnZ24nLFxuICAgIDEzNDogJ2F5JyxcbiAgICAxMzU6ICd0dCcsXG4gICAgMTM2OiAndWcnLFxuICAgIDEzNzogJ2R6JyxcbiAgICAxMzg6ICdqdicsXG4gICAgMTM5OiAnc3UnLFxuICAgIDE0MDogJ2dsJyxcbiAgICAxNDE6ICdhZicsXG4gICAgMTQyOiAnYnInLFxuICAgIDE0MzogJ2l1JyxcbiAgICAxNDQ6ICdnZCcsXG4gICAgMTQ1OiAnZ3YnLFxuICAgIDE0NjogJ2dhJyxcbiAgICAxNDc6ICd0bycsXG4gICAgMTQ4OiAnZWwtcG9seXRvbicsXG4gICAgMTQ5OiAna2wnLFxuICAgIDE1MDogJ2F6JyxcbiAgICAxNTE6ICdubidcbn07XG5cbi8vIE1hY09TIGxhbmd1YWdlIElEIOKGkiBNYWNPUyBzY3JpcHQgSURcbi8vXG4vLyBOb3RlIHRoYXQgdGhlIHNjcmlwdCBJRCBpcyBub3Qgc3VmZmljaWVudCB0byBkZXRlcm1pbmUgd2hhdCBlbmNvZGluZ1xuLy8gdG8gdXNlIGluIFRydWVUeXBlIGZpbGVzLiBGb3Igc29tZSBsYW5ndWFnZXMsIE1hY09TIHVzZWQgYSBtb2RpZmljYXRpb25cbi8vIG9mIGEgbWFpbnN0cmVhbSBzY3JpcHQuIEZvciBleGFtcGxlLCBhbiBJY2VsYW5kaWMgbmFtZSB3b3VsZCBiZSBzdG9yZWRcbi8vIHdpdGggc21Sb21hbiBpbiB0aGUgVHJ1ZVR5cGUgbmFtaW5nIHRhYmxlLCBidXQgdGhlIGFjdHVhbCBlbmNvZGluZ1xuLy8gaXMgYSBzcGVjaWFsIEljZWxhbmRpYyB2ZXJzaW9uIG9mIHRoZSBub3JtYWwgTWFjaW50b3NoIFJvbWFuIGVuY29kaW5nLlxuLy8gQXMgYW5vdGhlciBleGFtcGxlLCBJbnVrdGl0dXQgdXNlcyBhbiA4LWJpdCBlbmNvZGluZyBmb3IgQ2FuYWRpYW4gQWJvcmlnaW5hbFxuLy8gU3lsbGFibGVzIGJ1dCBNYWNPUyBoYWQgcnVuIG91dCBvZiBhdmFpbGFibGUgc2NyaXB0IGNvZGVzLCBzbyB0aGlzIHdhc1xuLy8gZG9uZSBhcyBhIChwcmV0dHkgcmFkaWNhbCkgXCJtb2RpZmljYXRpb25cIiBvZiBFdGhpb3BpYy5cbi8vXG4vLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvUmVhZG1lLnR4dFxudmFyIG1hY0xhbmd1YWdlVG9TY3JpcHQgPSB7XG4gICAgMDogMCwgIC8vIGxhbmdFbmdsaXNoIOKGkiBzbVJvbWFuXG4gICAgMTogMCwgIC8vIGxhbmdGcmVuY2gg4oaSIHNtUm9tYW5cbiAgICAyOiAwLCAgLy8gbGFuZ0dlcm1hbiDihpIgc21Sb21hblxuICAgIDM6IDAsICAvLyBsYW5nSXRhbGlhbiDihpIgc21Sb21hblxuICAgIDQ6IDAsICAvLyBsYW5nRHV0Y2gg4oaSIHNtUm9tYW5cbiAgICA1OiAwLCAgLy8gbGFuZ1N3ZWRpc2gg4oaSIHNtUm9tYW5cbiAgICA2OiAwLCAgLy8gbGFuZ1NwYW5pc2gg4oaSIHNtUm9tYW5cbiAgICA3OiAwLCAgLy8gbGFuZ0RhbmlzaCDihpIgc21Sb21hblxuICAgIDg6IDAsICAvLyBsYW5nUG9ydHVndWVzZSDihpIgc21Sb21hblxuICAgIDk6IDAsICAvLyBsYW5nTm9yd2VnaWFuIOKGkiBzbVJvbWFuXG4gICAgMTA6IDUsICAvLyBsYW5nSGVicmV3IOKGkiBzbUhlYnJld1xuICAgIDExOiAxLCAgLy8gbGFuZ0phcGFuZXNlIOKGkiBzbUphcGFuZXNlXG4gICAgMTI6IDQsICAvLyBsYW5nQXJhYmljIOKGkiBzbUFyYWJpY1xuICAgIDEzOiAwLCAgLy8gbGFuZ0Zpbm5pc2gg4oaSIHNtUm9tYW5cbiAgICAxNDogNiwgIC8vIGxhbmdHcmVlayDihpIgc21HcmVla1xuICAgIDE1OiAwLCAgLy8gbGFuZ0ljZWxhbmRpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTY6IDAsICAvLyBsYW5nTWFsdGVzZSDihpIgc21Sb21hblxuICAgIDE3OiAwLCAgLy8gbGFuZ1R1cmtpc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE4OiAwLCAgLy8gbGFuZ0Nyb2F0aWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxOTogMiwgIC8vIGxhbmdUcmFkQ2hpbmVzZSDihpIgc21UcmFkQ2hpbmVzZVxuICAgIDIwOiA0LCAgLy8gbGFuZ1VyZHUg4oaSIHNtQXJhYmljXG4gICAgMjE6IDksICAvLyBsYW5nSGluZGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDIyOiAyMSwgIC8vIGxhbmdUaGFpIOKGkiBzbVRoYWlcbiAgICAyMzogMywgIC8vIGxhbmdLb3JlYW4g4oaSIHNtS29yZWFuXG4gICAgMjQ6IDI5LCAgLy8gbGFuZ0xpdGh1YW5pYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI1OiAyOSwgIC8vIGxhbmdQb2xpc2gg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI2OiAyOSwgIC8vIGxhbmdIdW5nYXJpYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI3OiAyOSwgIC8vIGxhbmdFc3RvbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjg6IDI5LCAgLy8gbGFuZ0xhdHZpYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI5OiAwLCAgLy8gbGFuZ1NhbWkg4oaSIHNtUm9tYW5cbiAgICAzMDogMCwgIC8vIGxhbmdGYXJvZXNlIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzMTogNCwgIC8vIGxhbmdGYXJzaSDihpIgc21BcmFiaWMgKG1vZGlmaWVkKVxuICAgIDMyOiA3LCAgLy8gbGFuZ1J1c3NpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICAzMzogMjUsICAvLyBsYW5nU2ltcENoaW5lc2Ug4oaSIHNtU2ltcENoaW5lc2VcbiAgICAzNDogMCwgIC8vIGxhbmdGbGVtaXNoIOKGkiBzbVJvbWFuXG4gICAgMzU6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDM2OiAwLCAgLy8gbGFuZ0FsYmFuaWFuIOKGkiBzbVJvbWFuXG4gICAgMzc6IDAsICAvLyBsYW5nUm9tYW5pYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDM4OiAyOSwgIC8vIGxhbmdDemVjaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMzk6IDI5LCAgLy8gbGFuZ1Nsb3ZhayDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgNDA6IDAsICAvLyBsYW5nU2xvdmVuaWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICA0MTogNSwgIC8vIGxhbmdZaWRkaXNoIOKGkiBzbUhlYnJld1xuICAgIDQyOiA3LCAgLy8gbGFuZ1NlcmJpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0MzogNywgIC8vIGxhbmdNYWNlZG9uaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDQ6IDcsICAvLyBsYW5nQnVsZ2FyaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDU6IDcsICAvLyBsYW5nVWtyYWluaWFuIOKGkiBzbUN5cmlsbGljIChtb2RpZmllZClcbiAgICA0NjogNywgIC8vIGxhbmdCeWVsb3J1c3NpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NzogNywgIC8vIGxhbmdVemJlayDihpIgc21DeXJpbGxpY1xuICAgIDQ4OiA3LCAgLy8gbGFuZ0themFraCDihpIgc21DeXJpbGxpY1xuICAgIDQ5OiA3LCAgLy8gbGFuZ0F6ZXJiYWlqYW5pIOKGkiBzbUN5cmlsbGljXG4gICAgNTA6IDQsICAvLyBsYW5nQXplcmJhaWphbkFyIOKGkiBzbUFyYWJpY1xuICAgIDUxOiAyNCwgIC8vIGxhbmdBcm1lbmlhbiDihpIgc21Bcm1lbmlhblxuICAgIDUyOiAyMywgIC8vIGxhbmdHZW9yZ2lhbiDihpIgc21HZW9yZ2lhblxuICAgIDUzOiA3LCAgLy8gbGFuZ01vbGRhdmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDU0OiA3LCAgLy8gbGFuZ0tpcmdoaXog4oaSIHNtQ3lyaWxsaWNcbiAgICA1NTogNywgIC8vIGxhbmdUYWppa2kg4oaSIHNtQ3lyaWxsaWNcbiAgICA1NjogNywgIC8vIGxhbmdUdXJrbWVuIOKGkiBzbUN5cmlsbGljXG4gICAgNTc6IDI3LCAgLy8gbGFuZ01vbmdvbGlhbiDihpIgc21Nb25nb2xpYW5cbiAgICA1ODogNywgIC8vIGxhbmdNb25nb2xpYW5DeXIg4oaSIHNtQ3lyaWxsaWNcbiAgICA1OTogNCwgIC8vIGxhbmdQYXNodG8g4oaSIHNtQXJhYmljXG4gICAgNjA6IDQsICAvLyBsYW5nS3VyZGlzaCDihpIgc21BcmFiaWNcbiAgICA2MTogNCwgIC8vIGxhbmdLYXNobWlyaSDihpIgc21BcmFiaWNcbiAgICA2MjogNCwgIC8vIGxhbmdTaW5kaGkg4oaSIHNtQXJhYmljXG4gICAgNjM6IDI2LCAgLy8gbGFuZ1RpYmV0YW4g4oaSIHNtVGliZXRhblxuICAgIDY0OiA5LCAgLy8gbGFuZ05lcGFsaSDihpIgc21EZXZhbmFnYXJpXG4gICAgNjU6IDksICAvLyBsYW5nU2Fuc2tyaXQg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY2OiA5LCAgLy8gbGFuZ01hcmF0aGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY3OiAxMywgIC8vIGxhbmdCZW5nYWxpIOKGkiBzbUJlbmdhbGlcbiAgICA2ODogMTMsICAvLyBsYW5nQXNzYW1lc2Ug4oaSIHNtQmVuZ2FsaVxuICAgIDY5OiAxMSwgIC8vIGxhbmdHdWphcmF0aSDihpIgc21HdWphcmF0aVxuICAgIDcwOiAxMCwgIC8vIGxhbmdQdW5qYWJpIOKGkiBzbUd1cm11a2hpXG4gICAgNzE6IDEyLCAgLy8gbGFuZ09yaXlhIOKGkiBzbU9yaXlhXG4gICAgNzI6IDE3LCAgLy8gbGFuZ01hbGF5YWxhbSDihpIgc21NYWxheWFsYW1cbiAgICA3MzogMTYsICAvLyBsYW5nS2FubmFkYSDihpIgc21LYW5uYWRhXG4gICAgNzQ6IDE0LCAgLy8gbGFuZ1RhbWlsIOKGkiBzbVRhbWlsXG4gICAgNzU6IDE1LCAgLy8gbGFuZ1RlbHVndSDihpIgc21UZWx1Z3VcbiAgICA3NjogMTgsICAvLyBsYW5nU2luaGFsZXNlIOKGkiBzbVNpbmhhbGVzZVxuICAgIDc3OiAxOSwgIC8vIGxhbmdCdXJtZXNlIOKGkiBzbUJ1cm1lc2VcbiAgICA3ODogMjAsICAvLyBsYW5nS2htZXIg4oaSIHNtS2htZXJcbiAgICA3OTogMjIsICAvLyBsYW5nTGFvIOKGkiBzbUxhb1xuICAgIDgwOiAzMCwgIC8vIGxhbmdWaWV0bmFtZXNlIOKGkiBzbVZpZXRuYW1lc2VcbiAgICA4MTogMCwgIC8vIGxhbmdJbmRvbmVzaWFuIOKGkiBzbVJvbWFuXG4gICAgODI6IDAsICAvLyBsYW5nVGFnYWxvZyDihpIgc21Sb21hblxuICAgIDgzOiAwLCAgLy8gbGFuZ01hbGF5Um9tYW4g4oaSIHNtUm9tYW5cbiAgICA4NDogNCwgIC8vIGxhbmdNYWxheUFyYWJpYyDihpIgc21BcmFiaWNcbiAgICA4NTogMjgsICAvLyBsYW5nQW1oYXJpYyDihpIgc21FdGhpb3BpY1xuICAgIDg2OiAyOCwgIC8vIGxhbmdUaWdyaW55YSDihpIgc21FdGhpb3BpY1xuICAgIDg3OiAyOCwgIC8vIGxhbmdPcm9tbyDihpIgc21FdGhpb3BpY1xuICAgIDg4OiAwLCAgLy8gbGFuZ1NvbWFsaSDihpIgc21Sb21hblxuICAgIDg5OiAwLCAgLy8gbGFuZ1N3YWhpbGkg4oaSIHNtUm9tYW5cbiAgICA5MDogMCwgIC8vIGxhbmdLaW55YXJ3YW5kYSDihpIgc21Sb21hblxuICAgIDkxOiAwLCAgLy8gbGFuZ1J1bmRpIOKGkiBzbVJvbWFuXG4gICAgOTI6IDAsICAvLyBsYW5nTnlhbmphIOKGkiBzbVJvbWFuXG4gICAgOTM6IDAsICAvLyBsYW5nTWFsYWdhc3kg4oaSIHNtUm9tYW5cbiAgICA5NDogMCwgIC8vIGxhbmdFc3BlcmFudG8g4oaSIHNtUm9tYW5cbiAgICAxMjg6IDAsICAvLyBsYW5nV2Vsc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDEyOTogMCwgIC8vIGxhbmdCYXNxdWUg4oaSIHNtUm9tYW5cbiAgICAxMzA6IDAsICAvLyBsYW5nQ2F0YWxhbiDihpIgc21Sb21hblxuICAgIDEzMTogMCwgIC8vIGxhbmdMYXRpbiDihpIgc21Sb21hblxuICAgIDEzMjogMCwgIC8vIGxhbmdRdWVjaHVhIOKGkiBzbVJvbWFuXG4gICAgMTMzOiAwLCAgLy8gbGFuZ0d1YXJhbmkg4oaSIHNtUm9tYW5cbiAgICAxMzQ6IDAsICAvLyBsYW5nQXltYXJhIOKGkiBzbVJvbWFuXG4gICAgMTM1OiA3LCAgLy8gbGFuZ1RhdGFyIOKGkiBzbUN5cmlsbGljXG4gICAgMTM2OiA0LCAgLy8gbGFuZ1VpZ2h1ciDihpIgc21BcmFiaWNcbiAgICAxMzc6IDI2LCAgLy8gbGFuZ0R6b25na2hhIOKGkiBzbVRpYmV0YW5cbiAgICAxMzg6IDAsICAvLyBsYW5nSmF2YW5lc2VSb20g4oaSIHNtUm9tYW5cbiAgICAxMzk6IDAsICAvLyBsYW5nU3VuZGFuZXNlUm9tIOKGkiBzbVJvbWFuXG4gICAgMTQwOiAwLCAgLy8gbGFuZ0dhbGljaWFuIOKGkiBzbVJvbWFuXG4gICAgMTQxOiAwLCAgLy8gbGFuZ0FmcmlrYWFucyDihpIgc21Sb21hblxuICAgIDE0MjogMCwgIC8vIGxhbmdCcmV0b24g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0MzogMjgsICAvLyBsYW5nSW51a3RpdHV0IOKGkiBzbUV0aGlvcGljIChtb2RpZmllZClcbiAgICAxNDQ6IDAsICAvLyBsYW5nU2NvdHRpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NTogMCwgIC8vIGxhbmdNYW54R2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDY6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWNTY3JpcHQg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NzogMCwgIC8vIGxhbmdUb25nYW4g4oaSIHNtUm9tYW5cbiAgICAxNDg6IDYsICAvLyBsYW5nR3JlZWtBbmNpZW50IOKGkiBzbVJvbWFuXG4gICAgMTQ5OiAwLCAgLy8gbGFuZ0dyZWVubGFuZGljIOKGkiBzbVJvbWFuXG4gICAgMTUwOiAwLCAgLy8gbGFuZ0F6ZXJiYWlqYW5Sb21hbiDihpIgc21Sb21hblxuICAgIDE1MTogMCAgIC8vIGxhbmdOeW5vcnNrIOKGkiBzbVJvbWFuXG59O1xuXG4vLyBXaGlsZSBNaWNyb3NvZnQgaW5kaWNhdGVzIGEgcmVnaW9uL2NvdW50cnkgZm9yIGFsbCBpdHMgbGFuZ3VhZ2Vcbi8vIElEcywgd2Ugb21pdCB0aGUgcmVnaW9uIGNvZGUgaWYgaXQncyBlcXVhbCB0byB0aGUgXCJtb3N0IGxpa2VseVxuLy8gcmVnaW9uIHN1YnRhZ1wiIGFjY29yZGluZyB0byBVbmljb2RlIENMRFIuIEZvciBzY3JpcHRzLCB3ZSBvbWl0XG4vLyB0aGUgc3VidGFnIGlmIGl0IGlzIGVxdWFsIHRvIHRoZSBTdXBwcmVzcy1TY3JpcHQgZW50cnkgaW4gdGhlXG4vLyBJQU5BIGxhbmd1YWdlIHN1YnRhZyByZWdpc3RyeSBmb3IgSUVURiBCQ1AgNDcuXG4vL1xuLy8gRm9yIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXMgdGhhdCBpdHMgbGFuZ3VhZ2UgY29kZSAweDA0MUEgaXNcbi8vIENyb2F0aWFuIGluIENyb2F0aWEuIFdlIHRyYW5zZm9ybSB0aGlzIHRvIHRoZSBCQ1AgNDcgbGFuZ3VhZ2UgY29kZSAnaHInXG4vLyBhbmQgbm90ICdoci1IUicgYmVjYXVzZSBDcm9hdGlhIGlzIHRoZSBkZWZhdWx0IGNvdW50cnkgZm9yIENyb2F0aWFuLFxuLy8gYWNjb3JkaW5nIHRvIFVuaWNvZGUgQ0xEUi4gQXMgYW5vdGhlciBleGFtcGxlLCBNaWNyb3NvZnQgc3RhdGVzXG4vLyB0aGF0IDB4MTAxQSBpcyBDcm9hdGlhbiAoTGF0aW4pIGluIEJvc25pYS1IZXJ6ZWdvdmluYS4gV2UgdHJhbnNmb3JtXG4vLyB0aGlzIHRvICdoci1CQScgYW5kIG5vdCAnaHItTGF0bi1CQScgYmVjYXVzZSBMYXRpbiBpcyB0aGUgZGVmYXVsdCBzY3JpcHRcbi8vIGZvciB0aGUgQ3JvYXRpYW4gbGFuZ3VhZ2UsIGFjY29yZGluZyB0byBJQU5BLlxuLy9cbi8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvY2xkci9jaGFydHMvbGF0ZXN0L3N1cHBsZW1lbnRhbC9saWtlbHlfc3VidGFncy5odG1sXG4vLyBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeS9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnlcbnZhciB3aW5kb3dzTGFuZ3VhZ2VzID0ge1xuICAgIDB4MDQzNjogJ2FmJyxcbiAgICAweDA0MUM6ICdzcScsXG4gICAgMHgwNDg0OiAnZ3N3JyxcbiAgICAweDA0NUU6ICdhbScsXG4gICAgMHgxNDAxOiAnYXItRFonLFxuICAgIDB4M0MwMTogJ2FyLUJIJyxcbiAgICAweDBDMDE6ICdhcicsXG4gICAgMHgwODAxOiAnYXItSVEnLFxuICAgIDB4MkMwMTogJ2FyLUpPJyxcbiAgICAweDM0MDE6ICdhci1LVycsXG4gICAgMHgzMDAxOiAnYXItTEInLFxuICAgIDB4MTAwMTogJ2FyLUxZJyxcbiAgICAweDE4MDE6ICdhcnknLFxuICAgIDB4MjAwMTogJ2FyLU9NJyxcbiAgICAweDQwMDE6ICdhci1RQScsXG4gICAgMHgwNDAxOiAnYXItU0EnLFxuICAgIDB4MjgwMTogJ2FyLVNZJyxcbiAgICAweDFDMDE6ICdhZWInLFxuICAgIDB4MzgwMTogJ2FyLUFFJyxcbiAgICAweDI0MDE6ICdhci1ZRScsXG4gICAgMHgwNDJCOiAnaHknLFxuICAgIDB4MDQ0RDogJ2FzJyxcbiAgICAweDA4MkM6ICdhei1DeXJsJyxcbiAgICAweDA0MkM6ICdheicsXG4gICAgMHgwNDZEOiAnYmEnLFxuICAgIDB4MDQyRDogJ2V1JyxcbiAgICAweDA0MjM6ICdiZScsXG4gICAgMHgwODQ1OiAnYm4nLFxuICAgIDB4MDQ0NTogJ2JuLUlOJyxcbiAgICAweDIwMUE6ICdicy1DeXJsJyxcbiAgICAweDE0MUE6ICdicycsXG4gICAgMHgwNDdFOiAnYnInLFxuICAgIDB4MDQwMjogJ2JnJyxcbiAgICAweDA0MDM6ICdjYScsXG4gICAgMHgwQzA0OiAnemgtSEsnLFxuICAgIDB4MTQwNDogJ3poLU1PJyxcbiAgICAweDA4MDQ6ICd6aCcsXG4gICAgMHgxMDA0OiAnemgtU0cnLFxuICAgIDB4MDQwNDogJ3poLVRXJyxcbiAgICAweDA0ODM6ICdjbycsXG4gICAgMHgwNDFBOiAnaHInLFxuICAgIDB4MTAxQTogJ2hyLUJBJyxcbiAgICAweDA0MDU6ICdjcycsXG4gICAgMHgwNDA2OiAnZGEnLFxuICAgIDB4MDQ4QzogJ3BycycsXG4gICAgMHgwNDY1OiAnZHYnLFxuICAgIDB4MDgxMzogJ25sLUJFJyxcbiAgICAweDA0MTM6ICdubCcsXG4gICAgMHgwQzA5OiAnZW4tQVUnLFxuICAgIDB4MjgwOTogJ2VuLUJaJyxcbiAgICAweDEwMDk6ICdlbi1DQScsXG4gICAgMHgyNDA5OiAnZW4tMDI5JyxcbiAgICAweDQwMDk6ICdlbi1JTicsXG4gICAgMHgxODA5OiAnZW4tSUUnLFxuICAgIDB4MjAwOTogJ2VuLUpNJyxcbiAgICAweDQ0MDk6ICdlbi1NWScsXG4gICAgMHgxNDA5OiAnZW4tTlonLFxuICAgIDB4MzQwOTogJ2VuLVBIJyxcbiAgICAweDQ4MDk6ICdlbi1TRycsXG4gICAgMHgxQzA5OiAnZW4tWkEnLFxuICAgIDB4MkMwOTogJ2VuLVRUJyxcbiAgICAweDA4MDk6ICdlbi1HQicsXG4gICAgMHgwNDA5OiAnZW4nLFxuICAgIDB4MzAwOTogJ2VuLVpXJyxcbiAgICAweDA0MjU6ICdldCcsXG4gICAgMHgwNDM4OiAnZm8nLFxuICAgIDB4MDQ2NDogJ2ZpbCcsXG4gICAgMHgwNDBCOiAnZmknLFxuICAgIDB4MDgwQzogJ2ZyLUJFJyxcbiAgICAweDBDMEM6ICdmci1DQScsXG4gICAgMHgwNDBDOiAnZnInLFxuICAgIDB4MTQwQzogJ2ZyLUxVJyxcbiAgICAweDE4MEM6ICdmci1NQycsXG4gICAgMHgxMDBDOiAnZnItQ0gnLFxuICAgIDB4MDQ2MjogJ2Z5JyxcbiAgICAweDA0NTY6ICdnbCcsXG4gICAgMHgwNDM3OiAna2EnLFxuICAgIDB4MEMwNzogJ2RlLUFUJyxcbiAgICAweDA0MDc6ICdkZScsXG4gICAgMHgxNDA3OiAnZGUtTEknLFxuICAgIDB4MTAwNzogJ2RlLUxVJyxcbiAgICAweDA4MDc6ICdkZS1DSCcsXG4gICAgMHgwNDA4OiAnZWwnLFxuICAgIDB4MDQ2RjogJ2tsJyxcbiAgICAweDA0NDc6ICdndScsXG4gICAgMHgwNDY4OiAnaGEnLFxuICAgIDB4MDQwRDogJ2hlJyxcbiAgICAweDA0Mzk6ICdoaScsXG4gICAgMHgwNDBFOiAnaHUnLFxuICAgIDB4MDQwRjogJ2lzJyxcbiAgICAweDA0NzA6ICdpZycsXG4gICAgMHgwNDIxOiAnaWQnLFxuICAgIDB4MDQ1RDogJ2l1JyxcbiAgICAweDA4NUQ6ICdpdS1MYXRuJyxcbiAgICAweDA4M0M6ICdnYScsXG4gICAgMHgwNDM0OiAneGgnLFxuICAgIDB4MDQzNTogJ3p1JyxcbiAgICAweDA0MTA6ICdpdCcsXG4gICAgMHgwODEwOiAnaXQtQ0gnLFxuICAgIDB4MDQxMTogJ2phJyxcbiAgICAweDA0NEI6ICdrbicsXG4gICAgMHgwNDNGOiAna2snLFxuICAgIDB4MDQ1MzogJ2ttJyxcbiAgICAweDA0ODY6ICdxdWMnLFxuICAgIDB4MDQ4NzogJ3J3JyxcbiAgICAweDA0NDE6ICdzdycsXG4gICAgMHgwNDU3OiAna29rJyxcbiAgICAweDA0MTI6ICdrbycsXG4gICAgMHgwNDQwOiAna3knLFxuICAgIDB4MDQ1NDogJ2xvJyxcbiAgICAweDA0MjY6ICdsdicsXG4gICAgMHgwNDI3OiAnbHQnLFxuICAgIDB4MDgyRTogJ2RzYicsXG4gICAgMHgwNDZFOiAnbGInLFxuICAgIDB4MDQyRjogJ21rJyxcbiAgICAweDA4M0U6ICdtcy1CTicsXG4gICAgMHgwNDNFOiAnbXMnLFxuICAgIDB4MDQ0QzogJ21sJyxcbiAgICAweDA0M0E6ICdtdCcsXG4gICAgMHgwNDgxOiAnbWknLFxuICAgIDB4MDQ3QTogJ2FybicsXG4gICAgMHgwNDRFOiAnbXInLFxuICAgIDB4MDQ3QzogJ21vaCcsXG4gICAgMHgwNDUwOiAnbW4nLFxuICAgIDB4MDg1MDogJ21uLUNOJyxcbiAgICAweDA0NjE6ICduZScsXG4gICAgMHgwNDE0OiAnbmInLFxuICAgIDB4MDgxNDogJ25uJyxcbiAgICAweDA0ODI6ICdvYycsXG4gICAgMHgwNDQ4OiAnb3InLFxuICAgIDB4MDQ2MzogJ3BzJyxcbiAgICAweDA0MTU6ICdwbCcsXG4gICAgMHgwNDE2OiAncHQnLFxuICAgIDB4MDgxNjogJ3B0LVBUJyxcbiAgICAweDA0NDY6ICdwYScsXG4gICAgMHgwNDZCOiAncXUtQk8nLFxuICAgIDB4MDg2QjogJ3F1LUVDJyxcbiAgICAweDBDNkI6ICdxdScsXG4gICAgMHgwNDE4OiAncm8nLFxuICAgIDB4MDQxNzogJ3JtJyxcbiAgICAweDA0MTk6ICdydScsXG4gICAgMHgyNDNCOiAnc21uJyxcbiAgICAweDEwM0I6ICdzbWotTk8nLFxuICAgIDB4MTQzQjogJ3NtaicsXG4gICAgMHgwQzNCOiAnc2UtRkknLFxuICAgIDB4MDQzQjogJ3NlJyxcbiAgICAweDA4M0I6ICdzZS1TRScsXG4gICAgMHgyMDNCOiAnc21zJyxcbiAgICAweDE4M0I6ICdzbWEtTk8nLFxuICAgIDB4MUMzQjogJ3NtcycsXG4gICAgMHgwNDRGOiAnc2EnLFxuICAgIDB4MUMxQTogJ3NyLUN5cmwtQkEnLFxuICAgIDB4MEMxQTogJ3NyJyxcbiAgICAweDE4MUE6ICdzci1MYXRuLUJBJyxcbiAgICAweDA4MUE6ICdzci1MYXRuJyxcbiAgICAweDA0NkM6ICduc28nLFxuICAgIDB4MDQzMjogJ3RuJyxcbiAgICAweDA0NUI6ICdzaScsXG4gICAgMHgwNDFCOiAnc2snLFxuICAgIDB4MDQyNDogJ3NsJyxcbiAgICAweDJDMEE6ICdlcy1BUicsXG4gICAgMHg0MDBBOiAnZXMtQk8nLFxuICAgIDB4MzQwQTogJ2VzLUNMJyxcbiAgICAweDI0MEE6ICdlcy1DTycsXG4gICAgMHgxNDBBOiAnZXMtQ1InLFxuICAgIDB4MUMwQTogJ2VzLURPJyxcbiAgICAweDMwMEE6ICdlcy1FQycsXG4gICAgMHg0NDBBOiAnZXMtU1YnLFxuICAgIDB4MTAwQTogJ2VzLUdUJyxcbiAgICAweDQ4MEE6ICdlcy1ITicsXG4gICAgMHgwODBBOiAnZXMtTVgnLFxuICAgIDB4NEMwQTogJ2VzLU5JJyxcbiAgICAweDE4MEE6ICdlcy1QQScsXG4gICAgMHgzQzBBOiAnZXMtUFknLFxuICAgIDB4MjgwQTogJ2VzLVBFJyxcbiAgICAweDUwMEE6ICdlcy1QUicsXG5cbiAgICAvLyBNaWNyb3NvZnQgaGFzIGRlZmluZWQgdHdvIGRpZmZlcmVudCBsYW5ndWFnZSBjb2RlcyBmb3JcbiAgICAvLyDigJxTcGFuaXNoIHdpdGggbW9kZXJuIHNvcnRpbmfigJ0gYW5kIOKAnFNwYW5pc2ggd2l0aCB0cmFkaXRpb25hbFxuICAgIC8vIHNvcnRpbmfigJ0uIFRoaXMgbWFrZXMgc2Vuc2UgZm9yIGNvbGxhdGlvbiBBUElzLCBhbmQgaXQgd291bGQgYmVcbiAgICAvLyBwb3NzaWJsZSB0byBleHByZXNzIHRoaXMgaW4gQkNQIDQ3IGxhbmd1YWdlIHRhZ3MgdmlhIFVuaWNvZGVcbiAgICAvLyBleHRlbnNpb25zIChlZy4sIGVzLXUtY28tdHJhZCBpcyBTcGFuaXNoIHdpdGggdHJhZGl0aW9uYWxcbiAgICAvLyBzb3J0aW5nKS4gSG93ZXZlciwgZm9yIHN0b3JpbmcgbmFtZXMgaW4gZm9udHMsIHRoZSBkaXN0aW5jdGlvblxuICAgIC8vIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIHNvIHdlIGdpdmUg4oCcZXPigJ0gaW4gYm90aCBjYXNlcy5cbiAgICAweDBDMEE6ICdlcycsXG4gICAgMHgwNDBBOiAnZXMnLFxuXG4gICAgMHg1NDBBOiAnZXMtVVMnLFxuICAgIDB4MzgwQTogJ2VzLVVZJyxcbiAgICAweDIwMEE6ICdlcy1WRScsXG4gICAgMHgwODFEOiAnc3YtRkknLFxuICAgIDB4MDQxRDogJ3N2JyxcbiAgICAweDA0NUE6ICdzeXInLFxuICAgIDB4MDQyODogJ3RnJyxcbiAgICAweDA4NUY6ICd0em0nLFxuICAgIDB4MDQ0OTogJ3RhJyxcbiAgICAweDA0NDQ6ICd0dCcsXG4gICAgMHgwNDRBOiAndGUnLFxuICAgIDB4MDQxRTogJ3RoJyxcbiAgICAweDA0NTE6ICdibycsXG4gICAgMHgwNDFGOiAndHInLFxuICAgIDB4MDQ0MjogJ3RrJyxcbiAgICAweDA0ODA6ICd1ZycsXG4gICAgMHgwNDIyOiAndWsnLFxuICAgIDB4MDQyRTogJ2hzYicsXG4gICAgMHgwNDIwOiAndXInLFxuICAgIDB4MDg0MzogJ3V6LUN5cmwnLFxuICAgIDB4MDQ0MzogJ3V6JyxcbiAgICAweDA0MkE6ICd2aScsXG4gICAgMHgwNDUyOiAnY3knLFxuICAgIDB4MDQ4ODogJ3dvJyxcbiAgICAweDA0ODU6ICdzYWgnLFxuICAgIDB4MDQ3ODogJ2lpJyxcbiAgICAweDA0NkE6ICd5bydcbn07XG5cbi8vIFJldHVybnMgYSBJRVRGIEJDUCA0NyBsYW5ndWFnZSBjb2RlLCBmb3IgZXhhbXBsZSAnemgtSGFudCdcbi8vIGZvciAnQ2hpbmVzZSBpbiB0aGUgdHJhZGl0aW9uYWwgc2NyaXB0Jy5cbmZ1bmN0aW9uIGdldExhbmd1YWdlQ29kZShwbGF0Zm9ybUlELCBsYW5ndWFnZUlELCBsdGFnKSB7XG4gICAgc3dpdGNoIChwbGF0Zm9ybUlEKSB7XG4gICAgICAgIGNhc2UgMDogIC8vIFVuaWNvZGVcbiAgICAgICAgICAgIGlmIChsYW5ndWFnZUlEID09PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VuZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGx0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbHRhZ1tsYW5ndWFnZUlEXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOiAgLy8gTWFjaW50b3NoXG4gICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VzW2xhbmd1YWdlSURdO1xuXG4gICAgICAgIGNhc2UgMzogIC8vIFdpbmRvd3NcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dzTGFuZ3VhZ2VzW2xhbmd1YWdlSURdO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbnZhciB1dGYxNiA9ICd1dGYtMTYnO1xuXG4vLyBNYWNPUyBzY3JpcHQgSUQg4oaSIGVuY29kaW5nLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgZGVmYXVsdCBjYXNlLFxuLy8gd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgbWFjTGFuZ3VhZ2VFbmNvZGluZ3MuXG52YXIgbWFjU2NyaXB0RW5jb2RpbmdzID0ge1xuICAgIDA6ICdtYWNpbnRvc2gnLCAgICAgICAgICAgLy8gc21Sb21hblxuICAgIDE6ICd4LW1hYy1qYXBhbmVzZScsICAgICAgLy8gc21KYXBhbmVzZVxuICAgIDI6ICd4LW1hYy1jaGluZXNldHJhZCcsICAgLy8gc21UcmFkQ2hpbmVzZVxuICAgIDM6ICd4LW1hYy1rb3JlYW4nLCAgICAgICAgLy8gc21Lb3JlYW5cbiAgICA2OiAneC1tYWMtZ3JlZWsnLCAgICAgICAgIC8vIHNtR3JlZWtcbiAgICA3OiAneC1tYWMtY3lyaWxsaWMnLCAgICAgIC8vIHNtQ3lyaWxsaWNcbiAgICA5OiAneC1tYWMtZGV2YW5hZ2FpJywgICAgIC8vIHNtRGV2YW5hZ2FyaVxuICAgIDEwOiAneC1tYWMtZ3VybXVraGknLCAgICAgLy8gc21HdXJtdWtoaVxuICAgIDExOiAneC1tYWMtZ3VqYXJhdGknLCAgICAgLy8gc21HdWphcmF0aVxuICAgIDEyOiAneC1tYWMtb3JpeWEnLCAgICAgICAgLy8gc21Pcml5YVxuICAgIDEzOiAneC1tYWMtYmVuZ2FsaScsICAgICAgLy8gc21CZW5nYWxpXG4gICAgMTQ6ICd4LW1hYy10YW1pbCcsICAgICAgICAvLyBzbVRhbWlsXG4gICAgMTU6ICd4LW1hYy10ZWx1Z3UnLCAgICAgICAvLyBzbVRlbHVndVxuICAgIDE2OiAneC1tYWMta2FubmFkYScsICAgICAgLy8gc21LYW5uYWRhXG4gICAgMTc6ICd4LW1hYy1tYWxheWFsYW0nLCAgICAvLyBzbU1hbGF5YWxhbVxuICAgIDE4OiAneC1tYWMtc2luaGFsZXNlJywgICAgLy8gc21TaW5oYWxlc2VcbiAgICAxOTogJ3gtbWFjLWJ1cm1lc2UnLCAgICAgIC8vIHNtQnVybWVzZVxuICAgIDIwOiAneC1tYWMta2htZXInLCAgICAgICAgLy8gc21LaG1lclxuICAgIDIxOiAneC1tYWMtdGhhaScsICAgICAgICAgLy8gc21UaGFpXG4gICAgMjI6ICd4LW1hYy1sYW8nLCAgICAgICAgICAvLyBzbUxhb1xuICAgIDIzOiAneC1tYWMtZ2VvcmdpYW4nLCAgICAgLy8gc21HZW9yZ2lhblxuICAgIDI0OiAneC1tYWMtYXJtZW5pYW4nLCAgICAgLy8gc21Bcm1lbmlhblxuICAgIDI1OiAneC1tYWMtY2hpbmVzZXNpbXAnLCAgLy8gc21TaW1wQ2hpbmVzZVxuICAgIDI2OiAneC1tYWMtdGliZXRhbicsICAgICAgLy8gc21UaWJldGFuXG4gICAgMjc6ICd4LW1hYy1tb25nb2xpYW4nLCAgICAvLyBzbU1vbmdvbGlhblxuICAgIDI4OiAneC1tYWMtZXRoaW9waWMnLCAgICAgLy8gc21FdGhpb3BpY1xuICAgIDI5OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMzA6ICd4LW1hYy12aWV0bmFtZXNlJywgICAvLyBzbVZpZXRuYW1lc2VcbiAgICAzMTogJ3gtbWFjLWV4dGFyYWJpYycgICAgIC8vIHNtRXh0QXJhYmljXG59O1xuXG4vLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBleGNlcHRpb25hbFxuLy8gY2FzZXMsIHdoaWNoIG92ZXJyaWRlIG1hY1NjcmlwdEVuY29kaW5ncy4gRm9yIHdyaXRpbmcgTWFjT1MgbmFtaW5nXG4vLyB0YWJsZXMsIHdlIG5lZWQgdG8gZW1pdCBhIE1hY09TIHNjcmlwdCBJRC4gVGhlcmVmb3JlLCB3ZSBjYW5ub3Rcbi8vIG1lcmdlIG1hY1NjcmlwdEVuY29kaW5ncyBpbnRvIG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxuLy9cbi8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG52YXIgbWFjTGFuZ3VhZ2VFbmNvZGluZ3MgPSB7XG4gICAgMTU6ICd4LW1hYy1pY2VsYW5kaWMnLCAgICAvLyBsYW5nSWNlbGFuZGljXG4gICAgMTc6ICd4LW1hYy10dXJraXNoJywgICAgICAvLyBsYW5nVHVya2lzaFxuICAgIDE4OiAneC1tYWMtY3JvYXRpYW4nLCAgICAgLy8gbGFuZ0Nyb2F0aWFuXG4gICAgMjQ6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nTGl0aHVhbmlhblxuICAgIDI1OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1BvbGlzaFxuICAgIDI2OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0h1bmdhcmlhblxuICAgIDI3OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0VzdG9uaWFuXG4gICAgMjg6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nTGF0dmlhblxuICAgIDMwOiAneC1tYWMtaWNlbGFuZGljJywgICAgLy8gbGFuZ0Zhcm9lc2VcbiAgICAzNzogJ3gtbWFjLXJvbWFuaWFuJywgICAgIC8vIGxhbmdSb21hbmlhblxuICAgIDM4OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0N6ZWNoXG4gICAgMzk6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nU2xvdmFrXG4gICAgNDA6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nU2xvdmVuaWFuXG4gICAgMTQzOiAneC1tYWMtaW51aXQnLCAgICAgICAvLyBsYW5nSW51a3RpdHV0XG4gICAgMTQ2OiAneC1tYWMtZ2FlbGljJyAgICAgICAvLyBsYW5nSXJpc2hHYWVsaWNTY3JpcHRcbn07XG5cbmZ1bmN0aW9uIGdldEVuY29kaW5nKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQpIHtcbiAgICBzd2l0Y2ggKHBsYXRmb3JtSUQpIHtcbiAgICAgICAgY2FzZSAwOiAgLy8gVW5pY29kZVxuICAgICAgICAgICAgcmV0dXJuIHV0ZjE2O1xuXG4gICAgICAgIGNhc2UgMTogIC8vIEFwcGxlIE1hY2ludG9zaFxuICAgICAgICAgICAgcmV0dXJuIG1hY0xhbmd1YWdlRW5jb2RpbmdzW2xhbmd1YWdlSURdIHx8IG1hY1NjcmlwdEVuY29kaW5nc1tlbmNvZGluZ0lEXTtcblxuICAgICAgICBjYXNlIDM6ICAvLyBNaWNyb3NvZnQgV2luZG93c1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nSUQgPT09IDEgfHwgZW5jb2RpbmdJRCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRmMTY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIFBhcnNlIHRoZSBuYW1pbmcgYG5hbWVgIHRhYmxlLlxuLy8gRklYTUU6IEZvcm1hdCAxIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBub3Qgc3VwcG9ydGVkIHlldC5cbi8vIGx0YWcgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGBsdGFnJyB0YWJsZSwgc3VjaCBhcyBbJ2VuJywgJ3poLUhhbnMnLCAnZGUtQ0gtMTkwNCddLlxuZnVuY3Rpb24gcGFyc2VOYW1lVGFibGUoZGF0YSwgc3RhcnQsIGx0YWcpIHtcbiAgICB2YXIgbmFtZSA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcGxhdGZvcm1JRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGVuY29kaW5nSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBsYW5ndWFnZUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbmFtZUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lVGFibGVOYW1lc1tuYW1lSURdIHx8IG5hbWVJRDtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IGdldExhbmd1YWdlQ29kZShwbGF0Zm9ybUlELCBsYW5ndWFnZUlELCBsdGFnKTtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCk7XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIGxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCk7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHV0ZjE2KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGRlY29kZS5VVEYxNihkYXRhLCBzdHJpbmdPZmZzZXQgKyBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjb2RlLk1BQ1NUUklORyhkYXRhLCBzdHJpbmdPZmZzZXQgKyBvZmZzZXQsIGJ5dGVMZW5ndGgsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25zID0gbmFtZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9ucyA9IG5hbWVbcHJvcGVydHldID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zW2xhbmd1YWdlXSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZ1RhZ0NvdW50ID0gMDtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIEZJWE1FOiBBbHNvIGhhbmRsZSBNaWNyb3NvZnQncyAnbmFtZScgdGFibGUgMS5cbiAgICAgICAgbGFuZ1RhZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xufVxuXG4vLyB7MjM6ICdmb28nfSDihpIgeydmb28nOiAyM31cbi8vIFsnYmFyJywgJ2JheiddIOKGkiB7J2Jhcic6IDAsICdiYXonOiAxfVxuZnVuY3Rpb24gcmV2ZXJzZURpY3QoZGljdCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGljdCkge1xuICAgICAgICByZXN1bHRbZGljdFtrZXldXSA9IHBhcnNlSW50KGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVSZWNvcmQocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCwgbmFtZUlELCBsZW5ndGgsIG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdOYW1lUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGVuY29kaW5nSUR9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG4gICAgXSk7XG59XG5cbi8vIEZpbmRzIHRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG9yIC0xIGlmIG5vdCB0aGVyZS5cbi8vIExpa2UgU3RyaW5nLmluZGV4T2YoKSwgYnV0IGZvciBhcnJheXMuXG5mdW5jdGlvbiBmaW5kU3ViQXJyYXkobmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHZhciBuZWVkbGVMZW5ndGggPSBuZWVkbGUubGVuZ3RoO1xuICAgIHZhciBsaW1pdCA9IGhheXN0YWNrLmxlbmd0aCAtIG5lZWRsZUxlbmd0aCArIDE7XG5cbiAgICBsb29wOlxuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IGxpbWl0OyBwb3MrKykge1xuICAgICAgICBmb3IgKDsgcG9zIDwgbGltaXQ7IHBvcysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5lZWRsZUxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhheXN0YWNrW3BvcyArIGtdICE9PSBuZWVkbGVba10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGFkZFN0cmluZ1RvUG9vbChzLCBwb29sKSB7XG4gICAgdmFyIG9mZnNldCA9IGZpbmRTdWJBcnJheShzLCBwb29sKTtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICBvZmZzZXQgPSBwb29sLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHBvb2wucHVzaChzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVUYWJsZShuYW1lcywgbHRhZykge1xuICAgIHZhciBuYW1lSUQ7XG4gICAgdmFyIG5hbWVJRHMgPSBbXTtcblxuICAgIHZhciBuYW1lc1dpdGhOdW1lcmljS2V5cyA9IHt9O1xuICAgIHZhciBuYW1lVGFibGVJZHMgPSByZXZlcnNlRGljdChuYW1lVGFibGVOYW1lcyk7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWVzKSB7XG4gICAgICAgIHZhciBpZCA9IG5hbWVUYWJsZUlkc1trZXldO1xuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWQgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lSUQgPSBwYXJzZUludChpZCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG5hbWVJRCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSB0YWJsZSBlbnRyeSBcIicgKyBrZXkgKyAnXCIgZG9lcyBub3QgZXhpc3QsIHNlZSBuYW1lVGFibGVOYW1lcyBmb3IgY29tcGxldGUgbGlzdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzV2l0aE51bWVyaWNLZXlzW25hbWVJRF0gPSBuYW1lc1trZXldO1xuICAgICAgICBuYW1lSURzLnB1c2gobmFtZUlEKTtcbiAgICB9XG5cbiAgICB2YXIgbWFjTGFuZ3VhZ2VJZHMgPSByZXZlcnNlRGljdChtYWNMYW5ndWFnZXMpO1xuICAgIHZhciB3aW5kb3dzTGFuZ3VhZ2VJZHMgPSByZXZlcnNlRGljdCh3aW5kb3dzTGFuZ3VhZ2VzKTtcblxuICAgIHZhciBuYW1lUmVjb3JkcyA9IFtdO1xuICAgIHZhciBzdHJpbmdQb29sID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZUlEID0gbmFtZUlEc1tpXTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IG5hbWVzV2l0aE51bWVyaWNLZXlzW25hbWVJRF07XG4gICAgICAgIGZvciAodmFyIGxhbmcgaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRyYW5zbGF0aW9uc1tsYW5nXTtcblxuICAgICAgICAgICAgLy8gRm9yIE1hY09TLCB3ZSB0cnkgdG8gZW1pdCB0aGUgbmFtZSBpbiB0aGUgZm9ybSB0aGF0IHdhcyBpbnRyb2R1Y2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgaW5pdGlhbCB2ZXJzaW9uIG9mIHRoZSBUcnVlVHlwZSBzcGVjIChpbiB0aGUgbGF0ZSAxOTgwcykuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGNhbiBmYWlsIGZvciB2YXJpb3VzIHJlYXNvbnM6IHRoZSByZXF1ZXN0ZWQgQkNQIDQ3XG4gICAgICAgICAgICAvLyBsYW5ndWFnZSBjb2RlIG1pZ2h0IG5vdCBoYXZlIGFuIG9sZC1zdHlsZSBNYWMgZXF1aXZhbGVudDtcbiAgICAgICAgICAgIC8vIHdlIG1pZ2h0IG5vdCBoYXZlIGEgY29kZWMgZm9yIHRoZSBuZWVkZWQgY2hhcmFjdGVyIGVuY29kaW5nO1xuICAgICAgICAgICAgLy8gb3IgdGhlIG5hbWUgbWlnaHQgY29udGFpbiBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIG9sZC1zdHlsZSBNYWNpbnRvc2ggZW5jb2RpbmcuIEluIGNhc2Ugb2YgZmFpbHVyZSwgd2UgZW1pdFxuICAgICAgICAgICAgLy8gdGhlIG5hbWUgaW4gYSBtb3JlIG1vZGVybiBmYXNoaW9uIChVbmljb2RlIGVuY29kaW5nIHdpdGggQkNQIDQ3XG4gICAgICAgICAgICAvLyBsYW5ndWFnZSB0YWdzKSB0aGF0IGlzIHJlY29nbml6ZWQgYnkgTWFjT1MgMTAuNSwgcmVsZWFzZWQgaW4gMjAwOS5cbiAgICAgICAgICAgIC8vIElmIGZvbnRzIHdlcmUgb25seSByZWFkIGJ5IG9wZXJhdGluZyBzeXN0ZW1zLCB3ZSBjb3VsZCBzaW1wbHlcbiAgICAgICAgICAgIC8vIGVtaXQgYWxsIG5hbWVzIGluIHRoZSBtb2Rlcm4gZm9ybTsgdGhpcyB3b3VsZCBiZSBtdWNoIGVhc2llci5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGFyZSBtYW55IGFwcGxpY2F0aW9ucyBhbmQgbGlicmFyaWVzIHRoYXQgcmVhZFxuICAgICAgICAgICAgLy8gJ25hbWUnIHRhYmxlcyBkaXJlY3RseSwgYW5kIHRoZXNlIHdpbGwgdXN1YWxseSBvbmx5IHJlY29nbml6ZVxuICAgICAgICAgICAgLy8gdGhlIGFuY2llbnQgZm9ybSAoc2lsZW50bHkgc2tpcHBpbmcgdGhlIHVucmVjb2duaXplZCBuYW1lcykuXG4gICAgICAgICAgICB2YXIgbWFjUGxhdGZvcm0gPSAxOyAgLy8gTWFjaW50b3NoXG4gICAgICAgICAgICB2YXIgbWFjTGFuZ3VhZ2UgPSBtYWNMYW5ndWFnZUlkc1tsYW5nXTtcbiAgICAgICAgICAgIHZhciBtYWNTY3JpcHQgPSBtYWNMYW5ndWFnZVRvU2NyaXB0W21hY0xhbmd1YWdlXTtcbiAgICAgICAgICAgIHZhciBtYWNFbmNvZGluZyA9IGdldEVuY29kaW5nKG1hY1BsYXRmb3JtLCBtYWNTY3JpcHQsIG1hY0xhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciBtYWNOYW1lID0gZW5jb2RlLk1BQ1NUUklORyh0ZXh0LCBtYWNFbmNvZGluZyk7XG4gICAgICAgICAgICBpZiAobWFjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFjUGxhdGZvcm0gPSAwOyAgLy8gVW5pY29kZVxuICAgICAgICAgICAgICAgIG1hY0xhbmd1YWdlID0gbHRhZy5pbmRleE9mKGxhbmcpO1xuICAgICAgICAgICAgICAgIGlmIChtYWNMYW5ndWFnZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbHRhZy5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hY1NjcmlwdCA9IDQ7ICAvLyBVbmljb2RlIDIuMCBhbmQgbGF0ZXJcbiAgICAgICAgICAgICAgICBtYWNOYW1lID0gZW5jb2RlLlVURjE2KHRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWFjTmFtZU9mZnNldCA9IGFkZFN0cmluZ1RvUG9vbChtYWNOYW1lLCBzdHJpbmdQb29sKTtcbiAgICAgICAgICAgIG5hbWVSZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJRCwgbWFjTmFtZS5sZW5ndGgsIG1hY05hbWVPZmZzZXQpKTtcblxuICAgICAgICAgICAgdmFyIHdpbkxhbmd1YWdlID0gd2luZG93c0xhbmd1YWdlSWRzW2xhbmddO1xuICAgICAgICAgICAgaWYgKHdpbkxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luTmFtZSA9IGVuY29kZS5VVEYxNih0ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgd2luTmFtZU9mZnNldCA9IGFkZFN0cmluZ1RvUG9vbCh3aW5OYW1lLCBzdHJpbmdQb29sKTtcbiAgICAgICAgICAgICAgICBuYW1lUmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKDMsIDEsIHdpbkxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUlELCB3aW5OYW1lLmxlbmd0aCwgd2luTmFtZU9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmFtZVJlY29yZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiAoKGEucGxhdGZvcm1JRCAtIGIucGxhdGZvcm1JRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5lbmNvZGluZ0lEIC0gYi5lbmNvZGluZ0lEKSB8fFxuICAgICAgICAgICAgICAgIChhLmxhbmd1YWdlSUQgLSBiLmxhbmd1YWdlSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEubmFtZUlEIC0gYi5uYW1lSUQpKTtcbiAgICB9KTtcblxuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCduYW1lJywgW1xuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVSZWNvcmRzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nT2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA2ICsgbmFtZVJlY29yZHMubGVuZ3RoICogMTJ9XG4gICAgXSk7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IG5hbWVSZWNvcmRzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZWNvcmRfJyArIHIsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogbmFtZVJlY29yZHNbcl19KTtcbiAgICB9XG5cbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcbiAgICByZXR1cm4gdDtcbn1cblxudmFyIF9uYW1lID0geyBwYXJzZTogcGFyc2VOYW1lVGFibGUsIG1ha2U6IG1ha2VOYW1lVGFibGUgfTtcblxuLy8gVGhlIGBPUy8yYCB0YWJsZSBjb250YWlucyBtZXRyaWNzIHJlcXVpcmVkIGluIE9wZW5UeXBlIGZvbnRzLlxuXG52YXIgdW5pY29kZVJhbmdlcyA9IFtcbiAgICB7YmVnaW46IDB4MDAwMCwgZW5kOiAweDAwN0Z9LCAvLyBCYXNpYyBMYXRpblxuICAgIHtiZWdpbjogMHgwMDgwLCBlbmQ6IDB4MDBGRn0sIC8vIExhdGluLTEgU3VwcGxlbWVudFxuICAgIHtiZWdpbjogMHgwMTAwLCBlbmQ6IDB4MDE3Rn0sIC8vIExhdGluIEV4dGVuZGVkLUFcbiAgICB7YmVnaW46IDB4MDE4MCwgZW5kOiAweDAyNEZ9LCAvLyBMYXRpbiBFeHRlbmRlZC1CXG4gICAge2JlZ2luOiAweDAyNTAsIGVuZDogMHgwMkFGfSwgLy8gSVBBIEV4dGVuc2lvbnNcbiAgICB7YmVnaW46IDB4MDJCMCwgZW5kOiAweDAyRkZ9LCAvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnNcbiAgICB7YmVnaW46IDB4MDMwMCwgZW5kOiAweDAzNkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3NcbiAgICB7YmVnaW46IDB4MDM3MCwgZW5kOiAweDAzRkZ9LCAvLyBHcmVlayBhbmQgQ29wdGljXG4gICAge2JlZ2luOiAweDJDODAsIGVuZDogMHgyQ0ZGfSwgLy8gQ29wdGljXG4gICAge2JlZ2luOiAweDA0MDAsIGVuZDogMHgwNEZGfSwgLy8gQ3lyaWxsaWNcbiAgICB7YmVnaW46IDB4MDUzMCwgZW5kOiAweDA1OEZ9LCAvLyBBcm1lbmlhblxuICAgIHtiZWdpbjogMHgwNTkwLCBlbmQ6IDB4MDVGRn0sIC8vIEhlYnJld1xuICAgIHtiZWdpbjogMHhBNTAwLCBlbmQ6IDB4QTYzRn0sIC8vIFZhaVxuICAgIHtiZWdpbjogMHgwNjAwLCBlbmQ6IDB4MDZGRn0sIC8vIEFyYWJpY1xuICAgIHtiZWdpbjogMHgwN0MwLCBlbmQ6IDB4MDdGRn0sIC8vIE5Lb1xuICAgIHtiZWdpbjogMHgwOTAwLCBlbmQ6IDB4MDk3Rn0sIC8vIERldmFuYWdhcmlcbiAgICB7YmVnaW46IDB4MDk4MCwgZW5kOiAweDA5RkZ9LCAvLyBCZW5nYWxpXG4gICAge2JlZ2luOiAweDBBMDAsIGVuZDogMHgwQTdGfSwgLy8gR3VybXVraGlcbiAgICB7YmVnaW46IDB4MEE4MCwgZW5kOiAweDBBRkZ9LCAvLyBHdWphcmF0aVxuICAgIHtiZWdpbjogMHgwQjAwLCBlbmQ6IDB4MEI3Rn0sIC8vIE9yaXlhXG4gICAge2JlZ2luOiAweDBCODAsIGVuZDogMHgwQkZGfSwgLy8gVGFtaWxcbiAgICB7YmVnaW46IDB4MEMwMCwgZW5kOiAweDBDN0Z9LCAvLyBUZWx1Z3VcbiAgICB7YmVnaW46IDB4MEM4MCwgZW5kOiAweDBDRkZ9LCAvLyBLYW5uYWRhXG4gICAge2JlZ2luOiAweDBEMDAsIGVuZDogMHgwRDdGfSwgLy8gTWFsYXlhbGFtXG4gICAge2JlZ2luOiAweDBFMDAsIGVuZDogMHgwRTdGfSwgLy8gVGhhaVxuICAgIHtiZWdpbjogMHgwRTgwLCBlbmQ6IDB4MEVGRn0sIC8vIExhb1xuICAgIHtiZWdpbjogMHgxMEEwLCBlbmQ6IDB4MTBGRn0sIC8vIEdlb3JnaWFuXG4gICAge2JlZ2luOiAweDFCMDAsIGVuZDogMHgxQjdGfSwgLy8gQmFsaW5lc2VcbiAgICB7YmVnaW46IDB4MTEwMCwgZW5kOiAweDExRkZ9LCAvLyBIYW5ndWwgSmFtb1xuICAgIHtiZWdpbjogMHgxRTAwLCBlbmQ6IDB4MUVGRn0sIC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWxcbiAgICB7YmVnaW46IDB4MUYwMCwgZW5kOiAweDFGRkZ9LCAvLyBHcmVlayBFeHRlbmRlZFxuICAgIHtiZWdpbjogMHgyMDAwLCBlbmQ6IDB4MjA2Rn0sIC8vIEdlbmVyYWwgUHVuY3R1YXRpb25cbiAgICB7YmVnaW46IDB4MjA3MCwgZW5kOiAweDIwOUZ9LCAvLyBTdXBlcnNjcmlwdHMgQW5kIFN1YnNjcmlwdHNcbiAgICB7YmVnaW46IDB4MjBBMCwgZW5kOiAweDIwQ0Z9LCAvLyBDdXJyZW5jeSBTeW1ib2xcbiAgICB7YmVnaW46IDB4MjBEMCwgZW5kOiAweDIwRkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRm9yIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjEwMCwgZW5kOiAweDIxNEZ9LCAvLyBMZXR0ZXJsaWtlIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjE1MCwgZW5kOiAweDIxOEZ9LCAvLyBOdW1iZXIgRm9ybXNcbiAgICB7YmVnaW46IDB4MjE5MCwgZW5kOiAweDIxRkZ9LCAvLyBBcnJvd3NcbiAgICB7YmVnaW46IDB4MjIwMCwgZW5kOiAweDIyRkZ9LCAvLyBNYXRoZW1hdGljYWwgT3BlcmF0b3JzXG4gICAge2JlZ2luOiAweDIzMDAsIGVuZDogMHgyM0ZGfSwgLy8gTWlzY2VsbGFuZW91cyBUZWNobmljYWxcbiAgICB7YmVnaW46IDB4MjQwMCwgZW5kOiAweDI0M0Z9LCAvLyBDb250cm9sIFBpY3R1cmVzXG4gICAge2JlZ2luOiAweDI0NDAsIGVuZDogMHgyNDVGfSwgLy8gT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cbiAgICB7YmVnaW46IDB4MjQ2MCwgZW5kOiAweDI0RkZ9LCAvLyBFbmNsb3NlZCBBbHBoYW51bWVyaWNzXG4gICAge2JlZ2luOiAweDI1MDAsIGVuZDogMHgyNTdGfSwgLy8gQm94IERyYXdpbmdcbiAgICB7YmVnaW46IDB4MjU4MCwgZW5kOiAweDI1OUZ9LCAvLyBCbG9jayBFbGVtZW50c1xuICAgIHtiZWdpbjogMHgyNUEwLCBlbmQ6IDB4MjVGRn0sIC8vIEdlb21ldHJpYyBTaGFwZXNcbiAgICB7YmVnaW46IDB4MjYwMCwgZW5kOiAweDI2RkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjcwMCwgZW5kOiAweDI3QkZ9LCAvLyBEaW5nYmF0c1xuICAgIHtiZWdpbjogMHgzMDAwLCBlbmQ6IDB4MzAzRn0sIC8vIENKSyBTeW1ib2xzIEFuZCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgzMDQwLCBlbmQ6IDB4MzA5Rn0sIC8vIEhpcmFnYW5hXG4gICAge2JlZ2luOiAweDMwQTAsIGVuZDogMHgzMEZGfSwgLy8gS2F0YWthbmFcbiAgICB7YmVnaW46IDB4MzEwMCwgZW5kOiAweDMxMkZ9LCAvLyBCb3BvbW9mb1xuICAgIHtiZWdpbjogMHgzMTMwLCBlbmQ6IDB4MzE4Rn0sIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cbiAgICB7YmVnaW46IDB4QTg0MCwgZW5kOiAweEE4N0Z9LCAvLyBQaGFncy1wYVxuICAgIHtiZWdpbjogMHgzMjAwLCBlbmQ6IDB4MzJGRn0sIC8vIEVuY2xvc2VkIENKSyBMZXR0ZXJzIEFuZCBNb250aHNcbiAgICB7YmVnaW46IDB4MzMwMCwgZW5kOiAweDMzRkZ9LCAvLyBDSksgQ29tcGF0aWJpbGl0eVxuICAgIHtiZWdpbjogMHhBQzAwLCBlbmQ6IDB4RDdBRn0sIC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4RDgwMCwgZW5kOiAweERGRkZ9LCAvLyBOb24tUGxhbmUgMCAqXG4gICAge2JlZ2luOiAweDEwOTAwLCBlbmQ6IDB4MTA5MUZ9LCAvLyBQaG9lbmljaWFcbiAgICB7YmVnaW46IDB4NEUwMCwgZW5kOiAweDlGRkZ9LCAvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzXG4gICAge2JlZ2luOiAweEUwMDAsIGVuZDogMHhGOEZGfSwgLy8gUHJpdmF0ZSBVc2UgQXJlYSAocGxhbmUgMClcbiAgICB7YmVnaW46IDB4MzFDMCwgZW5kOiAweDMxRUZ9LCAvLyBDSksgU3Ryb2tlc1xuICAgIHtiZWdpbjogMHhGQjAwLCBlbmQ6IDB4RkI0Rn0sIC8vIEFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXG4gICAge2JlZ2luOiAweEZCNTAsIGVuZDogMHhGREZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXG4gICAge2JlZ2luOiAweEZFMjAsIGVuZDogMHhGRTJGfSwgLy8gQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICB7YmVnaW46IDB4RkUxMCwgZW5kOiAweEZFMUZ9LCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRTUwLCBlbmQ6IDB4RkU2Rn0sIC8vIFNtYWxsIEZvcm0gVmFyaWFudHNcbiAgICB7YmVnaW46IDB4RkU3MCwgZW5kOiAweEZFRkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICB7YmVnaW46IDB4RkYwMCwgZW5kOiAweEZGRUZ9LCAvLyBIYWxmd2lkdGggQW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRkYwLCBlbmQ6IDB4RkZGRn0sIC8vIFNwZWNpYWxzXG4gICAge2JlZ2luOiAweDBGMDAsIGVuZDogMHgwRkZGfSwgLy8gVGliZXRhblxuICAgIHtiZWdpbjogMHgwNzAwLCBlbmQ6IDB4MDc0Rn0sIC8vIFN5cmlhY1xuICAgIHtiZWdpbjogMHgwNzgwLCBlbmQ6IDB4MDdCRn0sIC8vIFRoYWFuYVxuICAgIHtiZWdpbjogMHgwRDgwLCBlbmQ6IDB4MERGRn0sIC8vIFNpbmhhbGFcbiAgICB7YmVnaW46IDB4MTAwMCwgZW5kOiAweDEwOUZ9LCAvLyBNeWFubWFyXG4gICAge2JlZ2luOiAweDEyMDAsIGVuZDogMHgxMzdGfSwgLy8gRXRoaW9waWNcbiAgICB7YmVnaW46IDB4MTNBMCwgZW5kOiAweDEzRkZ9LCAvLyBDaGVyb2tlZVxuICAgIHtiZWdpbjogMHgxNDAwLCBlbmQ6IDB4MTY3Rn0sIC8vIFVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcbiAgICB7YmVnaW46IDB4MTY4MCwgZW5kOiAweDE2OUZ9LCAvLyBPZ2hhbVxuICAgIHtiZWdpbjogMHgxNkEwLCBlbmQ6IDB4MTZGRn0sIC8vIFJ1bmljXG4gICAge2JlZ2luOiAweDE3ODAsIGVuZDogMHgxN0ZGfSwgLy8gS2htZXJcbiAgICB7YmVnaW46IDB4MTgwMCwgZW5kOiAweDE4QUZ9LCAvLyBNb25nb2xpYW5cbiAgICB7YmVnaW46IDB4MjgwMCwgZW5kOiAweDI4RkZ9LCAvLyBCcmFpbGxlIFBhdHRlcm5zXG4gICAge2JlZ2luOiAweEEwMDAsIGVuZDogMHhBNDhGfSwgLy8gWWkgU3lsbGFibGVzXG4gICAge2JlZ2luOiAweDE3MDAsIGVuZDogMHgxNzFGfSwgLy8gVGFnYWxvZ1xuICAgIHtiZWdpbjogMHgxMDMwMCwgZW5kOiAweDEwMzJGfSwgLy8gT2xkIEl0YWxpY1xuICAgIHtiZWdpbjogMHgxMDMzMCwgZW5kOiAweDEwMzRGfSwgLy8gR290aGljXG4gICAge2JlZ2luOiAweDEwNDAwLCBlbmQ6IDB4MTA0NEZ9LCAvLyBEZXNlcmV0XG4gICAge2JlZ2luOiAweDFEMDAwLCBlbmQ6IDB4MUQwRkZ9LCAvLyBCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXG4gICAge2JlZ2luOiAweDFENDAwLCBlbmQ6IDB4MUQ3RkZ9LCAvLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4RkYwMDAsIGVuZDogMHhGRkZGRH0sIC8vIFByaXZhdGUgVXNlIChwbGFuZSAxNSlcbiAgICB7YmVnaW46IDB4RkUwMCwgZW5kOiAweEZFMEZ9LCAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG4gICAge2JlZ2luOiAweEUwMDAwLCBlbmQ6IDB4RTAwN0Z9LCAvLyBUYWdzXG4gICAge2JlZ2luOiAweDE5MDAsIGVuZDogMHgxOTRGfSwgLy8gTGltYnVcbiAgICB7YmVnaW46IDB4MTk1MCwgZW5kOiAweDE5N0Z9LCAvLyBUYWkgTGVcbiAgICB7YmVnaW46IDB4MTk4MCwgZW5kOiAweDE5REZ9LCAvLyBOZXcgVGFpIEx1ZVxuICAgIHtiZWdpbjogMHgxQTAwLCBlbmQ6IDB4MUExRn0sIC8vIEJ1Z2luZXNlXG4gICAge2JlZ2luOiAweDJDMDAsIGVuZDogMHgyQzVGfSwgLy8gR2xhZ29saXRpY1xuICAgIHtiZWdpbjogMHgyRDMwLCBlbmQ6IDB4MkQ3Rn0sIC8vIFRpZmluYWdoXG4gICAge2JlZ2luOiAweDREQzAsIGVuZDogMHg0REZGfSwgLy8gWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4QTgwMCwgZW5kOiAweEE4MkZ9LCAvLyBTeWxvdGkgTmFncmlcbiAgICB7YmVnaW46IDB4MTAwMDAsIGVuZDogMHgxMDA3Rn0sIC8vIExpbmVhciBCIFN5bGxhYmFyeVxuICAgIHtiZWdpbjogMHgxMDE0MCwgZW5kOiAweDEwMThGfSwgLy8gQW5jaWVudCBHcmVlayBOdW1iZXJzXG4gICAge2JlZ2luOiAweDEwMzgwLCBlbmQ6IDB4MTAzOUZ9LCAvLyBVZ2FyaXRpY1xuICAgIHtiZWdpbjogMHgxMDNBMCwgZW5kOiAweDEwM0RGfSwgLy8gT2xkIFBlcnNpYW5cbiAgICB7YmVnaW46IDB4MTA0NTAsIGVuZDogMHgxMDQ3Rn0sIC8vIFNoYXZpYW5cbiAgICB7YmVnaW46IDB4MTA0ODAsIGVuZDogMHgxMDRBRn0sIC8vIE9zbWFueWFcbiAgICB7YmVnaW46IDB4MTA4MDAsIGVuZDogMHgxMDgzRn0sIC8vIEN5cHJpb3QgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwQTAwLCBlbmQ6IDB4MTBBNUZ9LCAvLyBLaGFyb3NodGhpXG4gICAge2JlZ2luOiAweDFEMzAwLCBlbmQ6IDB4MUQzNUZ9LCAvLyBUYWkgWHVhbiBKaW5nIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTIwMDAsIGVuZDogMHgxMjNGRn0sIC8vIEN1bmVpZm9ybVxuICAgIHtiZWdpbjogMHgxRDM2MCwgZW5kOiAweDFEMzdGfSwgLy8gQ291bnRpbmcgUm9kIE51bWVyYWxzXG4gICAge2JlZ2luOiAweDFCODAsIGVuZDogMHgxQkJGfSwgLy8gU3VuZGFuZXNlXG4gICAge2JlZ2luOiAweDFDMDAsIGVuZDogMHgxQzRGfSwgLy8gTGVwY2hhXG4gICAge2JlZ2luOiAweDFDNTAsIGVuZDogMHgxQzdGfSwgLy8gT2wgQ2hpa2lcbiAgICB7YmVnaW46IDB4QTg4MCwgZW5kOiAweEE4REZ9LCAvLyBTYXVyYXNodHJhXG4gICAge2JlZ2luOiAweEE5MDAsIGVuZDogMHhBOTJGfSwgLy8gS2F5YWggTGlcbiAgICB7YmVnaW46IDB4QTkzMCwgZW5kOiAweEE5NUZ9LCAvLyBSZWphbmdcbiAgICB7YmVnaW46IDB4QUEwMCwgZW5kOiAweEFBNUZ9LCAvLyBDaGFtXG4gICAge2JlZ2luOiAweDEwMTkwLCBlbmQ6IDB4MTAxQ0Z9LCAvLyBBbmNpZW50IFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTAxRDAsIGVuZDogMHgxMDFGRn0sIC8vIFBoYWlzdG9zIERpc2NcbiAgICB7YmVnaW46IDB4MTAyQTAsIGVuZDogMHgxMDJERn0sIC8vIENhcmlhblxuICAgIHtiZWdpbjogMHgxRjAzMCwgZW5kOiAweDFGMDlGfSAgLy8gRG9taW5vIFRpbGVzXG5dO1xuXG5mdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2UodW5pY29kZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pY29kZVJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB1bmljb2RlUmFuZ2VzW2ldO1xuICAgICAgICBpZiAodW5pY29kZSA+PSByYW5nZS5iZWdpbiAmJiB1bmljb2RlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlT1MyVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb3MyID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuXG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuXG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcbiAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi5zQ2FwSGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c01heENvbnRlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9zMjtcbn1cblxuZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB4MDAwM30sXG4gICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpZHRoQ2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMTQwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2NTB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ3OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDl9LFxuICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRQb3NpdGlvbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyNTh9LFxuICAgICAgICB7bmFtZTogJ3NGYW1pbHlDbGFzcycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYldlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlN0cm9rZVZhcmlhdGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYk1pZGxpbmUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhY2hWZW5kSUQnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6ICdYWFhYJ30sXG4gICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTGFzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0xpbmVHYXAnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NDYXBIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTWF4Q29udGV4dCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxudmFyIG9zMiA9IHsgcGFyc2U6IHBhcnNlT1MyVGFibGUsIG1ha2U6IG1ha2VPUzJUYWJsZSwgdW5pY29kZVJhbmdlczogdW5pY29kZVJhbmdlcywgZ2V0VW5pY29kZVJhbmdlOiBnZXRVbmljb2RlUmFuZ2UgfTtcblxuLy8gVGhlIGBwb3N0YCB0YWJsZSBzdG9yZXMgYWRkaXRpb25hbCBQb3N0U2NyaXB0IGluZm9ybWF0aW9uLCBzdWNoIGFzIGdseXBoIG5hbWVzLlxuXG4vLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlUG9zdFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBvc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHBvc3QudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgcG9zdC5pdGFsaWNBbmdsZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHBvc3QudW5kZXJsaW5lUG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LnVuZGVybGluZVRoaWNrbmVzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QuaXNGaXhlZFBpdGNoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcG9zdC5uYW1lcyA9IHN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleFtpXSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zdC5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdID49IHN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdC5uYW1lcy5wdXNoKHAucGFyc2VTdHJpbmcobmFtZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0Lm9mZnNldFtpJDJdID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG5mdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDMwMDAwfSxcbiAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICBdKTtcbn1cblxudmFyIHBvc3QgPSB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSwgbWFrZTogbWFrZVBvc3RUYWJsZSB9O1xuXG4vLyBUaGUgYEdTVUJgIHRhYmxlIGNvbnRhaW5zIGxpZ2F0dXJlcywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG52YXIgc3VidGFibGVQYXJzZXJzID0gbmV3IEFycmF5KDkpOyAgICAgICAgIC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNTU1xuc3VidGFibGVQYXJzZXJzWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgZGVsdGFHbHlwaElkOiB0aGlzLnBhcnNlVVNob3J0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgc3Vic3RpdHV0ZTogdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNNU1xuc3VidGFibGVQYXJzZXJzWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgTXVsdGlwbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIHNlcXVlbmNlczogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNBU1xuc3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5zdWJ0YWJsZVBhcnNlcnNbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdhdHVyZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlnR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlVVNob3J0KCkgLSAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICB9O1xufTtcblxudmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG4gICAgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnRcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ1NGXG5zdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlczogdGhpcy5wYXJzZUxpc3QoZ2x5cGhDb3VudCwgUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ0NcbnN1YnRhYmxlUGFyc2Vyc1s2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcbiAgICAgICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5zdWJ0YWJsZVBhcnNlcnNbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuICAgICAgICBleHRlbnNpb246IHN1YnRhYmxlUGFyc2Vyc1tleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlcilcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNSQ0NTXG5zdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBSZXZlcnNlIENoYWluaW5nIENvbnRleHR1YWwgU2luZ2xlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgc3Vic3RpdHV0ZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9nc3ViLmh0bVxuZnVuY3Rpb24gcGFyc2VHc3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbi8vIEdTVUIgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgc3VidGFibGVNYWtlcnMgPSBuZXcgQXJyYXkoOSk7XG5cbnN1YnRhYmxlTWFrZXJzWzFdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDEoc3VidGFibGUpIHtcbiAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2RlbHRhR2x5cGhJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuZGVsdGFHbHlwaElkfVxuICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdzdWJzdGl0dXRlJywgc3VidGFibGUuc3Vic3RpdHV0ZSkpKTtcbiAgICB9XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1syXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAyKHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgMiBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdzZXFTZXQnLCBzdWJ0YWJsZS5zZXF1ZW5jZXMsIGZ1bmN0aW9uKHNlcXVlbmNlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3NlcXVlbmNlU2V0VGFibGUnLCB0YWJsZS51c2hvcnRMaXN0KCdzZXF1ZW5jZScsIHNlcXVlbmNlU2V0KSk7XG4gICAgfSkpKTtcbn07XG5cbnN1YnRhYmxlTWFrZXJzWzNdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDMoc3VidGFibGUpIHtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSAzIHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2FsdFNldCcsIHN1YnRhYmxlLmFsdGVybmF0ZVNldHMsIGZ1bmN0aW9uKGFsdGVybmF0ZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdhbHRlcm5hdGVTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ2FsdGVybmF0ZScsIGFsdGVybmF0ZVNldCkpO1xuICAgIH0pKSk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1s0XSA9IGZ1bmN0aW9uIG1ha2VMb29rdXA0KHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgNCBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdsaWdTZXQnLCBzdWJ0YWJsZS5saWdhdHVyZVNldHMsIGZ1bmN0aW9uKGxpZ2F0dXJlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2xpZ2F0dXJlJywgbGlnYXR1cmVTZXQsIGZ1bmN0aW9uKGxpZ2F0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdsaWdhdHVyZVRhYmxlJyxcbiAgICAgICAgICAgICAgICBbe25hbWU6ICdsaWdHbHlwaCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlnYXR1cmUubGlnR2x5cGh9XVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnY29tcG9uZW50JywgbGlnYXR1cmUuY29tcG9uZW50cywgbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggKyAxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pKTtcbiAgICB9KSkpO1xufTtcblxuc3VidGFibGVNYWtlcnNbNl0gPSBmdW5jdGlvbiBtYWtlTG9va3VwNihzdWJ0YWJsZSkge1xuICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICB2YXIgcmV0dXJuVGFibGUgPSBuZXcgdGFibGUuVGFibGUoJ2NoYWluQ29udGV4dFRhYmxlJywgW1xuICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuc3Vic3RGb3JtYXR9LFxuICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2NoYWluUnVsZVNldCcsIHN1YnRhYmxlLmNoYWluUnVsZVNldHMsIGZ1bmN0aW9uKGNoYWluUnVsZVNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnY2hhaW5SdWxlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2NoYWluUnVsZScsIGNoYWluUnVsZVNldCwgZnVuY3Rpb24oY2hhaW5SdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlRGF0YSA9IHRhYmxlLnVzaG9ydExpc3QoJ2JhY2t0cmFja0dseXBoJywgY2hhaW5SdWxlLmJhY2t0cmFjaywgY2hhaW5SdWxlLmJhY2t0cmFjay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnaW5wdXRHbHlwaCcsIGNoYWluUnVsZS5pbnB1dCwgY2hhaW5SdWxlLmlucHV0Lmxlbmd0aCArIDEpKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ2xvb2thaGVhZEdseXBoJywgY2hhaW5SdWxlLmxvb2thaGVhZCwgY2hhaW5SdWxlLmxvb2thaGVhZC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ3N1YnN0aXR1dGlvbicsIFtdLCBjaGFpblJ1bGUubG9va3VwUmVjb3Jkcy5sZW5ndGgpKTtcblxuICAgICAgICAgICAgICAgIGNoYWluUnVsZS5sb29rdXBSZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZURhdGEgPSB0YWJsZURhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoe25hbWU6ICdzZXF1ZW5jZUluZGV4JyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcmVjb3JkLnNlcXVlbmNlSW5kZXh9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh7bmFtZTogJ2xvb2t1cExpc3RJbmRleCcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHJlY29yZC5sb29rdXBMaXN0SW5kZXh9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdjaGFpblJ1bGVUYWJsZScsIHRhYmxlRGF0YSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiByZXR1cm5UYWJsZTtcbiAgICB9IGVsc2UgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJ2xvb2t1cCB0eXBlIDYgZm9ybWF0IDIgaXMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG4gICAgfSBlbHNlIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICB2YXIgdGFibGVEYXRhID0gW1xuICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuc3Vic3RGb3JtYXR9IF07XG5cbiAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdiYWNrdHJhY2tHbHlwaENvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGh9KTtcbiAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UuZm9yRWFjaChmdW5jdGlvbiAoY292ZXJhZ2UsIGkpIHtcbiAgICAgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnYmFja3RyYWNrQ292ZXJhZ2UnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShjb3ZlcmFnZSl9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnaW5wdXRHbHlwaENvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aH0pO1xuICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmZvckVhY2goZnVuY3Rpb24gKGNvdmVyYWdlLCBpKSB7XG4gICAgICAgICAgICB0YWJsZURhdGEucHVzaCh7bmFtZTogJ2lucHV0Q292ZXJhZ2UnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShjb3ZlcmFnZSl9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnbG9va2FoZWFkR2x5cGhDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RofSk7XG4gICAgICAgIHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmZvckVhY2goZnVuY3Rpb24gKGNvdmVyYWdlLCBpKSB7XG4gICAgICAgICAgICB0YWJsZURhdGEucHVzaCh7bmFtZTogJ2xvb2thaGVhZENvdmVyYWdlJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2UoY292ZXJhZ2UpfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnc3Vic3RpdHV0aW9uQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmxvb2t1cFJlY29yZHMubGVuZ3RofSk7XG4gICAgICAgIHN1YnRhYmxlLmxvb2t1cFJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkLCBpKSB7XG4gICAgICAgICAgICB0YWJsZURhdGEgPSB0YWJsZURhdGFcbiAgICAgICAgICAgICAgICAuY29uY2F0KHtuYW1lOiAnc2VxdWVuY2VJbmRleCcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHJlY29yZC5zZXF1ZW5jZUluZGV4fSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHtuYW1lOiAnbG9va3VwTGlzdEluZGV4JyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcmVjb3JkLmxvb2t1cExpc3RJbmRleH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmV0dXJuVGFibGUkMSA9IG5ldyB0YWJsZS5UYWJsZSgnY2hhaW5Db250ZXh0VGFibGUnLCB0YWJsZURhdGEpO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5UYWJsZSQxO1xuICAgIH1cblxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJ2xvb2t1cCB0eXBlIDYgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLicpO1xufTtcblxuZnVuY3Rpb24gbWFrZUdzdWJUYWJsZShnc3ViKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1NVQicsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3N1Yi5zY3JpcHRzKX0sXG4gICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdzdWIuZmVhdHVyZXMpfSxcbiAgICAgICAge25hbWU6ICdsb29rdXBzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Mb29rdXBMaXN0KGdzdWIubG9va3Vwcywgc3VidGFibGVNYWtlcnMpfVxuICAgIF0pO1xufVxuXG52YXIgZ3N1YiA9IHsgcGFyc2U6IHBhcnNlR3N1YlRhYmxlLCBtYWtlOiBtYWtlR3N1YlRhYmxlIH07XG5cbi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG4vLyBQYXJzZSB0aGUgbWV0YWRhdGEgYG1ldGFgIHRhYmxlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNm1ldGEuaHRtbFxuZnVuY3Rpb24gcGFyc2VNZXRhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBNRVRBIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgcC5wYXJzZVVMb25nKCk7IC8vIGZsYWdzIC0gY3VycmVudGx5IHVudXNlZCBhbmQgc2V0IHRvIDBcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gdGFibGVPZmZzZXRcbiAgICB2YXIgbnVtRGF0YU1hcHMgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciB0YWdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhTWFwczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSBwLnBhcnNlVGFnKCk7XG4gICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGVjb2RlLlVURjgoZGF0YSwgc3RhcnQgKyBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcblxuICAgICAgICB0YWdzW3RhZ10gPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gbWFrZU1ldGFUYWJsZSh0YWdzKSB7XG4gICAgdmFyIG51bVRhZ3MgPSBPYmplY3Qua2V5cyh0YWdzKS5sZW5ndGg7XG4gICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcbiAgICB2YXIgc3RyaW5nUG9vbE9mZnNldCA9IDE2ICsgbnVtVGFncyAqIDEyO1xuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbWV0YScsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0fSxcbiAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG51bVRhZ3N9XG4gICAgXSk7XG5cbiAgICBmb3IgKHZhciB0YWcgaW4gdGFncykge1xuICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5sZW5ndGg7XG4gICAgICAgIHN0cmluZ1Bvb2wgKz0gdGFnc1t0YWddO1xuXG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3RhZyAnICsgdGFnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZ30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdvZmZzZXQgJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXQgKyBwb3N9KTtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVuZ3RoICcgKyB0YWcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiB0YWdzW3RhZ10ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5nUG9vbCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG1ldGEgPSB7IHBhcnNlOiBwYXJzZU1ldGFUYWJsZSwgbWFrZTogbWFrZU1ldGFUYWJsZSB9O1xuXG4vLyBUaGUgYHNmbnRgIHdyYXBwZXIgcHJvdmlkZXMgb3JnYW5pemF0aW9uIGZvciB0aGUgdGFibGVzIGluIHRoZSBmb250LlxuXG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSB8IDA7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGVja1N1bShieXRlcykge1xuICAgIHdoaWxlIChieXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBzdW0gKz0gKGJ5dGVzW2ldIDw8IDI0KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgM10pO1xuICAgIH1cblxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ1RhYmxlIFJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICd0YWcnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZyAhPT0gdW5kZWZpbmVkID8gdGFnIDogJyd9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNoZWNrU3VtICE9PSB1bmRlZmluZWQgPyBjaGVja1N1bSA6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9mZnNldCA6IDB9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBsZW5ndGggIT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IDB9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZm50VGFibGUodGFibGVzKSB7XG4gICAgdmFyIHNmbnQgPSBuZXcgdGFibGUuVGFibGUoJ3NmbnQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdUQUcnLCB2YWx1ZTogJ09UVE8nfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIHNmbnQudGFibGVzID0gdGFibGVzO1xuICAgIHNmbnQubnVtVGFibGVzID0gdGFibGVzLmxlbmd0aDtcbiAgICB2YXIgaGlnaGVzdFBvd2VyT2YyID0gTWF0aC5wb3coMiwgbG9nMihzZm50Lm51bVRhYmxlcykpO1xuICAgIHNmbnQuc2VhcmNoUmFuZ2UgPSAxNiAqIGhpZ2hlc3RQb3dlck9mMjtcbiAgICBzZm50LmVudHJ5U2VsZWN0b3IgPSBsb2cyKGhpZ2hlc3RQb3dlck9mMik7XG4gICAgc2ZudC5yYW5nZVNoaWZ0ID0gc2ZudC5udW1UYWJsZXMgKiAxNiAtIHNmbnQuc2VhcmNoUmFuZ2U7XG5cbiAgICB2YXIgcmVjb3JkRmllbGRzID0gW107XG4gICAgdmFyIHRhYmxlRmllbGRzID0gW107XG5cbiAgICB2YXIgb2Zmc2V0ID0gc2ZudC5zaXplT2YoKSArIChtYWtlVGFibGVSZWNvcmQoKS5zaXplT2YoKSAqIHNmbnQubnVtVGFibGVzKTtcbiAgICB3aGlsZSAob2Zmc2V0ICUgNCAhPT0gMCkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHQgPSB0YWJsZXNbaV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KHQudGFibGVOYW1lLmxlbmd0aCA9PT0gNCwgJ1RhYmxlIG5hbWUnICsgdC50YWJsZU5hbWUgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgICAgIHZhciB0YWJsZUxlbmd0aCA9IHQuc2l6ZU9mKCk7XG4gICAgICAgIHZhciB0YWJsZVJlY29yZCA9IG1ha2VUYWJsZVJlY29yZCh0LnRhYmxlTmFtZSwgY29tcHV0ZUNoZWNrU3VtKHQuZW5jb2RlKCkpLCBvZmZzZXQsIHRhYmxlTGVuZ3RoKTtcbiAgICAgICAgcmVjb3JkRmllbGRzLnB1c2goe25hbWU6IHRhYmxlUmVjb3JkLnRhZyArICcgVGFibGUgUmVjb3JkJywgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiB0YWJsZVJlY29yZH0pO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiB0LnRhYmxlTmFtZSArICcgdGFibGUnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbihyMSwgcjIpIHtcbiAgICAgICAgaWYgKHIxLnZhbHVlLnRhZyA+IHIyLnZhbHVlLnRhZykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHJlY29yZEZpZWxkcyk7XG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQodGFibGVGaWVsZHMpO1xuICAgIHJldHVybiBzZm50O1xufVxuXG4vLyBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgY2hhcmFjdGVyLiBJZiB0aGUgc3RyaW5nIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJhY3RlclxuLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIG1ldHJpY3MgZm9yIHRoZSBmaXJzdCBhdmFpbGFibGUgY2hhcmFjdGVyLlxuLy8gWW91IGNhbiBwcm92aWRlIG9wdGlvbmFsIGZhbGxiYWNrIG1ldHJpY3MgaWYgbm8gY2hhcmFjdGVycyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gbWV0cmljc0ZvckNoYXIoZm9udCwgY2hhcnMsIG5vdEZvdW5kTWV0cmljcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBmb250LmNoYXJUb0dseXBoSW5kZXgoY2hhcnNbaV0pO1xuICAgICAgICBpZiAoZ2x5cGhJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm90Rm91bmRNZXRyaWNzO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHZzLmxlbmd0aDtcbn1cblxuLy8gQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuLy8gVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG5mdW5jdGlvbiBmb250VG9TZm50VGFibGUoZm9udCkge1xuICAgIHZhciB4TWlucyA9IFtdO1xuICAgIHZhciB5TWlucyA9IFtdO1xuICAgIHZhciB4TWF4cyA9IFtdO1xuICAgIHZhciB5TWF4cyA9IFtdO1xuICAgIHZhciBhZHZhbmNlV2lkdGhzID0gW107XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgcmlnaHRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgZmlyc3RDaGFySW5kZXg7XG4gICAgdmFyIGxhc3RDaGFySW5kZXggPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTEgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTIgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTMgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciB1bmljb2RlID0gZ2x5cGgudW5pY29kZSB8IDA7XG5cbiAgICAgICAgaWYgKGlzTmFOKGdseXBoLmFkdmFuY2VXaWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2x5cGggJyArIGdseXBoLm5hbWUgKyAnICgnICsgaSArICcpOiBhZHZhbmNlV2lkdGggaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgLm5vdGRlZiBjaGFyXG4gICAgICAgICAgICBpZiAodW5pY29kZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJJbmRleCA9IHVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdENoYXJJbmRleCA8IHVuaWNvZGUpIHtcbiAgICAgICAgICAgIGxhc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gb3MyLmdldFVuaWNvZGVSYW5nZSh1bmljb2RlKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMzIpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMSB8PSAxIDw8IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgNjQpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMiB8PSAxIDw8IHBvc2l0aW9uIC0gMzI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCA5Nikge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UzIHw9IDEgPDwgcG9zaXRpb24gLSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDEyMykge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2U0IHw9IDEgPDwgcG9zaXRpb24gLSA5NjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSByYW5nZXMgYml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIHsgY29udGludWU7IH1cbiAgICAgICAgdmFyIG1ldHJpY3MgPSBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHhNaW5zLnB1c2gobWV0cmljcy54TWluKTtcbiAgICAgICAgeU1pbnMucHVzaChtZXRyaWNzLnlNaW4pO1xuICAgICAgICB4TWF4cy5wdXNoKG1ldHJpY3MueE1heCk7XG4gICAgICAgIHlNYXhzLnB1c2gobWV0cmljcy55TWF4KTtcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nKTtcbiAgICAgICAgcmlnaHRTaWRlQmVhcmluZ3MucHVzaChtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcpO1xuICAgICAgICBhZHZhbmNlV2lkdGhzLnB1c2goZ2x5cGguYWR2YW5jZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGZvbnQuYXNjZW5kZXI7XG4gICAgZ2xvYmFscy5kZXNjZW5kZXIgPSBmb250LmRlc2NlbmRlcjtcblxuICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuICAgICAgICBmbGFnczogMywgLy8gMDAwMDAwMTEgKGJhc2VsaW5lIGZvciBmb250IGF0IHk9MDsgbGVmdCBzaWRlYmVhcmluZyBwb2ludCBhdCB4PTApXG4gICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgeE1pbjogZ2xvYmFscy54TWluLFxuICAgICAgICB5TWluOiBnbG9iYWxzLnlNaW4sXG4gICAgICAgIHhNYXg6IGdsb2JhbHMueE1heCxcbiAgICAgICAgeU1heDogZ2xvYmFscy55TWF4LFxuICAgICAgICBsb3dlc3RSZWNQUEVNOiAzLFxuICAgICAgICBjcmVhdGVkVGltZXN0YW1wOiBmb250LmNyZWF0ZWRUaW1lc3RhbXBcbiAgICB9KTtcblxuICAgIHZhciBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB4QXZnQ2hhcldpZHRoOiBNYXRoLnJvdW5kKGdsb2JhbHMuYWR2YW5jZVdpZHRoQXZnKSxcbiAgICAgICAgdXNGaXJzdENoYXJJbmRleDogZmlyc3RDaGFySW5kZXgsXG4gICAgICAgIHVzTGFzdENoYXJJbmRleDogbGFzdENoYXJJbmRleCxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UxOiB1bFVuaWNvZGVSYW5nZTEsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMjogdWxVbmljb2RlUmFuZ2UyLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTM6IHVsVW5pY29kZVJhbmdlMyxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2U0OiB1bFVuaWNvZGVSYW5nZTQsXG4gICAgICAgIC8vIFNlZSBodHRwOi8vdHlwb3BoaWxlLmNvbS9ub2RlLzEzMDgxIGZvciBtb3JlIGluZm8gb24gdmVydGljYWwgbWV0cmljcy5cbiAgICAgICAgLy8gV2UgZ2V0IG1ldHJpY3MgZm9yIHR5cGljYWwgY2hhcmFjdGVycyAoc3VjaCBhcyBcInhcIiBmb3IgeEhlaWdodCkuXG4gICAgICAgIC8vIFdlIHByb3ZpZGUgc29tZSBmYWxsYmFjayBjaGFyYWN0ZXJzIGlmIGNoYXJhY3RlcnMgYXJlIHVuYXZhaWxhYmxlOiB0aGVpclxuICAgICAgICAvLyBvcmRlcmluZyB3YXMgY2hvc2VuIGV4cGVyaW1lbnRhbGx5LlxuICAgICAgICBzVHlwb0FzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuICAgICAgICBzVHlwb0Rlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHNUeXBvTGluZUdhcDogMCxcbiAgICAgICAgdXNXaW5Bc2NlbnQ6IGdsb2JhbHMueU1heCxcbiAgICAgICAgdXNXaW5EZXNjZW50OiBNYXRoLmFicyhnbG9iYWxzLnlNaW4pLFxuICAgICAgICB1bENvZGVQYWdlUmFuZ2UxOiAxLCAvLyBGSVhNRTogaGFyZC1jb2RlIExhdGluIDEgc3VwcG9ydCBmb3Igbm93XG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiBNYXRoLnJvdW5kKGdsb2JhbHMuYXNjZW5kZXIgLyAyKX0pLnlNYXgsXG4gICAgICAgIHNDYXBIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICdISUtMRUZKTU5UWkJEUFJBR09RU1VWV1hZJywgZ2xvYmFscykueU1heCxcbiAgICAgICAgdXNEZWZhdWx0Q2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAsIC8vIFVzZSBzcGFjZSBhcyB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgdXNCcmVha0NoYXI6IGZvbnQuaGFzQ2hhcignICcpID8gMzIgOiAwLCAvLyBVc2Ugc3BhY2UgYXMgdGhlIGJyZWFrIGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuICAgIH0sIGZvbnQudGFibGVzLm9zMikpO1xuXG4gICAgdmFyIGhtdHhUYWJsZSA9IGhtdHgubWFrZShmb250LmdseXBocyk7XG4gICAgdmFyIGNtYXBUYWJsZSA9IGNtYXAubWFrZShmb250LmdseXBocyk7XG5cbiAgICB2YXIgZW5nbGlzaEZhbWlseU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgdmFyIGVuZ2xpc2hTdHlsZU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250U3ViZmFtaWx5Jyk7XG4gICAgdmFyIGVuZ2xpc2hGdWxsTmFtZSA9IGVuZ2xpc2hGYW1pbHlOYW1lICsgJyAnICsgZW5nbGlzaFN0eWxlTmFtZTtcbiAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdwb3N0U2NyaXB0TmFtZScpO1xuICAgIGlmICghcG9zdFNjcmlwdE5hbWUpIHtcbiAgICAgICAgcG9zdFNjcmlwdE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgZW5nbGlzaFN0eWxlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIGZvbnQubmFtZXMpIHtcbiAgICAgICAgbmFtZXNbbl0gPSBmb250Lm5hbWVzW25dO1xuICAgIH1cblxuICAgIGlmICghbmFtZXMudW5pcXVlSUQpIHtcbiAgICAgICAgbmFtZXMudW5pcXVlSUQgPSB7ZW46IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ21hbnVmYWN0dXJlcicpICsgJzonICsgZW5nbGlzaEZ1bGxOYW1lfTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnBvc3RTY3JpcHROYW1lKSB7XG4gICAgICAgIG5hbWVzLnBvc3RTY3JpcHROYW1lID0ge2VuOiBwb3N0U2NyaXB0TmFtZX07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wcmVmZXJyZWRGYW1pbHkpIHtcbiAgICAgICAgbmFtZXMucHJlZmVycmVkRmFtaWx5ID0gZm9udC5uYW1lcy5mb250RmFtaWx5O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucHJlZmVycmVkU3ViZmFtaWx5KSB7XG4gICAgICAgIG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSA9IGZvbnQubmFtZXMuZm9udFN1YmZhbWlseTtcbiAgICB9XG5cbiAgICB2YXIgbGFuZ3VhZ2VUYWdzID0gW107XG4gICAgdmFyIG5hbWVUYWJsZSA9IF9uYW1lLm1ha2UobmFtZXMsIGxhbmd1YWdlVGFncyk7XG4gICAgdmFyIGx0YWdUYWJsZSA9IChsYW5ndWFnZVRhZ3MubGVuZ3RoID4gMCA/IGx0YWcubWFrZShsYW5ndWFnZVRhZ3MpIDogdW5kZWZpbmVkKTtcblxuICAgIHZhciBwb3N0VGFibGUgPSBwb3N0Lm1ha2UoKTtcbiAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuICAgICAgICB2ZXJzaW9uOiBmb250LmdldEVuZ2xpc2hOYW1lKCd2ZXJzaW9uJyksXG4gICAgICAgIGZ1bGxOYW1lOiBlbmdsaXNoRnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IGVuZ2xpc2hGYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHROYW1lOiBlbmdsaXNoU3R5bGVOYW1lLFxuICAgICAgICBwb3N0U2NyaXB0TmFtZTogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgZm9udEJCb3g6IFswLCBnbG9iYWxzLnlNaW4sIGdsb2JhbHMuYXNjZW5kZXIsIGdsb2JhbHMuYWR2YW5jZVdpZHRoTWF4XVxuICAgIH0pO1xuXG4gICAgdmFyIG1ldGFUYWJsZSA9IChmb250Lm1ldGFzICYmIE9iamVjdC5rZXlzKGZvbnQubWV0YXMpLmxlbmd0aCA+IDApID8gbWV0YS5tYWtlKGZvbnQubWV0YXMpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gVGhlIG9yZGVyIGRvZXMgbm90IG1hdHRlciBiZWNhdXNlIG1ha2VTZm50VGFibGUoKSB3aWxsIHNvcnQgdGhlbS5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcbiAgICBpZiAobHRhZ1RhYmxlKSB7XG4gICAgICAgIHRhYmxlcy5wdXNoKGx0YWdUYWJsZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbmFsIHRhYmxlc1xuICAgIGlmIChmb250LnRhYmxlcy5nc3ViKSB7XG4gICAgICAgIHRhYmxlcy5wdXNoKGdzdWIubWFrZShmb250LnRhYmxlcy5nc3ViKSk7XG4gICAgfVxuICAgIGlmIChtZXRhVGFibGUpIHtcbiAgICAgICAgdGFibGVzLnB1c2gobWV0YVRhYmxlKTtcbiAgICB9XG5cbiAgICB2YXIgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgZm9udCdzIGNoZWNrU3VtIGFuZCBzdG9yZSBpdCBpbiBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudC5cbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBzZm50VGFibGUuZmllbGRzO1xuICAgIHZhciBjaGVja1N1bUFkanVzdGVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGFibGVGaWVsZHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICBpZiAodGFibGVGaWVsZHNbaSQxXS5uYW1lID09PSAnaGVhZCB0YWJsZScpIHtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzW2kkMV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuICAgICAgICAgICAgY2hlY2tTdW1BZGp1c3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hlY2tTdW1BZGp1c3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxudmFyIHNmbnQgPSB7IG1ha2U6IG1ha2VTZm50VGFibGUsIGZvbnRUb1RhYmxlOiBmb250VG9TZm50VGFibGUsIGNvbXB1dGVDaGVja1N1bTogY29tcHV0ZUNoZWNrU3VtIH07XG5cbi8vIFRoZSBMYXlvdXQgb2JqZWN0IGlzIHRoZSBwcm90b3R5cGUgb2YgU3Vic3RpdHV0aW9uIG9iamVjdHMsIGFuZCBwcm92aWRlc1xuXG5mdW5jdGlvbiBzZWFyY2hUYWcoYXJyLCB0YWcpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXS50YWc7XG4gICAgICAgIGlmICh2YWwgPT09IHRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdGFnKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7IGltYXggPSBpbWlkIC0gMTsgfVxuICAgIH1cbiAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcbiAgICByZXR1cm4gLWltaW4gLSAxO1xufVxuXG5mdW5jdGlvbiBiaW5TZWFyY2goYXJyLCB2YWx1ZSkge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICB2YXIgdmFsID0gYXJyW2ltaWRdO1xuICAgICAgICBpZiAodmFsID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbi8vIGJpbmFyeSBzZWFyY2ggaW4gYSBsaXN0IG9mIHJhbmdlcyAoY292ZXJhZ2UsIGNsYXNzIGRlZmluaXRpb24pXG5mdW5jdGlvbiBzZWFyY2hSYW5nZShyYW5nZXMsIHZhbHVlKSB7XG4gICAgLy8ganNoaW50IGJpdHdpc2U6IGZhbHNlXG4gICAgdmFyIHJhbmdlO1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWlkXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA8IHZhbHVlKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7IGltYXggPSBpbWlkIC0gMTsgfVxuICAgIH1cbiAgICBpZiAoaW1pbiA+IDApIHtcbiAgICAgICAgcmFuZ2UgPSByYW5nZXNbaW1pbiAtIDFdO1xuICAgICAgICBpZiAodmFsdWUgPiByYW5nZS5lbmQpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5MYXlvdXRcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBMYXlvdXQoZm9udCwgdGFibGVOYW1lKSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbn1cblxuTGF5b3V0LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEJpbmFyeSBzZWFyY2ggYW4gb2JqZWN0IGJ5IFwidGFnXCIgcHJvcGVydHlcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZnVuY3Rpb24gc2VhcmNoVGFnXG4gICAgICogQG1lbWJlcm9mIG9wZW50eXBlLkxheW91dFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzZWFyY2hUYWc6IHNlYXJjaFRhZyxcblxuICAgIC8qKlxuICAgICAqIEJpbmFyeSBzZWFyY2ggaW4gYSBsaXN0IG9mIG51bWJlcnNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZnVuY3Rpb24gYmluU2VhcmNoXG4gICAgICogQG1lbWJlcm9mIG9wZW50eXBlLkxheW91dFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJpblNlYXJjaDogYmluU2VhcmNoLFxuXG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgTGF5b3V0IHRhYmxlIChHU1VCLCBHUE9TIGV0YykuXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY3JlYXRlIC0gV2hldGhlciB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIEdTVUIgb3IgR1BPUyB0YWJsZS5cbiAgICAgKi9cbiAgICBnZXRUYWJsZTogZnVuY3Rpb24oY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXTtcbiAgICAgICAgaWYgKCFsYXlvdXQgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXSA9IHRoaXMuY3JlYXRlRGVmYXVsdFRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgc2NyaXB0cyBpbiB0aGUgc3Vic3RpdHV0aW9uIHRhYmxlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNjcmlwdE5hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBsYXlvdXQuc2NyaXB0cy5tYXAoZnVuY3Rpb24oc2NyaXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LnRhZztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJlc3QgYmV0IGZvciBhIHNjcmlwdCBuYW1lLlxuICAgICAqIFJldHVybnMgJ0RGTFQnIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBJZiBub3QsIHJldHVybnMgJ2xhdG4nIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBJZiBuZWl0aGVyIGV4aXN0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0U2NyaXB0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgaGFzTGF0biA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGxheW91dC5zY3JpcHRzW2ldLnRhZztcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnREZMVCcpIHsgcmV0dXJuIG5hbWU7IH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbGF0bicpIHsgaGFzTGF0biA9IHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTGF0bikgeyByZXR1cm4gJ2xhdG4nOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIExhbmdTeXNSZWNvcmRzIGluIHRoZSBnaXZlbiBzY3JpcHQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIHNjcmlwdCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXRTY3JpcHRUYWJsZTogZnVuY3Rpb24oc2NyaXB0LCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoY3JlYXRlKTtcbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0IHx8ICdERkxUJztcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gbGF5b3V0LnNjcmlwdHM7XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKGxheW91dC5zY3JpcHRzLCBzY3JpcHQpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbcG9zXS5zY3JpcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzY3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7cmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLCBmZWF0dXJlSW5kZXhlczogW119LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBzY3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3Iuc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsYW5ndWFnZSBzeXN0ZW0gdGFibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgbGFuZ1N5c1RhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExhbmdTeXNUYWJsZTogZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBzY3JpcHRUYWJsZSA9IHRoaXMuZ2V0U2NyaXB0VGFibGUoc2NyaXB0LCBjcmVhdGUpO1xuICAgICAgICBpZiAoc2NyaXB0VGFibGUpIHtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UgfHwgbGFuZ3VhZ2UgPT09ICdkZmx0JyB8fCBsYW5ndWFnZSA9PT0gJ0RGTFQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmRlZmF1bHRMYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvcyA9IHNlYXJjaFRhZyhzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3JkcywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzW3Bvc10ubGFuZ1N5cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxhbmdTeXM6IHtyZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXX1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIE9uZSBvZiB0aGUgY29kZXMgbGlzdGVkIGF0IGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZmVhdHVyZWxpc3QuaHRtXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBmZWF0dXJlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEZlYXR1cmVUYWJsZTogZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYW5nU3lzVGFibGUgPSB0aGlzLmdldExhbmdTeXNUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpO1xuICAgICAgICBpZiAobGFuZ1N5c1RhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZVJlY29yZDtcbiAgICAgICAgICAgIHZhciBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmZlYXR1cmVzO1xuICAgICAgICAgICAgLy8gVGhlIEZlYXR1cmVJbmRleCBhcnJheSBvZiBpbmRpY2VzIGlzIGluIGFyYml0cmFyeSBvcmRlcixcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgYWxsRmVhdHVyZXMgaXMgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IGZlYXR1cmUgdGFnLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSBhbGxGZWF0dXJlc1tmZWF0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWNvcmQudGFnID09PSBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbEZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWMgb3JkZXJpbmcgb2YgZmVhdHVyZXMgd291bGQgcmVxdWlyZSB0byBzaGlmdCBmZWF0dXJlIGluZGV4ZXMgaW4gdGhlIHNjcmlwdCBsaXN0LlxuICAgICAgICAgICAgICAgIGNoZWNrLmFzc2VydChpbmRleCA9PT0gMCB8fCBmZWF0dXJlID49IGFsbEZlYXR1cmVzW2luZGV4IC0gMV0udGFnLCAnRmVhdHVyZXMgbXVzdCBiZSBhZGRlZCBpbiBhbHBoYWJldGljYWwgb3JkZXIuJyk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBmZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiB7IHBhcmFtczogMCwgbG9va3VwTGlzdEluZGV4ZXM6IFtdIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgZmVhdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvb2t1cCB0YWJsZXMgb2YgYSBnaXZlbiB0eXBlIGZvciBhIHNjcmlwdC9sYW5ndWFnZS9mZWF0dXJlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBsb29rdXAgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdCwgd2l0aCBubyBzdWJ0YWJsZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0TG9va3VwVGFibGVzOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBsb29rdXBUeXBlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVUYWJsZSA9IHRoaXMuZ2V0RmVhdHVyZVRhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSk7XG4gICAgICAgIHZhciB0YWJsZXMgPSBbXTtcbiAgICAgICAgaWYgKGZlYXR1cmVUYWJsZSkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlO1xuICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleGVzID0gZmVhdHVyZVRhYmxlLmxvb2t1cExpc3RJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbExvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5sb29rdXBzO1xuICAgICAgICAgICAgLy8gbG9va3VwTGlzdEluZGV4ZXMgYXJlIGluIG5vIHBhcnRpY3VsYXIgb3JkZXIsIHNvIHVzZSBuYWl2ZSBzZWFyY2guXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb2t1cExpc3RJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSBhbGxMb29rdXBzW2xvb2t1cExpc3RJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAobG9va3VwVGFibGUubG9va3VwVHlwZSA9PT0gbG9va3VwVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDAgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cEZsYWc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRhYmxlczogW10sXG4gICAgICAgICAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsTG9va3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYWxsTG9va3Vwcy5wdXNoKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xvb2t1cFRhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NsYXNzLWRlZmluaXRpb24tdGFibGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xhc3NEZWZUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRHbHlwaENsYXNzOiBmdW5jdGlvbihjbGFzc0RlZlRhYmxlLCBnbHlwaEluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAoY2xhc3NEZWZUYWJsZS5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoIDw9IGdseXBoSW5kZXggJiYgZ2x5cGhJbmRleCA8IGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaCArIGNsYXNzRGVmVGFibGUuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzRGVmVGFibGUuY2xhc3Nlc1tnbHlwaEluZGV4IC0gY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY2xhc3NEZWZUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmNsYXNzSWQgOiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNvdmVyYWdlIHRhYmxlXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NvdmVyYWdlLXRhYmxlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvdmVyYWdlVGFibGUgLSBhbiBPcGVuVHlwZSBMYXlvdXQgY292ZXJhZ2UgdGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldENvdmVyYWdlSW5kZXg6IGZ1bmN0aW9uKGNvdmVyYWdlVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJpblNlYXJjaChjb3ZlcmFnZVRhYmxlLmdseXBocywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IC0xO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlYXJjaFJhbmdlKGNvdmVyYWdlVGFibGUucmFuZ2VzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5pbmRleCArIGdseXBoSW5kZXggLSByYW5nZS5zdGFydCA6IC0xO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZ2x5cGggaW5kZXhlcyBvZiBhIGNvdmVyYWdlIHRhYmxlLlxuICAgICAqIEZvcm1hdCAxOiB0aGUgbGlzdCBpcyBzdG9yZWQgcmF3XG4gICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY292ZXJhZ2VUYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGV4cGFuZENvdmVyYWdlOiBmdW5jdGlvbihjb3ZlcmFnZVRhYmxlKSB7XG4gICAgICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlVGFibGUuZ2x5cGhzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGNvdmVyYWdlVGFibGUucmFuZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdseXBocztcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLy8gVGhlIFBvc2l0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlBvc2l0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3BvcycpO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIEluaXQgc29tZSBkYXRhIGZvciBmYXN0ZXIgYW5kIGVhc2llciBhY2Nlc3MgbGF0ZXIuXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICB0aGlzLmRlZmF1bHRLZXJuaW5nVGFibGVzID0gdGhpcy5nZXRLZXJuaW5nVGFibGVzKHNjcmlwdCk7XG59O1xuXG4vKipcbiAqIEZpbmQgYSBnbHlwaCBwYWlyIGluIGEgbGlzdCBvZiBsb29rdXAgdGFibGVzIG9mIHR5cGUgMiBhbmQgcmV0cmlldmUgdGhlIHhBZHZhbmNlIGtlcm5pbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge2ludGVnZXJ9IHJpZ2h0SW5kZXggLSByaWdodCBnbHlwaCBpbmRleFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihrZXJuaW5nTG9va3VwcywgbGVmdEluZGV4LCByaWdodEluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuaW5nTG9va3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0ga2VybmluZ0xvb2t1cHNbaV0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnRhYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2pdO1xuICAgICAgICAgICAgdmFyIGNvdkluZGV4ID0gdGhpcy5nZXRDb3ZlcmFnZUluZGV4KHN1YnRhYmxlLmNvdmVyYWdlLCBsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNvdkluZGV4IDwgMCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgc3dpdGNoIChzdWJ0YWJsZS5wb3NGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJTZXQgPSBzdWJ0YWJsZS5wYWlyU2V0c1tjb3ZJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpclNldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuc2Vjb25kR2x5cGggPT09IHJpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci52YWx1ZTEgJiYgcGFpci52YWx1ZTEueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBsZWZ0IGdseXBoIGZvdW5kLCBub3QgcmlnaHQgZ2x5cGggLSB0cnkgbmV4dCBzdWJ0YWJsZVxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MxID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMiA9IHRoaXMuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjIsIHJpZ2h0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciQxID0gc3VidGFibGUuY2xhc3NSZWNvcmRzW2NsYXNzMV1bY2xhc3MyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIkMS52YWx1ZTEgJiYgcGFpciQxLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBrZXJuaW5nIGxvb2t1cCB0YWJsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXSAtIHVzZSBmb250LnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCkgZm9yIGEgYmV0dGVyIGRlZmF1bHQgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7b2JqZWN0W119IFRoZSBsaXN0IG9mIGtlcm5pbmcgbG9va3VwIHRhYmxlcyAobWF5IGJlIGVtcHR5KSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIEdQT1MgdGFibGUgKGFuZCB3ZSBzaG91bGQgdXNlIHRoZSBrZXJuIHRhYmxlKVxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAodGhpcy5mb250LnRhYmxlcy5ncG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCAna2VybicsIDIpO1xuICAgIH1cbn07XG5cbi8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuU3Vic3RpdHV0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN1YnN0aXR1dGlvbihmb250KSB7XG4gICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dzdWInKTtcbn1cblxuLy8gQ2hlY2sgaWYgMiBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgZXF1YWwuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhcjEsIGFyMikge1xuICAgIHZhciBuID0gYXIxLmxlbmd0aDtcbiAgICBpZiAobiAhPT0gYXIyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYXIxW2ldICE9PSBhcjJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBzdWJ0YWJsZSBvZiBhIGxvb2t1cCB0YWJsZSBpbiBhIHBhcnRpY3VsYXIgZm9ybWF0LlxuZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3VidGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTdWJ0YWJsZSkge1xuICAgICAgICBzdWJ0YWJsZXMucHVzaChkZWZhdWx0U3VidGFibGUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFN1YnRhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdzdWIgLSBUaGUgR1NVQiB0YWJsZS5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGRlZmF1bHQgZW1wdHkgR1NVQiB0YWJsZSB3aXRoIGp1c3QgYSBERkxUIHNjcmlwdCBhbmQgZGZsdCBsYW5nIHN5cy5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBzY3JpcHRzOiBbe1xuICAgICAgICAgICAgdGFnOiAnREZMVCcsXG4gICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogeyByZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXSB9LFxuICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBsb29rdXBzOiBbXVxuICAgIH07XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHNpbmdsZSBzdWJzdGl0dXRpb25zIChsb29rdXAgdHlwZSAxKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLCAnc3MwMScuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0U2luZ2xlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuICAgICAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gc3VidGFibGUuZGVsdGFHbHlwaElkO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogZ2x5cGggKyBkZWx0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogc3Vic3RpdHV0ZVtqXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIG11bHRpcGxlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDIpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TXVsdGlwbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50cyA9IHN1YnRhYmxlLnNlcXVlbmNlc1tqXTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogcmVwbGFjZW1lbnRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBhbHRlcm5hdGVzIChsb29rdXAgdHlwZSAzKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IGFsdGVybmF0ZXMgLSBUaGUgbGlzdCBvZiBhbHRlcm5hdGVzXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0QWx0ZXJuYXRlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgYWx0ZXJuYXRlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNldHMgPSBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGVzLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IGFsdGVybmF0ZVNldHNbal0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdGVybmF0ZXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGxpZ2F0dXJlcyAobG9va3VwIHR5cGUgNCkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGxpZ2F0dXJlIG9iamVjdHMgbGlrZSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IGxpZ2F0dXJlcyAtIFRoZSBsaXN0IG9mIGxpZ2F0dXJlcy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRMaWdhdHVyZXMgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGxpZ2F0dXJlU2V0cyA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0cztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgdmFyIGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpZ1NldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnID0gbGlnU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICBsaWdhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWI6IFtzdGFydEdseXBoXS5jb25jYXQobGlnLmNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGxpZy5saWdHbHlwaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpZ2F0dXJlcztcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDEpXG4gKiBGb3JtYXQgMiwgbW9yZSBmbGV4aWJsZSwgaXMgYWx3YXlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBpZCB9IChmb3JtYXQgMSBpcyBub3Qgc3VwcG9ydGVkKVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkU2luZ2xlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDIsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMSBzdWJ0YWJsZSwgZm9ybWF0IDIsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG4gICAgICAgIHN1YnN0aXR1dGU6IFtdXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ1NpbmdsZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnN1YnN0aXR1dGVbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhIG11bHRpcGxlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMilcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnY2NtcCcsICdzdGNoJylcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRdIH0gZm9yIGZvcm1hdCAyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTXVsdGlwbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBjaGVjay5hc3NlcnQoc3Vic3RpdHV0aW9uLmJ5IGluc3RhbmNlb2YgQXJyYXkgJiYgc3Vic3RpdHV0aW9uLmJ5Lmxlbmd0aCA+IDEsICdNdWx0aXBsZTogXCJieVwiIG11c3QgYmUgYW4gYXJyYXkgb2YgdHdvIG9yIG1vcmUgaWRzJyk7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMiwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMiBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG4gICAgICAgIHNlcXVlbmNlczogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTXVsdGlwbGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5zZXF1ZW5jZXMuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnNlcXVlbmNlc1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGFuIGFsdGVybmF0ZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDMpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRzXSB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRBbHRlcm5hdGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzLCB0cnVlKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAzIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnQWx0ZXJuYXRlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0c1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaWdhdHVyZSAobG9va3VwIHR5cGUgNClcbiAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IGxpZ2F0dXJlIC0geyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBsaWdhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQsIHRydWUpWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXTtcbiAgICBpZiAoIXN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlID0geyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSA0IHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgICAgICBsaWdhdHVyZVNldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXSA9IHN1YnRhYmxlO1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gbGlnYXR1cmUuc3ViWzBdO1xuICAgIHZhciBsaWdDb21wb25lbnRzID0gbGlnYXR1cmUuc3ViLnNsaWNlKDEpO1xuICAgIHZhciBsaWdhdHVyZVRhYmxlID0ge1xuICAgICAgICBsaWdHbHlwaDogbGlnYXR1cmUuYnksXG4gICAgICAgIGNvbXBvbmVudHM6IGxpZ0NvbXBvbmVudHNcbiAgICB9O1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAvLyBsaWdhdHVyZVNldCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbcG9zXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWdhdHVyZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWYgbGlnYXR1cmUgYWxyZWFkeSBleGlzdHMsIHJldHVybi5cbiAgICAgICAgICAgIGlmIChhcnJheXNFcXVhbChsaWdhdHVyZVNldFtpXS5jb21wb25lbnRzLCBsaWdDb21wb25lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaWdhdHVyZSBkb2VzIG5vdCBleGlzdDogYWRkIGl0LlxuICAgICAgICBsaWdhdHVyZVNldC5wdXNoKGxpZ2F0dXJlVGFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsaWdhdHVyZVNldCBhbmQgYWRkIGNvdmVyYWdlIGZvciB0aGUgZmlyc3QgZ2x5cGguXG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLmxpZ2F0dXJlU2V0cy5zcGxpY2UocG9zLCAwLCBbbGlnYXR1cmVUYWJsZV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGlzdCBhbGwgZmVhdHVyZSBkYXRhIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZ2V0QWx0ZXJuYXRlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2NjbXAnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlwbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpKTtcbiAgICAgICAgY2FzZSAnc3RjaCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aXBsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQWRkIGEgc3Vic3RpdHV0aW9uIHRvIGEgZmVhdHVyZSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICBjYXNlICdhYWx0JzpcbiAgICAgICAgY2FzZSAnc2FsdCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi5ieSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFsdGVybmF0ZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgIGNhc2UgJ3JsaWcnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnY2NtcCc6XG4gICAgICAgICAgICBpZiAoc3ViLmJ5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRNdWx0aXBsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhYjtcbn1cblxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb05vZGVCdWZmZXIoYWIpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhYi5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSB2aWV3W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXJndW1lbnQoZXhwcmVzc2lvbiwgbWVzc2FnZSkge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbn1cblxuLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIFRoZSBjb29yZGluYXRlIGlzIDIgYnl0ZXMgbG9uZy5cbiAgICAgICAgLy8gSWYgdGhlIGBzYW1lYCBiaXQgaXMgc2V0LCB0aGUgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgY29vcmRpbmF0ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID4gMCkge1xuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBhcyBhIHNpZ25lZCAxNi1iaXQgZGVsdGEgdmFsdWUuXG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFBhcnNlIGEgVHJ1ZVR5cGUgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl94TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3lNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgdmFyIGZsYWdzO1xuICAgIHZhciBmbGFnO1xuXG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICB2YXIgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGgubnVtYmVyT2ZDb250b3VyczsgaSArPSAxKSB7XG4gICAgICAgICAgICBlbmRQb2ludEluZGljZXMucHVzaChwLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bWJlck9mQ29vcmRpbmF0ZXMgPSBlbmRQb2ludEluZGljZXNbZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgZmxhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgIGZsYWcgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICBpZiAoKGZsYWcgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpJDIgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjay5hcmd1bWVudChmbGFncy5sZW5ndGggPT09IG51bWJlck9mQ29vcmRpbmF0ZXMsICdCYWQgZmxhZ3MuJyk7XG5cbiAgICAgICAgaWYgKGVuZFBvaW50SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQzICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkM107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkkMykgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBweCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ0ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDUgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB5LCA0LCAzMik7XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIG1vcmVDb21wb25lbnRzID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG1vcmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleDogcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlMTA6IDAsXG4gICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgIGR5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHdvcmRzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlVVNob3J0KCksIHAucGFyc2VVU2hvcnQoKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMHgxMDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkNiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHJldHVybiBhIG5ldyBhcnJheS5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBuZXdQdCA9IHtcbiAgICAgICAgICAgIHg6IHRyYW5zZm9ybS54U2NhbGUgKiBwdC54ICsgdHJhbnNmb3JtLnNjYWxlMDEgKiBwdC55ICsgdHJhbnNmb3JtLmR4LFxuICAgICAgICAgICAgeTogdHJhbnNmb3JtLnNjYWxlMTAgKiBwdC54ICsgdHJhbnNmb3JtLnlTY2FsZSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHksXG4gICAgICAgICAgICBvbkN1cnZlOiBwdC5vbkN1cnZlLFxuICAgICAgICAgICAgbGFzdFBvaW50T2ZDb250b3VyOiBwdC5sYXN0UG9pbnRPZkNvbnRvdXJcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3UHQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXJzKHBvaW50cykge1xuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn1cblxuLy8gQ29udmVydCB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZSB0byBhIFBhdGguXG5mdW5jdGlvbiBnZXRQYXRoKHBvaW50cykge1xuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBnZXRDb250b3Vycyhwb2ludHMpO1xuXG4gICAgZm9yICh2YXIgY29udG91ckluZGV4ID0gMDsgY29udG91ckluZGV4IDwgY29udG91cnMubGVuZ3RoOyArK2NvbnRvdXJJbmRleCkge1xuICAgICAgICB2YXIgY29udG91ciA9IGNvbnRvdXJzW2NvbnRvdXJJbmRleF07XG5cbiAgICAgICAgdmFyIHByZXYgPSBudWxsO1xuICAgICAgICB2YXIgY3VyciA9IGNvbnRvdXJbY29udG91ci5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5leHQgPSBjb250b3VyWzBdO1xuXG4gICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhuZXh0LngsIG5leHQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvZmYtY3VydmUsIHN0YXJ0IGF0IHRoZWlyIG1pZGRsZS5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB7eDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41fTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBjb250b3VyWyhpICsgMSkgJSBjb250b3VyLmxlbmd0aF07XG5cbiAgICAgICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2MiA9IHByZXY7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQyID0gbmV4dDtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldi5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYyID0geyB4OiAoY3Vyci54ICsgcHJldi54KSAqIDAuNSwgeTogKGN1cnIueSArIHByZXYueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0MiA9IHsgeDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41IH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnIueCwgY3Vyci55LCBuZXh0Mi54LCBuZXh0Mi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBidWlsZFBhdGgoZ2x5cGhzLCBnbHlwaCkge1xuICAgIGlmIChnbHlwaC5pc0NvbXBvc2l0ZSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLmNvbXBvbmVudHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBnbHlwaC5jb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEdseXBoID0gZ2x5cGhzLmdldChjb21wb25lbnQuZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgdHRmR2x5cGhMb2FkZXIgdG8gcGFyc2UgdGhlIGdseXBoLlxuICAgICAgICAgICAgY29tcG9uZW50R2x5cGguZ2V0UGF0aCgpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXSA+IGdseXBoLnBvaW50cy5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdID4gY29tcG9uZW50R2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTWF0Y2hlZCBwb2ludHMgb3V0IG9mIHJhbmdlIGluICcgKyBnbHlwaC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQdCA9IGdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRQdCA9IGNvbXBvbmVudEdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IGNvbXBvbmVudC54U2NhbGUsIHNjYWxlMDE6IGNvbXBvbmVudC5zY2FsZTAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUxMDogY29tcG9uZW50LnNjYWxlMTAsIHlTY2FsZTogY29tcG9uZW50LnlTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4OiAwLCBkeTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQdCA9IHRyYW5zZm9ybVBvaW50cyhbc2Vjb25kUHRdLCB0cmFuc2Zvcm0pWzBdO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHggPSBmaXJzdFB0LnggLSBzZWNvbmRQdC54O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHkgPSBmaXJzdFB0LnkgLSBzZWNvbmRQdC55O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFBhdGgoZ2x5cGgucG9pbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVBbGwoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcbiAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG4gICAgLy8gVGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9jYSB0YWJsZSBpcyBpbnZhbGlkLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlT25Mb3dNZW1vcnkoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcbiAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG4gICAgZm9udC5fcHVzaCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG4vLyBQYXJzZSBhbGwgdGhlIGdseXBocyBhY2NvcmRpbmcgdG8gdGhlIG9mZnNldHMgZnJvbSB0aGUgYGxvY2FgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KVxuICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZU9uTG93TWVtb3J5KGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KTsgfVxuICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gcGFyc2VHbHlmVGFibGVBbGwoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpOyB9XG59XG5cbnZhciBnbHlmID0geyBnZXRQYXRoOiBnZXRQYXRoLCBwYXJzZTogcGFyc2VHbHlmVGFibGV9O1xuXG4vKiBBIFRydWVUeXBlIGZvbnQgaGludGluZyBpbnRlcnByZXRlci5cbipcbiogKGMpIDIwMTcgQXhlbCBLaXR0ZW5iZXJnZXJcbipcbiogVGhpcyBpbnRlcnByZXRlciBoYXMgYmVlbiBpbXBsZW1lbnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBkb2N1bWVudGF0aW9uOlxuKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA1L0NoYXA1Lmh0bWxcbipcbiogQWNjb3JkaW5nIHRvIHRoZSBkb2N1bWVudGF0aW9uIEYyNERPVDYgdmFsdWVzIGFyZSB1c2VkIGZvciBwaXhlbHMuXG4qIFRoYXQgbWVhbnMgY2FsY3VsYXRpb24gaXMgMS82NCBwaXhlbCBhY2N1cmF0ZSBhbmQgdXNlcyBpbnRlZ2VyIG9wZXJhdGlvbnMuXG4qIEhvd2V2ZXIsIEphdmFzY3JpcHQgaGFzIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbnMgYnkgZGVmYXVsdCBhbmQgb25seVxuKiB0aG9zZSBhcmUgYXZhaWxhYmxlLiBPbmUgY291bGQgbWFrZSBhIGNhc2UgdG8gc2ltdWxhdGUgdGhlIDEvNjQgYWNjdXJhY3lcbiogZXhhY3RseSBieSB0cnVuY2F0aW5nIGFmdGVyIGV2ZXJ5IGRpdmlzaW9uIG9wZXJhdGlvblxuKiAoZm9yIGV4YW1wbGUgd2l0aCA8PCAwKSB0byBnZXQgcGl4ZWwgZXhhY3RseSByZXN1bHRzIGFzIG90aGVyIFRydWVUeXBlXG4qIGltcGxlbWVudGF0aW9ucy4gSXQgbWF5IG1ha2Ugc2Vuc2Ugc2luY2Ugc29tZSBmb250cyBhcmUgcGl4ZWwgb3B0aW1pemVkXG4qIGJ5IGhhbmQgdXNpbmcgREVMVEFQIGluc3RydWN0aW9ucy4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndFxuKiBhbmQgcmF0aGVyIHVzZXMgZnVsbCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4qXG4qIHhTY2FsZSwgeVNjYWxlIGFuZCByb3RhdGlvbiBpcyBjdXJyZW50bHkgaWdub3JlZC5cbipcbiogQSBmZXcgbm9uLXRyaXZpYWwgaW5zdHJ1Y3Rpb25zIGFyZSBtaXNzaW5nIGFzIEkgZGlkbid0IGVuY291bnRlciB5ZXRcbiogYSBmb250IHRoYXQgdXNlZCB0aGVtIHRvIHRlc3QgYSBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbi5cbipcbiogU29tZSBmb250cyBzZWVtIHRvIHVzZSB1bmRvY3VtZW50ZWQgZmVhdHVyZXMgcmVnYXJkaW5nIHRoZSB0d2lsaWdodCB6b25lLlxuKiBPbmx5IHNvbWUgb2YgdGhlbSBhcmUgaW1wbGVtZW50ZWQgYXMgdGhleSB3ZXJlIGVuY291bnRlcmVkLlxuKlxuKiBUaGUgZXhwb3J0cy5ERUJVRyBzdGF0ZW1lbnRzIGFyZSByZW1vdmVkIG9uIHRoZSBtaW5pZmllZCBkaXN0cmlidXRpb24gZmlsZS5cbiovXG5cbnZhciBpbnN0cnVjdGlvblRhYmxlO1xudmFyIGV4ZWM7XG52YXIgZXhlY0dseXBoO1xudmFyIGV4ZWNDb21wb25lbnQ7XG5cbi8qXG4qIENyZWF0ZXMgYSBoaW50aW5nIG9iamVjdC5cbipcbiogVGhlcmUgb3VnaHQgdG8gYmUgZXhhY3RseSBvbmVcbiogZm9yIGVhY2ggdHJ1ZXR5cGUgZm9udCB0aGF0IGlzIHVzZWQgZm9yIGhpbnRpbmcuXG4qL1xuZnVuY3Rpb24gSGludGluZyhmb250KSB7XG4gICAgLy8gdGhlIGZvbnQgdGhpcyBoaW50aW5nIG9iamVjdCBpcyBmb3JcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuXG4gICAgdGhpcy5nZXRDb21tYW5kcyA9IGZ1bmN0aW9uIChoUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBnbHlmLmdldFBhdGgoaFBvaW50cykuY29tbWFuZHM7XG4gICAgfTtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZXNcbiAgICB0aGlzLl9mcGdtU3RhdGUgID1cbiAgICB0aGlzLl9wcmVwU3RhdGUgID1cbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgLy8gZXJyb3JTdGF0ZVxuICAgIC8vIDAgLi4uIGFsbCBva2F5XG4gICAgLy8gMSAuLi4gaGFkIGFuIGVycm9yIGluIGEgZ2x5ZixcbiAgICAvLyAgICAgICBjb250aW51ZSB3b3JraW5nIGJ1dCBzdG9wIHNwYW1taW5nXG4gICAgLy8gICAgICAgdGhlIGNvbnNvbGVcbiAgICAvLyAyIC4uLiBlcnJvciBhdCBwcmVwLCBzdG9wIGhpbnRpbmcgYXQgdGhpcyBwcGVtXG4gICAgLy8gMyAuLi4gZXJyb3IgYXQgZnBlZywgc3RvcCBoaW50aW5nIGZvciB0aGlzIGZvbnQgYXQgYWxsXG4gICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDA7XG59XG5cbi8qXG4qIE5vdCByb3VuZGluZy5cbiovXG5mdW5jdGlvbiByb3VuZE9mZih2KSB7XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0dyaWQodikge1xuICAgIC8vUm91bmRpbmcgaW4gVFQgaXMgc3VwcG9zZWQgdG8gXCJzeW1tZXRyaWNhbCBhcm91bmQgemVyb1wiXG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3VibGUgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvRG91YmxlR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModiAqIDIpKSAvIDI7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGhhbGYgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvSGFsZkdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiAoTWF0aC5yb3VuZChNYXRoLmFicyh2KSArIDAuNSkgLSAwLjUpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byB1cCB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVXBUb0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmNlaWwoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3duIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmREb3duVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5mbG9vcihNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFN1cGVyIHJvdW5kaW5nLlxuKi9cbnZhciByb3VuZFN1cGVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgcGVyaW9kID0gdGhpcy5zclBlcmlvZDtcbiAgICB2YXIgcGhhc2UgPSB0aGlzLnNyUGhhc2U7XG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuc3JUaHJlc2hvbGQ7XG4gICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cblxuICAgIHYgKz0gdGhyZXNob2xkIC0gcGhhc2U7XG5cbiAgICB2ID0gTWF0aC50cnVuYyh2IC8gcGVyaW9kKSAqIHBlcmlvZDtcblxuICAgIHYgKz0gcGhhc2U7XG5cbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3hncmlkZml0LnNvdXJjZWZvcmdlLm5ldC9yb3VuZC5odG1sXG4gICAgaWYgKHYgPCAwKSB7IHJldHVybiBwaGFzZSAqIHNpZ247IH1cblxuICAgIHJldHVybiB2ICogc2lnbjtcbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHgtYXhpcy5cbiovXG52YXIgeFVuaXRWZWN0b3IgPSB7XG4gICAgeDogMSxcblxuICAgIHk6IDAsXG5cbiAgICBheGlzOiAneCcsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueG8gOiBwMS54KSAtIChvMiA/IHAyLnhvIDogcDIueCk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueG8gLSBycDEueG87XG4gICAgICAgICAgICBkbzIgPSBwLnhvIC0gcnAyLnhvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnggLSBycDEueG87XG4gICAgICAgICAgICBkbTIgPSBycDIueCAtIHJwMi54bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXNcbiAgICBub3JtYWxTbG9wZTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC54ID0gKG9yZyA/IHJwLnhvIDogcnAueCkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnggPSBycGR4ICsgKHAueSAtIHJwZHkpIC8gcHYubm9ybWFsU2xvcGU7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiAwLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnhUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHktYXhpcy5cbiovXG52YXIgeVVuaXRWZWN0b3IgPSB7XG4gICAgeDogMCxcblxuICAgIHk6IDEsXG5cbiAgICBheGlzOiAneScsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueW8gOiBwMS55KSAtIChvMiA/IHAyLnlvIDogcDIueSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueW8gLSBycDEueW87XG4gICAgICAgICAgICBkbzIgPSBwLnlvIC0gcnAyLnlvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnkgLSBycDEueW87XG4gICAgICAgICAgICBkbTIgPSBycDIueSAtIHJwMi55bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXMuXG4gICAgbm9ybWFsU2xvcGU6IDAsXG5cbiAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueSA9IChvcmcgPyBycC55byA6IHJwLnkpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICAgICAgcC55ID0gcnBkeSArIHB2Lm5vcm1hbFNsb3BlICogKHAueCAtIHJwZHgpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiB2ZWN0b3IgbGluZS5cbiAgICBzbG9wZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnlUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbk9iamVjdC5mcmVlemUoeFVuaXRWZWN0b3IpO1xuT2JqZWN0LmZyZWV6ZSh5VW5pdFZlY3Rvcik7XG5cbi8qXG4qIENyZWF0ZXMgYSB1bml0IHZlY3RvciB0aGF0IGlzIG5vdCB4LSBvciB5LWF4aXMuXG4qL1xuZnVuY3Rpb24gVW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNsb3BlID0geSAvIHg7XG4gICAgdGhpcy5ub3JtYWxTbG9wZSA9IC14IC8geTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xufVxuXG4vKlxuKiBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuKiBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnggKiB4VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMikgK1xuICAgICAgICB0aGlzLnkgKiB5VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMilcbiAgICApO1xufTtcblxuLypcbiogTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4qIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiogb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbipcbiogU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24ocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgdmFyIGRtMTtcbiAgICB2YXIgZG0yO1xuICAgIHZhciBkbzE7XG4gICAgdmFyIGRvMjtcbiAgICB2YXIgZG9hMTtcbiAgICB2YXIgZG9hMjtcbiAgICB2YXIgZHQ7XG5cbiAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG59O1xuXG4vKlxuKiBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuKiBieSB0aGUgZGlzdGFuY2UgJ2QnXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbipcbiogcCAgIC4uLiAgcG9pbnQgdG8gc2V0XG4qIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4qIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiogcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiogb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuc2V0UmVsYXRpdmUgPSBmdW5jdGlvbihwLCBycCwgZCwgcHYsIG9yZykge1xuICAgIHB2ID0gcHYgfHwgdGhpcztcblxuICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICB2YXIgcHZucyA9IHB2Lm5vcm1hbFNsb3BlO1xuICAgIHZhciBmdnMgPSB0aGlzLnNsb3BlO1xuXG4gICAgdmFyIHB4ID0gcC54O1xuICAgIHZhciBweSA9IHAueTtcblxuICAgIHAueCA9IChmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5KSAvIChmdnMgLSBwdm5zKTtcbiAgICBwLnkgPSBmdnMgKiAocC54IC0gcHgpICsgcHk7XG59O1xuXG4vKlxuKiBUb3VjaGVzIHRoZSBwb2ludCBwLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24ocCkge1xuICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuICAgIHAueVRvdWNoZWQgPSB0cnVlO1xufTtcblxuLypcbiogUmV0dXJucyBhIHVuaXQgdmVjdG9yIHdpdGggeC95IGNvb3JkaW5hdGVzLlxuKi9cbmZ1bmN0aW9uIGdldFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgeCAvPSBkO1xuICAgIHkgLz0gZDtcblxuICAgIGlmICh4ID09PSAxICYmIHkgPT09IDApIHsgcmV0dXJuIHhVbml0VmVjdG9yOyB9XG4gICAgZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxKSB7IHJldHVybiB5VW5pdFZlY3RvcjsgfVxuICAgIGVsc2UgeyByZXR1cm4gbmV3IFVuaXRWZWN0b3IoeCwgeSk7IH1cbn1cblxuLypcbiogQ3JlYXRlcyBhIHBvaW50IGluIHRoZSBoaW50aW5nIGVuZ2luZS5cbiovXG5mdW5jdGlvbiBIUG9pbnQoXG4gICAgeCxcbiAgICB5LFxuICAgIGxhc3RQb2ludE9mQ29udG91cixcbiAgICBvbkN1cnZlXG4pIHtcbiAgICB0aGlzLnggPSB0aGlzLnhvID0gTWF0aC5yb3VuZCh4ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB4IHZhbHVlIGFuZCBvcmlnaW5hbCB4LXZhbHVlXG4gICAgdGhpcy55ID0gdGhpcy55byA9IE1hdGgucm91bmQoeSAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeSB2YWx1ZSBhbmQgb3JpZ2luYWwgeS12YWx1ZVxuXG4gICAgdGhpcy5sYXN0UG9pbnRPZkNvbnRvdXIgPSBsYXN0UG9pbnRPZkNvbnRvdXI7XG4gICAgdGhpcy5vbkN1cnZlID0gb25DdXJ2ZTtcbiAgICB0aGlzLnByZXZQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5leHRQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgdGhpcy55VG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xufVxuXG4vKlxuKiBSZXR1cm5zIHRoZSBuZXh0IHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXIuXG4qXG4qIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4qL1xuSFBvaW50LnByb3RvdHlwZS5uZXh0VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcCA9IHRoaXMubmV4dFBvaW50T25Db250b3VyO1xuXG4gICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5uZXh0UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogUmV0dXJucyB0aGUgcHJldmlvdXMgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91clxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUucHJldlRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHAgPSB0aGlzLnByZXZQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAucHJldlBvaW50T25Db250b3VyOyB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qXG4qIFRoZSB6ZXJvIHBvaW50LlxuKi9cbnZhciBIUFplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBIUG9pbnQoMCwgMCkpO1xuXG4vKlxuKiBUaGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4qXG4qIE5vdGU6IEZyZWV6aW5nIHRoZSBkZWZhdWx0U3RhdGUgYW5kIHRoZW4gZGVyaXZpbmcgZnJvbSBpdFxuKiBtYWtlcyB0aGUgVjggSmF2YXNjcmlwdCBlbmdpbmUgZ29pbmcgYXdrd2FyZCxcbiogc28gdGhpcyBpcyBhdm9pZGVkLCBhbGJlaXQgdGhlIGRlZmF1bHRTdGF0ZSBzaG91bGRuJ3RcbiogZXZlciBjaGFuZ2UuXG4qL1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBjdkN1dEluOiAxNyAvIDE2LCAgICAvLyBjb250cm9sIHZhbHVlIGN1dCBpblxuICAgIGRlbHRhQmFzZTogOSxcbiAgICBkZWx0YVNoaWZ0OiAwLjEyNSxcbiAgICBsb29wOiAxLCAgICAgICAgICAgICAvLyBsb29wcyBzb21lIGluc3RydWN0aW9uc1xuICAgIG1pbkRpczogMSwgICAgICAgICAgIC8vIG1pbmltdW0gZGlzdGFuY2VcbiAgICBhdXRvRmxpcDogdHJ1ZVxufTtcblxuLypcbiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBlbnYgIC4uLiAnZnBnbScgb3IgJ3ByZXAnIG9yICdnbHlmJ1xuKiBwcm9nIC4uLiB0aGUgcHJvZ3JhbVxuKi9cbmZ1bmN0aW9uIFN0YXRlKGVudiwgcHJvZykge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2cgPSBwcm9nO1xuXG4gICAgc3dpdGNoIChlbnYpIHtcbiAgICAgICAgY2FzZSAnZ2x5ZicgOlxuICAgICAgICAgICAgdGhpcy56cDAgPSB0aGlzLnpwMSA9IHRoaXMuenAyID0gMTtcbiAgICAgICAgICAgIHRoaXMucnAwID0gdGhpcy5ycDEgPSB0aGlzLnJwMiA9IDA7XG4gICAgICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgdGhpcy5mdiA9IHRoaXMucHYgPSB0aGlzLmRwdiA9IHhVbml0VmVjdG9yO1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuICAgIH1cbn1cblxuLypcbiogRXhlY3V0ZXMgYSBnbHlwaCBwcm9ncmFtLlxuKlxuKiBUaGlzIGRvZXMgdGhlIGhpbnRpbmcgZm9yIGVhY2ggZ2x5cGguXG4qXG4qIFJldHVybnMgYW4gYXJyYXkgb2YgbW92ZWQgcG9pbnRzLlxuKlxuKiBnbHlwaDogdGhlIGdseXBoIHRvIGhpbnRcbiogcHBlbTogdGhlIHNpemUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGZvclxuKi9cbkhpbnRpbmcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihnbHlwaCwgcHBlbSkge1xuICAgIGlmICh0eXBlb2YgcHBlbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBzaXplIGlzIG5vdCBhIG51bWJlciEnKTtcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlZCBhIGZhdGFsIGVycm9yLCBkb24ndCBkbyBhbnkgaGludGluZyBhbnltb3JlLlxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMikgeyByZXR1cm47IH1cblxuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHZhciBwcmVwU3RhdGUgPSB0aGlzLl9wcmVwU3RhdGU7XG5cbiAgICBpZiAoIXByZXBTdGF0ZSB8fCBwcmVwU3RhdGUucHBlbSAhPT0gcHBlbSkge1xuICAgICAgICB2YXIgZnBnbVN0YXRlID0gdGhpcy5fZnBnbVN0YXRlO1xuXG4gICAgICAgIGlmICghZnBnbVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlcyB0aGUgZnBnbSBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBkZWZpbmUgZnVuY3Rpb25zLlxuICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZGVmYXVsdFN0YXRlO1xuXG4gICAgICAgICAgICBmcGdtU3RhdGUgPVxuICAgICAgICAgICAgdGhpcy5fZnBnbVN0YXRlID1cbiAgICAgICAgICAgICAgICBuZXcgU3RhdGUoJ2ZwZ20nLCBmb250LnRhYmxlcy5mcGdtKTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlLmZ1bmNzID0gWyBdO1xuICAgICAgICAgICAgZnBnbVN0YXRlLmZvbnQgPSBmb250O1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEZQR00tLS0nKTtcbiAgICAgICAgICAgICAgICBmcGdtU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4ZWMoZnBnbVN0YXRlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBGUEdNOicgKyBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGVjdXRlcyB0aGUgcHJlcCBwcm9ncmFtIGZvciB0aGlzIHBwZW0gc2V0dGluZy5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIHNldCBjdnQgdmFsdWVzXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB0byBiZSByZW5kZXJlZCBmb250IHNpemUuXG5cbiAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZnBnbVN0YXRlO1xuICAgICAgICBwcmVwU3RhdGUgPVxuICAgICAgICB0aGlzLl9wcmVwU3RhdGUgPVxuICAgICAgICAgICAgbmV3IFN0YXRlKCdwcmVwJywgZm9udC50YWJsZXMucHJlcCk7XG5cbiAgICAgICAgcHJlcFN0YXRlLnBwZW0gPSBwcGVtO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdnQgdGFibGVcbiAgICAgICAgLy8gYW5kIHNjYWxlcyBpdCB0byB0aGUgY3VycmVudCBwcGVtIHNldHRpbmcuXG4gICAgICAgIHZhciBvQ3Z0ID0gZm9udC50YWJsZXMuY3Z0O1xuICAgICAgICBpZiAob0N2dCkge1xuICAgICAgICAgICAgdmFyIGN2dCA9IHByZXBTdGF0ZS5jdnQgPSBuZXcgQXJyYXkob0N2dC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gcHBlbSAvIGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb0N2dC5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGN2dFtjXSA9IG9DdnRbY10gKiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXBTdGF0ZS5jdnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBQUkVQLS0tJyk7XG4gICAgICAgICAgICBwcmVwU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWMocHJlcFN0YXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gUFJFUDonICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMSkgeyByZXR1cm47IH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleGVjR2x5cGgoZ2x5cGgsIHByZXBTdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yOicgKyBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBmdXJ0aGVyIGhpbnRpbmcgZXJyb3JzIGFyZSBzaWxlbmNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAxO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgZ2x5cGguXG4qL1xuZXhlY0dseXBoID0gZnVuY3Rpb24oZ2x5cGgsIHByZXBTdGF0ZSkge1xuICAgIC8vIG9yaWdpbmFsIHBvaW50IHBvc2l0aW9uc1xuICAgIHZhciB4U2NhbGUgPSBwcmVwU3RhdGUucHBlbSAvIHByZXBTdGF0ZS5mb250LnVuaXRzUGVyRW07XG4gICAgdmFyIHlTY2FsZSA9IHhTY2FsZTtcbiAgICB2YXIgY29tcG9uZW50cyA9IGdseXBoLmNvbXBvbmVudHM7XG4gICAgdmFyIGNvbnRvdXJzO1xuICAgIHZhciBnWm9uZTtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUgPSBwcmVwU3RhdGU7XG4gICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEdMWVBILS0tJyk7XG4gICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY0NvbXBvbmVudChnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgZ1pvbmUgPSBzdGF0ZS5nWm9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9udCA9IHByZXBTdGF0ZS5mb250O1xuICAgICAgICBnWm9uZSA9IFtdO1xuICAgICAgICBjb250b3VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBjZyA9IGZvbnQuZ2x5cGhzLmdldChjLmdseXBoSW5kZXgpO1xuXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGNnLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUCAnICsgaSArICctLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWNDb21wb25lbnQoY2csIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgICAgICAvLyBhcHBlbmRzIHRoZSBjb21wdXRlZCBwb2ludHMgdG8gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgLy8gcG9zdCBwcm9jZXNzZXMgdGhlIGNvbXBvbmVudCBwb2ludHNcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGgucm91bmQoYy5keCAqIHhTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZHkgPSBNYXRoLnJvdW5kKGMuZHkgKiB5U2NhbGUpO1xuICAgICAgICAgICAgdmFyIGd6ID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICB2YXIgY2MgPSBzdGF0ZS5jb250b3VycztcbiAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBnei5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGd6W3BpXTtcbiAgICAgICAgICAgICAgICBwLnhUb3VjaGVkID0gcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHAueG8gPSBwLnggPSBwLnggKyBkeDtcbiAgICAgICAgICAgICAgICBwLnlvID0gcC55ID0gcC55ICsgZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnTGVuID0gZ1pvbmUubGVuZ3RoO1xuICAgICAgICAgICAgZ1pvbmUucHVzaC5hcHBseShnWm9uZSwgZ3opO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY2Nbal0gKyBnTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbHlwaC5pbnN0cnVjdGlvbnMgJiYgIXN0YXRlLmluaGliaXRHcmlkRml0KSB7XG4gICAgICAgICAgICAvLyB0aGUgY29tcG9zaXRlIGhhcyBpbnN0cnVjdGlvbnMgb24gaXRzIG93blxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IGdab25lO1xuXG4gICAgICAgICAgICBzdGF0ZS5jb250b3VycyA9IGNvbnRvdXJzO1xuXG4gICAgICAgICAgICAvLyBub3RlOiBIUFplcm8gY2Fubm90IGJlIHVzZWQgaGVyZSwgc2luY2VcbiAgICAgICAgICAgIC8vICAgICAgIHRoZSBwb2ludCBtaWdodCBiZSBtb2RpZmllZFxuICAgICAgICAgICAgZ1pvbmUucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KDAsIDApLFxuICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QT1NJVEUtLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgICAgICBnWm9uZS5sZW5ndGggLT0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnWm9uZTtcbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgY29tcG9uZW50IG9mIGEgbXVsdGktY29tcG9uZW50IGdseXBoXG4qIG9yIG9mIHRoZSBnbHlwaCBpdHNlbGYgZm9yIGEgbm9uLWNvbXBvbmVudCBnbHlwaC5cbiovXG5leGVjQ29tcG9uZW50ID0gZnVuY3Rpb24oZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSlcbntcbiAgICB2YXIgcG9pbnRzID0gZ2x5cGgucG9pbnRzIHx8IFtdO1xuICAgIHZhciBwTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgZ1pvbmUgPSBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IFtdO1xuICAgIHZhciBjb250b3VycyA9IHN0YXRlLmNvbnRvdXJzID0gW107XG5cbiAgICAvLyBTY2FsZXMgdGhlIG9yaWdpbmFsIHBvaW50cyBhbmRcbiAgICAvLyBtYWtlcyBjb3BpZXMgZm9yIHRoZSBoaW50ZWQgcG9pbnRzLlxuICAgIHZhciBjcDsgLy8gY3VycmVudCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGdab25lW2ldID0gbmV3IEhQb2ludChcbiAgICAgICAgICAgIGNwLnggKiB4U2NhbGUsXG4gICAgICAgICAgICBjcC55ICogeVNjYWxlLFxuICAgICAgICAgICAgY3AubGFzdFBvaW50T2ZDb250b3VyLFxuICAgICAgICAgICAgY3Aub25DdXJ2ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENoYWluIGxpbmtzIHRoZSBjb250b3Vycy5cbiAgICB2YXIgc3A7IC8vIHN0YXJ0IHBvaW50XG4gICAgdmFyIG5wOyAvLyBuZXh0IHBvaW50XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwTGVuOyBpJDErKykge1xuICAgICAgICBjcCA9IGdab25lW2kkMV07XG5cbiAgICAgICAgaWYgKCFzcCkge1xuICAgICAgICAgICAgc3AgPSBjcDtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goaSQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IHNwO1xuICAgICAgICAgICAgc3AucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgICAgICBzcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5wID0gZ1pvbmVbaSQxICsgMV07XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBucDtcbiAgICAgICAgICAgIG5wLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluaGliaXRHcmlkRml0KSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BST0NFU1NJTkcgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBMZW47IGkkMisrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpJDIsIGdab25lW2kkMl0ueCwgZ1pvbmVbaSQyXS55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdab25lLnB1c2goXG4gICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICk7XG5cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIFJlbW92ZXMgdGhlIGV4dHJhIHBvaW50cy5cbiAgICBnWm9uZS5sZW5ndGggLT0gMjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGSU5JU0hFRCBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgcExlbjsgaSQzKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMywgZ1pvbmVbaSQzXS54LCBnWm9uZVtpJDNdLnkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIHByb2dyYW0gbG9hZGVkIGluIHN0YXRlLlxuKi9cbmV4ZWMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblxuICAgIGlmICghcHJvZykgeyByZXR1cm47IH1cblxuICAgIHZhciBwTGVuID0gcHJvZy5sZW5ndGg7XG4gICAgdmFyIGlucztcblxuICAgIGZvciAoc3RhdGUuaXAgPSAwOyBzdGF0ZS5pcCA8IHBMZW47IHN0YXRlLmlwKyspIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgc3RhdGUuc3RlcCsrOyB9XG4gICAgICAgIGlucyA9IGluc3RydWN0aW9uVGFibGVbcHJvZ1tzdGF0ZS5pcF1dO1xuXG4gICAgICAgIGlmICghaW5zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3Vua25vd24gaW5zdHJ1Y3Rpb246IDB4JyArXG4gICAgICAgICAgICAgICAgTnVtYmVyKHByb2dbc3RhdGUuaXBdKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnMoc3RhdGUpO1xuXG4gICAgICAgIC8vIHZlcnkgZXh0ZW5zaXZlIGRlYnVnZ2luZyBmb3IgZWFjaCBzdGVwXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICB2YXIgZGE7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZ1pvbmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnRab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRab25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RaJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhY2subGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAnLi4uJywgc3RhdGUuc3RhY2suc2xpY2Uoc3RhdGUuc3RhY2subGVuZ3RoIC0gMTApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc3RhY2subGVuZ3RoLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG59O1xuXG4vKlxuKiBJbml0aWFsaXplcyB0aGUgdHdpbGlnaHQgem9uZS5cbipcbiogVGhpcyBpcyBvbmx5IGRvbmUgaWYgYSBTWlB4IGluc3RydWN0aW9uXG4qIHJlZmVycyB0byB0aGUgdHdpbGlnaHQgem9uZS5cbiovXG5mdW5jdGlvbiBpbml0VFpvbmUoc3RhdGUpXG57XG4gICAgdmFyIHRab25lID0gc3RhdGUudFpvbmUgPSBuZXcgQXJyYXkoc3RhdGUuZ1pvbmUubGVuZ3RoKTtcblxuICAgIC8vIG5vIGlkZWEgaWYgdGhpcyBpcyBhY3R1YWxseSBjb3JyZWN0Li4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Wm9uZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRab25lW2ldID0gbmV3IEhQb2ludCgwLCAwKTtcbiAgICB9XG59XG5cbi8qXG4qIFNraXBzIHRoZSBpbnN0cnVjdGlvbiBwb2ludGVyIGFoZWFkIG92ZXIgYW4gSUYvRUxTRSBibG9jay5cbiogaGFuZGxlRWxzZSAuLiBpZiB0cnVlIGJyZWFrcyBvbiBtYXRjaGluZyBFTFNFXG4qL1xuZnVuY3Rpb24gc2tpcChzdGF0ZSwgaGFuZGxlRWxzZSlcbntcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIG5lc3RpbmcgPSAxO1xuICAgIHZhciBpbnM7XG5cbiAgICBkbyB7XG4gICAgICAgIGlucyA9IHByb2dbKytpcF07XG4gICAgICAgIGlmIChpbnMgPT09IDB4NTgpIC8vIElGXG4gICAgICAgICAgICB7IG5lc3RpbmcrKzsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NTkpIC8vIEVJRlxuICAgICAgICAgICAgeyBuZXN0aW5nLS07IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQwKSAvLyBOUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDEpIC8vIE5QVVNIV1xuICAgICAgICAgICAgeyBpcCArPSAyICogcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCMCAmJiBpbnMgPD0gMHhCNykgLy8gUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gaW5zIC0gMHhCMCArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjggJiYgaW5zIDw9IDB4QkYpIC8vIFBVU0hXXG4gICAgICAgICAgICB7IGlwICs9IChpbnMgLSAweEI4ICsgMSkgKiAyOyB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZUVsc2UgJiYgbmVzdGluZyA9PT0gMSAmJiBpbnMgPT09IDB4MUIpIC8vIEVMU0VcbiAgICAgICAgICAgIHsgYnJlYWs7IH1cbiAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4qICAgICAgICAgIEFuZCB0aGVuIGEgbG90IG9mIGluc3RydWN0aW9ucy4uLiAgICAgICAgICAgICAgICAqXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFNWVENBW2FdIFNldCBmcmVlZG9tIGFuZCBwcm9qZWN0aW9uIFZlY3RvcnMgVG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAwLTB4MDFcbmZ1bmN0aW9uIFNWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU1BWVENBW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDItMHgwM1xuZnVuY3Rpb24gU1BWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTRlZUQ0FbYV0gU2V0IEZyZWVkb20gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwNC0weDA1XG5mdW5jdGlvbiBTRlZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHY7XG59XG5cbi8vIFNQVlRMW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDA2LTB4MDdcbmZ1bmN0aW9uIFNQVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU1BWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNGVlRMW2FdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBMaW5lXG4vLyAweDA4LTB4MDlcbmZ1bmN0aW9uIFNGVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU0ZWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNQVkZTW10gU2V0IFByb2plY3Rpb24gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEFcbmZ1bmN0aW9uIFNQVkZTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xufVxuXG4vLyBTRlZGU1tdIFNldCBGcmVlZG9tIFZlY3RvciBGcm9tIFN0YWNrXG4vLyAweDBCXG5mdW5jdGlvbiBTRlZGUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcbn1cblxuLy8gR1BWW10gR2V0IFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBDXG5mdW5jdGlvbiBHUFYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHUFZbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHB2LnggKiAweDQwMDApO1xuICAgIHN0YWNrLnB1c2gocHYueSAqIDB4NDAwMCk7XG59XG5cbi8vIEdGVltdIEdldCBGcmVlZG9tIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR0ZWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0ZWW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChmdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKGZ2LnkgKiAweDQwMDApO1xufVxuXG4vLyBTRlZUUFZbXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gUHJvamVjdGlvbiBWZWN0b3Jcbi8vIDB4MEVcbmZ1bmN0aW9uIFNGVlRQVihzdGF0ZSkge1xuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVFBWW10nKTsgfVxufVxuXG4vLyBJU0VDVFtdIG1vdmVzIHBvaW50IHAgdG8gdGhlIEludGVyU0VDVGlvbiBvZiB0d28gbGluZXNcbi8vIDB4MEZcbmZ1bmN0aW9uIElTRUNUKHN0YXRlKVxue1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwYTBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBhMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGIwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYjFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHowID0gc3RhdGUuejA7XG4gICAgdmFyIHoxID0gc3RhdGUuejE7XG4gICAgdmFyIHBhMCA9IHowW3BhMGldO1xuICAgIHZhciBwYTEgPSB6MFtwYTFpXTtcbiAgICB2YXIgcGIwID0gejFbcGIwaV07XG4gICAgdmFyIHBiMSA9IHoxW3BiMWldO1xuICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ0lTRUNUW10sICcsIHBhMGksIHBhMWksIHBiMGksIHBiMWksIHBpKTsgfVxuXG4gICAgLy8gbWF0aCBmcm9tXG4gICAgLy8gZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNsaW5lX2ludGVyc2VjdGlvbiNHaXZlbl90d29fcG9pbnRzX29uX2VhY2hfbGluZVxuXG4gICAgdmFyIHgxID0gcGEwLng7XG4gICAgdmFyIHkxID0gcGEwLnk7XG4gICAgdmFyIHgyID0gcGExLng7XG4gICAgdmFyIHkyID0gcGExLnk7XG4gICAgdmFyIHgzID0gcGIwLng7XG4gICAgdmFyIHkzID0gcGIwLnk7XG4gICAgdmFyIHg0ID0gcGIxLng7XG4gICAgdmFyIHk0ID0gcGIxLnk7XG5cbiAgICB2YXIgZGl2ID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuICAgIHZhciBmMSA9IHgxICogeTIgLSB5MSAqIHgyO1xuICAgIHZhciBmMiA9IHgzICogeTQgLSB5MyAqIHg0O1xuXG4gICAgcC54ID0gKGYxICogKHgzIC0geDQpIC0gZjIgKiAoeDEgLSB4MikpIC8gZGl2O1xuICAgIHAueSA9IChmMSAqICh5MyAtIHk0KSAtIGYyICogKHkxIC0geTIpKSAvIGRpdjtcbn1cblxuLy8gU1JQMFtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMFxuLy8gMHgxMFxuZnVuY3Rpb24gU1JQMChzdGF0ZSkge1xuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDBbXScsIHN0YXRlLnJwMCk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMVxuLy8gMHgxMVxuZnVuY3Rpb24gU1JQMShzdGF0ZSkge1xuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDFbXScsIHN0YXRlLnJwMSk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMlxuLy8gMHgxMlxuZnVuY3Rpb24gU1JQMihzdGF0ZSkge1xuICAgIHN0YXRlLnJwMiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDJbXScsIHN0YXRlLnJwMik7IH1cbn1cblxuLy8gU1pQMFtdIFNldCBab25lIFBvaW50ZXIgMFxuLy8gMHgxM1xuZnVuY3Rpb24gU1pQMChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMFtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMCA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMVtdIFNldCBab25lIFBvaW50ZXIgMVxuLy8gMHgxNFxuZnVuY3Rpb24gU1pQMShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMVtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMSA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMltdIFNldCBab25lIFBvaW50ZXIgMlxuLy8gMHgxNVxuZnVuY3Rpb24gU1pQMihzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMltdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQU1tdIFNldCBab25lIFBvaW50ZXJTXG4vLyAweDE2XG5mdW5jdGlvbiBTWlBTKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlBTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAwID0gc3RhdGUuenAxID0gc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNMT09QW10gU2V0IExPT1AgdmFyaWFibGVcbi8vIDB4MTdcbmZ1bmN0aW9uIFNMT09QKHN0YXRlKSB7XG4gICAgc3RhdGUubG9vcCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NMT09QW10nLCBzdGF0ZS5sb29wKTsgfVxufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBHcmlkXG4vLyAweDE4XG5mdW5jdGlvbiBSVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvR3JpZDtcbn1cblxuLy8gUlRIR1tdIFJvdW5kIFRvIEhhbGYgR3JpZFxuLy8gMHgxOVxuZnVuY3Rpb24gUlRIRyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEhHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvSGFsZkdyaWQ7XG59XG5cbi8vIFNNRFtdIFNldCBNaW5pbXVtIERpc3RhbmNlXG4vLyAweDFBXG5mdW5jdGlvbiBTTUQoc3RhdGUpIHtcbiAgICB2YXIgZCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NNRFtdJywgZCk7IH1cblxuICAgIHN0YXRlLm1pbkRpcyA9IGQgLyAweDQwO1xufVxuXG4vLyBFTFNFW10gRUxTRSBjbGF1c2Vcbi8vIDB4MUJcbmZ1bmN0aW9uIEVMU0Uoc3RhdGUpIHtcbiAgICAvLyBUaGlzIGluc3RydWN0aW9uIGhhcyBiZWVuIHJlYWNoZWQgYnkgZXhlY3V0aW5nIGEgdGhlbiBicmFuY2hcbiAgICAvLyBzbyBpdCBqdXN0IHNraXBzIGFoZWFkIHVudGlsIG1hdGNoaW5nIEVJRi5cbiAgICAvL1xuICAgIC8vIEluIGNhc2UgdGhlIElGIHdhcyBuZWdhdGl2ZSB0aGUgSUZbXSBpbnN0cnVjdGlvbiBhbHJlYWR5XG4gICAgLy8gc2tpcHBlZCBmb3J3YXJkIG92ZXIgdGhlIEVMU0VbXVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VMU0VbXScpOyB9XG5cbiAgICBza2lwKHN0YXRlLCBmYWxzZSk7XG59XG5cbi8vIEpNUFJbXSBKdU1QIFJlbGF0aXZlXG4vLyAweDFDXG5mdW5jdGlvbiBKTVBSKHN0YXRlKSB7XG4gICAgdmFyIG8gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdKTVBSW10nLCBvKTsgfVxuXG4gICAgLy8gQSBqdW1wIGJ5IDEgd291bGQgZG8gbm90aGluZy5cbiAgICBzdGF0ZS5pcCArPSBvIC0gMTtcbn1cblxuLy8gU0NWVENJW10gU2V0IENvbnRyb2wgVmFsdWUgVGFibGUgQ3V0LUluXG4vLyAweDFEXG5mdW5jdGlvbiBTQ1ZUQ0koc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDVlRDSVtdJywgbik7IH1cblxuICAgIHN0YXRlLmN2Q3V0SW4gPSBuIC8gMHg0MDtcbn1cblxuLy8gRFVQW10gRFVQbGljYXRlIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIwXG5mdW5jdGlvbiBEVVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdEVVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKTtcbn1cblxuLy8gUE9QW10gUE9QIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIxXG5mdW5jdGlvbiBQT1Aoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUE9QW10nKTsgfVxuXG4gICAgc3RhdGUuc3RhY2sucG9wKCk7XG59XG5cbi8vIENMRUFSW10gQ0xFQVIgdGhlIHN0YWNrXG4vLyAweDIyXG5mdW5jdGlvbiBDTEVBUihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDTEVBUltdJyk7IH1cblxuICAgIHN0YXRlLnN0YWNrLmxlbmd0aCA9IDA7XG59XG5cbi8vIFNXQVBbXSBTV0FQIHRoZSB0b3AgdHdvIGVsZW1lbnRzIG9uIHRoZSBzdGFja1xuLy8gMHgyM1xuZnVuY3Rpb24gU1dBUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NXQVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHN0YWNrLnB1c2goYik7XG59XG5cbi8vIERFUFRIW10gREVQVEggb2YgdGhlIHN0YWNrXG4vLyAweDI0XG5mdW5jdGlvbiBERVBUSChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFUFRIW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5sZW5ndGgpO1xufVxuXG4vLyBMT09QQ0FMTFtdIExPT1BDQUxMIGZ1bmN0aW9uXG4vLyAweDJBXG5mdW5jdGlvbiBMT09QQ0FMTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTE9PUENBTExbXScsIGZuLCBjKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coXG4gICAgICAgICAgICArK3N0YXRlLnN0ZXAsXG4gICAgICAgICAgICBpICsgMSA8IGMgPyAnbmV4dCBsb29wY2FsbCcgOiAnZG9uZSBsb29wY2FsbCcsXG4gICAgICAgICAgICBpXG4gICAgICAgICk7IH1cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xufVxuXG4vLyBDQUxMW10gQ0FMTCBmdW5jdGlvblxuLy8gMHgyQlxuZnVuY3Rpb24gQ0FMTChzdGF0ZSkge1xuICAgIHZhciBmbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NBTExbXScsIGZuKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coKytzdGF0ZS5zdGVwLCAncmV0dXJuaW5nIGZyb20nLCBmbik7IH1cbn1cblxuLy8gQ0lOREVYW10gQ29weSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI1XG5mdW5jdGlvbiBDSU5ERVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NJTkRFWFtdJywgayk7IH1cblxuICAgIC8vIEluIGNhc2Ugb2YgayA9PSAxLCBpdCBjb3BpZXMgdGhlIGxhc3QgZWxlbWVudCBhZnRlciBwb3BwaW5nXG4gICAgLy8gdGh1cyBzdGFjay5sZW5ndGggLSBrLlxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0ga10pO1xufVxuXG4vLyBNSU5ERVhbXSBNb3ZlIHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjZcbmZ1bmN0aW9uIE1JTkRFWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOREVYW10nLCBrKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gaywgMSlbMF0pO1xufVxuXG4vLyBGREVGW10gRnVuY3Rpb24gREVGaW5pdGlvblxuLy8gMHgyQ1xuZnVuY3Rpb24gRkRFRihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lbnYgIT09ICdmcGdtJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ZERUYgbm90IGFsbG93ZWQgaGVyZScpOyB9XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG4gICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGlwQmVnaW4gPSBpcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGREVGW10nLCBmbik7IH1cblxuICAgIHdoaWxlIChwcm9nWysraXBdICE9PSAweDJEKXsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbiAgICBzdGF0ZS5mdW5jc1tmbl0gPSBwcm9nLnNsaWNlKGlwQmVnaW4gKyAxLCBpcCk7XG59XG5cbi8vIE1EQVBbYV0gTW92ZSBEaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4MkUtMHgyRlxuZnVuY3Rpb24gTURBUChyb3VuZCwgc3RhdGUpIHtcbiAgICB2YXIgcGkgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNREFQWycgKyByb3VuZCArICddJywgcGkpOyB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICBpZiAocm91bmQpIHsgZCA9IHN0YXRlLnJvdW5kKGQpOyB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xufVxuXG4vLyBJVVBbYV0gSW50ZXJwb2xhdGUgVW50b3VjaGVkIFBvaW50cyB0aHJvdWdoIHRoZSBvdXRsaW5lXG4vLyAweDMwXG5mdW5jdGlvbiBJVVAodiwgc3RhdGUpIHtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcbiAgICB2YXIgcExlbiA9IHoyLmxlbmd0aCAtIDI7XG4gICAgdmFyIGNwO1xuICAgIHZhciBwcDtcbiAgICB2YXIgbnA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSVVQWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuICAgICAgICBjcCA9IHoyW2ldOyAvLyBjdXJyZW50IHBvaW50XG5cbiAgICAgICAgLy8gaWYgdGhpcyBwb2ludCBoYXMgYmVlbiB0b3VjaGVkIGdvIG9uXG4gICAgICAgIGlmICh2LnRvdWNoZWQoY3ApKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgcHAgPSBjcC5wcmV2VG91Y2hlZCh2KTtcblxuICAgICAgICAvLyBubyBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkP1xuICAgICAgICBpZiAocHAgPT09IGNwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgbnAgPSBjcC5uZXh0VG91Y2hlZCh2KTtcblxuICAgICAgICBpZiAocHAgPT09IG5wKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkXG4gICAgICAgICAgICAvLyBzbyBzaW1wbHkgbW92ZXMgdGhlIHBvaW50IGxpa2UgdGhhdFxuXG4gICAgICAgICAgICB2LnNldFJlbGF0aXZlKGNwLCBjcCwgdi5kaXN0YW5jZShwcCwgcHAsIGZhbHNlLCB0cnVlKSwgdiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2LmludGVycG9sYXRlKGNwLCBwcCwgbnAsIHYpO1xuICAgIH1cbn1cblxuLy8gU0hQW10gU0hpZnQgUG9pbnQgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDMyLTB4MzNcbmZ1bmN0aW9uIFNIUChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKVxuICAgIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICAgICAgZnYudG91Y2gocCk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID9cbiAgICAgICAgICAgICAgICAgICAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOlxuICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgJ1NIUFsnICsgKGEgPyAncnAxJyA6ICdycDInKSArICddJywgcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gU0hDW10gU0hpZnQgQ29udG91ciB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzYtMHgzN1xuZnVuY3Rpb24gU0hDKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBjaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBzcCA9IHN0YXRlLnoyW3N0YXRlLmNvbnRvdXJzW2NpXV07XG4gICAgdmFyIHAgPSBzcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSENbJyArIGEgKyAnXScsIGNpKTsgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKHAgIT09IHJwKSB7IGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTsgfVxuICAgICAgICBwID0gcC5uZXh0UG9pbnRPbkNvbnRvdXI7XG4gICAgfSB3aGlsZSAocCAhPT0gc3ApO1xufVxuXG4vLyBTSFpbXSBTSGlmdCBab25lIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSFooYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIWlsnICsgYSArICddJywgZSk7IH1cblxuICAgIHZhciB6O1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIDAgOiB6ID0gc3RhdGUudFpvbmU7IGJyZWFrO1xuICAgICAgICBjYXNlIDEgOiB6ID0gc3RhdGUuZ1pvbmU7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUnKTtcbiAgICB9XG5cbiAgICB2YXIgcDtcbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuICAgIHZhciBwTGVuID0gei5sZW5ndGggLSAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKVxuICAgIHtcbiAgICAgICAgcCA9IHpbaV07XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICAgICAgLy9pZiAocCAhPT0gcnApIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICB9XG59XG5cbi8vIFNIUElYW10gU0hpZnQgcG9pbnQgYnkgYSBQSVhlbCBhbW91bnRcbi8vIDB4MzhcbmZ1bmN0aW9uIFNIUElYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBkID0gc3RhY2sucG9wKCkgLyAweDQwO1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnU0hQSVhbXScsIHBpLCBkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCk7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBJUFtdIEludGVycG9sYXRlIFBvaW50XG4vLyAweDM5XG5mdW5jdGlvbiBJUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycDFpID0gc3RhdGUucnAxO1xuICAgIHZhciBycDJpID0gc3RhdGUucnAyO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgcnAxID0gc3RhdGUuejBbcnAxaV07XG4gICAgdmFyIHJwMiA9IHN0YXRlLnoxW3JwMmldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ0lQW10nLCBwaSwgcnAxaSwgJzwtPicsIHJwMmlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5pbnRlcnBvbGF0ZShwLCBycDEsIHJwMiwgcHYpO1xuXG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBNU0lSUFthXSBNb3ZlIFN0YWNrIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweDNBLTB4M0JcbmZ1bmN0aW9uIE1TSVJQKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDY0O1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuICAgIHZhciBycDAgPSBzdGF0ZS56MFtzdGF0ZS5ycDBdO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVNJUlBbJyArIGEgKyAnXScsIGQsIHBpKTsgfVxuXG4gICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuICAgIHN0YXRlLnJwMiA9IHBpO1xuICAgIGlmIChhKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG59XG5cbi8vIEFMSUdOUlBbXSBBbGlnbiB0byByZWZlcmVuY2UgcG9pbnQuXG4vLyAweDNDXG5mdW5jdGlvbiBBTElHTlJQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwMGkgPSBzdGF0ZS5ycDA7XG4gICAgdmFyIHJwMCA9IHN0YXRlLnowW3JwMGldO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgejEgPSBzdGF0ZS56MTtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejFbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ0FMSUdOUlBbXScsIHBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCAwLCBwdik7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBEb3VibGUgR3JpZFxuLy8gMHgzRFxuZnVuY3Rpb24gUlRERyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVERHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvRG91YmxlR3JpZDtcbn1cblxuLy8gTUlBUFthXSBNb3ZlIEluZGlyZWN0IEFic29sdXRlIFBvaW50XG4vLyAweDNFLTB4M0ZcbmZ1bmN0aW9uIE1JQVAocm91bmQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgY3YgPSBzdGF0ZS5jdnRbbl07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAnTUlBUFsnICsgcm91bmQgKyAnXScsXG4gICAgICAgICAgICBuLCAnKCcsIGN2LCAnKScsIHBpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShwLCBIUFplcm8pO1xuXG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cblxuICAgICAgICBkID0gc3RhdGUucm91bmQoZCk7XG4gICAgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG5cbiAgICBpZiAoc3RhdGUuenAwID09PSAwKSB7XG4gICAgICAgIHAueG8gPSBwLng7XG4gICAgICAgIHAueW8gPSBwLnk7XG4gICAgfVxuXG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcbn1cblxuLy8gTlBVU0JbXSBQVVNIIE4gQnl0ZXNcbi8vIDB4NDBcbmZ1bmN0aW9uIE5QVVNIQihzdGF0ZSkge1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSEJbXScsIG4pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBzdGFjay5wdXNoKHByb2dbKytpcF0pOyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBOUFVTSFdbXSBQVVNIIE4gV29yZHNcbi8vIDB4NDFcbmZ1bmN0aW9uIE5QVVNIVyhzdGF0ZSkge1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHByb2dbKytpcF07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hXW10nLCBuKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSAocHJvZ1srK2lwXSA8PCA4KSB8IHByb2dbKytpcF07XG4gICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG4gICAgICAgIHN0YWNrLnB1c2godyk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gV1NbXSBXcml0ZSBTdG9yZVxuLy8gMHg0MlxuZnVuY3Rpb24gV1Moc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIGlmICghc3RvcmUpIHsgc3RvcmUgPSBzdGF0ZS5zdG9yZSA9IFtdOyB9XG5cbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV1MnLCB2LCBsKTsgfVxuXG4gICAgc3RvcmVbbF0gPSB2O1xufVxuXG4vLyBSU1tdIFJlYWQgU3RvcmVcbi8vIDB4NDNcbmZ1bmN0aW9uIFJTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHN0b3JlID0gc3RhdGUuc3RvcmU7XG5cbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JTJywgbCk7IH1cblxuICAgIHZhciB2ID0gKHN0b3JlICYmIHN0b3JlW2xdKSB8fCAwO1xuXG4gICAgc3RhY2sucHVzaCh2KTtcbn1cblxuLy8gV0NWVFBbXSBXcml0ZSBDb250cm9sIFZhbHVlIFRhYmxlIGluIFBpeGVsIHVuaXRzXG4vLyAweDQ0XG5mdW5jdGlvbiBXQ1ZUUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRQJywgdiwgbCk7IH1cblxuICAgIHN0YXRlLmN2dFtsXSA9IHYgLyAweDQwO1xufVxuXG4vLyBSQ1ZUW10gUmVhZCBDb250cm9sIFZhbHVlIFRhYmxlIGVudHJ5XG4vLyAweDQ1XG5mdW5jdGlvbiBSQ1ZUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGN2dGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSQ1ZUJywgY3Z0ZSk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUuY3Z0W2N2dGVdICogMHg0MCk7XG59XG5cbi8vIEdDW10gR2V0IENvb3JkaW5hdGUgcHJvamVjdGVkIG9udG8gdGhlIHByb2plY3Rpb24gdmVjdG9yXG4vLyAweDQ2LTB4NDdcbmZ1bmN0aW9uIEdDKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0NbJyArIGEgKyAnXScsIHBpKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5kcHYuZGlzdGFuY2UocCwgSFBaZXJvLCBhLCBmYWxzZSkgKiAweDQwKTtcbn1cblxuLy8gTURbYV0gTWVhc3VyZSBEaXN0YW5jZVxuLy8gMHg0OS0weDRBXG5mdW5jdGlvbiBNRChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwaTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkxID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejFbcGkyXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MFtwaTFdO1xuICAgIHZhciBkID0gc3RhdGUuZHB2LmRpc3RhbmNlKHAxLCBwMiwgYSwgYSk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURbJyArIGEgKyAnXScsIHBpMiwgcGkxLCAnLT4nLCBkKTsgfVxuXG4gICAgc3RhdGUuc3RhY2sucHVzaChNYXRoLnJvdW5kKGQgKiA2NCkpO1xufVxuXG4vLyBNUFBFTVtdIE1lYXN1cmUgUGl4ZWxzIFBlciBFTVxuLy8gMHg0QlxuZnVuY3Rpb24gTVBQRU0oc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVBQRU1bXScpOyB9XG4gICAgc3RhdGUuc3RhY2sucHVzaChzdGF0ZS5wcGVtKTtcbn1cblxuLy8gRkxJUE9OW10gc2V0IHRoZSBhdXRvIEZMSVAgQm9vbGVhbiB0byBPTlxuLy8gMHg0RFxuZnVuY3Rpb24gRkxJUE9OKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMSVBPTltdJyk7IH1cbiAgICBzdGF0ZS5hdXRvRmxpcCA9IHRydWU7XG59XG5cbi8vIExUW10gTGVzcyBUaGFuXG4vLyAweDUwXG5mdW5jdGlvbiBMVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xUW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxIDwgZTIgPyAxIDogMCk7XG59XG5cbi8vIExURVFbXSBMZXNzIFRoYW4gb3IgRVF1YWxcbi8vIDB4NTNcbmZ1bmN0aW9uIExURVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVEVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxIDw9IGUyID8gMSA6IDApO1xufVxuXG4vLyBHVEVRW10gR3JlYXRlciBUaGFuXG4vLyAweDUyXG5mdW5jdGlvbiBHVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dUW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxID4gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW4gb3IgRVF1YWxcbi8vIDB4NTNcbmZ1bmN0aW9uIEdURVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHVEVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxID49IGUyID8gMSA6IDApO1xufVxuXG4vLyBFUVtdIEVRdWFsXG4vLyAweDU0XG5mdW5jdGlvbiBFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyID09PSBlMSA/IDEgOiAwKTtcbn1cblxuLy8gTkVRW10gTm90IEVRdWFsXG4vLyAweDU1XG5mdW5jdGlvbiBORVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgIT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBPRERbXSBPRERcbi8vIDB4NTZcbmZ1bmN0aW9uIE9ERChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT0REW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDEgOiAwKTtcbn1cblxuLy8gRVZFTltdIEVWRU5cbi8vIDB4NTdcbmZ1bmN0aW9uIEVWRU4oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VWRU5bXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMCA6IDEpO1xufVxuXG4vLyBJRltdIElGIHRlc3Rcbi8vIDB4NThcbmZ1bmN0aW9uIElGKHN0YXRlKSB7XG4gICAgdmFyIHRlc3QgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJRltdJywgdGVzdCk7IH1cblxuICAgIC8vIGlmIHRlc3QgaXMgdHJ1ZSBpdCBqdXN0IGNvbnRpbnVlc1xuICAgIC8vIGlmIG5vdCB0aGUgaXAgaXMgc2tpcHBlZCB1bnRpbCBtYXRjaGluZyBFTFNFIG9yIEVJRlxuICAgIGlmICghdGVzdCkge1xuICAgICAgICBza2lwKHN0YXRlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAgJ0VJRltdJyk7IH1cbiAgICB9XG59XG5cbi8vIEVJRltdIEVuZCBJRlxuLy8gMHg1OVxuZnVuY3Rpb24gRUlGKHN0YXRlKSB7XG4gICAgLy8gdGhpcyBjYW4gYmUgcmVhY2hlZCBub3JtYWxseSB3aGVuXG4gICAgLy8gZXhlY3V0aW5nIGFuIGVsc2UgYnJhbmNoLlxuICAgIC8vIC0+IGp1c3QgaWdub3JlIGl0XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUlGW10nKTsgfVxufVxuXG4vLyBBTkRbXSBsb2dpY2FsIEFORFxuLy8gMHg1QVxuZnVuY3Rpb24gQU5EKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQU5EW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyICYmIGUxID8gMSA6IDApO1xufVxuXG4vLyBPUltdIGxvZ2ljYWwgT1Jcbi8vIDB4NUJcbmZ1bmN0aW9uIE9SKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT1JbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgfHwgZTEgPyAxIDogMCk7XG59XG5cbi8vIE5PVFtdIGxvZ2ljYWwgTk9UXG4vLyAweDVDXG5mdW5jdGlvbiBOT1Qoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05PVFtdJywgZSk7IH1cblxuICAgIHN0YWNrLnB1c2goZSA/IDAgOiAxKTtcbn1cblxuLy8gREVMVEFQMVtdIERFTFRBIGV4Y2VwdGlvbiBQMVxuLy8gREVMVEFQMltdIERFTFRBIGV4Y2VwdGlvbiBQMlxuLy8gREVMVEFQM1tdIERFTFRBIGV4Y2VwdGlvbiBQM1xuLy8gMHg1RCwgMHg3MSwgMHg3MlxuZnVuY3Rpb24gREVMVEFQMTIzKGIsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgcHBlbSA9IHN0YXRlLnBwZW07XG4gICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG4gICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcbiAgICB2YXIgejAgPSBzdGF0ZS56MDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBbJyArIGIgKyAnXScsIG4sIHN0YWNrKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUEZJWCcsIHBpLCAnYnknLCBtYWcgKiBkcyk7IH1cblxuICAgICAgICB2YXIgcCA9IHowW3BpXTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgbWFnICogZHMsIHB2KTtcbiAgICB9XG59XG5cbi8vIFNEQltdIFNldCBEZWx0YSBCYXNlIGluIHRoZSBncmFwaGljcyBzdGF0ZVxuLy8gMHg1RVxuZnVuY3Rpb24gU0RCKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTREJbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5kZWx0YUJhc2UgPSBuO1xufVxuXG4vLyBTRFNbXSBTZXQgRGVsdGEgU2hpZnQgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVGXG5mdW5jdGlvbiBTRFMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEU1tdJywgbik7IH1cblxuICAgIHN0YXRlLmRlbHRhU2hpZnQgPSBNYXRoLnBvdygwLjUsIG4pO1xufVxuXG4vLyBBRERbXSBBRERcbi8vIDB4NjBcbmZ1bmN0aW9uIEFERChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FERFtdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSArIG4yKTtcbn1cblxuLy8gU1VCW10gU1VCXG4vLyAweDYxXG5mdW5jdGlvbiBTVUIoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVUJbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgLSBuMik7XG59XG5cbi8vIERJVltdIERJVlxuLy8gMHg2MlxuZnVuY3Rpb24gRElWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRElWW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICogNjQgLyBuMik7XG59XG5cbi8vIE1VTFtdIE1VTFxuLy8gMHg2M1xuZnVuY3Rpb24gTVVMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVVMW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICogbjIgLyA2NCk7XG59XG5cbi8vIEFCU1tdIEFCU29sdXRlIHZhbHVlXG4vLyAweDY0XG5mdW5jdGlvbiBBQlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FCU1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5hYnMobikpO1xufVxuXG4vLyBORUdbXSBORUdhdGVcbi8vIDB4NjVcbmZ1bmN0aW9uIE5FRyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTkVHW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaCgtbik7XG59XG5cbi8vIEZMT09SW10gRkxPT1Jcbi8vIDB4NjZcbmZ1bmN0aW9uIEZMT09SKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGTE9PUltdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5mbG9vcihuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gQ0VJTElOR1tdIENFSUxJTkdcbi8vIDB4NjdcbmZ1bmN0aW9uIENFSUxJTkcoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NFSUxJTkdbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguY2VpbChuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gUk9VTkRbYWJdIFJPVU5EIHZhbHVlXG4vLyAweDY4LTB4NkJcbmZ1bmN0aW9uIFJPVU5EKGR0LCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9VTkRbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLnJvdW5kKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBXQ1ZURltdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gRnVuaXRzXG4vLyAweDcwXG5mdW5jdGlvbiBXQ1ZURihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZURltdJywgdiwgbCk7IH1cblxuICAgIHN0YXRlLmN2dFtsXSA9IHYgKiBzdGF0ZS5wcGVtIC8gc3RhdGUuZm9udC51bml0c1BlckVtO1xufVxuXG4vLyBERUxUQUMxW10gREVMVEEgZXhjZXB0aW9uIEMxXG4vLyBERUxUQUMyW10gREVMVEEgZXhjZXB0aW9uIEMyXG4vLyBERUxUQUMzW10gREVMVEEgZXhjZXB0aW9uIEMzXG4vLyAweDczLCAweDc0LCAweDc1XG5mdW5jdGlvbiBERUxUQUMxMjMoYiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ1snICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcHBlbSA9IGJhc2UgKyAoKGFyZyAmIDB4RjApID4+IDQpO1xuICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcbiAgICAgICAgaWYgKG1hZyA+PSAwKSB7IG1hZysrOyB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbWFnICogZHM7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ0ZJWCcsIGMsICdieScsIGRlbHRhKTsgfVxuXG4gICAgICAgIHN0YXRlLmN2dFtjXSArPSBkZWx0YTtcbiAgICB9XG59XG5cbi8vIFNST1VORFtdIFN1cGVyIFJPVU5EXG4vLyAweDc2XG5mdW5jdGlvbiBTUk9VTkQoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NST1VORFtdJywgbik7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIHZhciBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDAuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4NDA6XG4gICAgICAgICAgICBwZXJpb2QgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTUk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zclBlcmlvZCA9IHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4MzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuMjUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDIwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNSAgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDMwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNzUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIG4gJj0gMHgwRjtcblxuICAgIGlmIChuID09PSAwKSB7IHN0YXRlLnNyVGhyZXNob2xkID0gMDsgfVxuICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cbn1cblxuLy8gUzQ1Uk9VTkRbXSBTdXBlciBST1VORCA0NSBkZWdyZWVzXG4vLyAweDc3XG5mdW5jdGlvbiBTNDVST1VORChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUzQ1Uk9VTkRbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kU3VwZXI7XG5cbiAgICB2YXIgcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHhDMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMikgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4ODA6XG4gICAgICAgICAgICBwZXJpb2QgPSAyICogTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zclBlcmlvZCA9IHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4MzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuMjUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDIwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNSAgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDMwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNzUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIG4gJj0gMHgwRjtcblxuICAgIGlmIChuID09PSAwKSB7IHN0YXRlLnNyVGhyZXNob2xkID0gMDsgfVxuICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cbn1cblxuLy8gUk9GRltdIFJvdW5kIE9mZlxuLy8gMHg3QVxuZnVuY3Rpb24gUk9GRihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST0ZGW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZE9mZjtcbn1cblxuLy8gUlVUR1tdIFJvdW5kIFVwIFRvIEdyaWRcbi8vIDB4N0NcbmZ1bmN0aW9uIFJVVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlVUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRVcFRvR3JpZDtcbn1cblxuLy8gUkRUR1tdIFJvdW5kIERvd24gVG8gR3JpZFxuLy8gMHg3RFxuZnVuY3Rpb24gUkRURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSRFRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZERvd25Ub0dyaWQ7XG59XG5cbi8vIFNDQU5DVFJMW10gU0NBTiBjb252ZXJzaW9uIENvblRSb0xcbi8vIDB4ODVcbmZ1bmN0aW9uIFNDQU5DVFJMKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOQ1RSTFtdJywgbik7IH1cbn1cblxuLy8gU0RQVlRMW2FdIFNldCBEdWFsIFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcbi8vIDB4ODYtMHg4N1xuZnVuY3Rpb24gU0RQVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gR0VUSU5GT1tdIEdFVCBJTkZPcm1hdGlvblxuLy8gMHg4OFxuZnVuY3Rpb24gR0VUSU5GTyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzZWwgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgciA9IDA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0VUSU5GT1tdJywgc2VsKTsgfVxuXG4gICAgLy8gdjM1IGFzIGluIG5vIHN1YnBpeGVsIGhpbnRpbmdcbiAgICBpZiAoc2VsICYgMHgwMSkgeyByID0gMzU7IH1cblxuICAgIC8vIFRPRE8gcm90YXRpb24gYW5kIHN0cmV0Y2ggY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICAvLyBhbmQgdGh1cyB0aG9zZSBHRVRJTkZPIGFyZSBhbHdheXMgMC5cblxuICAgIC8vIG9wZW50eXBlLmpzIGlzIGFsd2F5cyBncmF5IHNjYWxpbmdcbiAgICBpZiAoc2VsICYgMHgyMCkgeyByIHw9IDB4MTAwMDsgfVxuXG4gICAgc3RhY2sucHVzaChyKTtcbn1cblxuLy8gUk9MTFtdIFJPTEwgdGhlIHRvcCB0aHJlZSBzdGFjayBlbGVtZW50c1xuLy8gMHg4QVxuZnVuY3Rpb24gUk9MTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPTExbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGIpO1xuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChjKTtcbn1cblxuLy8gTUFYW10gTUFYaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhCXG5mdW5jdGlvbiBNQVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNQVhbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5tYXgoZTEsIGUyKSk7XG59XG5cbi8vIE1JTltdIE1JTmltdW0gb2YgdG9wIHR3byBzdGFjayBlbGVtZW50c1xuLy8gMHg4Q1xuZnVuY3Rpb24gTUlOKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgubWluKGUxLCBlMikpO1xufVxuXG4vLyBTQ0FOVFlQRVtdIFNDQU5UWVBFXG4vLyAweDhEXG5mdW5jdGlvbiBTQ0FOVFlQRShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOVFlQRVtdJywgbik7IH1cbn1cblxuLy8gSU5TVENUUkxbXSBJTlNUQ1RSTFxuLy8gMHg4RFxuZnVuY3Rpb24gSU5TVENUUkwoc3RhdGUpIHtcbiAgICB2YXIgcyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSU5TVENUUkxbXScsIHMsIHYpOyB9XG5cbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAxIDogc3RhdGUuaW5oaWJpdEdyaWRGaXQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgY2FzZSAyIDogc3RhdGUuaWdub3JlQ3Z0ID0gISF2OyByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJTlNUQ1RSTFtdIHNlbGVjdG9yJyk7XG4gICAgfVxufVxuXG4vLyBQVVNIQlthYmNdIFBVU0ggQnl0ZXNcbi8vIDB4QjAtMHhCN1xuZnVuY3Rpb24gUFVTSEIobiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUFVTSEJbJyArIG4gKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBzdGFjay5wdXNoKHByb2dbKytpcF0pOyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBQVVNIV1thYmNdIFBVU0ggV29yZHNcbi8vIDB4QjgtMHhCRlxuZnVuY3Rpb24gUFVTSFcobiwgc3RhdGUpIHtcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5pcCwgJ1BVU0hXWycgKyBuICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSAocHJvZ1srK2lwXSA8PCA4KSB8IHByb2dbKytpcF07XG4gICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG4gICAgICAgIHN0YWNrLnB1c2godyk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gTURSUFthYmNkZV0gTW92ZSBEaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4RDAtMHhFRlxuLy8gKGlmIGluZGlyZWN0IGlzIDApXG4vL1xuLy8gYW5kXG4vL1xuLy8gTUlSUFthYmNkZV0gTW92ZSBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHhFMC0weEZGXG4vLyAoaWYgaW5kaXJlY3QgaXMgMSlcblxuZnVuY3Rpb24gTURSUF9NSVJQKGluZGlyZWN0LCBzZXRScDAsIGtlZXBELCBybywgZHQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGN2dGUgPSBpbmRpcmVjdCAmJiBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICB2YXIgcnAgPSBzdGF0ZS56MFtycDBpXTtcbiAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcblxuICAgIHZhciBtZCA9IHN0YXRlLm1pbkRpcztcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5kcHY7XG4gICAgdmFyIG9kOyAvLyBvcmlnaW5hbCBkaXN0YW5jZVxuICAgIHZhciBkOyAvLyBtb3ZpbmcgZGlzdGFuY2VcbiAgICB2YXIgc2lnbjsgLy8gc2lnbiBvZiBkaXN0YW5jZVxuICAgIHZhciBjdjtcblxuICAgIGQgPSBvZCA9IHB2LmRpc3RhbmNlKHAsIHJwLCB0cnVlLCB0cnVlKTtcbiAgICBzaWduID0gZCA+PSAwID8gMSA6IC0xOyAvLyBNYXRoLnNpZ24gd291bGQgYmUgMCBpbiBjYXNlIG9mIDBcblxuICAgIC8vIFRPRE8gY29uc2lkZXIgYXV0b0ZsaXBcbiAgICBkID0gTWF0aC5hYnMoZCk7XG5cbiAgICBpZiAoaW5kaXJlY3QpIHtcbiAgICAgICAgY3YgPSBzdGF0ZS5jdnRbY3Z0ZV07XG5cbiAgICAgICAgaWYgKHJvICYmIE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuICAgIH1cblxuICAgIGlmIChrZWVwRCAmJiBkIDwgbWQpIHsgZCA9IG1kOyB9XG5cbiAgICBpZiAocm8pIHsgZCA9IHN0YXRlLnJvdW5kKGQpOyB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBycCwgc2lnbiAqIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgIChpbmRpcmVjdCA/ICdNSVJQWycgOiAnTURSUFsnKSArXG4gICAgICAgICAgICAoc2V0UnAwID8gJ00nIDogJ20nKSArXG4gICAgICAgICAgICAoa2VlcEQgPyAnPicgOiAnXycpICtcbiAgICAgICAgICAgIChybyA/ICdSJyA6ICdfJykgK1xuICAgICAgICAgICAgKGR0ID09PSAwID8gJ0dyJyA6IChkdCA9PT0gMSA/ICdCbCcgOiAoZHQgPT09IDIgPyAnV2gnIDogJycpKSkgK1xuICAgICAgICAgICAgJ10nLFxuICAgICAgICAgICAgaW5kaXJlY3QgP1xuICAgICAgICAgICAgICAgIGN2dGUgKyAnKCcgKyBzdGF0ZS5jdnRbY3Z0ZV0gKyAnLCcgKyAgY3YgKyAnKScgOlxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgcGksXG4gICAgICAgICAgICAnKGQgPScsIG9kLCAnLT4nLCBzaWduICogZCwgJyknXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuICAgIHN0YXRlLnJwMiA9IHBpO1xuICAgIGlmIChzZXRScDApIHsgc3RhdGUucnAwID0gcGk7IH1cbn1cblxuLypcbiogVGhlIGluc3RydWN0aW9uIHRhYmxlLlxuKi9cbmluc3RydWN0aW9uVGFibGUgPSBbXG4gICAgLyogMHgwMCAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDEgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDAyICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDMgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNCAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDA1ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDYgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDcgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MDggKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDkgKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MEEgKi8gU1BWRlMsXG4gICAgLyogMHgwQiAqLyBTRlZGUyxcbiAgICAvKiAweDBDICovIEdQVixcbiAgICAvKiAweDBEICovIEdGVixcbiAgICAvKiAweDBFICovIFNGVlRQVixcbiAgICAvKiAweDBGICovIElTRUNULFxuICAgIC8qIDB4MTAgKi8gU1JQMCxcbiAgICAvKiAweDExICovIFNSUDEsXG4gICAgLyogMHgxMiAqLyBTUlAyLFxuICAgIC8qIDB4MTMgKi8gU1pQMCxcbiAgICAvKiAweDE0ICovIFNaUDEsXG4gICAgLyogMHgxNSAqLyBTWlAyLFxuICAgIC8qIDB4MTYgKi8gU1pQUyxcbiAgICAvKiAweDE3ICovIFNMT09QLFxuICAgIC8qIDB4MTggKi8gUlRHLFxuICAgIC8qIDB4MTkgKi8gUlRIRyxcbiAgICAvKiAweDFBICovIFNNRCxcbiAgICAvKiAweDFCICovIEVMU0UsXG4gICAgLyogMHgxQyAqLyBKTVBSLFxuICAgIC8qIDB4MUQgKi8gU0NWVENJLFxuICAgIC8qIDB4MUUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXQ0lcbiAgICAvKiAweDFGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV1xuICAgIC8qIDB4MjAgKi8gRFVQLFxuICAgIC8qIDB4MjEgKi8gUE9QLFxuICAgIC8qIDB4MjIgKi8gQ0xFQVIsXG4gICAgLyogMHgyMyAqLyBTV0FQLFxuICAgIC8qIDB4MjQgKi8gREVQVEgsXG4gICAgLyogMHgyNSAqLyBDSU5ERVgsXG4gICAgLyogMHgyNiAqLyBNSU5ERVgsXG4gICAgLyogMHgyNyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBBTElHTlBUU1xuICAgIC8qIDB4MjggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4MjkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gVVRQXG4gICAgLyogMHgyQSAqLyBMT09QQ0FMTCxcbiAgICAvKiAweDJCICovIENBTEwsXG4gICAgLyogMHgyQyAqLyBGREVGLFxuICAgIC8qIDB4MkQgKi8gdW5kZWZpbmVkLCAgIC8vIEVOREYgKGVhdGVuIGJ5IEZERUYpXG4gICAgLyogMHgyRSAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDJGICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzAgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgzMSAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDMyICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzMyAqLyBTSFAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzQgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDM1ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNiAqLyBTSFouYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzcgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM4ICovIFNIUElYLFxuICAgIC8qIDB4MzkgKi8gSVAsXG4gICAgLyogMHgzQSAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzQiAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzQyAqLyBBTElHTlJQLFxuICAgIC8qIDB4M0QgKi8gUlRERyxcbiAgICAvKiAweDNFICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4M0YgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0MCAqLyBOUFVTSEIsXG4gICAgLyogMHg0MSAqLyBOUFVTSFcsXG4gICAgLyogMHg0MiAqLyBXUyxcbiAgICAvKiAweDQzICovIFJTLFxuICAgIC8qIDB4NDQgKi8gV0NWVFAsXG4gICAgLyogMHg0NSAqLyBSQ1ZULFxuICAgIC8qIDB4NDYgKi8gR0MuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NDcgKi8gR0MuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NDggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU0NGU1xuICAgIC8qIDB4NDkgKi8gTUQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NEEgKi8gTUQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NEIgKi8gTVBQRU0sXG4gICAgLyogMHg0QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBNUFNcbiAgICAvKiAweDREICovIEZMSVBPTixcbiAgICAvKiAweDRFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBPRkZcbiAgICAvKiAweDRGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIERFQlVHXG4gICAgLyogMHg1MCAqLyBMVCxcbiAgICAvKiAweDUxICovIExURVEsXG4gICAgLyogMHg1MiAqLyBHVCxcbiAgICAvKiAweDUzICovIEdURVEsXG4gICAgLyogMHg1NCAqLyBFUSxcbiAgICAvKiAweDU1ICovIE5FUSxcbiAgICAvKiAweDU2ICovIE9ERCxcbiAgICAvKiAweDU3ICovIEVWRU4sXG4gICAgLyogMHg1OCAqLyBJRixcbiAgICAvKiAweDU5ICovIEVJRixcbiAgICAvKiAweDVBICovIEFORCxcbiAgICAvKiAweDVCICovIE9SLFxuICAgIC8qIDB4NUMgKi8gTk9ULFxuICAgIC8qIDB4NUQgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDVFICovIFNEQixcbiAgICAvKiAweDVGICovIFNEUyxcbiAgICAvKiAweDYwICovIEFERCxcbiAgICAvKiAweDYxICovIFNVQixcbiAgICAvKiAweDYyICovIERJVixcbiAgICAvKiAweDYzICovIE1VTCxcbiAgICAvKiAweDY0ICovIEFCUyxcbiAgICAvKiAweDY1ICovIE5FRyxcbiAgICAvKiAweDY2ICovIEZMT09SLFxuICAgIC8qIDB4NjcgKi8gQ0VJTElORyxcbiAgICAvKiAweDY4ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDY5ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDZBICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDZCICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDZDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZEICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDcwICovIFdDVlRGLFxuICAgIC8qIDB4NzEgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDcyICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3MyAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NzQgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDc1ICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3NiAqLyBTUk9VTkQsXG4gICAgLyogMHg3NyAqLyBTNDVST1VORCxcbiAgICAvKiAweDc4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST1RbXVxuICAgIC8qIDB4NzkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPRltdXG4gICAgLyogMHg3QSAqLyBST0ZGLFxuICAgIC8qIDB4N0IgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4N0MgKi8gUlVURyxcbiAgICAvKiAweDdEICovIFJEVEcsXG4gICAgLyogMHg3RSAqLyBQT1AsIC8vIGFjdHVhbGx5IFNBTkdXLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4N0YgKi8gUE9QLCAvLyBhY3R1YWxseSBBQSwgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcbiAgICAvKiAweDgwICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBQVFxuICAgIC8qIDB4ODEgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT05cbiAgICAvKiAweDgyICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09GRlxuICAgIC8qIDB4ODMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODUgKi8gU0NBTkNUUkwsXG4gICAgLyogMHg4NiAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4ODcgKi8gU0RQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDg4ICovIEdFVElORk8sXG4gICAgLyogMHg4OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBJREVGXG4gICAgLyogMHg4QSAqLyBST0xMLFxuICAgIC8qIDB4OEIgKi8gTUFYLFxuICAgIC8qIDB4OEMgKi8gTUlOLFxuICAgIC8qIDB4OEQgKi8gU0NBTlRZUEUsXG4gICAgLyogMHg4RSAqLyBJTlNUQ1RSTCxcbiAgICAvKiAweDhGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkxICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEExICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEIwICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEIxICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEIyICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEIzICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEI0ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEI1ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEI2ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEI3ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEI4ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEI5ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEJBICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEJCICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEJDICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEJEICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEJFICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEJGICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEMwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMCksXG4gICAgLyogMHhDMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDEpLFxuICAgIC8qIDB4QzIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAyKSxcbiAgICAvKiAweEMzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMyksXG4gICAgLyogMHhDNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDApLFxuICAgIC8qIDB4QzUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAxKSxcbiAgICAvKiAweEM2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMiksXG4gICAgLyogMHhDNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDMpLFxuICAgIC8qIDB4QzggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAwKSxcbiAgICAvKiAweEM5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMSksXG4gICAgLyogMHhDQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDIpLFxuICAgIC8qIDB4Q0IgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAzKSxcbiAgICAvKiAweENDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMCksXG4gICAgLyogMHhDRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDEpLFxuICAgIC8qIDB4Q0UgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAyKSxcbiAgICAvKiAweENGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMyksXG4gICAgLyogMHhEMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDApLFxuICAgIC8qIDB4RDEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAxKSxcbiAgICAvKiAweEQyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMiksXG4gICAgLyogMHhEMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDMpLFxuICAgIC8qIDB4RDQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAwKSxcbiAgICAvKiAweEQ1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMSksXG4gICAgLyogMHhENiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDIpLFxuICAgIC8qIDB4RDcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAzKSxcbiAgICAvKiAweEQ4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMCksXG4gICAgLyogMHhEOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDEpLFxuICAgIC8qIDB4REEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAyKSxcbiAgICAvKiAweERCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMyksXG4gICAgLyogMHhEQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDApLFxuICAgIC8qIDB4REQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAxKSxcbiAgICAvKiAweERFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMiksXG4gICAgLyogMHhERiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDMpLFxuICAgIC8qIDB4RTAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEUxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhFMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4RTMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEU0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhFNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4RTYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEU3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhFOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4RTkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweEVBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhFQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4RUMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweEVEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhFRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4RUYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEYwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhGMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RjIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEYzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhGNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RjUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEY2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhGNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RjggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEY5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhGQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4RkIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweEZDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhGRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4RkUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweEZGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMylcbl07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBNYXRoZW1hdGljYWwgQ29uc2lkZXJhdGlvbnNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5mdiAuLi4gcmVmZXJzIHRvIGZyZWVkb20gdmVjdG9yXG5wdiAuLi4gcmVmZXJzIHRvIHByb2plY3Rpb24gdmVjdG9yXG5ycCAuLi4gcmVmZXJzIHRvIHJlZmVyZW5jZSBwb2ludFxucCAgLi4uIHJlZmVycyB0byB0byBwb2ludCBiZWluZyBvcGVyYXRlZCBvblxuZCAgLi4uIHJlZmVycyB0byBkaXN0YW5jZVxuXG5TRVRSRUxBVElWRTpcbj09PT09PT09PT09PVxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHgtYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAocHYpXG4gICAgICAgICAgICAgICAgICAgICAuLSdcbiAgICAgICAgICAgICAgcnBkIC4tJ1xuICAgICAgICAgICAgICAgLi0qXG4gICAgICAgICAgZCAuLSc5MMKwJ1xuICAgICAgICAgLi0nICAgICAgICdcbiAgICAgIC4tJyAgICAgICAgICAgJ1xuICAgKi0nICAgICAgICAgICAgICAgJyBiXG4gIHJwICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICBwICotLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tIChmdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG1cblxuICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgZXF1YXRpb24gb2YgbGluZSBiXG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4LSBycGR4KVxuXG4gICB5ID0gcC55XG5cbiAgIHggPSBycGR4ICsgKCBwLnkgLSBycGR5ICkgLyBwdm5zXG5cblxuY2FzZSBmcmVlZG9tIHZlY3RvciA9PSB5LWF4aXM6XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICogcG1cbiAgICB8XFxcbiAgICB8IFxcXG4gICAgfCAgXFxcbiAgICB8ICAgXFxcbiAgICB8ICAgIFxcXG4gICAgfCAgICAgXFxcbiAgICB8ICAgICAgXFxcbiAgICB8ICAgICAgIFxcXG4gICAgfCAgICAgICAgXFxcbiAgICB8ICAgICAgICAgXFwgYlxuICAgIHwgICAgICAgICAgXFxcbiAgICB8ICAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgICBcXCAgICAuLScgKHB2KVxuICAgIHwgICAgICAgICA5MMKwIFxcLi0nXG4gICAgfCAgICAgICAgICAgLi0nKiBycGRcbiAgICB8ICAgICAgICAuLSdcbiAgICAqICAgICAqLScgIGRcbiAgICBwICAgICBycFxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgICAgICAgIHB2bnMgLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG4gICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiAgIHggPSBwLnhcblxuICAgeSA9IHJwZHkgKyAgcHZucyAqIChwLnggLSBycGR4KVxuXG5cblxuZ2VuZXJpYyBjYXNlOlxuLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4qIHBtXG4gICAgICAgICAgICAgICAgICAgICAgICAuJyAhXG4gICAgICAgICAgICAgICAgICAgICAgLicgICAgLlxuICAgICAgICAgICAgICAgICAgICAuJyAgICAgICFcbiAgICAgICAgICAgICAgICAgIC4nICAgICAgICAgLiBiXG4gICAgICAgICAgICAgICAgLicgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgcCAgICAgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICAgICAgICAgICA5MMKwICAgLiAgICAuLi4gKHB2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLSotJycnXG4gICAgICAgICAgICAgICAgICAuLi4tLS0nJycgICAgcnBkXG4gICAgICAgICAuLi4tLS0nJycgICBkXG4gICAqLS0nJydcbiAgcnBcblxuICAgIHJwZHggPSBycHggKyBkICogcHYueFxuICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gZXF1YXRpb24gb2YgbGluZSBiOlxuICAgIHB2bnMuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiBlcXVhdGlvbiBvZiBmcmVlZG9tIHZlY3RvciBsaW5lOlxuICAgIGZ2cyAuLi4gc2xvcGUgb2YgZnJlZWRvbSB2ZWN0b3IgKD1meS9meClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblxuICBvbiBwbSBib3RoIGVxdWF0aW9ucyBhcmUgdHJ1ZSBmb3Igc2FtZSB4L3lcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cbiAgZm9ybSB0byB5IGFuZCBzZXQgZXF1YWw6XG5cbiAgICBwdm5zICogKHggLSBycGR4KSArIHJwZHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cbiAgZXhwYW5kOlxuXG4gICAgcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHkgPSBmdnMgKiB4IC0gZnZzICogcHggKyBweVxuXG4gIHN3aXRjaDpcblxuICAgIGZ2cyAqIHggLSBmdnMgKiBweCArIHB5ID0gcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHlcblxuICBzb2x2ZSBmb3IgeDpcblxuICAgIGZ2cyAqIHggLSBwdm5zICogeCA9IGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggLSBweSArIHJwZHlcblxuXG5cbiAgICAgICAgICBmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5XG4gICAgeCA9ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICBmdnMgLSBwdm5zXG5cbiAgYW5kOlxuXG4gICAgeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuXG5cbklOVEVSUE9MQVRFOlxuPT09PT09PT09PT09XG5cbkV4YW1wbGVzIG9mIHBvaW50IGludGVycG9sYXRpb24uXG5cblRoZSB3ZWlnaHQgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSByZWZlcmVuY2UgcG9pbnQgZ2V0cyBiaWdnZXJcbnRoZSBmdXJ0aGVyIHRoZSBvdGhlciByZWZlcmVuY2UgcG9pbnQgaXMgYXdheSwgdGh1cyB0aGUgc2FmZXN0XG5vcHRpb24gKHRoYXQgaXMgYXZvaWRpbmcgMC8wIGRpdmlzaW9ucykgaXMgdG8gd2VpZ2h0IHRoZVxub3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhlIG90aGVyIHBvaW50IGJ5IHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMuXG5cbklmIHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMgaXMgMCwgdGhlbiBtb3ZlIHRoZSBwb2ludCBieSB0aGVcbmFyaXRobWV0aWMgYXZlcmFnZSBvZiB0aGUgbW92ZW1lbnQgb2YgYm90aCByZWZlcmVuY2UgcG9pbnRzLlxuXG5cblxuXG4gICAgICAgICAgICgrNilcbiAgICBycDFvICotLS0tPipycDFcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICgrMTIpXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgcnAybyAqLS0tLS0tLS0tLT4qIHJwMlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgICAgICAgICAyMCAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4ufCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gKCs4KSAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0tLS0+KnAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAxMiAgICAgLiAgICAgICAgICAyNCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgfC4uLi4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2XG5cblxuLS0tLS0tLVxuXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICgtMTApXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgcnAyICo8LS0tLS0tLS0tKiBycG8yXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgMTAgICAuICAgICAgICAgIDMwICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gKCs1KSAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0+KiBwICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgIDIwICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIHwuLi4ufC4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgNSAgICAgICAgMTVcblxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLlxuICAgIHJwMm8gKi0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tPiogcFxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLigrMzApXG4gICAgcnAybyAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qcnAyXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qIHBcblxuXG5cbnZpbTogc2V0IHRzPTQgc3c9NCBleHBhbmR0YWI6XG4qKioqKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgbGlzdCBvZiB0b2tlbnMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gVG9rZW4oY2hhcikge1xuICAgIHRoaXMuY2hhciA9IGNoYXI7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb250ZXh0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCByYW5nZSBlbmQgaW5kZXggb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgb3duZXIgY29udGV4dCBuYW1lXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRSYW5nZShzdGFydEluZGV4LCBlbmRPZmZzZXQsIGNvbnRleHROYW1lKSB7XG4gICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbmRPZmZzZXQgPSBlbmRPZmZzZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgY29udGV4dCBzdGFydCBhbmQgZW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgYSB1bmlxdWUgY29udGV4dCBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjaGVja1N0YXJ0IGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoZSBpbmRpY2F0ZXMgYSBjb250ZXh0J3Mgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNoZWNrRW5kIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoZSBpbmRpY2F0ZXMgYSBjb250ZXh0J3MgZW5kXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRDaGVja2VyKGNvbnRleHROYW1lLCBjaGVja1N0YXJ0LCBjaGVja0VuZCkge1xuICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICB0aGlzLm9wZW5SYW5nZSA9IG51bGw7XG4gICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB0aGlzLmNoZWNrU3RhcnQgPSBjaGVja1N0YXJ0O1xuICAgIHRoaXMuY2hlY2tFbmQgPSBjaGVja0VuZDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBDb250ZXh0UGFyYW1zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7YXJyYXl9IGNvbnRleHQgY29udGV4dCBpdGVtc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGN1cnJlbnRJbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgcGFyYW1zXG4gKiBAcGFyYW0ge2FycmF5fSBjb250ZXh0IGEgbGlzdCBvZiBpdGVtc1xuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFBhcmFtcyhjb250ZXh0LCBjdXJyZW50SW5kZXgpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuaW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgdGhpcy5sZW5ndGggPSBjb250ZXh0Lmxlbmd0aDtcbiAgICB0aGlzLmN1cnJlbnQgPSBjb250ZXh0W2N1cnJlbnRJbmRleF07XG4gICAgdGhpcy5iYWNrdHJhY2sgPSBjb250ZXh0LnNsaWNlKDAsIGN1cnJlbnRJbmRleCk7XG4gICAgdGhpcy5sb29rYWhlYWQgPSBjb250ZXh0LnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBldmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgZXZlbnQgdW5pcXVlIGlkXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50SWQpIHtcbiAgICB0aGlzLmV2ZW50SWQgPSBldmVudElkO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgY29yZSBldmVudHMgYW5kIGF1dG8gc3Vic2NyaWJlIHJlcXVpcmVkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge2FueX0gZXZlbnRzIGFuIG9iamVjdCB0aGF0IGVubGlzdHMgY29yZSBldmVudHMgaGFuZGxlcnNcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvcmVFdmVudHMoZXZlbnRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY29yZUV2ZW50cyA9IFtcbiAgICAgICAgJ3N0YXJ0JywgJ2VuZCcsICduZXh0JywgJ25ld1Rva2VuJywgJ2NvbnRleHRTdGFydCcsXG4gICAgICAgICdjb250ZXh0RW5kJywgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcbiAgICAgICAgJ3JlcGxhY2VUb2tlbicsICdyZXBsYWNlUmFuZ2UnLCAnY29tcG9zZVJVRCcsICd1cGRhdGVDb250ZXh0c1JhbmdlcydcbiAgICBdO1xuXG4gICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzJDEuZXZlbnRzLCBldmVudElkLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEV2ZW50KGV2ZW50SWQpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCEhZXZlbnRzKSB7XG4gICAgICAgIGNvcmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW2V2ZW50SWRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXF1aXJlc0NvbnRleHRVcGRhdGUgPSBbXG4gICAgICAgICdpbnNlcnRUb2tlbicsICdyZW1vdmVUb2tlbicsICdyZW1vdmVSYW5nZScsXG4gICAgICAgICdyZXBsYWNlVG9rZW4nLCAncmVwbGFjZVJhbmdlJywgJ2NvbXBvc2VSVUQnXG4gICAgXTtcbiAgICByZXF1aXJlc0NvbnRleHRVcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgICAgICB0aGlzJDEuZXZlbnRzW2V2ZW50SWRdLnN1YnNjcmliZShcbiAgICAgICAgICAgIHRoaXMkMS51cGRhdGVDb250ZXh0c1Jhbmdlc1xuICAgICAgICApO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHthbnl9IGV2ZW50cyB0b2tlbml6ZXIgY29yZSBldmVudHNcbiAqL1xuZnVuY3Rpb24gVG9rZW5pemVyKGV2ZW50cykge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5yZWdpc3RlcmVkQ29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmNvbnRleHRDaGVja2VycyA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kaWZpZXJzID0gW107XG5cbiAgICBpbml0aWFsaXplQ29yZUV2ZW50cy5jYWxsKHRoaXMsIGV2ZW50cyk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhdGUgb2YgYSB0b2tlbiwgdXN1YWxseSBjYWxsZWQgYnkgYSBzdGF0ZSBtb2RpZmllci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3RhdGUgaXRlbSBrZXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBzdGF0ZSBpdGVtIHZhbHVlXG4gKi9cblRva2VuLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICB0aGlzLmFjdGl2ZVN0YXRlID0geyBrZXk6IGtleSwgdmFsdWU6IHRoaXMuc3RhdGVba2V5XSB9O1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlO1xufTtcblxuVG9rZW4ucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtzdGF0ZUlkXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5kZXggZXhpc3RzIGluIHRoZSB0b2tlbnMgbGlzdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmluYm91bmRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgYW5kIGFwcGx5IGEgbGlzdCBvZiBvcGVyYXRpb25zIChyZXBsYWNlLCB1cGRhdGUsIGRlbGV0ZSlcbiAqIEBwYXJhbSB7YXJyYXl9IFJVRHMgcmVwbGFjZSwgdXBkYXRlIGFuZCBkZWxldGUgb3BlcmF0aW9uc1xuICogVE9ETzogUGVyZi4gT3B0aW1pemF0aW9uIChsZW5ndGhCZWZvcmUgPT09IGxlbmd0aEFmdGVyID8gZGlzcGF0Y2ggb25jZSlcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5jb21wb3NlUlVEID0gZnVuY3Rpb24gKFJVRHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzaWxlbnQgPSB0cnVlO1xuICAgIHZhciBzdGF0ZSA9IFJVRHMubWFwKGZ1bmN0aW9uIChSVUQpIHsgcmV0dXJuIChcbiAgICAgICAgdGhpcyQxW1JVRFswXV0uYXBwbHkodGhpcyQxLCBSVUQuc2xpY2UoMSkuY29uY2F0KHNpbGVudCkpXG4gICAgKTsgfSk7XG4gICAgdmFyIGhhc0ZBSUxPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eSgnRkFJTCcpXG4gICAgKTsgfTtcbiAgICBpZiAoc3RhdGUuZXZlcnkoaGFzRkFJTE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEZBSUw6IFwiY29tcG9zZVJVRDogb25lIG9yIG1vcmUgb3BlcmF0aW9ucyBoYXNuJ3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLFxuICAgICAgICAgICAgcmVwb3J0OiBzdGF0ZS5maWx0ZXIoaGFzRkFJTE9iamVjdClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaCgnY29tcG9zZVJVRCcsIFtzdGF0ZS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiAhaGFzRkFJTE9iamVjdChvcCk7IH0pXSk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSByYW5nZSBvZiB0b2tlbnMgd2l0aCBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcbiAqIEBwYXJhbSB7dG9rZW59IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVwbGFjZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIG9mZnNldCwgdG9rZW5zLCBzaWxlbnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgIT09IG51bGwgPyBvZmZzZXQgOiB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGlzVG9rZW5UeXBlID0gdG9rZW5zLmV2ZXJ5KGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfSk7XG4gICAgaWYgKCFpc05hTihzdGFydEluZGV4KSAmJiB0aGlzLmluYm91bmRJbmRleChzdGFydEluZGV4KSAmJiBpc1Rva2VuVHlwZSkge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSB0aGlzLnRva2Vucy5zcGxpY2UuYXBwbHkoXG4gICAgICAgICAgICB0aGlzLnRva2VucywgW3N0YXJ0SW5kZXgsIG9mZnNldF0uY29uY2F0KHRva2VucylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVwbGFjZVRva2VuJywgW3N0YXJ0SW5kZXgsIG9mZnNldCwgdG9rZW5zXSk7IH1cbiAgICAgICAgcmV0dXJuIFtyZXBsYWNlZCwgdG9rZW5zXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAncmVwbGFjZVJhbmdlOiBpbnZhbGlkIHRva2VucyBvciBzdGFydEluZGV4LicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSB0b2tlbiB3aXRoIGFub3RoZXIgdG9rZW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICogQHBhcmFtIHt0b2tlbn0gdG9rZW4gYSB0b2tlbiB0byByZXBsYWNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlcGxhY2VUb2tlbiA9IGZ1bmN0aW9uIChpbmRleCwgdG9rZW4sIHNpbGVudCkge1xuICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KGluZGV4KSAmJiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IHRoaXMudG9rZW5zLnNwbGljZShpbmRleCwgMSwgdG9rZW4pO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZXBsYWNlVG9rZW4nLCBbaW5kZXgsIHRva2VuXSk7IH1cbiAgICAgICAgcmV0dXJuIFtyZXBsYWNlZFswXSwgdG9rZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdyZXBsYWNlVG9rZW46IGludmFsaWQgdG9rZW4gb3IgaW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHJhbmdlIG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggcmFuZ2Ugc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgcmFuZ2Ugb2Zmc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24oc3RhcnRJbmRleCwgb2Zmc2V0LCBzaWxlbnQpIHtcbiAgICBvZmZzZXQgPSAhaXNOYU4ob2Zmc2V0KSA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnMuc3BsaWNlKHN0YXJ0SW5kZXgsIG9mZnNldCk7XG4gICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVtb3ZlUmFuZ2UnLCBbdG9rZW5zLCBzdGFydEluZGV4LCBvZmZzZXRdKTsgfVxuICAgIHJldHVybiB0b2tlbnM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRva2VuIGF0IGEgY2VydGFpbiBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlbW92ZVRva2VuID0gZnVuY3Rpb24oaW5kZXgsIHNpbGVudCkge1xuICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KGluZGV4KSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2Vucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZW1vdmVUb2tlbicsIFt0b2tlbiwgaW5kZXhdKTsgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlbW92ZVRva2VuOiBpbnZhbGlkIHRva2VuIGluZGV4LicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEluc2VydCBhIGxpc3Qgb2YgdG9rZW5zIGF0IGEgY2VydGFpbiBpbmRleFxuICogQHBhcmFtIHthcnJheX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5zZXJ0IHRoZSBsaXN0IG9mIHRva2VucyBhdCBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5pbnNlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbnMsIGluZGV4LCBzaWxlbnQpIHtcbiAgICB2YXIgdG9rZW5UeXBlID0gdG9rZW5zLmV2ZXJ5KFxuICAgICAgICBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuIGluc3RhbmNlb2YgVG9rZW47IH1cbiAgICApO1xuICAgIGlmICh0b2tlblR5cGUpIHtcbiAgICAgICAgdGhpcy50b2tlbnMuc3BsaWNlLmFwcGx5KFxuICAgICAgICAgICAgdGhpcy50b2tlbnMsIFtpbmRleCwgMF0uY29uY2F0KHRva2VucylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgnaW5zZXJ0VG9rZW4nLCBbdG9rZW5zLCBpbmRleF0pOyB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ2luc2VydFRva2VuOiBpbnZhbGlkIHRva2VuKHMpLicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc3RhdGUgbW9kaWZpZXIgdGhhdCBpcyBjYWxsZWQgb24gJ25ld1Rva2VuJyBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVySWQgc3RhdGUgbW9kaWZpZXIgaWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9kaWZpZXIgYSBmdW5jdGlvbiB0byB1cGRhdGUgdG9rZW4gc3RhdGVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3Rlck1vZGlmaWVyID0gZnVuY3Rpb24obW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuICAgIHRoaXMuZXZlbnRzLm5ld1Rva2VuLnN1YnNjcmliZShmdW5jdGlvbih0b2tlbiwgY29udGV4dFBhcmFtcykge1xuICAgICAgICB2YXIgY29uZGl0aW9uUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcbiAgICAgICAgdmFyIGNhbkFwcGx5TW9kaWZpZXIgPSAoXG4gICAgICAgICAgICBjb25kaXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBjb25kaXRpb25QYXJhbXMpID09PSB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RpZmllclBhcmFtcyA9IFt0b2tlbiwgY29udGV4dFBhcmFtc107XG4gICAgICAgIGlmIChjYW5BcHBseU1vZGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVWYWx1ZSA9IG1vZGlmaWVyLmFwcGx5KHRoaXMsIG1vZGlmaWVyUGFyYW1zKTtcbiAgICAgICAgICAgIHRva2VuLnNldFN0YXRlKG1vZGlmaWVySWQsIG5ld1N0YXRlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kaWZpZXJzLnB1c2gobW9kaWZpZXJJZCk7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSBhIGhhbmRsZXIgdG8gYW4gZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50SGFuZGxlciBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5zdWJzY3JpYmVycy5wdXNoKGV2ZW50SGFuZGxlcikpIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogKFwiaW52YWxpZCAnXCIgKyAodGhpcy5ldmVudElkKSArIFwiJyBldmVudCBoYW5kbGVyXCIpfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzSWQgc3Vic2NyaXB0aW9uIGlkXG4gKi9cbkV2ZW50LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzSWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLnNwbGljZShzdWJzSWQsIDEpO1xufTtcblxuLyoqXG4gKiBTZXRzIGNvbnRleHQgcGFyYW1zIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjb250ZXh0IHBhcmFtcyBjdXJyZW50IHZhbHVlIGluZGV4XG4gKi9cbkNvbnRleHRQYXJhbXMucHJvdG90eXBlLnNldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY29udGV4dFtpbmRleF07XG4gICAgdGhpcy5iYWNrdHJhY2sgPSB0aGlzLmNvbnRleHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgIHRoaXMubG9va2FoZWFkID0gdGhpcy5jb250ZXh0LnNsaWNlKGluZGV4ICsgMSk7XG59O1xuXG4vKipcbiAqIEdldCBhbiBpdGVtIGF0IGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBleGFtcGxlIChjdXJyZW50IHZhbHVlIGlzIDMpOlxuICogIDEgICAgMiAgIFszXSAgIDQgICAgNSAgIHwgICBpdGVtcyB2YWx1ZXNcbiAqIC0yICAgLTEgICAgMCAgICAxICAgIDIgICB8ICAgb2Zmc2V0IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBhbiBvZmZzZXQgZnJvbSBjdXJyZW50IHZhbHVlIGluZGV4XG4gKi9cbkNvbnRleHRQYXJhbXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAob2Zmc2V0ID09PSAwKTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGNhc2UgKG9mZnNldCA8IDAgJiYgTWF0aC5hYnMob2Zmc2V0KSA8PSB0aGlzLmJhY2t0cmFjay5sZW5ndGgpOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja3RyYWNrLnNsaWNlKG9mZnNldClbMF07XG4gICAgICAgIGNhc2UgKG9mZnNldCA+IDAgJiYgb2Zmc2V0IDw9IHRoaXMubG9va2FoZWFkLmxlbmd0aCk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWRbb2Zmc2V0IC0gMV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29udGV4dCByYW5nZSBpbnRvIGEgc3RyaW5nIHZhbHVlXG4gKiBAcGFyYW0ge2NvbnRleHRSYW5nZX0gcmFuZ2UgYSBjb250ZXh0IHJhbmdlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmFuZ2VUb1RleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb250ZXh0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pLmpvaW4oJycpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgdG9rZW5zIGludG8gYSBzdHJpbmdcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY29udGV4dCBieSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lIHRvIGdldFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dE5hbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMucmVnaXN0ZXJlZENvbnRleHRzW2NvbnRleHROYW1lXTtcbiAgICByZXR1cm4gISFjb250ZXh0ID8gY29udGV4dCA6IG51bGw7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgYSBuZXcgZXZlbnQgaGFuZGxlciB0byBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lIHRvIHN1YnNjcmliZSB0b1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRIYW5kbGVyIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbiBldmVudFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmICghIWV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5zdWJzY3JpYmUoZXZlbnRIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHthbnl9IGFyZ3MgZXZlbnQgaGFuZGxlciBhcmd1bWVudHNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgYXJncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFwcGx5KHRoaXMkMSwgYXJncyB8fCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgY29udGV4dCBjaGVja2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgYSB1bmlxdWUgY29udGV4dCBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb250ZXh0U3RhcnRDaGVjayBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvbiBjb250ZXh0IHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb250ZXh0RW5kQ2hlY2sgIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgZW5kXG4gKiBUT0RPOiBjYWxsIHRva2VuaXplIG9uIHJlZ2lzdHJhdGlvbiB0byB1cGRhdGUgY29udGV4dCByYW5nZXMgd2l0aCB0aGUgbmV3IGNvbnRleHQuXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVnaXN0ZXJDb250ZXh0Q2hlY2tlciA9IGZ1bmN0aW9uKGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrKSB7XG4gICAgaWYgKCEhdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKSkgeyByZXR1cm4ge1xuICAgICAgICBGQUlMOlxuICAgICAgICAoXCJjb250ZXh0IG5hbWUgJ1wiICsgY29udGV4dE5hbWUgKyBcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkLlwiKVxuICAgIH07IH1cbiAgICBpZiAodHlwZW9mIGNvbnRleHRTdGFydENoZWNrICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIFwibWlzc2luZyBjb250ZXh0IHN0YXJ0IGNoZWNrLlwiXG4gICAgfTsgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dEVuZENoZWNrICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIFwibWlzc2luZyBjb250ZXh0IGVuZCBjaGVjay5cIlxuICAgIH07IH1cbiAgICB2YXIgY29udGV4dENoZWNrZXJzID0gbmV3IENvbnRleHRDaGVja2VyKFxuICAgICAgICBjb250ZXh0TmFtZSwgY29udGV4dFN0YXJ0Q2hlY2ssIGNvbnRleHRFbmRDaGVja1xuICAgICk7XG4gICAgdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdID0gY29udGV4dENoZWNrZXJzO1xuICAgIHRoaXMuY29udGV4dENoZWNrZXJzLnB1c2goY29udGV4dENoZWNrZXJzKTtcbiAgICByZXR1cm4gY29udGV4dENoZWNrZXJzO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgY29udGV4dCByYW5nZSB0b2tlbnNcbiAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2VcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRSYW5nZVRva2VucyA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgdmFyIGVuZEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCArIHJhbmdlLmVuZE9mZnNldDtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgICB0aGlzLnRva2Vuc1xuICAgICAgICAgICAgLnNsaWNlKHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHJhbmdlcyBvZiBhIGNvbnRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRDb250ZXh0UmFuZ2VzID0gZnVuY3Rpb24oY29udGV4dE5hbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSk7XG4gICAgaWYgKCEhY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5yYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogKFwiY29udGV4dCBjaGVja2VyICdcIiArIGNvbnRleHROYW1lICsgXCInIGlzIG5vdCByZWdpc3RlcmVkLlwiKSB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVzZXRzIGNvbnRleHQgcmFuZ2VzIHRvIHJ1biBjb250ZXh0IHVwZGF0ZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc2V0Q29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWRDb250ZXh0cyA9IHRoaXMucmVnaXN0ZXJlZENvbnRleHRzO1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIHJlZ2lzdGVyZWRDb250ZXh0cykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZENvbnRleHRzLmhhc093blByb3BlcnR5KGNvbnRleHROYW1lKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSByZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuICAgICAgICAgICAgY29udGV4dC5yYW5nZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRleHRzUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXRDb250ZXh0c1JhbmdlcygpO1xuICAgIHZhciBjaGFycyA9IHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhjaGFycywgaSk7XG4gICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVDb250ZXh0c1JhbmdlcycsIFt0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c10pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBlbmQgb2Zmc2V0IG9mIGFuIG9wZW4gcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgcmFuZ2UgZW5kIG9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnNldEVuZE9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQsIGNvbnRleHROYW1lKSB7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZS5zdGFydEluZGV4O1xuICAgIHZhciByYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2Uoc3RhcnRJbmRleCwgb2Zmc2V0LCBjb250ZXh0TmFtZSk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkucmFuZ2VzO1xuICAgIHJhbmdlLnJhbmdlSWQgPSBjb250ZXh0TmFtZSArIFwiLlwiICsgKHJhbmdlcy5sZW5ndGgpO1xuICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZSA9IG51bGw7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuLyoqXG4gKiBSdW5zIGEgY29udGV4dCBjaGVjayBvbiB0aGUgY3VycmVudCBjb250ZXh0XG4gKiBAcGFyYW0ge2NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY3VycmVudCBjb250ZXh0IHBhcmFtc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJ1bkNvbnRleHRDaGVjayA9IGZ1bmN0aW9uKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbmRleCA9IGNvbnRleHRQYXJhbXMuaW5kZXg7XG4gICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGV4dENoZWNrZXIpIHtcbiAgICAgICAgdmFyIGNvbnRleHROYW1lID0gY29udGV4dENoZWNrZXIuY29udGV4dE5hbWU7XG4gICAgICAgIHZhciBvcGVuUmFuZ2UgPSB0aGlzJDEuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlO1xuICAgICAgICBpZiAoIW9wZW5SYW5nZSAmJiBjb250ZXh0Q2hlY2tlci5jaGVja1N0YXJ0KGNvbnRleHRQYXJhbXMpKSB7XG4gICAgICAgICAgICBvcGVuUmFuZ2UgPSBuZXcgQ29udGV4dFJhbmdlKGluZGV4LCBudWxsLCBjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICB0aGlzJDEuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlID0gb3BlblJhbmdlO1xuICAgICAgICAgICAgdGhpcyQxLmRpc3BhdGNoKCdjb250ZXh0U3RhcnQnLCBbY29udGV4dE5hbWUsIGluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhb3BlblJhbmdlICYmIGNvbnRleHRDaGVja2VyLmNoZWNrRW5kKGNvbnRleHRQYXJhbXMpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKGluZGV4IC0gb3BlblJhbmdlLnN0YXJ0SW5kZXgpICsgMTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMkMS5zZXRFbmRPZmZzZXQob2Zmc2V0LCBjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICB0aGlzJDEuZGlzcGF0Y2goJ2NvbnRleHRFbmQnLCBbY29udGV4dE5hbWUsIHJhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSB0ZXh0IGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYSB0ZXh0IHRvIHRva2VuaXplXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG4gICAgdmFyIGNoYXJzID0gQXJyYXkuZnJvbSh0ZXh0KTtcbiAgICB0aGlzLmRpc3BhdGNoKCdzdGFydCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhjaGFycywgaSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goJ25leHQnLCBbY29udGV4dFBhcmFtc10pO1xuICAgICAgICB0aGlzLnJ1bkNvbnRleHRDaGVjayhjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuKGNoYXIpO1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnbmV3VG9rZW4nLCBbdG9rZW4sIGNvbnRleHRQYXJhbXNdKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaCgnZW5kJywgW3RoaXMudG9rZW5zXSk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLy8g4pWt4pSA4pSE4pSE4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWuXG4vLyDilIogQ2hhcmFjdGVyIENsYXNzIEFzc2VydGlvbnMg4pSKIENoZWNrcyBpZiBhIGNoYXIgYmVsb25ncyB0byBhIGNlcnRhaW4gY2xhc3Mg4pSKXG4vLyDilbDilIDilb7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDila9cbi8vIGpzY3M6ZGlzYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgQXJhYmljXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQXJhYmljQ2hhcihjKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjVGXFx1MDY2QS1cXHUwNkQyXFx1MDZGQS1cXHUwNkZGXS8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgYW4gaXNvbGF0ZWQgYXJhYmljIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNJc29sYXRlZEFyYWJpY0NoYXIoY2hhcikge1xuICAgIHJldHVybiAvW1xcdTA2MzBcXHUwNjkwXFx1MDYyMVxcdTA2MzFcXHUwNjYxXFx1MDY3MVxcdTA2MjJcXHUwNjMyXFx1MDY3MlxcdTA2OTJcXHUwNkMyXFx1MDYyM1xcdTA2NzNcXHUwNjkzXFx1MDZDM1xcdTA2MjRcXHUwNjk0XFx1MDZDNFxcdTA2MjVcXHUwNjc1XFx1MDY5NVxcdTA2QzVcXHUwNkU1XFx1MDY3NlxcdTA2OTZcXHUwNkM2XFx1MDYyN1xcdTA2NzdcXHUwNjk3XFx1MDZDN1xcdTA2NDhcXHUwNjg4XFx1MDY5OFxcdTA2QzhcXHUwNjg5XFx1MDY5OVxcdTA2QzlcXHUwNjhBXFx1MDZDQVxcdTA2NkJcXHUwNjhCXFx1MDZDQlxcdTA2OENcXHUwNjhEXFx1MDZDRFxcdTA2RkRcXHUwNjhFXFx1MDZFRVxcdTA2RkVcXHUwNjJGXFx1MDY4RlxcdTA2Q0ZcXHUwNkVGXS8udGVzdChjaGFyKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgYW4gQXJhYmljIFRhc2hrZWVsIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNUYXNoa2VlbEFyYWJpY0NoYXIoY2hhcikge1xuICAgIHJldHVybiAvW1xcdTA2MDAtXFx1MDYwNVxcdTA2MEMtXFx1MDYwRVxcdTA2MTAtXFx1MDYxQlxcdTA2MUVcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURdLy50ZXN0KGNoYXIpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBMYXRpblxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc0xhdGluQ2hhcihjKSB7XG4gICAgcmV0dXJuIC9bQS16XS8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgd2hpdGVzcGFjZSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjKSB7XG4gICAgcmV0dXJuIC9cXHMvLnRlc3QoYyk7XG59XG5cbi8qKlxuICogUXVlcnkgYSBmZWF0dXJlIGJ5IHNvbWUgb2YgaXQncyBwcm9wZXJ0aWVzIHRvIGxvb2t1cCBhIGdseXBoIHN1YnN0aXR1dGlvbi5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBmZWF0dXJlIHF1ZXJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlUXVlcnkoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFN1YnN0aXR1dGlvbkFjdGlvblxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgc3Vic3RpdHV0aW9uIHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgZmVhdHVyZSB0YWdcbiAqIEBwcm9wZXJ0eSB7YW55fSBzdWJzdGl0dXRpb24gc3Vic3RpdHV0aW9uIHZhbHVlKHMpXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBzdWJzdGl0dXRpb24gYWN0aW9uIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbkFjdGlvbn0gYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFN1YnN0aXR1dGlvbkFjdGlvbihhY3Rpb24pIHtcbiAgICB0aGlzLmlkID0gYWN0aW9uLmlkO1xuICAgIHRoaXMudGFnID0gYWN0aW9uLnRhZztcbiAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IGFjdGlvbi5zdWJzdGl0dXRpb247XG59XG5cbi8qKlxuICogTG9va3VwIGEgY292ZXJhZ2UgdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge0NvdmVyYWdlVGFibGV9IGNvdmVyYWdlIGNvdmVyYWdlIHRhYmxlXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIGNvdmVyYWdlKSB7XG4gICAgaWYgKCFnbHlwaEluZGV4KSB7IHJldHVybiAtMTsgfVxuICAgIHN3aXRjaCAoY292ZXJhZ2UuZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZS5nbHlwaHMuaW5kZXhPZihnbHlwaEluZGV4KTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2UucmFuZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggPj0gcmFuZ2Uuc3RhcnQgJiYgZ2x5cGhJbmRleCA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdseXBoSW5kZXggLSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBub3QgZm91bmRcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBnbHlwaEluZGV4ICsgc3VidGFibGUuZGVsdGFHbHlwaElkO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMlxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBzdWJ0YWJsZS5zdWJzdGl0dXRlW3N1YnN0aXR1dGVJbmRleF07XG59XG5cbi8qKlxuICogTG9va3VwIGEgbGlzdCBvZiBjb3ZlcmFnZSB0YWJsZXNcbiAqIEBwYXJhbSB7YW55fSBjb3ZlcmFnZUxpc3QgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBsb29rdXBDb3ZlcmFnZUxpc3QoY292ZXJhZ2VMaXN0LCBjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGxvb2t1cExpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVyYWdlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY292ZXJhZ2UgPSBjb3ZlcmFnZUxpc3RbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgICAgICBnbHlwaEluZGV4ID0gQXJyYXkuaXNBcnJheShnbHlwaEluZGV4KSA/IGdseXBoSW5kZXhbMF0gOiBnbHlwaEluZGV4O1xuICAgICAgICB2YXIgbG9va3VwSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBjb3ZlcmFnZSk7XG4gICAgICAgIGlmIChsb29rdXBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxvb2t1cExpc3QucHVzaChsb29rdXBJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvb2t1cExpc3QubGVuZ3RoICE9PSBjb3ZlcmFnZUxpc3QubGVuZ3RoKSB7IHJldHVybiAtMTsgfVxuICAgIHJldHVybiBsb29rdXBMaXN0O1xufVxuXG4vKipcbiAqIEhhbmRsZSBjaGFpbmluZyBjb250ZXh0IHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAzXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0Myhjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuICAgIHZhciBsb29rdXBzQ291bnQgPSAoXG4gICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoICtcbiAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICtcbiAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoXG4gICAgKTtcbiAgICBpZiAoY29udGV4dFBhcmFtcy5jb250ZXh0Lmxlbmd0aCA8IGxvb2t1cHNDb3VudCkgeyByZXR1cm4gW107IH1cbiAgICAvLyBJTlBVVCBMT09LVVAgLy9cbiAgICB2YXIgaW5wdXRMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLCBjb250ZXh0UGFyYW1zXG4gICAgKTtcbiAgICBpZiAoaW5wdXRMb29rdXBzID09PSAtMSkgeyByZXR1cm4gW107IH1cbiAgICAvLyBMT09LQUhFQUQgTE9PS1VQIC8vXG4gICAgdmFyIGxvb2thaGVhZE9mZnNldCA9IHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoIC0gMTtcbiAgICBpZiAoY29udGV4dFBhcmFtcy5sb29rYWhlYWQubGVuZ3RoIDwgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICAgIHZhciBsb29rYWhlYWRDb250ZXh0ID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWQuc2xpY2UobG9va2FoZWFkT2Zmc2V0KTtcbiAgICB3aGlsZSAobG9va2FoZWFkQ29udGV4dC5sZW5ndGggJiYgaXNUYXNoa2VlbEFyYWJpY0NoYXIobG9va2FoZWFkQ29udGV4dFswXS5jaGFyKSkge1xuICAgICAgICBsb29rYWhlYWRDb250ZXh0LnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciBsb29rYWhlYWRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhsb29rYWhlYWRDb250ZXh0LCAwKTtcbiAgICB2YXIgbG9va2FoZWFkTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UsIGxvb2thaGVhZFBhcmFtc1xuICAgICk7XG4gICAgLy8gQkFDS1RSQUNLIExPT0tVUCAvL1xuICAgIHZhciBiYWNrdHJhY2tDb250ZXh0ID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuYmFja3RyYWNrKTtcbiAgICBiYWNrdHJhY2tDb250ZXh0LnJldmVyc2UoKTtcbiAgICB3aGlsZSAoYmFja3RyYWNrQ29udGV4dC5sZW5ndGggJiYgaXNUYXNoa2VlbEFyYWJpY0NoYXIoYmFja3RyYWNrQ29udGV4dFswXS5jaGFyKSkge1xuICAgICAgICBiYWNrdHJhY2tDb250ZXh0LnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChiYWNrdHJhY2tDb250ZXh0Lmxlbmd0aCA8IHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgICB2YXIgYmFja3RyYWNrUGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoYmFja3RyYWNrQ29udGV4dCwgMCk7XG4gICAgdmFyIGJhY2t0cmFja0xvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgIHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLCBiYWNrdHJhY2tQYXJhbXNcbiAgICApO1xuICAgIHZhciBjb250ZXh0UnVsZXNNYXRjaCA9IChcbiAgICAgICAgaW5wdXRMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggJiZcbiAgICAgICAgbG9va2FoZWFkTG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCAmJlxuICAgICAgICBiYWNrdHJhY2tMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoXG4gICAgKTtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIGlmIChjb250ZXh0UnVsZXNNYXRjaCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlLmxvb2t1cFJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb29rdXBSZWNvcmQgPSBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzW2ldO1xuICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleCA9IGxvb2t1cFJlY29yZC5sb29rdXBMaXN0SW5kZXg7XG4gICAgICAgICAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cEJ5SW5kZXgobG9va3VwTGlzdEluZGV4KTtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbG9va3VwVGFibGUuc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRhYmxlJDEgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbc107XG4gICAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHRoaXMuZ2V0TG9va3VwTWV0aG9kKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSQxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUkMSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvblR5cGUgPT09ICcxMicpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBpbnB1dExvb2t1cHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5nZXQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uID0gbG9va3VwKGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikgeyBzdWJzdGl0dXRpb25zLnB1c2goc3Vic3RpdHV0aW9uKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufVxuXG4vKipcbiAqIEhhbmRsZSBsaWdhdHVyZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEoY29udGV4dFBhcmFtcywgc3VidGFibGUpIHtcbiAgICAvLyBDT1ZFUkFHRSBMT09LVVAgLy9cbiAgICB2YXIgZ2x5cGhJbmRleCA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgbGlnU2V0SW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgaWYgKGxpZ1NldEluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIENPTVBPTkVOVFMgTE9PS1VQXG4gICAgLy8gKCEpIG5vdGUsIGNvbXBvbmVudHMgYXJlIG9yZGVyZWQgaW4gdGhlIHdyaXR0ZW4gZGlyZWN0aW9uLlxuICAgIHZhciBsaWdhdHVyZTtcbiAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbbGlnU2V0SW5kZXhdO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbGlnYXR1cmVTZXQubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgbGlnYXR1cmUgPSBsaWdhdHVyZVNldFtzXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgbG9va2FoZWFkSXRlbSA9IGNvbnRleHRQYXJhbXMubG9va2FoZWFkW2xdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxpZ2F0dXJlLmNvbXBvbmVudHNbbF07XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkSXRlbSAhPT0gY29tcG9uZW50KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICBpZiAobCA9PT0gbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggLSAxKSB7IHJldHVybiBsaWdhdHVyZTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEhhbmRsZSBkZWNvbXBvc2l0aW9uIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCBnbHlwaCBpbmRleFxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlY29tcG9zaXRpb25TdWJzdGl0dXRpb25Gb3JtYXQxKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBzdWJ0YWJsZS5zZXF1ZW5jZXNbc3Vic3RpdHV0ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBHZXQgZGVmYXVsdCBzY3JpcHQgZmVhdHVyZXMgaW5kZXhlc1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldERlZmF1bHRTY3JpcHRGZWF0dXJlc0luZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcmlwdHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIuc2NyaXB0cztcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNjcmlwdHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbc107XG4gICAgICAgIGlmIChzY3JpcHQudGFnID09PSAnREZMVCcpIHsgcmV0dXJuIChcbiAgICAgICAgICAgIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXNcbiAgICAgICAgKTsgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEdldCBmZWF0dXJlIGluZGV4ZXMgb2YgYSBzcGVjaWZpYyBzY3JpcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldFNjcmlwdEZlYXR1cmVzSW5kZXhlcyA9IGZ1bmN0aW9uKHNjcmlwdFRhZykge1xuICAgIHZhciB0YWJsZXMgPSB0aGlzLmZvbnQudGFibGVzO1xuICAgIGlmICghdGFibGVzLmdzdWIpIHsgcmV0dXJuIFtdOyB9XG4gICAgaWYgKCFzY3JpcHRUYWcpIHsgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcygpOyB9XG4gICAgdmFyIHNjcmlwdHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIuc2NyaXB0cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG4gICAgICAgIGlmIChzY3JpcHQudGFnID09PSBzY3JpcHRUYWcgJiYgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cykge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZHMgPSBzY3JpcHQubGFuZ1N5c1JlY29yZHM7XG4gICAgICAgICAgICBpZiAoISFsYW5nU3lzUmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGFuZ1N5c1JlY29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmQgPSBsYW5nU3lzUmVjb3Jkc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdTeXNSZWNvcmQudGFnID09PSBzY3JpcHRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzID0gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXMuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcygpO1xufTtcblxuLyoqXG4gKiBNYXAgYSBmZWF0dXJlIHRhZyB0byBhIGdzdWIgZmVhdHVyZVxuICogQHBhcmFtIHthbnl9IGZlYXR1cmVzIGdzdWIgZmVhdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLm1hcFRhZ3NUb0ZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCBzY3JpcHRUYWcpIHtcbiAgICB2YXIgdGFncyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9IGZlYXR1cmVzW2ldLnRhZztcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXS5mZWF0dXJlO1xuICAgICAgICB0YWdzW3RhZ10gPSBmZWF0dXJlO1xuICAgIH1cbiAgICB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ10udGFncyA9IHRhZ3M7XG59O1xuXG4vKipcbiAqIEdldCBmZWF0dXJlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXMgPSBmdW5jdGlvbiAoc2NyaXB0VGFnKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1tzY3JpcHRUYWddO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHNjcmlwdFRhZykpIHsgcmV0dXJuIGZlYXR1cmVzOyB9XG4gICAgdmFyIGZlYXR1cmVzSW5kZXhlcyA9IHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzKHNjcmlwdFRhZyk7XG4gICAgaWYgKCFmZWF0dXJlc0luZGV4ZXMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgZ3N1YiA9IHRoaXMuZm9udC50YWJsZXMuZ3N1YjtcbiAgICBmZWF0dXJlcyA9IGZlYXR1cmVzSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBnc3ViLmZlYXR1cmVzW2luZGV4XTsgfSk7XG4gICAgdGhpcy5mZWF0dXJlc1tzY3JpcHRUYWddID0gZmVhdHVyZXM7XG4gICAgdGhpcy5tYXBUYWdzVG9GZWF0dXJlcyhmZWF0dXJlcywgc2NyaXB0VGFnKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdWJzdGl0dXRpb24gdHlwZVxuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U3Vic3RpdHV0aW9uVHlwZSA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSkge1xuICAgIHZhciBsb29rdXBUeXBlID0gbG9va3VwVGFibGUubG9va3VwVHlwZS50b1N0cmluZygpO1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHN1YnRhYmxlLnN1YnN0Rm9ybWF0LnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGxvb2t1cFR5cGUgKyBzdWJzdEZvcm1hdDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCBtZXRob2RcbiAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcbiAqIEBwYXJhbSB7YW55fSBzdWJ0YWJsZSBzdWJ0YWJsZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cE1ldGhvZCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1YnN0aXR1dGlvblR5cGUgPSB0aGlzLmdldFN1YnN0aXR1dGlvblR5cGUobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICBzd2l0Y2ggKHN1YnN0aXR1dGlvblR5cGUpIHtcbiAgICAgICAgY2FzZSAnMTEnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnMTInOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnNjMnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0UGFyYW1zKSB7IHJldHVybiBjaGFpbmluZ1N1YnN0aXR1dGlvbkZvcm1hdDMuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbY29udGV4dFBhcmFtcywgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICc0MSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzIxJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibG9va3VwVHlwZTogXCIgKyAobG9va3VwVGFibGUubG9va3VwVHlwZSkgKyBcIiAtIFwiICtcbiAgICAgICAgICAgICAgICBcInN1YnN0Rm9ybWF0OiBcIiArIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgXCJpcyBub3QgeWV0IHN1cHBvcnRlZFwiXG4gICAgICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICogWyBMT09LVVAgVFlQRVMgXVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2luZ2xlICAgICAgICAgICAgICAgICAgICAgICAgMTtcbiAqIE11bHRpcGxlICAgICAgICAgICAgICAgICAgICAgIDI7XG4gKiBBbHRlcm5hdGUgICAgICAgICAgICAgICAgICAgICAzO1xuICogTGlnYXR1cmUgICAgICAgICAgICAgICAgICAgICAgNDtcbiAqIENvbnRleHQgICAgICAgICAgICAgICAgICAgICAgIDU7XG4gKiBDaGFpbmluZ0NvbnRleHQgICAgICAgICAgICAgICA2O1xuICogRXh0ZW5zaW9uU3Vic3RpdHV0aW9uICAgICAgICAgNztcbiAqIFJldmVyc2VDaGFpbmluZ0NvbnRleHQgICAgICAgIDg7XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRlF1ZXJ5XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgZmVhdHVyZSB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgZmVhdHVyZSBzY3JpcHRcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtc1xuICovXG5cbi8qKlxuICogTG9va3VwIGEgZmVhdHVyZSB1c2luZyBhIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RlF1ZXJ5fSBxdWVyeSBmZWF0dXJlIHF1ZXJ5XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUubG9va3VwRmVhdHVyZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBjb250ZXh0UGFyYW1zID0gcXVlcnkuY29udGV4dFBhcmFtcztcbiAgICB2YXIgY3VycmVudEluZGV4ID0gY29udGV4dFBhcmFtcy5pbmRleDtcbiAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZ2V0RmVhdHVyZSh7XG4gICAgICAgIHRhZzogcXVlcnkudGFnLCBzY3JpcHQ6IHF1ZXJ5LnNjcmlwdFxuICAgIH0pO1xuICAgIGlmICghZmVhdHVyZSkgeyByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBcImZvbnQgJ1wiICsgKHRoaXMuZm9udC5uYW1lcy5mdWxsTmFtZS5lbikgKyBcIicgXCIgK1xuICAgICAgICBcImRvZXNuJ3Qgc3VwcG9ydCBmZWF0dXJlICdcIiArIChxdWVyeS50YWcpICsgXCInIFwiICtcbiAgICAgICAgXCJmb3Igc2NyaXB0ICdcIiArIChxdWVyeS5zY3JpcHQpICsgXCInLlwiXG4gICAgKTsgfVxuICAgIHZhciBsb29rdXBzID0gdGhpcy5nZXRGZWF0dXJlTG9va3VwcyhmZWF0dXJlKTtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdLmNvbmNhdChjb250ZXh0UGFyYW1zLmNvbnRleHQpO1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbG9va3Vwcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbG9va3VwVGFibGUgPSBsb29rdXBzW2xdO1xuICAgICAgICB2YXIgc3VidGFibGVzID0gdGhpcy5nZXRMb29rdXBTdWJ0YWJsZXMobG9va3VwVGFibGUpO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN1YnRhYmxlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW3NdO1xuICAgICAgICAgICAgdmFyIHN1YnN0VHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHRoaXMuZ2V0TG9va3VwTWV0aG9kKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uID0gKHZvaWQgMCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnN0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzExJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDExLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxMiwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNjMnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgc3Vic3RpdHV0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNjMsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzQxJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA0MSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnMjEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMjEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKHN1YnN0aXR1dGlvbnMsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzdGl0dXRpb24pICYmICFzdWJzdGl0dXRpb24ubGVuZ3RoKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zLmxlbmd0aCA/IHN1YnN0aXR1dGlvbnMgOiBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBmb250IHN1cHBvcnRzIGEgc3BlY2lmaWMgZmVhdHVyZXNcbiAqIEBwYXJhbSB7RlF1ZXJ5fSBxdWVyeSBmZWF0dXJlIHF1ZXJ5IG9iamVjdFxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeS5zY3JpcHQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdGhpcy5nZXRTY3JpcHRGZWF0dXJlcyhxdWVyeS5zY3JpcHQpO1xuICAgIHZhciBzdXBwb3J0ZWRTY3JpcHQgPSB0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHF1ZXJ5LnNjcmlwdCk7XG4gICAgaWYgKCFxdWVyeS50YWcpIHsgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdDsgfVxuICAgIHZhciBzdXBwb3J0ZWRGZWF0dXJlID0gKFxuICAgICAgICB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF0uc29tZShmdW5jdGlvbiAoZmVhdHVyZSkgeyByZXR1cm4gZmVhdHVyZS50YWcgPT09IHF1ZXJ5LnRhZzsgfSlcbiAgICApO1xuICAgIHJldHVybiBzdXBwb3J0ZWRTY3JpcHQgJiYgc3VwcG9ydGVkRmVhdHVyZTtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZSBzdWJ0YWJsZXNcbiAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRMb29rdXBTdWJ0YWJsZXMgPSBmdW5jdGlvbiAobG9va3VwVGFibGUpIHtcbiAgICByZXR1cm4gbG9va3VwVGFibGUuc3VidGFibGVzIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgdGFibGUgYnkgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsb29rdXAgdGFibGUgaW5kZXhcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRMb29rdXBCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGxvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIubG9va3VwcztcbiAgICByZXR1cm4gbG9va3Vwc1tpbmRleF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZXMgZm9yIGEgZmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRGZWF0dXJlTG9va3VwcyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgLy8gVE9ETzogbWVtb2l6ZVxuICAgIHJldHVybiBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzLm1hcCh0aGlzLmdldExvb2t1cEJ5SW5kZXguYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IGEgZmVhdHVyZSBieSBpdCdzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7YW55fSBxdWVyeSBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgYSBxdWVyeVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbiBnZXRGZWF0dXJlKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLmZvbnQpIHsgcmV0dXJuIHsgRkFJTDogXCJObyBmb250IHdhcyBmb3VuZFwifTsgfVxuICAgIGlmICghdGhpcy5mZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eShxdWVyeS5zY3JpcHQpKSB7XG4gICAgICAgIHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXMocXVlcnkuc2NyaXB0KTtcbiAgICB9XG4gICAgdmFyIHNjcmlwdEZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdO1xuICAgIGlmICghc2NyaXB0RmVhdHVyZXMpIHsgcmV0dXJuIChcbiAgICAgICAgeyBGQUlMOiAoXCJObyBmZWF0dXJlIGZvciBzY3JpcHQgXCIgKyAocXVlcnkuc2NyaXB0KSl9XG4gICAgKTsgfVxuICAgIGlmICghc2NyaXB0RmVhdHVyZXMudGFnc1txdWVyeS50YWddKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XS50YWdzW3F1ZXJ5LnRhZ107XG59O1xuXG4vKipcbiAqIEFyYWJpYyB3b3JkIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBhcmFiaWNXb3JkU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gYXJhYmljIGZpcnN0IGNoYXJcbiAgICAgICAgKHByZXZDaGFyID09PSBudWxsICYmIGlzQXJhYmljQ2hhcihjaGFyKSkgfHxcbiAgICAgICAgLy8gPyBhcmFiaWMgY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGFyYWJpYyBjaGFyXG4gICAgICAgICghaXNBcmFiaWNDaGFyKHByZXZDaGFyKSAmJiBpc0FyYWJpY0NoYXIoY2hhcikpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYXJhYmljV29yZEVuZENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGxhc3QgYXJhYmljIGNoYXJcbiAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgYXJhYmljXG4gICAgICAgICghaXNBcmFiaWNDaGFyKG5leHRDaGFyKSlcbiAgICApO1xufVxuXG52YXIgYXJhYmljV29yZENoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1dvcmRTdGFydENoZWNrLFxuICAgIGVuZENoZWNrOiBhcmFiaWNXb3JkRW5kQ2hlY2tcbn07XG5cbi8qKlxuICogQXJhYmljIHNlbnRlbmNlIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBhcmFiaWNTZW50ZW5jZVN0YXJ0Q2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBjaGFyID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBwcmV2Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KC0xKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGFuIGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcbiAgICAgICAgKGlzQXJhYmljQ2hhcihjaGFyKSB8fCBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSkgJiZcbiAgICAgICAgIWlzQXJhYmljQ2hhcihwcmV2Q2hhcilcbiAgICApO1xufVxuXG5mdW5jdGlvbiBhcmFiaWNTZW50ZW5jZUVuZENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBuZXh0Q2hhciA9PT0gbnVsbDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICghaXNBcmFiaWNDaGFyKG5leHRDaGFyKSAmJiAhaXNUYXNoa2VlbEFyYWJpY0NoYXIobmV4dENoYXIpKTpcbiAgICAgICAgICAgIHZhciBuZXh0SXNXaGl0ZXNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcbiAgICAgICAgICAgIGlmICghbmV4dElzV2hpdGVzcGFjZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKG5leHRJc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJhYmljQ2hhckFoZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXJhYmljQ2hhckFoZWFkID0gKFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5zb21lKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGlzQXJhYmljQ2hhcihjKSB8fCBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjKTsgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyYWJpY0NoYXJBaGVhZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgYXJhYmljU2VudGVuY2VDaGVjayA9IHtcbiAgICBzdGFydENoZWNrOiBhcmFiaWNTZW50ZW5jZVN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGFyYWJpY1NlbnRlbmNlRW5kQ2hlY2tcbn07XG5cbi8qKlxuICogQXBwbHkgc2luZ2xlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMVxuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgdG9rZW5zW2luZGV4XS5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uKTtcbn1cblxuLyoqXG4gKiBBcHBseSBzaW5nbGUgc3Vic3RpdHV0aW9uIGZvcm1hdCAyXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICB0b2tlbnNbaW5kZXhdLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24pO1xufVxuXG4vKipcbiAqIEFwcGx5IGNoYWluaW5nIGNvbnRleHQgc3Vic3RpdHV0aW9uIGZvcm1hdCAzXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0MyQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIGFjdGlvbi5zdWJzdGl0dXRpb24uZm9yRWFjaChmdW5jdGlvbiAoc3Vic3QsIG9mZnNldCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBvZmZzZXRdO1xuICAgICAgICB0b2tlbi5zZXRTdGF0ZShhY3Rpb24udGFnLCBzdWJzdCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgbGlnYXR1cmUgc3Vic3RpdHV0aW9uIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgdG9rZW4uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbi5saWdHbHlwaCk7XG4gICAgdmFyIGNvbXBzQ291bnQgPSBhY3Rpb24uc3Vic3RpdHV0aW9uLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHNDb3VudDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2luZGV4ICsgaSArIDFdO1xuICAgICAgICB0b2tlbi5zZXRTdGF0ZSgnZGVsZXRlZCcsIHRydWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdXBwb3J0ZWQgc3Vic3RpdHV0aW9uc1xuICovXG52YXIgU1VCU1RJVFVUSU9OUyA9IHtcbiAgICAxMTogc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MSQxLFxuICAgIDEyOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyJDEsXG4gICAgNjM6IGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0MyQxLFxuICAgIDQxOiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEkMVxufTtcblxuLyoqXG4gKiBBcHBseSBzdWJzdGl0dXRpb25zIHRvIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbkFjdGlvbiAmJiBTVUJTVElUVVRJT05TW2FjdGlvbi5pZF0pIHtcbiAgICAgICAgU1VCU1RJVFVUSU9OU1thY3Rpb24uaWRdKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBjYW4gYmUgY29ubmVjdGVkIHRvIGl0J3MgcHJlY2VkaW5nIGNoYXJcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY2hhckNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgb2YgYSBjaGFyXG4gKi9cbmZ1bmN0aW9uIHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykge1xuICAgIHZhciBiYWNrdHJhY2sgPSBbXS5jb25jYXQoY2hhckNvbnRleHRQYXJhbXMuYmFja3RyYWNrKTtcbiAgICBmb3IgKHZhciBpID0gYmFja3RyYWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwcmV2Q2hhciA9IGJhY2t0cmFja1tpXTtcbiAgICAgICAgdmFyIGlzb2xhdGVkID0gaXNJc29sYXRlZEFyYWJpY0NoYXIocHJldkNoYXIpO1xuICAgICAgICB2YXIgdGFzaGtlZWwgPSBpc1Rhc2hrZWVsQXJhYmljQ2hhcihwcmV2Q2hhcik7XG4gICAgICAgIGlmICghaXNvbGF0ZWQgJiYgIXRhc2hrZWVsKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIGlmIChpc29sYXRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBjYW4gYmUgY29ubmVjdGVkIHRvIGl0J3MgcHJvY2VlZGluZyBjaGFyXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNoYXJDb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIG9mIGEgY2hhclxuICovXG5mdW5jdGlvbiB3aWxsQ29ubmVjdE5leHQoY2hhckNvbnRleHRQYXJhbXMpIHtcbiAgICBpZiAoaXNJc29sYXRlZEFyYWJpY0NoYXIoY2hhckNvbnRleHRQYXJhbXMuY3VycmVudCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhckNvbnRleHRQYXJhbXMubG9va2FoZWFkW2ldO1xuICAgICAgICB2YXIgdGFzaGtlZWwgPSBpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcik7XG4gICAgICAgIGlmICghdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFwcGx5IGFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgdG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7IHJldHVybjsgfVxuICAgIHZhciBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoXG4gICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5nZXRTdGF0ZSgnZ2x5cGhJbmRleCcpOyB9XG4gICAgKSwgMCk7XG4gICAgdmFyIGNoYXJDb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoXG4gICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9XG4gICAgKSwgMCk7XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuLCBpbmRleCkge1xuICAgICAgICBpZiAoaXNUYXNoa2VlbEFyYWJpY0NoYXIodG9rZW4uY2hhcikpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgY2hhckNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIENPTk5FQ1QgPSAwOyAvLyAyIGJpdHMgMDAgKDEwOiBjYW4gY29ubmVjdCBuZXh0KSAoMDE6IGNhbiBjb25uZWN0IHByZXYpXG4gICAgICAgIGlmICh3aWxsQ29ubmVjdFByZXYoY2hhckNvbnRleHRQYXJhbXMpKSB7IENPTk5FQ1QgfD0gMTsgfVxuICAgICAgICBpZiAod2lsbENvbm5lY3ROZXh0KGNoYXJDb250ZXh0UGFyYW1zKSkgeyBDT05ORUNUIHw9IDI7IH1cbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgc3dpdGNoIChDT05ORUNUKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICh0YWcgPSAnZmluYScpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjogKHRhZyA9ICdpbml0Jyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiAodGFnID0gJ21lZGknKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ3MuaW5kZXhPZih0YWcpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG4gICAgICAgICAgICB0YWc6IHRhZywgc2NyaXB0OiBzY3JpcHQsIGNvbnRleHRQYXJhbXM6IGNvbnRleHRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zIGluc3RhbmNlb2YgRXJyb3IpIHsgcmV0dXJuIGNvbnNvbGUuaW5mbyhzdWJzdGl0dXRpb25zLm1lc3NhZ2UpOyB9XG4gICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbkFjdGlvbikge1xuICAgICAgICAgICAgICAgIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29udGV4dFBhcmFtcy5jb250ZXh0W2luZGV4XSA9IGFjdGlvbi5zdWJzdGl0dXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgZmVhdHVyZSB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5cbi8qKlxuICogVXBkYXRlIGNvbnRleHQgcGFyYW1zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuICAgIHJldHVybiBuZXcgQ29udGV4dFBhcmFtcyhjb250ZXh0LCBpbmRleCB8fCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIHRvIGEgY29udGV4dCByYW5nZVxuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGFyYWJpY1JlcXVpcmVkTGlnYXR1cmVzKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG4gICAgY29udGV4dFBhcmFtcy5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24gKGdseXBoSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG4gICAgICAgICAgICB0YWc6ICdybGlnJywgc2NyaXB0OiBzY3JpcHQsIGNvbnRleHRQYXJhbXM6IGNvbnRleHRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogTGF0aW4gd29yZCBjb250ZXh0IGNoZWNrZXJzXG4gKi9cblxuZnVuY3Rpb24gbGF0aW5Xb3JkU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGF0aW4gZmlyc3QgY2hhclxuICAgICAgICAocHJldkNoYXIgPT09IG51bGwgJiYgaXNMYXRpbkNoYXIoY2hhcikpIHx8XG4gICAgICAgIC8vID8gbGF0aW4gY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGxhdGluIGNoYXJcbiAgICAgICAgKCFpc0xhdGluQ2hhcihwcmV2Q2hhcikgJiYgaXNMYXRpbkNoYXIoY2hhcikpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbGF0aW5Xb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGFzdCBsYXRpbiBjaGFyXG4gICAgICAgIChuZXh0Q2hhciA9PT0gbnVsbCkgfHxcbiAgICAgICAgLy8gPyBuZXh0IGNoYXIgaXMgbm90IGxhdGluXG4gICAgICAgICghaXNMYXRpbkNoYXIobmV4dENoYXIpKVxuICAgICk7XG59XG5cbnZhciBsYXRpbldvcmRDaGVjayA9IHtcbiAgICBzdGFydENoZWNrOiBsYXRpbldvcmRTdGFydENoZWNrLFxuICAgIGVuZENoZWNrOiBsYXRpbldvcmRFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcHBseSBMYXRpbiBsaWdhdHVyZSBmZWF0dXJlIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zLCBpbmRleCkge1xuICAgIHZhciBjb250ZXh0ID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlOyB9KTtcbiAgICByZXR1cm4gbmV3IENvbnRleHRQYXJhbXMoY29udGV4dCwgaW5kZXggfHwgMCk7XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyB0byBhIGNvbnRleHQgcmFuZ2VcbiAqIEBwYXJhbSB7Q29udGV4dFJhbmdlfSByYW5nZSBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5mdW5jdGlvbiBsYXRpbkxpZ2F0dXJlKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zKTtcbiAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogJ2xpZ2EnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTsgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEluZmVyIGJpZGlyZWN0aW9uYWwgcHJvcGVydGllcyBmb3IgYSBnaXZlbiB0ZXh0IGFuZCBhcHBseVxuICogdGhlIGNvcnJlc3BvbmRpbmcgbGF5b3V0IHJ1bGVzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIEJpZGkuIGZlYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZURpciB0ZXh0IGJhc2UgZGlyZWN0aW9uLiB2YWx1ZSBlaXRoZXIgJ2x0cicgb3IgJ3J0bCdcbiAqL1xuZnVuY3Rpb24gQmlkaShiYXNlRGlyKSB7XG4gICAgdGhpcy5iYXNlRGlyID0gYmFzZURpciB8fCAnbHRyJztcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcbiAgICB0aGlzLmZlYXR1cmVzVGFncyA9IHt9O1xufVxuXG4vKipcbiAqIFNldHMgQmlkaSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhIHRleHQgaW5wdXRcbiAqL1xuQmlkaS5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbn07XG5cbi8qKlxuICogU3RvcmUgZXNzZW50aWFsIGNvbnRleHQgY2hlY2tzOlxuICogYXJhYmljIHdvcmQgY2hlY2sgZm9yIGFwcGx5aW5nIGdzdWIgZmVhdHVyZXNcbiAqIGFyYWJpYyBzZW50ZW5jZSBjaGVjayBmb3IgYWRqdXN0aW5nIGFyYWJpYyBsYXlvdXRcbiAqL1xuQmlkaS5wcm90b3R5cGUuY29udGV4dENoZWNrcyA9ICh7XG4gICAgbGF0aW5Xb3JkQ2hlY2s6IGxhdGluV29yZENoZWNrLFxuICAgIGFyYWJpY1dvcmRDaGVjazogYXJhYmljV29yZENoZWNrLFxuICAgIGFyYWJpY1NlbnRlbmNlQ2hlY2s6IGFyYWJpY1NlbnRlbmNlQ2hlY2tcbn0pO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGFyYWJpYyB3b3JkIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIoY2hlY2tJZCkge1xuICAgIHZhciBjaGVjayA9IHRoaXMuY29udGV4dENoZWNrc1soY2hlY2tJZCArIFwiQ2hlY2tcIildO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci5yZWdpc3RlckNvbnRleHRDaGVja2VyKFxuICAgICAgICBjaGVja0lkLCBjaGVjay5zdGFydENoZWNrLCBjaGVjay5lbmRDaGVja1xuICAgICk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBwcmUgdG9rZW5pemF0aW9uIHByb2NlZHVyZSB0aGVuXG4gKiB0b2tlbml6ZSB0ZXh0IGlucHV0XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGV4dCgpIHtcbiAgICByZWdpc3RlckNvbnRleHRDaGVja2VyLmNhbGwodGhpcywgJ2xhdGluV29yZCcpO1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnYXJhYmljV29yZCcpO1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnYXJhYmljU2VudGVuY2UnKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIudG9rZW5pemUodGhpcy50ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlIGFyYWJpYyBzZW50ZW5jZSBsYXlvdXRcbiAqIFRPRE86IGNoZWNrIGJhc2UgZGlyIGJlZm9yZSBhcHBseWluZyBhZGp1c3RtZW50cyAtIHByaW9yaXR5IGxvd1xuICovXG5mdW5jdGlvbiByZXZlcnNlQXJhYmljU2VudGVuY2VzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1NlbnRlbmNlJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciByYW5nZVRva2VucyA9IHRoaXMkMS50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgICAgICB0aGlzJDEudG9rZW5pemVyLnJlcGxhY2VSYW5nZShcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0SW5kZXgsXG4gICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQsXG4gICAgICAgICAgICByYW5nZVRva2Vucy5yZXZlcnNlKClcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBzdXBwb3J0ZWQgZmVhdHVyZXMgdGFnc1xuICogQHBhcmFtIHtzY3JpcHR9IHNjcmlwdCBzY3JpcHQgdGFnXG4gKiBAcGFyYW0ge0FycmF5fSB0YWdzIGZlYXR1cmVzIHRhZ3MgbGlzdFxuICovXG5CaWRpLnByb3RvdHlwZS5yZWdpc3RlckZlYXR1cmVzID0gZnVuY3Rpb24gKHNjcmlwdCwgdGFncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1cHBvcnRlZFRhZ3MgPSB0YWdzLmZpbHRlcihcbiAgICAgICAgZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGhpcyQxLnF1ZXJ5LnN1cHBvcnRzKHtzY3JpcHQ6IHNjcmlwdCwgdGFnOiB0YWd9KTsgfVxuICAgICk7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0gPSBzdXBwb3J0ZWRUYWdzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0gPVxuICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdLmNvbmNhdChzdXBwb3J0ZWRUYWdzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IEdTVUIgZmVhdHVyZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHRhZ3NMaXN0IGEgbGlzdCBvZiBmZWF0dXJlcyB0YWdzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IGEgc2NyaXB0IHRhZ1xuICogQHBhcmFtIHtGb250fSBmb250IG9wZW50eXBlIGZvbnQgaW5zdGFuY2VcbiAqL1xuQmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlcyA9IGZ1bmN0aW9uIChmb250LCBmZWF0dXJlcykge1xuICAgIGlmICghZm9udCkgeyB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyB2YWxpZCBmb250IHdhcyBwcm92aWRlZCB0byBhcHBseSBmZWF0dXJlcydcbiAgICApOyB9XG4gICAgaWYgKCF0aGlzLnF1ZXJ5KSB7IHRoaXMucXVlcnkgPSBuZXcgRmVhdHVyZVF1ZXJ5KGZvbnQpOyB9XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBmZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ZdO1xuICAgICAgICBpZiAoIXRoaXMucXVlcnkuc3VwcG9ydHMoe3NjcmlwdDogZmVhdHVyZS5zY3JpcHR9KSkgeyBjb250aW51ZTsgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZXMoZmVhdHVyZS5zY3JpcHQsIGZlYXR1cmUudGFncyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHN0YXRlIG1vZGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kaWZpZXJJZCBzdGF0ZSBtb2RpZmllciBpZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIG1vZGlmaWVyIGZ1bmN0aW9uIHRvIHNldCB0b2tlbiBzdGF0ZVxuICovXG5CaWRpLnByb3RvdHlwZS5yZWdpc3Rlck1vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpIHtcbiAgICB0aGlzLnRva2VuaXplci5yZWdpc3Rlck1vZGlmaWVyKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiAnZ2x5cGhJbmRleCcgaXMgcmVnaXN0ZXJlZFxuICovXG5mdW5jdGlvbiBjaGVja0dseXBoSW5kZXhTdGF0dXMoKSB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyZWRNb2RpZmllcnMuaW5kZXhPZignZ2x5cGhJbmRleCcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnZ2x5cGhJbmRleCBtb2RpZmllciBpcyByZXF1aXJlZCB0byBhcHBseSAnICtcbiAgICAgICAgICAgICdhcmFiaWMgcHJlc2VudGF0aW9uIGZlYXR1cmVzLidcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbHkgYXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyBmZWF0dXJlc1xuICovXG5mdW5jdGlvbiBhcHBseUFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgYXJhYmljUHJlc2VudGF0aW9uRm9ybXMuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXJhYmljUmVxdWlyZUxpZ2F0dXJlcygpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7IHJldHVybjsgfVxuICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcbiAgICBpZiAodGFncy5pbmRleE9mKCdybGlnJykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdhcmFiaWNXb3JkJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGFyYWJpY1JlcXVpcmVkTGlnYXR1cmVzLmNhbGwodGhpcyQxLCByYW5nZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgcmVxdWlyZWQgYXJhYmljIGxpZ2F0dXJlc1xuICovXG5mdW5jdGlvbiBhcHBseUxhdGluTGlnYXR1cmVzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdsYXRuJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIGlmICh0YWdzLmluZGV4T2YoJ2xpZ2EnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2xhdGluV29yZCcpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBsYXRpbkxpZ2F0dXJlLmNhbGwodGhpcyQxLCByYW5nZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb250ZXh0IGlzIHJlZ2lzdGVyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgY29udGV4dCBpZFxuICovXG5CaWRpLnByb3RvdHlwZS5jaGVja0NvbnRleHRSZWFkeSA9IGZ1bmN0aW9uIChjb250ZXh0SWQpIHtcbiAgICByZXR1cm4gISF0aGlzLnRva2VuaXplci5nZXRDb250ZXh0KGNvbnRleHRJZCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGZlYXR1cmVzIHRvIHJlZ2lzdGVyZWQgY29udGV4dHNcbiAqL1xuQmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlc1RvQ29udGV4dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2FyYWJpY1dvcmQnKSkge1xuICAgICAgICBhcHBseUFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zLmNhbGwodGhpcyk7XG4gICAgICAgIGFwcGx5QXJhYmljUmVxdWlyZUxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnbGF0aW5Xb3JkJykpIHtcbiAgICAgICAgYXBwbHlMYXRpbkxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljU2VudGVuY2UnKSkge1xuICAgICAgICByZXZlcnNlQXJhYmljU2VudGVuY2VzLmNhbGwodGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBwcm9jZXNzIHRleHQgaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGFuIGlucHV0IHRleHRcbiAqL1xuQmlkaS5wcm90b3R5cGUucHJvY2Vzc1RleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLnRleHQgfHwgdGhpcy50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICAgICAgdG9rZW5pemVUZXh0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXBwbHlGZWF0dXJlc1RvQ29udGV4dHMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBzdHJpbmcgb2YgdGV4dCB0byBpZGVudGlmeSBhbmQgYWRqdXN0XG4gKiBiaWRpcmVjdGlvbmFsIHRleHQgZW50aXRpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBpbnB1dCB0ZXh0XG4gKi9cbkJpZGkucHJvdG90eXBlLmdldEJpZGlUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnByb2Nlc3NUZXh0KHRleHQpO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci5nZXRUZXh0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBpbmRleCBvZiBlYWNoIHRva2VuXG4gKiBAcGFyYW0ge3RleHR9IHRleHQgYW4gaW5wdXQgdGV4dFxuICovXG5CaWRpLnByb3RvdHlwZS5nZXRUZXh0R2x5cGhzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnByb2Nlc3NUZXh0KHRleHQpO1xuICAgIHZhciBpbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRva2VuaXplci50b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbml6ZXIudG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4uc3RhdGUuZGVsZXRlZCkgeyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTtcbiAgICAgICAgaW5kZXhlcy5wdXNoKEFycmF5LmlzQXJyYXkoaW5kZXgpID8gaW5kZXhbMF0gOiBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleGVzO1xufTtcblxuLy8gVGhlIEZvbnQgb2JqZWN0XG5cbi8qKlxuICogQHR5cGVkZWYgRm9udE9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBlbXB0eSAtIHdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IGVtcHR5IGZvbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmYW1pbHlOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGVOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZ1bGxOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHBvc3RTY3JpcHROYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBtYW51ZmFjdHVyZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY29weXJpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZz19IHRyYWRlbWFya1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IHVuaXRzUGVyRW1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGNyZWF0ZWRUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2VpZ2h0Q2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2lkdGhDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSBmc1NlbGVjdGlvblxuICovXG5cbi8qKlxuICogQSBGb250IHJlcHJlc2VudHMgYSBsb2FkZWQgT3BlblR5cGUgZm9udCBmaWxlLlxuICogSXQgY29udGFpbnMgYSBzZXQgb2YgZ2x5cGhzIGFuZCBtZXRob2RzIHRvIGRyYXcgdGV4dCBvbiBhIGRyYXdpbmcgY29udGV4dCxcbiAqIG9yIHRvIGdldCBhIHBhdGggcmVwcmVzZW50aW5nIHRoZSB0ZXh0LlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRm9udFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0ZvbnRPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZvbnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudGFibGVzID0gb3B0aW9ucy50YWJsZXMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMuZW1wdHkpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5mYW1pbHlOYW1lLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgZmFtaWx5TmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnN0eWxlTmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnVuaXRzUGVyRW0sICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuYXNjZW5kZXIsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBhc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciA8PSAwLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgbmVnYXRpdmUgZGVzY2VuZGVyIHZhbHVlIGlzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuICAgICAgICB0aGlzLm5hbWVzID0ge1xuICAgICAgICAgICAgZm9udEZhbWlseToge2VuOiBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZvbnRTdWJmYW1pbHk6IHtlbjogb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB7ZW46IG9wdGlvbnMuZnVsbE5hbWUgfHwgb3B0aW9ucy5mYW1pbHlOYW1lICsgJyAnICsgb3B0aW9ucy5zdHlsZU5hbWV9LFxuICAgICAgICAgICAgLy8gcG9zdFNjcmlwdE5hbWUgbWF5IG5vdCBjb250YWluIGFueSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBwb3N0U2NyaXB0TmFtZToge2VuOiBvcHRpb25zLnBvc3RTY3JpcHROYW1lIHx8IChvcHRpb25zLmZhbWlseU5hbWUgKyBvcHRpb25zLnN0eWxlTmFtZSkucmVwbGFjZSgvXFxzL2csICcnKX0sXG4gICAgICAgICAgICBkZXNpZ25lcjoge2VuOiBvcHRpb25zLmRlc2lnbmVyIHx8ICcgJ30sXG4gICAgICAgICAgICBkZXNpZ25lclVSTDoge2VuOiBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXIgfHwgJyAnfSxcbiAgICAgICAgICAgIG1hbnVmYWN0dXJlclVSTDoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlclVSTCB8fCAnICd9LFxuICAgICAgICAgICAgbGljZW5zZToge2VuOiBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnfSxcbiAgICAgICAgICAgIGxpY2Vuc2VVUkw6IHtlbjogb3B0aW9ucy5saWNlbnNlVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICB2ZXJzaW9uOiB7ZW46IG9wdGlvbnMudmVyc2lvbiB8fCAnVmVyc2lvbiAwLjEnfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7ZW46IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnfSxcbiAgICAgICAgICAgIGNvcHlyaWdodDoge2VuOiBvcHRpb25zLmNvcHlyaWdodCB8fCAnICd9LFxuICAgICAgICAgICAgdHJhZGVtYXJrOiB7ZW46IG9wdGlvbnMudHJhZGVtYXJrIHx8ICcgJ31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG4gICAgICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgICAgICB0aGlzLmRlc2NlbmRlciA9IG9wdGlvbnMuZGVzY2VuZGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMudGFibGVzID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLnRhYmxlcywge1xuICAgICAgICAgICAgb3MyOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB1c1dlaWdodENsYXNzOiBvcHRpb25zLndlaWdodENsYXNzIHx8IHRoaXMudXNXZWlnaHRDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgICAgICB1c1dpZHRoQ2xhc3M6IG9wdGlvbnMud2lkdGhDbGFzcyB8fCB0aGlzLnVzV2lkdGhDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgICAgICBmc1NlbGVjdGlvbjogb3B0aW9ucy5mc1NlbGVjdGlvbiB8fCB0aGlzLmZzU2VsZWN0aW9uVmFsdWVzLlJFR1VMQVIsXG4gICAgICAgICAgICB9LCBvcHRpb25zLnRhYmxlcy5vczIpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydGVkID0gdHJ1ZTsgLy8gRGVwcmVjYXRlZDogcGFyc2VCdWZmZXIgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmb250IGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgdGhpcy5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQodGhpcywgb3B0aW9ucy5nbHlwaHMgfHwgW10pO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBuZXcgRGVmYXVsdEVuY29kaW5nKHRoaXMpO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUG9zaXRpb24odGhpcyk7XG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKHRoaXMpO1xuICAgIHRoaXMudGFibGVzID0gdGhpcy50YWJsZXMgfHwge307XG5cbiAgICAvLyBuZWVkZWQgZm9yIGxvdyBtZW1vcnkgbW9kZSBvbmx5LlxuICAgIHRoaXMuX3B1c2ggPSBudWxsO1xuICAgIHRoaXMuX2htdHhUYWJsZURhdGEgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGludGluZycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oaW50aW5nKSB7IHJldHVybiB0aGlzLl9oaW50aW5nOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lc0Zvcm1hdCA9PT0gJ3RydWV0eXBlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5faGludGluZyA9IG5ldyBIaW50aW5nKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmb250IGhhcyBhIGdseXBoIGZvciB0aGUgZ2l2ZW4gY2hhcmFjdGVyLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuRm9udC5wcm90b3R5cGUuaGFzQ2hhciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIGdseXBoSW5kZXggPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoYyk7XG4gICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gLm5vdGRlZlxuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGg7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBmZWF0dXJlc1xuICogQHBhcmFtIHthbnl9IG9wdGlvbnMgZmVhdHVyZXMgb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS51cGRhdGVGZWF0dXJlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIGFsbCBmZWF0dXJlcyBvcHRpb25zIG5vdCBvbmx5ICdsYXRuJy5cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUuc2NyaXB0ID09PSAnbGF0bicpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NyaXB0OiAnbGF0bicsXG4gICAgICAgICAgICAgICAgdGFnczogZmVhdHVyZS50YWdzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7IHJldHVybiBvcHRpb25zW3RhZ107IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbiAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIHZhciBiaWRpID0gbmV3IEJpZGkoKTtcblxuICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgJ2dseXBoSW5kZXgnIHN0YXRlIG1vZGlmaWVyXG4gICAgdmFyIGNoYXJUb0dseXBoSW5kZXhNb2QgPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRoaXMkMS5jaGFyVG9HbHlwaEluZGV4KHRva2VuLmNoYXIpOyB9O1xuICAgIGJpZGkucmVnaXN0ZXJNb2RpZmllcignZ2x5cGhJbmRleCcsIG51bGwsIGNoYXJUb0dseXBoSW5kZXhNb2QpO1xuXG4gICAgLy8gcm9sbC1iYWNrIHRvIGRlZmF1bHQgZmVhdHVyZXNcbiAgICB2YXIgZmVhdHVyZXMgPSBvcHRpb25zID9cbiAgICB0aGlzLnVwZGF0ZUZlYXR1cmVzKG9wdGlvbnMuZmVhdHVyZXMpIDpcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzO1xuXG4gICAgYmlkaS5hcHBseUZlYXR1cmVzKHRoaXMsIGZlYXR1cmVzKTtcblxuICAgIHZhciBpbmRleGVzID0gYmlkaS5nZXRUZXh0R2x5cGhzKHMpO1xuXG4gICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG4gICAgLy8gY29udmVydCBnbHlwaCBpbmRleGVzIHRvIGdseXBoIG9iamVjdHNcbiAgICB2YXIgZ2x5cGhzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgdmFyIG5vdGRlZiA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoc1tpXSA9IHRoaXMuZ2x5cGhzLmdldChpbmRleGVzW2ldKSB8fCBub3RkZWY7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Gb250LnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbiAqIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbiAqIGJldHdlZW4gZ2x5cGhzLlxuICogRm9yIEdQT1Mga2VybmluZywgdGhpcyBtZXRob2QgdXNlcyB0aGUgZGVmYXVsdCBzY3JpcHQgYW5kIGxhbmd1YWdlLCB3aGljaCBjb3ZlcnNcbiAqIG1vc3QgdXNlIGNhc2VzLiBUbyBoYXZlIGdyZWF0ZXIgY29udHJvbCwgdXNlIGZvbnQucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlIC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSBsZWZ0R2x5cGhcbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSByaWdodEdseXBoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgIGxlZnRHbHlwaCA9IGxlZnRHbHlwaC5pbmRleCB8fCBsZWZ0R2x5cGg7XG4gICAgcmlnaHRHbHlwaCA9IHJpZ2h0R2x5cGguaW5kZXggfHwgcmlnaHRHbHlwaDtcbiAgICB2YXIgZ3Bvc0tlcm5pbmcgPSB0aGlzLnBvc2l0aW9uLmRlZmF1bHRLZXJuaW5nVGFibGVzO1xuICAgIGlmIChncG9zS2VybmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoZ3Bvc0tlcm5pbmcsIGxlZnRHbHlwaCwgcmlnaHRHbHlwaCk7XG4gICAgfVxuICAgIC8vIFwia2VyblwiIHRhYmxlXG4gICAgcmV0dXJuIHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDA7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J10gLSBsYW5ndWFnZSBzeXN0ZW0gdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZmVhdHVyZXNdIC0gT3BlblR5cGUgTGF5b3V0IGZlYXR1cmUgdGFncy4gVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZmVhdHVyZXMgb2YgdGhlIGdpdmVuIHNjcmlwdC9sYW5ndWFnZSBzeXN0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuICovXG5Gb250LnByb3RvdHlwZS5kZWZhdWx0UmVuZGVyT3B0aW9ucyA9IHtcbiAgICBrZXJuaW5nOiB0cnVlLFxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVzZSA0IGZlYXR1cmVzIGFyZSByZXF1aXJlZCB0byByZW5kZXIgQXJhYmljIHRleHQgcHJvcGVybHlcbiAgICAgICAgICogYW5kIHNob3VsZG4ndCBiZSB0dXJuZWQgb2ZmIHdoZW4gcmVuZGVyaW5nIGFyYWJpYyB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgeyBzY3JpcHQ6ICdhcmFiJywgdGFnczogWydpbml0JywgJ21lZGknLCAnZmluYScsICdybGlnJ10gfSxcbiAgICAgICAgeyBzY3JpcHQ6ICdsYXRuJywgdGFnczogWydsaWdhJywgJ3JsaWcnXSB9XG4gICAgXVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gYXBwbHkuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Gb250LnByb3RvdHlwZS5mb3JFYWNoR2x5cGggPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHZhciBmb250U2NhbGUgPSAxIC8gdGhpcy51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgdmFyIGdseXBocyA9IHRoaXMuc3RyaW5nVG9HbHlwaHModGV4dCwgb3B0aW9ucyk7XG4gICAgdmFyIGtlcm5pbmdMb29rdXBzO1xuICAgIGlmIChvcHRpb25zLmtlcm5pbmcpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0IHx8IHRoaXMucG9zaXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICAgICAga2VybmluZ0xvb2t1cHMgPSB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhcHBseSBwb3NpdGlvbiBhZGp1c3RtZW50IGxvb2t1cHMgaW4gYSBtb3JlIGdlbmVyaWMgd2F5LlxuICAgICAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHVzZSB0aGUgeEFkdmFuY2UgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2VybmluZ1ZhbHVlID0ga2VybmluZ0xvb2t1cHMgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoa2VybmluZ0xvb2t1cHMsIGdseXBoLmluZGV4LCBnbHlwaHNbaSArIDFdLmluZGV4KSA6XG4gICAgICAgICAgICAgICAgICB0aGlzLmdldEtlcm5pbmdWYWx1ZShnbHlwaCwgZ2x5cGhzW2kgKyAxXSk7XG4gICAgICAgICAgICB4ICs9IGtlcm5pbmdWYWx1ZSAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHggKz0gb3B0aW9ucy5sZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50cmFja2luZykge1xuICAgICAgICAgICAgeCArPSAob3B0aW9ucy50cmFja2luZyAvIDEwMDApICogZm9udFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gdGV4dC5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiB7b3BlbnR5cGUuUGF0aH1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gbmV3IFBhdGgoKTtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgZnVsbFBhdGguZXh0ZW5kKGdseXBoUGF0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwaHMgb2YgYSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRoW119XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZ2x5cGhQYXRocyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICBnbHlwaFBhdGhzLnB1c2goZ2x5cGhQYXRoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBnbHlwaFBhdGhzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZHZhbmNlIHdpZHRoIG9mIGEgdGV4dC5cbiAqXG4gKiBUaGlzIGlzIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBQYXRoLmdldEJvdW5kaW5nQm94KCkgYXMgZm9yIGV4YW1wbGUgYVxuICogc3VmZml4ZWQgd2hpdGVzcGFjZSBpbmNyZWFzZXMgdGhlIGFkdmFuY2VXaWR0aCBidXQgbm90IHRoZSBib3VuZGluZyBib3hcbiAqIG9yIGFuIG92ZXJoYW5naW5nIGxldHRlciBsaWtlIGEgY2FsbGlncmFwaGljICdmJyBtaWdodCBoYXZlIGEgcXVpdGUgbGFyZ2VyXG4gKiBib3VuZGluZyBib3ggdGhhbiBpdHMgYWR2YW5jZSB3aWR0aC5cbiAqXG4gKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGNhbnZhczJkQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aFxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIGFkdmFuY2Ugd2lkdGhcbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0QWR2YW5jZVdpZHRoID0gZnVuY3Rpb24odGV4dCwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgMCwgMCwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKCkge30pO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSB0ZXh0IG9uIHRoZSBnaXZlbiBkcmF3aW5nIGNvbnRleHQuXG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwb2ludHMgb2YgYWxsIGdseXBocyBpbiB0aGUgdGV4dC5cbiAqIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd1BvaW50cyhjdHgsIGdYLCBnWSwgZ0ZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhdyBsaW5lcyBpbmRpY2F0aW5nIGltcG9ydGFudCBmb250IG1lYXN1cmVtZW50cyBmb3IgYWxsIGdseXBocyBpbiB0aGUgdGV4dC5cbiAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuICogQmx1ZSBsaW5lcyBpbmRpY2F0ZSB0aGUgZ2x5cGggYm91bmRpbmcgYm94LlxuICogR3JlZW4gbGluZSBpbmRpY2F0ZXMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgdGhlIGdseXBoLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0ge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUuZHJhd01ldHJpY3MgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3TWV0cmljcyhjdHgsIGdYLCBnWSwgZ0ZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRFbmdsaXNoTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJhbnNsYXRpb25zID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbnMuZW47XG4gICAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZVxuICovXG5Gb250LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0TmFtZVByZXNlbnQobmFtZSkge1xuICAgICAgICB2YXIgZW5nbGlzaE5hbWUgPSBfdGhpcy5nZXRFbmdsaXNoTmFtZShuYW1lKTtcbiAgICAgICAgYXNzZXJ0KGVuZ2xpc2hOYW1lICYmIGVuZ2xpc2hOYW1lLnRyaW0oKS5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydE5hbWVQcmVzZW50KCdmb250RmFtaWx5Jyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3dlaWdodE5hbWUnKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnbWFudWZhY3R1cmVyJyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2NvcHlyaWdodCcpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCd2ZXJzaW9uJyk7XG5cbiAgICAvLyBEaW1lbnNpb24gaW5mb3JtYXRpb25cbiAgICBhc3NlcnQodGhpcy51bml0c1BlckVtID4gMCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbiAqIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuICogQHJldHVybiB7b3BlbnR5cGUuVGFibGV9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC5cbiAqL1xuRm9udC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYG9wZW50eXBlLkZvbnRgIGludG8gYW4gYEFycmF5QnVmZmVyYFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbiAqL1xuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuICAgIHZhciBmYW1pbHlOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuICAgIHZhciBzdHlsZU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250U3ViZmFtaWx5Jyk7XG4gICAgZmlsZU5hbWUgPSBmaWxlTmFtZSB8fCBmYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBzdHlsZU5hbWUgKyAnLm90Zic7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgd2luZG93LlVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxuICAgICAgICBpZiAod2luZG93LlVSTCkge1xuICAgICAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSwge3R5cGU6ICdmb250L29wZW50eXBlJ30pO1xuXG4gICAgICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBsaW5rLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb250IGZpbGUgY291bGQgbm90IGJlIGRvd25sb2FkZWQuIFRyeSB1c2luZyBhIGRpZmZlcmVudCBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGFycmF5QnVmZmVyVG9Ob2RlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgYnVmZmVyKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS5mc1NlbGVjdGlvblZhbHVlcyA9IHtcbiAgICBJVEFMSUM6ICAgICAgICAgICAgICAweDAwMSwgLy8xXG4gICAgVU5ERVJTQ09SRTogICAgICAgICAgMHgwMDIsIC8vMlxuICAgIE5FR0FUSVZFOiAgICAgICAgICAgIDB4MDA0LCAvLzRcbiAgICBPVVRMSU5FRDogICAgICAgICAgICAweDAwOCwgLy84XG4gICAgU1RSSUtFT1VUOiAgICAgICAgICAgMHgwMTAsIC8vMTZcbiAgICBCT0xEOiAgICAgICAgICAgICAgICAweDAyMCwgLy8zMlxuICAgIFJFR1VMQVI6ICAgICAgICAgICAgIDB4MDQwLCAvLzY0XG4gICAgVVNFUl9UWVBPX01FVFJJQ1M6ICAgMHgwODAsIC8vMTI4XG4gICAgV1dTOiAgICAgICAgICAgICAgICAgMHgxMDAsIC8vMjU2XG4gICAgT0JMSVFVRTogICAgICAgICAgICAgMHgyMDAgIC8vNTEyXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0ge1xuICAgIFVMVFJBX0NPTkRFTlNFRDogMSxcbiAgICBFWFRSQV9DT05ERU5TRUQ6IDIsXG4gICAgQ09OREVOU0VEOiAzLFxuICAgIFNFTUlfQ09OREVOU0VEOiA0LFxuICAgIE1FRElVTTogNSxcbiAgICBTRU1JX0VYUEFOREVEOiA2LFxuICAgIEVYUEFOREVEOiA3LFxuICAgIEVYVFJBX0VYUEFOREVEOiA4LFxuICAgIFVMVFJBX0VYUEFOREVEOiA5XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2VpZ2h0Q2xhc3NlcyA9IHtcbiAgICBUSElOOiAxMDAsXG4gICAgRVhUUkFfTElHSFQ6IDIwMCxcbiAgICBMSUdIVDogMzAwLFxuICAgIE5PUk1BTDogNDAwLFxuICAgIE1FRElVTTogNTAwLFxuICAgIFNFTUlfQk9MRDogNjAwLFxuICAgIEJPTEQ6IDcwMCxcbiAgICBFWFRSQV9CT0xEOiA4MDAsXG4gICAgQkxBQ0s6ICAgIDkwMFxufTtcblxuLy8gVGhlIGBmdmFyYCB0YWJsZSBzdG9yZXMgZm9udCB2YXJpYXRpb24gYXhlcyBhbmQgaW5zdGFuY2VzLlxuXG5mdW5jdGlvbiBhZGROYW1lKG5hbWUsIG5hbWVzKSB7XG4gICAgdmFyIG5hbWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICB2YXIgbmFtZUlEID0gMjU2O1xuICAgIGZvciAodmFyIG5hbWVLZXkgaW4gbmFtZXMpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChuYW1lS2V5KTtcbiAgICAgICAgaWYgKCFuIHx8IG4gPCAyNTYpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KG5hbWVzW25hbWVLZXldKSA9PT0gbmFtZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZUlEIDw9IG4pIHtcbiAgICAgICAgICAgIG5hbWVJRCA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmFtZXNbbmFtZUlEXSA9IG5hbWU7XG4gICAgcmV0dXJuIG5hbWVJRDtcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJBeGlzKG4sIGF4aXMsIG5hbWVzKSB7XG4gICAgdmFyIG5hbWVJRCA9IGFkZE5hbWUoYXhpcy5uYW1lLCBuYW1lcyk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge25hbWU6ICd0YWdfJyArIG4sIHR5cGU6ICdUQUcnLCB2YWx1ZTogYXhpcy50YWd9LFxuICAgICAgICB7bmFtZTogJ21pblZhbHVlXycgKyBuLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogYXhpcy5taW5WYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnZGVmYXVsdFZhbHVlXycgKyBuLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogYXhpcy5kZWZhdWx0VmFsdWUgPDwgMTZ9LFxuICAgICAgICB7bmFtZTogJ21heFZhbHVlXycgKyBuLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogYXhpcy5tYXhWYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3NfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVJRH1cbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJBeGlzKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBheGlzID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBheGlzLnRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICBheGlzLm1pblZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgYXhpcy5kZWZhdWx0VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLm1heFZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgIC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcbiAgICBheGlzLm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuICAgIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhckluc3RhbmNlKG4sIGluc3QsIGF4ZXMsIG5hbWVzKSB7XG4gICAgdmFyIG5hbWVJRCA9IGFkZE5hbWUoaW5zdC5uYW1lLCBuYW1lcyk7XG4gICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdmbGFnc18nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGF4aXNUYWcgPSBheGVzW2ldLnRhZztcbiAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogJ2F4aXNfJyArIG4gKyAnICcgKyBheGlzVGFnLFxuICAgICAgICAgICAgdHlwZTogJ0ZJWEVEJyxcbiAgICAgICAgICAgIHZhbHVlOiBpbnN0LmNvb3JkaW5hdGVzW2F4aXNUYWddIDw8IDE2XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckluc3RhbmNlKGRhdGEsIHN0YXJ0LCBheGVzLCBuYW1lcykge1xuICAgIHZhciBpbnN0ID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBpbnN0Lm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuICAgIHAuc2tpcCgndVNob3J0JywgMSk7ICAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG5cbiAgICBpbnN0LmNvb3JkaW5hdGVzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGluc3QuY29vcmRpbmF0ZXNbYXhlc1tpXS50YWddID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VGdmFyVGFibGUoZnZhciwgbmFtZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdmdmFyJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0VG9EYXRhJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudFNpemVQYWlycycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnYXhpc0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmdmFyLmF4ZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdheGlzU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMjB9LFxuICAgICAgICB7bmFtZTogJ2luc3RhbmNlQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZ2YXIuaW5zdGFuY2VzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnaW5zdGFuY2VTaXplJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0ICsgZnZhci5heGVzLmxlbmd0aCAqIDR9XG4gICAgXSk7XG4gICAgcmVzdWx0Lm9mZnNldFRvRGF0YSA9IHJlc3VsdC5zaXplT2YoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnZhci5heGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5maWVsZHMgPSByZXN1bHQuZmllbGRzLmNvbmNhdChtYWtlRnZhckF4aXMoaSwgZnZhci5heGVzW2ldLCBuYW1lcykpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnZhci5pbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFySW5zdGFuY2UoaiwgZnZhci5pbnN0YW5jZXNbal0sIGZ2YXIuYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJUYWJsZShkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDB4MDAwMTAwMDAsICdVbnN1cHBvcnRlZCBmdmFyIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgdmFyIG9mZnNldFRvRGF0YSA9IHAucGFyc2VPZmZzZXQxNigpO1xuICAgIC8vIFNraXAgY291bnRTaXplUGFpcnMuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTtcbiAgICB2YXIgYXhpc0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBheGlzU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgaW5zdGFuY2VDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgaW5zdGFuY2VTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgdmFyIGF4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNDb3VudDsgaSsrKSB7XG4gICAgICAgIGF4ZXMucHVzaChwYXJzZUZ2YXJBeGlzKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0VG9EYXRhICsgaSAqIGF4aXNTaXplLCBuYW1lcykpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICB2YXIgaW5zdGFuY2VTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0VG9EYXRhICsgYXhpc0NvdW50ICogYXhpc1NpemU7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnN0YW5jZUNvdW50OyBqKyspIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2gocGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgaW5zdGFuY2VTdGFydCArIGogKiBpbnN0YW5jZVNpemUsIGF4ZXMsIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtheGVzOiBheGVzLCBpbnN0YW5jZXM6IGluc3RhbmNlc307XG59XG5cbnZhciBmdmFyID0geyBtYWtlOiBtYWtlRnZhclRhYmxlLCBwYXJzZTogcGFyc2VGdmFyVGFibGUgfTtcblxuLy8gVGhlIGBHREVGYCB0YWJsZSBjb250YWlucyB2YXJpb3VzIGdseXBoIHByb3BlcnRpZXNcblxudmFyIGF0dGFjaExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYXR0YWNoUG9pbnRzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIudVNob3J0TGlzdCkpXG4gICAgfTtcbn07XG5cbnZhciBjYXJldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDEgfHwgZm9ybWF0ID09PSAyIHx8IGZvcm1hdCA9PT0gMyxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIENhcmV0VmFsdWUgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGU6IHRoaXMucGFyc2VTaG9ydCgpIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgcG9pbnRpbmRleDogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuICAgICAgICAvLyBEZXZpY2UgLyBWYXJpYXRpb24gSW5kZXggdGFibGVzIHVuc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGU6IHRoaXMucGFyc2VTaG9ydCgpIH07XG4gICAgfVxufTtcblxudmFyIGxpZ0dseXBoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGNhcmV0VmFsdWUpKTtcbn07XG5cbnZhciBsaWdDYXJldExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgbGlnR2x5cGhzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihsaWdHbHlwaCkpXG4gICAgfTtcbn07XG5cbnZhciBtYXJrR2x5cGhTZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXJzZVVTaG9ydCgpOyAvLyBWZXJzaW9uXG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpO1xufTtcblxuZnVuY3Rpb24gcGFyc2VHREVGVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4yIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4zLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgR0RFRiB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIHZhciBnZGVmID0ge1xuICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgIGNsYXNzRGVmOiBwLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICBhdHRhY2hMaXN0OiBwLnBhcnNlUG9pbnRlcihhdHRhY2hMaXN0KSxcbiAgICAgICAgbGlnQ2FyZXRMaXN0OiBwLnBhcnNlUG9pbnRlcihsaWdDYXJldExpc3QpLFxuICAgICAgICBtYXJrQXR0YWNoQ2xhc3NEZWY6IHAucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZilcbiAgICB9O1xuICAgIGlmICh0YWJsZVZlcnNpb24gPj0gMS4yKSB7XG4gICAgICAgIGdkZWYubWFya0dseXBoU2V0cyA9IHAucGFyc2VQb2ludGVyKG1hcmtHbHlwaFNldHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2RlZjtcbn1cbnZhciBnZGVmID0geyBwYXJzZTogcGFyc2VHREVGVGFibGUgfTtcblxuLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbnZhciBzdWJ0YWJsZVBhcnNlcnMkMSA9IG5ldyBBcnJheSgxMCk7ICAgICAgICAgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0xLXNpbmdsZS1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG4vLyB0aGlzID0gUGFyc2VyIGluc3RhbmNlXG5zdWJ0YWJsZVBhcnNlcnMkMVsxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc2Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAocG9zZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy5wYXJzZVZhbHVlUmVjb3JkTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IEdQT1MgbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0yLXBhaXItYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuc3VidGFibGVQYXJzZXJzJDFbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBwb3NGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXNzZXJ0KHBvc0Zvcm1hdCA9PT0gMSB8fCBwb3NGb3JtYXQgPT09IDIsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBHUE9TIGxvb2t1cCB0eXBlIDIgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuICAgIHZhciBjb3ZlcmFnZSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSk7XG4gICAgdmFyIHZhbHVlRm9ybWF0MSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVGb3JtYXQyID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChwb3NGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gQWRqdXN0bWVudHMgZm9yIEdseXBoIFBhaXJzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG4gICAgICAgICAgICBwYWlyU2V0czogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmxpc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgICAgICAgIC8vIHBhaXJWYWx1ZVJlY29yZFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDEpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBvc0Zvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgY2xhc3NEZWYxID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgdmFyIGNsYXNzRGVmMiA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG4gICAgICAgIHZhciBjbGFzczFDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzMkNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gQ2xhc3MgUGFpciBBZGp1c3RtZW50XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG4gICAgICAgICAgICBjbGFzc0RlZjE6IGNsYXNzRGVmMSxcbiAgICAgICAgICAgIGNsYXNzRGVmMjogY2xhc3NEZWYyLFxuICAgICAgICAgICAgY2xhc3MxQ291bnQ6IGNsYXNzMUNvdW50LFxuICAgICAgICAgICAgY2xhc3MyQ291bnQ6IGNsYXNzMkNvdW50LFxuICAgICAgICAgICAgY2xhc3NSZWNvcmRzOiB0aGlzLnBhcnNlTGlzdChjbGFzczFDb3VudCwgUGFyc2VyLmxpc3QoY2xhc3MyQ291bnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuc3VidGFibGVQYXJzZXJzJDFbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNCBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNyBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOCBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbOV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDkoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3Bvc1xuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uICcgKyB0YWJsZVZlcnNpb24pO1xuXG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbi8vIEdQT1MgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBOT1QgU1VQUE9SVEVEXG52YXIgc3VidGFibGVNYWtlcnMkMSA9IG5ldyBBcnJheSgxMCk7XG5cbmZ1bmN0aW9uIG1ha2VHcG9zVGFibGUoZ3Bvcykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ0dQT1MnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdwb3Muc2NyaXB0cyl9LFxuICAgICAgICB7bmFtZTogJ2ZlYXR1cmVzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5GZWF0dXJlTGlzdChncG9zLmZlYXR1cmVzKX0sXG4gICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChncG9zLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzJDEpfVxuICAgIF0pO1xufVxuXG52YXIgZ3BvcyA9IHsgcGFyc2U6IHBhcnNlR3Bvc1RhYmxlLCBtYWtlOiBtYWtlR3Bvc1RhYmxlIH07XG5cbi8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJ0YWJsZUxlbmd0aCwgc3VidGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFRoZSBNYWMga2VybiB0YWJsZSBzdG9yZXMgdGhlIHZlcnNpb24gYXMgYSBmaXhlZCAoMzIgYml0cykgYnV0IHdlIG9ubHkgbG9hZGVkIHRoZSBmaXJzdCAxNiBiaXRzLlxuICAgIC8vIFNraXAgdGhlIHJlc3QuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgblRhYmxlcyA9IHAucGFyc2VVTG9uZygpO1xuICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuICAgIGlmIChuVGFibGVzID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgdGhlIGZpcnN0IGtlcm4gc3VidGFibGUgaXMgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBwLnNraXAoJ3VMb25nJyk7XG4gICAgdmFyIGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICBpZiAoc3VidGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcbiAgICB9XG59XG5cbnZhciBrZXJuID0geyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcblxuLy8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBwYXJzZUZuID0gc2hvcnRWZXJzaW9uID8gcC5wYXJzZVVTaG9ydCA6IHAucGFyc2VVTG9uZztcbiAgICAvLyBUaGVyZSBpcyBhbiBleHRyYSBlbnRyeSBhZnRlciB0aGUgbGFzdCBpbmRleCBlbGVtZW50IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgbGFzdCBnbHlwaC5cbiAgICAvLyBUaGF0J3Mgd2h5IHdlIHVzZSBudW1HbHlwaHMgKyAxLlxuICAgIHZhciBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBocyArIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhPZmZzZXQgPSBwYXJzZUZuLmNhbGwocCk7XG4gICAgICAgIGlmIChzaG9ydFZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaG9ydCB0YWJsZSB2ZXJzaW9uIHN0b3JlcyB0aGUgYWN0dWFsIG9mZnNldCBkaXZpZGVkIGJ5IDIuXG4gICAgICAgICAgICBnbHlwaE9mZnNldCAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhPZmZzZXRzLnB1c2goZ2x5cGhPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbnZhciBsb2NhID0geyBwYXJzZTogcGFyc2VMb2NhVGFibGUgfTtcblxuLy8gb3BlbnR5cGUuanNcblxuLyoqXG4gKiBUaGUgb3BlbnR5cGUgbGlicmFyeS5cbiAqIEBuYW1lc3BhY2Ugb3BlbnR5cGVcbiAqL1xuXG4vLyBGaWxlIGxvYWRlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIExvYWRzIGEgZm9udCBmcm9tIGEgZmlsZS4gVGhlIGNhbGxiYWNrIHRocm93cyBhbiBlcnJvciBtZXNzYWdlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaWYgaXQgZmFpbHNcbiAqIGFuZCB0aGUgZm9udCBhcyBhbiBBcnJheUJ1ZmZlciBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpZiBpdCBzdWNjZWVkcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRGcm9tRmlsZShwYXRoLCBjYWxsYmFjaykge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBidWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBMb2FkcyBhIGZvbnQgZnJvbSBhIFVSTC4gVGhlIGNhbGxiYWNrIHRocm93cyBhbiBlcnJvciBtZXNzYWdlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaWYgaXQgZmFpbHNcbiAqIGFuZCB0aGUgZm9udCBhcyBhbiBBcnJheUJ1ZmZlciBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpZiBpdCBzdWNjZWVkcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCBmaWxlLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9udCBsb2FkIGNvbXBsZXRlc1xuICovXG5mdW5jdGlvbiBsb2FkRnJvbVVybCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZDogJyArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygnRm9udCBjb3VsZCBub3QgYmUgbG9hZGVkJyk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xufVxuXG4vLyBUYWJsZSBEaXJlY3RvcnkgRW50cmllcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIFBhcnNlcyBPcGVuVHlwZSB0YWJsZSBlbnRyaWVzLlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHAgPSAxMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgY2hlY2tzdW06IGNoZWNrc3VtLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGgsIGNvbXByZXNzaW9uOiBmYWxzZX0pO1xuICAgICAgICBwICs9IDE2O1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogUGFyc2VzIFdPRkYgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHAgPSA0NDsgLy8gb2Zmc2V0IHRvIHRoZSBmaXJzdCB0YWJsZSBkaXJlY3RvcnkgZW50cnkuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICB2YXIgY29tcExlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgdmFyIG9yaWdMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKGNvbXBMZW5ndGggPCBvcmlnTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9ICdXT0ZGJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7dGFnOiB0YWcsIG9mZnNldDogb2Zmc2V0LCBjb21wcmVzc2lvbjogY29tcHJlc3Npb24sXG4gICAgICAgICAgICBjb21wcmVzc2VkTGVuZ3RoOiBjb21wTGVuZ3RoLCBsZW5ndGg6IG9yaWdMZW5ndGh9KTtcbiAgICAgICAgcCArPSAyMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFRhYmxlRGF0YVxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0RhdGFWaWV3fSBkYXRhIC0gVGhlIERhdGFWaWV3XG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IC0gVGhlIGRhdGEgb2Zmc2V0LlxuICovXG5cbi8qKlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtUYWJsZURhdGF9XG4gKi9cbmZ1bmN0aW9uIHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KSB7XG4gICAgaWYgKHRhYmxlRW50cnkuY29tcHJlc3Npb24gPT09ICdXT0ZGJykge1xuICAgICAgICB2YXIgaW5CdWZmZXIgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgdGFibGVFbnRyeS5vZmZzZXQgKyAyLCB0YWJsZUVudHJ5LmNvbXByZXNzZWRMZW5ndGggLSAyKTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgdGlueUluZmxhdGUoaW5CdWZmZXIsIG91dEJ1ZmZlcik7XG4gICAgICAgIGlmIChvdXRCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gdGFibGVFbnRyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb21wcmVzc2lvbiBlcnJvcjogJyArIHRhYmxlRW50cnkudGFnICsgJyBkZWNvbXByZXNzZWQgbGVuZ3RoIGRvZXNuXFwndCBtYXRjaCByZWNvcmRlZCBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIsIDApO1xuICAgICAgICByZXR1cm4ge2RhdGE6IHZpZXcsIG9mZnNldDogMH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtkYXRhOiBkYXRhLCBvZmZzZXQ6IHRhYmxlRW50cnkub2Zmc2V0fTtcbiAgICB9XG59XG5cbi8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBQYXJzZSB0aGUgT3BlblR5cGUgZmlsZSBkYXRhIChhcyBhbiBBcnJheUJ1ZmZlcikgYW5kIHJldHVybiBhIEZvbnQgb2JqZWN0LlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmb250IGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn1cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0IC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyLCBvcHQpIHtcbiAgICBvcHQgPSAob3B0ID09PSB1bmRlZmluZWQgfHwgb3B0ID09PSBudWxsKSA/ICB7fSA6IG9wdDtcblxuICAgIHZhciBpbmRleFRvTG9jRm9ybWF0O1xuICAgIHZhciBsdGFnVGFibGU7XG5cbiAgICAvLyBTaW5jZSB0aGUgY29uc3RydWN0b3IgY2FuIGFsc28gYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgZm9udHMgZnJvbSBzY3JhdGNoLCB3ZSBpbmRpY2F0ZSB0aGlzXG4gICAgLy8gc2hvdWxkIGJlIGFuIGVtcHR5IGZvbnQgdGhhdCB3ZSdsbCBmaWxsIHdpdGggb3VyIG93biBkYXRhLlxuICAgIHZhciBmb250ID0gbmV3IEZvbnQoe2VtcHR5OiB0cnVlfSk7XG5cbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cbiAgICB2YXIgZGF0YSA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDApO1xuICAgIHZhciBudW1UYWJsZXM7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBzaWduYXR1cmUgPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgaWYgKHNpZ25hdHVyZSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSB8fCBzaWduYXR1cmUgPT09ICd0cnVlJyB8fCBzaWduYXR1cmUgPT09ICd0eXAxJykge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICdPVFRPJykge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnd09GRicpIHtcbiAgICAgICAgdmFyIGZsYXZvciA9IHBhcnNlLmdldFRhZyhkYXRhLCA0KTtcbiAgICAgICAgaWYgKGZsYXZvciA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSkge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhdm9yID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgZmxhdm9yICcgKyBzaWduYXR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBzaWduYXR1cmUgJyArIHNpZ25hdHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGNmZlRhYmxlRW50cnk7XG4gICAgdmFyIGZ2YXJUYWJsZUVudHJ5O1xuICAgIHZhciBnbHlmVGFibGVFbnRyeTtcbiAgICB2YXIgZ2RlZlRhYmxlRW50cnk7XG4gICAgdmFyIGdwb3NUYWJsZUVudHJ5O1xuICAgIHZhciBnc3ViVGFibGVFbnRyeTtcbiAgICB2YXIgaG10eFRhYmxlRW50cnk7XG4gICAgdmFyIGtlcm5UYWJsZUVudHJ5O1xuICAgIHZhciBsb2NhVGFibGVFbnRyeTtcbiAgICB2YXIgbmFtZVRhYmxlRW50cnk7XG4gICAgdmFyIG1ldGFUYWJsZUVudHJ5O1xuICAgIHZhciBwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFibGVFbnRyeSA9IHRhYmxlRW50cmllc1tpXTtcbiAgICAgICAgdmFyIHRhYmxlID0gKHZvaWQgMCk7XG4gICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NtYXAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBDbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjdnQgJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jdnQgPSBwLnBhcnNlU2hvcnRMaXN0KHRhYmxlRW50cnkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdmFyJzpcbiAgICAgICAgICAgICAgICBmdmFyVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmcGdtJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5mcGdtID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhlYWQgPSBoZWFkLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC51bml0c1BlckVtID0gZm9udC50YWJsZXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoaGVhJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuYXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmFzY2VuZGVyO1xuICAgICAgICAgICAgICAgIGZvbnQuZGVzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG10eCc6XG4gICAgICAgICAgICAgICAgaG10eFRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbHRhZyc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgbHRhZ1RhYmxlID0gbHRhZy5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWF4cCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMubWF4cCA9IG1heHAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICAgICAgbmFtZVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnT1MvMic6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMub3MyID0gb3MyLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb3N0JzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wb3N0ID0gcG9zdC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBHbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMucHJlcCA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnbHlmJzpcbiAgICAgICAgICAgICAgICBnbHlmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgICAgICBsb2NhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgICAgICBjZmZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tlcm4nOlxuICAgICAgICAgICAgICAgIGtlcm5UYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dERUYnOlxuICAgICAgICAgICAgICAgIGdkZWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgICAgIGdwb3NUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dTVUInOlxuICAgICAgICAgICAgICAgIGdzdWJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgIG1ldGFUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYW1lVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbmFtZVRhYmxlRW50cnkpO1xuICAgIGZvbnQudGFibGVzLm5hbWUgPSBfbmFtZS5wYXJzZShuYW1lVGFibGUuZGF0YSwgbmFtZVRhYmxlLm9mZnNldCwgbHRhZ1RhYmxlKTtcbiAgICBmb250Lm5hbWVzID0gZm9udC50YWJsZXMubmFtZTtcblxuICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgdmFyIGxvY2FUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBsb2NhVGFibGVFbnRyeSk7XG4gICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UobG9jYVRhYmxlLmRhdGEsIGxvY2FUYWJsZS5vZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuICAgICAgICB2YXIgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGdseWZUYWJsZS5kYXRhLCBnbHlmVGFibGUub2Zmc2V0LCBsb2NhT2Zmc2V0cywgZm9udCwgb3B0KTtcbiAgICB9IGVsc2UgaWYgKGNmZlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGNmZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGNmZlRhYmxlRW50cnkpO1xuICAgICAgICBjZmYucGFyc2UoY2ZmVGFibGUuZGF0YSwgY2ZmVGFibGUub2Zmc2V0LCBmb250LCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9udCBkb2VzblxcJ3QgY29udGFpbiBUcnVlVHlwZSBvciBDRkYgb3V0bGluZXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBobXR4VGFibGVFbnRyeSk7XG4gICAgaG10eC5wYXJzZShmb250LCBobXR4VGFibGUuZGF0YSwgaG10eFRhYmxlLm9mZnNldCwgZm9udC5udW1iZXJPZkhNZXRyaWNzLCBmb250Lm51bUdseXBocywgZm9udC5nbHlwaHMsIG9wdCk7XG4gICAgYWRkR2x5cGhOYW1lcyhmb250LCBvcHQpO1xuXG4gICAgaWYgKGtlcm5UYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBrZXJuVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwga2VyblRhYmxlRW50cnkpO1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IGtlcm4ucGFyc2Uoa2VyblRhYmxlLmRhdGEsIGtlcm5UYWJsZS5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGdkZWZUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBnZGVmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2RlZlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5nZGVmID0gZ2RlZi5wYXJzZShnZGVmVGFibGUuZGF0YSwgZ2RlZlRhYmxlLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGdwb3NUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBncG9zVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3Bvc1RhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5ncG9zID0gZ3Bvcy5wYXJzZShncG9zVGFibGUuZGF0YSwgZ3Bvc1RhYmxlLm9mZnNldCk7XG4gICAgICAgIGZvbnQucG9zaXRpb24uaW5pdCgpO1xuICAgIH1cblxuICAgIGlmIChnc3ViVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3N1YlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdzdWJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3N1YiA9IGdzdWIucGFyc2UoZ3N1YlRhYmxlLmRhdGEsIGdzdWJUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChmdmFyVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZnZhclRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGZ2YXJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZnZhciA9IGZ2YXIucGFyc2UoZnZhclRhYmxlLmRhdGEsIGZ2YXJUYWJsZS5vZmZzZXQsIGZvbnQubmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChtZXRhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgbWV0YVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG1ldGFUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMubWV0YSA9IG1ldGEucGFyc2UobWV0YVRhYmxlLmRhdGEsIG1ldGFUYWJsZS5vZmZzZXQpO1xuICAgICAgICBmb250Lm1ldGFzID0gZm9udC50YWJsZXMubWV0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBsb2FkIHRoZSBmb250IGZyb20gYSBVUkwgb3IgYSBmaWxlc3lzdGVtLiBXaGVuIGRvbmUsIGNhbGwgdGhlIGNhbGxiYWNrXG4gKiB3aXRoIHR3byBhcmd1bWVudHMgYChlcnIsIGZvbnQpYC4gVGhlIGBlcnJgIHdpbGwgYmUgbnVsbCBvbiBzdWNjZXNzLFxuICogdGhlIGBmb250YCBpcyBhIEZvbnQgb2JqZWN0LlxuICogV2UgdXNlIHRoZSBub2RlLmpzIGNhbGxiYWNrIGNvbnZlbnRpb24gc28gdGhhdFxuICogb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cbiAqIEBhbGlhcyBvcGVudHlwZS5sb2FkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZvbnQgdG8gbG9hZC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrLCBvcHQpIHtcbiAgICBvcHQgPSAob3B0ID09PSB1bmRlZmluZWQgfHwgb3B0ID09PSBudWxsKSA/ICB7fSA6IG9wdDtcbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGxvYWRGbiA9IGlzTm9kZSAmJiAhb3B0LmlzVXJsID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsb2FkRm4odXJsLCBmdW5jdGlvbihlcnIsIGFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb250O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb250ID0gcGFyc2VCdWZmZXIoYXJyYXlCdWZmZXIsIG9wdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZvbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZvbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBmaWxlLlxuICogV2hlbiBkb25lLCByZXR1cm5zIHRoZSBmb250IG9iamVjdCBvciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAYWxpYXMgb3BlbnR5cGUubG9hZFN5bmNcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHQgLSBvcHQubG93TWVtb3J5XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBsb2FkU3luYyh1cmwsIG9wdCkge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgdmFyIGJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYyh1cmwpO1xuICAgIHJldHVybiBwYXJzZUJ1ZmZlcihub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpLCBvcHQpO1xufVxuXG52YXIgb3BlbnR5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Rm9udDogRm9udCxcblx0R2x5cGg6IEdseXBoLFxuXHRQYXRoOiBQYXRoLFxuXHRCb3VuZGluZ0JveDogQm91bmRpbmdCb3gsXG5cdF9wYXJzZTogcGFyc2UsXG5cdHBhcnNlOiBwYXJzZUJ1ZmZlcixcblx0bG9hZDogbG9hZCxcblx0bG9hZFN5bmM6IGxvYWRTeW5jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgb3BlbnR5cGU7XG5leHBvcnQgeyBCb3VuZGluZ0JveCwgRm9udCwgR2x5cGgsIFBhdGgsIHBhcnNlIGFzIF9wYXJzZSwgbG9hZCwgbG9hZFN5bmMsIHBhcnNlQnVmZmVyIGFzIHBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVudHlwZS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/opentype.js/dist/opentype.module.js\n"));

/***/ }),

/***/ "?3514":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* (ignored) */

/***/ })

}]);